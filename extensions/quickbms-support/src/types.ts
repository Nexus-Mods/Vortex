import Promise from "bluebird";

export class QuickBMSError extends Error {
  private mErrorLines: string;
  constructor(message: string, stdErrLines: string[]) {
    super(message);
    this.name = "QuickBMSError";

    // We probably only care for the last ~40 lines which will
    //  generally contain some sort of clue as to what actually happened.
    //  stdErr output from QBMS can be hundreds if not thousands of lines
    //  long (depending on how many mods the user had installed) which
    //  can cause the array to get truncated "<long array cut>"
    const filtered = this.trimContact(stdErrLines);
    this.mErrorLines =
      filtered.length > 40
        ? filtered.slice(filtered.length - 40).join("\n")
        : filtered.join("\n");
  }

  public get errorLines(): string {
    return this.mErrorLines;
  }

  private trimContact(stdErrLines: string[]): string[] {
    // This function intends to trim error lines containing
    //  Luigi's contact details when an error occurrs - this is not
    //  to remove attribution, but rather to try and limit the amount
    //  of spam Luigi might be getting from our users.
    // @Luigi, if for whatever reason you like the spam and wish us to
    //  re-instate this information - let us know.
    // The attribution dashlet will remain in place, crediting QBMS's
    //  creator, Luigi Auriemma.
    return stdErrLines.filter((line, idx) =>
      idx > 10 ? true : !line.toLowerCase().includes("luigi"),
    );
  }
}

export class UnregisteredGameError extends Error {
  constructor(gameMode: string) {
    super(`${gameMode} is not a qbms registered game`);
  }
}

export type QBMSOperationType = "extract" | "reimport" | "write" | "list";

export interface IQBMSOptions {
  // qbms will overwrite any existing files during extraction.
  overwrite?: boolean;

  // qbms verbose mode
  verbose?: boolean;

  // do we want qbms to log all of its operations
  createLog?: boolean;

  // qbms is case _in_sensitive by default
  caseSensitive?: boolean;

  // minimal information output during qbms operations (some output may still be generated)
  quiet?: boolean;

  // By default qbms will delete any temporary files generated by the .bms scripts
  //  it executes. This option ensures that qbms does not remove those automatically.
  keepTemporaryFiles?: boolean;

  // The allow resize paremeter controls QBMS's reimport process which attempts
  // to replace files within a game's archive. When set to true it will use "reimport2"
  //  and the regular "reimport" when set to false.
  //  qbms offers two reimport types, "reimport" and "reimport2";
  //  - When using the default "reimport" type it's important to ensure that
  //    the files you're using as replacements are not larger than the original files!!
  //  - Use "reimport2" if the replacement files are larger than the original files but be
  //    wary that this may be a _one_ time reimport as it may throw off any existing
  //    BMS scripts because size/offset would have changed.
  allowResize?: boolean;

  // file wildcards: both {} and * are valid, although {} is less error prone.
  wildCards?: string[];
}

export interface IListEntry {
  offset: string;
  size: string;
  filePath: string;
}

export interface IQBMSOpProps {
  // The Nexus Mods domain name for the game
  //  in question.
  gameMode: string;

  // Absolute path to the BMS script to be used
  //  for this QBMS operation.
  bmsScriptPath: string;

  // Absolute path to the affected archive
  archivePath: string;

  // Vortex will not inform the user of successful or failed QBMS operations.
  //  The generated error will still be forwarded to the calling extension, thus
  //  transferring all error handling responsibilities to the extension itself.
  // Note that this property will not affect QBMS's own verbosity!
  quiet?: boolean;

  // QBMS specific options.
  qbmsOptions?: IQBMSOptions;

  // The operation path has different uses depending
  //  on the QBMS operation we're using. e.g. qbmsExtract
  //  will extract the contents of an archive to operationPath
  //  while reimport will attempt to insert the contents of
  //  operationPath to the archive.
  operationPath?: string;

  // Extension specific attachments; should only be populated
  //  by officially supported game extensions.
  additionalAttachments?: () => Promise<IAttachmentData[]>;

  // Callback functor called once QBMS finishes its operations.
  callback?: (err: Error, data: any) => void;
}

export interface IAttachmentData {
  filePath: string;
  description: string;
}
