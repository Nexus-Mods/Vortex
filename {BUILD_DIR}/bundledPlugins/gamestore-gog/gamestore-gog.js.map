{"version":3,"file":"index.js","mappings":";;;;;;;;;;AAAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,0BAAU;AAClC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,wCAAiB;AACxC,qBAAqB,mBAAO,CAAC,8BAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,oBAAoB;AACrF;AACA;AACA;AACA;AACA,6DAA6D,4CAA4C;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD,qCAAqC,mBAAmB;AACxD;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe","sources":["webpack://gamestore-gog/external commonjs2 \"bluebird\"","webpack://gamestore-gog/external commonjs2 \"path\"","webpack://gamestore-gog/external commonjs2 \"vortex-api\"","webpack://gamestore-gog/external commonjs2 \"winapi-bindings\"","webpack://gamestore-gog/webpack/bootstrap","webpack://gamestore-gog/./src/index.ts"],"sourcesContent":["module.exports = require(\"bluebird\");","module.exports = require(\"path\");","module.exports = require(\"vortex-api\");","module.exports = require(\"winapi-bindings\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Promise = require(\"bluebird\");\nconst path = require(\"path\");\nconst winapi = require(\"winapi-bindings\");\nconst vortex_api_1 = require(\"vortex-api\");\nconst STORE_ID = 'gog';\nconst STORE_NAME = 'GOG';\nconst STORE_PRIORITY = 15;\nconst GOG_EXEC = 'GalaxyClient.exe';\nconst REG_GOG_GAMES = 'SOFTWARE\\\\WOW6432Node\\\\GOG.com\\\\Games';\nclass GoGLauncher {\n    constructor() {\n        this.id = STORE_ID;\n        this.name = STORE_NAME;\n        this.priority = STORE_PRIORITY;\n        if (process.platform === 'win32') {\n            try {\n                const gogPath = winapi.RegGetValue('HKEY_LOCAL_MACHINE', 'SOFTWARE\\\\WOW6432Node\\\\GOG.com\\\\GalaxyClient\\\\paths', 'client');\n                this.mClientPath = Promise.resolve(gogPath.value);\n            }\n            catch (err) {\n                (0, vortex_api_1.log)('info', 'gog not found', { error: err.message });\n                this.mClientPath = undefined;\n            }\n        }\n        else {\n            (0, vortex_api_1.log)('info', 'gog not found', { error: 'only available on Windows systems' });\n            this.mClientPath = undefined;\n        }\n    }\n    findByName(namePattern) {\n        const re = new RegExp('^' + namePattern + '$');\n        return this.allGames()\n            .then(entries => entries.find(entry => re.test(entry.name)))\n            .then(entry => {\n            if (entry === undefined) {\n                return Promise.reject(new vortex_api_1.types.GameEntryNotFound(namePattern, STORE_ID));\n            }\n            else {\n                return Promise.resolve(entry);\n            }\n        });\n    }\n    launchGame(appInfo, api) {\n        return this.getExecInfo(appInfo)\n            .then(execInfo => api.runExecutable(execInfo.execPath, execInfo.arguments, {\n            cwd: path.dirname(execInfo.execPath),\n            suggestDeploy: true,\n            shell: true,\n        }));\n    }\n    getExecInfo(appId) {\n        return this.allGames()\n            .then(entries => {\n            const gameEntry = entries.find(entry => entry.appid === appId);\n            return (gameEntry === undefined)\n                ? Promise.reject(new vortex_api_1.types.GameEntryNotFound(appId, STORE_ID))\n                : this.mClientPath.then((basePath) => {\n                    const gogClientExec = {\n                        execPath: path.join(basePath, GOG_EXEC),\n                        arguments: ['/command=runGame',\n                            `/gameId=${gameEntry.appid}`,\n                            `path=\"${gameEntry.gamePath}\"`],\n                    };\n                    return Promise.resolve(gogClientExec);\n                });\n        });\n    }\n    findByAppId(appId) {\n        const matcher = Array.isArray(appId)\n            ? (entry) => (appId.includes(entry.appid))\n            : (entry) => (appId === entry.appid);\n        return this.allGames()\n            .then(entries => {\n            const gameEntry = entries.find(matcher);\n            if (gameEntry === undefined) {\n                return Promise.reject(new vortex_api_1.types.GameEntryNotFound(Array.isArray(appId) ? appId.join(', ') : appId, STORE_ID));\n            }\n            else {\n                return Promise.resolve(gameEntry);\n            }\n        });\n    }\n    allGames() {\n        if (!this.mCache) {\n            this.mCache = this.getGameEntries();\n        }\n        return this.mCache;\n    }\n    reloadGames() {\n        return new Promise((resolve) => {\n            this.mCache = this.getGameEntries();\n            return resolve();\n        });\n    }\n    getGameStorePath() {\n        return (!!this.mClientPath)\n            ? this.mClientPath.then(basePath => Promise.resolve(path.join(basePath, 'GalaxyClient.exe')))\n            : Promise.resolve(undefined);\n    }\n    identifyGame(gamePath, fallback) {\n        return Promise.all([this.fileExists(path.join(gamePath, 'gog.ico')), fallback(gamePath)])\n            .then(([custom, fallback]) => {\n            if (custom !== fallback) {\n                (0, vortex_api_1.log)('warn', '(gog) game identification inconclusive', {\n                    gamePath,\n                    custom,\n                    fallback,\n                });\n            }\n            return custom || fallback;\n        });\n    }\n    fileExists(filePath) {\n        return vortex_api_1.fs.statAsync(filePath)\n            .then(() => true)\n            .catch(() => false);\n    }\n    getGameEntries() {\n        return (!!this.mClientPath)\n            ? new Promise((resolve, reject) => {\n                try {\n                    winapi.WithRegOpen('HKEY_LOCAL_MACHINE', REG_GOG_GAMES, hkey => {\n                        const keys = winapi.RegEnumKeys(hkey);\n                        const gameEntries = keys.map(key => {\n                            try {\n                                const gameEntry = {\n                                    appid: winapi.RegGetValue(hkey, key.key, 'gameID').value,\n                                    gamePath: winapi.RegGetValue(hkey, key.key, 'path').value,\n                                    name: winapi.RegGetValue(hkey, key.key, 'startMenu').value,\n                                    gameStoreId: STORE_ID,\n                                };\n                                return gameEntry;\n                            }\n                            catch (err) {\n                                (0, vortex_api_1.log)('error', 'gamestore-gog: failed to create game entry', err);\n                                return undefined;\n                            }\n                        }).filter(entry => !!entry);\n                        return resolve(gameEntries);\n                    });\n                }\n                catch (err) {\n                    return (err.code === 'ENOENT') ? resolve([]) : reject(err);\n                }\n            })\n            : Promise.resolve([]);\n    }\n}\nfunction main(context) {\n    const instance = process.platform === 'win32' ? new GoGLauncher() : undefined;\n    if (instance !== undefined) {\n        context.registerGameStore(instance);\n    }\n    return true;\n}\nexports.default = main;\n"],"names":[],"sourceRoot":""}