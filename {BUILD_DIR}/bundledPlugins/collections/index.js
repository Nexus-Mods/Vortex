/******/ (() => { // webpackBootstrap
/******/ 	const __webpack_modules__ = ({

/***/ "../../node_modules/bail/index.js":
/*!****************************************!*\
  !*** ../../node_modules/bail/index.js ***!
  \****************************************/
/***/ ((module) => {

      "use strict";


      module.exports = bail

      function bail(err) {
        if (err) {
          throw err
        }
      }


/***/ }),

/***/ "../../node_modules/comma-separated-tokens/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/comma-separated-tokens/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";


      exports.parse = parse
      exports.stringify = stringify

      const comma = ','
      const space = ' '
      const empty = ''

// Parse comma-separated tokens to an array.
      function parse(value) {
        const values = []
        const input = String(value || empty)
        let index = input.indexOf(comma)
        let lastIndex = 0
        let end = false
        let val

        while (!end) {
          if (index === -1) {
            index = input.length
            end = true
          }

          val = input.slice(lastIndex, index).trim()

          if (val || !end) {
            values.push(val)
          }

          lastIndex = index + 1
          index = input.indexOf(comma, lastIndex)
        }

        return values
      }

// Compile an array to comma-separated tokens.
// `options.padLeft` (default: `true`) pads a space left of each token, and
// `options.padRight` (default: `false`) pads a space to the right of each token.
      function stringify(values, options) {
        const settings = options || {}
        const left = settings.padLeft === false ? empty : space
        const right = settings.padRight ? space : empty

  // Ensure the last empty entry is seen.
        if (values[values.length - 1] === empty) {
          values = values.concat(empty)
        }

        return values.join(right + comma + left).trim()
      }


/***/ }),

/***/ "../../node_modules/extend/index.js":
/*!******************************************!*\
  !*** ../../node_modules/extend/index.js ***!
  \******************************************/
/***/ ((module) => {

      "use strict";


      const hasOwn = Object.prototype.hasOwnProperty;
      const toStr = Object.prototype.toString;
      const defineProperty = Object.defineProperty;
      const gOPD = Object.getOwnPropertyDescriptor;

      const isArray = function isArray(arr) {
        if (typeof Array.isArray === 'function') {
          return Array.isArray(arr);
        }

        return toStr.call(arr) === '[object Array]';
      };

      const isPlainObject = function isPlainObject(obj) {
        if (!obj || toStr.call(obj) !== '[object Object]') {
          return false;
        }

        const hasOwnConstructor = hasOwn.call(obj, 'constructor');
        const hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
        if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
          return false;
        }

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
        let key;
        for (key in obj) { /**/ }

        return typeof key === 'undefined' || hasOwn.call(obj, key);
      };

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
      const setProperty = function setProperty(target, options) {
        if (defineProperty && options.name === '__proto__') {
          defineProperty(target, options.name, {
            enumerable: true,
            configurable: true,
            value: options.newValue,
            writable: true
          });
        } else {
          target[options.name] = options.newValue;
        }
      };

// Return undefined instead of __proto__ if '__proto__' is not an own property
      const getProperty = function getProperty(obj, name) {
        if (name === '__proto__') {
          if (!hasOwn.call(obj, name)) {
            return void 0;
          } else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
            return gOPD(obj, name).value;
          }
        }

        return obj[name];
      };

      module.exports = function extend() {
        let options, name, src, copy, copyIsArray, clone;
        let target = arguments[0];
        let i = 1;
        const length = arguments.length;
        let deep = false;

	// Handle a deep copy situation
        if (typeof target === 'boolean') {
          deep = target;
          target = arguments[1] || {};
		// skip the boolean and the target
          i = 2;
        }
        if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
          target = {};
        }

        for (; i < length; ++i) {
          options = arguments[i];
		// Only deal with non-null/undefined values
          if (options != null) {
			// Extend the base object
            for (name in options) {
              src = getProperty(target, name);
              copy = getProperty(options, name);

				// Prevent never-ending loop
              if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
                if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                  if (copyIsArray) {
                    copyIsArray = false;
                    clone = src && isArray(src) ? src : [];
                  } else {
                    clone = src && isPlainObject(src) ? src : {};
                  }

						// Never move original objects, clone them
                  setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
                } else if (typeof copy !== 'undefined') {
                  setProperty(target, { name: name, newValue: copy });
                }
              }
            }
          }
        }

	// Return the modified object
        return target;
      };


/***/ }),

/***/ "../../node_modules/inline-style-parser/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/inline-style-parser/index.js ***!
  \*******************************************************/
/***/ ((module) => {

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
      const COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;

      const NEWLINE_REGEX = /\n/g;
      const WHITESPACE_REGEX = /^\s*/;

// declaration
      const PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
      const COLON_REGEX = /^:\s*/;
      const VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
      const SEMICOLON_REGEX = /^[;\s]*/;

// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
      const TRIM_REGEX = /^\s+|\s+$/g;

// strings
      const NEWLINE = '\n';
      const FORWARD_SLASH = '/';
      const ASTERISK = '*';
      const EMPTY_STRING = '';

// types
      const TYPE_COMMENT = 'comment';
      const TYPE_DECLARATION = 'declaration';

/**
 * @param {String} style
 * @param {Object} [options]
 * @return {Object[]}
 * @throws {TypeError}
 * @throws {Error}
 */
      module.exports = function(style, options) {
        if (typeof style !== 'string') {
          throw new TypeError('First argument must be a string');
        }

        if (!style) return [];

        options = options || {};

  /**
   * Positional.
   */
        let lineno = 1;
        let column = 1;

  /**
   * Update lineno and column based on `str`.
   *
   * @param {String} str
   */
        function updatePosition(str) {
          const lines = str.match(NEWLINE_REGEX);
          if (lines) lineno += lines.length;
          const i = str.lastIndexOf(NEWLINE);
          column = ~i ? str.length - i : column + str.length;
        }

  /**
   * Mark position and patch `node.position`.
   *
   * @return {Function}
   */
        function position() {
          const start = { line: lineno, column: column };
          return function(node) {
            node.position = new Position(start);
            whitespace();
            return node;
          };
        }

  /**
   * Store position information for a node.
   *
   * @constructor
   * @property {Object} start
   * @property {Object} end
   * @property {undefined|String} source
   */
        function Position(start) {
          this.start = start;
          this.end = { line: lineno, column: column };
          this.source = options.source;
        }

  /**
   * Non-enumerable source string.
   */
        Position.prototype.content = style;

        const errorsList = [];

  /**
   * Error `msg`.
   *
   * @param {String} msg
   * @throws {Error}
   */
        function error(msg) {
          const err = new Error(
            options.source + ':' + lineno + ':' + column + ': ' + msg
          );
          err.reason = msg;
          err.filename = options.source;
          err.line = lineno;
          err.column = column;
          err.source = style;

          if (options.silent) {
            errorsList.push(err);
          } else {
            throw err;
          }
        }

  /**
   * Match `re` and return captures.
   *
   * @param {RegExp} re
   * @return {undefined|Array}
   */
        function match(re) {
          const m = re.exec(style);
          if (!m) return;
          const str = m[0];
          updatePosition(str);
          style = style.slice(str.length);
          return m;
        }

  /**
   * Parse whitespace.
   */
        function whitespace() {
          match(WHITESPACE_REGEX);
        }

  /**
   * Parse comments.
   *
   * @param {Object[]} [rules]
   * @return {Object[]}
   */
        function comments(rules) {
          let c;
          rules = rules || [];
          while ((c = comment())) {
            if (c !== false) {
              rules.push(c);
            }
          }
          return rules;
        }

  /**
   * Parse comment.
   *
   * @return {Object}
   * @throws {Error}
   */
        function comment() {
          const pos = position();
          if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;

          let i = 2;
          while (
            EMPTY_STRING != style.charAt(i) &&
      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))
          ) {
            ++i;
          }
          i += 2;

          if (EMPTY_STRING === style.charAt(i - 1)) {
            return error('End of comment missing');
          }

          const str = style.slice(2, i - 2);
          column += 2;
          updatePosition(str);
          style = style.slice(i);
          column += 2;

          return pos({
            type: TYPE_COMMENT,
            comment: str
          });
        }

  /**
   * Parse declaration.
   *
   * @return {Object}
   * @throws {Error}
   */
        function declaration() {
          const pos = position();

    // prop
          const prop = match(PROPERTY_REGEX);
          if (!prop) return;
          comment();

    // :
          if (!match(COLON_REGEX)) return error("property missing ':'");

    // val
          const val = match(VALUE_REGEX);

          const ret = pos({
            type: TYPE_DECLARATION,
            property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
            value: val
              ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))
              : EMPTY_STRING
          });

    // ;
          match(SEMICOLON_REGEX);

          return ret;
        }

  /**
   * Parse declarations.
   *
   * @return {Object[]}
   */
        function declarations() {
          const decls = [];

          comments(decls);

    // declarations
          let decl;
          while ((decl = declaration())) {
            if (decl !== false) {
              decls.push(decl);
              comments(decls);
            }
          }

          return decls;
        }

        whitespace();
        return declarations();
      };

/**
 * Trim `str`.
 *
 * @param {String} str
 * @return {String}
 */
      function trim(str) {
        return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
      }


/***/ }),

/***/ "../../node_modules/is-plain-obj/index.js":
/*!************************************************!*\
  !*** ../../node_modules/is-plain-obj/index.js ***!
  \************************************************/
/***/ ((module) => {

      "use strict";


      module.exports = value => {
        if (Object.prototype.toString.call(value) !== '[object Object]') {
          return false;
        }

        const prototype = Object.getPrototypeOf(value);
        return prototype === null || prototype === Object.prototype;
      };


/***/ }),

/***/ "../../node_modules/mdast-util-definitions/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/mdast-util-definitions/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const visit = __webpack_require__(/*! unist-util-visit */ "../../node_modules/unist-util-visit/index.js")

      module.exports = getDefinitionFactory

      const own = {}.hasOwnProperty

// Get a definition in `node` by `identifier`.
      function getDefinitionFactory(node, options) {
        return getterFactory(gather(node, options))
      }

// Gather all definitions in `node`
      function gather(node) {
        const cache = {}

        if (!node || !node.type) {
          throw new Error('mdast-util-definitions expected node')
        }

        visit(node, 'definition', ondefinition)

        return cache

        function ondefinition(definition) {
          const id = normalise(definition.identifier)
          if (!own.call(cache, id)) {
            cache[id] = definition
          }
        }
      }

// Factory to get a node from the given definition-cache.
      function getterFactory(cache) {
        return getter

  // Get a node from the bound definition-cache.
        function getter(identifier) {
          const id = identifier && normalise(identifier)
          return id && own.call(cache, id) ? cache[id] : null
        }
      }

      function normalise(identifier) {
        return identifier.toUpperCase()
      }


/***/ }),

/***/ "../../node_modules/mdast-util-from-markdown/dist/index.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/mdast-util-from-markdown/dist/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = fromMarkdown

// These three are compiled away in the `dist/`

      const toString = __webpack_require__(/*! mdast-util-to-string */ "../../node_modules/mdast-util-to-string/index.js")
      const assign = __webpack_require__(/*! micromark/dist/constant/assign */ "../../node_modules/micromark/dist/constant/assign.js")
      const own = __webpack_require__(/*! micromark/dist/constant/has-own-property */ "../../node_modules/micromark/dist/constant/has-own-property.js")
      const normalizeIdentifier = __webpack_require__(/*! micromark/dist/util/normalize-identifier */ "../../node_modules/micromark/dist/util/normalize-identifier.js")
      const safeFromInt = __webpack_require__(/*! micromark/dist/util/safe-from-int */ "../../node_modules/micromark/dist/util/safe-from-int.js")
      const parser = __webpack_require__(/*! micromark/dist/parse */ "../../node_modules/micromark/dist/parse.js")
      const preprocessor = __webpack_require__(/*! micromark/dist/preprocess */ "../../node_modules/micromark/dist/preprocess.js")
      const postprocess = __webpack_require__(/*! micromark/dist/postprocess */ "../../node_modules/micromark/dist/postprocess.js")
      const decode = __webpack_require__(/*! parse-entities/decode-entity */ "../../node_modules/parse-entities/decode-entity.browser.js")
      const stringifyPosition = __webpack_require__(/*! unist-util-stringify-position */ "../../node_modules/unist-util-stringify-position/index.js")

      function fromMarkdown(value, encoding, options) {
        if (typeof encoding !== 'string') {
          options = encoding
          encoding = undefined
        }

        return compiler(options)(
          postprocess(
            parser(options).document().write(preprocessor()(value, encoding, true))
          )
        )
      }

// Note this compiler only understand complete buffering, not streaming.
      function compiler(options) {
        const settings = options || {}
        const config = configure(
          {
            transforms: [],
            canContainEols: [
              'emphasis',
              'fragment',
              'heading',
              'paragraph',
              'strong'
            ],

            enter: {
              autolink: opener(link),
              autolinkProtocol: onenterdata,
              autolinkEmail: onenterdata,
              atxHeading: opener(heading),
              blockQuote: opener(blockQuote),
              characterEscape: onenterdata,
              characterReference: onenterdata,
              codeFenced: opener(codeFlow),
              codeFencedFenceInfo: buffer,
              codeFencedFenceMeta: buffer,
              codeIndented: opener(codeFlow, buffer),
              codeText: opener(codeText, buffer),
              codeTextData: onenterdata,
              data: onenterdata,
              codeFlowValue: onenterdata,
              definition: opener(definition),
              definitionDestinationString: buffer,
              definitionLabelString: buffer,
              definitionTitleString: buffer,
              emphasis: opener(emphasis),
              hardBreakEscape: opener(hardBreak),
              hardBreakTrailing: opener(hardBreak),
              htmlFlow: opener(html, buffer),
              htmlFlowData: onenterdata,
              htmlText: opener(html, buffer),
              htmlTextData: onenterdata,
              image: opener(image),
              label: buffer,
              link: opener(link),
              listItem: opener(listItem),
              listItemValue: onenterlistitemvalue,
              listOrdered: opener(list, onenterlistordered),
              listUnordered: opener(list),
              paragraph: opener(paragraph),
              reference: onenterreference,
              referenceString: buffer,
              resourceDestinationString: buffer,
              resourceTitleString: buffer,
              setextHeading: opener(heading),
              strong: opener(strong),
              thematicBreak: opener(thematicBreak)
            },

            exit: {
              atxHeading: closer(),
              atxHeadingSequence: onexitatxheadingsequence,
              autolink: closer(),
              autolinkEmail: onexitautolinkemail,
              autolinkProtocol: onexitautolinkprotocol,
              blockQuote: closer(),
              characterEscapeValue: onexitdata,
              characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
              characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
              characterReferenceValue: onexitcharacterreferencevalue,
              codeFenced: closer(onexitcodefenced),
              codeFencedFence: onexitcodefencedfence,
              codeFencedFenceInfo: onexitcodefencedfenceinfo,
              codeFencedFenceMeta: onexitcodefencedfencemeta,
              codeFlowValue: onexitdata,
              codeIndented: closer(onexitcodeindented),
              codeText: closer(onexitcodetext),
              codeTextData: onexitdata,
              data: onexitdata,
              definition: closer(),
              definitionDestinationString: onexitdefinitiondestinationstring,
              definitionLabelString: onexitdefinitionlabelstring,
              definitionTitleString: onexitdefinitiontitlestring,
              emphasis: closer(),
              hardBreakEscape: closer(onexithardbreak),
              hardBreakTrailing: closer(onexithardbreak),
              htmlFlow: closer(onexithtmlflow),
              htmlFlowData: onexitdata,
              htmlText: closer(onexithtmltext),
              htmlTextData: onexitdata,
              image: closer(onexitimage),
              label: onexitlabel,
              labelText: onexitlabeltext,
              lineEnding: onexitlineending,
              link: closer(onexitlink),
              listItem: closer(),
              listOrdered: closer(),
              listUnordered: closer(),
              paragraph: closer(),
              referenceString: onexitreferencestring,
              resourceDestinationString: onexitresourcedestinationstring,
              resourceTitleString: onexitresourcetitlestring,
              resource: onexitresource,
              setextHeading: closer(onexitsetextheading),
              setextHeadingLineSequence: onexitsetextheadinglinesequence,
              setextHeadingText: onexitsetextheadingtext,
              strong: closer(),
              thematicBreak: closer()
            }
          },

          settings.mdastExtensions || []
        )

        const data = {}

        return compile

        function compile(events) {
          let tree = {type: 'root', children: []}
          const stack = [tree]
          const tokenStack = []
          const listStack = []
          let index = -1
          let handler
          let listStart

          const context = {
            stack: stack,
            tokenStack: tokenStack,
            config: config,
            enter: enter,
            exit: exit,
            buffer: buffer,
            resume: resume,
            setData: setData,
            getData: getData
          }

          while (++index < events.length) {
      // We preprocess lists to add `listItem` tokens, and to infer whether
      // items the list itself are spread out.
            if (
              events[index][1].type === 'listOrdered' ||
        events[index][1].type === 'listUnordered'
            ) {
              if (events[index][0] === 'enter') {
                listStack.push(index)
              } else {
                listStart = listStack.pop(index)
                index = prepareList(events, listStart, index)
              }
            }
          }

          index = -1

          while (++index < events.length) {
            handler = config[events[index][0]]

            if (own.call(handler, events[index][1].type)) {
              handler[events[index][1].type].call(
                assign({sliceSerialize: events[index][2].sliceSerialize}, context),
                events[index][1]
              )
            }
          }

          if (tokenStack.length) {
            throw new Error(
              'Cannot close document, a token (`' +
          tokenStack[tokenStack.length - 1].type +
          '`, ' +
          stringifyPosition({
            start: tokenStack[tokenStack.length - 1].start,
            end: tokenStack[tokenStack.length - 1].end
          }) +
          ') is still open'
            )
          }

    // Figure out `root` position.
          tree.position = {
            start: point(
              events.length ? events[0][1].start : {line: 1, column: 1, offset: 0}
            ),

            end: point(
              events.length
                ? events[events.length - 2][1].end
                : {line: 1, column: 1, offset: 0}
            )
          }

          index = -1
          while (++index < config.transforms.length) {
            tree = config.transforms[index](tree) || tree
          }

          return tree
        }

        function prepareList(events, start, length) {
          let index = start - 1
          let containerBalance = -1
          let listSpread = false
          let listItem
          let tailIndex
          let lineIndex
          let tailEvent
          let event
          let firstBlankLineIndex
          let atMarker

          while (++index <= length) {
            event = events[index]

            if (
              event[1].type === 'listUnordered' ||
        event[1].type === 'listOrdered' ||
        event[1].type === 'blockQuote'
            ) {
              if (event[0] === 'enter') {
                containerBalance++
              } else {
                containerBalance--
              }

              atMarker = undefined
            } else if (event[1].type === 'lineEndingBlank') {
              if (event[0] === 'enter') {
                if (
                  listItem &&
            !atMarker &&
            !containerBalance &&
            !firstBlankLineIndex
                ) {
                  firstBlankLineIndex = index
                }

                atMarker = undefined
              }
            } else if (
              event[1].type === 'linePrefix' ||
        event[1].type === 'listItemValue' ||
        event[1].type === 'listItemMarker' ||
        event[1].type === 'listItemPrefix' ||
        event[1].type === 'listItemPrefixWhitespace'
            ) {
        // Empty.
            } else {
              atMarker = undefined
            }

            if (
              (!containerBalance &&
          event[0] === 'enter' &&
          event[1].type === 'listItemPrefix') ||
        (containerBalance === -1 &&
          event[0] === 'exit' &&
          (event[1].type === 'listUnordered' ||
            event[1].type === 'listOrdered'))
            ) {
              if (listItem) {
                tailIndex = index
                lineIndex = undefined

                while (tailIndex--) {
                  tailEvent = events[tailIndex]

                  if (
                    tailEvent[1].type === 'lineEnding' ||
              tailEvent[1].type === 'lineEndingBlank'
                  ) {
                    if (tailEvent[0] === 'exit') continue

                    if (lineIndex) {
                      events[lineIndex][1].type = 'lineEndingBlank'
                      listSpread = true
                    }

                    tailEvent[1].type = 'lineEnding'
                    lineIndex = tailIndex
                  } else if (
                    tailEvent[1].type === 'linePrefix' ||
              tailEvent[1].type === 'blockQuotePrefix' ||
              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||
              tailEvent[1].type === 'blockQuoteMarker' ||
              tailEvent[1].type === 'listItemIndent'
                  ) {
              // Empty
                  } else {
                    break
                  }
                }

                if (
                  firstBlankLineIndex &&
            (!lineIndex || firstBlankLineIndex < lineIndex)
                ) {
                  listItem._spread = true
                }

          // Fix position.
                listItem.end = point(
                  lineIndex ? events[lineIndex][1].start : event[1].end
                )

                events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])
                index++
                length++
              }

        // Create a new list item.
              if (event[1].type === 'listItemPrefix') {
                listItem = {
                  type: 'listItem',
                  _spread: false,
                  start: point(event[1].start)
                }

                events.splice(index, 0, ['enter', listItem, event[2]])
                index++
                length++
                firstBlankLineIndex = undefined
                atMarker = true
              }
            }
          }

          events[start][1]._spread = listSpread
          return length
        }

        function setData(key, value) {
          data[key] = value
        }

        function getData(key) {
          return data[key]
        }

        function point(d) {
          return {line: d.line, column: d.column, offset: d.offset}
        }

        function opener(create, and) {
          return open

          function open(token) {
            enter.call(this, create(token), token)
            if (and) and.call(this, token)
          }
        }

        function buffer() {
          this.stack.push({type: 'fragment', children: []})
        }

        function enter(node, token) {
          this.stack[this.stack.length - 1].children.push(node)
          this.stack.push(node)
          this.tokenStack.push(token)
          node.position = {start: point(token.start)}
          return node
        }

        function closer(and) {
          return close

          function close(token) {
            if (and) and.call(this, token)
            exit.call(this, token)
          }
        }

        function exit(token) {
          const node = this.stack.pop()
          const open = this.tokenStack.pop()

          if (!open) {
            throw new Error(
              'Cannot close `' +
          token.type +
          '` (' +
          stringifyPosition({start: token.start, end: token.end}) +
          '): it’s not open'
            )
          } else if (open.type !== token.type) {
            throw new Error(
              'Cannot close `' +
          token.type +
          '` (' +
          stringifyPosition({start: token.start, end: token.end}) +
          '): a different token (`' +
          open.type +
          '`, ' +
          stringifyPosition({start: open.start, end: open.end}) +
          ') is open'
            )
          }

          node.position.end = point(token.end)
          return node
        }

        function resume() {
          return toString(this.stack.pop())
        }

  //
  // Handlers.
  //

        function onenterlistordered() {
          setData('expectingFirstListItemValue', true)
        }

        function onenterlistitemvalue(token) {
          if (getData('expectingFirstListItemValue')) {
            this.stack[this.stack.length - 2].start = parseInt(
              this.sliceSerialize(token),
              10
            )

            setData('expectingFirstListItemValue')
          }
        }

        function onexitcodefencedfenceinfo() {
          const data = this.resume()
          this.stack[this.stack.length - 1].lang = data
        }

        function onexitcodefencedfencemeta() {
          const data = this.resume()
          this.stack[this.stack.length - 1].meta = data
        }

        function onexitcodefencedfence() {
    // Exit if this is the closing fence.
          if (getData('flowCodeInside')) return
          this.buffer()
          setData('flowCodeInside', true)
        }

        function onexitcodefenced() {
          const data = this.resume()
          this.stack[this.stack.length - 1].value = data.replace(
            /^(\r?\n|\r)|(\r?\n|\r)$/g,
            ''
          )

          setData('flowCodeInside')
        }

        function onexitcodeindented() {
          const data = this.resume()
          this.stack[this.stack.length - 1].value = data
        }

        function onexitdefinitionlabelstring(token) {
    // Discard label, use the source content instead.
          const label = this.resume()
          this.stack[this.stack.length - 1].label = label
          this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
            this.sliceSerialize(token)
          ).toLowerCase()
        }

        function onexitdefinitiontitlestring() {
          const data = this.resume()
          this.stack[this.stack.length - 1].title = data
        }

        function onexitdefinitiondestinationstring() {
          const data = this.resume()
          this.stack[this.stack.length - 1].url = data
        }

        function onexitatxheadingsequence(token) {
          if (!this.stack[this.stack.length - 1].depth) {
            this.stack[this.stack.length - 1].depth = this.sliceSerialize(
              token
            ).length
          }
        }

        function onexitsetextheadingtext() {
          setData('setextHeadingSlurpLineEnding', true)
        }

        function onexitsetextheadinglinesequence(token) {
          this.stack[this.stack.length - 1].depth =
      this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2
        }

        function onexitsetextheading() {
          setData('setextHeadingSlurpLineEnding')
        }

        function onenterdata(token) {
          const siblings = this.stack[this.stack.length - 1].children
          let tail = siblings[siblings.length - 1]

          if (!tail || tail.type !== 'text') {
      // Add a new text node.
            tail = text()
            tail.position = {start: point(token.start)}
            this.stack[this.stack.length - 1].children.push(tail)
          }

          this.stack.push(tail)
        }

        function onexitdata(token) {
          const tail = this.stack.pop()
          tail.value += this.sliceSerialize(token)
          tail.position.end = point(token.end)
        }

        function onexitlineending(token) {
          const context = this.stack[this.stack.length - 1]

    // If we’re at a hard break, include the line ending in there.
          if (getData('atHardBreak')) {
            context.children[context.children.length - 1].position.end = point(
              token.end
            )

            setData('atHardBreak')
            return
          }

          if (
            !getData('setextHeadingSlurpLineEnding') &&
      config.canContainEols.indexOf(context.type) > -1
          ) {
            onenterdata.call(this, token)
            onexitdata.call(this, token)
          }
        }

        function onexithardbreak() {
          setData('atHardBreak', true)
        }

        function onexithtmlflow() {
          const data = this.resume()
          this.stack[this.stack.length - 1].value = data
        }

        function onexithtmltext() {
          const data = this.resume()
          this.stack[this.stack.length - 1].value = data
        }

        function onexitcodetext() {
          const data = this.resume()
          this.stack[this.stack.length - 1].value = data
        }

        function onexitlink() {
          const context = this.stack[this.stack.length - 1]

    // To do: clean.
          if (getData('inReference')) {
            context.type += 'Reference'
            context.referenceType = getData('referenceType') || 'shortcut'
            delete context.url
            delete context.title
          } else {
            delete context.identifier
            delete context.label
            delete context.referenceType
          }

          setData('referenceType')
        }

        function onexitimage() {
          const context = this.stack[this.stack.length - 1]

    // To do: clean.
          if (getData('inReference')) {
            context.type += 'Reference'
            context.referenceType = getData('referenceType') || 'shortcut'
            delete context.url
            delete context.title
          } else {
            delete context.identifier
            delete context.label
            delete context.referenceType
          }

          setData('referenceType')
        }

        function onexitlabeltext(token) {
          this.stack[this.stack.length - 2].identifier = normalizeIdentifier(
            this.sliceSerialize(token)
          ).toLowerCase()
        }

        function onexitlabel() {
          const fragment = this.stack[this.stack.length - 1]
          const value = this.resume()

          this.stack[this.stack.length - 1].label = value

    // Assume a reference.
          setData('inReference', true)

          if (this.stack[this.stack.length - 1].type === 'link') {
            this.stack[this.stack.length - 1].children = fragment.children
          } else {
            this.stack[this.stack.length - 1].alt = value
          }
        }

        function onexitresourcedestinationstring() {
          const data = this.resume()
          this.stack[this.stack.length - 1].url = data
        }

        function onexitresourcetitlestring() {
          const data = this.resume()
          this.stack[this.stack.length - 1].title = data
        }

        function onexitresource() {
          setData('inReference')
        }

        function onenterreference() {
          setData('referenceType', 'collapsed')
        }

        function onexitreferencestring(token) {
          const label = this.resume()
          this.stack[this.stack.length - 1].label = label
          this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
            this.sliceSerialize(token)
          ).toLowerCase()
          setData('referenceType', 'full')
        }

        function onexitcharacterreferencemarker(token) {
          setData('characterReferenceType', token.type)
        }

        function onexitcharacterreferencevalue(token) {
          const data = this.sliceSerialize(token)
          const type = getData('characterReferenceType')
          let value
          let tail

          if (type) {
            value = safeFromInt(
              data,
              type === 'characterReferenceMarkerNumeric' ? 10 : 16
            )

            setData('characterReferenceType')
          } else {
            value = decode(data)
          }

          tail = this.stack.pop()
          tail.value += value
          tail.position.end = point(token.end)
        }

        function onexitautolinkprotocol(token) {
          onexitdata.call(this, token)
          this.stack[this.stack.length - 1].url = this.sliceSerialize(token)
        }

        function onexitautolinkemail(token) {
          onexitdata.call(this, token)
          this.stack[this.stack.length - 1].url =
      'mailto:' + this.sliceSerialize(token)
        }

  //
  // Creaters.
  //

        function blockQuote() {
          return {type: 'blockquote', children: []}
        }

        function codeFlow() {
          return {type: 'code', lang: null, meta: null, value: ''}
        }

        function codeText() {
          return {type: 'inlineCode', value: ''}
        }

        function definition() {
          return {
            type: 'definition',
            identifier: '',
            label: null,
            title: null,
            url: ''
          }
        }

        function emphasis() {
          return {type: 'emphasis', children: []}
        }

        function heading() {
          return {type: 'heading', depth: undefined, children: []}
        }

        function hardBreak() {
          return {type: 'break'}
        }

        function html() {
          return {type: 'html', value: ''}
        }

        function image() {
          return {type: 'image', title: null, url: '', alt: null}
        }

        function link() {
          return {type: 'link', title: null, url: '', children: []}
        }

        function list(token) {
          return {
            type: 'list',
            ordered: token.type === 'listOrdered',
            start: null,
            spread: token._spread,
            children: []
          }
        }

        function listItem(token) {
          return {
            type: 'listItem',
            spread: token._spread,
            checked: null,
            children: []
          }
        }

        function paragraph() {
          return {type: 'paragraph', children: []}
        }

        function strong() {
          return {type: 'strong', children: []}
        }

        function text() {
          return {type: 'text', value: ''}
        }

        function thematicBreak() {
          return {type: 'thematicBreak'}
        }
      }

      function configure(config, extensions) {
        let index = -1

        while (++index < extensions.length) {
          extension(config, extensions[index])
        }

        return config
      }

      function extension(config, extension) {
        let key
        let left

        for (key in extension) {
          left = own.call(config, key) ? config[key] : (config[key] = {})

          if (key === 'canContainEols' || key === 'transforms') {
            config[key] = [].concat(left, extension[key])
          } else {
            Object.assign(left, extension[key])
          }
        }
      }


/***/ }),

/***/ "../../node_modules/mdast-util-from-markdown/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/mdast-util-from-markdown/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = __webpack_require__(/*! ./dist */ "../../node_modules/mdast-util-from-markdown/dist/index.js")


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";

      module.exports = __webpack_require__(/*! ./lib */ "../../node_modules/mdast-util-to-hast/lib/index.js")


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/all.js":
/*!********************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/all.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = all

      const one = __webpack_require__(/*! ./one */ "../../node_modules/mdast-util-to-hast/lib/one.js")

      function all(h, parent) {
        const nodes = parent.children || []
        const length = nodes.length
        let values = []
        let index = -1
        let result
        let head

        while (++index < length) {
          result = one(h, nodes[index], parent)

          if (result) {
            if (index && nodes[index - 1].type === 'break') {
              if (result.value) {
                result.value = result.value.replace(/^\s+/, '')
              }

              head = result.children && result.children[0]

              if (head && head.value) {
                head.value = head.value.replace(/^\s+/, '')
              }
            }

            values = values.concat(result)
          }
        }

        return values
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/footer.js":
/*!***********************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/footer.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = generateFootnotes

      const thematicBreak = __webpack_require__(/*! ./handlers/thematic-break */ "../../node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js")
      const list = __webpack_require__(/*! ./handlers/list */ "../../node_modules/mdast-util-to-hast/lib/handlers/list.js")
      const wrap = __webpack_require__(/*! ./wrap */ "../../node_modules/mdast-util-to-hast/lib/wrap.js")

      function generateFootnotes(h) {
        const footnoteById = h.footnoteById
        const footnoteOrder = h.footnoteOrder
        const length = footnoteOrder.length
        let index = -1
        const listItems = []
        let def
        let backReference
        let content
        let tail

        while (++index < length) {
          def = footnoteById[footnoteOrder[index].toUpperCase()]

          if (!def) {
            continue
          }

          content = def.children.concat()
          tail = content[content.length - 1]
          backReference = {
            type: 'link',
            url: '#fnref-' + def.identifier,
            data: {hProperties: {className: ['footnote-backref']}},
            children: [{type: 'text', value: '↩'}]
          }

          if (!tail || tail.type !== 'paragraph') {
            tail = {type: 'paragraph', children: []}
            content.push(tail)
          }

          tail.children.push(backReference)

          listItems.push({
            type: 'listItem',
            data: {hProperties: {id: 'fn-' + def.identifier}},
            children: content,
            position: def.position
          })
        }

        if (listItems.length === 0) {
          return null
        }

        return h(
          null,
          'div',
          {className: ['footnotes']},
          wrap(
            [
              thematicBreak(h),
              list(h, {type: 'list', ordered: true, children: listItems})
            ],
            true
          )
        )
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/blockquote.js":
/*!************************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/blockquote.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = blockquote

      const wrap = __webpack_require__(/*! ../wrap */ "../../node_modules/mdast-util-to-hast/lib/wrap.js")
      const all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

      function blockquote(h, node) {
        return h(node, 'blockquote', wrap(all(h, node), true))
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/break.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/break.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = hardBreak

      const u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

      function hardBreak(h, node) {
        return [h(node, 'br'), u('text', '\n')]
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/code.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/code.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = code

      const u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

      function code(h, node) {
        const value = node.value ? node.value + '\n' : ''
  // To do: next major, use `node.lang` w/o regex, the splitting’s been going
  // on for years in remark now.
        const lang = node.lang && node.lang.match(/^[^ \t]+(?=[ \t]|$)/)
        const props = {}
        let code

        if (lang) {
          props.className = ['language-' + lang]
        }

        code = h(node, 'code', props, [u('text', value)])

        if (node.meta) {
          code.data = {meta: node.meta}
        }

        return h(node.position, 'pre', [code])
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/delete.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/delete.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = strikethrough

      const all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

      function strikethrough(h, node) {
        return h(node, 'del', all(h, node))
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/emphasis.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/emphasis.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = emphasis

      const all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

      function emphasis(h, node) {
        return h(node, 'em', all(h, node))
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = footnoteReference

      const u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

      function footnoteReference(h, node) {
        const footnoteOrder = h.footnoteOrder
        const identifier = String(node.identifier)

        if (footnoteOrder.indexOf(identifier) === -1) {
          footnoteOrder.push(identifier)
        }

        return h(node.position, 'sup', {id: 'fnref-' + identifier}, [
          h(node, 'a', {href: '#fn-' + identifier, className: ['footnote-ref']}, [
            u('text', node.label || identifier)
          ])
        ])
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/footnote.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/footnote.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = footnote

      const footnoteReference = __webpack_require__(/*! ./footnote-reference */ "../../node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js")

      function footnote(h, node) {
        const footnoteById = h.footnoteById
        const footnoteOrder = h.footnoteOrder
        let identifier = 1

        while (identifier in footnoteById) {
          identifier++
        }

        identifier = String(identifier)

  // No need to check if `identifier` exists in `footnoteOrder`, it’s guaranteed
  // to not exist because we just generated it.
        footnoteOrder.push(identifier)

        footnoteById[identifier] = {
          type: 'footnoteDefinition',
          identifier: identifier,
          children: [{type: 'paragraph', children: node.children}],
          position: node.position
        }

        return footnoteReference(h, {
          type: 'footnoteReference',
          identifier: identifier,
          position: node.position
        })
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/heading.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/heading.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = heading

      const all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

      function heading(h, node) {
        return h(node, 'h' + node.depth, all(h, node))
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/html.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/html.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = html

      const u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

// Return either a `raw` node in dangerous mode, otherwise nothing.
      function html(h, node) {
        return h.dangerous ? h.augment(node, u('raw', node.value)) : null
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/image-reference.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/image-reference.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = imageReference

      const normalize = __webpack_require__(/*! mdurl/encode */ "../../node_modules/mdurl/encode.js")
      const revert = __webpack_require__(/*! ../revert */ "../../node_modules/mdast-util-to-hast/lib/revert.js")

      function imageReference(h, node) {
        const def = h.definition(node.identifier)
        let props

        if (!def) {
          return revert(h, node)
        }

        props = {src: normalize(def.url || ''), alt: node.alt}

        if (def.title !== null && def.title !== undefined) {
          props.title = def.title
        }

        return h(node, 'img', props)
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/image.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/image.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const normalize = __webpack_require__(/*! mdurl/encode */ "../../node_modules/mdurl/encode.js")

      module.exports = image

      function image(h, node) {
        const props = {src: normalize(node.url), alt: node.alt}

        if (node.title !== null && node.title !== undefined) {
          props.title = node.title
        }

        return h(node, 'img', props)
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/index.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/index.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = {
        blockquote: __webpack_require__(/*! ./blockquote */ "../../node_modules/mdast-util-to-hast/lib/handlers/blockquote.js"),
        break: __webpack_require__(/*! ./break */ "../../node_modules/mdast-util-to-hast/lib/handlers/break.js"),
        code: __webpack_require__(/*! ./code */ "../../node_modules/mdast-util-to-hast/lib/handlers/code.js"),
        delete: __webpack_require__(/*! ./delete */ "../../node_modules/mdast-util-to-hast/lib/handlers/delete.js"),
        emphasis: __webpack_require__(/*! ./emphasis */ "../../node_modules/mdast-util-to-hast/lib/handlers/emphasis.js"),
        footnoteReference: __webpack_require__(/*! ./footnote-reference */ "../../node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js"),
        footnote: __webpack_require__(/*! ./footnote */ "../../node_modules/mdast-util-to-hast/lib/handlers/footnote.js"),
        heading: __webpack_require__(/*! ./heading */ "../../node_modules/mdast-util-to-hast/lib/handlers/heading.js"),
        html: __webpack_require__(/*! ./html */ "../../node_modules/mdast-util-to-hast/lib/handlers/html.js"),
        imageReference: __webpack_require__(/*! ./image-reference */ "../../node_modules/mdast-util-to-hast/lib/handlers/image-reference.js"),
        image: __webpack_require__(/*! ./image */ "../../node_modules/mdast-util-to-hast/lib/handlers/image.js"),
        inlineCode: __webpack_require__(/*! ./inline-code */ "../../node_modules/mdast-util-to-hast/lib/handlers/inline-code.js"),
        linkReference: __webpack_require__(/*! ./link-reference */ "../../node_modules/mdast-util-to-hast/lib/handlers/link-reference.js"),
        link: __webpack_require__(/*! ./link */ "../../node_modules/mdast-util-to-hast/lib/handlers/link.js"),
        listItem: __webpack_require__(/*! ./list-item */ "../../node_modules/mdast-util-to-hast/lib/handlers/list-item.js"),
        list: __webpack_require__(/*! ./list */ "../../node_modules/mdast-util-to-hast/lib/handlers/list.js"),
        paragraph: __webpack_require__(/*! ./paragraph */ "../../node_modules/mdast-util-to-hast/lib/handlers/paragraph.js"),
        root: __webpack_require__(/*! ./root */ "../../node_modules/mdast-util-to-hast/lib/handlers/root.js"),
        strong: __webpack_require__(/*! ./strong */ "../../node_modules/mdast-util-to-hast/lib/handlers/strong.js"),
        table: __webpack_require__(/*! ./table */ "../../node_modules/mdast-util-to-hast/lib/handlers/table.js"),
        text: __webpack_require__(/*! ./text */ "../../node_modules/mdast-util-to-hast/lib/handlers/text.js"),
        thematicBreak: __webpack_require__(/*! ./thematic-break */ "../../node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js"),
        toml: ignore,
        yaml: ignore,
        definition: ignore,
        footnoteDefinition: ignore
      }

// Return nothing for nodes that are ignored.
      function ignore() {
        return null
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/inline-code.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/inline-code.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = inlineCode

      const u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

      function inlineCode(h, node) {
        const value = node.value.replace(/\r?\n|\r/g, ' ')
        return h(node, 'code', [u('text', value)])
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/link-reference.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/link-reference.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = linkReference

      const normalize = __webpack_require__(/*! mdurl/encode */ "../../node_modules/mdurl/encode.js")
      const revert = __webpack_require__(/*! ../revert */ "../../node_modules/mdast-util-to-hast/lib/revert.js")
      const all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

      function linkReference(h, node) {
        const def = h.definition(node.identifier)
        let props

        if (!def) {
          return revert(h, node)
        }

        props = {href: normalize(def.url || '')}

        if (def.title !== null && def.title !== undefined) {
          props.title = def.title
        }

        return h(node, 'a', props, all(h, node))
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/link.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/link.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const normalize = __webpack_require__(/*! mdurl/encode */ "../../node_modules/mdurl/encode.js")
      const all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

      module.exports = link

      function link(h, node) {
        const props = {href: normalize(node.url)}

        if (node.title !== null && node.title !== undefined) {
          props.title = node.title
        }

        return h(node, 'a', props, all(h, node))
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/list-item.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/list-item.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = listItem

      const u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")
      const all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

      function listItem(h, node, parent) {
        const result = all(h, node)
        let head = result[0]
        const loose = parent ? listLoose(parent) : listItemLoose(node)
        const props = {}
        let wrapped = []
        let length
        let index
        let child

        if (typeof node.checked === 'boolean') {
          if (!head || head.tagName !== 'p') {
            head = h(null, 'p', [])
            result.unshift(head)
          }

          if (head.children.length > 0) {
            head.children.unshift(u('text', ' '))
          }

          head.children.unshift(
            h(null, 'input', {
              type: 'checkbox',
              checked: node.checked,
              disabled: true
            })
          )

    // According to github-markdown-css, this class hides bullet.
    // See: <https://github.com/sindresorhus/github-markdown-css>.
          props.className = ['task-list-item']
        }

        length = result.length
        index = -1

        while (++index < length) {
          child = result[index]

    // Add eols before nodes, except if this is a loose, first paragraph.
          if (loose || index !== 0 || child.tagName !== 'p') {
            wrapped.push(u('text', '\n'))
          }

          if (child.tagName === 'p' && !loose) {
            wrapped = wrapped.concat(child.children)
          } else {
            wrapped.push(child)
          }
        }

  // Add a final eol.
        if (length && (loose || child.tagName !== 'p')) {
          wrapped.push(u('text', '\n'))
        }

        return h(node, 'li', props, wrapped)
      }

      function listLoose(node) {
        let loose = node.spread
        const children = node.children
        const length = children.length
        let index = -1

        while (!loose && ++index < length) {
          loose = listItemLoose(children[index])
        }

        return loose
      }

      function listItemLoose(node) {
        const spread = node.spread

        return spread === undefined || spread === null
          ? node.children.length > 1
          : spread
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/list.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/list.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = list

      const wrap = __webpack_require__(/*! ../wrap */ "../../node_modules/mdast-util-to-hast/lib/wrap.js")
      const all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

      function list(h, node) {
        const props = {}
        const name = node.ordered ? 'ol' : 'ul'
        let items
        let index = -1
        let length

        if (typeof node.start === 'number' && node.start !== 1) {
          props.start = node.start
        }

        items = all(h, node)
        length = items.length

  // Like GitHub, add a class for custom styling.
        while (++index < length) {
          if (
            items[index].properties.className &&
      items[index].properties.className.indexOf('task-list-item') !== -1
          ) {
            props.className = ['contains-task-list']
            break
          }
        }

        return h(node, name, props, wrap(items, true))
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/paragraph.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/paragraph.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = paragraph

      const all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

      function paragraph(h, node) {
        return h(node, 'p', all(h, node))
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/root.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/root.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = root

      const u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")
      const wrap = __webpack_require__(/*! ../wrap */ "../../node_modules/mdast-util-to-hast/lib/wrap.js")
      const all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

      function root(h, node) {
        return h.augment(node, u('root', wrap(all(h, node))))
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/strong.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/strong.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = strong

      const all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

      function strong(h, node) {
        return h(node, 'strong', all(h, node))
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/table.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/table.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = table

      const position = __webpack_require__(/*! unist-util-position */ "../../node_modules/unist-util-position/index.js")
      const wrap = __webpack_require__(/*! ../wrap */ "../../node_modules/mdast-util-to-hast/lib/wrap.js")
      const all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

      function table(h, node) {
        const rows = node.children
        let index = rows.length
        const align = node.align || []
        const alignLength = align.length
        const result = []
        let pos
        let row
        let out
        let name
        let cell

        while (index--) {
          row = rows[index].children
          name = index === 0 ? 'th' : 'td'
          pos = alignLength || row.length
          out = []

          while (pos--) {
            cell = row[pos]
            out[pos] = h(cell, name, {align: align[pos]}, cell ? all(h, cell) : [])
          }

          result[index] = h(rows[index], 'tr', wrap(out, true))
        }

        return h(
          node,
          'table',
          wrap(
            [h(result[0].position, 'thead', wrap([result[0]], true))].concat(
              result[1]
                ? h(
                  {
                    start: position.start(result[1]),
                    end: position.end(result[result.length - 1])
                  },
                  'tbody',
                  wrap(result.slice(1), true)
                )
                : []
            ),
            true
          )
        )
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/text.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/text.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = text

      const u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

      function text(h, node) {
        return h.augment(
          node,
          u('text', String(node.value).replace(/[ \t]*(\r?\n|\r)[ \t]*/g, '$1'))
        )
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js ***!
  \****************************************************************************/
/***/ ((module) => {

      "use strict";


      module.exports = thematicBreak

      function thematicBreak(h, node) {
        return h(node, 'hr')
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = toHast

      const u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")
      const visit = __webpack_require__(/*! unist-util-visit */ "../../node_modules/unist-util-visit/index.js")
      const position = __webpack_require__(/*! unist-util-position */ "../../node_modules/unist-util-position/index.js")
      const generated = __webpack_require__(/*! unist-util-generated */ "../../node_modules/unist-util-generated/index.js")
      const definitions = __webpack_require__(/*! mdast-util-definitions */ "../../node_modules/mdast-util-definitions/index.js")
      const one = __webpack_require__(/*! ./one */ "../../node_modules/mdast-util-to-hast/lib/one.js")
      const footer = __webpack_require__(/*! ./footer */ "../../node_modules/mdast-util-to-hast/lib/footer.js")
      const handlers = __webpack_require__(/*! ./handlers */ "../../node_modules/mdast-util-to-hast/lib/handlers/index.js")

      const own = {}.hasOwnProperty

      let deprecationWarningIssued = false

// Factory to transform.
      function factory(tree, options) {
        const settings = options || {}

  // Issue a warning if the deprecated tag 'allowDangerousHTML' is used
        if (settings.allowDangerousHTML !== undefined && !deprecationWarningIssued) {
          deprecationWarningIssued = true
          console.warn(
            'mdast-util-to-hast: deprecation: `allowDangerousHTML` is nonstandard, use `allowDangerousHtml` instead'
          )
        }

        const dangerous = settings.allowDangerousHtml || settings.allowDangerousHTML
        const footnoteById = {}

        h.dangerous = dangerous
        h.definition = definitions(tree)
        h.footnoteById = footnoteById
        h.footnoteOrder = []
        h.augment = augment
        h.handlers = Object.assign({}, handlers, settings.handlers)
        h.unknownHandler = settings.unknownHandler
        h.passThrough = settings.passThrough

        visit(tree, 'footnoteDefinition', onfootnotedefinition)

        return h

  // Finalise the created `right`, a hast node, from `left`, an mdast node.
        function augment(left, right) {
          let data
          let ctx

    // Handle `data.hName`, `data.hProperties, `data.hChildren`.
          if (left && left.data) {
            data = left.data

            if (data.hName) {
              if (right.type !== 'element') {
                right = {
                  type: 'element',
                  tagName: '',
                  properties: {},
                  children: []
                }
              }

              right.tagName = data.hName
            }

            if (right.type === 'element' && data.hProperties) {
              right.properties = Object.assign({}, right.properties, data.hProperties)
            }

            if (right.children && data.hChildren) {
              right.children = data.hChildren
            }
          }

          ctx = left && left.position ? left : {position: left}

          if (!generated(ctx)) {
            right.position = {
              start: position.start(ctx),
              end: position.end(ctx)
            }
          }

          return right
        }

  // Create an element for `node`.
        function h(node, tagName, props, children) {
          if (
            (children === undefined || children === null) &&
      typeof props === 'object' &&
      'length' in props
          ) {
            children = props
            props = {}
          }

          return augment(node, {
            type: 'element',
            tagName: tagName,
            properties: props || {},
            children: children || []
          })
        }

        function onfootnotedefinition(definition) {
          const id = String(definition.identifier).toUpperCase()

    // Mimick CM behavior of link definitions.
    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.
          if (!own.call(footnoteById, id)) {
            footnoteById[id] = definition
          }
        }
      }

// Transform `tree`, which is an mdast node, to a hast node.
      function toHast(tree, options) {
        const h = factory(tree, options)
        const node = one(h, tree)
        const foot = footer(h)

        if (foot) {
          node.children = node.children.concat(u('text', '\n'), foot)
        }

        return node
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/one.js":
/*!********************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/one.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = one

      const u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")
      const all = __webpack_require__(/*! ./all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

      const own = {}.hasOwnProperty

// Transform an unknown node.
      function unknown(h, node) {
        if (text(node)) {
          return h.augment(node, u('text', node.value))
        }

        return h(node, 'div', all(h, node))
      }

// Visit a node.
      function one(h, node, parent) {
        const type = node && node.type
        let fn

  // Fail on non-nodes.
        if (!type) {
          throw new Error('Expected node, got `' + node + '`')
        }

        if (own.call(h.handlers, type)) {
          fn = h.handlers[type]
        } else if (h.passThrough && h.passThrough.indexOf(type) > -1) {
          fn = returnNode
        } else {
          fn = h.unknownHandler
        }

        return (typeof fn === 'function' ? fn : unknown)(h, node, parent)
      }

// Check if the node should be renderered as a text node.
      function text(node) {
        const data = node.data || {}

        if (
          own.call(data, 'hName') ||
    own.call(data, 'hProperties') ||
    own.call(data, 'hChildren')
        ) {
          return false
        }

        return 'value' in node
      }

      function returnNode(h, node) {
        let clone

        if (node.children) {
          clone = Object.assign({}, node)
          clone.children = all(h, node)
          return clone
        }

        return node
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/revert.js":
/*!***********************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/revert.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = revert

      const u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")
      const all = __webpack_require__(/*! ./all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

// Return the content of a reference without definition as Markdown.
      function revert(h, node) {
        const subtype = node.referenceType
        let suffix = ']'
        let contents
        let head
        let tail

        if (subtype === 'collapsed') {
          suffix += '[]'
        } else if (subtype === 'full') {
          suffix += '[' + (node.label || node.identifier) + ']'
        }

        if (node.type === 'imageReference') {
          return u('text', '![' + node.alt + suffix)
        }

        contents = all(h, node)
        head = contents[0]

        if (head && head.type === 'text') {
          head.value = '[' + head.value
        } else {
          contents.unshift(u('text', '['))
        }

        tail = contents[contents.length - 1]

        if (tail && tail.type === 'text') {
          tail.value += suffix
        } else {
          contents.push(u('text', suffix))
        }

        return contents
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/wrap.js":
/*!*********************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/wrap.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = wrap

      const u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

// Wrap `nodes` with line feeds between each entry.
// Optionally adds line feeds at the start and end.
      function wrap(nodes, loose) {
        const result = []
        let index = -1
        const length = nodes.length

        if (loose) {
          result.push(u('text', '\n'))
        }

        while (++index < length) {
          if (index) {
            result.push(u('text', '\n'))
          }

          result.push(nodes[index])
        }

        if (loose && nodes.length > 0) {
          result.push(u('text', '\n'))
        }

        return result
      }


/***/ }),

/***/ "../../node_modules/mdast-util-to-string/index.js":
/*!********************************************************!*\
  !*** ../../node_modules/mdast-util-to-string/index.js ***!
  \********************************************************/
/***/ ((module) => {

      "use strict";


      module.exports = toString

// Get the text content of a node.
// Prefer the node’s plain-text fields, otherwise serialize its children,
// and if the given value is an array, serialize the nodes in it.
      function toString(node) {
        return (
          (node &&
      (node.value ||
        node.alt ||
        node.title ||
        ('children' in node && all(node.children)) ||
        ('length' in node && all(node)))) ||
    ''
        )
      }

      function all(values) {
        const result = []
        let index = -1

        while (++index < values.length) {
          result[index] = toString(values[index])
        }

        return result.join('')
      }


/***/ }),

/***/ "../../node_modules/mdurl/encode.js":
/*!******************************************!*\
  !*** ../../node_modules/mdurl/encode.js ***!
  \******************************************/
/***/ ((module) => {

      "use strict";




      const encodeCache = {};


// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
      function getEncodeCache(exclude) {
        let i, ch, cache = encodeCache[exclude];
        if (cache) { return cache; }

        cache = encodeCache[exclude] = [];

        for (i = 0; i < 128; i++) {
          ch = String.fromCharCode(i);

          if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
            cache.push(ch);
          } else {
            cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
          }
        }

        for (i = 0; i < exclude.length; i++) {
          cache[exclude.charCodeAt(i)] = exclude[i];
        }

        return cache;
      }


// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
      function encode(string, exclude, keepEscaped) {
        let i, l, code, nextCode, cache,
          result = '';

        if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
          keepEscaped  = exclude;
          exclude = encode.defaultChars;
        }

        if (typeof keepEscaped === 'undefined') {
          keepEscaped = true;
        }

        cache = getEncodeCache(exclude);

        for (i = 0, l = string.length; i < l; i++) {
          code = string.charCodeAt(i);

          if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
            if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
              result += string.slice(i, i + 3);
              i += 2;
              continue;
            }
          }

          if (code < 128) {
            result += cache[code];
            continue;
          }

          if (code >= 0xD800 && code <= 0xDFFF) {
            if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
              nextCode = string.charCodeAt(i + 1);
              if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
                result += encodeURIComponent(string[i] + string[i + 1]);
                i++;
                continue;
              }
            }
            result += '%EF%BF%BD';
            continue;
          }

          result += encodeURIComponent(string[i]);
        }

        return result;
      }

      encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
      encode.componentChars = "-_.!~*'()";


      module.exports = encode;


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-alpha.js":
/*!******************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-alpha.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

      const asciiAlpha = regexCheck(/[A-Za-z]/)

      module.exports = asciiAlpha


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-alphanumeric.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-alphanumeric.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

      const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/)

      module.exports = asciiAlphanumeric


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-atext.js":
/*!******************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-atext.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

      const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/)

      module.exports = asciiAtext


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-control.js":
/*!********************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-control.js ***!
  \********************************************************************/
/***/ ((module) => {

      "use strict";


// Note: EOF is seen as ASCII control here, because `null < 32 == true`.
      function asciiControl(code) {
        return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
          code < 32 || code === 127
        )
      }

      module.exports = asciiControl


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-digit.js":
/*!******************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-digit.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

      const asciiDigit = regexCheck(/\d/)

      module.exports = asciiDigit


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-hex-digit.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-hex-digit.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

      const asciiHexDigit = regexCheck(/[\dA-Fa-f]/)

      module.exports = asciiHexDigit


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-punctuation.js":
/*!************************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-punctuation.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

      const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)

      module.exports = asciiPunctuation


/***/ }),

/***/ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js ***!
  \************************************************************************************/
/***/ ((module) => {

      "use strict";


      function markdownLineEndingOrSpace(code) {
        return code < 0 || code === 32
      }

      module.exports = markdownLineEndingOrSpace


/***/ }),

/***/ "../../node_modules/micromark/dist/character/markdown-line-ending.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/markdown-line-ending.js ***!
  \***************************************************************************/
/***/ ((module) => {

      "use strict";


      function markdownLineEnding(code) {
        return code < -2
      }

      module.exports = markdownLineEnding


/***/ }),

/***/ "../../node_modules/micromark/dist/character/markdown-space.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/markdown-space.js ***!
  \*********************************************************************/
/***/ ((module) => {

      "use strict";


      function markdownSpace(code) {
        return code === -2 || code === -1 || code === 32
      }

      module.exports = markdownSpace


/***/ }),

/***/ "../../node_modules/micromark/dist/character/unicode-punctuation.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/unicode-punctuation.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const unicodePunctuationRegex = __webpack_require__(/*! ../constant/unicode-punctuation-regex.js */ "../../node_modules/micromark/dist/constant/unicode-punctuation-regex.js")
      const regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

// In fact adds to the bundle size.

      const unicodePunctuation = regexCheck(unicodePunctuationRegex)

      module.exports = unicodePunctuation


/***/ }),

/***/ "../../node_modules/micromark/dist/character/unicode-whitespace.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/unicode-whitespace.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

      const unicodeWhitespace = regexCheck(/\s/)

      module.exports = unicodeWhitespace


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/assign.js":
/*!************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/assign.js ***!
  \************************************************************/
/***/ ((module) => {

      "use strict";


      const assign = Object.assign

      module.exports = assign


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/from-char-code.js":
/*!********************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/from-char-code.js ***!
  \********************************************************************/
/***/ ((module) => {

      "use strict";


      const fromCharCode = String.fromCharCode

      module.exports = fromCharCode


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/has-own-property.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/has-own-property.js ***!
  \**********************************************************************/
/***/ ((module) => {

      "use strict";


      const own = {}.hasOwnProperty

      module.exports = own


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/html-block-names.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/html-block-names.js ***!
  \**********************************************************************/
/***/ ((module) => {

      "use strict";


// This module is copied from <https://spec.commonmark.org/0.29/#html-blocks>.
      const basics = [
        'address',
        'article',
        'aside',
        'base',
        'basefont',
        'blockquote',
        'body',
        'caption',
        'center',
        'col',
        'colgroup',
        'dd',
        'details',
        'dialog',
        'dir',
        'div',
        'dl',
        'dt',
        'fieldset',
        'figcaption',
        'figure',
        'footer',
        'form',
        'frame',
        'frameset',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'head',
        'header',
        'hr',
        'html',
        'iframe',
        'legend',
        'li',
        'link',
        'main',
        'menu',
        'menuitem',
        'nav',
        'noframes',
        'ol',
        'optgroup',
        'option',
        'p',
        'param',
        'section',
        'source',
        'summary',
        'table',
        'tbody',
        'td',
        'tfoot',
        'th',
        'thead',
        'title',
        'tr',
        'track',
        'ul'
      ]

      module.exports = basics


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/html-raw-names.js":
/*!********************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/html-raw-names.js ***!
  \********************************************************************/
/***/ ((module) => {

      "use strict";


// This module is copied from <https://spec.commonmark.org/0.29/#html-blocks>.
      const raws = ['pre', 'script', 'style', 'textarea']

      module.exports = raws


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/splice.js":
/*!************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/splice.js ***!
  \************************************************************/
/***/ ((module) => {

      "use strict";


      const splice = [].splice

      module.exports = splice


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/unicode-punctuation-regex.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/unicode-punctuation-regex.js ***!
  \*******************************************************************************/
/***/ ((module) => {

      "use strict";


// This module is generated by `script/`.
//
// CommonMark handles attention (emphasis, strong) markers based on what comes
// before or after them.
// One such difference is if those characters are Unicode punctuation.
// This script is generated from the Unicode data.
      const unicodePunctuation = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/

      module.exports = unicodePunctuation


/***/ }),

/***/ "../../node_modules/micromark/dist/constructs.js":
/*!*******************************************************!*\
  !*** ../../node_modules/micromark/dist/constructs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";


      Object.defineProperty(exports, "__esModule", ({value: true}))

      const text$1 = __webpack_require__(/*! ./initialize/text.js */ "../../node_modules/micromark/dist/initialize/text.js")
      const attention = __webpack_require__(/*! ./tokenize/attention.js */ "../../node_modules/micromark/dist/tokenize/attention.js")
      const autolink = __webpack_require__(/*! ./tokenize/autolink.js */ "../../node_modules/micromark/dist/tokenize/autolink.js")
      const blockQuote = __webpack_require__(/*! ./tokenize/block-quote.js */ "../../node_modules/micromark/dist/tokenize/block-quote.js")
      const characterEscape = __webpack_require__(/*! ./tokenize/character-escape.js */ "../../node_modules/micromark/dist/tokenize/character-escape.js")
      const characterReference = __webpack_require__(/*! ./tokenize/character-reference.js */ "../../node_modules/micromark/dist/tokenize/character-reference.js")
      const codeFenced = __webpack_require__(/*! ./tokenize/code-fenced.js */ "../../node_modules/micromark/dist/tokenize/code-fenced.js")
      const codeIndented = __webpack_require__(/*! ./tokenize/code-indented.js */ "../../node_modules/micromark/dist/tokenize/code-indented.js")
      const codeText = __webpack_require__(/*! ./tokenize/code-text.js */ "../../node_modules/micromark/dist/tokenize/code-text.js")
      const definition = __webpack_require__(/*! ./tokenize/definition.js */ "../../node_modules/micromark/dist/tokenize/definition.js")
      const hardBreakEscape = __webpack_require__(/*! ./tokenize/hard-break-escape.js */ "../../node_modules/micromark/dist/tokenize/hard-break-escape.js")
      const headingAtx = __webpack_require__(/*! ./tokenize/heading-atx.js */ "../../node_modules/micromark/dist/tokenize/heading-atx.js")
      const htmlFlow = __webpack_require__(/*! ./tokenize/html-flow.js */ "../../node_modules/micromark/dist/tokenize/html-flow.js")
      const htmlText = __webpack_require__(/*! ./tokenize/html-text.js */ "../../node_modules/micromark/dist/tokenize/html-text.js")
      const labelEnd = __webpack_require__(/*! ./tokenize/label-end.js */ "../../node_modules/micromark/dist/tokenize/label-end.js")
      const labelStartImage = __webpack_require__(/*! ./tokenize/label-start-image.js */ "../../node_modules/micromark/dist/tokenize/label-start-image.js")
      const labelStartLink = __webpack_require__(/*! ./tokenize/label-start-link.js */ "../../node_modules/micromark/dist/tokenize/label-start-link.js")
      const lineEnding = __webpack_require__(/*! ./tokenize/line-ending.js */ "../../node_modules/micromark/dist/tokenize/line-ending.js")
      const list = __webpack_require__(/*! ./tokenize/list.js */ "../../node_modules/micromark/dist/tokenize/list.js")
      const setextUnderline = __webpack_require__(/*! ./tokenize/setext-underline.js */ "../../node_modules/micromark/dist/tokenize/setext-underline.js")
      const thematicBreak = __webpack_require__(/*! ./tokenize/thematic-break.js */ "../../node_modules/micromark/dist/tokenize/thematic-break.js")

      const document = {
        42: list,
  // Asterisk
        43: list,
  // Plus sign
        45: list,
  // Dash
        48: list,
  // 0
        49: list,
  // 1
        50: list,
  // 2
        51: list,
  // 3
        52: list,
  // 4
        53: list,
  // 5
        54: list,
  // 6
        55: list,
  // 7
        56: list,
  // 8
        57: list,
  // 9
        62: blockQuote // Greater than
      }
      const contentInitial = {
        91: definition // Left square bracket
      }
      const flowInitial = {
        '-2': codeIndented,
  // Horizontal tab
        '-1': codeIndented,
  // Virtual space
        32: codeIndented // Space
      }
      const flow = {
        35: headingAtx,
  // Number sign
        42: thematicBreak,
  // Asterisk
        45: [setextUnderline, thematicBreak],
  // Dash
        60: htmlFlow,
  // Less than
        61: setextUnderline,
  // Equals to
        95: thematicBreak,
  // Underscore
        96: codeFenced,
  // Grave accent
        126: codeFenced // Tilde
      }
      const string = {
        38: characterReference,
  // Ampersand
        92: characterEscape // Backslash
      }
      const text = {
        '-5': lineEnding,
  // Carriage return
        '-4': lineEnding,
  // Line feed
        '-3': lineEnding,
  // Carriage return + line feed
        33: labelStartImage,
  // Exclamation mark
        38: characterReference,
  // Ampersand
        42: attention,
  // Asterisk
        60: [autolink, htmlText],
  // Less than
        91: labelStartLink,
  // Left square bracket
        92: [hardBreakEscape, characterEscape],
  // Backslash
        93: labelEnd,
  // Right square bracket
        95: attention,
  // Underscore
        96: codeText // Grave accent
      }
      const insideSpan = {
        null: [attention, text$1.resolver]
      }
      const disable = {
        null: []
      }

      exports.contentInitial = contentInitial
      exports.disable = disable
      exports.document = document
      exports.flow = flow
      exports.flowInitial = flowInitial
      exports.insideSpan = insideSpan
      exports.string = string
      exports.text = text


/***/ }),

/***/ "../../node_modules/micromark/dist/initialize/content.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/initialize/content.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";


      Object.defineProperty(exports, "__esModule", ({value: true}))

      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const factorySpace = __webpack_require__(/*! ../tokenize/factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

      const tokenize = initializeContent

      function initializeContent(effects) {
        const contentStart = effects.attempt(
          this.parser.constructs.contentInitial,
          afterContentStartConstruct,
          paragraphInitial
        )
        let previous
        return contentStart

        function afterContentStartConstruct(code) {
          if (code === null) {
            effects.consume(code)
            return
          }

          effects.enter('lineEnding')
          effects.consume(code)
          effects.exit('lineEnding')
          return factorySpace(effects, contentStart, 'linePrefix')
        }

        function paragraphInitial(code) {
          effects.enter('paragraph')
          return lineStart(code)
        }

        function lineStart(code) {
          const token = effects.enter('chunkText', {
            contentType: 'text',
            previous: previous
          })

          if (previous) {
            previous.next = token
          }

          previous = token
          return data(code)
        }

        function data(code) {
          if (code === null) {
            effects.exit('chunkText')
            effects.exit('paragraph')
            effects.consume(code)
            return
          }

          if (markdownLineEnding(code)) {
            effects.consume(code)
            effects.exit('chunkText')
            return lineStart
          } // Data.

          effects.consume(code)
          return data
        }
      }

      exports.tokenize = tokenize


/***/ }),

/***/ "../../node_modules/micromark/dist/initialize/document.js":
/*!****************************************************************!*\
  !*** ../../node_modules/micromark/dist/initialize/document.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";


      Object.defineProperty(exports, "__esModule", ({value: true}))

      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const factorySpace = __webpack_require__(/*! ../tokenize/factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")
      const partialBlankLine = __webpack_require__(/*! ../tokenize/partial-blank-line.js */ "../../node_modules/micromark/dist/tokenize/partial-blank-line.js")

      const tokenize = initializeDocument
      const containerConstruct = {
        tokenize: tokenizeContainer
      }
      const lazyFlowConstruct = {
        tokenize: tokenizeLazyFlow
      }

      function initializeDocument(effects) {
        const self = this
        const stack = []
        let continued = 0
        const inspectConstruct = {
          tokenize: tokenizeInspect,
          partial: true
        }
        let inspectResult
        let childFlow
        let childToken
        return start

        function start(code) {
          if (continued < stack.length) {
            self.containerState = stack[continued][1]
            return effects.attempt(
              stack[continued][0].continuation,
              documentContinue,
              documentContinued
            )(code)
          }

          return documentContinued(code)
        }

        function documentContinue(code) {
          continued++
          return start(code)
        }

        function documentContinued(code) {
    // If we’re in a concrete construct (such as when expecting another line of
    // HTML, or we resulted in lazy content), we can immediately start flow.
          if (inspectResult && inspectResult.flowContinue) {
            return flowStart(code)
          }

          self.interrupt =
      childFlow &&
      childFlow.currentConstruct &&
      childFlow.currentConstruct.interruptible
          self.containerState = {}
          return effects.attempt(
            containerConstruct,
            containerContinue,
            flowStart
          )(code)
        }

        function containerContinue(code) {
          stack.push([self.currentConstruct, self.containerState])
          self.containerState = undefined
          return documentContinued(code)
        }

        function flowStart(code) {
          if (code === null) {
            exitContainers(0, true)
            effects.consume(code)
            return
          }

          childFlow = childFlow || self.parser.flow(self.now())
          effects.enter('chunkFlow', {
            contentType: 'flow',
            previous: childToken,
            _tokenizer: childFlow
          })
          return flowContinue(code)
        }

        function flowContinue(code) {
          if (code === null) {
            continueFlow(effects.exit('chunkFlow'))
            return flowStart(code)
          }

          if (markdownLineEnding(code)) {
            effects.consume(code)
            continueFlow(effects.exit('chunkFlow'))
            return effects.check(inspectConstruct, documentAfterPeek)
          }

          effects.consume(code)
          return flowContinue
        }

        function documentAfterPeek(code) {
          exitContainers(
            inspectResult.continued,
            inspectResult && inspectResult.flowEnd
          )
          continued = 0
          return start(code)
        }

        function continueFlow(token) {
          if (childToken) childToken.next = token
          childToken = token
          childFlow.lazy = inspectResult && inspectResult.lazy
          childFlow.defineSkip(token.start)
          childFlow.write(self.sliceStream(token))
        }

        function exitContainers(size, end) {
          let index = stack.length // Close the flow.

          if (childFlow && end) {
            childFlow.write([null])
            childToken = childFlow = undefined
          } // Exit open containers.

          while (index-- > size) {
            self.containerState = stack[index][1]
            stack[index][0].exit.call(self, effects)
          }

          stack.length = size
        }

        function tokenizeInspect(effects, ok) {
          let subcontinued = 0
          inspectResult = {}
          return inspectStart

          function inspectStart(code) {
            if (subcontinued < stack.length) {
              self.containerState = stack[subcontinued][1]
              return effects.attempt(
                stack[subcontinued][0].continuation,
                inspectContinue,
                inspectLess
              )(code)
            } // If we’re continued but in a concrete flow, we can’t have more
      // containers.

            if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
              inspectResult.flowContinue = true
              return inspectDone(code)
            }

            self.interrupt =
        childFlow.currentConstruct && childFlow.currentConstruct.interruptible
            self.containerState = {}
            return effects.attempt(
              containerConstruct,
              inspectFlowEnd,
              inspectDone
            )(code)
          }

          function inspectContinue(code) {
            subcontinued++
            return self.containerState._closeFlow
              ? inspectFlowEnd(code)
              : inspectStart(code)
          }

          function inspectLess(code) {
            if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {
        // Maybe another container?
              self.containerState = {}
              return effects.attempt(
                containerConstruct,
                inspectFlowEnd, // Maybe flow, or a blank line?
                effects.attempt(
                  lazyFlowConstruct,
                  inspectFlowEnd,
                  effects.check(partialBlankLine, inspectFlowEnd, inspectLazy)
                )
              )(code)
            } // Otherwise we’re interrupting.

            return inspectFlowEnd(code)
          }

          function inspectLazy(code) {
      // Act as if all containers are continued.
            subcontinued = stack.length
            inspectResult.lazy = true
            inspectResult.flowContinue = true
            return inspectDone(code)
          } // We’re done with flow if we have more containers, or an interruption.

          function inspectFlowEnd(code) {
            inspectResult.flowEnd = true
            return inspectDone(code)
          }

          function inspectDone(code) {
            inspectResult.continued = subcontinued
            self.interrupt = self.containerState = undefined
            return ok(code)
          }
        }
      }

      function tokenizeContainer(effects, ok, nok) {
        return factorySpace(
          effects,
          effects.attempt(this.parser.constructs.document, ok, nok),
          'linePrefix',
          this.parser.constructs.disable.null.indexOf('codeIndented') > -1
            ? undefined
            : 4
        )
      }

      function tokenizeLazyFlow(effects, ok, nok) {
        return factorySpace(
          effects,
          effects.lazy(this.parser.constructs.flow, ok, nok),
          'linePrefix',
          this.parser.constructs.disable.null.indexOf('codeIndented') > -1
            ? undefined
            : 4
        )
      }

      exports.tokenize = tokenize


/***/ }),

/***/ "../../node_modules/micromark/dist/initialize/flow.js":
/*!************************************************************!*\
  !*** ../../node_modules/micromark/dist/initialize/flow.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";


      Object.defineProperty(exports, "__esModule", ({value: true}))

      const content = __webpack_require__(/*! ../tokenize/content.js */ "../../node_modules/micromark/dist/tokenize/content.js")
      const factorySpace = __webpack_require__(/*! ../tokenize/factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")
      const partialBlankLine = __webpack_require__(/*! ../tokenize/partial-blank-line.js */ "../../node_modules/micromark/dist/tokenize/partial-blank-line.js")

      const tokenize = initializeFlow

      function initializeFlow(effects) {
        const self = this
        const initial = effects.attempt(
    // Try to parse a blank line.
          partialBlankLine,
          atBlankEnding, // Try to parse initial flow (essentially, only code).
          effects.attempt(
            this.parser.constructs.flowInitial,
            afterConstruct,
            factorySpace(
              effects,
              effects.attempt(
                this.parser.constructs.flow,
                afterConstruct,
                effects.attempt(content, afterConstruct)
              ),
              'linePrefix'
            )
          )
        )
        return initial

        function atBlankEnding(code) {
          if (code === null) {
            effects.consume(code)
            return
          }

          effects.enter('lineEndingBlank')
          effects.consume(code)
          effects.exit('lineEndingBlank')
          self.currentConstruct = undefined
          return initial
        }

        function afterConstruct(code) {
          if (code === null) {
            effects.consume(code)
            return
          }

          effects.enter('lineEnding')
          effects.consume(code)
          effects.exit('lineEnding')
          self.currentConstruct = undefined
          return initial
        }
      }

      exports.tokenize = tokenize


/***/ }),

/***/ "../../node_modules/micromark/dist/initialize/text.js":
/*!************************************************************!*\
  !*** ../../node_modules/micromark/dist/initialize/text.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";


      Object.defineProperty(exports, "__esModule", ({value: true}))

      const assign = __webpack_require__(/*! ../constant/assign.js */ "../../node_modules/micromark/dist/constant/assign.js")
      const shallow = __webpack_require__(/*! ../util/shallow.js */ "../../node_modules/micromark/dist/util/shallow.js")

      const text = initializeFactory('text')
      const string = initializeFactory('string')
      const resolver = {
        resolveAll: createResolver()
      }

      function initializeFactory(field) {
        return {
          tokenize: initializeText,
          resolveAll: createResolver(
            field === 'text' ? resolveAllLineSuffixes : undefined
          )
        }

        function initializeText(effects) {
          const self = this
          const constructs = this.parser.constructs[field]
          const text = effects.attempt(constructs, start, notText)
          return start

          function start(code) {
            return atBreak(code) ? text(code) : notText(code)
          }

          function notText(code) {
            if (code === null) {
              effects.consume(code)
              return
            }

            effects.enter('data')
            effects.consume(code)
            return data
          }

          function data(code) {
            if (atBreak(code)) {
              effects.exit('data')
              return text(code)
            } // Data.

            effects.consume(code)
            return data
          }

          function atBreak(code) {
            const list = constructs[code]
            let index = -1

            if (code === null) {
              return true
            }

            if (list) {
              while (++index < list.length) {
                if (
                  !list[index].previous ||
            list[index].previous.call(self, self.previous)
                ) {
                  return true
                }
              }
            }
          }
        }
      }

      function createResolver(extraResolver) {
        return resolveAllText

        function resolveAllText(events, context) {
          let index = -1
          let enter // A rather boring computation (to merge adjacent `data` events) which
    // improves mm performance by 29%.

          while (++index <= events.length) {
            if (enter === undefined) {
              if (events[index] && events[index][1].type === 'data') {
                enter = index
                index++
              }
            } else if (!events[index] || events[index][1].type !== 'data') {
        // Don’t do anything if there is one data token.
              if (index !== enter + 2) {
                events[enter][1].end = events[index - 1][1].end
                events.splice(enter + 2, index - enter - 2)
                index = enter + 2
              }

              enter = undefined
            }
          }

          return extraResolver ? extraResolver(events, context) : events
        }
      } // A rather ugly set of instructions which again looks at chunks in the input
// stream.
// The reason to do this here is that it is *much* faster to parse in reverse.
// And that we can’t hook into `null` to split the line suffix before an EOF.
// To do: figure out if we can make this into a clean utility, or even in core.
// As it will be useful for GFMs literal autolink extension (and maybe even
// tables?)

      function resolveAllLineSuffixes(events, context) {
        let eventIndex = -1
        let chunks
        let data
        let chunk
        let index
        let bufferIndex
        let size
        let tabs
        let token

        while (++eventIndex <= events.length) {
          if (
            (eventIndex === events.length ||
        events[eventIndex][1].type === 'lineEnding') &&
      events[eventIndex - 1][1].type === 'data'
          ) {
            data = events[eventIndex - 1][1]
            chunks = context.sliceStream(data)
            index = chunks.length
            bufferIndex = -1
            size = 0
            tabs = undefined

            while (index--) {
              chunk = chunks[index]

              if (typeof chunk === 'string') {
                bufferIndex = chunk.length

                while (chunk.charCodeAt(bufferIndex - 1) === 32) {
                  size++
                  bufferIndex--
                }

                if (bufferIndex) break
                bufferIndex = -1
              } // Number
              else if (chunk === -2) {
                tabs = true
                size++
              } else if (chunk === -1);
              else {
          // Replacement character, exit.
                index++
                break
              }
            }

            if (size) {
              token = {
                type:
            eventIndex === events.length || tabs || size < 2
              ? 'lineSuffix'
              : 'hardBreakTrailing',
                start: {
                  line: data.end.line,
                  column: data.end.column - size,
                  offset: data.end.offset - size,
                  _index: data.start._index + index,
                  _bufferIndex: index
                    ? bufferIndex
                    : data.start._bufferIndex + bufferIndex
                },
                end: shallow(data.end)
              }
              data.end = shallow(token.start)

              if (data.start.offset === data.end.offset) {
                assign(data, token)
              } else {
                events.splice(
                  eventIndex,
                  0,
                  ['enter', token, context],
                  ['exit', token, context]
                )
                eventIndex += 2
              }
            }

            eventIndex++
          }
        }

        return events
      }

      exports.resolver = resolver
      exports.string = string
      exports.text = text


/***/ }),

/***/ "../../node_modules/micromark/dist/parse.js":
/*!**************************************************!*\
  !*** ../../node_modules/micromark/dist/parse.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const content = __webpack_require__(/*! ./initialize/content.js */ "../../node_modules/micromark/dist/initialize/content.js")
      const document = __webpack_require__(/*! ./initialize/document.js */ "../../node_modules/micromark/dist/initialize/document.js")
      const flow = __webpack_require__(/*! ./initialize/flow.js */ "../../node_modules/micromark/dist/initialize/flow.js")
      const text = __webpack_require__(/*! ./initialize/text.js */ "../../node_modules/micromark/dist/initialize/text.js")
      const combineExtensions = __webpack_require__(/*! ./util/combine-extensions.js */ "../../node_modules/micromark/dist/util/combine-extensions.js")
      const createTokenizer = __webpack_require__(/*! ./util/create-tokenizer.js */ "../../node_modules/micromark/dist/util/create-tokenizer.js")
      const miniflat = __webpack_require__(/*! ./util/miniflat.js */ "../../node_modules/micromark/dist/util/miniflat.js")
      const constructs = __webpack_require__(/*! ./constructs.js */ "../../node_modules/micromark/dist/constructs.js")

      function parse(options) {
        const settings = options || {}
        const parser = {
          defined: [],
          constructs: combineExtensions(
            [constructs].concat(miniflat(settings.extensions))
          ),
          content: create(content),
          document: create(document),
          flow: create(flow),
          string: create(text.string),
          text: create(text.text)
        }
        return parser

        function create(initializer) {
          return creator

          function creator(from) {
            return createTokenizer(parser, initializer, from)
          }
        }
      }

      module.exports = parse


/***/ }),

/***/ "../../node_modules/micromark/dist/postprocess.js":
/*!********************************************************!*\
  !*** ../../node_modules/micromark/dist/postprocess.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const subtokenize = __webpack_require__(/*! ./util/subtokenize.js */ "../../node_modules/micromark/dist/util/subtokenize.js")

      function postprocess(events) {
        while (!subtokenize(events)) {
    // Empty
        }

        return events
      }

      module.exports = postprocess


/***/ }),

/***/ "../../node_modules/micromark/dist/preprocess.js":
/*!*******************************************************!*\
  !*** ../../node_modules/micromark/dist/preprocess.js ***!
  \*******************************************************/
/***/ ((module) => {

      "use strict";


      const search = /[\0\t\n\r]/g

      function preprocess() {
        let start = true
        let column = 1
        let buffer = ''
        let atCarriageReturn
        return preprocessor

        function preprocessor(value, encoding, end) {
          const chunks = []
          let match
          let next
          let startPosition
          let endPosition
          let code
          value = buffer + value.toString(encoding)
          startPosition = 0
          buffer = ''

          if (start) {
            if (value.charCodeAt(0) === 65279) {
              startPosition++
            }

            start = undefined
          }

          while (startPosition < value.length) {
            search.lastIndex = startPosition
            match = search.exec(value)
            endPosition = match ? match.index : value.length
            code = value.charCodeAt(endPosition)

            if (!match) {
              buffer = value.slice(startPosition)
              break
            }

            if (code === 10 && startPosition === endPosition && atCarriageReturn) {
              chunks.push(-3)
              atCarriageReturn = undefined
            } else {
              if (atCarriageReturn) {
                chunks.push(-5)
                atCarriageReturn = undefined
              }

              if (startPosition < endPosition) {
                chunks.push(value.slice(startPosition, endPosition))
                column += endPosition - startPosition
              }

              if (code === 0) {
                chunks.push(65533)
                column++
              } else if (code === 9) {
                next = Math.ceil(column / 4) * 4
                chunks.push(-2)

                while (column++ < next) chunks.push(-1)
              } else if (code === 10) {
                chunks.push(-4)
                column = 1
              } // Must be carriage return.
              else {
                atCarriageReturn = true
                column = 1
              }
            }

            startPosition = endPosition + 1
          }

          if (end) {
            if (atCarriageReturn) chunks.push(-5)
            if (buffer) chunks.push(buffer)
            chunks.push(null)
          }

          return chunks
        }
      }

      module.exports = preprocess


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/attention.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/attention.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const chunkedPush = __webpack_require__(/*! ../util/chunked-push.js */ "../../node_modules/micromark/dist/util/chunked-push.js")
      const chunkedSplice = __webpack_require__(/*! ../util/chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
      const classifyCharacter = __webpack_require__(/*! ../util/classify-character.js */ "../../node_modules/micromark/dist/util/classify-character.js")
      const movePoint = __webpack_require__(/*! ../util/move-point.js */ "../../node_modules/micromark/dist/util/move-point.js")
      const resolveAll = __webpack_require__(/*! ../util/resolve-all.js */ "../../node_modules/micromark/dist/util/resolve-all.js")
      const shallow = __webpack_require__(/*! ../util/shallow.js */ "../../node_modules/micromark/dist/util/shallow.js")

      const attention = {
        name: 'attention',
        tokenize: tokenizeAttention,
        resolveAll: resolveAllAttention
      }

      function resolveAllAttention(events, context) {
        let index = -1
        let open
        let group
        let text
        let openingSequence
        let closingSequence
        let use
        let nextEvents
        let offset // Walk through all events.
  //
  // Note: performance of this is fine on an mb of normal markdown, but it’s
  // a bottleneck for malicious stuff.

        while (++index < events.length) {
    // Find a token that can close.
          if (
            events[index][0] === 'enter' &&
      events[index][1].type === 'attentionSequence' &&
      events[index][1]._close
          ) {
            open = index // Now walk back to find an opener.

            while (open--) {
        // Find a token that can open the closer.
              if (
                events[open][0] === 'exit' &&
          events[open][1].type === 'attentionSequence' &&
          events[open][1]._open && // If the markers are the same:
          context.sliceSerialize(events[open][1]).charCodeAt(0) ===
            context.sliceSerialize(events[index][1]).charCodeAt(0)
              ) {
          // If the opening can close or the closing can open,
          // and the close size *is not* a multiple of three,
          // but the sum of the opening and closing size *is* multiple of three,
          // then don’t match.
                if (
                  (events[open][1]._close || events[index][1]._open) &&
            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&
            !(
              (events[open][1].end.offset -
                events[open][1].start.offset +
                events[index][1].end.offset -
                events[index][1].start.offset) %
              3
            )
                ) {
                  continue
                } // Number of markers to use from the sequence.

                use =
            events[open][1].end.offset - events[open][1].start.offset > 1 &&
            events[index][1].end.offset - events[index][1].start.offset > 1
              ? 2
              : 1
                openingSequence = {
                  type: use > 1 ? 'strongSequence' : 'emphasisSequence',
                  start: movePoint(shallow(events[open][1].end), -use),
                  end: shallow(events[open][1].end)
                }
                closingSequence = {
                  type: use > 1 ? 'strongSequence' : 'emphasisSequence',
                  start: shallow(events[index][1].start),
                  end: movePoint(shallow(events[index][1].start), use)
                }
                text = {
                  type: use > 1 ? 'strongText' : 'emphasisText',
                  start: shallow(events[open][1].end),
                  end: shallow(events[index][1].start)
                }
                group = {
                  type: use > 1 ? 'strong' : 'emphasis',
                  start: shallow(openingSequence.start),
                  end: shallow(closingSequence.end)
                }
                events[open][1].end = shallow(openingSequence.start)
                events[index][1].start = shallow(closingSequence.end)
                nextEvents = [] // If there are more markers in the opening, add them before.

                if (events[open][1].end.offset - events[open][1].start.offset) {
                  nextEvents = chunkedPush(nextEvents, [
                    ['enter', events[open][1], context],
                    ['exit', events[open][1], context]
                  ])
                } // Opening.

                nextEvents = chunkedPush(nextEvents, [
                  ['enter', group, context],
                  ['enter', openingSequence, context],
                  ['exit', openingSequence, context],
                  ['enter', text, context]
                ]) // Between.

                nextEvents = chunkedPush(
                  nextEvents,
                  resolveAll(
                    context.parser.constructs.insideSpan.null,
                    events.slice(open + 1, index),
                    context
                  )
                ) // Closing.

                nextEvents = chunkedPush(nextEvents, [
                  ['exit', text, context],
                  ['enter', closingSequence, context],
                  ['exit', closingSequence, context],
                  ['exit', group, context]
                ]) // If there are more markers in the closing, add them after.

                if (events[index][1].end.offset - events[index][1].start.offset) {
                  offset = 2
                  nextEvents = chunkedPush(nextEvents, [
                    ['enter', events[index][1], context],
                    ['exit', events[index][1], context]
                  ])
                } else {
                  offset = 0
                }

                chunkedSplice(events, open - 1, index - open + 3, nextEvents)
                index = open + nextEvents.length - offset - 2
                break
              }
            }
          }
        } // Remove remaining sequences.

        index = -1

        while (++index < events.length) {
          if (events[index][1].type === 'attentionSequence') {
            events[index][1].type = 'data'
          }
        }

        return events
      }

      function tokenizeAttention(effects, ok) {
        const before = classifyCharacter(this.previous)
        let marker
        return start

        function start(code) {
          effects.enter('attentionSequence')
          marker = code
          return sequence(code)
        }

        function sequence(code) {
          let token
          let after
          let open
          let close

          if (code === marker) {
            effects.consume(code)
            return sequence
          }

          token = effects.exit('attentionSequence')
          after = classifyCharacter(code)
          open = !after || (after === 2 && before)
          close = !before || (before === 2 && after)
          token._open = marker === 42 ? open : open && (before || !close)
          token._close = marker === 42 ? close : close && (after || !open)
          return ok(code)
        }
      }

      module.exports = attention


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/autolink.js":
/*!**************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/autolink.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const asciiAlpha = __webpack_require__(/*! ../character/ascii-alpha.js */ "../../node_modules/micromark/dist/character/ascii-alpha.js")
      const asciiAlphanumeric = __webpack_require__(/*! ../character/ascii-alphanumeric.js */ "../../node_modules/micromark/dist/character/ascii-alphanumeric.js")
      const asciiAtext = __webpack_require__(/*! ../character/ascii-atext.js */ "../../node_modules/micromark/dist/character/ascii-atext.js")
      const asciiControl = __webpack_require__(/*! ../character/ascii-control.js */ "../../node_modules/micromark/dist/character/ascii-control.js")

      const autolink = {
        name: 'autolink',
        tokenize: tokenizeAutolink
      }

      function tokenizeAutolink(effects, ok, nok) {
        let size = 1
        return start

        function start(code) {
          effects.enter('autolink')
          effects.enter('autolinkMarker')
          effects.consume(code)
          effects.exit('autolinkMarker')
          effects.enter('autolinkProtocol')
          return open
        }

        function open(code) {
          if (asciiAlpha(code)) {
            effects.consume(code)
            return schemeOrEmailAtext
          }

          return asciiAtext(code) ? emailAtext(code) : nok(code)
        }

        function schemeOrEmailAtext(code) {
          return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)
            ? schemeInsideOrEmailAtext(code)
            : emailAtext(code)
        }

        function schemeInsideOrEmailAtext(code) {
          if (code === 58) {
            effects.consume(code)
            return urlInside
          }

          if (
            (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) &&
      size++ < 32
          ) {
            effects.consume(code)
            return schemeInsideOrEmailAtext
          }

          return emailAtext(code)
        }

        function urlInside(code) {
          if (code === 62) {
            effects.exit('autolinkProtocol')
            return end(code)
          }

          if (code === 32 || code === 60 || asciiControl(code)) {
            return nok(code)
          }

          effects.consume(code)
          return urlInside
        }

        function emailAtext(code) {
          if (code === 64) {
            effects.consume(code)
            size = 0
            return emailAtSignOrDot
          }

          if (asciiAtext(code)) {
            effects.consume(code)
            return emailAtext
          }

          return nok(code)
        }

        function emailAtSignOrDot(code) {
          return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)
        }

        function emailLabel(code) {
          if (code === 46) {
            effects.consume(code)
            size = 0
            return emailAtSignOrDot
          }

          if (code === 62) {
      // Exit, then change the type.
            effects.exit('autolinkProtocol').type = 'autolinkEmail'
            return end(code)
          }

          return emailValue(code)
        }

        function emailValue(code) {
          if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {
            effects.consume(code)
            return code === 45 ? emailValue : emailLabel
          }

          return nok(code)
        }

        function end(code) {
          effects.enter('autolinkMarker')
          effects.consume(code)
          effects.exit('autolinkMarker')
          effects.exit('autolink')
          return ok
        }
      }

      module.exports = autolink


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/block-quote.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/block-quote.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

      const blockQuote = {
        name: 'blockQuote',
        tokenize: tokenizeBlockQuoteStart,
        continuation: {
          tokenize: tokenizeBlockQuoteContinuation
        },
        exit: exit
      }

      function tokenizeBlockQuoteStart(effects, ok, nok) {
        const self = this
        return start

        function start(code) {
          if (code === 62) {
            if (!self.containerState.open) {
              effects.enter('blockQuote', {
                _container: true
              })
              self.containerState.open = true
            }

            effects.enter('blockQuotePrefix')
            effects.enter('blockQuoteMarker')
            effects.consume(code)
            effects.exit('blockQuoteMarker')
            return after
          }

          return nok(code)
        }

        function after(code) {
          if (markdownSpace(code)) {
            effects.enter('blockQuotePrefixWhitespace')
            effects.consume(code)
            effects.exit('blockQuotePrefixWhitespace')
            effects.exit('blockQuotePrefix')
            return ok
          }

          effects.exit('blockQuotePrefix')
          return ok(code)
        }
      }

      function tokenizeBlockQuoteContinuation(effects, ok, nok) {
        return factorySpace(
          effects,
          effects.attempt(blockQuote, ok, nok),
          'linePrefix',
          this.parser.constructs.disable.null.indexOf('codeIndented') > -1
            ? undefined
            : 4
        )
      }

      function exit(effects) {
        effects.exit('blockQuote')
      }

      module.exports = blockQuote


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/character-escape.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/character-escape.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const asciiPunctuation = __webpack_require__(/*! ../character/ascii-punctuation.js */ "../../node_modules/micromark/dist/character/ascii-punctuation.js")

      const characterEscape = {
        name: 'characterEscape',
        tokenize: tokenizeCharacterEscape
      }

      function tokenizeCharacterEscape(effects, ok, nok) {
        return start

        function start(code) {
          effects.enter('characterEscape')
          effects.enter('escapeMarker')
          effects.consume(code)
          effects.exit('escapeMarker')
          return open
        }

        function open(code) {
          if (asciiPunctuation(code)) {
            effects.enter('characterEscapeValue')
            effects.consume(code)
            effects.exit('characterEscapeValue')
            effects.exit('characterEscape')
            return ok
          }

          return nok(code)
        }
      }

      module.exports = characterEscape


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/character-reference.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/character-reference.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const decodeEntity = __webpack_require__(/*! parse-entities/decode-entity.js */ "../../node_modules/parse-entities/decode-entity.browser.js")
      const asciiAlphanumeric = __webpack_require__(/*! ../character/ascii-alphanumeric.js */ "../../node_modules/micromark/dist/character/ascii-alphanumeric.js")
      const asciiDigit = __webpack_require__(/*! ../character/ascii-digit.js */ "../../node_modules/micromark/dist/character/ascii-digit.js")
      const asciiHexDigit = __webpack_require__(/*! ../character/ascii-hex-digit.js */ "../../node_modules/micromark/dist/character/ascii-hex-digit.js")

      function _interopDefaultLegacy(e) {
        return e && typeof e === 'object' && 'default' in e ? e : {default: e}
      }

      const decodeEntity__default = /*#__PURE__*/ _interopDefaultLegacy(decodeEntity)

      const characterReference = {
        name: 'characterReference',
        tokenize: tokenizeCharacterReference
      }

      function tokenizeCharacterReference(effects, ok, nok) {
        const self = this
        let size = 0
        let max
        let test
        return start

        function start(code) {
          effects.enter('characterReference')
          effects.enter('characterReferenceMarker')
          effects.consume(code)
          effects.exit('characterReferenceMarker')
          return open
        }

        function open(code) {
          if (code === 35) {
            effects.enter('characterReferenceMarkerNumeric')
            effects.consume(code)
            effects.exit('characterReferenceMarkerNumeric')
            return numeric
          }

          effects.enter('characterReferenceValue')
          max = 31
          test = asciiAlphanumeric
          return value(code)
        }

        function numeric(code) {
          if (code === 88 || code === 120) {
            effects.enter('characterReferenceMarkerHexadecimal')
            effects.consume(code)
            effects.exit('characterReferenceMarkerHexadecimal')
            effects.enter('characterReferenceValue')
            max = 6
            test = asciiHexDigit
            return value
          }

          effects.enter('characterReferenceValue')
          max = 7
          test = asciiDigit
          return value(code)
        }

        function value(code) {
          let token

          if (code === 59 && size) {
            token = effects.exit('characterReferenceValue')

            if (
              test === asciiAlphanumeric &&
        !decodeEntity__default['default'](self.sliceSerialize(token))
            ) {
              return nok(code)
            }

            effects.enter('characterReferenceMarker')
            effects.consume(code)
            effects.exit('characterReferenceMarker')
            effects.exit('characterReference')
            return ok
          }

          if (test(code) && size++ < max) {
            effects.consume(code)
            return value
          }

          return nok(code)
        }
      }

      module.exports = characterReference


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/code-fenced.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/code-fenced.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
      const prefixSize = __webpack_require__(/*! ../util/prefix-size.js */ "../../node_modules/micromark/dist/util/prefix-size.js")
      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

      const codeFenced = {
        name: 'codeFenced',
        tokenize: tokenizeCodeFenced,
        concrete: true
      }

      function tokenizeCodeFenced(effects, ok, nok) {
        const self = this
        const closingFenceConstruct = {
          tokenize: tokenizeClosingFence,
          partial: true
        }
        const initialPrefix = prefixSize(this.events, 'linePrefix')
        let sizeOpen = 0
        let marker
        return start

        function start(code) {
          effects.enter('codeFenced')
          effects.enter('codeFencedFence')
          effects.enter('codeFencedFenceSequence')
          marker = code
          return sequenceOpen(code)
        }

        function sequenceOpen(code) {
          if (code === marker) {
            effects.consume(code)
            sizeOpen++
            return sequenceOpen
          }

          effects.exit('codeFencedFenceSequence')
          return sizeOpen < 3
            ? nok(code)
            : factorySpace(effects, infoOpen, 'whitespace')(code)
        }

        function infoOpen(code) {
          if (code === null || markdownLineEnding(code)) {
            return openAfter(code)
          }

          effects.enter('codeFencedFenceInfo')
          effects.enter('chunkString', {
            contentType: 'string'
          })
          return info(code)
        }

        function info(code) {
          if (code === null || markdownLineEndingOrSpace(code)) {
            effects.exit('chunkString')
            effects.exit('codeFencedFenceInfo')
            return factorySpace(effects, infoAfter, 'whitespace')(code)
          }

          if (code === 96 && code === marker) return nok(code)
          effects.consume(code)
          return info
        }

        function infoAfter(code) {
          if (code === null || markdownLineEnding(code)) {
            return openAfter(code)
          }

          effects.enter('codeFencedFenceMeta')
          effects.enter('chunkString', {
            contentType: 'string'
          })
          return meta(code)
        }

        function meta(code) {
          if (code === null || markdownLineEnding(code)) {
            effects.exit('chunkString')
            effects.exit('codeFencedFenceMeta')
            return openAfter(code)
          }

          if (code === 96 && code === marker) return nok(code)
          effects.consume(code)
          return meta
        }

        function openAfter(code) {
          effects.exit('codeFencedFence')
          return self.interrupt ? ok(code) : content(code)
        }

        function content(code) {
          if (code === null) {
            return after(code)
          }

          if (markdownLineEnding(code)) {
            effects.enter('lineEnding')
            effects.consume(code)
            effects.exit('lineEnding')
            return effects.attempt(
              closingFenceConstruct,
              after,
              initialPrefix
                ? factorySpace(effects, content, 'linePrefix', initialPrefix + 1)
                : content
            )
          }

          effects.enter('codeFlowValue')
          return contentContinue(code)
        }

        function contentContinue(code) {
          if (code === null || markdownLineEnding(code)) {
            effects.exit('codeFlowValue')
            return content(code)
          }

          effects.consume(code)
          return contentContinue
        }

        function after(code) {
          effects.exit('codeFenced')
          return ok(code)
        }

        function tokenizeClosingFence(effects, ok, nok) {
          let size = 0
          return factorySpace(
            effects,
            closingSequenceStart,
            'linePrefix',
            this.parser.constructs.disable.null.indexOf('codeIndented') > -1
              ? undefined
              : 4
          )

          function closingSequenceStart(code) {
            effects.enter('codeFencedFence')
            effects.enter('codeFencedFenceSequence')
            return closingSequence(code)
          }

          function closingSequence(code) {
            if (code === marker) {
              effects.consume(code)
              size++
              return closingSequence
            }

            if (size < sizeOpen) return nok(code)
            effects.exit('codeFencedFenceSequence')
            return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)
          }

          function closingSequenceEnd(code) {
            if (code === null || markdownLineEnding(code)) {
              effects.exit('codeFencedFence')
              return ok(code)
            }

            return nok(code)
          }
        }
      }

      module.exports = codeFenced


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/code-indented.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/code-indented.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const chunkedSplice = __webpack_require__(/*! ../util/chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
      const prefixSize = __webpack_require__(/*! ../util/prefix-size.js */ "../../node_modules/micromark/dist/util/prefix-size.js")
      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

      const codeIndented = {
        name: 'codeIndented',
        tokenize: tokenizeCodeIndented,
        resolve: resolveCodeIndented
      }
      const indentedContentConstruct = {
        tokenize: tokenizeIndentedContent,
        partial: true
      }

      function resolveCodeIndented(events, context) {
        const code = {
          type: 'codeIndented',
          start: events[0][1].start,
          end: events[events.length - 1][1].end
        }
        chunkedSplice(events, 0, 0, [['enter', code, context]])
        chunkedSplice(events, events.length, 0, [['exit', code, context]])
        return events
      }

      function tokenizeCodeIndented(effects, ok, nok) {
        return effects.attempt(indentedContentConstruct, afterPrefix, nok)

        function afterPrefix(code) {
          if (code === null) {
            return ok(code)
          }

          if (markdownLineEnding(code)) {
            return effects.attempt(indentedContentConstruct, afterPrefix, ok)(code)
          }

          effects.enter('codeFlowValue')
          return content(code)
        }

        function content(code) {
          if (code === null || markdownLineEnding(code)) {
            effects.exit('codeFlowValue')
            return afterPrefix(code)
          }

          effects.consume(code)
          return content
        }
      }

      function tokenizeIndentedContent(effects, ok, nok) {
        const self = this
        return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)

        function afterPrefix(code) {
          if (markdownLineEnding(code)) {
            effects.enter('lineEnding')
            effects.consume(code)
            effects.exit('lineEnding')
            return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)
          }

          return prefixSize(self.events, 'linePrefix') < 4 ? nok(code) : ok(code)
        }
      }

      module.exports = codeIndented


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/code-text.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/code-text.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")

      const codeText = {
        name: 'codeText',
        tokenize: tokenizeCodeText,
        resolve: resolveCodeText,
        previous: previous
      }

      function resolveCodeText(events) {
        let tailExitIndex = events.length - 4
        let headEnterIndex = 3
        let index
        let enter // If we start and end with an EOL or a space.

        if (
          (events[headEnterIndex][1].type === 'lineEnding' ||
      events[headEnterIndex][1].type === 'space') &&
    (events[tailExitIndex][1].type === 'lineEnding' ||
      events[tailExitIndex][1].type === 'space')
        ) {
          index = headEnterIndex // And we have data.

          while (++index < tailExitIndex) {
            if (events[index][1].type === 'codeTextData') {
        // Then we have padding.
              events[tailExitIndex][1].type = events[headEnterIndex][1].type =
          'codeTextPadding'
              headEnterIndex += 2
              tailExitIndex -= 2
              break
            }
          }
        } // Merge adjacent spaces and data.

        index = headEnterIndex - 1
        tailExitIndex++

        while (++index <= tailExitIndex) {
          if (enter === undefined) {
            if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {
              enter = index
            }
          } else if (
            index === tailExitIndex ||
      events[index][1].type === 'lineEnding'
          ) {
            events[enter][1].type = 'codeTextData'

            if (index !== enter + 2) {
              events[enter][1].end = events[index - 1][1].end
              events.splice(enter + 2, index - enter - 2)
              tailExitIndex -= index - enter - 2
              index = enter + 2
            }

            enter = undefined
          }
        }

        return events
      }

      function previous(code) {
  // If there is a previous code, there will always be a tail.
        return (
          code !== 96 ||
    this.events[this.events.length - 1][1].type === 'characterEscape'
        )
      }

      function tokenizeCodeText(effects, ok, nok) {
        let sizeOpen = 0
        let size
        let token
        return start

        function start(code) {
          effects.enter('codeText')
          effects.enter('codeTextSequence')
          return openingSequence(code)
        }

        function openingSequence(code) {
          if (code === 96) {
            effects.consume(code)
            sizeOpen++
            return openingSequence
          }

          effects.exit('codeTextSequence')
          return gap(code)
        }

        function gap(code) {
    // EOF.
          if (code === null) {
            return nok(code)
          } // Closing fence?
    // Could also be data.

          if (code === 96) {
            token = effects.enter('codeTextSequence')
            size = 0
            return closingSequence(code)
          } // Tabs don’t work, and virtual spaces don’t make sense.

          if (code === 32) {
            effects.enter('space')
            effects.consume(code)
            effects.exit('space')
            return gap
          }

          if (markdownLineEnding(code)) {
            effects.enter('lineEnding')
            effects.consume(code)
            effects.exit('lineEnding')
            return gap
          } // Data.

          effects.enter('codeTextData')
          return data(code)
        } // In code.

        function data(code) {
          if (
            code === null ||
      code === 32 ||
      code === 96 ||
      markdownLineEnding(code)
          ) {
            effects.exit('codeTextData')
            return gap(code)
          }

          effects.consume(code)
          return data
        } // Closing fence.

        function closingSequence(code) {
    // More.
          if (code === 96) {
            effects.consume(code)
            size++
            return closingSequence
          } // Done!

          if (size === sizeOpen) {
            effects.exit('codeTextSequence')
            effects.exit('codeText')
            return ok(code)
          } // More or less accents: mark as data.

          token.type = 'codeTextData'
          return data(code)
        }
      }

      module.exports = codeText


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/content.js":
/*!*************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/content.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const prefixSize = __webpack_require__(/*! ../util/prefix-size.js */ "../../node_modules/micromark/dist/util/prefix-size.js")
      const subtokenize = __webpack_require__(/*! ../util/subtokenize.js */ "../../node_modules/micromark/dist/util/subtokenize.js")
      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

// No name because it must not be turned off.
      const content = {
        tokenize: tokenizeContent,
        resolve: resolveContent,
        interruptible: true,
        lazy: true
      }
      const continuationConstruct = {
        tokenize: tokenizeContinuation,
        partial: true
      } // Content is transparent: it’s parsed right now. That way, definitions are also
// parsed right now: before text in paragraphs (specifically, media) are parsed.

      function resolveContent(events) {
        subtokenize(events)
        return events
      }

      function tokenizeContent(effects, ok) {
        let previous
        return start

        function start(code) {
          effects.enter('content')
          previous = effects.enter('chunkContent', {
            contentType: 'content'
          })
          return data(code)
        }

        function data(code) {
          if (code === null) {
            return contentEnd(code)
          }

          if (markdownLineEnding(code)) {
            return effects.check(
              continuationConstruct,
              contentContinue,
              contentEnd
            )(code)
          } // Data.

          effects.consume(code)
          return data
        }

        function contentEnd(code) {
          effects.exit('chunkContent')
          effects.exit('content')
          return ok(code)
        }

        function contentContinue(code) {
          effects.consume(code)
          effects.exit('chunkContent')
          previous = previous.next = effects.enter('chunkContent', {
            contentType: 'content',
            previous: previous
          })
          return data
        }
      }

      function tokenizeContinuation(effects, ok, nok) {
        const self = this
        return startLookahead

        function startLookahead(code) {
          effects.enter('lineEnding')
          effects.consume(code)
          effects.exit('lineEnding')
          return factorySpace(effects, prefixed, 'linePrefix')
        }

        function prefixed(code) {
          if (code === null || markdownLineEnding(code)) {
            return nok(code)
          }

          if (
            self.parser.constructs.disable.null.indexOf('codeIndented') > -1 ||
      prefixSize(self.events, 'linePrefix') < 4
          ) {
            return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)
          }

          return ok(code)
        }
      }

      module.exports = content


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/definition.js":
/*!****************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/definition.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
      const normalizeIdentifier = __webpack_require__(/*! ../util/normalize-identifier.js */ "../../node_modules/micromark/dist/util/normalize-identifier.js")
      const factoryDestination = __webpack_require__(/*! ./factory-destination.js */ "../../node_modules/micromark/dist/tokenize/factory-destination.js")
      const factoryLabel = __webpack_require__(/*! ./factory-label.js */ "../../node_modules/micromark/dist/tokenize/factory-label.js")
      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")
      const factoryWhitespace = __webpack_require__(/*! ./factory-whitespace.js */ "../../node_modules/micromark/dist/tokenize/factory-whitespace.js")
      const factoryTitle = __webpack_require__(/*! ./factory-title.js */ "../../node_modules/micromark/dist/tokenize/factory-title.js")

      const definition = {
        name: 'definition',
        tokenize: tokenizeDefinition
      }
      const titleConstruct = {
        tokenize: tokenizeTitle,
        partial: true
      }

      function tokenizeDefinition(effects, ok, nok) {
        const self = this
        let identifier
        return start

        function start(code) {
          effects.enter('definition')
          return factoryLabel.call(
            self,
            effects,
            labelAfter,
            nok,
            'definitionLabel',
            'definitionLabelMarker',
            'definitionLabelString'
          )(code)
        }

        function labelAfter(code) {
          identifier = normalizeIdentifier(
            self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
          )

          if (code === 58) {
            effects.enter('definitionMarker')
            effects.consume(code)
            effects.exit('definitionMarker') // Note: blank lines can’t exist in content.

            return factoryWhitespace(
              effects,
              factoryDestination(
                effects,
                effects.attempt(
                  titleConstruct,
                  factorySpace(effects, after, 'whitespace'),
                  factorySpace(effects, after, 'whitespace')
                ),
                nok,
                'definitionDestination',
                'definitionDestinationLiteral',
                'definitionDestinationLiteralMarker',
                'definitionDestinationRaw',
                'definitionDestinationString'
              )
            )
          }

          return nok(code)
        }

        function after(code) {
          if (code === null || markdownLineEnding(code)) {
            effects.exit('definition')

            if (self.parser.defined.indexOf(identifier) < 0) {
              self.parser.defined.push(identifier)
            }

            return ok(code)
          }

          return nok(code)
        }
      }

      function tokenizeTitle(effects, ok, nok) {
        return start

        function start(code) {
          return markdownLineEndingOrSpace(code)
            ? factoryWhitespace(effects, before)(code)
            : nok(code)
        }

        function before(code) {
          if (code === 34 || code === 39 || code === 40) {
            return factoryTitle(
              effects,
              factorySpace(effects, after, 'whitespace'),
              nok,
              'definitionTitle',
              'definitionTitleMarker',
              'definitionTitleString'
            )(code)
          }

          return nok(code)
        }

        function after(code) {
          return code === null || markdownLineEnding(code) ? ok(code) : nok(code)
        }
      }

      module.exports = definition


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/factory-destination.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/factory-destination.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const asciiControl = __webpack_require__(/*! ../character/ascii-control.js */ "../../node_modules/micromark/dist/character/ascii-control.js")
      const markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")

// eslint-disable-next-line max-params
      function destinationFactory(
        effects,
        ok,
        nok,
        type,
        literalType,
        literalMarkerType,
        rawType,
        stringType,
        max
      ) {
        const limit = max || Infinity
        let balance = 0
        return start

        function start(code) {
          if (code === 60) {
            effects.enter(type)
            effects.enter(literalType)
            effects.enter(literalMarkerType)
            effects.consume(code)
            effects.exit(literalMarkerType)
            return destinationEnclosedBefore
          }

          if (asciiControl(code) || code === 41) {
            return nok(code)
          }

          effects.enter(type)
          effects.enter(rawType)
          effects.enter(stringType)
          effects.enter('chunkString', {
            contentType: 'string'
          })
          return destinationRaw(code)
        }

        function destinationEnclosedBefore(code) {
          if (code === 62) {
            effects.enter(literalMarkerType)
            effects.consume(code)
            effects.exit(literalMarkerType)
            effects.exit(literalType)
            effects.exit(type)
            return ok
          }

          effects.enter(stringType)
          effects.enter('chunkString', {
            contentType: 'string'
          })
          return destinationEnclosed(code)
        }

        function destinationEnclosed(code) {
          if (code === 62) {
            effects.exit('chunkString')
            effects.exit(stringType)
            return destinationEnclosedBefore(code)
          }

          if (code === null || code === 60 || markdownLineEnding(code)) {
            return nok(code)
          }

          effects.consume(code)
          return code === 92 ? destinationEnclosedEscape : destinationEnclosed
        }

        function destinationEnclosedEscape(code) {
          if (code === 60 || code === 62 || code === 92) {
            effects.consume(code)
            return destinationEnclosed
          }

          return destinationEnclosed(code)
        }

        function destinationRaw(code) {
          if (code === 40) {
            if (++balance > limit) return nok(code)
            effects.consume(code)
            return destinationRaw
          }

          if (code === 41) {
            if (!balance--) {
              effects.exit('chunkString')
              effects.exit(stringType)
              effects.exit(rawType)
              effects.exit(type)
              return ok(code)
            }

            effects.consume(code)
            return destinationRaw
          }

          if (code === null || markdownLineEndingOrSpace(code)) {
            if (balance) return nok(code)
            effects.exit('chunkString')
            effects.exit(stringType)
            effects.exit(rawType)
            effects.exit(type)
            return ok(code)
          }

          if (asciiControl(code)) return nok(code)
          effects.consume(code)
          return code === 92 ? destinationRawEscape : destinationRaw
        }

        function destinationRawEscape(code) {
          if (code === 40 || code === 41 || code === 92) {
            effects.consume(code)
            return destinationRaw
          }

          return destinationRaw(code)
        }
      }

      module.exports = destinationFactory


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/factory-label.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/factory-label.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")

// eslint-disable-next-line max-params
      function labelFactory(effects, ok, nok, type, markerType, stringType) {
        const self = this
        let size = 0
        let data
        return start

        function start(code) {
          effects.enter(type)
          effects.enter(markerType)
          effects.consume(code)
          effects.exit(markerType)
          effects.enter(stringType)
          return atBreak
        }

        function atBreak(code) {
          if (
            code === null ||
      code === 91 ||
      (code === 93 && !data) ||
      /* c8 ignore next */
      (code === 94 &&
        /* c8 ignore next */
        !size &&
        /* c8 ignore next */
        '_hiddenFootnoteSupport' in self.parser.constructs) ||
      size > 999
          ) {
            return nok(code)
          }

          if (code === 93) {
            effects.exit(stringType)
            effects.enter(markerType)
            effects.consume(code)
            effects.exit(markerType)
            effects.exit(type)
            return ok
          }

          if (markdownLineEnding(code)) {
            effects.enter('lineEnding')
            effects.consume(code)
            effects.exit('lineEnding')
            return atBreak
          }

          effects.enter('chunkString', {
            contentType: 'string'
          })
          return label(code)
        }

        function label(code) {
          if (
            code === null ||
      code === 91 ||
      code === 93 ||
      markdownLineEnding(code) ||
      size++ > 999
          ) {
            effects.exit('chunkString')
            return atBreak(code)
          }

          effects.consume(code)
          data = data || !markdownSpace(code)
          return code === 92 ? labelEscape : label
        }

        function labelEscape(code) {
          if (code === 91 || code === 92 || code === 93) {
            effects.consume(code)
            size++
            return label
          }

          return label(code)
        }
      }

      module.exports = labelFactory


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/factory-space.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/factory-space.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")

      function spaceFactory(effects, ok, type, max) {
        const limit = max ? max - 1 : Infinity
        let size = 0
        return start

        function start(code) {
          if (markdownSpace(code)) {
            effects.enter(type)
            return prefix(code)
          }

          return ok(code)
        }

        function prefix(code) {
          if (markdownSpace(code) && size++ < limit) {
            effects.consume(code)
            return prefix
          }

          effects.exit(type)
          return ok(code)
        }
      }

      module.exports = spaceFactory


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/factory-title.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/factory-title.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

      function titleFactory(effects, ok, nok, type, markerType, stringType) {
        let marker
        return start

        function start(code) {
          effects.enter(type)
          effects.enter(markerType)
          effects.consume(code)
          effects.exit(markerType)
          marker = code === 40 ? 41 : code
          return atFirstTitleBreak
        }

        function atFirstTitleBreak(code) {
          if (code === marker) {
            effects.enter(markerType)
            effects.consume(code)
            effects.exit(markerType)
            effects.exit(type)
            return ok
          }

          effects.enter(stringType)
          return atTitleBreak(code)
        }

        function atTitleBreak(code) {
          if (code === marker) {
            effects.exit(stringType)
            return atFirstTitleBreak(marker)
          }

          if (code === null) {
            return nok(code)
          } // Note: blank lines can’t exist in content.

          if (markdownLineEnding(code)) {
            effects.enter('lineEnding')
            effects.consume(code)
            effects.exit('lineEnding')
            return factorySpace(effects, atTitleBreak, 'linePrefix')
          }

          effects.enter('chunkString', {
            contentType: 'string'
          })
          return title(code)
        }

        function title(code) {
          if (code === marker || code === null || markdownLineEnding(code)) {
            effects.exit('chunkString')
            return atTitleBreak(code)
          }

          effects.consume(code)
          return code === 92 ? titleEscape : title
        }

        function titleEscape(code) {
          if (code === marker || code === 92) {
            effects.consume(code)
            return title
          }

          return title(code)
        }
      }

      module.exports = titleFactory


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/factory-whitespace.js":
/*!************************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/factory-whitespace.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

      function whitespaceFactory(effects, ok) {
        let seen
        return start

        function start(code) {
          if (markdownLineEnding(code)) {
            effects.enter('lineEnding')
            effects.consume(code)
            effects.exit('lineEnding')
            seen = true
            return start
          }

          if (markdownSpace(code)) {
            return factorySpace(
              effects,
              start,
              seen ? 'linePrefix' : 'lineSuffix'
            )(code)
          }

          return ok(code)
        }
      }

      module.exports = whitespaceFactory


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/hard-break-escape.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/hard-break-escape.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")

      const hardBreakEscape = {
        name: 'hardBreakEscape',
        tokenize: tokenizeHardBreakEscape
      }

      function tokenizeHardBreakEscape(effects, ok, nok) {
        return start

        function start(code) {
          effects.enter('hardBreakEscape')
          effects.enter('escapeMarker')
          effects.consume(code)
          return open
        }

        function open(code) {
          if (markdownLineEnding(code)) {
            effects.exit('escapeMarker')
            effects.exit('hardBreakEscape')
            return ok(code)
          }

          return nok(code)
        }
      }

      module.exports = hardBreakEscape


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/heading-atx.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/heading-atx.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
      const markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
      const chunkedSplice = __webpack_require__(/*! ../util/chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

      const headingAtx = {
        name: 'headingAtx',
        tokenize: tokenizeHeadingAtx,
        resolve: resolveHeadingAtx
      }

      function resolveHeadingAtx(events, context) {
        let contentEnd = events.length - 2
        let contentStart = 3
        let content
        let text // Prefix whitespace, part of the opening.

        if (events[contentStart][1].type === 'whitespace') {
          contentStart += 2
        } // Suffix whitespace, part of the closing.

        if (
          contentEnd - 2 > contentStart &&
    events[contentEnd][1].type === 'whitespace'
        ) {
          contentEnd -= 2
        }

        if (
          events[contentEnd][1].type === 'atxHeadingSequence' &&
    (contentStart === contentEnd - 1 ||
      (contentEnd - 4 > contentStart &&
        events[contentEnd - 2][1].type === 'whitespace'))
        ) {
          contentEnd -= contentStart + 1 === contentEnd ? 2 : 4
        }

        if (contentEnd > contentStart) {
          content = {
            type: 'atxHeadingText',
            start: events[contentStart][1].start,
            end: events[contentEnd][1].end
          }
          text = {
            type: 'chunkText',
            start: events[contentStart][1].start,
            end: events[contentEnd][1].end,
            contentType: 'text'
          }
          chunkedSplice(events, contentStart, contentEnd - contentStart + 1, [
            ['enter', content, context],
            ['enter', text, context],
            ['exit', text, context],
            ['exit', content, context]
          ])
        }

        return events
      }

      function tokenizeHeadingAtx(effects, ok, nok) {
        const self = this
        let size = 0
        return start

        function start(code) {
          effects.enter('atxHeading')
          effects.enter('atxHeadingSequence')
          return fenceOpenInside(code)
        }

        function fenceOpenInside(code) {
          if (code === 35 && size++ < 6) {
            effects.consume(code)
            return fenceOpenInside
          }

          if (code === null || markdownLineEndingOrSpace(code)) {
            effects.exit('atxHeadingSequence')
            return self.interrupt ? ok(code) : headingBreak(code)
          }

          return nok(code)
        }

        function headingBreak(code) {
          if (code === 35) {
            effects.enter('atxHeadingSequence')
            return sequence(code)
          }

          if (code === null || markdownLineEnding(code)) {
            effects.exit('atxHeading')
            return ok(code)
          }

          if (markdownSpace(code)) {
            return factorySpace(effects, headingBreak, 'whitespace')(code)
          }

          effects.enter('atxHeadingText')
          return data(code)
        }

        function sequence(code) {
          if (code === 35) {
            effects.consume(code)
            return sequence
          }

          effects.exit('atxHeadingSequence')
          return headingBreak(code)
        }

        function data(code) {
          if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {
            effects.exit('atxHeadingText')
            return headingBreak(code)
          }

          effects.consume(code)
          return data
        }
      }

      module.exports = headingAtx


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/html-flow.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/html-flow.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const asciiAlpha = __webpack_require__(/*! ../character/ascii-alpha.js */ "../../node_modules/micromark/dist/character/ascii-alpha.js")
      const asciiAlphanumeric = __webpack_require__(/*! ../character/ascii-alphanumeric.js */ "../../node_modules/micromark/dist/character/ascii-alphanumeric.js")
      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
      const markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
      const fromCharCode = __webpack_require__(/*! ../constant/from-char-code.js */ "../../node_modules/micromark/dist/constant/from-char-code.js")
      const htmlBlockNames = __webpack_require__(/*! ../constant/html-block-names.js */ "../../node_modules/micromark/dist/constant/html-block-names.js")
      const htmlRawNames = __webpack_require__(/*! ../constant/html-raw-names.js */ "../../node_modules/micromark/dist/constant/html-raw-names.js")
      const partialBlankLine = __webpack_require__(/*! ./partial-blank-line.js */ "../../node_modules/micromark/dist/tokenize/partial-blank-line.js")

      const htmlFlow = {
        name: 'htmlFlow',
        tokenize: tokenizeHtmlFlow,
        resolveTo: resolveToHtmlFlow,
        concrete: true
      }
      const nextBlankConstruct = {
        tokenize: tokenizeNextBlank,
        partial: true
      }

      function resolveToHtmlFlow(events) {
        let index = events.length

        while (index--) {
          if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {
            break
          }
        }

        if (index > 1 && events[index - 2][1].type === 'linePrefix') {
    // Add the prefix start to the HTML token.
          events[index][1].start = events[index - 2][1].start // Add the prefix start to the HTML line token.

          events[index + 1][1].start = events[index - 2][1].start // Remove the line prefix.

          events.splice(index - 2, 2)
        }

        return events
      }

      function tokenizeHtmlFlow(effects, ok, nok) {
        const self = this
        let kind
        let startTag
        let buffer
        let index
        let marker
        return start

        function start(code) {
          effects.enter('htmlFlow')
          effects.enter('htmlFlowData')
          effects.consume(code)
          return open
        }

        function open(code) {
          if (code === 33) {
            effects.consume(code)
            return declarationStart
          }

          if (code === 47) {
            effects.consume(code)
            return tagCloseStart
          }

          if (code === 63) {
            effects.consume(code)
            kind = 3 // While we’re in an instruction instead of a declaration, we’re on a `?`
      // right now, so we do need to search for `>`, similar to declarations.

            return self.interrupt ? ok : continuationDeclarationInside
          }

          if (asciiAlpha(code)) {
            effects.consume(code)
            buffer = fromCharCode(code)
            startTag = true
            return tagName
          }

          return nok(code)
        }

        function declarationStart(code) {
          if (code === 45) {
            effects.consume(code)
            kind = 2
            return commentOpenInside
          }

          if (code === 91) {
            effects.consume(code)
            kind = 5
            buffer = 'CDATA['
            index = 0
            return cdataOpenInside
          }

          if (asciiAlpha(code)) {
            effects.consume(code)
            kind = 4
            return self.interrupt ? ok : continuationDeclarationInside
          }

          return nok(code)
        }

        function commentOpenInside(code) {
          if (code === 45) {
            effects.consume(code)
            return self.interrupt ? ok : continuationDeclarationInside
          }

          return nok(code)
        }

        function cdataOpenInside(code) {
          if (code === buffer.charCodeAt(index++)) {
            effects.consume(code)
            return index === buffer.length
              ? self.interrupt
                ? ok
                : continuation
              : cdataOpenInside
          }

          return nok(code)
        }

        function tagCloseStart(code) {
          if (asciiAlpha(code)) {
            effects.consume(code)
            buffer = fromCharCode(code)
            return tagName
          }

          return nok(code)
        }

        function tagName(code) {
          if (
            code === null ||
      code === 47 ||
      code === 62 ||
      markdownLineEndingOrSpace(code)
          ) {
            if (
              code !== 47 &&
        startTag &&
        htmlRawNames.indexOf(buffer.toLowerCase()) > -1
            ) {
              kind = 1
              return self.interrupt ? ok(code) : continuation(code)
            }

            if (htmlBlockNames.indexOf(buffer.toLowerCase()) > -1) {
              kind = 6

              if (code === 47) {
                effects.consume(code)
                return basicSelfClosing
              }

              return self.interrupt ? ok(code) : continuation(code)
            }

            kind = 7 // Do not support complete HTML when interrupting.

            return self.interrupt
              ? nok(code)
              : startTag
                ? completeAttributeNameBefore(code)
                : completeClosingTagAfter(code)
          }

          if (code === 45 || asciiAlphanumeric(code)) {
            effects.consume(code)
            buffer += fromCharCode(code)
            return tagName
          }

          return nok(code)
        }

        function basicSelfClosing(code) {
          if (code === 62) {
            effects.consume(code)
            return self.interrupt ? ok : continuation
          }

          return nok(code)
        }

        function completeClosingTagAfter(code) {
          if (markdownSpace(code)) {
            effects.consume(code)
            return completeClosingTagAfter
          }

          return completeEnd(code)
        }

        function completeAttributeNameBefore(code) {
          if (code === 47) {
            effects.consume(code)
            return completeEnd
          }

          if (code === 58 || code === 95 || asciiAlpha(code)) {
            effects.consume(code)
            return completeAttributeName
          }

          if (markdownSpace(code)) {
            effects.consume(code)
            return completeAttributeNameBefore
          }

          return completeEnd(code)
        }

        function completeAttributeName(code) {
          if (
            code === 45 ||
      code === 46 ||
      code === 58 ||
      code === 95 ||
      asciiAlphanumeric(code)
          ) {
            effects.consume(code)
            return completeAttributeName
          }

          return completeAttributeNameAfter(code)
        }

        function completeAttributeNameAfter(code) {
          if (code === 61) {
            effects.consume(code)
            return completeAttributeValueBefore
          }

          if (markdownSpace(code)) {
            effects.consume(code)
            return completeAttributeNameAfter
          }

          return completeAttributeNameBefore(code)
        }

        function completeAttributeValueBefore(code) {
          if (
            code === null ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96
          ) {
            return nok(code)
          }

          if (code === 34 || code === 39) {
            effects.consume(code)
            marker = code
            return completeAttributeValueQuoted
          }

          if (markdownSpace(code)) {
            effects.consume(code)
            return completeAttributeValueBefore
          }

          marker = undefined
          return completeAttributeValueUnquoted(code)
        }

        function completeAttributeValueQuoted(code) {
          if (code === marker) {
            effects.consume(code)
            return completeAttributeValueQuotedAfter
          }

          if (code === null || markdownLineEnding(code)) {
            return nok(code)
          }

          effects.consume(code)
          return completeAttributeValueQuoted
        }

        function completeAttributeValueUnquoted(code) {
          if (
            code === null ||
      code === 34 ||
      code === 39 ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96 ||
      markdownLineEndingOrSpace(code)
          ) {
            return completeAttributeNameAfter(code)
          }

          effects.consume(code)
          return completeAttributeValueUnquoted
        }

        function completeAttributeValueQuotedAfter(code) {
          if (code === 47 || code === 62 || markdownSpace(code)) {
            return completeAttributeNameBefore(code)
          }

          return nok(code)
        }

        function completeEnd(code) {
          if (code === 62) {
            effects.consume(code)
            return completeAfter
          }

          return nok(code)
        }

        function completeAfter(code) {
          if (markdownSpace(code)) {
            effects.consume(code)
            return completeAfter
          }

          return code === null || markdownLineEnding(code)
            ? continuation(code)
            : nok(code)
        }

        function continuation(code) {
          if (code === 45 && kind === 2) {
            effects.consume(code)
            return continuationCommentInside
          }

          if (code === 60 && kind === 1) {
            effects.consume(code)
            return continuationRawTagOpen
          }

          if (code === 62 && kind === 4) {
            effects.consume(code)
            return continuationClose
          }

          if (code === 63 && kind === 3) {
            effects.consume(code)
            return continuationDeclarationInside
          }

          if (code === 93 && kind === 5) {
            effects.consume(code)
            return continuationCharacterDataInside
          }

          if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {
            return effects.check(
              nextBlankConstruct,
              continuationClose,
              continuationAtLineEnding
            )(code)
          }

          if (code === null || markdownLineEnding(code)) {
            return continuationAtLineEnding(code)
          }

          effects.consume(code)
          return continuation
        }

        function continuationAtLineEnding(code) {
          effects.exit('htmlFlowData')
          return htmlContinueStart(code)
        }

        function htmlContinueStart(code) {
          if (code === null) {
            return done(code)
          }

          if (markdownLineEnding(code)) {
            effects.enter('lineEnding')
            effects.consume(code)
            effects.exit('lineEnding')
            return htmlContinueStart
          }

          effects.enter('htmlFlowData')
          return continuation(code)
        }

        function continuationCommentInside(code) {
          if (code === 45) {
            effects.consume(code)
            return continuationDeclarationInside
          }

          return continuation(code)
        }

        function continuationRawTagOpen(code) {
          if (code === 47) {
            effects.consume(code)
            buffer = ''
            return continuationRawEndTag
          }

          return continuation(code)
        }

        function continuationRawEndTag(code) {
          if (code === 62 && htmlRawNames.indexOf(buffer.toLowerCase()) > -1) {
            effects.consume(code)
            return continuationClose
          }

          if (asciiAlpha(code) && buffer.length < 8) {
            effects.consume(code)
            buffer += fromCharCode(code)
            return continuationRawEndTag
          }

          return continuation(code)
        }

        function continuationCharacterDataInside(code) {
          if (code === 93) {
            effects.consume(code)
            return continuationDeclarationInside
          }

          return continuation(code)
        }

        function continuationDeclarationInside(code) {
          if (code === 62) {
            effects.consume(code)
            return continuationClose
          }

          return continuation(code)
        }

        function continuationClose(code) {
          if (code === null || markdownLineEnding(code)) {
            effects.exit('htmlFlowData')
            return done(code)
          }

          effects.consume(code)
          return continuationClose
        }

        function done(code) {
          effects.exit('htmlFlow')
          return ok(code)
        }
      }

      function tokenizeNextBlank(effects, ok, nok) {
        return start

        function start(code) {
          effects.exit('htmlFlowData')
          effects.enter('lineEndingBlank')
          effects.consume(code)
          effects.exit('lineEndingBlank')
          return effects.attempt(partialBlankLine, ok, nok)
        }
      }

      module.exports = htmlFlow


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/html-text.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/html-text.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const asciiAlpha = __webpack_require__(/*! ../character/ascii-alpha.js */ "../../node_modules/micromark/dist/character/ascii-alpha.js")
      const asciiAlphanumeric = __webpack_require__(/*! ../character/ascii-alphanumeric.js */ "../../node_modules/micromark/dist/character/ascii-alphanumeric.js")
      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
      const markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

      const htmlText = {
        name: 'htmlText',
        tokenize: tokenizeHtmlText
      }

      function tokenizeHtmlText(effects, ok, nok) {
        const self = this
        let marker
        let buffer
        let index
        let returnState
        return start

        function start(code) {
          effects.enter('htmlText')
          effects.enter('htmlTextData')
          effects.consume(code)
          return open
        }

        function open(code) {
          if (code === 33) {
            effects.consume(code)
            return declarationOpen
          }

          if (code === 47) {
            effects.consume(code)
            return tagCloseStart
          }

          if (code === 63) {
            effects.consume(code)
            return instruction
          }

          if (asciiAlpha(code)) {
            effects.consume(code)
            return tagOpen
          }

          return nok(code)
        }

        function declarationOpen(code) {
          if (code === 45) {
            effects.consume(code)
            return commentOpen
          }

          if (code === 91) {
            effects.consume(code)
            buffer = 'CDATA['
            index = 0
            return cdataOpen
          }

          if (asciiAlpha(code)) {
            effects.consume(code)
            return declaration
          }

          return nok(code)
        }

        function commentOpen(code) {
          if (code === 45) {
            effects.consume(code)
            return commentStart
          }

          return nok(code)
        }

        function commentStart(code) {
          if (code === null || code === 62) {
            return nok(code)
          }

          if (code === 45) {
            effects.consume(code)
            return commentStartDash
          }

          return comment(code)
        }

        function commentStartDash(code) {
          if (code === null || code === 62) {
            return nok(code)
          }

          return comment(code)
        }

        function comment(code) {
          if (code === null) {
            return nok(code)
          }

          if (code === 45) {
            effects.consume(code)
            return commentClose
          }

          if (markdownLineEnding(code)) {
            returnState = comment
            return atLineEnding(code)
          }

          effects.consume(code)
          return comment
        }

        function commentClose(code) {
          if (code === 45) {
            effects.consume(code)
            return end
          }

          return comment(code)
        }

        function cdataOpen(code) {
          if (code === buffer.charCodeAt(index++)) {
            effects.consume(code)
            return index === buffer.length ? cdata : cdataOpen
          }

          return nok(code)
        }

        function cdata(code) {
          if (code === null) {
            return nok(code)
          }

          if (code === 93) {
            effects.consume(code)
            return cdataClose
          }

          if (markdownLineEnding(code)) {
            returnState = cdata
            return atLineEnding(code)
          }

          effects.consume(code)
          return cdata
        }

        function cdataClose(code) {
          if (code === 93) {
            effects.consume(code)
            return cdataEnd
          }

          return cdata(code)
        }

        function cdataEnd(code) {
          if (code === 62) {
            return end(code)
          }

          if (code === 93) {
            effects.consume(code)
            return cdataEnd
          }

          return cdata(code)
        }

        function declaration(code) {
          if (code === null || code === 62) {
            return end(code)
          }

          if (markdownLineEnding(code)) {
            returnState = declaration
            return atLineEnding(code)
          }

          effects.consume(code)
          return declaration
        }

        function instruction(code) {
          if (code === null) {
            return nok(code)
          }

          if (code === 63) {
            effects.consume(code)
            return instructionClose
          }

          if (markdownLineEnding(code)) {
            returnState = instruction
            return atLineEnding(code)
          }

          effects.consume(code)
          return instruction
        }

        function instructionClose(code) {
          return code === 62 ? end(code) : instruction(code)
        }

        function tagCloseStart(code) {
          if (asciiAlpha(code)) {
            effects.consume(code)
            return tagClose
          }

          return nok(code)
        }

        function tagClose(code) {
          if (code === 45 || asciiAlphanumeric(code)) {
            effects.consume(code)
            return tagClose
          }

          return tagCloseBetween(code)
        }

        function tagCloseBetween(code) {
          if (markdownLineEnding(code)) {
            returnState = tagCloseBetween
            return atLineEnding(code)
          }

          if (markdownSpace(code)) {
            effects.consume(code)
            return tagCloseBetween
          }

          return end(code)
        }

        function tagOpen(code) {
          if (code === 45 || asciiAlphanumeric(code)) {
            effects.consume(code)
            return tagOpen
          }

          if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
            return tagOpenBetween(code)
          }

          return nok(code)
        }

        function tagOpenBetween(code) {
          if (code === 47) {
            effects.consume(code)
            return end
          }

          if (code === 58 || code === 95 || asciiAlpha(code)) {
            effects.consume(code)
            return tagOpenAttributeName
          }

          if (markdownLineEnding(code)) {
            returnState = tagOpenBetween
            return atLineEnding(code)
          }

          if (markdownSpace(code)) {
            effects.consume(code)
            return tagOpenBetween
          }

          return end(code)
        }

        function tagOpenAttributeName(code) {
          if (
            code === 45 ||
      code === 46 ||
      code === 58 ||
      code === 95 ||
      asciiAlphanumeric(code)
          ) {
            effects.consume(code)
            return tagOpenAttributeName
          }

          return tagOpenAttributeNameAfter(code)
        }

        function tagOpenAttributeNameAfter(code) {
          if (code === 61) {
            effects.consume(code)
            return tagOpenAttributeValueBefore
          }

          if (markdownLineEnding(code)) {
            returnState = tagOpenAttributeNameAfter
            return atLineEnding(code)
          }

          if (markdownSpace(code)) {
            effects.consume(code)
            return tagOpenAttributeNameAfter
          }

          return tagOpenBetween(code)
        }

        function tagOpenAttributeValueBefore(code) {
          if (
            code === null ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96
          ) {
            return nok(code)
          }

          if (code === 34 || code === 39) {
            effects.consume(code)
            marker = code
            return tagOpenAttributeValueQuoted
          }

          if (markdownLineEnding(code)) {
            returnState = tagOpenAttributeValueBefore
            return atLineEnding(code)
          }

          if (markdownSpace(code)) {
            effects.consume(code)
            return tagOpenAttributeValueBefore
          }

          effects.consume(code)
          marker = undefined
          return tagOpenAttributeValueUnquoted
        }

        function tagOpenAttributeValueQuoted(code) {
          if (code === marker) {
            effects.consume(code)
            return tagOpenAttributeValueQuotedAfter
          }

          if (code === null) {
            return nok(code)
          }

          if (markdownLineEnding(code)) {
            returnState = tagOpenAttributeValueQuoted
            return atLineEnding(code)
          }

          effects.consume(code)
          return tagOpenAttributeValueQuoted
        }

        function tagOpenAttributeValueQuotedAfter(code) {
          if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {
            return tagOpenBetween(code)
          }

          return nok(code)
        }

        function tagOpenAttributeValueUnquoted(code) {
          if (
            code === null ||
      code === 34 ||
      code === 39 ||
      code === 60 ||
      code === 61 ||
      code === 96
          ) {
            return nok(code)
          }

          if (code === 62 || markdownLineEndingOrSpace(code)) {
            return tagOpenBetween(code)
          }

          effects.consume(code)
          return tagOpenAttributeValueUnquoted
        } // We can’t have blank lines in content, so no need to worry about empty
  // tokens.

        function atLineEnding(code) {
          effects.exit('htmlTextData')
          effects.enter('lineEnding')
          effects.consume(code)
          effects.exit('lineEnding')
          return factorySpace(
            effects,
            afterPrefix,
            'linePrefix',
            self.parser.constructs.disable.null.indexOf('codeIndented') > -1
              ? undefined
              : 4
          )
        }

        function afterPrefix(code) {
          effects.enter('htmlTextData')
          return returnState(code)
        }

        function end(code) {
          if (code === 62) {
            effects.consume(code)
            effects.exit('htmlTextData')
            effects.exit('htmlText')
            return ok
          }

          return nok(code)
        }
      }

      module.exports = htmlText


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/label-end.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/label-end.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
      const chunkedPush = __webpack_require__(/*! ../util/chunked-push.js */ "../../node_modules/micromark/dist/util/chunked-push.js")
      const chunkedSplice = __webpack_require__(/*! ../util/chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
      const normalizeIdentifier = __webpack_require__(/*! ../util/normalize-identifier.js */ "../../node_modules/micromark/dist/util/normalize-identifier.js")
      const resolveAll = __webpack_require__(/*! ../util/resolve-all.js */ "../../node_modules/micromark/dist/util/resolve-all.js")
      const shallow = __webpack_require__(/*! ../util/shallow.js */ "../../node_modules/micromark/dist/util/shallow.js")
      const factoryDestination = __webpack_require__(/*! ./factory-destination.js */ "../../node_modules/micromark/dist/tokenize/factory-destination.js")
      const factoryLabel = __webpack_require__(/*! ./factory-label.js */ "../../node_modules/micromark/dist/tokenize/factory-label.js")
      const factoryTitle = __webpack_require__(/*! ./factory-title.js */ "../../node_modules/micromark/dist/tokenize/factory-title.js")
      const factoryWhitespace = __webpack_require__(/*! ./factory-whitespace.js */ "../../node_modules/micromark/dist/tokenize/factory-whitespace.js")

      const labelEnd = {
        name: 'labelEnd',
        tokenize: tokenizeLabelEnd,
        resolveTo: resolveToLabelEnd,
        resolveAll: resolveAllLabelEnd
      }
      const resourceConstruct = {
        tokenize: tokenizeResource
      }
      const fullReferenceConstruct = {
        tokenize: tokenizeFullReference
      }
      const collapsedReferenceConstruct = {
        tokenize: tokenizeCollapsedReference
      }

      function resolveAllLabelEnd(events) {
        let index = -1
        let token

        while (++index < events.length) {
          token = events[index][1]

          if (
            !token._used &&
      (token.type === 'labelImage' ||
        token.type === 'labelLink' ||
        token.type === 'labelEnd')
          ) {
      // Remove the marker.
            events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)
            token.type = 'data'
            index++
          }
        }

        return events
      }

      function resolveToLabelEnd(events, context) {
        let index = events.length
        let offset = 0
        let group
        let label
        let text
        let token
        let open
        let close
        let media // Find an opening.

        while (index--) {
          token = events[index][1]

          if (open) {
      // If we see another link, or inactive link label, we’ve been here before.
            if (
              token.type === 'link' ||
        (token.type === 'labelLink' && token._inactive)
            ) {
              break
            } // Mark other link openings as inactive, as we can’t have links in
      // links.

            if (events[index][0] === 'enter' && token.type === 'labelLink') {
              token._inactive = true
            }
          } else if (close) {
            if (
              events[index][0] === 'enter' &&
        (token.type === 'labelImage' || token.type === 'labelLink') &&
        !token._balanced
            ) {
              open = index

              if (token.type !== 'labelLink') {
                offset = 2
                break
              }
            }
          } else if (token.type === 'labelEnd') {
            close = index
          }
        }

        group = {
          type: events[open][1].type === 'labelLink' ? 'link' : 'image',
          start: shallow(events[open][1].start),
          end: shallow(events[events.length - 1][1].end)
        }
        label = {
          type: 'label',
          start: shallow(events[open][1].start),
          end: shallow(events[close][1].end)
        }
        text = {
          type: 'labelText',
          start: shallow(events[open + offset + 2][1].end),
          end: shallow(events[close - 2][1].start)
        }
        media = [
          ['enter', group, context],
          ['enter', label, context]
        ] // Opening marker.

        media = chunkedPush(media, events.slice(open + 1, open + offset + 3)) // Text open.

        media = chunkedPush(media, [['enter', text, context]]) // Between.

        media = chunkedPush(
          media,
          resolveAll(
            context.parser.constructs.insideSpan.null,
            events.slice(open + offset + 4, close - 3),
            context
          )
        ) // Text close, marker close, label close.

        media = chunkedPush(media, [
          ['exit', text, context],
          events[close - 2],
          events[close - 1],
          ['exit', label, context]
        ]) // Reference, resource, or so.

        media = chunkedPush(media, events.slice(close + 1)) // Media close.

        media = chunkedPush(media, [['exit', group, context]])
        chunkedSplice(events, open, events.length, media)
        return events
      }

      function tokenizeLabelEnd(effects, ok, nok) {
        const self = this
        let index = self.events.length
        let labelStart
        let defined // Find an opening.

        while (index--) {
          if (
            (self.events[index][1].type === 'labelImage' ||
        self.events[index][1].type === 'labelLink') &&
      !self.events[index][1]._balanced
          ) {
            labelStart = self.events[index][1]
            break
          }
        }

        return start

        function start(code) {
          if (!labelStart) {
            return nok(code)
          } // It’s a balanced bracket, but contains a link.

          if (labelStart._inactive) return balanced(code)
          defined =
      self.parser.defined.indexOf(
        normalizeIdentifier(
          self.sliceSerialize({
            start: labelStart.end,
            end: self.now()
          })
        )
      ) > -1
          effects.enter('labelEnd')
          effects.enter('labelMarker')
          effects.consume(code)
          effects.exit('labelMarker')
          effects.exit('labelEnd')
          return afterLabelEnd
        }

        function afterLabelEnd(code) {
    // Resource: `[asd](fgh)`.
          if (code === 40) {
            return effects.attempt(
              resourceConstruct,
              ok,
              defined ? ok : balanced
            )(code)
          } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?

          if (code === 91) {
            return effects.attempt(
              fullReferenceConstruct,
              ok,
              defined
                ? effects.attempt(collapsedReferenceConstruct, ok, balanced)
                : balanced
            )(code)
          } // Shortcut reference: `[asd]`?

          return defined ? ok(code) : balanced(code)
        }

        function balanced(code) {
          labelStart._balanced = true
          return nok(code)
        }
      }

      function tokenizeResource(effects, ok, nok) {
        return start

        function start(code) {
          effects.enter('resource')
          effects.enter('resourceMarker')
          effects.consume(code)
          effects.exit('resourceMarker')
          return factoryWhitespace(effects, open)
        }

        function open(code) {
          if (code === 41) {
            return end(code)
          }

          return factoryDestination(
            effects,
            destinationAfter,
            nok,
            'resourceDestination',
            'resourceDestinationLiteral',
            'resourceDestinationLiteralMarker',
            'resourceDestinationRaw',
            'resourceDestinationString',
            3
          )(code)
        }

        function destinationAfter(code) {
          return markdownLineEndingOrSpace(code)
            ? factoryWhitespace(effects, between)(code)
            : end(code)
        }

        function between(code) {
          if (code === 34 || code === 39 || code === 40) {
            return factoryTitle(
              effects,
              factoryWhitespace(effects, end),
              nok,
              'resourceTitle',
              'resourceTitleMarker',
              'resourceTitleString'
            )(code)
          }

          return end(code)
        }

        function end(code) {
          if (code === 41) {
            effects.enter('resourceMarker')
            effects.consume(code)
            effects.exit('resourceMarker')
            effects.exit('resource')
            return ok
          }

          return nok(code)
        }
      }

      function tokenizeFullReference(effects, ok, nok) {
        const self = this
        return start

        function start(code) {
          return factoryLabel.call(
            self,
            effects,
            afterLabel,
            nok,
            'reference',
            'referenceMarker',
            'referenceString'
          )(code)
        }

        function afterLabel(code) {
          return self.parser.defined.indexOf(
            normalizeIdentifier(
              self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
            )
          ) < 0
            ? nok(code)
            : ok(code)
        }
      }

      function tokenizeCollapsedReference(effects, ok, nok) {
        return start

        function start(code) {
          effects.enter('reference')
          effects.enter('referenceMarker')
          effects.consume(code)
          effects.exit('referenceMarker')
          return open
        }

        function open(code) {
          if (code === 93) {
            effects.enter('referenceMarker')
            effects.consume(code)
            effects.exit('referenceMarker')
            effects.exit('reference')
            return ok
          }

          return nok(code)
        }
      }

      module.exports = labelEnd


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/label-start-image.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/label-start-image.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const labelEnd = __webpack_require__(/*! ./label-end.js */ "../../node_modules/micromark/dist/tokenize/label-end.js")

      const labelStartImage = {
        name: 'labelStartImage',
        tokenize: tokenizeLabelStartImage,
        resolveAll: labelEnd.resolveAll
      }

      function tokenizeLabelStartImage(effects, ok, nok) {
        const self = this
        return start

        function start(code) {
          effects.enter('labelImage')
          effects.enter('labelImageMarker')
          effects.consume(code)
          effects.exit('labelImageMarker')
          return open
        }

        function open(code) {
          if (code === 91) {
            effects.enter('labelMarker')
            effects.consume(code)
            effects.exit('labelMarker')
            effects.exit('labelImage')
            return after
          }

          return nok(code)
        }

        function after(code) {
    /* c8 ignore next */
          return code === 94 &&
      /* c8 ignore next */
      '_hiddenFootnoteSupport' in self.parser.constructs
            ? /* c8 ignore next */
            nok(code)
            : ok(code)
        }
      }

      module.exports = labelStartImage


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/label-start-link.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/label-start-link.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const labelEnd = __webpack_require__(/*! ./label-end.js */ "../../node_modules/micromark/dist/tokenize/label-end.js")

      const labelStartLink = {
        name: 'labelStartLink',
        tokenize: tokenizeLabelStartLink,
        resolveAll: labelEnd.resolveAll
      }

      function tokenizeLabelStartLink(effects, ok, nok) {
        const self = this
        return start

        function start(code) {
          effects.enter('labelLink')
          effects.enter('labelMarker')
          effects.consume(code)
          effects.exit('labelMarker')
          effects.exit('labelLink')
          return after
        }

        function after(code) {
    /* c8 ignore next */
          return code === 94 &&
      /* c8 ignore next */
      '_hiddenFootnoteSupport' in self.parser.constructs
            ? /* c8 ignore next */
            nok(code)
            : ok(code)
        }
      }

      module.exports = labelStartLink


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/line-ending.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/line-ending.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

      const lineEnding = {
        name: 'lineEnding',
        tokenize: tokenizeLineEnding
      }

      function tokenizeLineEnding(effects, ok) {
        return start

        function start(code) {
          effects.enter('lineEnding')
          effects.consume(code)
          effects.exit('lineEnding')
          return factorySpace(effects, ok, 'linePrefix')
        }
      }

      module.exports = lineEnding


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/list.js":
/*!**********************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/list.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const asciiDigit = __webpack_require__(/*! ../character/ascii-digit.js */ "../../node_modules/micromark/dist/character/ascii-digit.js")
      const markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
      const prefixSize = __webpack_require__(/*! ../util/prefix-size.js */ "../../node_modules/micromark/dist/util/prefix-size.js")
      const sizeChunks = __webpack_require__(/*! ../util/size-chunks.js */ "../../node_modules/micromark/dist/util/size-chunks.js")
      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")
      const partialBlankLine = __webpack_require__(/*! ./partial-blank-line.js */ "../../node_modules/micromark/dist/tokenize/partial-blank-line.js")
      const thematicBreak = __webpack_require__(/*! ./thematic-break.js */ "../../node_modules/micromark/dist/tokenize/thematic-break.js")

      const list = {
        name: 'list',
        tokenize: tokenizeListStart,
        continuation: {
          tokenize: tokenizeListContinuation
        },
        exit: tokenizeListEnd
      }
      const listItemPrefixWhitespaceConstruct = {
        tokenize: tokenizeListItemPrefixWhitespace,
        partial: true
      }
      const indentConstruct = {
        tokenize: tokenizeIndent,
        partial: true
      }

      function tokenizeListStart(effects, ok, nok) {
        const self = this
        let initialSize = prefixSize(self.events, 'linePrefix')
        let size = 0
        return start

        function start(code) {
          const kind =
      self.containerState.type ||
      (code === 42 || code === 43 || code === 45
        ? 'listUnordered'
        : 'listOrdered')

          if (
            kind === 'listUnordered'
              ? !self.containerState.marker || code === self.containerState.marker
              : asciiDigit(code)
          ) {
            if (!self.containerState.type) {
              self.containerState.type = kind
              effects.enter(kind, {
                _container: true
              })
            }

            if (kind === 'listUnordered') {
              effects.enter('listItemPrefix')
              return code === 42 || code === 45
                ? effects.check(thematicBreak, nok, atMarker)(code)
                : atMarker(code)
            }

            if (!self.interrupt || code === 49) {
              effects.enter('listItemPrefix')
              effects.enter('listItemValue')
              return inside(code)
            }
          }

          return nok(code)
        }

        function inside(code) {
          if (asciiDigit(code) && ++size < 10) {
            effects.consume(code)
            return inside
          }

          if (
            (!self.interrupt || size < 2) &&
      (self.containerState.marker
        ? code === self.containerState.marker
        : code === 41 || code === 46)
          ) {
            effects.exit('listItemValue')
            return atMarker(code)
          }

          return nok(code)
        }

        function atMarker(code) {
          effects.enter('listItemMarker')
          effects.consume(code)
          effects.exit('listItemMarker')
          self.containerState.marker = self.containerState.marker || code
          return effects.check(
            partialBlankLine, // Can’t be empty when interrupting.
            self.interrupt ? nok : onBlank,
            effects.attempt(
              listItemPrefixWhitespaceConstruct,
              endOfPrefix,
              otherPrefix
            )
          )
        }

        function onBlank(code) {
          self.containerState.initialBlankLine = true
          initialSize++
          return endOfPrefix(code)
        }

        function otherPrefix(code) {
          if (markdownSpace(code)) {
            effects.enter('listItemPrefixWhitespace')
            effects.consume(code)
            effects.exit('listItemPrefixWhitespace')
            return endOfPrefix
          }

          return nok(code)
        }

        function endOfPrefix(code) {
          self.containerState.size =
      initialSize + sizeChunks(self.sliceStream(effects.exit('listItemPrefix')))
          return ok(code)
        }
      }

      function tokenizeListContinuation(effects, ok, nok) {
        const self = this
        self.containerState._closeFlow = undefined
        return effects.check(partialBlankLine, onBlank, notBlank)

        function onBlank(code) {
          self.containerState.furtherBlankLines =
      self.containerState.furtherBlankLines ||
      self.containerState.initialBlankLine // We have a blank line.
    // Still, try to consume at most the items size.

          return factorySpace(
            effects,
            ok,
            'listItemIndent',
            self.containerState.size + 1
          )(code)
        }

        function notBlank(code) {
          if (self.containerState.furtherBlankLines || !markdownSpace(code)) {
            self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined
            return notInCurrentItem(code)
          }

          self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined
          return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)
        }

        function notInCurrentItem(code) {
    // While we do continue, we signal that the flow should be closed.
          self.containerState._closeFlow = true // As we’re closing flow, we’re no longer interrupting.

          self.interrupt = undefined
          return factorySpace(
            effects,
            effects.attempt(list, ok, nok),
            'linePrefix',
            self.parser.constructs.disable.null.indexOf('codeIndented') > -1
              ? undefined
              : 4
          )(code)
        }
      }

      function tokenizeIndent(effects, ok, nok) {
        const self = this
        return factorySpace(
          effects,
          afterPrefix,
          'listItemIndent',
          self.containerState.size + 1
        )

        function afterPrefix(code) {
          return prefixSize(self.events, 'listItemIndent') ===
      self.containerState.size
            ? ok(code)
            : nok(code)
        }
      }

      function tokenizeListEnd(effects) {
        effects.exit(this.containerState.type)
      }

      function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
        const self = this
        return factorySpace(
          effects,
          afterPrefix,
          'listItemPrefixWhitespace',
          self.parser.constructs.disable.null.indexOf('codeIndented') > -1
            ? undefined
            : 4 + 1
        )

        function afterPrefix(code) {
          return markdownSpace(code) ||
      !prefixSize(self.events, 'listItemPrefixWhitespace')
            ? nok(code)
            : ok(code)
        }
      }

      module.exports = list


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/partial-blank-line.js":
/*!************************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/partial-blank-line.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

      const partialBlankLine = {
        tokenize: tokenizePartialBlankLine,
        partial: true
      }

      function tokenizePartialBlankLine(effects, ok, nok) {
        return factorySpace(effects, afterWhitespace, 'linePrefix')

        function afterWhitespace(code) {
          return code === null || markdownLineEnding(code) ? ok(code) : nok(code)
        }
      }

      module.exports = partialBlankLine


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/setext-underline.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/setext-underline.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const shallow = __webpack_require__(/*! ../util/shallow.js */ "../../node_modules/micromark/dist/util/shallow.js")
      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

      const setextUnderline = {
        name: 'setextUnderline',
        tokenize: tokenizeSetextUnderline,
        resolveTo: resolveToSetextUnderline
      }

      function resolveToSetextUnderline(events, context) {
        let index = events.length
        let content
        let text
        let definition
        let heading // Find the opening of the content.
  // It’ll always exist: we don’t tokenize if it isn’t there.

        while (index--) {
          if (events[index][0] === 'enter') {
            if (events[index][1].type === 'content') {
              content = index
              break
            }

            if (events[index][1].type === 'paragraph') {
              text = index
            }
          } // Exit
          else {
            if (events[index][1].type === 'content') {
        // Remove the content end (if needed we’ll add it later)
              events.splice(index, 1)
            }

            if (!definition && events[index][1].type === 'definition') {
              definition = index
            }
          }
        }

        heading = {
          type: 'setextHeading',
          start: shallow(events[text][1].start),
          end: shallow(events[events.length - 1][1].end)
        } // Change the paragraph to setext heading text.

        events[text][1].type = 'setextHeadingText' // If we have definitions in the content, we’ll keep on having content,
  // but we need move it.

        if (definition) {
          events.splice(text, 0, ['enter', heading, context])
          events.splice(definition + 1, 0, ['exit', events[content][1], context])
          events[content][1].end = shallow(events[definition][1].end)
        } else {
          events[content][1] = heading
        } // Add the heading exit at the end.

        events.push(['exit', heading, context])
        return events
      }

      function tokenizeSetextUnderline(effects, ok, nok) {
        const self = this
        let index = self.events.length
        let marker
        let paragraph // Find an opening.

        while (index--) {
    // Skip enter/exit of line ending, line prefix, and content.
    // We can now either have a definition or a paragraph.
          if (
            self.events[index][1].type !== 'lineEnding' &&
      self.events[index][1].type !== 'linePrefix' &&
      self.events[index][1].type !== 'content'
          ) {
            paragraph = self.events[index][1].type === 'paragraph'
            break
          }
        }

        return start

        function start(code) {
          if (!self.lazy && (self.interrupt || paragraph)) {
            effects.enter('setextHeadingLine')
            effects.enter('setextHeadingLineSequence')
            marker = code
            return closingSequence(code)
          }

          return nok(code)
        }

        function closingSequence(code) {
          if (code === marker) {
            effects.consume(code)
            return closingSequence
          }

          effects.exit('setextHeadingLineSequence')
          return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code)
        }

        function closingSequenceEnd(code) {
          if (code === null || markdownLineEnding(code)) {
            effects.exit('setextHeadingLine')
            return ok(code)
          }

          return nok(code)
        }
      }

      module.exports = setextUnderline


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/thematic-break.js":
/*!********************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/thematic-break.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
      const factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

      const thematicBreak = {
        name: 'thematicBreak',
        tokenize: tokenizeThematicBreak
      }

      function tokenizeThematicBreak(effects, ok, nok) {
        let size = 0
        let marker
        return start

        function start(code) {
          effects.enter('thematicBreak')
          marker = code
          return atBreak(code)
        }

        function atBreak(code) {
          if (code === marker) {
            effects.enter('thematicBreakSequence')
            return sequence(code)
          }

          if (markdownSpace(code)) {
            return factorySpace(effects, atBreak, 'whitespace')(code)
          }

          if (size < 3 || (code !== null && !markdownLineEnding(code))) {
            return nok(code)
          }

          effects.exit('thematicBreak')
          return ok(code)
        }

        function sequence(code) {
          if (code === marker) {
            effects.consume(code)
            size++
            return sequence
          }

          effects.exit('thematicBreakSequence')
          return atBreak(code)
        }
      }

      module.exports = thematicBreak


/***/ }),

/***/ "../../node_modules/micromark/dist/util/chunked-push.js":
/*!**************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/chunked-push.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const chunkedSplice = __webpack_require__(/*! ./chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")

      function chunkedPush(list, items) {
        if (list.length) {
          chunkedSplice(list, list.length, 0, items)
          return list
        }

        return items
      }

      module.exports = chunkedPush


/***/ }),

/***/ "../../node_modules/micromark/dist/util/chunked-splice.js":
/*!****************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/chunked-splice.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const splice = __webpack_require__(/*! ../constant/splice.js */ "../../node_modules/micromark/dist/constant/splice.js")

// causes a stack overflow in V8 when trying to insert 100k items for instance.

      function chunkedSplice(list, start, remove, items) {
        const end = list.length
        let chunkStart = 0
        let parameters // Make start between zero and `end` (included).

        if (start < 0) {
          start = -start > end ? 0 : end + start
        } else {
          start = start > end ? end : start
        }

        remove = remove > 0 ? remove : 0 // No need to chunk the items if there’s only a couple (10k) items.

        if (items.length < 10000) {
          parameters = Array.from(items)
          parameters.unshift(start, remove)
          splice.apply(list, parameters)
        } else {
    // Delete `remove` items starting from `start`
          if (remove) splice.apply(list, [start, remove]) // Insert the items in chunks to not cause stack overflows.

          while (chunkStart < items.length) {
            parameters = items.slice(chunkStart, chunkStart + 10000)
            parameters.unshift(start, 0)
            splice.apply(list, parameters)
            chunkStart += 10000
            start += 10000
          }
        }
      }

      module.exports = chunkedSplice


/***/ }),

/***/ "../../node_modules/micromark/dist/util/classify-character.js":
/*!********************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/classify-character.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
      const unicodePunctuation = __webpack_require__(/*! ../character/unicode-punctuation.js */ "../../node_modules/micromark/dist/character/unicode-punctuation.js")
      const unicodeWhitespace = __webpack_require__(/*! ../character/unicode-whitespace.js */ "../../node_modules/micromark/dist/character/unicode-whitespace.js")

// Classify whether a character is unicode whitespace, unicode punctuation, or
// anything else.
// Used for attention (emphasis, strong), whose sequences can open or close
// based on the class of surrounding characters.
      function classifyCharacter(code) {
        if (
          code === null ||
    markdownLineEndingOrSpace(code) ||
    unicodeWhitespace(code)
        ) {
          return 1
        }

        if (unicodePunctuation(code)) {
          return 2
        }
      }

      module.exports = classifyCharacter


/***/ }),

/***/ "../../node_modules/micromark/dist/util/combine-extensions.js":
/*!********************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/combine-extensions.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const hasOwnProperty = __webpack_require__(/*! ../constant/has-own-property.js */ "../../node_modules/micromark/dist/constant/has-own-property.js")
      const chunkedSplice = __webpack_require__(/*! ./chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
      const miniflat = __webpack_require__(/*! ./miniflat.js */ "../../node_modules/micromark/dist/util/miniflat.js")

      function combineExtensions(extensions) {
        const all = {}
        let index = -1

        while (++index < extensions.length) {
          extension(all, extensions[index])
        }

        return all
      }

      function extension(all, extension) {
        let hook
        let left
        let right
        let code

        for (hook in extension) {
          left = hasOwnProperty.call(all, hook) ? all[hook] : (all[hook] = {})
          right = extension[hook]

          for (code in right) {
            left[code] = constructs(
              miniflat(right[code]),
              hasOwnProperty.call(left, code) ? left[code] : []
            )
          }
        }
      }

      function constructs(list, existing) {
        let index = -1
        const before = []

        while (++index < list.length) {
          (list[index].add === 'after' ? existing : before).push(list[index])
        }

        chunkedSplice(existing, 0, 0, before)
        return existing
      }

      module.exports = combineExtensions


/***/ }),

/***/ "../../node_modules/micromark/dist/util/create-tokenizer.js":
/*!******************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/create-tokenizer.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const assign = __webpack_require__(/*! ../constant/assign.js */ "../../node_modules/micromark/dist/constant/assign.js")
      const markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
      const chunkedPush = __webpack_require__(/*! ./chunked-push.js */ "../../node_modules/micromark/dist/util/chunked-push.js")
      const chunkedSplice = __webpack_require__(/*! ./chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
      const miniflat = __webpack_require__(/*! ./miniflat.js */ "../../node_modules/micromark/dist/util/miniflat.js")
      const resolveAll = __webpack_require__(/*! ./resolve-all.js */ "../../node_modules/micromark/dist/util/resolve-all.js")
      const serializeChunks = __webpack_require__(/*! ./serialize-chunks.js */ "../../node_modules/micromark/dist/util/serialize-chunks.js")
      const shallow = __webpack_require__(/*! ./shallow.js */ "../../node_modules/micromark/dist/util/shallow.js")
      const sliceChunks = __webpack_require__(/*! ./slice-chunks.js */ "../../node_modules/micromark/dist/util/slice-chunks.js")

// Create a tokenizer.
// Tokenizers deal with one type of data (e.g., containers, flow, text).
// The parser is the object dealing with it all.
// `initialize` works like other constructs, except that only its `tokenize`
// function is used, in which case it doesn’t receive an `ok` or `nok`.
// `from` can be given to set the point before the first character, although
// when further lines are indented, they must be set with `defineSkip`.
      function createTokenizer(parser, initialize, from) {
        let point = from
          ? shallow(from)
          : {
            line: 1,
            column: 1,
            offset: 0
          }
        const columnStart = {}
        const resolveAllConstructs = []
        let chunks = []
        let stack = []

        const effects = {
          consume: consume,
          enter: enter,
          exit: exit,
          attempt: constructFactory(onsuccessfulconstruct),
          check: constructFactory(onsuccessfulcheck),
          interrupt: constructFactory(onsuccessfulcheck, {
            interrupt: true
          }),
          lazy: constructFactory(onsuccessfulcheck, {
            lazy: true
          })
        } // State and tools for resolving and serializing.

        const context = {
          previous: null,
          events: [],
          parser: parser,
          sliceStream: sliceStream,
          sliceSerialize: sliceSerialize,
          now: now,
          defineSkip: skip,
          write: write
        } // The state function.

        let state = initialize.tokenize.call(context, effects) // Track which character we expect to be consumed, to catch bugs.

        if (initialize.resolveAll) {
          resolveAllConstructs.push(initialize)
        } // Store where we are in the input stream.

        point._index = 0
        point._bufferIndex = -1
        return context

        function write(slice) {
          chunks = chunkedPush(chunks, slice)
          main() // Exit if we’re not done, resolve might change stuff.

          if (chunks[chunks.length - 1] !== null) {
            return []
          }

          addResult(initialize, 0) // Otherwise, resolve, and exit.

          context.events = resolveAll(resolveAllConstructs, context.events, context)
          return context.events
        } //
  // Tools.
  //

        function sliceSerialize(token) {
          return serializeChunks(sliceStream(token))
        }

        function sliceStream(token) {
          return sliceChunks(chunks, token)
        }

        function now() {
          return shallow(point)
        }

        function skip(value) {
          columnStart[value.line] = value.column
          accountForPotentialSkip()
        } //
  // State management.
  //
  // Main loop (note that `_index` and `_bufferIndex` in `point` are modified by
  // `consume`).
  // Here is where we walk through the chunks, which either include strings of
  // several characters, or numerical character codes.
  // The reason to do this in a loop instead of a call is so the stack can
  // drain.

        function main() {
          let chunkIndex
          let chunk

          while (point._index < chunks.length) {
            chunk = chunks[point._index] // If we’re in a buffer chunk, loop through it.

            if (typeof chunk === 'string') {
              chunkIndex = point._index

              if (point._bufferIndex < 0) {
                point._bufferIndex = 0
              }

              while (
                point._index === chunkIndex &&
          point._bufferIndex < chunk.length
              ) {
                go(chunk.charCodeAt(point._bufferIndex))
              }
            } else {
              go(chunk)
            }
          }
        } // Deal with one code.

        function go(code) {
          state = state(code)
        } // Move a character forward.

        function consume(code) {
          if (markdownLineEnding(code)) {
            point.line++
            point.column = 1
            point.offset += code === -3 ? 2 : 1
            accountForPotentialSkip()
          } else if (code !== -1) {
            point.column++
            point.offset++
          } // Not in a string chunk.

          if (point._bufferIndex < 0) {
            point._index++
          } else {
            point._bufferIndex++ // At end of string chunk.

            if (point._bufferIndex === chunks[point._index].length) {
              point._bufferIndex = -1
              point._index++
            }
          } // Expose the previous character.

          context.previous = code // Mark as consumed.
        } // Start a token.

        function enter(type, fields) {
          const token = fields || {}
          token.type = type
          token.start = now()
          context.events.push(['enter', token, context])
          stack.push(token)
          return token
        } // Stop a token.

        function exit(type) {
          const token = stack.pop()
          token.end = now()
          context.events.push(['exit', token, context])
          return token
        } // Use results.

        function onsuccessfulconstruct(construct, info) {
          addResult(construct, info.from)
        } // Discard results.

        function onsuccessfulcheck(construct, info) {
          info.restore()
        } // Factory to attempt/check/interrupt.

        function constructFactory(onreturn, fields) {
          return hook // Handle either an object mapping codes to constructs, a list of
    // constructs, or a single construct.

          function hook(constructs, returnState, bogusState) {
            let listOfConstructs
            let constructIndex
            let currentConstruct
            let info
            return constructs.tokenize || 'length' in constructs
              ? handleListOfConstructs(miniflat(constructs))
              : handleMapOfConstructs

            function handleMapOfConstructs(code) {
              if (code in constructs || null in constructs) {
                return handleListOfConstructs(
                  constructs.null
                    ? /* c8 ignore next */
                    miniflat(constructs[code]).concat(miniflat(constructs.null))
                    : constructs[code]
                )(code)
              }

              return bogusState(code)
            }

            function handleListOfConstructs(list) {
              listOfConstructs = list
              constructIndex = 0
              return handleConstruct(list[constructIndex])
            }

            function handleConstruct(construct) {
              return start

              function start(code) {
          // To do: not nede to store if there is no bogus state, probably?
          // Currently doesn’t work because `inspect` in document does a check
          // w/o a bogus, which doesn’t make sense. But it does seem to help perf
          // by not storing.
                info = store()
                currentConstruct = construct

                if (!construct.partial) {
                  context.currentConstruct = construct
                }

                if (
                  construct.name &&
            context.parser.constructs.disable.null.indexOf(construct.name) > -1
                ) {
                  return nok()
                }

                return construct.tokenize.call(
                  fields ? assign({}, context, fields) : context,
                  effects,
                  ok,
                  nok
                )(code)
              }
            }

            function ok(code) {
              onreturn(currentConstruct, info)
              return returnState
            }

            function nok(code) {
              info.restore()

              if (++constructIndex < listOfConstructs.length) {
                return handleConstruct(listOfConstructs[constructIndex])
              }

              return bogusState
            }
          }
        }

        function addResult(construct, from) {
          if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {
            resolveAllConstructs.push(construct)
          }

          if (construct.resolve) {
            chunkedSplice(
              context.events,
              from,
              context.events.length - from,
              construct.resolve(context.events.slice(from), context)
            )
          }

          if (construct.resolveTo) {
            context.events = construct.resolveTo(context.events, context)
          }
        }

        function store() {
          const startPoint = now()
          const startPrevious = context.previous
          const startCurrentConstruct = context.currentConstruct
          const startEventsIndex = context.events.length
          const startStack = Array.from(stack)
          return {
            restore: restore,
            from: startEventsIndex
          }

          function restore() {
            point = startPoint
            context.previous = startPrevious
            context.currentConstruct = startCurrentConstruct
            context.events.length = startEventsIndex
            stack = startStack
            accountForPotentialSkip()
          }
        }

        function accountForPotentialSkip() {
          if (point.line in columnStart && point.column < 2) {
            point.column = columnStart[point.line]
            point.offset += columnStart[point.line] - 1
          }
        }
      }

      module.exports = createTokenizer


/***/ }),

/***/ "../../node_modules/micromark/dist/util/miniflat.js":
/*!**********************************************************!*\
  !*** ../../node_modules/micromark/dist/util/miniflat.js ***!
  \**********************************************************/
/***/ ((module) => {

      "use strict";


      function miniflat(value) {
        return value === null || value === undefined
          ? []
          : 'length' in value
            ? value
            : [value]
      }

      module.exports = miniflat


/***/ }),

/***/ "../../node_modules/micromark/dist/util/move-point.js":
/*!************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/move-point.js ***!
  \************************************************************/
/***/ ((module) => {

      "use strict";


// chunks (replacement characters, tabs, or line endings).

      function movePoint(point, offset) {
        point.column += offset
        point.offset += offset
        point._bufferIndex += offset
        return point
      }

      module.exports = movePoint


/***/ }),

/***/ "../../node_modules/micromark/dist/util/normalize-identifier.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/normalize-identifier.js ***!
  \**********************************************************************/
/***/ ((module) => {

      "use strict";


      function normalizeIdentifier(value) {
        return (
          value // Collapse Markdown whitespace.
            .replace(/[\t\n\r ]+/g, ' ') // Trim.
            .replace(/^ | $/g, '') // Some characters are considered “uppercase”, but if their lowercase
      // counterpart is uppercased will result in a different uppercase
      // character.
      // Hence, to get that form, we perform both lower- and uppercase.
      // Upper case makes sure keys will not interact with default prototypal
      // methods: no object method is uppercase.
            .toLowerCase()
            .toUpperCase()
        )
      }

      module.exports = normalizeIdentifier


/***/ }),

/***/ "../../node_modules/micromark/dist/util/prefix-size.js":
/*!*************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/prefix-size.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const sizeChunks = __webpack_require__(/*! ./size-chunks.js */ "../../node_modules/micromark/dist/util/size-chunks.js")

      function prefixSize(events, type) {
        const tail = events[events.length - 1]
        if (!tail || tail[1].type !== type) return 0
        return sizeChunks(tail[2].sliceStream(tail[1]))
      }

      module.exports = prefixSize


/***/ }),

/***/ "../../node_modules/micromark/dist/util/regex-check.js":
/*!*************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/regex-check.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const fromCharCode = __webpack_require__(/*! ../constant/from-char-code.js */ "../../node_modules/micromark/dist/constant/from-char-code.js")

      function regexCheck(regex) {
        return check

        function check(code) {
          return regex.test(fromCharCode(code))
        }
      }

      module.exports = regexCheck


/***/ }),

/***/ "../../node_modules/micromark/dist/util/resolve-all.js":
/*!*************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/resolve-all.js ***!
  \*************************************************************/
/***/ ((module) => {

      "use strict";


      function resolveAll(constructs, events, context) {
        const called = []
        let index = -1
        let resolve

        while (++index < constructs.length) {
          resolve = constructs[index].resolveAll

          if (resolve && called.indexOf(resolve) < 0) {
            events = resolve(events, context)
            called.push(resolve)
          }
        }

        return events
      }

      module.exports = resolveAll


/***/ }),

/***/ "../../node_modules/micromark/dist/util/safe-from-int.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/safe-from-int.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const fromCharCode = __webpack_require__(/*! ../constant/from-char-code.js */ "../../node_modules/micromark/dist/constant/from-char-code.js")

      function safeFromInt(value, base) {
        const code = parseInt(value, base)

        if (
    // C0 except for HT, LF, FF, CR, space
          code < 9 ||
    code === 11 ||
    (code > 13 && code < 32) || // Control character (DEL) of the basic block and C1 controls.
    (code > 126 && code < 160) || // Lone high surrogates and low surrogates.
    (code > 55295 && code < 57344) || // Noncharacters.
    (code > 64975 && code < 65008) ||
    (code & 65535) === 65535 ||
    (code & 65535) === 65534 || // Out of range
    code > 1114111
        ) {
          return '\uFFFD'
        }

        return fromCharCode(code)
      }

      module.exports = safeFromInt


/***/ }),

/***/ "../../node_modules/micromark/dist/util/serialize-chunks.js":
/*!******************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/serialize-chunks.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const fromCharCode = __webpack_require__(/*! ../constant/from-char-code.js */ "../../node_modules/micromark/dist/constant/from-char-code.js")

      function serializeChunks(chunks) {
        let index = -1
        const result = []
        let chunk
        let value
        let atTab

        while (++index < chunks.length) {
          chunk = chunks[index]

          if (typeof chunk === 'string') {
            value = chunk
          } else if (chunk === -5) {
            value = '\r'
          } else if (chunk === -4) {
            value = '\n'
          } else if (chunk === -3) {
            value = '\r' + '\n'
          } else if (chunk === -2) {
            value = '\t'
          } else if (chunk === -1) {
            if (atTab) continue
            value = ' '
          } else {
      // Currently only replacement character.
            value = fromCharCode(chunk)
          }

          atTab = chunk === -2
          result.push(value)
        }

        return result.join('')
      }

      module.exports = serializeChunks


/***/ }),

/***/ "../../node_modules/micromark/dist/util/shallow.js":
/*!*********************************************************!*\
  !*** ../../node_modules/micromark/dist/util/shallow.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const assign = __webpack_require__(/*! ../constant/assign.js */ "../../node_modules/micromark/dist/constant/assign.js")

      function shallow(object) {
        return assign({}, object)
      }

      module.exports = shallow


/***/ }),

/***/ "../../node_modules/micromark/dist/util/size-chunks.js":
/*!*************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/size-chunks.js ***!
  \*************************************************************/
/***/ ((module) => {

      "use strict";


// Counts tabs based on their expanded size, and CR+LF as one character.

      function sizeChunks(chunks) {
        let index = -1
        let size = 0

        while (++index < chunks.length) {
          size += typeof chunks[index] === 'string' ? chunks[index].length : 1
        }

        return size
      }

      module.exports = sizeChunks


/***/ }),

/***/ "../../node_modules/micromark/dist/util/slice-chunks.js":
/*!**************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/slice-chunks.js ***!
  \**************************************************************/
/***/ ((module) => {

      "use strict";


      function sliceChunks(chunks, token) {
        const startIndex = token.start._index
        const startBufferIndex = token.start._bufferIndex
        const endIndex = token.end._index
        const endBufferIndex = token.end._bufferIndex
        let view

        if (startIndex === endIndex) {
          view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]
        } else {
          view = chunks.slice(startIndex, endIndex)

          if (startBufferIndex > -1) {
            view[0] = view[0].slice(startBufferIndex)
          }

          if (endBufferIndex > 0) {
            view.push(chunks[endIndex].slice(0, endBufferIndex))
          }
        }

        return view
      }

      module.exports = sliceChunks


/***/ }),

/***/ "../../node_modules/micromark/dist/util/subtokenize.js":
/*!*************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/subtokenize.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const assign = __webpack_require__(/*! ../constant/assign.js */ "../../node_modules/micromark/dist/constant/assign.js")
      const chunkedSplice = __webpack_require__(/*! ./chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
      const shallow = __webpack_require__(/*! ./shallow.js */ "../../node_modules/micromark/dist/util/shallow.js")

      function subtokenize(events) {
        const jumps = {}
        let index = -1
        let event
        let lineIndex
        let otherIndex
        let otherEvent
        let parameters
        let subevents
        let more

        while (++index < events.length) {
          while (index in jumps) {
            index = jumps[index]
          }

          event = events[index] // Add a hook for the GFM tasklist extension, which needs to know if text
    // is in the first content of a list item.

          if (
            index &&
      event[1].type === 'chunkFlow' &&
      events[index - 1][1].type === 'listItemPrefix'
          ) {
            subevents = event[1]._tokenizer.events
            otherIndex = 0

            if (
              otherIndex < subevents.length &&
        subevents[otherIndex][1].type === 'lineEndingBlank'
            ) {
              otherIndex += 2
            }

            if (
              otherIndex < subevents.length &&
        subevents[otherIndex][1].type === 'content'
            ) {
              while (++otherIndex < subevents.length) {
                if (subevents[otherIndex][1].type === 'content') {
                  break
                }

                if (subevents[otherIndex][1].type === 'chunkText') {
                  subevents[otherIndex][1].isInFirstContentOfListItem = true
                  otherIndex++
                }
              }
            }
          } // Enter.

          if (event[0] === 'enter') {
            if (event[1].contentType) {
              assign(jumps, subcontent(events, index))
              index = jumps[index]
              more = true
            }
          } // Exit.
          else if (event[1]._container || event[1]._movePreviousLineEndings) {
            otherIndex = index
            lineIndex = undefined

            while (otherIndex--) {
              otherEvent = events[otherIndex]

              if (
                otherEvent[1].type === 'lineEnding' ||
          otherEvent[1].type === 'lineEndingBlank'
              ) {
                if (otherEvent[0] === 'enter') {
                  if (lineIndex) {
                    events[lineIndex][1].type = 'lineEndingBlank'
                  }

                  otherEvent[1].type = 'lineEnding'
                  lineIndex = otherIndex
                }
              } else {
                break
              }
            }

            if (lineIndex) {
        // Fix position.
              event[1].end = shallow(events[lineIndex][1].start) // Switch container exit w/ line endings.

              parameters = events.slice(lineIndex, index)
              parameters.unshift(event)
              chunkedSplice(events, lineIndex, index - lineIndex + 1, parameters)
            }
          }
        }

        return !more
      }

      function subcontent(events, eventIndex) {
        let token = events[eventIndex][1]
        const context = events[eventIndex][2]
        let startPosition = eventIndex - 1
        const startPositions = []
        const tokenizer =
    token._tokenizer || context.parser[token.contentType](token.start)
        const childEvents = tokenizer.events
        const jumps = []
        const gaps = {}
        let stream
        let previous
        let index
        let entered
        let end
        let adjust // Loop forward through the linked tokens to pass them in order to the
  // subtokenizer.

        while (token) {
    // Find the position of the event for this token.
          while (events[++startPosition][1] !== token) {
      // Empty.
          }

          startPositions.push(startPosition)

          if (!token._tokenizer) {
            stream = context.sliceStream(token)

            if (!token.next) {
              stream.push(null)
            }

            if (previous) {
              tokenizer.defineSkip(token.start)
            }

            if (token.isInFirstContentOfListItem) {
              tokenizer._gfmTasklistFirstContentOfListItem = true
            }

            tokenizer.write(stream)

            if (token.isInFirstContentOfListItem) {
              tokenizer._gfmTasklistFirstContentOfListItem = undefined
            }
          } // Unravel the next token.

          previous = token
          token = token.next
        } // Now, loop back through all events (and linked tokens), to figure out which
  // parts belong where.

        token = previous
        index = childEvents.length

        while (index--) {
    // Make sure we’ve at least seen something (final eol is part of the last
    // token).
          if (childEvents[index][0] === 'enter') {
            entered = true
          } else if (
      // Find a void token that includes a break.
            entered &&
      childEvents[index][1].type === childEvents[index - 1][1].type &&
      childEvents[index][1].start.line !== childEvents[index][1].end.line
          ) {
            add(childEvents.slice(index + 1, end))
      // Help GC.
            token._tokenizer = token.next = undefined
            token = token.previous
            end = index + 1
          }
        }

  // Help GC.
        tokenizer.events = token._tokenizer = token.next = undefined // Do head:

        add(childEvents.slice(0, end))
        index = -1
        adjust = 0

        while (++index < jumps.length) {
          gaps[adjust + jumps[index][0]] = adjust + jumps[index][1]
          adjust += jumps[index][1] - jumps[index][0] - 1
        }

        return gaps

        function add(slice) {
          const start = startPositions.pop()
          jumps.unshift([start, start + slice.length - 1])
          chunkedSplice(events, start, 2, slice)
        }
      }

      module.exports = subtokenize


/***/ }),

/***/ "../../node_modules/object-assign/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/object-assign/index.js ***!
  \*************************************************/
/***/ ((module) => {

      "use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
      const getOwnPropertySymbols = Object.getOwnPropertySymbols;
      const hasOwnProperty = Object.prototype.hasOwnProperty;
      const propIsEnumerable = Object.prototype.propertyIsEnumerable;

      function toObject(val) {
        if (val === null || val === undefined) {
          throw new TypeError('Object.assign cannot be called with null or undefined');
        }

        return Object(val);
      }

      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
          const test1 = new String('abc');  // eslint-disable-line no-new-wrappers
          test1[5] = 'de';
          if (Object.getOwnPropertyNames(test1)[0] === '5') {
            return false;
          }

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
          const test2 = {};
          for (let i = 0; i < 10; i++) {
            test2['_' + String.fromCharCode(i)] = i;
          }
          const order2 = Object.getOwnPropertyNames(test2).map(function (n) {
            return test2[n];
          });
          if (order2.join('') !== '0123456789') {
            return false;
          }

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
          const test3 = {};
          'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
            return false;
          }

          return true;
        } catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
          return false;
        }
      }

      module.exports = shouldUseNative() ? Object.assign : function (target, source) {
        let from;
        const to = toObject(target);
        let symbols;

        for (let s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);

          for (const key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }

          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (let i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }

        return to;
      };


/***/ }),

/***/ "../../node_modules/parse-entities/decode-entity.browser.js":
/*!******************************************************************!*\
  !*** ../../node_modules/parse-entities/decode-entity.browser.js ***!
  \******************************************************************/
/***/ ((module) => {

      "use strict";


/* eslint-env browser */

      let el

      const semicolon = 59 //  ';'

      module.exports = decodeEntity

      function decodeEntity(characters) {
        const entity = '&' + characters + ';'
        let char

        el = el || document.createElement('i')
        el.innerHTML = entity
        char = el.textContent

  // Some entities do not require the closing semicolon (`&not` - for instance),
  // which leads to situations where parsing the assumed entity of &notit; will
  // result in the string `¬it;`.  When we encounter a trailing semicolon after
  // parsing and the entity to decode was not a semicolon (`&semi;`), we can
  // assume that the matching was incomplete
        if (char.charCodeAt(char.length - 1) === semicolon && characters !== 'semi') {
          return false
        }

  // If the decoded string is equal to the input, the entity was not valid
        return char === entity ? false : char
      }


/***/ }),

/***/ "../../node_modules/prop-types/checkPropTypes.js":
/*!*******************************************************!*\
  !*** ../../node_modules/prop-types/checkPropTypes.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



      let printWarning = function() {};

      if (true) {
        var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js");
        var loggedTypeFailures = {};
        var has = __webpack_require__(/*! ./lib/has */ "../../node_modules/prop-types/lib/has.js");

        printWarning = function(text) {
          const message = 'Warning: ' + text;
          if (typeof console !== 'undefined') {
            console.error(message);
          }
          try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
            throw new Error(message);
          } catch (x) { /**/ }
        };
      }

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
      function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
        if (true) {
          for (const typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
              try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
                if (typeof typeSpecs[typeSpecName] !== 'function') {
                  const err = Error(
                    (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
                  );
                  err.name = 'Invariant Violation';
                  throw err;
                }
                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
              } catch (ex) {
                error = ex;
              }
              if (error && !(error instanceof Error)) {
                printWarning(
                  (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
                );
              }
              if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
                loggedTypeFailures[error.message] = true;

                const stack = getStack ? getStack() : '';

                printWarning(
                  'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
                );
              }
            }
          }
        }
      }

/**
 * Resets warning cache when testing.
 *
 * @private
 */
      checkPropTypes.resetWarningCache = function() {
        if (true) {
          loggedTypeFailures = {};
        }
      }

      module.exports = checkPropTypes;


/***/ }),

/***/ "../../node_modules/prop-types/factoryWithTypeCheckers.js":
/*!****************************************************************!*\
  !*** ../../node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



      const ReactIs = __webpack_require__(/*! react-is */ "../../node_modules/react-is/index.js");
      const assign = __webpack_require__(/*! object-assign */ "../../node_modules/object-assign/index.js");

      const ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js");
      const has = __webpack_require__(/*! ./lib/has */ "../../node_modules/prop-types/lib/has.js");
      const checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "../../node_modules/prop-types/checkPropTypes.js");

      let printWarning = function() {};

      if (true) {
        printWarning = function(text) {
          const message = 'Warning: ' + text;
          if (typeof console !== 'undefined') {
            console.error(message);
          }
          try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
            throw new Error(message);
          } catch (x) {}
        };
      }

      function emptyFunctionThatReturnsNull() {
        return null;
      }

      module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
        const ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
        const FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
        function getIteratorFn(maybeIterable) {
          const iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === 'function') {
            return iteratorFn;
          }
        }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

        const ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
        const ReactPropTypes = {
          array: createPrimitiveTypeChecker('array'),
          bigint: createPrimitiveTypeChecker('bigint'),
          bool: createPrimitiveTypeChecker('boolean'),
          func: createPrimitiveTypeChecker('function'),
          number: createPrimitiveTypeChecker('number'),
          object: createPrimitiveTypeChecker('object'),
          string: createPrimitiveTypeChecker('string'),
          symbol: createPrimitiveTypeChecker('symbol'),

          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          elementType: createElementTypeTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker,
        };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
        function is(x, y) {
    // SameValue algorithm
          if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
            return x !== 0 || 1 / x === 1 / y;
          } else {
      // Step 6.a: NaN == NaN
            return x !== x && y !== y;
          }
        }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
        function PropTypeError(message, data) {
          this.message = message;
          this.data = data && typeof data === 'object' ? data: {};
          this.stack = '';
        }
  // Make `instanceof Error` still work for returned errors.
        PropTypeError.prototype = Error.prototype;

        function createChainableTypeChecker(validate) {
          if (true) {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;

            if (secret !== ReactPropTypesSecret) {
              if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
                const err = new Error(
                  'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
                );
                err.name = 'Invariant Violation';
                throw err;
              } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
                const cacheKey = componentName + ':' + propName;
                if (
                  !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
                ) {
                  printWarning(
                    'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
                  );
                  manualPropTypeCallCache[cacheKey] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
                }
                return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
              }
              return null;
            } else {
              return validate(props, propName, componentName, location, propFullName);
            }
          }

          const chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);

          return chainedCheckType;
        }

        function createPrimitiveTypeChecker(expectedType) {
          function validate(props, propName, componentName, location, propFullName, secret) {
            const propValue = props[propName];
            const propType = getPropType(propValue);
            if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
              const preciseType = getPreciseType(propValue);

              return new PropTypeError(
                'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
                {expectedType: expectedType}
              );
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createAnyTypeChecker() {
          return createChainableTypeChecker(emptyFunctionThatReturnsNull);
        }

        function createArrayOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
              return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
            }
            const propValue = props[propName];
            if (!Array.isArray(propValue)) {
              const propType = getPropType(propValue);
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
            }
            for (let i = 0; i < propValue.length; i++) {
              const error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createElementTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            const propValue = props[propName];
            if (!isValidElement(propValue)) {
              const propType = getPropType(propValue);
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createElementTypeTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            const propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
              const propType = getPropType(propValue);
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createInstanceTypeChecker(expectedClass) {
          function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              const expectedClassName = expectedClass.name || ANONYMOUS;
              const actualClassName = getClassName(props[propName]);
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            if (true) {
              if (arguments.length > 1) {
                printWarning(
                  'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
                );
              } else {
                printWarning('Invalid argument supplied to oneOf, expected an array.');
              }
            }
            return emptyFunctionThatReturnsNull;
          }

          function validate(props, propName, componentName, location, propFullName) {
            const propValue = props[propName];
            for (let i = 0; i < expectedValues.length; i++) {
              if (is(propValue, expectedValues[i])) {
                return null;
              }
            }

            const valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
              const type = getPreciseType(value);
              if (type === 'symbol') {
                return String(value);
              }
              return value;
            });
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
          }
          return createChainableTypeChecker(validate);
        }

        function createObjectOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
              return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
            }
            const propValue = props[propName];
            const propType = getPropType(propValue);
            if (propType !== 'object') {
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
            }
            for (const key in propValue) {
              if (has(propValue, key)) {
                const error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error instanceof Error) {
                  return error;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;
            return emptyFunctionThatReturnsNull;
          }

          for (let i = 0; i < arrayOfTypeCheckers.length; i++) {
            const checker = arrayOfTypeCheckers[i];
            if (typeof checker !== 'function') {
              printWarning(
                'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
              );
              return emptyFunctionThatReturnsNull;
            }
          }

          function validate(props, propName, componentName, location, propFullName) {
            const expectedTypes = [];
            for (let i = 0; i < arrayOfTypeCheckers.length; i++) {
              const checker = arrayOfTypeCheckers[i];
              const checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
              if (checkerResult == null) {
                return null;
              }
              if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
                expectedTypes.push(checkerResult.data.expectedType);
              }
            }
            const expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
          }
          return createChainableTypeChecker(validate);
        }

        function createNodeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function invalidValidatorError(componentName, location, propFullName, key, type) {
          return new PropTypeError(
            (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
          );
        }

        function createShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            const propValue = props[propName];
            const propType = getPropType(propValue);
            if (propType !== 'object') {
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
            for (const key in shapeTypes) {
              const checker = shapeTypes[key];
              if (typeof checker !== 'function') {
                return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
              }
              const error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createStrictShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            const propValue = props[propName];
            const propType = getPropType(propValue);
            if (propType !== 'object') {
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
      // We need to check all keys in case some are required but missing from props.
            const allKeys = assign({}, props[propName], shapeTypes);
            for (const key in allKeys) {
              const checker = shapeTypes[key];
              if (has(shapeTypes, key) && typeof checker !== 'function') {
                return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
              }
              if (!checker) {
                return new PropTypeError(
                  'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
                );
              }
              const error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }

          return createChainableTypeChecker(validate);
        }

        function isNode(propValue) {
          switch (typeof propValue) {
            case 'number':
            case 'string':
            case 'undefined':
              return true;
            case 'boolean':
              return !propValue;
            case 'object':
              if (Array.isArray(propValue)) {
                return propValue.every(isNode);
              }
              if (propValue === null || isValidElement(propValue)) {
                return true;
              }

              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                const iterator = iteratorFn.call(propValue);
                let step;
                if (iteratorFn !== propValue.entries) {
                  while (!(step = iterator.next()).done) {
                    if (!isNode(step.value)) {
                      return false;
                    }
                  }
                } else {
            // Iterator will provide entry [k,v] tuples rather than values.
                  while (!(step = iterator.next()).done) {
                    const entry = step.value;
                    if (entry) {
                      if (!isNode(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }

              return true;
            default:
              return false;
          }
        }

        function isSymbol(propType, propValue) {
    // Native Symbol.
          if (propType === 'symbol') {
            return true;
          }

    // falsy value can't be a Symbol
          if (!propValue) {
            return false;
          }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
          if (propValue['@@toStringTag'] === 'Symbol') {
            return true;
          }

    // Fallback for non-spec compliant Symbols which are polyfilled.
          if (typeof Symbol === 'function' && propValue instanceof Symbol) {
            return true;
          }

          return false;
        }

  // Equivalent of `typeof` but with special handling for array and regexp.
        function getPropType(propValue) {
          const propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return 'array';
          }
          if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
            return 'object';
          }
          if (isSymbol(propType, propValue)) {
            return 'symbol';
          }
          return propType;
        }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
        function getPreciseType(propValue) {
          if (typeof propValue === 'undefined' || propValue === null) {
            return '' + propValue;
          }
          const propType = getPropType(propValue);
          if (propType === 'object') {
            if (propValue instanceof Date) {
              return 'date';
            } else if (propValue instanceof RegExp) {
              return 'regexp';
            }
          }
          return propType;
        }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
        function getPostfixForTypeWarning(value) {
          const type = getPreciseType(value);
          switch (type) {
            case 'array':
            case 'object':
              return 'an ' + type;
            case 'boolean':
            case 'date':
            case 'regexp':
              return 'a ' + type;
            default:
              return type;
          }
        }

  // Returns class name of the object, if any.
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }

        ReactPropTypes.checkPropTypes = checkPropTypes;
        ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
        ReactPropTypes.PropTypes = ReactPropTypes;

        return ReactPropTypes;
      };


/***/ }),

/***/ "../../node_modules/prop-types/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/prop-types/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

      if (true) {
        const ReactIs = __webpack_require__(/*! react-is */ "../../node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
        const throwOnDirectAccess = true;
        module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "../../node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
      } else // removed by dead control flow
      {}


/***/ }),

/***/ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*****************************************************************/
/***/ ((module) => {

      "use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



      const ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

      module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "../../node_modules/prop-types/lib/has.js":
/*!************************************************!*\
  !*** ../../node_modules/prop-types/lib/has.js ***!
  \************************************************/
/***/ ((module) => {

      module.exports = Function.call.bind(Object.prototype.hasOwnProperty);


/***/ }),

/***/ "../../node_modules/property-information/find.js":
/*!*******************************************************!*\
  !*** ../../node_modules/property-information/find.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const normalize = __webpack_require__(/*! ./normalize */ "../../node_modules/property-information/normalize.js")
      const DefinedInfo = __webpack_require__(/*! ./lib/util/defined-info */ "../../node_modules/property-information/lib/util/defined-info.js")
      const Info = __webpack_require__(/*! ./lib/util/info */ "../../node_modules/property-information/lib/util/info.js")

      const data = 'data'

      module.exports = find

      const valid = /^data[-\w.:]+$/i
      const dash = /-[a-z]/g
      const cap = /[A-Z]/g

      function find(schema, value) {
        const normal = normalize(value)
        let prop = value
        let Type = Info

        if (normal in schema.normal) {
          return schema.property[schema.normal[normal]]
        }

        if (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value)) {
    // Attribute or property.
          if (value.charAt(4) === '-') {
            prop = datasetToProperty(value)
          } else {
            value = datasetToAttribute(value)
          }

          Type = DefinedInfo
        }

        return new Type(prop, value)
      }

      function datasetToProperty(attribute) {
        const value = attribute.slice(5).replace(dash, camelcase)
        return data + value.charAt(0).toUpperCase() + value.slice(1)
      }

      function datasetToAttribute(property) {
        let value = property.slice(4)

        if (dash.test(value)) {
          return property
        }

        value = value.replace(cap, kebab)

        if (value.charAt(0) !== '-') {
          value = '-' + value
        }

        return data + value
      }

      function kebab($0) {
        return '-' + $0.toLowerCase()
      }

      function camelcase($0) {
        return $0.charAt(1).toUpperCase()
      }


/***/ }),

/***/ "../../node_modules/property-information/hast-to-react.json":
/*!******************************************************************!*\
  !*** ../../node_modules/property-information/hast-to-react.json ***!
  \******************************************************************/
/***/ ((module) => {

      "use strict";
      module.exports = /*#__PURE__*/JSON.parse('{"classId":"classID","dataType":"datatype","itemId":"itemID","strokeDashArray":"strokeDasharray","strokeDashOffset":"strokeDashoffset","strokeLineCap":"strokeLinecap","strokeLineJoin":"strokeLinejoin","strokeMiterLimit":"strokeMiterlimit","typeOf":"typeof","xLinkActuate":"xlinkActuate","xLinkArcRole":"xlinkArcrole","xLinkHref":"xlinkHref","xLinkRole":"xlinkRole","xLinkShow":"xlinkShow","xLinkTitle":"xlinkTitle","xLinkType":"xlinkType","xmlnsXLink":"xmlnsXlink"}');

/***/ }),

/***/ "../../node_modules/property-information/html.js":
/*!*******************************************************!*\
  !*** ../../node_modules/property-information/html.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const merge = __webpack_require__(/*! ./lib/util/merge */ "../../node_modules/property-information/lib/util/merge.js")
      const xlink = __webpack_require__(/*! ./lib/xlink */ "../../node_modules/property-information/lib/xlink.js")
      const xml = __webpack_require__(/*! ./lib/xml */ "../../node_modules/property-information/lib/xml.js")
      const xmlns = __webpack_require__(/*! ./lib/xmlns */ "../../node_modules/property-information/lib/xmlns.js")
      const aria = __webpack_require__(/*! ./lib/aria */ "../../node_modules/property-information/lib/aria.js")
      const html = __webpack_require__(/*! ./lib/html */ "../../node_modules/property-information/lib/html.js")

      module.exports = merge([xml, xlink, xmlns, aria, html])


/***/ }),

/***/ "../../node_modules/property-information/lib/aria.js":
/*!***********************************************************!*\
  !*** ../../node_modules/property-information/lib/aria.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const types = __webpack_require__(/*! ./util/types */ "../../node_modules/property-information/lib/util/types.js")
      const create = __webpack_require__(/*! ./util/create */ "../../node_modules/property-information/lib/util/create.js")

      const booleanish = types.booleanish
      const number = types.number
      const spaceSeparated = types.spaceSeparated

      module.exports = create({
        transform: ariaTransform,
        properties: {
          ariaActiveDescendant: null,
          ariaAtomic: booleanish,
          ariaAutoComplete: null,
          ariaBusy: booleanish,
          ariaChecked: booleanish,
          ariaColCount: number,
          ariaColIndex: number,
          ariaColSpan: number,
          ariaControls: spaceSeparated,
          ariaCurrent: null,
          ariaDescribedBy: spaceSeparated,
          ariaDetails: null,
          ariaDisabled: booleanish,
          ariaDropEffect: spaceSeparated,
          ariaErrorMessage: null,
          ariaExpanded: booleanish,
          ariaFlowTo: spaceSeparated,
          ariaGrabbed: booleanish,
          ariaHasPopup: null,
          ariaHidden: booleanish,
          ariaInvalid: null,
          ariaKeyShortcuts: null,
          ariaLabel: null,
          ariaLabelledBy: spaceSeparated,
          ariaLevel: number,
          ariaLive: null,
          ariaModal: booleanish,
          ariaMultiLine: booleanish,
          ariaMultiSelectable: booleanish,
          ariaOrientation: null,
          ariaOwns: spaceSeparated,
          ariaPlaceholder: null,
          ariaPosInSet: number,
          ariaPressed: booleanish,
          ariaReadOnly: booleanish,
          ariaRelevant: null,
          ariaRequired: booleanish,
          ariaRoleDescription: spaceSeparated,
          ariaRowCount: number,
          ariaRowIndex: number,
          ariaRowSpan: number,
          ariaSelected: booleanish,
          ariaSetSize: number,
          ariaSort: null,
          ariaValueMax: number,
          ariaValueMin: number,
          ariaValueNow: number,
          ariaValueText: null,
          role: null
        }
      })

      function ariaTransform(_, prop) {
        return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase()
      }


/***/ }),

/***/ "../../node_modules/property-information/lib/html.js":
/*!***********************************************************!*\
  !*** ../../node_modules/property-information/lib/html.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const types = __webpack_require__(/*! ./util/types */ "../../node_modules/property-information/lib/util/types.js")
      const create = __webpack_require__(/*! ./util/create */ "../../node_modules/property-information/lib/util/create.js")
      const caseInsensitiveTransform = __webpack_require__(/*! ./util/case-insensitive-transform */ "../../node_modules/property-information/lib/util/case-insensitive-transform.js")

      const boolean = types.boolean
      const overloadedBoolean = types.overloadedBoolean
      const booleanish = types.booleanish
      const number = types.number
      const spaceSeparated = types.spaceSeparated
      const commaSeparated = types.commaSeparated

      module.exports = create({
        space: 'html',
        attributes: {
          acceptcharset: 'accept-charset',
          classname: 'class',
          htmlfor: 'for',
          httpequiv: 'http-equiv'
        },
        transform: caseInsensitiveTransform,
        mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],
        properties: {
    // Standard Properties.
          abbr: null,
          accept: commaSeparated,
          acceptCharset: spaceSeparated,
          accessKey: spaceSeparated,
          action: null,
          allow: null,
          allowFullScreen: boolean,
          allowPaymentRequest: boolean,
          allowUserMedia: boolean,
          alt: null,
          as: null,
          async: boolean,
          autoCapitalize: null,
          autoComplete: spaceSeparated,
          autoFocus: boolean,
          autoPlay: boolean,
          capture: boolean,
          charSet: null,
          checked: boolean,
          cite: null,
          className: spaceSeparated,
          cols: number,
          colSpan: null,
          content: null,
          contentEditable: booleanish,
          controls: boolean,
          controlsList: spaceSeparated,
          coords: number | commaSeparated,
          crossOrigin: null,
          data: null,
          dateTime: null,
          decoding: null,
          default: boolean,
          defer: boolean,
          dir: null,
          dirName: null,
          disabled: boolean,
          download: overloadedBoolean,
          draggable: booleanish,
          encType: null,
          enterKeyHint: null,
          form: null,
          formAction: null,
          formEncType: null,
          formMethod: null,
          formNoValidate: boolean,
          formTarget: null,
          headers: spaceSeparated,
          height: number,
          hidden: boolean,
          high: number,
          href: null,
          hrefLang: null,
          htmlFor: spaceSeparated,
          httpEquiv: spaceSeparated,
          id: null,
          imageSizes: null,
          imageSrcSet: commaSeparated,
          inputMode: null,
          integrity: null,
          is: null,
          isMap: boolean,
          itemId: null,
          itemProp: spaceSeparated,
          itemRef: spaceSeparated,
          itemScope: boolean,
          itemType: spaceSeparated,
          kind: null,
          label: null,
          lang: null,
          language: null,
          list: null,
          loading: null,
          loop: boolean,
          low: number,
          manifest: null,
          max: null,
          maxLength: number,
          media: null,
          method: null,
          min: null,
          minLength: number,
          multiple: boolean,
          muted: boolean,
          name: null,
          nonce: null,
          noModule: boolean,
          noValidate: boolean,
          onAbort: null,
          onAfterPrint: null,
          onAuxClick: null,
          onBeforePrint: null,
          onBeforeUnload: null,
          onBlur: null,
          onCancel: null,
          onCanPlay: null,
          onCanPlayThrough: null,
          onChange: null,
          onClick: null,
          onClose: null,
          onContextMenu: null,
          onCopy: null,
          onCueChange: null,
          onCut: null,
          onDblClick: null,
          onDrag: null,
          onDragEnd: null,
          onDragEnter: null,
          onDragExit: null,
          onDragLeave: null,
          onDragOver: null,
          onDragStart: null,
          onDrop: null,
          onDurationChange: null,
          onEmptied: null,
          onEnded: null,
          onError: null,
          onFocus: null,
          onFormData: null,
          onHashChange: null,
          onInput: null,
          onInvalid: null,
          onKeyDown: null,
          onKeyPress: null,
          onKeyUp: null,
          onLanguageChange: null,
          onLoad: null,
          onLoadedData: null,
          onLoadedMetadata: null,
          onLoadEnd: null,
          onLoadStart: null,
          onMessage: null,
          onMessageError: null,
          onMouseDown: null,
          onMouseEnter: null,
          onMouseLeave: null,
          onMouseMove: null,
          onMouseOut: null,
          onMouseOver: null,
          onMouseUp: null,
          onOffline: null,
          onOnline: null,
          onPageHide: null,
          onPageShow: null,
          onPaste: null,
          onPause: null,
          onPlay: null,
          onPlaying: null,
          onPopState: null,
          onProgress: null,
          onRateChange: null,
          onRejectionHandled: null,
          onReset: null,
          onResize: null,
          onScroll: null,
          onSecurityPolicyViolation: null,
          onSeeked: null,
          onSeeking: null,
          onSelect: null,
          onSlotChange: null,
          onStalled: null,
          onStorage: null,
          onSubmit: null,
          onSuspend: null,
          onTimeUpdate: null,
          onToggle: null,
          onUnhandledRejection: null,
          onUnload: null,
          onVolumeChange: null,
          onWaiting: null,
          onWheel: null,
          open: boolean,
          optimum: number,
          pattern: null,
          ping: spaceSeparated,
          placeholder: null,
          playsInline: boolean,
          poster: null,
          preload: null,
          readOnly: boolean,
          referrerPolicy: null,
          rel: spaceSeparated,
          required: boolean,
          reversed: boolean,
          rows: number,
          rowSpan: number,
          sandbox: spaceSeparated,
          scope: null,
          scoped: boolean,
          seamless: boolean,
          selected: boolean,
          shape: null,
          size: number,
          sizes: null,
          slot: null,
          span: number,
          spellCheck: booleanish,
          src: null,
          srcDoc: null,
          srcLang: null,
          srcSet: commaSeparated,
          start: number,
          step: null,
          style: null,
          tabIndex: number,
          target: null,
          title: null,
          translate: null,
          type: null,
          typeMustMatch: boolean,
          useMap: null,
          value: booleanish,
          width: number,
          wrap: null,

    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
          align: null, // Several. Use CSS `text-align` instead,
          aLink: null, // `<body>`. Use CSS `a:active {color}` instead
          archive: spaceSeparated, // `<object>`. List of URIs to archives
          axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`
          background: null, // `<body>`. Use CSS `background-image` instead
          bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead
          border: number, // `<table>`. Use CSS `border-width` instead,
          borderColor: null, // `<table>`. Use CSS `border-color` instead,
          bottomMargin: number, // `<body>`
          cellPadding: null, // `<table>`
          cellSpacing: null, // `<table>`
          char: null, // Several table elements. When `align=char`, sets the character to align on
          charOff: null, // Several table elements. When `char`, offsets the alignment
          classId: null, // `<object>`
          clear: null, // `<br>`. Use CSS `clear` instead
          code: null, // `<object>`
          codeBase: null, // `<object>`
          codeType: null, // `<object>`
          color: null, // `<font>` and `<hr>`. Use CSS instead
          compact: boolean, // Lists. Use CSS to reduce space between items instead
          declare: boolean, // `<object>`
          event: null, // `<script>`
          face: null, // `<font>`. Use CSS instead
          frame: null, // `<table>`
          frameBorder: null, // `<iframe>`. Use CSS `border` instead
          hSpace: number, // `<img>` and `<object>`
          leftMargin: number, // `<body>`
          link: null, // `<body>`. Use CSS `a:link {color: *}` instead
          longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
          lowSrc: null, // `<img>`. Use a `<picture>`
          marginHeight: number, // `<body>`
          marginWidth: number, // `<body>`
          noResize: boolean, // `<frame>`
          noHref: boolean, // `<area>`. Use no href instead of an explicit `nohref`
          noShade: boolean, // `<hr>`. Use background-color and height instead of borders
          noWrap: boolean, // `<td>` and `<th>`
          object: null, // `<applet>`
          profile: null, // `<head>`
          prompt: null, // `<isindex>`
          rev: null, // `<link>`
          rightMargin: number, // `<body>`
          rules: null, // `<table>`
          scheme: null, // `<meta>`
          scrolling: booleanish, // `<frame>`. Use overflow in the child context
          standby: null, // `<object>`
          summary: null, // `<table>`
          text: null, // `<body>`. Use CSS `color` instead
          topMargin: number, // `<body>`
          valueType: null, // `<param>`
          version: null, // `<html>`. Use a doctype.
          vAlign: null, // Several. Use CSS `vertical-align` instead
          vLink: null, // `<body>`. Use CSS `a:visited {color}` instead
          vSpace: number, // `<img>` and `<object>`

    // Non-standard Properties.
          allowTransparency: null,
          autoCorrect: null,
          autoSave: null,
          disablePictureInPicture: boolean,
          disableRemotePlayback: boolean,
          prefix: null,
          property: null,
          results: number,
          security: null,
          unselectable: null
        }
      })


/***/ }),

/***/ "../../node_modules/property-information/lib/svg.js":
/*!**********************************************************!*\
  !*** ../../node_modules/property-information/lib/svg.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const types = __webpack_require__(/*! ./util/types */ "../../node_modules/property-information/lib/util/types.js")
      const create = __webpack_require__(/*! ./util/create */ "../../node_modules/property-information/lib/util/create.js")
      const caseSensitiveTransform = __webpack_require__(/*! ./util/case-sensitive-transform */ "../../node_modules/property-information/lib/util/case-sensitive-transform.js")

      const boolean = types.boolean
      const number = types.number
      const spaceSeparated = types.spaceSeparated
      const commaSeparated = types.commaSeparated
      const commaOrSpaceSeparated = types.commaOrSpaceSeparated

      module.exports = create({
        space: 'svg',
        attributes: {
          accentHeight: 'accent-height',
          alignmentBaseline: 'alignment-baseline',
          arabicForm: 'arabic-form',
          baselineShift: 'baseline-shift',
          capHeight: 'cap-height',
          className: 'class',
          clipPath: 'clip-path',
          clipRule: 'clip-rule',
          colorInterpolation: 'color-interpolation',
          colorInterpolationFilters: 'color-interpolation-filters',
          colorProfile: 'color-profile',
          colorRendering: 'color-rendering',
          crossOrigin: 'crossorigin',
          dataType: 'datatype',
          dominantBaseline: 'dominant-baseline',
          enableBackground: 'enable-background',
          fillOpacity: 'fill-opacity',
          fillRule: 'fill-rule',
          floodColor: 'flood-color',
          floodOpacity: 'flood-opacity',
          fontFamily: 'font-family',
          fontSize: 'font-size',
          fontSizeAdjust: 'font-size-adjust',
          fontStretch: 'font-stretch',
          fontStyle: 'font-style',
          fontVariant: 'font-variant',
          fontWeight: 'font-weight',
          glyphName: 'glyph-name',
          glyphOrientationHorizontal: 'glyph-orientation-horizontal',
          glyphOrientationVertical: 'glyph-orientation-vertical',
          hrefLang: 'hreflang',
          horizAdvX: 'horiz-adv-x',
          horizOriginX: 'horiz-origin-x',
          horizOriginY: 'horiz-origin-y',
          imageRendering: 'image-rendering',
          letterSpacing: 'letter-spacing',
          lightingColor: 'lighting-color',
          markerEnd: 'marker-end',
          markerMid: 'marker-mid',
          markerStart: 'marker-start',
          navDown: 'nav-down',
          navDownLeft: 'nav-down-left',
          navDownRight: 'nav-down-right',
          navLeft: 'nav-left',
          navNext: 'nav-next',
          navPrev: 'nav-prev',
          navRight: 'nav-right',
          navUp: 'nav-up',
          navUpLeft: 'nav-up-left',
          navUpRight: 'nav-up-right',
          onAbort: 'onabort',
          onActivate: 'onactivate',
          onAfterPrint: 'onafterprint',
          onBeforePrint: 'onbeforeprint',
          onBegin: 'onbegin',
          onCancel: 'oncancel',
          onCanPlay: 'oncanplay',
          onCanPlayThrough: 'oncanplaythrough',
          onChange: 'onchange',
          onClick: 'onclick',
          onClose: 'onclose',
          onCopy: 'oncopy',
          onCueChange: 'oncuechange',
          onCut: 'oncut',
          onDblClick: 'ondblclick',
          onDrag: 'ondrag',
          onDragEnd: 'ondragend',
          onDragEnter: 'ondragenter',
          onDragExit: 'ondragexit',
          onDragLeave: 'ondragleave',
          onDragOver: 'ondragover',
          onDragStart: 'ondragstart',
          onDrop: 'ondrop',
          onDurationChange: 'ondurationchange',
          onEmptied: 'onemptied',
          onEnd: 'onend',
          onEnded: 'onended',
          onError: 'onerror',
          onFocus: 'onfocus',
          onFocusIn: 'onfocusin',
          onFocusOut: 'onfocusout',
          onHashChange: 'onhashchange',
          onInput: 'oninput',
          onInvalid: 'oninvalid',
          onKeyDown: 'onkeydown',
          onKeyPress: 'onkeypress',
          onKeyUp: 'onkeyup',
          onLoad: 'onload',
          onLoadedData: 'onloadeddata',
          onLoadedMetadata: 'onloadedmetadata',
          onLoadStart: 'onloadstart',
          onMessage: 'onmessage',
          onMouseDown: 'onmousedown',
          onMouseEnter: 'onmouseenter',
          onMouseLeave: 'onmouseleave',
          onMouseMove: 'onmousemove',
          onMouseOut: 'onmouseout',
          onMouseOver: 'onmouseover',
          onMouseUp: 'onmouseup',
          onMouseWheel: 'onmousewheel',
          onOffline: 'onoffline',
          onOnline: 'ononline',
          onPageHide: 'onpagehide',
          onPageShow: 'onpageshow',
          onPaste: 'onpaste',
          onPause: 'onpause',
          onPlay: 'onplay',
          onPlaying: 'onplaying',
          onPopState: 'onpopstate',
          onProgress: 'onprogress',
          onRateChange: 'onratechange',
          onRepeat: 'onrepeat',
          onReset: 'onreset',
          onResize: 'onresize',
          onScroll: 'onscroll',
          onSeeked: 'onseeked',
          onSeeking: 'onseeking',
          onSelect: 'onselect',
          onShow: 'onshow',
          onStalled: 'onstalled',
          onStorage: 'onstorage',
          onSubmit: 'onsubmit',
          onSuspend: 'onsuspend',
          onTimeUpdate: 'ontimeupdate',
          onToggle: 'ontoggle',
          onUnload: 'onunload',
          onVolumeChange: 'onvolumechange',
          onWaiting: 'onwaiting',
          onZoom: 'onzoom',
          overlinePosition: 'overline-position',
          overlineThickness: 'overline-thickness',
          paintOrder: 'paint-order',
          panose1: 'panose-1',
          pointerEvents: 'pointer-events',
          referrerPolicy: 'referrerpolicy',
          renderingIntent: 'rendering-intent',
          shapeRendering: 'shape-rendering',
          stopColor: 'stop-color',
          stopOpacity: 'stop-opacity',
          strikethroughPosition: 'strikethrough-position',
          strikethroughThickness: 'strikethrough-thickness',
          strokeDashArray: 'stroke-dasharray',
          strokeDashOffset: 'stroke-dashoffset',
          strokeLineCap: 'stroke-linecap',
          strokeLineJoin: 'stroke-linejoin',
          strokeMiterLimit: 'stroke-miterlimit',
          strokeOpacity: 'stroke-opacity',
          strokeWidth: 'stroke-width',
          tabIndex: 'tabindex',
          textAnchor: 'text-anchor',
          textDecoration: 'text-decoration',
          textRendering: 'text-rendering',
          typeOf: 'typeof',
          underlinePosition: 'underline-position',
          underlineThickness: 'underline-thickness',
          unicodeBidi: 'unicode-bidi',
          unicodeRange: 'unicode-range',
          unitsPerEm: 'units-per-em',
          vAlphabetic: 'v-alphabetic',
          vHanging: 'v-hanging',
          vIdeographic: 'v-ideographic',
          vMathematical: 'v-mathematical',
          vectorEffect: 'vector-effect',
          vertAdvY: 'vert-adv-y',
          vertOriginX: 'vert-origin-x',
          vertOriginY: 'vert-origin-y',
          wordSpacing: 'word-spacing',
          writingMode: 'writing-mode',
          xHeight: 'x-height',
    // These were camelcased in Tiny. Now lowercased in SVG 2
          playbackOrder: 'playbackorder',
          timelineBegin: 'timelinebegin'
        },
        transform: caseSensitiveTransform,
        properties: {
          about: commaOrSpaceSeparated,
          accentHeight: number,
          accumulate: null,
          additive: null,
          alignmentBaseline: null,
          alphabetic: number,
          amplitude: number,
          arabicForm: null,
          ascent: number,
          attributeName: null,
          attributeType: null,
          azimuth: number,
          bandwidth: null,
          baselineShift: null,
          baseFrequency: null,
          baseProfile: null,
          bbox: null,
          begin: null,
          bias: number,
          by: null,
          calcMode: null,
          capHeight: number,
          className: spaceSeparated,
          clip: null,
          clipPath: null,
          clipPathUnits: null,
          clipRule: null,
          color: null,
          colorInterpolation: null,
          colorInterpolationFilters: null,
          colorProfile: null,
          colorRendering: null,
          content: null,
          contentScriptType: null,
          contentStyleType: null,
          crossOrigin: null,
          cursor: null,
          cx: null,
          cy: null,
          d: null,
          dataType: null,
          defaultAction: null,
          descent: number,
          diffuseConstant: number,
          direction: null,
          display: null,
          dur: null,
          divisor: number,
          dominantBaseline: null,
          download: boolean,
          dx: null,
          dy: null,
          edgeMode: null,
          editable: null,
          elevation: number,
          enableBackground: null,
          end: null,
          event: null,
          exponent: number,
          externalResourcesRequired: null,
          fill: null,
          fillOpacity: number,
          fillRule: null,
          filter: null,
          filterRes: null,
          filterUnits: null,
          floodColor: null,
          floodOpacity: null,
          focusable: null,
          focusHighlight: null,
          fontFamily: null,
          fontSize: null,
          fontSizeAdjust: null,
          fontStretch: null,
          fontStyle: null,
          fontVariant: null,
          fontWeight: null,
          format: null,
          fr: null,
          from: null,
          fx: null,
          fy: null,
          g1: commaSeparated,
          g2: commaSeparated,
          glyphName: commaSeparated,
          glyphOrientationHorizontal: null,
          glyphOrientationVertical: null,
          glyphRef: null,
          gradientTransform: null,
          gradientUnits: null,
          handler: null,
          hanging: number,
          hatchContentUnits: null,
          hatchUnits: null,
          height: null,
          href: null,
          hrefLang: null,
          horizAdvX: number,
          horizOriginX: number,
          horizOriginY: number,
          id: null,
          ideographic: number,
          imageRendering: null,
          initialVisibility: null,
          in: null,
          in2: null,
          intercept: number,
          k: number,
          k1: number,
          k2: number,
          k3: number,
          k4: number,
          kernelMatrix: commaOrSpaceSeparated,
          kernelUnitLength: null,
          keyPoints: null, // SEMI_COLON_SEPARATED
          keySplines: null, // SEMI_COLON_SEPARATED
          keyTimes: null, // SEMI_COLON_SEPARATED
          kerning: null,
          lang: null,
          lengthAdjust: null,
          letterSpacing: null,
          lightingColor: null,
          limitingConeAngle: number,
          local: null,
          markerEnd: null,
          markerMid: null,
          markerStart: null,
          markerHeight: null,
          markerUnits: null,
          markerWidth: null,
          mask: null,
          maskContentUnits: null,
          maskUnits: null,
          mathematical: null,
          max: null,
          media: null,
          mediaCharacterEncoding: null,
          mediaContentEncodings: null,
          mediaSize: number,
          mediaTime: null,
          method: null,
          min: null,
          mode: null,
          name: null,
          navDown: null,
          navDownLeft: null,
          navDownRight: null,
          navLeft: null,
          navNext: null,
          navPrev: null,
          navRight: null,
          navUp: null,
          navUpLeft: null,
          navUpRight: null,
          numOctaves: null,
          observer: null,
          offset: null,
          onAbort: null,
          onActivate: null,
          onAfterPrint: null,
          onBeforePrint: null,
          onBegin: null,
          onCancel: null,
          onCanPlay: null,
          onCanPlayThrough: null,
          onChange: null,
          onClick: null,
          onClose: null,
          onCopy: null,
          onCueChange: null,
          onCut: null,
          onDblClick: null,
          onDrag: null,
          onDragEnd: null,
          onDragEnter: null,
          onDragExit: null,
          onDragLeave: null,
          onDragOver: null,
          onDragStart: null,
          onDrop: null,
          onDurationChange: null,
          onEmptied: null,
          onEnd: null,
          onEnded: null,
          onError: null,
          onFocus: null,
          onFocusIn: null,
          onFocusOut: null,
          onHashChange: null,
          onInput: null,
          onInvalid: null,
          onKeyDown: null,
          onKeyPress: null,
          onKeyUp: null,
          onLoad: null,
          onLoadedData: null,
          onLoadedMetadata: null,
          onLoadStart: null,
          onMessage: null,
          onMouseDown: null,
          onMouseEnter: null,
          onMouseLeave: null,
          onMouseMove: null,
          onMouseOut: null,
          onMouseOver: null,
          onMouseUp: null,
          onMouseWheel: null,
          onOffline: null,
          onOnline: null,
          onPageHide: null,
          onPageShow: null,
          onPaste: null,
          onPause: null,
          onPlay: null,
          onPlaying: null,
          onPopState: null,
          onProgress: null,
          onRateChange: null,
          onRepeat: null,
          onReset: null,
          onResize: null,
          onScroll: null,
          onSeeked: null,
          onSeeking: null,
          onSelect: null,
          onShow: null,
          onStalled: null,
          onStorage: null,
          onSubmit: null,
          onSuspend: null,
          onTimeUpdate: null,
          onToggle: null,
          onUnload: null,
          onVolumeChange: null,
          onWaiting: null,
          onZoom: null,
          opacity: null,
          operator: null,
          order: null,
          orient: null,
          orientation: null,
          origin: null,
          overflow: null,
          overlay: null,
          overlinePosition: number,
          overlineThickness: number,
          paintOrder: null,
          panose1: null,
          path: null,
          pathLength: number,
          patternContentUnits: null,
          patternTransform: null,
          patternUnits: null,
          phase: null,
          ping: spaceSeparated,
          pitch: null,
          playbackOrder: null,
          pointerEvents: null,
          points: null,
          pointsAtX: number,
          pointsAtY: number,
          pointsAtZ: number,
          preserveAlpha: null,
          preserveAspectRatio: null,
          primitiveUnits: null,
          propagate: null,
          property: commaOrSpaceSeparated,
          r: null,
          radius: null,
          referrerPolicy: null,
          refX: null,
          refY: null,
          rel: commaOrSpaceSeparated,
          rev: commaOrSpaceSeparated,
          renderingIntent: null,
          repeatCount: null,
          repeatDur: null,
          requiredExtensions: commaOrSpaceSeparated,
          requiredFeatures: commaOrSpaceSeparated,
          requiredFonts: commaOrSpaceSeparated,
          requiredFormats: commaOrSpaceSeparated,
          resource: null,
          restart: null,
          result: null,
          rotate: null,
          rx: null,
          ry: null,
          scale: null,
          seed: null,
          shapeRendering: null,
          side: null,
          slope: null,
          snapshotTime: null,
          specularConstant: number,
          specularExponent: number,
          spreadMethod: null,
          spacing: null,
          startOffset: null,
          stdDeviation: null,
          stemh: null,
          stemv: null,
          stitchTiles: null,
          stopColor: null,
          stopOpacity: null,
          strikethroughPosition: number,
          strikethroughThickness: number,
          string: null,
          stroke: null,
          strokeDashArray: commaOrSpaceSeparated,
          strokeDashOffset: null,
          strokeLineCap: null,
          strokeLineJoin: null,
          strokeMiterLimit: number,
          strokeOpacity: number,
          strokeWidth: null,
          style: null,
          surfaceScale: number,
          syncBehavior: null,
          syncBehaviorDefault: null,
          syncMaster: null,
          syncTolerance: null,
          syncToleranceDefault: null,
          systemLanguage: commaOrSpaceSeparated,
          tabIndex: number,
          tableValues: null,
          target: null,
          targetX: number,
          targetY: number,
          textAnchor: null,
          textDecoration: null,
          textRendering: null,
          textLength: null,
          timelineBegin: null,
          title: null,
          transformBehavior: null,
          type: null,
          typeOf: commaOrSpaceSeparated,
          to: null,
          transform: null,
          u1: null,
          u2: null,
          underlinePosition: number,
          underlineThickness: number,
          unicode: null,
          unicodeBidi: null,
          unicodeRange: null,
          unitsPerEm: number,
          values: null,
          vAlphabetic: number,
          vMathematical: number,
          vectorEffect: null,
          vHanging: number,
          vIdeographic: number,
          version: null,
          vertAdvY: number,
          vertOriginX: number,
          vertOriginY: number,
          viewBox: null,
          viewTarget: null,
          visibility: null,
          width: null,
          widths: null,
          wordSpacing: null,
          writingMode: null,
          x: null,
          x1: null,
          x2: null,
          xChannelSelector: null,
          xHeight: number,
          y: null,
          y1: null,
          y2: null,
          yChannelSelector: null,
          z: null,
          zoomAndPan: null
        }
      })


/***/ }),

/***/ "../../node_modules/property-information/lib/util/case-insensitive-transform.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/case-insensitive-transform.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const caseSensitiveTransform = __webpack_require__(/*! ./case-sensitive-transform */ "../../node_modules/property-information/lib/util/case-sensitive-transform.js")

      module.exports = caseInsensitiveTransform

      function caseInsensitiveTransform(attributes, property) {
        return caseSensitiveTransform(attributes, property.toLowerCase())
      }


/***/ }),

/***/ "../../node_modules/property-information/lib/util/case-sensitive-transform.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/case-sensitive-transform.js ***!
  \************************************************************************************/
/***/ ((module) => {

      "use strict";


      module.exports = caseSensitiveTransform

      function caseSensitiveTransform(attributes, attribute) {
        return attribute in attributes ? attributes[attribute] : attribute
      }


/***/ }),

/***/ "../../node_modules/property-information/lib/util/create.js":
/*!******************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/create.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const normalize = __webpack_require__(/*! ../../normalize */ "../../node_modules/property-information/normalize.js")
      const Schema = __webpack_require__(/*! ./schema */ "../../node_modules/property-information/lib/util/schema.js")
      const DefinedInfo = __webpack_require__(/*! ./defined-info */ "../../node_modules/property-information/lib/util/defined-info.js")

      module.exports = create

      function create(definition) {
        const space = definition.space
        const mustUseProperty = definition.mustUseProperty || []
        const attributes = definition.attributes || {}
        const props = definition.properties
        const transform = definition.transform
        const property = {}
        const normal = {}
        let prop
        let info

        for (prop in props) {
          info = new DefinedInfo(
            prop,
            transform(attributes, prop),
            props[prop],
            space
          )

          if (mustUseProperty.indexOf(prop) !== -1) {
            info.mustUseProperty = true
          }

          property[prop] = info

          normal[normalize(prop)] = prop
          normal[normalize(info.attribute)] = prop
        }

        return new Schema(property, normal, space)
      }


/***/ }),

/***/ "../../node_modules/property-information/lib/util/defined-info.js":
/*!************************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/defined-info.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const Info = __webpack_require__(/*! ./info */ "../../node_modules/property-information/lib/util/info.js")
      const types = __webpack_require__(/*! ./types */ "../../node_modules/property-information/lib/util/types.js")

      module.exports = DefinedInfo

      DefinedInfo.prototype = new Info()
      DefinedInfo.prototype.defined = true

      const checks = [
        'boolean',
        'booleanish',
        'overloadedBoolean',
        'number',
        'commaSeparated',
        'spaceSeparated',
        'commaOrSpaceSeparated'
      ]
      const checksLength = checks.length

      function DefinedInfo(property, attribute, mask, space) {
        let index = -1
        let check

        mark(this, 'space', space)

        Info.call(this, property, attribute)

        while (++index < checksLength) {
          check = checks[index]
          mark(this, check, (mask & types[check]) === types[check])
        }
      }

      function mark(values, key, value) {
        if (value) {
          values[key] = value
        }
      }


/***/ }),

/***/ "../../node_modules/property-information/lib/util/info.js":
/*!****************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/info.js ***!
  \****************************************************************/
/***/ ((module) => {

      "use strict";


      module.exports = Info

      const proto = Info.prototype

      proto.space = null
      proto.attribute = null
      proto.property = null
      proto.boolean = false
      proto.booleanish = false
      proto.overloadedBoolean = false
      proto.number = false
      proto.commaSeparated = false
      proto.spaceSeparated = false
      proto.commaOrSpaceSeparated = false
      proto.mustUseProperty = false
      proto.defined = false

      function Info(property, attribute) {
        this.property = property
        this.attribute = attribute
      }


/***/ }),

/***/ "../../node_modules/property-information/lib/util/merge.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/merge.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const xtend = __webpack_require__(/*! xtend */ "../../node_modules/xtend/immutable.js")
      const Schema = __webpack_require__(/*! ./schema */ "../../node_modules/property-information/lib/util/schema.js")

      module.exports = merge

      function merge(definitions) {
        const length = definitions.length
        const property = []
        const normal = []
        let index = -1
        let info
        let space

        while (++index < length) {
          info = definitions[index]
          property.push(info.property)
          normal.push(info.normal)
          space = info.space
        }

        return new Schema(
          xtend.apply(null, property),
          xtend.apply(null, normal),
          space
        )
      }


/***/ }),

/***/ "../../node_modules/property-information/lib/util/schema.js":
/*!******************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/schema.js ***!
  \******************************************************************/
/***/ ((module) => {

      "use strict";


      module.exports = Schema

      const proto = Schema.prototype

      proto.space = null
      proto.normal = {}
      proto.property = {}

      function Schema(property, normal, space) {
        this.property = property
        this.normal = normal

        if (space) {
          this.space = space
        }
      }


/***/ }),

/***/ "../../node_modules/property-information/lib/util/types.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/types.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";


      let powers = 0

      exports.boolean = increment()
      exports.booleanish = increment()
      exports.overloadedBoolean = increment()
      exports.number = increment()
      exports.spaceSeparated = increment()
      exports.commaSeparated = increment()
      exports.commaOrSpaceSeparated = increment()

      function increment() {
        return Math.pow(2, ++powers)
      }


/***/ }),

/***/ "../../node_modules/property-information/lib/xlink.js":
/*!************************************************************!*\
  !*** ../../node_modules/property-information/lib/xlink.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const create = __webpack_require__(/*! ./util/create */ "../../node_modules/property-information/lib/util/create.js")

      module.exports = create({
        space: 'xlink',
        transform: xlinkTransform,
        properties: {
          xLinkActuate: null,
          xLinkArcRole: null,
          xLinkHref: null,
          xLinkRole: null,
          xLinkShow: null,
          xLinkTitle: null,
          xLinkType: null
        }
      })

      function xlinkTransform(_, prop) {
        return 'xlink:' + prop.slice(5).toLowerCase()
      }


/***/ }),

/***/ "../../node_modules/property-information/lib/xml.js":
/*!**********************************************************!*\
  !*** ../../node_modules/property-information/lib/xml.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const create = __webpack_require__(/*! ./util/create */ "../../node_modules/property-information/lib/util/create.js")

      module.exports = create({
        space: 'xml',
        transform: xmlTransform,
        properties: {
          xmlLang: null,
          xmlBase: null,
          xmlSpace: null
        }
      })

      function xmlTransform(_, prop) {
        return 'xml:' + prop.slice(3).toLowerCase()
      }


/***/ }),

/***/ "../../node_modules/property-information/lib/xmlns.js":
/*!************************************************************!*\
  !*** ../../node_modules/property-information/lib/xmlns.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const create = __webpack_require__(/*! ./util/create */ "../../node_modules/property-information/lib/util/create.js")
      const caseInsensitiveTransform = __webpack_require__(/*! ./util/case-insensitive-transform */ "../../node_modules/property-information/lib/util/case-insensitive-transform.js")

      module.exports = create({
        space: 'xmlns',
        attributes: {
          xmlnsxlink: 'xmlns:xlink'
        },
        transform: caseInsensitiveTransform,
        properties: {
          xmlns: null,
          xmlnsXLink: null
        }
      })


/***/ }),

/***/ "../../node_modules/property-information/normalize.js":
/*!************************************************************!*\
  !*** ../../node_modules/property-information/normalize.js ***!
  \************************************************************/
/***/ ((module) => {

      "use strict";


      module.exports = normalize

      function normalize(value) {
        return value.toLowerCase()
      }


/***/ }),

/***/ "../../node_modules/property-information/svg.js":
/*!******************************************************!*\
  !*** ../../node_modules/property-information/svg.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const merge = __webpack_require__(/*! ./lib/util/merge */ "../../node_modules/property-information/lib/util/merge.js")
      const xlink = __webpack_require__(/*! ./lib/xlink */ "../../node_modules/property-information/lib/xlink.js")
      const xml = __webpack_require__(/*! ./lib/xml */ "../../node_modules/property-information/lib/xml.js")
      const xmlns = __webpack_require__(/*! ./lib/xmlns */ "../../node_modules/property-information/lib/xmlns.js")
      const aria = __webpack_require__(/*! ./lib/aria */ "../../node_modules/property-information/lib/aria.js")
      const svg = __webpack_require__(/*! ./lib/svg */ "../../node_modules/property-information/lib/svg.js")

      module.exports = merge([xml, xlink, xmlns, aria, svg])


/***/ }),

/***/ "../../node_modules/react-is/cjs/react-is.development.js":
/*!***************************************************************!*\
  !*** ../../node_modules/react-is/cjs/react-is.development.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





      if (true) {
        (function() {
          'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
          const hasSymbol = typeof Symbol === 'function' && Symbol.for;
          const REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
          const REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
          const REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
          const REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
          const REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
          const REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
          const REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

          const REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
          const REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
          const REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
          const REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
          const REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
          const REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
          const REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
          const REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
          const REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
          const REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
          const REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

          function isValidElementType(type) {
            return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }

          function typeOf(object) {
            if (typeof object === 'object' && object !== null) {
              const $$typeof = object.$$typeof;

              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;

                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;

                    default:
                      var $$typeofType = type && type.$$typeof;

                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;

                        default:
                          return $$typeof;
                      }

                  }

                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }

            return undefined;
          } // AsyncMode is deprecated along with isAsyncMode

          const AsyncMode = REACT_ASYNC_MODE_TYPE;
          const ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          const ContextConsumer = REACT_CONTEXT_TYPE;
          const ContextProvider = REACT_PROVIDER_TYPE;
          const Element = REACT_ELEMENT_TYPE;
          const ForwardRef = REACT_FORWARD_REF_TYPE;
          const Fragment = REACT_FRAGMENT_TYPE;
          const Lazy = REACT_LAZY_TYPE;
          const Memo = REACT_MEMO_TYPE;
          const Portal = REACT_PORTAL_TYPE;
          const Profiler = REACT_PROFILER_TYPE;
          const StrictMode = REACT_STRICT_MODE_TYPE;
          const Suspense = REACT_SUSPENSE_TYPE;
          let hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

                console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
              }
            }

            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }

          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }


/***/ }),

/***/ "../../node_modules/react-is/index.js":
/*!********************************************!*\
  !*** ../../node_modules/react-is/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      if (false) // removed by dead control flow
      {} else {
        module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "../../node_modules/react-is/cjs/react-is.development.js");
      }


/***/ }),

/***/ "../../node_modules/react-markdown/node_modules/react-is/cjs/react-is.development.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/react-markdown/node_modules/react-is/cjs/react-is.development.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";
/** @license React v17.0.2
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



      if (true) {
        (function() {
          'use strict';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
          let REACT_ELEMENT_TYPE = 0xeac7;
          let REACT_PORTAL_TYPE = 0xeaca;
          let REACT_FRAGMENT_TYPE = 0xeacb;
          let REACT_STRICT_MODE_TYPE = 0xeacc;
          let REACT_PROFILER_TYPE = 0xead2;
          let REACT_PROVIDER_TYPE = 0xeacd;
          let REACT_CONTEXT_TYPE = 0xeace;
          let REACT_FORWARD_REF_TYPE = 0xead0;
          let REACT_SUSPENSE_TYPE = 0xead1;
          let REACT_SUSPENSE_LIST_TYPE = 0xead8;
          let REACT_MEMO_TYPE = 0xead3;
          let REACT_LAZY_TYPE = 0xead4;
          let REACT_BLOCK_TYPE = 0xead9;
          let REACT_SERVER_BLOCK_TYPE = 0xeada;
          let REACT_FUNDAMENTAL_TYPE = 0xead5;
          let REACT_SCOPE_TYPE = 0xead7;
          let REACT_OPAQUE_ID_TYPE = 0xeae0;
          let REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
          let REACT_OFFSCREEN_TYPE = 0xeae2;
          let REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

          if (typeof Symbol === 'function' && Symbol.for) {
            const symbolFor = Symbol.for;
            REACT_ELEMENT_TYPE = symbolFor('react.element');
            REACT_PORTAL_TYPE = symbolFor('react.portal');
            REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
            REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
            REACT_PROFILER_TYPE = symbolFor('react.profiler');
            REACT_PROVIDER_TYPE = symbolFor('react.provider');
            REACT_CONTEXT_TYPE = symbolFor('react.context');
            REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
            REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
            REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
            REACT_MEMO_TYPE = symbolFor('react.memo');
            REACT_LAZY_TYPE = symbolFor('react.lazy');
            REACT_BLOCK_TYPE = symbolFor('react.block');
            REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
            REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
            REACT_SCOPE_TYPE = symbolFor('react.scope');
            REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
            REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
            REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
            REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
          }

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

          const enableScopeAPI = false; // Experimental Create Event Handle API.

          function isValidElementType(type) {
            if (typeof type === 'string' || typeof type === 'function') {
              return true;
            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
              return true;
            }

            if (typeof type === 'object' && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
                return true;
              }
            }

            return false;
          }

          function typeOf(object) {
            if (typeof object === 'object' && object !== null) {
              const $$typeof = object.$$typeof;

              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;

                  switch (type) {
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                    case REACT_SUSPENSE_LIST_TYPE:
                      return type;

                    default:
                      var $$typeofType = type && type.$$typeof;

                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;

                        default:
                          return $$typeof;
                      }

                  }

                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }

            return undefined;
          }
          const ContextConsumer = REACT_CONTEXT_TYPE;
          const ContextProvider = REACT_PROVIDER_TYPE;
          const Element = REACT_ELEMENT_TYPE;
          const ForwardRef = REACT_FORWARD_REF_TYPE;
          const Fragment = REACT_FRAGMENT_TYPE;
          const Lazy = REACT_LAZY_TYPE;
          const Memo = REACT_MEMO_TYPE;
          const Portal = REACT_PORTAL_TYPE;
          const Profiler = REACT_PROFILER_TYPE;
          const StrictMode = REACT_STRICT_MODE_TYPE;
          const Suspense = REACT_SUSPENSE_TYPE;
          let hasWarnedAboutDeprecatedIsAsyncMode = false;
          let hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

                console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
              }
            }

            return false;
          }
          function isConcurrentMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
                hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

                console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
              }
            }

            return false;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }

          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }


/***/ }),

/***/ "../../node_modules/react-markdown/node_modules/react-is/index.js":
/*!************************************************************************!*\
  !*** ../../node_modules/react-markdown/node_modules/react-is/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      if (false) // removed by dead control flow
      {} else {
        module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "../../node_modules/react-markdown/node_modules/react-is/cjs/react-is.development.js");
      }


/***/ }),

/***/ "../../node_modules/react-markdown/src/ast-to-react.js":
/*!*************************************************************!*\
  !*** ../../node_modules/react-markdown/src/ast-to-react.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";


      const React = __webpack_require__(/*! react */ "react")
      const ReactIs = __webpack_require__(/*! react-is */ "../../node_modules/react-markdown/node_modules/react-is/index.js")
      const svg = __webpack_require__(/*! property-information/svg */ "../../node_modules/property-information/svg.js")
      const find = __webpack_require__(/*! property-information/find */ "../../node_modules/property-information/find.js")
      const hastToReact = __webpack_require__(/*! property-information/hast-to-react.json */ "../../node_modules/property-information/hast-to-react.json")
      const spaces = __webpack_require__(/*! space-separated-tokens */ "../../node_modules/space-separated-tokens/index.js")
      const commas = __webpack_require__(/*! comma-separated-tokens */ "../../node_modules/comma-separated-tokens/index.js")
      const style = __webpack_require__(/*! style-to-object */ "../../node_modules/style-to-object/index.js")

      exports.hastToReact = toReact
      exports.hastChildrenToReact = childrenToReact

/**
 * @typedef {JSX.IntrinsicElements} IntrinsicElements
 * @typedef {import('react').ReactNode} ReactNode
 * @typedef {import('unist').Position} Position
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Text} Text
 * @typedef {import('hast').Comment} Comment
 * @typedef {import('hast').DocType} Doctype
 */

/**
 * @typedef Info
 * @property {string?} space
 * @property {string?} attribute
 * @property {string?} property
 * @property {boolean} boolean
 * @property {boolean} booleanish
 * @property {boolean} overloadedBoolean
 * @property {boolean} number
 * @property {boolean} commaSeparated
 * @property {boolean} spaceSeparated
 * @property {boolean} commaOrSpaceSeparated
 * @property {boolean} mustUseProperty
 * @property {boolean} defined
 *
 * @typedef Schema
 * @property {Object.<string, Info>} property
 * @property {Object.<string, string>} normal
 * @property {string?} space
 *
 * @typedef Raw
 * @property {'raw'} type
 * @property {string} value
 *
 * @typedef Context
 * @property {TransformOptions} options
 * @property {Schema} schema
 * @property {number} listDepth
 *
 * @callback TransformLink
 * @param {string} href
 * @param {Array.<Comment|Element|Text>} children
 * @param {string?} title
 * @returns {string}
 *
 * @callback TransformImage
 * @param {string} src
 * @param {string} alt
 * @param {string?} title
 * @returns {string}
 *
 * @callback TransformLinkTarget
 * @param {string} href
 * @param {Array.<Comment|Element|Text>} children
 * @param {string?} title
 * @returns {string|undefined}
 *
 * @typedef {keyof IntrinsicElements} ReactMarkdownNames
 *
 * To do: is `data-sourcepos` typeable?
 *
 * @typedef ReactMarkdownProps
 * @property {Element} node
 * @property {string} key
 * @property {ReactNode[]} children
 * @property {Position?} [sourcePosition] Passed when `options.rawSourcePos` is given
 * @property {number} [index] Passed when `options.includeElementIndex` is given
 * @property {number} [siblingCount] Passed when `options.includeElementIndex` is given
 *
 * @callback CodeComponent
 * @param {JSX.IntrinsicElements['code'] & ReactMarkdownProps & {inline?: boolean}} props
 * @returns {ReactNode}
 *
 * @callback HeadingComponent
 * @param {JSX.IntrinsicElements['h1'] & ReactMarkdownProps & {level: number}} props
 * @returns {ReactNode}
 *
 * @callback LiComponent
 * @param {JSX.IntrinsicElements['li'] & ReactMarkdownProps & {checked: boolean|null, index: number, ordered: boolean}} props
 * @returns {ReactNode}
 *
 * @callback OrderedListComponent
 * @param {JSX.IntrinsicElements['ol'] & ReactMarkdownProps & {depth: number, ordered: true}} props
 * @returns {ReactNode}
 *
 * @callback TableCellComponent
 * @param {JSX.IntrinsicElements['table'] & ReactMarkdownProps & {style?: Object.<string, unknown>, isHeader: boolean}} props
 * @returns {ReactNode}
 *
 * @callback TableRowComponent
 * @param {JSX.IntrinsicElements['tr'] & ReactMarkdownProps & {isHeader: boolean}} props
 * @returns {ReactNode}
 *
 * @callback UnorderedListComponent
 * @param {JSX.IntrinsicElements['ul'] & ReactMarkdownProps & {depth: number, ordered: false}} props
 * @returns {ReactNode}
 *
 * @typedef SpecialComponents
 * @property {CodeComponent|ReactMarkdownNames} code
 * @property {HeadingComponent|ReactMarkdownNames} h1
 * @property {HeadingComponent|ReactMarkdownNames} h2
 * @property {HeadingComponent|ReactMarkdownNames} h3
 * @property {HeadingComponent|ReactMarkdownNames} h4
 * @property {HeadingComponent|ReactMarkdownNames} h5
 * @property {HeadingComponent|ReactMarkdownNames} h6
 * @property {LiComponent|ReactMarkdownNames} li
 * @property {OrderedListComponent|ReactMarkdownNames} ol
 * @property {TableCellComponent|ReactMarkdownNames} td
 * @property {TableCellComponent|ReactMarkdownNames} th
 * @property {TableRowComponent|ReactMarkdownNames} tr
 * @property {UnorderedListComponent|ReactMarkdownNames} ul
 *
 * @typedef {{[TagName in keyof IntrinsicElements]: TagName | ((props: IntrinsicElements[TagName] & ReactMarkdownProps) => ReactNode)}} NormalComponents
 * @typedef {Partial<Omit<NormalComponents, keyof SpecialComponents> & SpecialComponents>} Components
 */

/**
 * @typedef TransformOptions
 * @property {boolean} [sourcePos=false]
 * @property {boolean} [rawSourcePos=false]
 * @property {boolean} [skipHtml=false]
 * @property {boolean} [includeElementIndex=false]
 * @property {null|false|TransformLink} [transformLinkUri]
 * @property {TransformImage} [transformImageUri]
 * @property {string|TransformLinkTarget} [linkTarget]
 * @property {Components} [components]
 */

      const own = {}.hasOwnProperty

// The table-related elements that must not contain whitespace text according
// to React.
      const tableElements = new Set(['table', 'thead', 'tbody', 'tfoot', 'tr'])

/**
 * @param {Context} context
 * @param {Element|Root} node
 */
      function childrenToReact(context, node) {
  /** @type {Array.<ReactNode>} */
        const children = []
        let childIndex = -1
  /** @type {Comment|Doctype|Element|Raw|Text} */
        let child

        while (++childIndex < node.children.length) {
          child = node.children[childIndex]

          if (child.type === 'element') {
            children.push(toReact(context, child, childIndex, node))
          } else if (child.type === 'text') {
      // React does not permit whitespace text elements as children of table:
      // cf. https://github.com/remarkjs/react-markdown/issues/576
            if (
              node.type !== 'element' ||
        !tableElements.has(node.tagName) ||
        child.value !== '\n'
            ) {
              children.push(child.value)
            }
          }
    // @ts-expect-error `raw` nodes are non-standard
          else if (child.type === 'raw' && !context.options.skipHtml) {
      // Default behavior is to show (encoded) HTML.
      // @ts-expect-error `raw` nodes are non-standard
            children.push(child.value)
          }
        }

        return children
      }

/**
 * @param {Context} context
 * @param {Element} node
 * @param {number} index
 * @param {Element|Root} parent
 */
      function toReact(context, node, index, parent) {
        const options = context.options
        const parentSchema = context.schema
  /** @type {ReactMarkdownNames} */
  // @ts-expect-error assume a known HTML/SVG element.
        const name = node.tagName
  /** @type {Object.<string, unknown>} */
        const properties = {}
        let schema = parentSchema
  /** @type {string} */
        let property

        if (parentSchema.space === 'html' && name === 'svg') {
          schema = svg
          context.schema = schema
        }

  /* istanbul ignore else - types say they’re optional. */
        if (node.properties) {
          for (property in node.properties) {
      /* istanbul ignore else - prototype polution. */
            if (own.call(node.properties, property)) {
              addProperty(properties, property, node.properties[property], context)
            }
          }
        }

        if (name === 'ol' || name === 'ul') {
          context.listDepth++
        }

        const children = childrenToReact(context, node)

        if (name === 'ol' || name === 'ul') {
          context.listDepth--
        }

  // Restore parent schema.
        context.schema = parentSchema

  // Nodes created by plugins do not have positional info, in which case we use
  // an object that matches the positon interface.
        const position = node.position || {
          start: {line: null, column: null, offset: null},
          end: {line: null, column: null, offset: null}
        }
        const component =
    options.components && own.call(options.components, name)
      ? options.components[name]
      : name
        const basic = typeof component === 'string' || component === React.Fragment

        if (!ReactIs.isValidElementType(component)) {
          throw new TypeError(
            `Component for name \`${name}\` not defined or is not renderable`
          )
        }

        properties.key = [
          name,
          position.start.line,
          position.start.column,
          index
        ].join('-')

        if (name === 'a' && options.linkTarget) {
          properties.target =
      typeof options.linkTarget === 'function'
        ? // @ts-expect-error assume `href` is a string
        options.linkTarget(properties.href, node.children, properties.title)
        : options.linkTarget
        }

        if (name === 'a' && options.transformLinkUri) {
          properties.href = options.transformLinkUri(
      // @ts-expect-error assume `href` is a string
            properties.href,
            node.children,
            properties.title
          )
        }

        if (
          !basic &&
    name === 'code' &&
    parent.type === 'element' &&
    parent.tagName !== 'pre'
        ) {
          properties.inline = true
        }

        if (
          !basic &&
    (name === 'h1' ||
      name === 'h2' ||
      name === 'h3' ||
      name === 'h4' ||
      name === 'h5' ||
      name === 'h6')
        ) {
          properties.level = parseInt(name.charAt(1), 10)
        }

        if (name === 'img' && options.transformImageUri) {
          properties.src = options.transformImageUri(
      // @ts-expect-error assume `src` is a string
            properties.src,
            properties.alt,
            properties.title
          )
        }

        if (!basic && name === 'li' && parent.type === 'element') {
          const input = getInputElement(node)
          properties.checked =
      input && input.properties ? Boolean(input.properties.checked) : null
          properties.index = getElementsBeforeCount(parent, node)
          properties.ordered = parent.tagName === 'ol'
        }

        if (!basic && (name === 'ol' || name === 'ul')) {
          properties.ordered = name === 'ol'
          properties.depth = context.listDepth
        }

        if (name === 'td' || name === 'th') {
          if (properties.align) {
            if (!properties.style) properties.style = {}
      // @ts-expect-error assume `style` is an object
            properties.style.textAlign = properties.align
            delete properties.align
          }

          if (!basic) {
            properties.isHeader = name === 'th'
          }
        }

        if (!basic && name === 'tr' && parent.type === 'element') {
          properties.isHeader = Boolean(parent.tagName === 'thead')
        }

  // If `sourcePos` is given, pass source information (line/column info from markdown source).
        if (options.sourcePos) {
          properties['data-sourcepos'] = flattenPosition(position)
        }

        if (!basic && options.rawSourcePos) {
          properties.sourcePosition = node.position
        }

  // If `includeElementIndex` is given, pass node index info to components.
        if (!basic && options.includeElementIndex) {
          properties.index = getElementsBeforeCount(parent, node)
          properties.siblingCount = getElementsBeforeCount(parent)
        }

        if (!basic) {
          properties.node = node
        }

  // Ensure no React warnings are emitted for void elements w/ children.
        return children.length > 0
          ? React.createElement(component, properties, children)
          : React.createElement(component, properties)
      }

/**
 * @param {Element|Root} node
 * @returns {Element?}
 */
      function getInputElement(node) {
        let index = -1

        while (++index < node.children.length) {
          const child = node.children[index]

          if (child.type === 'element' && child.tagName === 'input') {
            return child
          }
        }

        return null
      }

/**
 * @param {Element|Root} parent
 * @param {Element} [node]
 * @returns {number}
 */
      function getElementsBeforeCount(parent, node) {
        let index = -1
        let count = 0

        while (++index < parent.children.length) {
          if (parent.children[index] === node) break
          if (parent.children[index].type === 'element') count++
        }

        return count
      }

/**
 * @param {Object.<string, unknown>} props
 * @param {string} prop
 * @param {unknown} value
 * @param {Context} ctx
 */
      function addProperty(props, prop, value, ctx) {
  /** @type {Info} */
        const info = find(ctx.schema, prop)
        let result = value

  // Ignore nullish and `NaN` values.
  // eslint-disable-next-line no-self-compare
        if (result === null || result === undefined || result !== result) {
          return
        }

  // Accept `array`.
  // Most props are space-separated.
        if (result && typeof result === 'object' && 'length' in result) {
    // type-coverage:ignore-next-line remove when typed.
          result = (info.commaSeparated ? commas : spaces).stringify(result)
        }

        if (info.property === 'style' && typeof result === 'string') {
          result = parseStyle(result)
        }

  /* istanbul ignore else - types say they’re optional. */
        if (info.space && info.property) {
          props[
            own.call(hastToReact, info.property)
              ? hastToReact[info.property]
              : info.property
          ] = result
        } else if (info.attribute) {
          props[info.attribute] = result
        }
      }

/**
 * @param {string} value
 * @returns {Object.<string, string>}
 */
      function parseStyle(value) {
  /** @type {Object.<string, string>} */
        const result = {}

        try {
          style(value, iterator)
        } catch (/** @type {unknown} */ _) {
    // Silent.
        }

        return result

  /**
   * @param {string} name
   * @param {string} v
   */
        function iterator(name, v) {
          const k = name.slice(0, 4) === '-ms-' ? `ms-${name.slice(4)}` : name
          result[k.replace(/-([a-z])/g, styleReplacer)] = v
        }
      }

/**
 * @param {unknown} _
 * @param {string} $1
 */
      function styleReplacer(_, $1) {
        return $1.toUpperCase()
      }

/**
 * @param {Position|{start: {line: null, column: null, offset: null}, end: {line: null, column: null, offset: null}}} pos
 * @returns {string}
 */
      function flattenPosition(pos) {
        return [
          pos.start.line,
          ':',
          pos.start.column,
          '-',
          pos.end.line,
          ':',
          pos.end.column
        ]
          .map((d) => String(d))
          .join('')
      }


/***/ }),

/***/ "../../node_modules/react-markdown/src/react-markdown.js":
/*!***************************************************************!*\
  !*** ../../node_modules/react-markdown/src/react-markdown.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const React = __webpack_require__(/*! react */ "react")
      const vfile = __webpack_require__(/*! vfile */ "../../node_modules/vfile/index.js")
      const unified = __webpack_require__(/*! unified */ "../../node_modules/unified/index.js")
      const parse = __webpack_require__(/*! remark-parse */ "../../node_modules/remark-parse/index.js")
      const remarkRehype = __webpack_require__(/*! remark-rehype */ "../../node_modules/remark-rehype/index.js")
      const PropTypes = __webpack_require__(/*! prop-types */ "../../node_modules/prop-types/index.js")
      const html = __webpack_require__(/*! property-information/html */ "../../node_modules/property-information/html.js")
      const filter = __webpack_require__(/*! ./rehype-filter.js */ "../../node_modules/react-markdown/src/rehype-filter.js")
      const uriTransformer = __webpack_require__(/*! ./uri-transformer.js */ "../../node_modules/react-markdown/src/uri-transformer.js")
      const childrenToReact = (__webpack_require__(/*! ./ast-to-react.js */ "../../node_modules/react-markdown/src/ast-to-react.js").hastChildrenToReact)

/**
 * @typedef {import('react').ReactNode} ReactNode
 * @typedef {import('react').ReactElement<{}>} ReactElement
 * @typedef {import('unified').PluggableList} PluggableList
 * @typedef {import('hast').Root} Root
 * @typedef {import('./rehype-filter.js').RehypeFilterOptions} FilterOptions
 * @typedef {import('./ast-to-react.js').TransformOptions} TransformOptions
 *
 * @typedef CoreOptions
 * @property {string} children
 *
 * @typedef PluginOptions
 * @property {PluggableList} [plugins=[]] **deprecated**: use `remarkPlugins` instead
 * @property {PluggableList} [remarkPlugins=[]]
 * @property {PluggableList} [rehypePlugins=[]]
 *
 * @typedef LayoutOptions
 * @property {string} [className]
 *
 * @typedef {CoreOptions & PluginOptions & LayoutOptions & FilterOptions & TransformOptions} ReactMarkdownOptions
 */

      module.exports = ReactMarkdown

      const own = {}.hasOwnProperty
      const changelog =
  'https://github.com/remarkjs/react-markdown/blob/main/changelog.md'

/**
 * @typedef Deprecation
 * @property {string} id
 * @property {string} [to]
 */

/**
 * @type {Object.<string, Deprecation>}
 */
      const deprecated = {
        renderers: {to: 'components', id: 'change-renderers-to-components'},
        astPlugins: {id: 'remove-buggy-html-in-markdown-parser'},
        allowDangerousHtml: {id: 'remove-buggy-html-in-markdown-parser'},
        escapeHtml: {id: 'remove-buggy-html-in-markdown-parser'},
        source: {to: 'children', id: 'change-source-to-children'},
        allowNode: {
          to: 'allowElement',
          id: 'replace-allownode-allowedtypes-and-disallowedtypes'
        },
        allowedTypes: {
          to: 'allowedElements',
          id: 'replace-allownode-allowedtypes-and-disallowedtypes'
        },
        disallowedTypes: {
          to: 'disallowedElements',
          id: 'replace-allownode-allowedtypes-and-disallowedtypes'
        },
        includeNodeIndex: {
          to: 'includeElementIndex',
          id: 'change-includenodeindex-to-includeelementindex'
        }
      }

/**
 * @param {ReactMarkdownOptions} options
 * @returns {ReactElement}
 */
      function ReactMarkdown(options) {
        for (const key in deprecated) {
          if (own.call(deprecated, key) && own.call(options, key)) {
      /** @type {Deprecation} */
            const deprecation = deprecated[key]
            console.warn(
              `[react-markdown] Warning: please ${
                deprecation.to ? `use \`${deprecation.to}\` instead of` : 'remove'
              } \`${key}\` (see <${changelog}#${deprecation.id}> for more info)`
            )
            delete deprecated[key]
          }
        }

        const processor = unified()
          .use(parse)
    // TODO: deprecate `plugins` in v7.0.0.
          .use(options.remarkPlugins || options.plugins || [])
          .use(remarkRehype, {allowDangerousHtml: true})
          .use(options.rehypePlugins || [])
          .use(filter, options)

  /** @type {vfile} */
        let file

        if (typeof options.children === 'string') {
          file = vfile(options.children)
        } else {
          if (options.children !== undefined && options.children !== null) {
            console.warn(
              `[react-markdown] Warning: please pass a string as \`children\` (not: \`${options.children}\`)`
            )
          }

          file = vfile()
        }

  /** @type {Root} */
  // @ts-expect-error we’ll throw if it isn’t a root next.
        const hastNode = processor.runSync(processor.parse(file), file)

        if (hastNode.type !== 'root') {
          throw new TypeError('Expected a `root` node')
        }

  /** @type {ReactElement} */
        let result = React.createElement(
          React.Fragment,
          {},
          childrenToReact({options: options, schema: html, listDepth: 0}, hastNode)
        )

        if (options.className) {
          result = React.createElement('div', {className: options.className}, result)
        }

        return result
      }

      ReactMarkdown.defaultProps = {transformLinkUri: uriTransformer}

      ReactMarkdown.propTypes = {
  // Core options:
        children: PropTypes.string,
  // Layout options:
        className: PropTypes.string,
  // Filter options:
        allowElement: PropTypes.func,
        allowedElements: PropTypes.arrayOf(PropTypes.string),
        disallowedElements: PropTypes.arrayOf(PropTypes.string),
        unwrapDisallowed: PropTypes.bool,
  // Plugin options:
  // type-coverage:ignore-next-line
        remarkPlugins: PropTypes.arrayOf(
          PropTypes.oneOfType([
            PropTypes.object,
            PropTypes.func,
            PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.object, PropTypes.func]))
          ])
        ),
  // type-coverage:ignore-next-line
        rehypePlugins: PropTypes.arrayOf(
          PropTypes.oneOfType([
            PropTypes.object,
            PropTypes.func,
            PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.object, PropTypes.func]))
          ])
        ),
  // Transform options:
        sourcePos: PropTypes.bool,
        rawSourcePos: PropTypes.bool,
        skipHtml: PropTypes.bool,
        includeElementIndex: PropTypes.bool,
        transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
        linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
        transformImageUri: PropTypes.func,
        components: PropTypes.object
      }

      ReactMarkdown.uriTransformer = uriTransformer


/***/ }),

/***/ "../../node_modules/react-markdown/src/rehype-filter.js":
/*!**************************************************************!*\
  !*** ../../node_modules/react-markdown/src/rehype-filter.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      const visit = __webpack_require__(/*! unist-util-visit */ "../../node_modules/unist-util-visit/index.js")

      module.exports = rehypeFilter

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Element} Element
 *
 * @callback AllowElement
 * @param {Element} element
 * @param {number} index
 * @param {Element|Root} parent
 * @returns {boolean|undefined}
 *
 * @typedef RehypeFilterOptions
 * @property {Array.<string>} [allowedElements]
 * @property {Array.<string>} [disallowedElements=[]]
 * @property {AllowElement} [allowElement]
 * @property {boolean} [unwrapDisallowed=false]
 */

/**
 * @type {import('unified').Plugin<[RehypeFilterOptions]>}
 */
      function rehypeFilter(options) {
        if (options.allowedElements && options.disallowedElements) {
          throw new TypeError(
            'Only one of `allowedElements` and `disallowedElements` should be defined'
          )
        }

        if (
          options.allowedElements ||
    options.disallowedElements ||
    options.allowElement
        ) {
          return (tree) => {
            const node = /** @type {Root} */ (tree)
            visit(node, 'element', onelement)
          }
        }

  /**
   * @param {Node} node_
   * @param {number|null|undefined} index
   * @param {Node|null|undefined} parent_
   * @returns {number|void}
   */
        function onelement(node_, index, parent_) {
          const node = /** @type {Element} */ (node_)
          const parent = /** @type {Element|Root} */ (parent_)
    /** @type {boolean|undefined} */
          let remove

          if (options.allowedElements) {
            remove = !options.allowedElements.includes(node.tagName)
          } else if (options.disallowedElements) {
            remove = options.disallowedElements.includes(node.tagName)
          }

          if (!remove && options.allowElement && typeof index === 'number') {
            remove = !options.allowElement(node, index, parent)
          }

          if (remove && typeof index === 'number') {
            if (options.unwrapDisallowed && node.children) {
              parent.children.splice(index, 1, ...node.children)
            } else {
              parent.children.splice(index, 1)
            }

            return index
          }

          return undefined
        }
      }


/***/ }),

/***/ "../../node_modules/react-markdown/src/uri-transformer.js":
/*!****************************************************************!*\
  !*** ../../node_modules/react-markdown/src/uri-transformer.js ***!
  \****************************************************************/
/***/ ((module) => {

      const protocols = ['http', 'https', 'mailto', 'tel']

      module.exports = uriTransformer

/**
 * @param {string} uri
 * @returns {string}
 */
      function uriTransformer(uri) {
        const url = (uri || '').trim()
        const first = url.charAt(0)

        if (first === '#' || first === '/') {
          return url
        }

        const colon = url.indexOf(':')
        if (colon === -1) {
          return url
        }

        let index = -1

        while (++index < protocols.length) {
          const protocol = protocols[index]

          if (
            colon === protocol.length &&
      url.slice(0, protocol.length).toLowerCase() === protocol
          ) {
            return url
          }
        }

        index = url.indexOf('?')
        if (index !== -1 && colon > index) {
          return url
        }

        index = url.indexOf('#')
        if (index !== -1 && colon > index) {
          return url
        }

  // eslint-disable-next-line no-script-url
        return 'javascript:void(0)'
      }


/***/ }),

/***/ "../../node_modules/remark-parse/index.js":
/*!************************************************!*\
  !*** ../../node_modules/remark-parse/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = parse

      const fromMarkdown = __webpack_require__(/*! mdast-util-from-markdown */ "../../node_modules/mdast-util-from-markdown/index.js")

      function parse(options) {
        const self = this

        this.Parser = parse

        function parse(doc) {
          return fromMarkdown(
            doc,
            Object.assign({}, self.data('settings'), options, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
              extensions: self.data('micromarkExtensions') || [],
              mdastExtensions: self.data('fromMarkdownExtensions') || []
            })
          )
        }
      }


/***/ }),

/***/ "../../node_modules/remark-rehype/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/remark-rehype/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const mdast2hast = __webpack_require__(/*! mdast-util-to-hast */ "../../node_modules/mdast-util-to-hast/index.js")

      module.exports = remark2rehype

// Attacher.
// If a destination is given, runs the destination with the new hast tree
// (bridge mode).
// Without destination, returns the tree: further plugins run on that tree
// (mutate mode).
      function remark2rehype(destination, options) {
        if (destination && !destination.process) {
          options = destination
          destination = null
        }

        return destination ? bridge(destination, options) : mutate(options)
      }

// Bridge mode.
// Runs the destination with the new hast tree.
      function bridge(destination, options) {
        return transformer

        function transformer(node, file, next) {
          destination.run(mdast2hast(node, options), file, done)

          function done(error) {
            next(error)
          }
        }
      }

// Mutate-mode.
// Further transformers run on the hast tree.
      function mutate(options) {
        return transformer

        function transformer(node) {
          return mdast2hast(node, options)
        }
      }


/***/ }),

/***/ "../../node_modules/space-separated-tokens/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/space-separated-tokens/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";


      exports.parse = parse
      exports.stringify = stringify

      const empty = ''
      const space = ' '
      const whiteSpace = /[ \t\n\r\f]+/g

      function parse(value) {
        const input = String(value || empty).trim()
        return input === empty ? [] : input.split(whiteSpace)
      }

      function stringify(values) {
        return values.join(space).trim()
      }


/***/ }),

/***/ "../../node_modules/style-to-object/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/style-to-object/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      const parse = __webpack_require__(/*! inline-style-parser */ "../../node_modules/inline-style-parser/index.js");

/**
 * Parses inline style to object.
 *
 * @example
 * // returns { 'line-height': '42' }
 * StyleToObject('line-height: 42;');
 *
 * @param  {String}      style      - The inline style.
 * @param  {Function}    [iterator] - The iterator function.
 * @return {null|Object}
 */
      function StyleToObject(style, iterator) {
        let output = null;
        if (!style || typeof style !== 'string') {
          return output;
        }

        let declaration;
        const declarations = parse(style);
        const hasIterator = typeof iterator === 'function';
        let property;
        let value;

        for (let i = 0, len = declarations.length; i < len; i++) {
          declaration = declarations[i];
          property = declaration.property;
          value = declaration.value;

          if (hasIterator) {
            iterator(property, value, declaration);
          } else if (value) {
            output || (output = {});
            output[property] = value;
          }
        }

        return output;
      }

      module.exports = StyleToObject;


/***/ }),

/***/ "../../node_modules/trough/index.js":
/*!******************************************!*\
  !*** ../../node_modules/trough/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const wrap = __webpack_require__(/*! ./wrap.js */ "../../node_modules/trough/wrap.js")

      module.exports = trough

      trough.wrap = wrap

      const slice = [].slice

// Create new middleware.
      function trough() {
        const fns = []
        const middleware = {}

        middleware.run = run
        middleware.use = use

        return middleware

  // Run `fns`.  Last argument must be a completion handler.
        function run() {
          let index = -1
          let input = slice.call(arguments, 0, -1)
          const done = arguments[arguments.length - 1]

          if (typeof done !== 'function') {
            throw new Error('Expected function as last argument, not ' + done)
          }

          next.apply(null, [null].concat(input))

    // Run the next `fn`, if any.
          function next(err) {
            const fn = fns[++index]
            const params = slice.call(arguments, 0)
            const values = params.slice(1)
            const length = input.length
            let pos = -1

            if (err) {
              done(err)
              return
            }

      // Copy non-nully input into values.
            while (++pos < length) {
              if (values[pos] === null || values[pos] === undefined) {
                values[pos] = input[pos]
              }
            }

            input = values

      // Next or done.
            if (fn) {
              wrap(fn, next).apply(null, input)
            } else {
              done.apply(null, [null].concat(input))
            }
          }
        }

  // Add `fn` to the list.
        function use(fn) {
          if (typeof fn !== 'function') {
            throw new Error('Expected `fn` to be a function, not ' + fn)
          }

          fns.push(fn)

          return middleware
        }
      }


/***/ }),

/***/ "../../node_modules/trough/wrap.js":
/*!*****************************************!*\
  !*** ../../node_modules/trough/wrap.js ***!
  \*****************************************/
/***/ ((module) => {

      "use strict";


      const slice = [].slice

      module.exports = wrap

// Wrap `fn`.
// Can be sync or async; return a promise, receive a completion handler, return
// new values and errors.
      function wrap(fn, callback) {
        let invoked

        return wrapped

        function wrapped() {
          const params = slice.call(arguments, 0)
          const callback = fn.length > params.length
          let result

          if (callback) {
            params.push(done)
          }

          try {
            result = fn.apply(null, params)
          } catch (error) {
      // Well, this is quite the pickle.
      // `fn` received a callback and invoked it (thus continuing the pipeline),
      // but later also threw an error.
      // We’re not about to restart the pipeline again, so the only thing left
      // to do is to throw the thing instead.
            if (callback && invoked) {
              throw error
            }

            return done(error)
          }

          if (!callback) {
            if (result && typeof result.then === 'function') {
              result.then(then, done)
            } else if (result instanceof Error) {
              done(result)
            } else {
              then(result)
            }
          }
        }

  // Invoke `next`, only once.
        function done() {
          if (!invoked) {
            invoked = true

            callback.apply(null, arguments)
          }
        }

  // Invoke `done` with one value.
  // Tracks if an error is passed, too.
        function then(value) {
          done(null, value)
        }
      }


/***/ }),

/***/ "../../node_modules/unified/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/unified/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const bail = __webpack_require__(/*! bail */ "../../node_modules/bail/index.js")
      const buffer = __webpack_require__(/*! is-buffer */ "../../node_modules/unified/node_modules/is-buffer/index.js")
      const extend = __webpack_require__(/*! extend */ "../../node_modules/extend/index.js")
      const plain = __webpack_require__(/*! is-plain-obj */ "../../node_modules/is-plain-obj/index.js")
      const trough = __webpack_require__(/*! trough */ "../../node_modules/trough/index.js")
      const vfile = __webpack_require__(/*! vfile */ "../../node_modules/vfile/index.js")

// Expose a frozen processor.
      module.exports = unified().freeze()

      const slice = [].slice
      const own = {}.hasOwnProperty

// Process pipeline.
      const pipeline = trough()
        .use(pipelineParse)
        .use(pipelineRun)
        .use(pipelineStringify)

      function pipelineParse(p, ctx) {
        ctx.tree = p.parse(ctx.file)
      }

      function pipelineRun(p, ctx, next) {
        p.run(ctx.tree, ctx.file, done)

        function done(error, tree, file) {
          if (error) {
            next(error)
          } else {
            ctx.tree = tree
            ctx.file = file
            next()
          }
        }
      }

      function pipelineStringify(p, ctx) {
        const result = p.stringify(ctx.tree, ctx.file)

        if (result === undefined || result === null) {
    // Empty.
        } else if (typeof result === 'string' || buffer(result)) {
          if ('value' in ctx.file) {
            ctx.file.value = result
          }

          ctx.file.contents = result
        } else {
          ctx.file.result = result
        }
      }

// Function to create the first processor.
      function unified() {
        const attachers = []
        const transformers = trough()
        let namespace = {}
        let freezeIndex = -1
        let frozen

  // Data management.
        processor.data = data

  // Lock.
        processor.freeze = freeze

  // Plugins.
        processor.attachers = attachers
        processor.use = use

  // API.
        processor.parse = parse
        processor.stringify = stringify
        processor.run = run
        processor.runSync = runSync
        processor.process = process
        processor.processSync = processSync

  // Expose.
        return processor

  // Create a new processor based on the processor in the current scope.
        function processor() {
          const destination = unified()
          let index = -1

          while (++index < attachers.length) {
            destination.use.apply(null, attachers[index])
          }

          destination.data(extend(true, {}, namespace))

          return destination
        }

  // Freeze: used to signal a processor that has finished configuration.
  //
  // For example, take unified itself: it’s frozen.
  // Plugins should not be added to it.
  // Rather, it should be extended, by invoking it, before modifying it.
  //
  // In essence, always invoke this when exporting a processor.
        function freeze() {
          let values
          let transformer

          if (frozen) {
            return processor
          }

          while (++freezeIndex < attachers.length) {
            values = attachers[freezeIndex]

            if (values[1] === false) {
              continue
            }

            if (values[1] === true) {
              values[1] = undefined
            }

            transformer = values[0].apply(processor, values.slice(1))

            if (typeof transformer === 'function') {
              transformers.use(transformer)
            }
          }

          frozen = true
          freezeIndex = Infinity

          return processor
        }

  // Data management.
  // Getter / setter for processor-specific informtion.
        function data(key, value) {
          if (typeof key === 'string') {
      // Set `key`.
            if (arguments.length === 2) {
              assertUnfrozen('data', frozen)
              namespace[key] = value
              return processor
            }

      // Get `key`.
            return (own.call(namespace, key) && namespace[key]) || null
          }

    // Set space.
          if (key) {
            assertUnfrozen('data', frozen)
            namespace = key
            return processor
          }

    // Get space.
          return namespace
        }

  // Plugin management.
  //
  // Pass it:
  // *   an attacher and options,
  // *   a preset,
  // *   a list of presets, attachers, and arguments (list of attachers and
  //     options).
        function use(value) {
          let settings

          assertUnfrozen('use', frozen)

          if (value === null || value === undefined) {
      // Empty.
          } else if (typeof value === 'function') {
            addPlugin.apply(null, arguments)
          } else if (typeof value === 'object') {
            if ('length' in value) {
              addList(value)
            } else {
              addPreset(value)
            }
          } else {
            throw new Error('Expected usable value, not `' + value + '`')
          }

          if (settings) {
            namespace.settings = extend(namespace.settings || {}, settings)
          }

          return processor

          function addPreset(result) {
            addList(result.plugins)

            if (result.settings) {
              settings = extend(settings || {}, result.settings)
            }
          }

          function add(value) {
            if (typeof value === 'function') {
              addPlugin(value)
            } else if (typeof value === 'object') {
              if ('length' in value) {
                addPlugin.apply(null, value)
              } else {
                addPreset(value)
              }
            } else {
              throw new Error('Expected usable value, not `' + value + '`')
            }
          }

          function addList(plugins) {
            let index = -1

            if (plugins === null || plugins === undefined) {
        // Empty.
            } else if (typeof plugins === 'object' && 'length' in plugins) {
              while (++index < plugins.length) {
                add(plugins[index])
              }
            } else {
              throw new Error('Expected a list of plugins, not `' + plugins + '`')
            }
          }

          function addPlugin(plugin, value) {
            const entry = find(plugin)

            if (entry) {
              if (plain(entry[1]) && plain(value)) {
                value = extend(true, entry[1], value)
              }

              entry[1] = value
            } else {
              attachers.push(slice.call(arguments))
            }
          }
        }

        function find(plugin) {
          let index = -1

          while (++index < attachers.length) {
            if (attachers[index][0] === plugin) {
              return attachers[index]
            }
          }
        }

  // Parse a file (in string or vfile representation) into a unist node using
  // the `Parser` on the processor.
        function parse(doc) {
          const file = vfile(doc)
          let Parser

          freeze()
          Parser = processor.Parser
          assertParser('parse', Parser)

          if (newable(Parser, 'parse')) {
            return new Parser(String(file), file).parse()
          }

          return Parser(String(file), file) // eslint-disable-line new-cap
        }

  // Run transforms on a unist node representation of a file (in string or
  // vfile representation), async.
        function run(node, file, cb) {
          assertNode(node)
          freeze()

          if (!cb && typeof file === 'function') {
            cb = file
            file = null
          }

          if (!cb) {
            return new Promise(executor)
          }

          executor(null, cb)

          function executor(resolve, reject) {
            transformers.run(node, vfile(file), done)

            function done(error, tree, file) {
              tree = tree || node
              if (error) {
                reject(error)
              } else if (resolve) {
                resolve(tree)
              } else {
                cb(null, tree, file)
              }
            }
          }
        }

  // Run transforms on a unist node representation of a file (in string or
  // vfile representation), sync.
        function runSync(node, file) {
          let result
          let complete

          run(node, file, done)

          assertDone('runSync', 'run', complete)

          return result

          function done(error, tree) {
            complete = true
            result = tree
            bail(error)
          }
        }

  // Stringify a unist node representation of a file (in string or vfile
  // representation) into a string using the `Compiler` on the processor.
        function stringify(node, doc) {
          const file = vfile(doc)
          let Compiler

          freeze()
          Compiler = processor.Compiler
          assertCompiler('stringify', Compiler)
          assertNode(node)

          if (newable(Compiler, 'compile')) {
            return new Compiler(node, file).compile()
          }

          return Compiler(node, file) // eslint-disable-line new-cap
        }

  // Parse a file (in string or vfile representation) into a unist node using
  // the `Parser` on the processor, then run transforms on that node, and
  // compile the resulting node using the `Compiler` on the processor, and
  // store that result on the vfile.
        function process(doc, cb) {
          freeze()
          assertParser('process', processor.Parser)
          assertCompiler('process', processor.Compiler)

          if (!cb) {
            return new Promise(executor)
          }

          executor(null, cb)

          function executor(resolve, reject) {
            const file = vfile(doc)

            pipeline.run(processor, {file: file}, done)

            function done(error) {
              if (error) {
                reject(error)
              } else if (resolve) {
                resolve(file)
              } else {
                cb(null, file)
              }
            }
          }
        }

  // Process the given document (in string or vfile representation), sync.
        function processSync(doc) {
          let file
          let complete

          freeze()
          assertParser('processSync', processor.Parser)
          assertCompiler('processSync', processor.Compiler)
          file = vfile(doc)

          process(file, done)

          assertDone('processSync', 'process', complete)

          return file

          function done(error) {
            complete = true
            bail(error)
          }
        }
      }

// Check if `value` is a constructor.
      function newable(value, name) {
        return (
          typeof value === 'function' &&
    value.prototype &&
    // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    (keys(value.prototype) || name in value.prototype)
        )
      }

// Check if `value` is an object with keys.
      function keys(value) {
        let key
        for (key in value) {
          return true
        }

        return false
      }

// Assert a parser is available.
      function assertParser(name, Parser) {
        if (typeof Parser !== 'function') {
          throw new Error('Cannot `' + name + '` without `Parser`')
        }
      }

// Assert a compiler is available.
      function assertCompiler(name, Compiler) {
        if (typeof Compiler !== 'function') {
          throw new Error('Cannot `' + name + '` without `Compiler`')
        }
      }

// Assert the processor is not frozen.
      function assertUnfrozen(name, frozen) {
        if (frozen) {
          throw new Error(
            'Cannot invoke `' +
        name +
        '` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.'
          )
        }
      }

// Assert `node` is a unist node.
      function assertNode(node) {
        if (!node || typeof node.type !== 'string') {
          throw new Error('Expected node, got `' + node + '`')
        }
      }

// Assert that `complete` is `true`.
      function assertDone(name, asyncName, complete) {
        if (!complete) {
          throw new Error(
            '`' + name + '` finished async. Use `' + asyncName + '` instead'
          )
        }
      }


/***/ }),

/***/ "../../node_modules/unified/node_modules/is-buffer/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/unified/node_modules/is-buffer/index.js ***!
  \******************************************************************/
/***/ ((module) => {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

      module.exports = function isBuffer (obj) {
        return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
      }


/***/ }),

/***/ "../../node_modules/unist-builder/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/unist-builder/index.js ***!
  \*************************************************/
/***/ ((module) => {

      "use strict";


      module.exports = u

      function u(type, props, value) {
        let node

        if (
          (value === null || value === undefined) &&
    (typeof props !== 'object' || Array.isArray(props))
        ) {
          value = props
          props = {}
        }

        node = Object.assign({type: String(type)}, props)

        if (Array.isArray(value)) {
          node.children = value
        } else if (value !== null && value !== undefined) {
          node.value = String(value)
        }

        return node
      }


/***/ }),

/***/ "../../node_modules/unist-util-generated/index.js":
/*!********************************************************!*\
  !*** ../../node_modules/unist-util-generated/index.js ***!
  \********************************************************/
/***/ ((module) => {

      "use strict";


      module.exports = generated

      function generated(node) {
        return (
          !node ||
    !node.position ||
    !node.position.start ||
    !node.position.start.line ||
    !node.position.start.column ||
    !node.position.end ||
    !node.position.end.line ||
    !node.position.end.column
        )
      }


/***/ }),

/***/ "../../node_modules/unist-util-is/convert.js":
/*!***************************************************!*\
  !*** ../../node_modules/unist-util-is/convert.js ***!
  \***************************************************/
/***/ ((module) => {

      "use strict";


      module.exports = convert

      function convert(test) {
        if (test == null) {
          return ok
        }

        if (typeof test === 'string') {
          return typeFactory(test)
        }

        if (typeof test === 'object') {
          return 'length' in test ? anyFactory(test) : allFactory(test)
        }

        if (typeof test === 'function') {
          return test
        }

        throw new Error('Expected function, string, or object as test')
      }

// Utility assert each property in `test` is represented in `node`, and each
// values are strictly equal.
      function allFactory(test) {
        return all

        function all(node) {
          let key

          for (key in test) {
            if (node[key] !== test[key]) return false
          }

          return true
        }
      }

      function anyFactory(tests) {
        const checks = []
        let index = -1

        while (++index < tests.length) {
          checks[index] = convert(tests[index])
        }

        return any

        function any() {
          let index = -1

          while (++index < checks.length) {
            if (checks[index].apply(this, arguments)) {
              return true
            }
          }

          return false
        }
      }

// Utility to convert a string into a function which checks a given node’s type
// for said string.
      function typeFactory(test) {
        return type

        function type(node) {
          return Boolean(node && node.type === test)
        }
      }

// Utility to return true.
      function ok() {
        return true
      }


/***/ }),

/***/ "../../node_modules/unist-util-position/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/unist-util-position/index.js ***!
  \*******************************************************/
/***/ ((module) => {

      "use strict";


      const start = factory('start')
      const end = factory('end')

      module.exports = position

      position.start = start
      position.end = end

      function position(node) {
        return {start: start(node), end: end(node)}
      }

      function factory(type) {
        point.displayName = type

        return point

        function point(node) {
          const point = (node && node.position && node.position[type]) || {}

          return {
            line: point.line || null,
            column: point.column || null,
            offset: isNaN(point.offset) ? null : point.offset
          }
        }
      }


/***/ }),

/***/ "../../node_modules/unist-util-stringify-position/index.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/unist-util-stringify-position/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

      "use strict";


      const own = {}.hasOwnProperty

      module.exports = stringify

      function stringify(value) {
  // Nothing.
        if (!value || typeof value !== 'object') {
          return ''
        }

  // Node.
        if (own.call(value, 'position') || own.call(value, 'type')) {
          return position(value.position)
        }

  // Position.
        if (own.call(value, 'start') || own.call(value, 'end')) {
          return position(value)
        }

  // Point.
        if (own.call(value, 'line') || own.call(value, 'column')) {
          return point(value)
        }

  // ?
        return ''
      }

      function point(point) {
        if (!point || typeof point !== 'object') {
          point = {}
        }

        return index(point.line) + ':' + index(point.column)
      }

      function position(pos) {
        if (!pos || typeof pos !== 'object') {
          pos = {}
        }

        return point(pos.start) + '-' + point(pos.end)
      }

      function index(value) {
        return value && typeof value === 'number' ? value : 1
      }


/***/ }),

/***/ "../../node_modules/unist-util-visit-parents/color.browser.js":
/*!********************************************************************!*\
  !*** ../../node_modules/unist-util-visit-parents/color.browser.js ***!
  \********************************************************************/
/***/ ((module) => {

      module.exports = identity
      function identity(d) {
        return d
      }


/***/ }),

/***/ "../../node_modules/unist-util-visit-parents/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/unist-util-visit-parents/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = visitParents

      const convert = __webpack_require__(/*! unist-util-is/convert */ "../../node_modules/unist-util-is/convert.js")
      const color = __webpack_require__(/*! ./color */ "../../node_modules/unist-util-visit-parents/color.browser.js")

      const CONTINUE = true
      const SKIP = 'skip'
      const EXIT = false

      visitParents.CONTINUE = CONTINUE
      visitParents.SKIP = SKIP
      visitParents.EXIT = EXIT

      function visitParents(tree, test, visitor, reverse) {
        let step
        let is

        if (typeof test === 'function' && typeof visitor !== 'function') {
          reverse = visitor
          visitor = test
          test = null
        }

        is = convert(test)
        step = reverse ? -1 : 1

        factory(tree, null, [])()

        function factory(node, index, parents) {
          const value = typeof node === 'object' && node !== null ? node : {}
          let name

          if (typeof value.type === 'string') {
            name =
        typeof value.tagName === 'string'
          ? value.tagName
          : typeof value.name === 'string'
            ? value.name
            : undefined

            visit.displayName =
        'node (' + color(value.type + (name ? '<' + name + '>' : '')) + ')'
          }

          return visit

          function visit() {
            const grandparents = parents.concat(node)
            let result = []
            let subresult
            let offset

            if (!test || is(node, index, parents[parents.length - 1] || null)) {
              result = toResult(visitor(node, parents))

              if (result[0] === EXIT) {
                return result
              }
            }

            if (node.children && result[0] !== SKIP) {
              offset = (reverse ? node.children.length : -1) + step

              while (offset > -1 && offset < node.children.length) {
                subresult = factory(node.children[offset], offset, grandparents)()

                if (subresult[0] === EXIT) {
                  return subresult
                }

                offset =
            typeof subresult[1] === 'number' ? subresult[1] : offset + step
              }
            }

            return result
          }
        }
      }

      function toResult(value) {
        if (value !== null && typeof value === 'object' && 'length' in value) {
          return value
        }

        if (typeof value === 'number') {
          return [CONTINUE, value]
        }

        return [value]
      }


/***/ }),

/***/ "../../node_modules/unist-util-visit/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/unist-util-visit/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = visit

      const visitParents = __webpack_require__(/*! unist-util-visit-parents */ "../../node_modules/unist-util-visit-parents/index.js")

      const CONTINUE = visitParents.CONTINUE
      const SKIP = visitParents.SKIP
      const EXIT = visitParents.EXIT

      visit.CONTINUE = CONTINUE
      visit.SKIP = SKIP
      visit.EXIT = EXIT

      function visit(tree, test, visitor, reverse) {
        if (typeof test === 'function' && typeof visitor !== 'function') {
          reverse = visitor
          visitor = test
          test = null
        }

        visitParents(tree, test, overload, reverse)

        function overload(node, parents) {
          const parent = parents[parents.length - 1]
          const index = parent ? parent.children.indexOf(node) : null
          return visitor(node, index, parent)
        }
      }


/***/ }),

/***/ "../../node_modules/vfile-message/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/vfile-message/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const stringify = __webpack_require__(/*! unist-util-stringify-position */ "../../node_modules/unist-util-stringify-position/index.js")

      module.exports = VMessage

// Inherit from `Error#`.
      function VMessagePrototype() {}
      VMessagePrototype.prototype = Error.prototype
      VMessage.prototype = new VMessagePrototype()

// Message properties.
      const proto = VMessage.prototype

      proto.file = ''
      proto.name = ''
      proto.reason = ''
      proto.message = ''
      proto.stack = ''
      proto.fatal = null
      proto.column = null
      proto.line = null

// Construct a new VMessage.
//
// Note: We cannot invoke `Error` on the created context, as that adds readonly
// `line` and `column` attributes on Safari 9, thus throwing and failing the
// data.
      function VMessage(reason, position, origin) {
        let parts
        let range
        let location

        if (typeof position === 'string') {
          origin = position
          position = null
        }

        parts = parseOrigin(origin)
        range = stringify(position) || '1:1'

        location = {
          start: {line: null, column: null},
          end: {line: null, column: null}
        }

  // Node.
        if (position && position.position) {
          position = position.position
        }

        if (position) {
    // Position.
          if (position.start) {
            location = position
            position = position.start
          } else {
      // Point.
            location.start = position
          }
        }

        if (reason.stack) {
          this.stack = reason.stack
          reason = reason.message
        }

        this.message = reason
        this.name = range
        this.reason = reason
        this.line = position ? position.line : null
        this.column = position ? position.column : null
        this.location = location
        this.source = parts[0]
        this.ruleId = parts[1]
      }

      function parseOrigin(origin) {
        const result = [null, null]
        let index

        if (typeof origin === 'string') {
          index = origin.indexOf(':')

          if (index === -1) {
            result[1] = origin
          } else {
            result[0] = origin.slice(0, index)
            result[1] = origin.slice(index + 1)
          }
        }

        return result
      }


/***/ }),

/***/ "../../node_modules/vfile/index.js":
/*!*****************************************!*\
  !*** ../../node_modules/vfile/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      module.exports = __webpack_require__(/*! ./lib */ "../../node_modules/vfile/lib/index.js")


/***/ }),

/***/ "../../node_modules/vfile/lib/core.js":
/*!********************************************!*\
  !*** ../../node_modules/vfile/lib/core.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const p = __webpack_require__(/*! ./minpath */ "../../node_modules/vfile/lib/minpath.browser.js")
      const proc = __webpack_require__(/*! ./minproc */ "../../node_modules/vfile/lib/minproc.browser.js")
      const buffer = __webpack_require__(/*! is-buffer */ "../../node_modules/vfile/node_modules/is-buffer/index.js")

      module.exports = VFile

      const own = {}.hasOwnProperty

// Order of setting (least specific to most), we need this because otherwise
// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
// stem can be set.
      const order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']

      VFile.prototype.toString = toString

// Access full path (`~/index.min.js`).
      Object.defineProperty(VFile.prototype, 'path', {get: getPath, set: setPath})

// Access parent path (`~`).
      Object.defineProperty(VFile.prototype, 'dirname', {
        get: getDirname,
        set: setDirname
      })

// Access basename (`index.min.js`).
      Object.defineProperty(VFile.prototype, 'basename', {
        get: getBasename,
        set: setBasename
      })

// Access extname (`.js`).
      Object.defineProperty(VFile.prototype, 'extname', {
        get: getExtname,
        set: setExtname
      })

// Access stem (`index.min`).
      Object.defineProperty(VFile.prototype, 'stem', {get: getStem, set: setStem})

// Construct a new file.
      function VFile(options) {
        let prop
        let index

        if (!options) {
          options = {}
        } else if (typeof options === 'string' || buffer(options)) {
          options = {contents: options}
        } else if ('message' in options && 'messages' in options) {
          return options
        }

        if (!(this instanceof VFile)) {
          return new VFile(options)
        }

        this.data = {}
        this.messages = []
        this.history = []
        this.cwd = proc.cwd()

  // Set path related properties in the correct order.
        index = -1

        while (++index < order.length) {
          prop = order[index]

          if (own.call(options, prop)) {
            this[prop] = options[prop]
          }
        }

  // Set non-path related properties.
        for (prop in options) {
          if (order.indexOf(prop) < 0) {
            this[prop] = options[prop]
          }
        }
      }

      function getPath() {
        return this.history[this.history.length - 1]
      }

      function setPath(path) {
        assertNonEmpty(path, 'path')

        if (this.path !== path) {
          this.history.push(path)
        }
      }

      function getDirname() {
        return typeof this.path === 'string' ? p.dirname(this.path) : undefined
      }

      function setDirname(dirname) {
        assertPath(this.path, 'dirname')
        this.path = p.join(dirname || '', this.basename)
      }

      function getBasename() {
        return typeof this.path === 'string' ? p.basename(this.path) : undefined
      }

      function setBasename(basename) {
        assertNonEmpty(basename, 'basename')
        assertPart(basename, 'basename')
        this.path = p.join(this.dirname || '', basename)
      }

      function getExtname() {
        return typeof this.path === 'string' ? p.extname(this.path) : undefined
      }

      function setExtname(extname) {
        assertPart(extname, 'extname')
        assertPath(this.path, 'extname')

        if (extname) {
          if (extname.charCodeAt(0) !== 46 /* `.` */) {
            throw new Error('`extname` must start with `.`')
          }

          if (extname.indexOf('.', 1) > -1) {
            throw new Error('`extname` cannot contain multiple dots')
          }
        }

        this.path = p.join(this.dirname, this.stem + (extname || ''))
      }

      function getStem() {
        return typeof this.path === 'string'
          ? p.basename(this.path, this.extname)
          : undefined
      }

      function setStem(stem) {
        assertNonEmpty(stem, 'stem')
        assertPart(stem, 'stem')
        this.path = p.join(this.dirname || '', stem + (this.extname || ''))
      }

// Get the value of the file.
      function toString(encoding) {
        return (this.contents || '').toString(encoding)
      }

// Assert that `part` is not a path (i.e., does not contain `p.sep`).
      function assertPart(part, name) {
        if (part && part.indexOf(p.sep) > -1) {
          throw new Error(
            '`' + name + '` cannot be a path: did not expect `' + p.sep + '`'
          )
        }
      }

// Assert that `part` is not empty.
      function assertNonEmpty(part, name) {
        if (!part) {
          throw new Error('`' + name + '` cannot be empty')
        }
      }

// Assert `path` exists.
      function assertPath(path, name) {
        if (!path) {
          throw new Error('Setting `' + name + '` requires `path` to be set too')
        }
      }


/***/ }),

/***/ "../../node_modules/vfile/lib/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/vfile/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const VMessage = __webpack_require__(/*! vfile-message */ "../../node_modules/vfile-message/index.js")
      const VFile = __webpack_require__(/*! ./core.js */ "../../node_modules/vfile/lib/core.js")

      module.exports = VFile

      VFile.prototype.message = message
      VFile.prototype.info = info
      VFile.prototype.fail = fail

// Create a message with `reason` at `position`.
// When an error is passed in as `reason`, copies the stack.
      function message(reason, position, origin) {
        const message = new VMessage(reason, position, origin)

        if (this.path) {
          message.name = this.path + ':' + message.name
          message.file = this.path
        }

        message.fatal = false

        this.messages.push(message)

        return message
      }

// Fail: creates a vmessage, associates it with the file, and throws it.
      function fail() {
        const message = this.message.apply(this, arguments)

        message.fatal = true

        throw message
      }

// Info: creates a vmessage, associates it with the file, and marks the fatality
// as null.
      function info() {
        const message = this.message.apply(this, arguments)

        message.fatal = null

        return message
      }


/***/ }),

/***/ "../../node_modules/vfile/lib/minpath.browser.js":
/*!*******************************************************!*\
  !*** ../../node_modules/vfile/lib/minpath.browser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";


// A derivative work based on:
// <https://github.com/browserify/path-browserify>.
// Which is licensed:
//
// MIT License
//
// Copyright (c) 2013 James Halliday
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// A derivative work based on:
//
// Parts of that are extracted from Node’s internal `path` module:
// <https://github.com/nodejs/node/blob/master/lib/path.js>.
// Which is licensed:
//
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

      exports.basename = basename
      exports.dirname = dirname
      exports.extname = extname
      exports.join = join
      exports.sep = '/'

      function basename(path, ext) {
        let start = 0
        let end = -1
        let index
        let firstNonSlashEnd
        let seenNonSlash
        let extIndex

        if (ext !== undefined && typeof ext !== 'string') {
          throw new TypeError('"ext" argument must be a string')
        }

        assertPath(path)
        index = path.length

        if (ext === undefined || !ext.length || ext.length > path.length) {
          while (index--) {
            if (path.charCodeAt(index) === 47 /* `/` */) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now.
              if (seenNonSlash) {
                start = index + 1
                break
              }
            } else if (end < 0) {
        // We saw the first non-path separator, mark this as the end of our
        // path component.
              seenNonSlash = true
              end = index + 1
            }
          }

          return end < 0 ? '' : path.slice(start, end)
        }

        if (ext === path) {
          return ''
        }

        firstNonSlashEnd = -1
        extIndex = ext.length - 1

        while (index--) {
          if (path.charCodeAt(index) === 47 /* `/` */) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now.
            if (seenNonSlash) {
              start = index + 1
              break
            }
          } else {
            if (firstNonSlashEnd < 0) {
        // We saw the first non-path separator, remember this index in case
        // we need it if the extension ends up not matching.
              seenNonSlash = true
              firstNonSlashEnd = index + 1
            }

            if (extIndex > -1) {
        // Try to match the explicit extension.
              if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {
                if (extIndex < 0) {
            // We matched the extension, so mark this as the end of our path
            // component
                  end = index
                }
              } else {
          // Extension does not match, so our result is the entire path
          // component
                extIndex = -1
                end = firstNonSlashEnd
              }
            }
          }
        }

        if (start === end) {
          end = firstNonSlashEnd
        } else if (end < 0) {
          end = path.length
        }

        return path.slice(start, end)
      }

      function dirname(path) {
        let end
        let unmatchedSlash
        let index

        assertPath(path)

        if (!path.length) {
          return '.'
        }

        end = -1
        index = path.length

  // Prefix `--` is important to not run on `0`.
        while (--index) {
          if (path.charCodeAt(index) === 47 /* `/` */) {
            if (unmatchedSlash) {
              end = index
              break
            }
          } else if (!unmatchedSlash) {
      // We saw the first non-path separator
            unmatchedSlash = true
          }
        }

        return end < 0
          ? path.charCodeAt(0) === 47 /* `/` */
            ? '/'
            : '.'
          : end === 1 && path.charCodeAt(0) === 47 /* `/` */
            ? '//'
            : path.slice(0, end)
      }

      function extname(path) {
        let startDot = -1
        let startPart = 0
        let end = -1
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find.
        let preDotState = 0
        let unmatchedSlash
        let code
        let index

        assertPath(path)

        index = path.length

        while (index--) {
          code = path.charCodeAt(index)

          if (code === 47 /* `/` */) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now.
            if (unmatchedSlash) {
              startPart = index + 1
              break
            }

            continue
          }

          if (end < 0) {
      // We saw the first non-path separator, mark this as the end of our
      // extension.
            unmatchedSlash = true
            end = index + 1
          }

          if (code === 46 /* `.` */) {
      // If this is our first dot, mark it as the start of our extension.
            if (startDot < 0) {
              startDot = index
            } else if (preDotState !== 1) {
              preDotState = 1
            }
          } else if (startDot > -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension.
            preDotState = -1
          }
        }

        if (
          startDot < 0 ||
    end < 0 ||
    // We saw a non-dot character immediately before the dot.
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly `..`.
    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)
        ) {
          return ''
        }

        return path.slice(startDot, end)
      }

      function join() {
        let index = -1
        let joined

        while (++index < arguments.length) {
          assertPath(arguments[index])

          if (arguments[index]) {
            joined =
        joined === undefined
          ? arguments[index]
          : joined + '/' + arguments[index]
          }
        }

        return joined === undefined ? '.' : normalize(joined)
      }

// Note: `normalize` is not exposed as `path.normalize`, so some code is
// manually removed from it.
      function normalize(path) {
        let absolute
        let value

        assertPath(path)

        absolute = path.charCodeAt(0) === 47 /* `/` */

  // Normalize the path according to POSIX rules.
        value = normalizeString(path, !absolute)

        if (!value.length && !absolute) {
          value = '.'
        }

        if (value.length && path.charCodeAt(path.length - 1) === 47 /* / */) {
          value += '/'
        }

        return absolute ? '/' + value : value
      }

// Resolve `.` and `..` elements in a path with directory names.
      function normalizeString(path, allowAboveRoot) {
        let result = ''
        let lastSegmentLength = 0
        let lastSlash = -1
        let dots = 0
        let index = -1
        let code
        let lastSlashIndex

        while (++index <= path.length) {
          if (index < path.length) {
            code = path.charCodeAt(index)
          } else if (code === 47 /* `/` */) {
            break
          } else {
            code = 47 /* `/` */
          }

          if (code === 47 /* `/` */) {
            if (lastSlash === index - 1 || dots === 1) {
        // Empty.
            } else if (lastSlash !== index - 1 && dots === 2) {
              if (
                result.length < 2 ||
          lastSegmentLength !== 2 ||
          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||
          result.charCodeAt(result.length - 2) !== 46 /* `.` */
              ) {
                if (result.length > 2) {
                  lastSlashIndex = result.lastIndexOf('/')

            /* istanbul ignore else - No clue how to cover it. */
                  if (lastSlashIndex !== result.length - 1) {
                    if (lastSlashIndex < 0) {
                      result = ''
                      lastSegmentLength = 0
                    } else {
                      result = result.slice(0, lastSlashIndex)
                      lastSegmentLength = result.length - 1 - result.lastIndexOf('/')
                    }

                    lastSlash = index
                    dots = 0
                    continue
                  }
                } else if (result.length) {
                  result = ''
                  lastSegmentLength = 0
                  lastSlash = index
                  dots = 0
                  continue
                }
              }

              if (allowAboveRoot) {
                result = result.length ? result + '/..' : '..'
                lastSegmentLength = 2
              }
            } else {
              if (result.length) {
                result += '/' + path.slice(lastSlash + 1, index)
              } else {
                result = path.slice(lastSlash + 1, index)
              }

              lastSegmentLength = index - lastSlash - 1
            }

            lastSlash = index
            dots = 0
          } else if (code === 46 /* `.` */ && dots > -1) {
            dots++
          } else {
            dots = -1
          }
        }

        return result
      }

      function assertPath(path) {
        if (typeof path !== 'string') {
          throw new TypeError(
            'Path must be a string. Received ' + JSON.stringify(path)
          )
        }
      }


/***/ }),

/***/ "../../node_modules/vfile/lib/minproc.browser.js":
/*!*******************************************************!*\
  !*** ../../node_modules/vfile/lib/minproc.browser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";


// Somewhat based on:
// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.
// But I don’t think one tiny line of code can be copyrighted. 😅
      exports.cwd = cwd

      function cwd() {
        return '/'
      }


/***/ }),

/***/ "../../node_modules/vfile/node_modules/is-buffer/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/vfile/node_modules/is-buffer/index.js ***!
  \****************************************************************/
/***/ ((module) => {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

      module.exports = function isBuffer (obj) {
        return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
      }


/***/ }),

/***/ "../../node_modules/xtend/immutable.js":
/*!*********************************************!*\
  !*** ../../node_modules/xtend/immutable.js ***!
  \*********************************************/
/***/ ((module) => {

      module.exports = extend

      const hasOwnProperty = Object.prototype.hasOwnProperty;

      function extend() {
        const target = {}

        for (let i = 0; i < arguments.length; i++) {
          const source = arguments[i]

          for (const key in source) {
            if (hasOwnProperty.call(source, key)) {
              target[key] = source[key]
            }
          }
        }

        return target
      }


/***/ }),

/***/ "./node_modules/bsdiff-node/index.js":
/*!*******************************************!*\
  !*** ./node_modules/bsdiff-node/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";

      const fs = __webpack_require__(/*! fs */ "fs");
      const { promisify } = __webpack_require__(/*! util */ "util");
      const readFile = promisify(fs.readFile);
      const writeFile = promisify(fs.writeFile);

      function nodeify(promise, cb) {
        if (typeof cb === "function") {
          promise.then(() => cb()).catch(cb);
          return;
        }
        return promise;
      }

      function diff(_srcFile, dstFile, patchFile, cb) {
        const work = (async () => {
          const data = await readFile(dstFile);
          await writeFile(patchFile, data);
        })();
        return nodeify(work, cb);
      }

      function patch(_srcFile, patchFile, dstFile, cb) {
        const work = (async () => {
          const data = await readFile(patchFile);
          await writeFile(dstFile, data);
        })();
        return nodeify(work, cb);
      }

      module.exports = { diff, patch };


/***/ }),

/***/ "./node_modules/crc-32/crc32.js":
/*!**************************************!*\
  !*** ./node_modules/crc-32/crc32.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
/* vim: set ts=2: */
/*exported CRC32 */
      let CRC32;
      (function (factory) {
	/*jshint ignore:start */
	/*eslint-disable */
	if(typeof DO_NOT_EXPORT_CRC === 'undefined') {
		if(true) {
			factory(exports);
		} else // removed by dead control flow
{}
	} else {
		factory(CRC32 = {});
	}
	/*eslint-enable */
	/*jshint ignore:end */
      }(function(CRC32) {
        CRC32.version = '1.2.2';
/*global Int32Array */
        function signed_crc_table() {
          let c = 0, table = new Array(256);

          for(let n =0; n != 256; ++n){
            c = n;
            c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
            c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
            c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
            c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
            c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
            c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
            c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
            c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
            table[n] = c;
          }

          return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
        }

        const T0 = signed_crc_table();
        function slice_by_16_tables(T) {
          let c = 0, v = 0, n = 0, table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096) ;

          for(n = 0; n != 256; ++n) table[n] = T[n];
          for(n = 0; n != 256; ++n) {
            v = T[n];
            for(c = 256 + n; c < 4096; c += 256) v = table[c] = (v >>> 8) ^ T[v & 0xFF];
          }
          const out = [];
          for(n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
          return out;
        }
        const TT = slice_by_16_tables(T0);
        const T1 = TT[0],  T2 = TT[1],  T3 = TT[2],  T4 = TT[3],  T5 = TT[4];
        const T6 = TT[5],  T7 = TT[6],  T8 = TT[7],  T9 = TT[8],  Ta = TT[9];
        const Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
        function crc32_bstr(bstr, seed) {
          let C = seed ^ -1;
          for(let i = 0, L = bstr.length; i < L;) C = (C>>>8) ^ T0[(C^bstr.charCodeAt(i++))&0xFF];
          return ~C;
        }

        function crc32_buf(B, seed) {
          let C = seed ^ -1, L = B.length - 15, i = 0;
          for(; i < L;) C =
		Tf[B[i++] ^ (C & 255)] ^
		Te[B[i++] ^ ((C >> 8) & 255)] ^
		Td[B[i++] ^ ((C >> 16) & 255)] ^
		Tc[B[i++] ^ (C >>> 24)] ^
		Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^
		T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^
		T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
          L += 15;
          while(i < L) C = (C>>>8) ^ T0[(C^B[i++])&0xFF];
          return ~C;
        }

        function crc32_str(str, seed) {
          let C = seed ^ -1;
          for(let i = 0, L = str.length, c = 0, d = 0; i < L;) {
            c = str.charCodeAt(i++);
            if(c < 0x80) {
              C = (C>>>8) ^ T0[(C^c)&0xFF];
            } else if(c < 0x800) {
              C = (C>>>8) ^ T0[(C ^ (192|((c>>6)&31)))&0xFF];
              C = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];
            } else if(c >= 0xD800 && c < 0xE000) {
              c = (c&1023)+64; d = str.charCodeAt(i++)&1023;
              C = (C>>>8) ^ T0[(C ^ (240|((c>>8)&7)))&0xFF];
              C = (C>>>8) ^ T0[(C ^ (128|((c>>2)&63)))&0xFF];
              C = (C>>>8) ^ T0[(C ^ (128|((d>>6)&15)|((c&3)<<4)))&0xFF];
              C = (C>>>8) ^ T0[(C ^ (128|(d&63)))&0xFF];
            } else {
              C = (C>>>8) ^ T0[(C ^ (224|((c>>12)&15)))&0xFF];
              C = (C>>>8) ^ T0[(C ^ (128|((c>>6)&63)))&0xFF];
              C = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];
            }
          }
          return ~C;
        }
        CRC32.table = T0;
// $FlowIgnore
        CRC32.bstr = crc32_bstr;
// $FlowIgnore
        CRC32.buf = crc32_buf;
// $FlowIgnore
        CRC32.str = crc32_str;
      }));


/***/ }),

/***/ "./node_modules/memoize-one/dist/memoize-one.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/memoize-one/dist/memoize-one.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ memoizeOne)
/* harmony export */ });
      const safeIsNaN = Number.isNaN ||
    function ponyfill(value) {
      return typeof value === 'number' && value !== value;
    };
      function isEqual(first, second) {
        if (first === second) {
          return true;
        }
        if (safeIsNaN(first) && safeIsNaN(second)) {
          return true;
        }
        return false;
      }
      function areInputsEqual(newInputs, lastInputs) {
        if (newInputs.length !== lastInputs.length) {
          return false;
        }
        for (let i = 0; i < newInputs.length; i++) {
          if (!isEqual(newInputs[i], lastInputs[i])) {
            return false;
          }
        }
        return true;
      }

      function memoizeOne(resultFn, isEqual) {
        if (isEqual === void 0) { isEqual = areInputsEqual; }
        let cache = null;
        function memoized() {
          const newArgs = [];
          for (let _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
          }
          if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {
            return cache.lastResult;
          }
          const lastResult = resultFn.apply(this, newArgs);
          cache = {
            lastResult: lastResult,
            lastArgs: newArgs,
            lastThis: this,
          };
          return lastResult;
        }
        memoized.clear = function clear() {
          cache = null;
        };
        return memoized;
      }




/***/ }),

/***/ "./node_modules/nanoid/index.browser.js":
/*!**********************************************!*\
  !*** ./node_modules/nanoid/index.browser.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),
/* harmony export */   customRandom: () => (/* binding */ customRandom),
/* harmony export */   nanoid: () => (/* binding */ nanoid),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   urlAlphabet: () => (/* reexport safe */ _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__.urlAlphabet)
/* harmony export */ });
/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-alphabet/index.js */ "./node_modules/nanoid/url-alphabet/index.js");

      const random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
      const customRandom = (alphabet, defaultSize, getRandom) => {
        const mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
        const step = -~((1.6 * mask * defaultSize) / alphabet.length)
        return (size = defaultSize) => {
          let id = ''
          while (true) {
            const bytes = getRandom(step)
            let j = step | 0
            while (j--) {
              id += alphabet[bytes[j] & mask] || ''
              if (id.length === size) return id
            }
          }
        }
      }
      const customAlphabet = (alphabet, size = 21) =>
        customRandom(alphabet, size, random)
      const nanoid = (size = 21) =>
        crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
          byte &= 63
          if (byte < 36) {
            id += byte.toString(36)
          } else if (byte < 62) {
            id += (byte - 26).toString(36).toUpperCase()
          } else if (byte > 62) {
            id += '-'
          } else {
            id += '_'
          }
          return id
        }, '')



/***/ }),

/***/ "./node_modules/nanoid/url-alphabet/index.js":
/*!***************************************************!*\
  !*** ./node_modules/nanoid/url-alphabet/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   urlAlphabet: () => (/* binding */ urlAlphabet)
/* harmony export */ });
      const urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'



/***/ }),

/***/ "./node_modules/shortid/index.js":
/*!***************************************!*\
  !*** ./node_modules/shortid/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";

      module.exports = __webpack_require__(/*! ./lib/index */ "./node_modules/shortid/lib/index.js");


/***/ }),

/***/ "./node_modules/shortid/lib/alphabet.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/alphabet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const randomFromSeed = __webpack_require__(/*! ./random/random-from-seed */ "./node_modules/shortid/lib/random/random-from-seed.js");

      const ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
      let alphabet;
      let previousSeed;

      let shuffled;

      function reset() {
        shuffled = false;
      }

      function setCharacters(_alphabet_) {
        if (!_alphabet_) {
          if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
          }
          return;
        }

        if (_alphabet_ === alphabet) {
          return;
        }

        if (_alphabet_.length !== ORIGINAL.length) {
          throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
        }

        const unique = _alphabet_.split('').filter(function(item, ind, arr){
          return ind !== arr.lastIndexOf(item);
        });

        if (unique.length) {
          throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
        }

        alphabet = _alphabet_;
        reset();
      }

      function characters(_alphabet_) {
        setCharacters(_alphabet_);
        return alphabet;
      }

      function setSeed(seed) {
        randomFromSeed.seed(seed);
        if (previousSeed !== seed) {
          reset();
          previousSeed = seed;
        }
      }

      function shuffle() {
        if (!alphabet) {
          setCharacters(ORIGINAL);
        }

        const sourceArray = alphabet.split('');
        const targetArray = [];
        let r = randomFromSeed.nextValue();
        let characterIndex;

        while (sourceArray.length > 0) {
          r = randomFromSeed.nextValue();
          characterIndex = Math.floor(r * sourceArray.length);
          targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
        }
        return targetArray.join('');
      }

      function getShuffled() {
        if (shuffled) {
          return shuffled;
        }
        shuffled = shuffle();
        return shuffled;
      }

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
      function lookup(index) {
        const alphabetShuffled = getShuffled();
        return alphabetShuffled[index];
      }

      function get () {
        return alphabet || ORIGINAL;
      }

      module.exports = {
        get: get,
        characters: characters,
        seed: setSeed,
        lookup: lookup,
        shuffled: getShuffled
      };


/***/ }),

/***/ "./node_modules/shortid/lib/build.js":
/*!*******************************************!*\
  !*** ./node_modules/shortid/lib/build.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const generate = __webpack_require__(/*! ./generate */ "./node_modules/shortid/lib/generate.js");
      const alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
      const REDUCE_TIME = 1567752802062;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
      const version = 7;

// Counter is used when shortid is called multiple times in one second.
      let counter;

// Remember the last time shortid was called in case counter is needed.
      let previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
      function build(clusterWorkerId) {
        let str = '';

        const seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

        if (seconds === previousSeconds) {
          counter++;
        } else {
          counter = 0;
          previousSeconds = seconds;
        }

        str = str + generate(version);
        str = str + generate(clusterWorkerId);
        if (counter > 0) {
          str = str + generate(counter);
        }
        str = str + generate(seconds);
        return str;
      }

      module.exports = build;


/***/ }),

/***/ "./node_modules/shortid/lib/generate.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/generate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");
      const random = __webpack_require__(/*! ./random/random-byte */ "./node_modules/shortid/lib/random/random-byte-browser.js");
      const customRandom = (__webpack_require__(/*! nanoid */ "./node_modules/nanoid/index.browser.js").customRandom);

      function generate(number) {
        let loopCounter = 0;
        let done;

        let str = '';

        while (!done) {
          str = str + customRandom(alphabet.get(), 1, random)();
          done = number < (Math.pow(16, loopCounter + 1 ) );
          loopCounter++;
        }
        return str;
      }

      module.exports = generate;


/***/ }),

/***/ "./node_modules/shortid/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/shortid/lib/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");
      const build = __webpack_require__(/*! ./build */ "./node_modules/shortid/lib/build.js");
      const isValid = __webpack_require__(/*! ./is-valid */ "./node_modules/shortid/lib/is-valid.js");

// if you are using cluster or multiple servers use this to make each instance
// has a unique value for worker
// Note: I don't know if this is automatically set when using third
// party cluster solutions such as pm2.
      let clusterWorkerId = __webpack_require__(/*! ./util/cluster-worker-id */ "./node_modules/shortid/lib/util/cluster-worker-id-browser.js") || 0;

/**
 * Set the seed.
 * Highly recommended if you don't want people to try to figure out your id schema.
 * exposed as shortid.seed(int)
 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
 */
      function seed(seedValue) {
        alphabet.seed(seedValue);
        return module.exports;
      }

/**
 * Set the cluster worker or machine id
 * exposed as shortid.worker(int)
 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
 * returns shortid module so it can be chained.
 */
      function worker(workerId) {
        clusterWorkerId = workerId;
        return module.exports;
      }

/**
 *
 * sets new characters to use in the alphabet
 * returns the shuffled alphabet
 */
      function characters(newCharacters) {
        if (newCharacters !== undefined) {
          alphabet.characters(newCharacters);
        }

        return alphabet.shuffled();
      }

/**
 * Generate unique id
 * Returns string id
 */
      function generate() {
        return build(clusterWorkerId);
      }

// Export all other functions as properties of the generate function
      module.exports = generate;
      module.exports.generate = generate;
      module.exports.seed = seed;
      module.exports.worker = worker;
      module.exports.characters = characters;
      module.exports.isValid = isValid;


/***/ }),

/***/ "./node_modules/shortid/lib/is-valid.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/is-valid.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";

      const alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");

      function isShortId(id) {
        if (!id || typeof id !== 'string' || id.length < 6 ) {
          return false;
        }

        const nonAlphabetic = new RegExp('[^' +
      alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&') +
    ']');
        return !nonAlphabetic.test(id);
      }

      module.exports = isShortId;


/***/ }),

/***/ "./node_modules/shortid/lib/random/random-byte-browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/shortid/lib/random/random-byte-browser.js ***!
  \****************************************************************/
/***/ ((module) => {

      "use strict";


      const crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

      let randomByte;

      if (!crypto || !crypto.getRandomValues) {
        randomByte = function(size) {
          const bytes = [];
          for (let i = 0; i < size; i++) {
            bytes.push(Math.floor(Math.random() * 256));
          }
          return bytes;
        };
      } else {
        randomByte = function(size) {
          return crypto.getRandomValues(new Uint8Array(size));
        };
      }

      module.exports = randomByte;


/***/ }),

/***/ "./node_modules/shortid/lib/random/random-from-seed.js":
/*!*************************************************************!*\
  !*** ./node_modules/shortid/lib/random/random-from-seed.js ***!
  \*************************************************************/
/***/ ((module) => {

      "use strict";


// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

      let seed = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
      function getNextValue() {
        seed = (seed * 9301 + 49297) % 233280;
        return seed/(233280.0);
      }

      function setSeed(_seed_) {
        seed = _seed_;
      }

      module.exports = {
        nextValue: getNextValue,
        seed: setSeed
      };


/***/ }),

/***/ "./node_modules/shortid/lib/util/cluster-worker-id-browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/shortid/lib/util/cluster-worker-id-browser.js ***!
  \********************************************************************/
/***/ ((module) => {

      "use strict";


      module.exports = 0;


/***/ }),

/***/ "./node_modules/tmp/lib/tmp.js":
/*!*************************************!*\
  !*** ./node_modules/tmp/lib/tmp.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */

/*
 * Module dependencies.
 */
      const fs = __webpack_require__(/*! fs */ "fs");
      const os = __webpack_require__(/*! os */ "os");
      const path = __webpack_require__(/*! path */ "path");
      const crypto = __webpack_require__(/*! crypto */ "crypto");
      const _c = { fs: fs.constants, os: os.constants };

/*
 * The working inner variables.
 */
      const // the random characters to choose from
        RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
        TEMPLATE_PATTERN = /XXXXXX/,
        DEFAULT_TRIES = 3,
        CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),
  // constants are off on the windows platform and will not match the actual errno codes
        IS_WIN32 = os.platform() === 'win32',
        EBADF = _c.EBADF || _c.os.errno.EBADF,
        ENOENT = _c.ENOENT || _c.os.errno.ENOENT,
        DIR_MODE = 0o700 /* 448 */,
        FILE_MODE = 0o600 /* 384 */,
        EXIT = 'exit',
  // this will hold the objects need to be removed on exit
        _removeObjects = [],
  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback
        FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);

      let _gracefulCleanup = false;

/**
 * Recursively remove a directory and its contents.
 *
 * @param {string} dirPath path of directory to remove
 * @param {Function} callback
 * @private
 */
      function rimraf(dirPath, callback) {
        return fs.rm(dirPath, { recursive: true }, callback);
      }

/**
 * Recursively remove a directory and its contents, synchronously.
 *
 * @param {string} dirPath path of directory to remove
 * @private
 */
      function FN_RIMRAF_SYNC(dirPath) {
        return fs.rmSync(dirPath, { recursive: true });
      }

/**
 * Gets a temporary file name.
 *
 * @param {(Options|tmpNameCallback)} options options or callback
 * @param {?tmpNameCallback} callback the callback function
 */
      function tmpName(options, callback) {
        const args = _parseArguments(options, callback),
          opts = args[0],
          cb = args[1];

        _assertAndSanitizeOptions(opts, function (err, sanitizedOptions) {
          if (err) return cb(err);

          let tries = sanitizedOptions.tries;
          (function _getUniqueName() {
            try {
              const name = _generateTmpName(sanitizedOptions);

        // check whether the path exists then retry if needed
              fs.stat(name, function (err) {
          /* istanbul ignore else */
                if (!err) {
            /* istanbul ignore else */
                  if (tries-- > 0) return _getUniqueName();

                  return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));
                }

                cb(null, name);
              });
            } catch (err) {
              cb(err);
            }
          })();
        });
      }

/**
 * Synchronous version of tmpName.
 *
 * @param {Object} options
 * @returns {string} the generated random name
 * @throws {Error} if the options are invalid or could not generate a filename
 */
      function tmpNameSync(options) {
        const args = _parseArguments(options),
          opts = args[0];

        const sanitizedOptions = _assertAndSanitizeOptionsSync(opts);

        let tries = sanitizedOptions.tries;
        do {
          const name = _generateTmpName(sanitizedOptions);
          try {
            fs.statSync(name);
          } catch (e) {
            return name;
          }
        } while (tries-- > 0);

        throw new Error('Could not get a unique tmp filename, max tries reached');
      }

/**
 * Creates and opens a temporary file.
 *
 * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined
 * @param {?fileCallback} callback
 */
      function file(options, callback) {
        const args = _parseArguments(options, callback),
          opts = args[0],
          cb = args[1];

  // gets a temporary filename
        tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
          if (err) return cb(err);

    // create and open the file
          fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
      /* istanbu ignore else */
            if (err) return cb(err);

            if (opts.discardDescriptor) {
              return fs.close(fd, function _discardCallback(possibleErr) {
          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only
                return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));
              });
            } else {
        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care
        // about the descriptor
              const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
              cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
            }
          });
        });
      }

/**
 * Synchronous version of file.
 *
 * @param {Options} options
 * @returns {FileSyncObject} object consists of name, fd and removeCallback
 * @throws {Error} if cannot create a file
 */
      function fileSync(options) {
        const args = _parseArguments(options),
          opts = args[0];

        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
        const name = tmpNameSync(opts);
        let fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
  /* istanbul ignore else */
        if (opts.discardDescriptor) {
          fs.closeSync(fd);
          fd = undefined;
        }

        return {
          name: name,
          fd: fd,
          removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
        };
      }

/**
 * Creates a temporary directory.
 *
 * @param {(Options|dirCallback)} options the options or the callback function
 * @param {?dirCallback} callback
 */
      function dir(options, callback) {
        const args = _parseArguments(options, callback),
          opts = args[0],
          cb = args[1];

  // gets a temporary filename
        tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
          if (err) return cb(err);

    // create the directory
          fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
      /* istanbul ignore else */
            if (err) return cb(err);

            cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
          });
        });
      }

/**
 * Synchronous version of dir.
 *
 * @param {Options} options
 * @returns {DirSyncObject} object consists of name and removeCallback
 * @throws {Error} if it cannot create a directory
 */
      function dirSync(options) {
        const args = _parseArguments(options),
          opts = args[0];

        const name = tmpNameSync(opts);
        fs.mkdirSync(name, opts.mode || DIR_MODE);

        return {
          name: name,
          removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
        };
      }

/**
 * Removes files asynchronously.
 *
 * @param {Object} fdPath
 * @param {Function} next
 * @private
 */
      function _removeFileAsync(fdPath, next) {
        const _handler = function (err) {
          if (err && !_isENOENT(err)) {
      // reraise any unanticipated error
            return next(err);
          }
          next();
        };

        if (0 <= fdPath[0])
          fs.close(fdPath[0], function () {
            fs.unlink(fdPath[1], _handler);
          });
        else fs.unlink(fdPath[1], _handler);
      }

/**
 * Removes files synchronously.
 *
 * @param {Object} fdPath
 * @private
 */
      function _removeFileSync(fdPath) {
        let rethrownException = null;
        try {
          if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);
        } catch (e) {
    // reraise any unanticipated error
          if (!_isEBADF(e) && !_isENOENT(e)) throw e;
        } finally {
          try {
            fs.unlinkSync(fdPath[1]);
          } catch (e) {
      // reraise any unanticipated error
            if (!_isENOENT(e)) rethrownException = e;
          }
        }
        if (rethrownException !== null) {
          throw rethrownException;
        }
      }

/**
 * Prepares the callback for removal of the temporary file.
 *
 * Returns either a sync callback or a async callback depending on whether
 * fileSync or file was called, which is expressed by the sync parameter.
 *
 * @param {string} name the path of the file
 * @param {number} fd file descriptor
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {fileCallback | fileCallbackSync}
 * @private
 */
      function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {
        const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);
        const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);

        if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

        return sync ? removeCallbackSync : removeCallback;
      }

/**
 * Prepares the callback for removal of the temporary directory.
 *
 * Returns either a sync callback or a async callback depending on whether
 * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.
 *
 * @param {string} name
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {Function} the callback
 * @private
 */
      function _prepareTmpDirRemoveCallback(name, opts, sync) {
        const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);
        const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
        const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);
        const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);
        if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

        return sync ? removeCallbackSync : removeCallback;
      }

/**
 * Creates a guarded function wrapping the removeFunction call.
 *
 * The cleanup callback is save to be called multiple times.
 * Subsequent invocations will be ignored.
 *
 * @param {Function} removeFunction
 * @param {string} fileOrDirName
 * @param {boolean} sync
 * @param {cleanupCallbackSync?} cleanupCallbackSync
 * @returns {cleanupCallback | cleanupCallbackSync}
 * @private
 */
      function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {
        let called = false;

  // if sync is true, the next parameter will be ignored
        return function _cleanupCallback(next) {
    /* istanbul ignore else */
          if (!called) {
      // remove cleanupCallback from cache
            const toRemove = cleanupCallbackSync || _cleanupCallback;
            const index = _removeObjects.indexOf(toRemove);
      /* istanbul ignore else */
            if (index >= 0) _removeObjects.splice(index, 1);

            called = true;
            if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
              return removeFunction(fileOrDirName);
            } else {
              return removeFunction(fileOrDirName, next || function () {});
            }
          }
        };
      }

/**
 * The garbage collector.
 *
 * @private
 */
      function _garbageCollector() {
  /* istanbul ignore else */
        if (!_gracefulCleanup) return;

  // the function being called removes itself from _removeObjects,
  // loop until _removeObjects is empty
        while (_removeObjects.length) {
          try {
            _removeObjects[0]();
          } catch (e) {
      // already removed?
          }
        }
      }

/**
 * Random name generator based on crypto.
 * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
 *
 * @param {number} howMany
 * @returns {string} the generated random name
 * @private
 */
      function _randomChars(howMany) {
        let value = [],
          rnd = null;

  // make sure that we do not fail because we ran out of entropy
        try {
          rnd = crypto.randomBytes(howMany);
        } catch (e) {
          rnd = crypto.pseudoRandomBytes(howMany);
        }

        for (let i = 0; i < howMany; i++) {
          value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
        }

        return value.join('');
      }

/**
 * Checks whether the `obj` parameter is defined or not.
 *
 * @param {Object} obj
 * @returns {boolean} true if the object is undefined
 * @private
 */
      function _isUndefined(obj) {
        return typeof obj === 'undefined';
      }

/**
 * Parses the function arguments.
 *
 * This function helps to have optional arguments.
 *
 * @param {(Options|null|undefined|Function)} options
 * @param {?Function} callback
 * @returns {Array} parsed arguments
 * @private
 */
      function _parseArguments(options, callback) {
  /* istanbul ignore else */
        if (typeof options === 'function') {
          return [{}, options];
        }

  /* istanbul ignore else */
        if (_isUndefined(options)) {
          return [{}, callback];
        }

  // copy options so we do not leak the changes we make internally
        const actualOptions = {};
        for (const key of Object.getOwnPropertyNames(options)) {
          actualOptions[key] = options[key];
        }

        return [actualOptions, callback];
      }

/**
 * Resolve the specified path name in respect to tmpDir.
 *
 * The specified name might include relative path components, e.g. ../
 * so we need to resolve in order to be sure that is is located inside tmpDir
 *
 * @private
 */
      function _resolvePath(name, tmpDir, cb) {
        const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);

        fs.stat(pathToResolve, function (err) {
          if (err) {
            fs.realpath(path.dirname(pathToResolve), function (err, parentDir) {
              if (err) return cb(err);

              cb(null, path.join(parentDir, path.basename(pathToResolve)));
            });
          } else {
            fs.realpath(pathToResolve, cb);
          }
        });
      }

/**
 * Resolve the specified path name in respect to tmpDir.
 *
 * The specified name might include relative path components, e.g. ../
 * so we need to resolve in order to be sure that is is located inside tmpDir
 *
 * @private
 */
      function _resolvePathSync(name, tmpDir) {
        const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);

        try {
          fs.statSync(pathToResolve);
          return fs.realpathSync(pathToResolve);
        } catch (_err) {
          const parentDir = fs.realpathSync(path.dirname(pathToResolve));

          return path.join(parentDir, path.basename(pathToResolve));
        }
      }

/**
 * Generates a new temporary name.
 *
 * @param {Object} opts
 * @returns {string} the new random name according to opts
 * @private
 */
      function _generateTmpName(opts) {
        const tmpDir = opts.tmpdir;

  /* istanbul ignore else */
        if (!_isUndefined(opts.name)) {
          return path.join(tmpDir, opts.dir, opts.name);
        }

  /* istanbul ignore else */
        if (!_isUndefined(opts.template)) {
          return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));
        }

  // prefix and postfix
        const name = [
          opts.prefix ? opts.prefix : 'tmp',
          '-',
          process.pid,
          '-',
          _randomChars(12),
          opts.postfix ? '-' + opts.postfix : ''
        ].join('');

        return path.join(tmpDir, opts.dir, name);
      }

/**
 * Asserts and sanitizes the basic options.
 *
 * @private
 */
      function _assertOptionsBase(options) {
        if (!_isUndefined(options.name)) {
          const name = options.name;

    // assert that name is not absolute and does not contain a path
          if (path.isAbsolute(name)) throw new Error(`name option must not contain an absolute path, found "${name}".`);

    // must not fail on valid .<name> or ..<name> or similar such constructs
          const basename = path.basename(name);
          if (basename === '..' || basename === '.' || basename !== name)
            throw new Error(`name option must not contain a path, found "${name}".`);
        }

  /* istanbul ignore else */
        if (!_isUndefined(options.template) && !options.template.match(TEMPLATE_PATTERN)) {
          throw new Error(`Invalid template, found "${options.template}".`);
        }

  /* istanbul ignore else */
        if ((!_isUndefined(options.tries) && isNaN(options.tries)) || options.tries < 0) {
          throw new Error(`Invalid tries, found "${options.tries}".`);
        }

  // if a name was specified we will try once
        options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
        options.keep = !!options.keep;
        options.detachDescriptor = !!options.detachDescriptor;
        options.discardDescriptor = !!options.discardDescriptor;
        options.unsafeCleanup = !!options.unsafeCleanup;

  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to
        options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;
        options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;
      }

/**
 * Gets the relative directory to tmpDir.
 *
 * @private
 */
      function _getRelativePath(option, name, tmpDir, cb) {
        if (_isUndefined(name)) return cb(null);

        _resolvePath(name, tmpDir, function (err, resolvedPath) {
          if (err) return cb(err);

          const relativePath = path.relative(tmpDir, resolvedPath);

          if (!resolvedPath.startsWith(tmpDir)) {
            return cb(new Error(`${option} option must be relative to "${tmpDir}", found "${relativePath}".`));
          }

          cb(null, relativePath);
        });
      }

/**
 * Gets the relative path to tmpDir.
 *
 * @private
 */
      function _getRelativePathSync(option, name, tmpDir) {
        if (_isUndefined(name)) return;

        const resolvedPath = _resolvePathSync(name, tmpDir);
        const relativePath = path.relative(tmpDir, resolvedPath);

        if (!resolvedPath.startsWith(tmpDir)) {
          throw new Error(`${option} option must be relative to "${tmpDir}", found "${relativePath}".`);
        }

        return relativePath;
      }

/**
 * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
 * options.
 *
 * @private
 */
      function _assertAndSanitizeOptions(options, cb) {
        _getTmpDir(options, function (err, tmpDir) {
          if (err) return cb(err);

          options.tmpdir = tmpDir;

          try {
            _assertOptionsBase(options, tmpDir);
          } catch (err) {
            return cb(err);
          }

    // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to
          _getRelativePath('dir', options.dir, tmpDir, function (err, dir) {
            if (err) return cb(err);

            options.dir = _isUndefined(dir) ? '' : dir;

      // sanitize further if template is relative to options.dir
            _getRelativePath('template', options.template, tmpDir, function (err, template) {
              if (err) return cb(err);

              options.template = template;

              cb(null, options);
            });
          });
        });
      }

/**
 * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
 * options.
 *
 * @private
 */
      function _assertAndSanitizeOptionsSync(options) {
        const tmpDir = (options.tmpdir = _getTmpDirSync(options));

        _assertOptionsBase(options, tmpDir);

        const dir = _getRelativePathSync('dir', options.dir, tmpDir);
        options.dir = _isUndefined(dir) ? '' : dir;

        options.template = _getRelativePathSync('template', options.template, tmpDir);

        return options;
      }

/**
 * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
      function _isEBADF(error) {
        return _isExpectedError(error, -EBADF, 'EBADF');
      }

/**
 * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
      function _isENOENT(error) {
        return _isExpectedError(error, -ENOENT, 'ENOENT');
      }

/**
 * Helper to determine whether the expected error code matches the actual code and errno,
 * which will differ between the supported node versions.
 *
 * - Node >= 7.0:
 *   error.code {string}
 *   error.errno {number} any numerical value will be negated
 *
 * CAVEAT
 *
 * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT
 * is no different here.
 *
 * @param {SystemError} error
 * @param {number} errno
 * @param {string} code
 * @private
 */
      function _isExpectedError(error, errno, code) {
        return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;
      }

/**
 * Sets the graceful cleanup.
 *
 * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the
 * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary
 * object removals.
 */
      function setGracefulCleanup() {
        _gracefulCleanup = true;
      }

/**
 * Returns the currently configured tmp dir from os.tmpdir().
 *
 * @private
 */
      function _getTmpDir(options, cb) {
        return fs.realpath((options && options.tmpdir) || os.tmpdir(), cb);
      }

/**
 * Returns the currently configured tmp dir from os.tmpdir().
 *
 * @private
 */
      function _getTmpDirSync(options) {
        return fs.realpathSync((options && options.tmpdir) || os.tmpdir());
      }

// Install process exit listener
      process.addListener(EXIT, _garbageCollector);

/**
 * Configuration options.
 *
 * @typedef {Object} Options
 * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected
 * @property {?number} tries the number of tries before give up the name generation
 * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files
 * @property {?string} template the "mkstemp" like filename template
 * @property {?string} name fixed name relative to tmpdir or the specified dir option
 * @property {?string} dir tmp directory relative to the root tmp directory in use
 * @property {?string} prefix prefix for the generated name
 * @property {?string} postfix postfix for the generated name
 * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir
 * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty
 * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection
 * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection
 */

/**
 * @typedef {Object} FileSyncObject
 * @property {string} name the name of the file
 * @property {string} fd the file descriptor or -1 if the fd has been discarded
 * @property {fileCallback} removeCallback the callback function to remove the file
 */

/**
 * @typedef {Object} DirSyncObject
 * @property {string} name the name of the directory
 * @property {fileCallback} removeCallback the callback function to remove the directory
 */

/**
 * @callback tmpNameCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 */

/**
 * @callback fileCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback fileCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * @callback dirCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback dirCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallback
 * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallbackSync
 */

/**
 * Callback function for function composition.
 * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
 *
 * @callback simpleCallback
 */

// exporting all the needed methods

// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will
// allow users to reconfigure the temporary directory
      Object.defineProperty(module.exports, "tmpdir", ({
        enumerable: true,
        configurable: false,
        get: function () {
          return _getTmpDirSync();
        }
      }));

      module.exports.dir = dir;
      module.exports.dirSync = dirSync;

      module.exports.file = file;
      module.exports.fileSync = fileSync;

      module.exports.tmpName = tmpName;
      module.exports.tmpNameSync = tmpNameSync;

      module.exports.setGracefulCleanup = setGracefulCleanup;


/***/ }),

/***/ "./src/actions/persistent.ts":
/*!***********************************!*\
  !*** ./src/actions/persistent.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.clearPendingVote = exports.setPendingVote = exports.updateSuccessRate = exports.updateRevisionInfo = exports.updateCollectionInfo = void 0;
      const redux_act_1 = __webpack_require__(/*! redux-act */ "redux-act");
      exports.updateCollectionInfo = (0, redux_act_1.createAction)('UPDATE_COLLECTION_INFO', (collectionId, collectionInfo, timestamp) => ({ collectionId, collectionInfo, timestamp }));
      exports.updateRevisionInfo = (0, redux_act_1.createAction)('UPDATE_REVISION_INFO', (revisionId, revisionInfo, timestamp) => ({ revisionId, revisionInfo, timestamp }));
      exports.updateSuccessRate = (0, redux_act_1.createAction)('UPDATE_COLLECTION_HEALTH_RATE', (revisionId, vote, average, total) => ({ revisionId, vote, average, total }));
      exports.setPendingVote = (0, redux_act_1.createAction)('SET_REVISION_PENDING_VOTE', (revisionId, collectionSlug, revisionNumber, time) => ({ revisionId, collectionSlug, revisionNumber, time }));
      exports.clearPendingVote = (0, redux_act_1.createAction)('CLEAR_REVISION_PENDING_VOTE', (revisionId) => ({ revisionId }));


/***/ }),

/***/ "./src/actions/session.ts":
/*!********************************!*\
  !*** ./src/actions/session.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.healthDownvoteDialog = exports.startAddModsToCollection = exports.startEditCollection = void 0;
      const redux_act_1 = __webpack_require__(/*! redux-act */ "redux-act");
      exports.startEditCollection = (0, redux_act_1.createAction)('START_EDIT_COLLECTION', (modId) => ({ modId }));
      exports.startAddModsToCollection = (0, redux_act_1.createAction)('START_ADD_MODS_TO_COLLECTION', (collectionId) => ({ collectionId }));
      exports.healthDownvoteDialog = (0, redux_act_1.createAction)('HEALTH_DOWNVOTE_DIALOG', (collectionModId) => ({ collectionModId }));


/***/ }),

/***/ "./src/actions/settings.ts":
/*!*********************************!*\
  !*** ./src/actions/settings.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.setSortWorkshop = exports.setSortAdded = void 0;
      const redux_act_1 = __webpack_require__(/*! redux-act */ "redux-act");
      exports.setSortAdded = (0, redux_act_1.createAction)('SORT_COLLECTION_ADDED', (sorting) => ({ sorting }));
      exports.setSortWorkshop = (0, redux_act_1.createAction)('SORT_COLLECTION_WORKSHOP', (sorting) => ({ sorting }));


/***/ }),

/***/ "./src/collectionCreate.ts":
/*!*********************************!*\
  !*** ./src/collectionCreate.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.removeCollectionAction = exports.addCollectionAction = exports.alreadyIncluded = exports.removeCollectionCondition = exports.addCollectionCondition = exports.initFromProfile = void 0;
      const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
      const transformCollection_1 = __webpack_require__(/*! ./util/transformCollection */ "./src/util/transformCollection.ts");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const util_1 = __webpack_require__(/*! ./util/util */ "./src/util/util.ts");
      async function initFromProfile(api, profileId) {
        let _a, _b;
        try {
          let forcedName;
          const isQuickCollection = profileId === undefined;
          if (isQuickCollection && vortex_api_1.selectors.activeProfile(api.getState()) === undefined) {
            throw new vortex_api_1.util.ProcessCanceled('No active profile');
          }
          else if (isQuickCollection) {
            profileId = vortex_api_1.selectors.activeProfile(api.getState()).id;
            await (0, transformCollection_1.showQuickCollectionRestrictionsDialog)(api);
            forcedName = `My mods: ${new Date().toLocaleDateString('en-GB', {
              day: '2-digit',
              month: 'short',
              year: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
            })}`;
          }
          const { id, name, updated, wantsToUpload } = await (0, transformCollection_1.createCollectionFromProfile)(api, profileId, forcedName);
          if (isQuickCollection) {
            const state = api.getState();
            const activeGameId = vortex_api_1.selectors.activeGameId(state);
            const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', activeGameId], {});
            const hasRules = ((_b = (_a = mods[id]) === null || _a === void 0 ? void 0 : _a.rules) !== null && _b !== void 0 ? _b : []).length > 0;
            if (!hasRules) {
              await api.showDialog('error', 'Collection is empty', {
                text: 'The generated quick collection is empty. Please ensure the Nexus Mods sourced mods you want to include are '
                        + 'enabled and deployed.',
              }, [
                { label: 'Close' },
              ]);
              return;
            }
          }
          api.store.dispatch(vortex_api_1.actions.setModEnabled(profileId, id, true));
          if (wantsToUpload) {
            await (0, util_1.uploadCollection)(api, profileId, id);
          }
          api.sendNotification({
            type: 'success',
            id: 'collection-created',
            title: updated ? 'Collection updated' : 'Collection created',
            message: name,
            displayMS: vortex_api_1.util.calcDuration(name.length + 20),
            actions: [
              {
                title: 'Edit',
                action: dismiss => {
                  api.events.emit('edit-collection', id);
                  dismiss();
                },
              },
            ],
          });
        }
        catch (err) {
          if (!(err instanceof vortex_api_1.util.UserCanceled)) {
            throw err;
          }
        }
      }
      exports.initFromProfile = initFromProfile;
      const collections = (mods) => {
        const isWorkshopCollection = mod => {
          let _a;
          return (mod.type === constants_1.MOD_TYPE)
            && (((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.editable) === true);
        };
        return Object.values(mods)
          .filter(isWorkshopCollection)
          .map(coll => { let _a; return new Set(((_a = coll.rules) !== null && _a !== void 0 ? _a : []).map(rule => rule.reference.id)); });
      };
      function addCollectionCondition(api, instanceIds) {
        const state = api.getState();
        const gameId = vortex_api_1.selectors.activeGameId(state);
        const mods = state.persistent.mods[gameId];
        return collections(mods).find(ruleSet => {
          return instanceIds.find(modId => (mods[modId].type !== constants_1.MOD_TYPE) && !ruleSet.has(modId)) !== undefined;
        }) !== undefined;
      }
      exports.addCollectionCondition = addCollectionCondition;
      function removeCollectionCondition(api, instanceIds) {
        const state = api.getState();
        const gameId = vortex_api_1.selectors.activeGameId(state);
        const mods = state.persistent.mods[gameId];
        return collections(mods).find(ruleSet => {
          return instanceIds.find(modId => ruleSet.has(modId)) !== undefined;
        }) !== undefined;
      }
      exports.removeCollectionCondition = removeCollectionCondition;
      function alreadyIncluded(rules, modId) {
        let _a;
        return ((_a = rules === null || rules === void 0 ? void 0 : rules.find) === null || _a === void 0 ? void 0 : _a.call(rules, rule => rule.reference.id === modId)) !== undefined;
      }
      exports.alreadyIncluded = alreadyIncluded;
      function addCollectionAction(api, instanceIdsIn) {
        const state = api.getState();
        const gameId = vortex_api_1.selectors.activeGameId(state);
        const mods = state.persistent.mods[gameId];
        const instanceIds = instanceIdsIn.filter(modId => mods[modId] !== undefined);
        const filtered = instanceIds.filter(modId => (mods[modId].type !== constants_1.MOD_TYPE));
        const collections = Object.keys(mods)
          .filter(collectionId => {
            let _a, _b;
            if ((mods[collectionId].type !== constants_1.MOD_TYPE)
            || (((_a = mods[collectionId].attributes) === null || _a === void 0 ? void 0 : _a.editable) !== true)) {
              return false;
            }
            const rules = (_b = mods[collectionId].rules) !== null && _b !== void 0 ? _b : [];
            return filtered.find(modId => !alreadyIncluded(rules, modId)) !== undefined;
          });
        const sortAlphabetically = (modIds) => {
          const temp = [...modIds];
          temp.sort((a, b) => {
            const modA = vortex_api_1.util.renderModName(mods[a]).toLowerCase();
            const modB = vortex_api_1.util.renderModName(mods[b]).toLowerCase();
            return modA.localeCompare(modB);
          });
          return temp;
        };
        return api.showDialog('question', 'Add Mods to Collection', {
          text: 'Choose which collection you want the selected mods to be added',
          message: sortAlphabetically(filtered).map(modId => vortex_api_1.util.renderModName(mods[modId], { version: true, variant: true })).join('\n'),
          choices: sortAlphabetically(collections).map((modId, idx) => ({
            id: modId,
            text: vortex_api_1.util.renderModName(mods[modId]),
            value: idx === 0,
          })),
        }, [
          { label: 'Cancel' },
          { label: 'Add' },
        ])
          .then((result) => {
            let _a;
            if (result.action === 'Add') {
              const collectionId = Object.keys(result.input).find(target => result.input[target]);
              if (mods[collectionId] === undefined) {
                return;
              }
              const rules = (_a = mods[collectionId].rules) !== null && _a !== void 0 ? _a : [];
              vortex_api_1.util.batchDispatch(api.store, filtered.reduce((prev, modId) => {
                if (!alreadyIncluded(rules, modId) && (mods[modId].type !== constants_1.MOD_TYPE)) {
                  prev.push(vortex_api_1.actions.addModRule(gameId, collectionId, {
                    type: 'requires',
                    reference: {
                      id: modId,
                    },
                  }));
                }
                return prev;
              }, []));
            }
          });
      }
      exports.addCollectionAction = addCollectionAction;
      function removeCollectionAction(api, instanceIds) {
        const state = api.getState();
        const gameId = vortex_api_1.selectors.activeGameId(state);
        const mods = state.persistent.mods[gameId];
        const collections = Object.keys(mods)
          .filter(collectionId => {
            let _a, _b;
            if ((mods[collectionId].type !== constants_1.MOD_TYPE)
            || (((_a = mods[collectionId].attributes) === null || _a === void 0 ? void 0 : _a.editable) !== true)) {
              return false;
            }
            const rules = (_b = mods[collectionId].rules) !== null && _b !== void 0 ? _b : [];
            return instanceIds.find(modId => alreadyIncluded(rules, modId)) !== undefined;
          });
        return api.showDialog('question', 'Remove Mods from Collection', {
          text: 'Please select the (modifiable) collection to remove the mods from',
          message: instanceIds.map(modId => vortex_api_1.util.renderModName(mods[modId])).join('\n'),
          choices: collections.map((modId, idx) => ({
            id: modId,
            text: vortex_api_1.util.renderModName(mods[modId]),
            value: idx === 0,
          })),
        }, [
          { label: 'Cancel' },
          { label: 'Remove' },
        ])
          .then((result) => {
            let _a;
            if (result.action === 'Remove') {
              const collectionId = Object.keys(result.input).find(target => result.input[target]);
              const rules = (_a = mods[collectionId].rules) !== null && _a !== void 0 ? _a : [];
              vortex_api_1.util.batchDispatch(api.store, instanceIds.reduce((prev, modId) => {
                const ruleToRemove = rules.find(rule => rule.reference.id === modId);
                if (ruleToRemove !== undefined) {
                  prev.push(vortex_api_1.actions.removeModRule(gameId, collectionId, ruleToRemove));
                }
                return prev;
              }, []));
            }
          });
      }
      exports.removeCollectionAction = removeCollectionAction;


/***/ }),

/***/ "./src/collectionExport.ts":
/*!*********************************!*\
  !*** ./src/collectionExport.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.doExportToFile = exports.doExportToAPI = void 0;
      const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
      const transformCollection_1 = __webpack_require__(/*! ./util/transformCollection */ "./src/util/transformCollection.ts");
      const util_1 = __webpack_require__(/*! ./util/util */ "./src/util/util.ts");
      const PromiseBB = __webpack_require__(/*! bluebird */ "bluebird");
      const _ = __webpack_require__(/*! lodash */ "lodash");
      const Zip = __webpack_require__(/*! node-7z */ "node-7z");
      const path = __webpack_require__(/*! path */ "path");
      const tmp_1 = __webpack_require__(/*! tmp */ "./node_modules/tmp/lib/tmp.js");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      async function withTmpDir(cb) {
        return new Promise((resolve, reject) => {
          (0, tmp_1.dir)((err, tmpPath, cleanup) => {
            if (err !== null) {
              return reject(err);
            }
            else {
              cb(tmpPath)
                .then(() => {
                  resolve();
                })
                .catch(tmpErr => {
                  reject(tmpErr);
                })
                .finally(() => {
                  try {
                    cleanup();
                  }
                  catch (err) {
                    (0, vortex_api_1.log)('warn', 'Failed to clean up temp file', { path, err });
                  }
                });
            }
          });
        });
      }
      async function zip(zipPath, sourcePath) {
        const zipper = new Zip();
        const files = await vortex_api_1.fs.readdirAsync(sourcePath);
        await zipper.add(zipPath, files.map(fileName => path.join(sourcePath, fileName)));
      }
      async function generateCollectionInfo(api, gameId, collection, progress, error) {
        const state = api.getState();
        const mods = state.persistent.mods[gameId];
        const stagingPath = vortex_api_1.selectors.installPath(state);
        return (0, transformCollection_1.modToCollection)(api, gameId, stagingPath, collection, mods, progress, error);
      }
      async function writeCollectionToFile(state, info, mod, outputPath) {
        let _a, _b, _c;
        await vortex_api_1.fs.ensureDirWritableAsync(outputPath, () => PromiseBB.resolve());
        await vortex_api_1.fs.writeFileAsync(path.join(outputPath, 'collection.json'), JSON.stringify(info, undefined, 2));
        const stagingPath = vortex_api_1.selectors.installPath(state);
        const modPath = path.join(stagingPath, mod.installationPath);
        try {
          const tweaks = (_a = mod.enabledINITweaks) !== null && _a !== void 0 ? _a : [];
          for (const tweak of tweaks) {
            await vortex_api_1.fs.copyAsync(path.join(modPath, 'INI Tweaks', tweak), path.join(outputPath, 'INI Tweaks', tweak));
          }
        }
        catch (err) {
          if (err.code !== 'ENOENT') {
            throw err;
          }
        }
        await vortex_api_1.fs.copyAsync(path.join(modPath, constants_1.BUNDLED_PATH), path.join(outputPath, constants_1.BUNDLED_PATH));
        await vortex_api_1.fs.copyAsync(path.join(modPath, constants_1.PATCHES_PATH), path.join(outputPath, constants_1.PATCHES_PATH));
        const zipPath = path.join(modPath, 'export', `collection_${(_c = (_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.version) !== null && _c !== void 0 ? _c : '0'}.7z`);
        try {
          await vortex_api_1.fs.removeAsync(zipPath);
        }
        catch (err) {
          if (err.code !== 'ENOENT') {
            throw err;
          }
        }
        await zip(zipPath, outputPath);
        await vortex_api_1.fs.removeAsync(outputPath);
        return zipPath;
      }
      function filterInfoModSource(source) {
        return _.omit(source, ['instructions', 'fileSize', 'tag']);
      }
      function filterInfoMod(mod) {
        const res = _.omit(mod, ['hashes', 'choices', 'patches', 'details', 'instructions', 'phase', 'fileOverrides']);
        res.source = filterInfoModSource(res.source);
        return res;
      }
      function filterInfo(input) {
        const info = _.omit(input.info, ['installInstructions']);
        return {
          info,
          mods: input.mods.map(mod => filterInfoMod(mod)),
        };
      }
      async function queryErrorsContinue(api, errors) {
        const res = await api.showDialog('error', 'Errors creating collection', {
          text: 'There were errors creating the collection, do you want to proceed anyway?',
          message: errors.map(err => api.translate(err.message, { replace: err.replace })).join('\n'),
        }, [
          { label: 'Cancel' },
          { label: 'Continue' },
        ]);
        if (res.action === 'Cancel') {
          throw new vortex_api_1.util.UserCanceled();
        }
      }
      function renderGraphLocateError(api, gameId, modId, det) {
        let _a, _b, _c;
        const t = api.translate;
        const state = api.getState();
        const mods = state.persistent.mods[gameId];
        switch (det.attribute) {
          case 'modId': {
            const missingMod = Object.values(mods).find(iter => { let _a, _b, _c; return ((_c = (_b = (_a = iter.attributes) === null || _a === void 0 ? void 0 : _a.modId) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) === det.value.toString(); });
            if (missingMod !== undefined) {
              return t('Mod not found on nexusmods.com: {{modName}} (modId: {{modId}}), '
                    + 'it may have been removed.', { replace: {
                modName: vortex_api_1.util.renderModName(missingMod),
                modId: det.value,
              } });
            }
            else {
              return t('Mod with id {{modId}} not found', { replace: { modId: det.value } });
            }
          }
          case 'fileId': {
            const missingMod = Object.values(mods).find(iter => { let _a, _b, _c; return ((_c = (_b = (_a = iter.attributes) === null || _a === void 0 ? void 0 : _a.fileId) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) === det.value.toString(); });
            if (missingMod !== undefined) {
              return t('Mod not found on nexusmods.com: {{modName}} '
                    + '(modId: {{modId}}, fileId: {{fileId}}), '
                    + 'it may have been removed.', { replace: {
                modName: vortex_api_1.util.renderModName(missingMod, { version: true }),
                modId: (_b = (_a = missingMod.attributes) === null || _a === void 0 ? void 0 : _a.modId) !== null && _b !== void 0 ? _b : 'Unknown',
                fileId: (_c = missingMod.attributes) === null || _c === void 0 ? void 0 : _c.fileId,
              } });
            }
            else {
              return t('Mod with file id {{fileId}} not found', { replace: { fileId: det.value } });
            }
          }
          default: {
            return det.message;
          }
        }
      }
      function renderGraphErrorFallback(message, det) {
        return det.message || message;
      }
      function renderGraphErrorDetail(api, gameId, modId, message, det) {
        if ((det.type === 'LOCATE_ERROR') && !!det.value) {
          return renderGraphLocateError(api, gameId, modId, det);
        }
        else {
          return renderGraphErrorFallback(message, det);
        }
      }
      async function doExportToAPI(api, gameId, modId, uploaderName) {
        let _a;
        const state = api.store.getState();
        const mod = state.persistent.mods[gameId][modId];
        const { progress, progressEnd } = (0, util_1.makeProgressFunction)(api);
        const errors = [];
        let mayIgnore = true;
        const onError = (message, replace, allowIgnore) => {
          errors.push({ message, replace });
          mayIgnore && (mayIgnore = allowIgnore);
        };
        let info;
        let collectionId;
        let collectionSlug;
        let revisionNumber;
        try {
          info = await generateCollectionInfo(api, gameId, mod, progress, onError);
          if (errors.length > 0) {
            if (mayIgnore) {
              await queryErrorsContinue(api, errors);
            }
            else {
              throw new vortex_api_1.util.UserCanceled();
            }
          }
          await withTmpDir(async (tmpPath) => {
            let _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const filePath = await writeCollectionToFile(state, info, mod, tmpPath);
            collectionId = (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.collectionId) !== null && _b !== void 0 ? _b : undefined;
            const modUploader = (_d = (_c = mod.attributes) === null || _c === void 0 ? void 0 : _c.uploader) !== null && _d !== void 0 ? _d : (_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.author;
            if ((collectionId !== undefined) && (modUploader !== uploaderName)) {
              (0, vortex_api_1.log)('info', 'user doesn\'t match original author, creating new collection');
              collectionId = undefined;
            }
            const result = await vortex_api_1.util.toPromise(cb => api.events.emit('submit-collection', filterInfo(info), filePath, collectionId, cb));
            collectionId = result.collection.id;
            collectionSlug = result.collection.slug;
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'collectionId', collectionId));
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'collectionSlug', result.collection.slug));
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'source', 'nexus'));
            const revisionId = (_g = (_f = result.revision) === null || _f === void 0 ? void 0 : _f.id) !== null && _g !== void 0 ? _g : result['revisionId'];
            revisionNumber = (_j = (_h = result.revision) === null || _h === void 0 ? void 0 : _h.revisionNumber) !== null && _j !== void 0 ? _j : result['revisionNumber'];
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'revisionId', revisionId));
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'revisionNumber', revisionNumber));
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'version', ((revisionNumber !== null && revisionNumber !== void 0 ? revisionNumber : 0) + 1).toString()));
          });
          progressEnd();
        }
        catch (err) {
          progressEnd();
          if (err.name === 'ModFileNotFound') {
            const file = info.mods.find(iter => iter.source.fileId === err.fileId);
            api.sendNotification({
              type: 'error',
              title: 'The server can\'t find one of the files in the collection, '
                    + 'are mod id and file id for it set correctly?',
              message: file !== undefined ? file.name : `id: ${err.fileId}`,
            });
            throw new vortex_api_1.util.ProcessCanceled('Mod file not found');
          }
          else if (err.constructor.name === 'ParameterInvalid') {
            api.sendNotification({
              type: 'error',
              title: 'The server rejected this collection',
              message: err.message || '<No reason given>',
            });
            throw new vortex_api_1.util.ProcessCanceled('collection rejected');
          }
          else if (err.constructor.name === 'GraphError') {
            const message = err.message;
            const details = (_a = err['details']) !== null && _a !== void 0 ? _a : [];
            api.sendNotification({
              type: 'error',
              message: 'The server rejected this collection',
              actions: [
                { title: 'More', action: () => {
                  api.showDialog('error', 'The server rejected this collection', {
                    text: details.length === 0 ? message : details.map(detail => renderGraphErrorDetail(api, gameId, modId, message, detail)).join('\n'),
                  }, [
                    { label: 'Close' },
                  ]);
                } },
              ],
            });
            throw new vortex_api_1.util.ProcessCanceled('collection rejected');
          }
          else if (err instanceof vortex_api_1.util.ProcessCanceled) {
            api.showErrorNotification('Failed to upload collection', err, { allowReport: false });
          }
          else {
            throw err;
          }
        }
        return { slug: collectionSlug, revisionNumber };
      }
      exports.doExportToAPI = doExportToAPI;
      async function doExportToFile(api, gameId, modId) {
        const state = api.store.getState();
        const mod = state.persistent.mods[gameId][modId];
        const { progress, progressEnd } = (0, util_1.makeProgressFunction)(api);
        const errors = [];
        const onError = (message, replace) => {
          errors.push({ message, replace });
        };
        try {
          const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
          const modPath = path.join(stagingPath, mod.installationPath);
          const outputPath = path.join(modPath, 'build');
          const info = await generateCollectionInfo(api, gameId, mod, progress, onError);
          const zipPath = await writeCollectionToFile(state, info, mod, outputPath);
          const dialogActions = [
            {
              title: 'Open', action: () => {
                vortex_api_1.util.opn(path.join(stagingPath, mod.installationPath, 'export')).catch(() => null);
              },
            },
          ];
          if (errors.length > 0) {
            const li = (input) => `[*]${input}`;
            dialogActions.unshift({
              title: 'Errors',
              action: () => {
                api.showDialog('error', 'Collection Export Errors', {
                  bbcode: '[list]'
                            + errors.map(err => li(api.translate(err.message, { replace: err.replace })))
                            + '[/list]',
                }, [
                  { label: 'Close' },
                ]);
              },
            });
          }
          api.sendNotification({
            id: 'collection-exported',
            title: errors.length > 0 ? 'Collection exported, there were errors' : 'Collection exported',
            message: zipPath,
            type: errors.length > 0 ? 'warning' : 'success',
            actions: dialogActions,
          });
        }
        catch (err) {
          api.showErrorNotification('Failed to export collection', err);
        }
        progressEnd();
      }
      exports.doExportToFile = doExportToFile;


/***/ }),

/***/ "./src/collectionInstall.ts":
/*!**********************************!*\
  !*** ./src/collectionInstall.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.postprocessCollection = exports.makeInstall = exports.testSupported = void 0;
      const extension_1 = __webpack_require__(/*! ./util/extension */ "./src/util/extension.ts");
      const gameSupport_1 = __webpack_require__(/*! ./util/gameSupport */ "./src/util/gameSupport/index.ts");
      const transformCollection_1 = __webpack_require__(/*! ./util/transformCollection */ "./src/util/transformCollection.ts");
      const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
      const _ = __webpack_require__(/*! lodash */ "lodash");
      const path = __webpack_require__(/*! path */ "path");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const importCollection_1 = __webpack_require__(/*! ./util/importCollection */ "./src/util/importCollection.ts");
      const collectionConfig_1 = __webpack_require__(/*! ./util/collectionConfig */ "./src/util/collectionConfig/index.ts");
      async function testSupported(files, gameId) {
        return {
          supported: files.indexOf('collection.json') !== -1,
          requiredFiles: ['collection.json'],
        };
      }
      exports.testSupported = testSupported;
      function makeInstall(api) {
        return async (files, destinationPath, gameId, progressDelegate) => {
          let _a;
          const collection = await (0, importCollection_1.readCollection)(api, path.join(destinationPath, 'collection.json'));
          const config = await (0, collectionConfig_1.parseConfig)({ collection, gameId });
          const configInstructions = Object.entries(config).reduce((accum, [key, value]) => {
            const instr = { type: 'attribute', key, value, };
            accum.push(instr);
            return accum;
          }, []);
          const filesToCopy = files
            .filter(filePath => !filePath.endsWith(path.sep)
            && (filePath.split(path.sep)[0] !== constants_1.BUNDLED_PATH));
          const bundled = files
            .filter(filePath => !filePath.endsWith(path.sep)
            && (filePath.split(path.sep)[0] === constants_1.BUNDLED_PATH));
          const knownGames = vortex_api_1.selectors.knownGames(api.getState());
          const state = api.getState();
          const downloads = Object.values(state.persistent.downloads.files).reverse();
          const collectionDownload = downloads.find(down => (down.localPath !== undefined)
            && (path.basename(destinationPath, '.installing')
                === path.basename(down.localPath, path.extname(down.localPath))));
          return Promise.resolve({
            instructions: [
              {
                type: 'attribute',
                key: 'customFileName',
                value: (((_a = collectionDownload === null || collectionDownload === void 0 ? void 0 : collectionDownload.modInfo) === null || _a === void 0 ? void 0 : _a.name) !== undefined)
                  ? collectionDownload.modInfo.name
                  : collection.info.name,
              },
              {
                type: 'attribute',
                key: 'installInstructions',
                value: collection.info.installInstructions,
              },
              ...configInstructions,
              {
                type: 'setmodtype',
                value: constants_1.MOD_TYPE,
              },
              ...filesToCopy.map(filePath => ({
                type: 'copy',
                source: filePath,
                destination: filePath,
              })),
              ...bundled.map(filePath => ({
                type: 'copy',
                source: filePath,
                destination: filePath,
              })),
              ...collection.mods.map(mod => ({
                type: 'rule',
                rule: (0, transformCollection_1.collectionModToRule)(knownGames, mod),
              })),
            ],
          });
        };
      }
      exports.makeInstall = makeInstall;
      function applyCollectionRules(api, gameId, collection, mods) {
        let _a;
        const batch = ((_a = collection.modRules) !== null && _a !== void 0 ? _a : []).reduce((prev, rule) => {
          let _a, _b;
          const sourceMod = vortex_api_1.util.findModByRef(rule.source, mods);
          if (sourceMod !== undefined) {
            const destMod = vortex_api_1.util.findModByRef(rule.reference, mods);
            let exists = false;
            if (destMod !== undefined) {
              const exSourceRules = ((_a = sourceMod.rules) !== null && _a !== void 0 ? _a : []).filter(iter => ['before', 'after'].includes(iter.type)
                    && vortex_api_1.util.testModReference(destMod, iter.reference));
              exSourceRules.forEach(exSourceRule => {
                const copy = JSON.parse(JSON.stringify(exSourceRule));
                delete copy.reference.idHint;
                if (!exists && _.isEqual(copy, rule)) {
                  exists = true;
                }
                else {
                  prev.push(vortex_api_1.actions.removeModRule(gameId, sourceMod.id, exSourceRule));
                }
              });
              const exDestRules = ((_b = destMod.rules) !== null && _b !== void 0 ? _b : []).filter(iter => ['before', 'after'].includes(iter.type)
                    && vortex_api_1.util.testModReference(sourceMod, iter.reference));
              exDestRules.forEach(exDestRule => {
                prev.push(vortex_api_1.actions.removeModRule(gameId, destMod.id, exDestRule));
              });
              rule.reference = {
                id: destMod.id,
                idHint: destMod.id,
                archiveId: destMod.archiveId,
              };
            }
            if (!exists) {
              (0, vortex_api_1.log)('info', 'add collection rule', { gameId, sourceMod: sourceMod.id, rule: JSON.stringify(rule) });
              prev.push(vortex_api_1.actions.addModRule(gameId, sourceMod.id, rule));
            }
          }
          return prev;
        }, []);
        vortex_api_1.util.batchDispatch(api.store, batch);
      }
      async function postprocessCollection(api, gameId, collectionMod, collection, mods) {
        (0, vortex_api_1.log)('info', 'postprocess collection');
        applyCollectionRules(api, gameId, collection, mods);
        try {
          await vortex_api_1.util.toPromise(cb => api.events.emit('deploy-mods', cb));
        }
        catch (err) {
          (0, vortex_api_1.log)('warn', 'Failed to deploy during collection post processing');
        }
        const exts = (0, extension_1.findExtensions)(api.getState(), gameId);
        for (const ext of exts) {
          await ext.parse(gameId, collection, collectionMod);
        }
        await (0, gameSupport_1.parseGameSpecifics)(api, gameId, collection, collectionMod);
      }
      exports.postprocessCollection = postprocessCollection;


/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.INSTRUCTIONS_PLACEHOLDER = exports.DEFAULT_INSTRUCTIONS = exports.CACHE_LRU_COUNT = exports.CACHE_EXPIRE_MS = exports.PATCH_OVERHEAD = exports.MAX_PATCH_SIZE = exports.DELAY_FIRST_VOTE_REQUEST = exports.TIME_BEFORE_VOTE = exports.OPTIONAL_TWEAK_PREFIX = exports.INI_TWEAKS_PATH = exports.MAX_COLLECTION_NAME_LENGTH = exports.MIN_COLLECTION_NAME_LENGTH = exports.INSTALLING_NOTIFICATION_ID = exports.PATCHES_PATH = exports.BUNDLED_PATH = exports.ADULT_CONTENT_URL = exports.TOS_URL = exports.PREMIUM_PATH = exports.NEXUS_PROTOCOL = exports.NEXUS_BASE_GAMES_URL = exports.NEXUS_NEXT_URL = exports.NEXUS_BASE_URL = exports.NEXUS_NEXT_SUBDOMAIN = exports.NEXUS_FLAMEWORK_SUBDOMAIN = exports.NEXUS_DOMAIN = exports.AVATAR_FALLBACK = exports.AUTHOR_UNKNOWN = exports.NAMESPACE = exports.MOD_TYPE = void 0;
      exports.MOD_TYPE = 'collection';
      exports.NAMESPACE = 'collection';
      exports.AUTHOR_UNKNOWN = '<Unknown User>';
      exports.AVATAR_FALLBACK = 'assets/images/noavatar.png';
      exports.NEXUS_DOMAIN = process.env['NEXUS_DOMAIN'] || 'nexusmods.com';
      exports.NEXUS_FLAMEWORK_SUBDOMAIN = process.env['FLAMEWORK_SUBDOMAIN'] || 'www';
      exports.NEXUS_NEXT_SUBDOMAIN = process.env['NEXT_SUBDOMAIN'] || 'next';
      exports.NEXUS_BASE_URL = process.env['NEXUS_BASE_URL'] || `https://${exports.NEXUS_FLAMEWORK_SUBDOMAIN}.${exports.NEXUS_DOMAIN}`;
      exports.NEXUS_NEXT_URL = process.env['NEXUS_NEXT_URL'] || `https://${exports.NEXUS_DOMAIN}/games`;
      exports.NEXUS_BASE_GAMES_URL = process.env['NEXUS_BASE_GAMES_URL'] || `https://${exports.NEXUS_FLAMEWORK_SUBDOMAIN}.${exports.NEXUS_DOMAIN}/games`;
      exports.NEXUS_PROTOCOL = 'https:';
      exports.PREMIUM_PATH = ['account', 'billing', 'premium'];
      exports.TOS_URL = 'https://help.nexusmods.com/article/115-guidelines-for-collections';
      exports.ADULT_CONTENT_URL = 'https://help.nexusmods.com/article/19-adult-content-guidelines';
      exports.BUNDLED_PATH = 'bundled';
      exports.PATCHES_PATH = 'patches';
      exports.INSTALLING_NOTIFICATION_ID = 'installing-collection-';
      exports.MIN_COLLECTION_NAME_LENGTH = 3;
      exports.MAX_COLLECTION_NAME_LENGTH = 36;
      exports.INI_TWEAKS_PATH = 'Ini Tweaks';
      exports.OPTIONAL_TWEAK_PREFIX = '(optional).';
      exports.TIME_BEFORE_VOTE = 48 * 60 * 60 * 1000;
      exports.DELAY_FIRST_VOTE_REQUEST = 1 * 60 * 1000;
      exports.MAX_PATCH_SIZE = 0.2;
      exports.PATCH_OVERHEAD = 130;
      exports.CACHE_EXPIRE_MS = 1 * 60 * 60 * 1000;
      exports.CACHE_LRU_COUNT = 50;
      exports.DEFAULT_INSTRUCTIONS = 'No additional instructions.';
      exports.INSTRUCTIONS_PLACEHOLDER = 'Enter instructions here (Markdown supported - Links, Bold, Italics)';


/***/ }),

/***/ "./src/eventHandlers.ts":
/*!******************************!*\
  !*** ./src/eventHandlers.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.onCollectionUpdate = void 0;
      const Bluebird = __webpack_require__(/*! bluebird */ "bluebird");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const InstallChangelogDialog_1 = __webpack_require__(/*! ./views/InstallDialog/InstallChangelogDialog */ "./src/views/InstallDialog/InstallChangelogDialog.tsx");
      async function collectionUpdate(api, downloadGameId, collectionSlug, revisionNumber, oldModId) {
        let _a, _b, _c;
        try {
          const latest = (await api.emitAndAwait('get-nexus-collection-revision', collectionSlug, parseInt(revisionNumber, 10)))[0];
          if (latest === undefined) {
            throw new vortex_api_1.util.ProcessCanceled(`Server returned no info on collection ${collectionSlug}, revision ${revisionNumber}`);
          }
          const collection = latest.collection;
          if (collectionSlug !== collection.slug) {
            throw new Error(`Invalid collection "${collectionSlug}"`);
          }
          const state = api.getState();
          const gameMode = vortex_api_1.selectors.activeGameId(state);
          const oldMod = state.persistent.mods[gameMode][oldModId];
          if (!!((_a = latest.collectionChangelog) === null || _a === void 0 ? void 0 : _a.description) && (oldMod !== undefined)) {
            await (0, InstallChangelogDialog_1.default)(oldMod, gameMode, latest);
          }
          const modInfo = {
            game: downloadGameId,
            source: 'nexus',
            name: collection === null || collection === void 0 ? void 0 : collection.name,
            nexus: {
              ids: {
                gameId: downloadGameId,
                collectionId: collection.id,
                collectionSlug,
                revisionId: latest.id,
                revisionNumber: latest.revisionNumber,
              },
              revisionInfo: latest,
            },
          };
          const downloadURLs = (await api.emitAndAwait('resolve-collection-url', latest.downloadLink))[0];
          let dlId;
          try {
            const fileName = vortex_api_1.util.sanitizeFilename(collection.name);
            dlId = await vortex_api_1.util.toPromise(cb => api.events.emit('start-download', downloadURLs.map(iter => iter.URI), modInfo, fileName + `-rev${latest.revisionNumber}.7z`, cb, 'never', { allowInstall: false }));
          }
          catch (err) {
            if (err.name === 'AlreadyDownloaded') {
              const { files } = api.getState().persistent.downloads;
              dlId = Object.keys(files).find(iter => files[iter].localPath === err.fileName);
            }
            if (dlId === undefined) {
              throw err;
            }
          }
          api.events.emit('analytics-track-click-event', 'Collections', 'Update Collection');
          const oldRules = (_b = oldMod === null || oldMod === void 0 ? void 0 : oldMod.rules) !== null && _b !== void 0 ? _b : [];
          const newModId = await vortex_api_1.util.toPromise(cb => api.events.emit('start-install-download', dlId, undefined, cb));
          const mods = api.getState().persistent.mods[gameMode];
          if (mods[newModId] === undefined) {
            throw new vortex_api_1.util.ProcessCanceled('Download failed, update archive not found');
          }
          const candidates = oldRules
            .filter(rule => ['requires', 'recommends'].includes(rule.type))
            .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
            .filter(mod => {
              let _a;
              return (mod !== undefined)
                && (((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a['installedAsDependency']) === true);
            });
          const notCandidates = Object.values(mods)
            .filter(mod => !candidates.includes(mod) && ![oldModId, newModId].includes(mod.id));
          const references = (rules, mod) => (rules !== null && rules !== void 0 ? rules : []).find(rule => ['requires', 'recommends'].includes(rule.type)
            && vortex_api_1.util.testModReference(mod, rule.reference)) !== undefined;
          const obsolete = candidates
            .filter(mod => !references(mods[newModId].rules, mod))
            .filter(mod => notCandidates
              .find(other => references(other.rules, mod)) === undefined);
          let ops = { remove: [], keep: [] };
          if (obsolete.length > 0) {
            const collectionName = (_c = collection === null || collection === void 0 ? void 0 : collection.name) !== null && _c !== void 0 ? _c : vortex_api_1.util.renderModName(oldMod);
            const result = await api.showDialog('question', 'Remove mods from old revision?', {
              text: 'There are {{count}} mods installed that are not present in the latest '
                    + 'revision of "{{collectionName}}". It is recommended that you remove the '
                    + 'unused mods to avoid compatibility issues going forward. '
                    + 'If you choose to keep the mods installed they will no longer be associated '
                    + 'with this Collection and will be managed as if they have been installed '
                    + 'individually. Would you like to remove the old mods now?',
              parameters: {
                count: obsolete.length,
                collectionName,
              },
            }, [
              { label: 'Keep All' },
              { label: 'Review Mods' },
              { label: 'Remove All' },
            ]);
            if (result.action === 'Keep All') {
              ops.keep = obsolete.map(mod => mod.id);
            }
            else if (result.action === 'Remove All') {
              ops.remove = obsolete.map(mod => mod.id);
            }
            else {
              const reviewResult = await api.showDialog('question', 'Remove mods from old revision?', {
                text: 'The following mods are not present in the latest revision of '
                        + '"{{collectionName}}". Please select the ones to remove.',
                parameters: {
                  collectionName,
                },
                checkboxes: obsolete.map(mod => ({ id: mod.id, text: vortex_api_1.util.renderModName(mod), value: true })),
              }, [
                { label: 'Keep All' },
                { label: 'Remove selected' },
              ]);
              if (reviewResult.action === 'Keep All') {
                ops.keep = obsolete.map(mod => mod.id);
              }
              else {
                ops = Object.keys(reviewResult.input).reduce((prev, value) => {
                  if (reviewResult.input[value]) {
                    prev.remove.push(value);
                  }
                  else {
                    prev.keep.push(value);
                  }
                  return prev;
                }, { remove: [], keep: [] });
              }
            }
          }
          vortex_api_1.util.batchDispatch(api.store, ops.keep.map(modId => vortex_api_1.actions.setModAttribute(gameMode, modId, 'installedAsDependency', false)));
          await vortex_api_1.util.toPromise(cb => api.events.emit('remove-mods', gameMode, [oldModId, ...ops.remove], cb, { incomplete: true, ignoreInstalling: true }));
        }
        catch (err) {
          if (!(err instanceof vortex_api_1.util.UserCanceled)) {
            api.showErrorNotification('Failed to download collection', err, {
              allowReport: !(err instanceof vortex_api_1.util.ProcessCanceled),
              warning: err instanceof vortex_api_1.util.ProcessCanceled,
            });
          }
        }
      }
      function onCollectionUpdate(api, driver) {
        return (gameId, collectionSlug, revisionNumber, source, oldModId, cb) => {
          if ((source !== 'nexus') || (collectionSlug === undefined) || (revisionNumber === undefined)) {
            return;
          }
          driver.prepare(() => Bluebird.resolve(collectionUpdate(api, gameId, collectionSlug, revisionNumber.toString(), oldModId))
            .then(() => {
              cb === null || cb === void 0 ? void 0 : cb(null);
            })
            .catch(err => {
              if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                api.showErrorNotification('Failed to update collection', err);
              }
              cb === null || cb === void 0 ? void 0 : cb(err);
            }));
        };
      }
      exports.onCollectionUpdate = onCollectionUpdate;


/***/ }),

/***/ "./src/initweaks.ts":
/*!**************************!*\
  !*** ./src/initweaks.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.importTweaks = exports.getEnabledTweaks = void 0;
      const path = __webpack_require__(/*! path */ "path");
      const React = __webpack_require__(/*! react */ "react");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const IniTweaks_1 = __webpack_require__(/*! ./views/IniTweaks */ "./src/views/IniTweaks.tsx");
      const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
      const gameSupport = {
        skyrim: {
          gameSettingsFiles: ['Skyrim.ini', 'SkyrimPrefs.ini'],
        },
        skyrimse: {
          gameSettingsFiles: ['Skyrim.ini', 'SkyrimPrefs.ini', 'SkyrimCustom.ini'],
        },
        skyrimvr: {
          gameSettingsFiles: ['Skyrim.ini', 'SkyrimPrefs.ini'],
        },
        fallout3: {
          gameSettingsFiles: ['Fallout.ini', 'FalloutPrefs.ini', 'FalloutCustom.ini'],
        },
        fallout4: {
          gameSettingsFiles: ['Fallout4.ini', 'Fallout4Prefs.ini', 'Fallout4Custom.ini'],
        },
        fallout4vr: {
          gameSettingsFiles: ['Fallout4Custom.ini', 'Fallout4Prefs.ini'],
        },
        falloutnv: {
          gameSettingsFiles: ['Fallout.ini', 'FalloutPrefs.ini'],
        },
        starfield: {
          gameSettingsFiles: ['StarfieldCustom.ini', 'StarfieldPrefs.ini'],
        },
        oblivion: {
          gameSettingsFiles: ['Oblivion.ini'],
        },
        enderal: {
          gameSettingsFiles: ['Enderal.ini', 'EnderalPrefs.ini'],
        },
        enderalspecialedition: {
          gameSettingsFiles: ['Enderal.ini', 'EnderalPrefs.ini'],
        },
      };
      function isSupported(gameId) {
        return gameSupport[gameId] !== undefined;
      }
      function validateFilenameInput(content) {
        const input = content.input[0].value || '';
        if ((input.length < 2) || !vortex_api_1.util.isFilenameValid(input)) {
          return [{
            actions: ['Confirm'],
            errorText: 'Has to be a valid file name',
            id: content.input[0].id,
          }];
        }
        else {
          return [];
        }
      }
      function TweakListWrap(api, prop) {
        return React.createElement(IniTweaks_1.default, {
          ...prop,
          settingsFiles: gameSupport[prop.gameId].gameSettingsFiles,
          onRefreshTweaks: genRefreshTweaks,
          onAddIniTweak: (modPath, settingsFiles) => genAddIniTweak(api, modPath, settingsFiles),
          onRemoveIniTweak: (modPath, tweak) => genRemoveIniTweak(api, prop, modPath, tweak),
        });
      }
      async function getTweaks(dirPath) {
        try {
          const tweaks = await vortex_api_1.fs.readdirAsync(dirPath);
          return tweaks;
        }
        catch (err) {
          (0, vortex_api_1.log)('debug', 'failed to find tweaks', err);
          return [];
        }
      }
      function getEnabledTweaks(api, gameId, modId) {
        const state = api.getState();
        const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', gameId], {});
        const tweaks = vortex_api_1.util.getSafe(mods[modId], ['enabledINITweaks'], []);
        return tweaks;
      }
      exports.getEnabledTweaks = getEnabledTweaks;
      async function importTweaks(api, profile, mods, destCollection, force) {
        let _a;
        const tweaks = await getAllTweaks(api, profile, mods);
        const state = api.getState();
        const stagingFolder = vortex_api_1.selectors.installPathForGame(state, profile.gameId);
        const destTweakDirPath = path.join(stagingFolder, destCollection.id, constants_1.INI_TWEAKS_PATH);
        const batchedActions = [];
        const existingTweaks = (_a = destCollection.enabledINITweaks) !== null && _a !== void 0 ? _a : [];
        await vortex_api_1.fs.ensureDirWritableAsync(destTweakDirPath);
        for (const tweak of tweaks) {
          if (force !== true && existingTweaks.includes(tweak.fileName)) {
            continue;
          }
          try {
            const dest = path.join(destTweakDirPath, path.basename(tweak.sourcePath));
            await vortex_api_1.fs.copyAsync(tweak.sourcePath, dest, { overwrite: true });
            batchedActions.push(vortex_api_1.actions.setINITweakEnabled(profile.gameId, destCollection.id, tweak.fileName, true));
          }
          catch (err) {
            (0, vortex_api_1.log)('error', 'Unable to import tweak', err);
            continue;
          }
        }
        if (batchedActions.length > 0) {
          vortex_api_1.util.batchDispatch(api.store, batchedActions);
        }
        return Promise.resolve(tweaks);
      }
      exports.importTweaks = importTweaks;
      async function getAllTweaks(api, profile, mods) {
        const state = api.getState();
        if ((profile === null || profile === void 0 ? void 0 : profile.gameId) === undefined) {
          return Promise.resolve([]);
        }
        const installationPath = vortex_api_1.selectors.installPathForGame(state, profile.gameId);
        const enabledMods = Object.keys(mods)
          .filter(id => vortex_api_1.util.getSafe(profile.modState, [id, 'enabled'], false)
        && (mods[id].installationPath !== undefined));
        const validTweaks = [];
        for (const modId of enabledMods) {
          const modPath = path.join(installationPath, mods[modId].installationPath);
          const tweaks = getEnabledTweaks(api, profile.gameId, modId);
          if (tweaks.length === 0) {
            continue;
          }
          for (const tweak of tweaks) {
            try {
              const tweakPath = path.join(modPath, constants_1.INI_TWEAKS_PATH, tweak);
              await vortex_api_1.fs.statAsync(tweakPath);
              validTweaks.push({
                enabled: true,
                sourcePath: tweakPath,
                fileName: tweak,
              });
            }
            catch (err) {
              continue;
            }
          }
        }
        return Promise.resolve(validTweaks);
      }
      async function removeOptionalPrefix(filePath) {
        try {
          if (filePath.indexOf(constants_1.OPTIONAL_TWEAK_PREFIX) !== -1) {
            const trimmedFilePath = filePath.replace(constants_1.OPTIONAL_TWEAK_PREFIX, '');
            await vortex_api_1.fs.removeAsync(trimmedFilePath).catch(err => null);
            await vortex_api_1.fs.linkAsync(filePath, trimmedFilePath);
            await vortex_api_1.fs.removeAsync(filePath);
            return Promise.resolve(trimmedFilePath);
          }
          else {
            return Promise.resolve(filePath);
          }
        }
        catch (err) {
          (0, vortex_api_1.log)('error', 'failed to remove optional prefix from ini file', { error: err, filePath });
          return Promise.resolve(filePath);
        }
      }
      async function genRefreshTweaks(modPath) {
        const tweakPath = path.join(modPath, constants_1.INI_TWEAKS_PATH);
        const tweaks = await getTweaks(tweakPath);
        return tweaks.reduce(async (accumP, twk) => {
          const accum = await accumP;
          const filePath = await removeOptionalPrefix(path.join(tweakPath, twk));
          accum.push({ fileName: path.basename(filePath) });
          return accum;
        }, Promise.resolve([]));
      }
      async function genRemoveIniTweak(api, props, modPath, tweak) {
        return api.showDialog('question', 'Remove INI Tweak', {
          text: 'You are about to remove an INI tweak "{{fileName}}" from the collection. Are you sure you wish to proceed ?',
          parameters: { fileName: tweak.fileName },
        }, [
          { label: 'Cancel' },
          { label: 'Remove' },
        ]).then(async (res) => {
          if (res.action === 'Remove') {
            try {
              const tweaks = await genRefreshTweaks(modPath);
              const targetTweak = tweaks.find(twk => twk.fileName === tweak.fileName);
              const tweakPath = path.join(modPath, constants_1.INI_TWEAKS_PATH, targetTweak.fileName);
              await vortex_api_1.fs.removeAsync(tweakPath);
              const { gameId, collection } = props;
              api.store.dispatch(vortex_api_1.actions.setINITweakEnabled(gameId, collection.id, targetTweak.fileName, false));
            }
            catch (err) {
              if (err.code === 'ENOENT') {
                const { gameId, collection } = props;
                api.store.dispatch(vortex_api_1.actions.setINITweakEnabled(gameId, collection.id, tweak.fileName, false));
                return;
              }
              api.showErrorNotification('Failed to remove INI tweak', err, { allowReport: ['EPERM'].includes(err.code) });
            }
          }
        });
      }
      async function genAddIniTweak(api, modPath, settingsFiles) {
        return api.showDialog('question', 'Name', {
          text: 'Please enter a name for the ini tweak',
          input: [
            { id: 'name', type: 'text' },
          ],
          choices: settingsFiles.map((fileName, idx) => ({
            text: fileName,
            value: idx === 0,
            id: fileName,
          })),
          condition: validateFilenameInput,
        }, [
          { label: 'Cancel' },
          { label: 'Confirm' },
        ]).then(res => {
          if (res.action === 'Confirm') {
            const tweaksPath = path.join(modPath, constants_1.INI_TWEAKS_PATH);
            let selectedIni = Object.keys(res.input)
              .find(key => (path.extname(key) === '.ini') && res.input[key] === true);
            if (selectedIni === undefined) {
              return Promise.reject(new Error('No ini file selected'));
            }
            selectedIni = path.basename(selectedIni, path.extname(selectedIni));
            const fileName = `${res.input['name']} [${selectedIni}].ini`;
            return vortex_api_1.fs.ensureDirWritableAsync(tweaksPath, () => Promise.resolve())
              .then(() => vortex_api_1.fs.writeFileAsync(path.join(tweaksPath, fileName), ''));
          }
          else {
            return Promise.resolve();
          }
        });
      }
      async function genEnableIniTweaks(api, gameId, mod) {
        const stagingPath = vortex_api_1.selectors.installPathForGame(api.getState(), gameId);
        const modPath = path.join(stagingPath, mod.installationPath);
        try {
          const tweaks = await genRefreshTweaks(modPath);
          const batched = tweaks.map(req => vortex_api_1.actions.setINITweakEnabled(gameId, mod.id, req.fileName, true));
          if (batched.length > 0) {
            vortex_api_1.util.batchDispatch(api.store, batched);
          }
        }
        catch (err) {
          if (err.code !== 'ENOENT') {
            api.showErrorNotification('Failed to enable collection ini tweaks', err);
          }
        }
      }
      function init(context) {
        context.optional.registerCollectionFeature('ini-tweaks', () => Promise.resolve({}), (gameId, collection, mod) => genEnableIniTweaks(context.api, gameId, mod), () => Promise.resolve(), () => 'INI Tweaks', (state, gameId) => isSupported(gameId), (prop) => TweakListWrap(context.api, prop));
      }
      exports["default"] = init;


/***/ }),

/***/ "./src/reducers/persistent.ts":
/*!************************************!*\
  !*** ./src/reducers/persistent.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const actions = __webpack_require__(/*! ../actions/persistent */ "./src/actions/persistent.ts");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const persistentReducer = {
        reducers: {
          [actions.updateCollectionInfo]: (state, payload) => {
            const { collectionId, collectionInfo, timestamp } = payload;
            if (collectionInfo === undefined) {
              return vortex_api_1.util.deleteOrNop(state, ['collections', collectionId]);
            }
            else {
              return vortex_api_1.util.setSafe(state, ['collections', collectionId], { timestamp, info: collectionInfo });
            }
          },
          [actions.updateRevisionInfo]: (state, payload) => {
            const { revisionId, revisionInfo, timestamp } = payload;
            if (revisionInfo === undefined) {
              return vortex_api_1.util.deleteOrNop(state, ['revisions', 'revisionId']);
            }
            else {
              return vortex_api_1.util.setSafe(state, ['revisions', revisionId], { timestamp, info: revisionInfo });
            }
          },
          [actions.updateSuccessRate]: (state, payload) => {
            const { revisionId, vote, average, total } = payload;
            const revPath = ['revisions', revisionId, 'info'];
            state = vortex_api_1.util.setSafe(state, [...revPath, 'metadata', 'ratingValue'], vote);
            return vortex_api_1.util.setSafe(state, [...revPath, 'rating'], {
              average,
              total,
            });
          },
          [actions.setPendingVote]: (state, payload) => {
            const { revisionId, collectionSlug, revisionNumber, time } = payload;
            return vortex_api_1.util.setSafe(state, ['pendingVotes', revisionId], {
              collectionSlug, revisionNumber, time
            });
          },
          [actions.clearPendingVote]: (state, payload) => {
            const { revisionId } = payload;
            return vortex_api_1.util.deleteOrNop(state, ['pendingVotes', revisionId]);
          },
        },
        defaults: {
          collections: {},
          revisions: {},
          pendingVotes: {},
        },
      };
      exports["default"] = persistentReducer;


/***/ }),

/***/ "./src/reducers/session.ts":
/*!*********************************!*\
  !*** ./src/reducers/session.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const actions = __webpack_require__(/*! ../actions/session */ "./src/actions/session.ts");
      const sessionReducer = {
        reducers: {
          [actions.startEditCollection]: (state, payload) => {
            const { modId } = payload;
            return vortex_api_1.util.setSafe(state, ['editCollectionId'], modId);
          },
          [actions.startAddModsToCollection]: (state, payload) => {
            const { collectionId } = payload;
            return vortex_api_1.util.setSafe(state, ['addModsId'], collectionId);
          },
          [actions.healthDownvoteDialog]: (state, payload) => {
            const { collectionModId } = payload;
            return vortex_api_1.util.setSafe(state, ['healthDownvoteDialog'], collectionModId);
          }
        },
        defaults: {
          editCollectionId: undefined,
          addModsId: undefined,
          healthDownvoteDialog: undefined,
        },
      };
      exports["default"] = sessionReducer;


/***/ }),

/***/ "./src/reducers/settings.ts":
/*!**********************************!*\
  !*** ./src/reducers/settings.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const actions = __webpack_require__(/*! ../actions/settings */ "./src/actions/settings.ts");
      const settingsReducer = {
        reducers: {
          [actions.setSortAdded]: (state, payload) => {
            const { sorting } = payload;
            return vortex_api_1.util.setSafe(state, ['sortAdded'], sorting);
          },
          [actions.setSortWorkshop]: (state, payload) => {
            const { sorting } = payload;
            return vortex_api_1.util.setSafe(state, ['sortWorkshop'], sorting);
          },
        },
        defaults: {
          sortAdded: 'datedownloaded',
          sortWorkshop: 'recentlyupdated',
        },
      };
      exports["default"] = settingsReducer;


/***/ }),

/***/ "./src/tools.ts":
/*!**********************!*\
  !*** ./src/tools.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const Tools_1 = __webpack_require__(/*! ./views/Tools */ "./src/views/Tools.tsx");
      const path = __webpack_require__(/*! path */ "path");
      const React = __webpack_require__(/*! react */ "react");
      const shortid_1 = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function ToolsListWrap(prop) {
        return React.createElement(Tools_1.default, {
          ...prop,
        });
      }
      function convertTools(state, gameId, includedTools) {
        const { tools } = state.settings.gameMode.discovered[gameId];
        const discovery = vortex_api_1.selectors.discoveryByGame(state, gameId);
        return vortex_api_1.util.makeUniqueByKey(includedTools !== null && includedTools !== void 0 ? includedTools : [], item => item)
          .filter(toolId => { let _a, _b; return ((_a = tools[toolId]) === null || _a === void 0 ? void 0 : _a.custom) && !((_b = tools[toolId]) === null || _b === void 0 ? void 0 : _b.hidden); })
          .map(toolId => {
            const tool = tools[toolId];
            const exe = vortex_api_1.util.isChildPath(tool.path, discovery.path)
              ? path.relative(discovery.path, tool.path)
              : tool.path;
            return {
              name: tool.name,
              exe,
              args: tool.parameters,
              env: tool.environment,
              cwd: tool.workingDirectory,
              detach: tool.detach,
              shell: tool.shell,
              onStart: tool.onStart,
            };
          });
      }
      function generateTools(api, gameId, mod) {
        let _a, _b;
        return {
          tools: convertTools(api.getState(), gameId, (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.includedTools),
        };
      }
      function normalizePath(input) {
        return path.normalize(input.toUpperCase());
      }
      function isSameTool(discovery, lhs, rhs) {
        if ((lhs === null || lhs === void 0 ? void 0 : lhs.path) === undefined) {
          return false;
        }
        return (normalizePath(lhs.path) === normalizePath(path.resolve(discovery.path, rhs.exe)))
        || (lhs.name === rhs.name);
      }
      function updatePaths(tool, gamePath) {
        return {
          ...tool,
          exe: path.isAbsolute(tool.exe)
            ? tool.exe
            : path.join(gamePath, tool.exe),
        };
      }
      async function cloneTools(api, gameId, tools, from, to) {
        const discovery = vortex_api_1.selectors.discoveryByGame(api.getState(), gameId);
        const knownTools = api.getState().settings.gameMode.discovered[gameId].tools;
        const includedTools = (tools !== null && tools !== void 0 ? tools : []).map(tool => {
          const exePath = path.isAbsolute(tool.exe)
            ? tool.exe
            : path.join(discovery.path, tool.exe);
          return Object.keys(knownTools !== null && knownTools !== void 0 ? knownTools : {})
            .find(iter => (knownTools[iter].custom && !knownTools[iter].hidden)
            && (normalizePath(knownTools[iter].path) === normalizePath(exePath)
                || knownTools[iter].name === tool.name));
        })
          .filter(iter => iter !== undefined);
        const attributes = vortex_api_1.util.setSafe(to.attributes.collection, ['includedTools'], includedTools);
        api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, to.id, 'collection', attributes));
      }
      async function setUpTools(api, gameId, tools) {
        const knownTools = api.getState().settings.gameMode.discovered[gameId].tools;
        const discovery = vortex_api_1.selectors.discoveryByGame(api.getState(), gameId);
        const addTools = (tools !== null && tools !== void 0 ? tools : [])
          .map(tool => updatePaths(tool, discovery.path))
          .filter(tool => Object.values(knownTools !== null && knownTools !== void 0 ? knownTools : {})
            .find(iter => isSameTool(discovery, iter, tool)) === undefined);
        const addActions = addTools.map(tool => {
          tool.id = (0, shortid_1.generate)();
          return vortex_api_1.actions.addDiscoveredTool(gameId, tool.id, {
            id: tool.id,
            path: tool.exe,
            name: tool.name,
            requiredFiles: [],
            executable: null,
            parameters: tool.args,
            environment: tool.env,
            workingDirectory: tool.cwd,
            shell: tool.shell,
            detach: tool.detach,
            onStart: tool.onStart,
            custom: true,
            hidden: true,
          }, true);
        });
        vortex_api_1.util.batchDispatch(api.store, addActions);
        const notFoundTools = [];
        await Promise.all(addTools.map(async (tool) => {
          try {
            await vortex_api_1.fs.statAsync(tool.exe);
          }
          catch (err) {
            notFoundTools.push(tool.name);
          }
          if (path.extname(tool.exe) === '.exe') {
            const iconPath = vortex_api_1.util.StarterInfo.toolIconRW(gameId, tool.id);
            await vortex_api_1.fs.ensureDirWritableAsync(path.dirname(iconPath), () => Promise.resolve());
            try {
              await vortex_api_1.util['extractExeIcon'](tool.exe, iconPath);
            }
            catch (err) {
              (0, vortex_api_1.log)('warn', 'failed to extract exe icon', { executable: tool.exe, error: err.message });
            }
          }
        }));
        if (notFoundTools.length > 0) {
          await api.showDialog('info', 'Tool not found', {
            text: 'The collection you just installed set up tools to be run from the dashboard, '
                + 'however not all were found locally. '
                + 'It\'s possible that these tools will be available after the next deployment '
                + 'completes, otherwise you may have to edit the configuration for the tool to '
                + 'adjust them to your own setup.',
            message: notFoundTools.join('\n'),
          }, [
            { label: 'Continue' },
          ]);
        }
        vortex_api_1.util.batchDispatch(api.store, addTools.map(tool => vortex_api_1.actions.setToolVisible(gameId, tool.id, true)));
      }
      function init(context) {
        context.optional.registerCollectionFeature('tools', (gameId, includedMods, mod) => generateTools(context.api, gameId, mod), (gameId, collection, mod) => setUpTools(context.api, gameId, collection['tools']), (gameId, collection, from, to) => cloneTools(context.api, gameId, collection['tools'], from, to), () => 'Tools', (state, gameId) => true, ToolsListWrap);
      }
      exports["default"] = init;


/***/ }),

/***/ "./src/util/InfoCache.ts":
/*!*******************************!*\
  !*** ./src/util/InfoCache.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const persistent_1 = __webpack_require__(/*! ../actions/persistent */ "./src/actions/persistent.ts");
      const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
      const importCollection_1 = __webpack_require__(/*! ./importCollection */ "./src/util/importCollection.ts");
      const path = __webpack_require__(/*! path */ "path");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      class InfoCache {
        constructor(api) {
          this.mCacheRevRequests = {};
          this.mCacheColRequests = {};
          this.mCacheColRules = {};
          this.mApi = api;
        }
        async getCollectionModRules(revisionId, collection, gameId) {
          const cacheId = revisionId !== null && revisionId !== void 0 ? revisionId : collection.id;
          if (this.mCacheColRules[cacheId] === undefined) {
            this.mCacheColRules[cacheId] = this.cacheCollectionModRules(revisionId, collection, gameId);
          }
          return this.mCacheColRules[cacheId];
        }
        async getCollectionInfo(slug, forceFetch) {
          let _a, _b;
          const { store } = this.mApi;
          if (slug === undefined) {
            return;
          }
          const collections = (_a = store.getState().persistent.collections.collections) !== null && _a !== void 0 ? _a : {};
          if (forceFetch
            || (((_b = collections[slug]) === null || _b === void 0 ? void 0 : _b.timestamp) === undefined)
            || ((Date.now() - collections[slug].timestamp) > constants_1.CACHE_EXPIRE_MS)) {
            if (this.mCacheColRequests[slug] === undefined) {
              this.mCacheColRequests[slug] = this.cacheCollectionInfo(slug);
            }
            return this.mCacheColRequests[slug];
          }
          return collections[slug].info;
        }
        async clearCache() {
          const { store } = this.mApi;
          const state = this.mApi.getState();
          const cutOffTime = Date.now() - constants_1.CACHE_EXPIRE_MS;
          {
            const { collections } = state.persistent.collections;
            const collectionsToDrop = Object.keys(collections)
              .sort((lhs, rhs) => collections[rhs].timestamp - collections[lhs].timestamp)
              .reduce((prev, iter, idx) => {
                if ((idx >= constants_1.CACHE_LRU_COUNT) || (collections[iter].timestamp < cutOffTime)) {
                  prev.push(iter);
                }
                return prev;
              }, []);
            if (collectionsToDrop.length > 0) {
              (0, vortex_api_1.log)('debug', 'dropping outdated collections cache', { ids: collectionsToDrop });
              vortex_api_1.util.batchDispatch(store, collectionsToDrop
                .map(coll => (0, persistent_1.updateCollectionInfo)(coll, undefined, undefined)));
            }
          }
          {
            const { revisions } = state.persistent.collections;
            const revisionsToDrop = Object.keys(revisions)
              .sort((lhs, rhs) => revisions[rhs].timestamp - revisions[lhs].timestamp)
              .reduce((prev, iter, idx) => {
                if ((idx >= constants_1.CACHE_LRU_COUNT) || (revisions[iter].timestamp < cutOffTime)) {
                  prev.push(iter);
                }
                return prev;
              }, []);
            if (revisionsToDrop.length > 0) {
              (0, vortex_api_1.log)('debug', 'dropping outdated revision cache', { ids: revisionsToDrop });
              vortex_api_1.util.batchDispatch(store, revisionsToDrop
                .map(rev => (0, persistent_1.updateRevisionInfo)(rev, undefined, undefined)));
            }
          }
        }
        async getRevisionInfo(revisionId, collectionSlug, revisionNumber, fetchBehavior = 'allow') {
          let _a, _b, _c, _d;
          const { store } = this.mApi;
          const revisions = (_a = store.getState().persistent.collections.revisions) !== null && _a !== void 0 ? _a : {};
          if ((fetchBehavior === 'force')
            || (((_b = revisions[revisionId]) === null || _b === void 0 ? void 0 : _b.timestamp) === undefined)
            || (((Date.now() - revisions[revisionId].timestamp) > constants_1.CACHE_EXPIRE_MS)
                && (fetchBehavior === 'allow'))) {
            this.fetchRevisionInfo(revisions, revisionId, collectionSlug, revisionNumber);
            return this.mCacheRevRequests[revisionId];
          }
          if (!((_d = (_c = revisions[revisionId]) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.collection)) {
            return Promise.resolve(undefined);
          }
          const collectionInfo = await this.getCollectionInfo(revisions[revisionId].info.collection.slug);
          return {
            ...revisions[revisionId].info,
            collection: {
              ...collectionInfo,
            },
          };
        }
        fetchRevisionInfo(revisions, revisionId, collectionSlug, revisionNumber) {
          let _a;
          (0, vortex_api_1.log)('info', 'revision info cache outdated', {
            timestamp: (_a = revisions[revisionId]) === null || _a === void 0 ? void 0 : _a.timestamp,
            now: Date.now(),
          });
          if (this.mCacheRevRequests[revisionId] === undefined) {
            this.mCacheRevRequests[revisionId] =
                this.cacheRevisionInfo(revisionId, collectionSlug, revisionNumber);
          }
        }
        async cacheCollectionModRules(revisionId, collection, gameId) {
          const store = this.mApi.store;
          const state = store.getState();
          const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', gameId], {});
          const colMod = collection !== null && collection !== void 0 ? collection : (Object.values(mods).find(iter => { let _a; return (iter.type === constants_1.MOD_TYPE) && (((_a = iter.attributes) === null || _a === void 0 ? void 0 : _a.revisionId) === revisionId); }));
          if ((colMod === null || colMod === void 0 ? void 0 : colMod.installationPath) === undefined) {
            return [];
          }
          const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
          try {
            const collectionInfo = await (0, importCollection_1.readCollection)(this.mApi, path.join(stagingPath, colMod.installationPath, 'collection.json'));
            return collectionInfo.modRules;
          }
          catch (err) {
            if (err.code !== 'ENOENT') {
              this.mApi.showErrorNotification('Failed to cache collection mod rules', err, {
                allowReport: false,
              });
            }
            return [];
          }
        }
        async cacheCollectionInfo(collectionSlug) {
          const { store } = this.mApi;
          const collectionInfo = (await this.mApi.emitAndAwait('get-nexus-collection', collectionSlug))[0];
          if (!!(collectionInfo === null || collectionInfo === void 0 ? void 0 : collectionInfo.id)) {
            store.dispatch((0, persistent_1.updateCollectionInfo)(collectionInfo.id.toString(), collectionInfo, Date.now()));
            delete this.mCacheColRequests[collectionInfo.id.toString()];
          }
          return collectionInfo;
        }
        updateRevisionCacheState(store, revisionId, revisionInfo, now) {
          store.dispatch((0, persistent_1.updateCollectionInfo)(revisionInfo.collection.id.toString(), revisionInfo.collection, now));
          store.dispatch((0, persistent_1.updateRevisionInfo)(revisionId, {
            ...revisionInfo,
            collection: {
              id: revisionInfo.collection.id,
              slug: revisionInfo.collection.slug,
            },
          }, now));
        }
        async cacheRevisionInfo(revisionId, collectionSlug, revisionNumber) {
          const { store } = this.mApi;
          if ((collectionSlug === undefined) || (revisionNumber === undefined)) {
            const err = new Error('missing collection/revision id');
            err['allowReport'] = false;
            return Promise.reject(err);
          }
          const revisionInfo = (await this.mApi.emitAndAwait('get-nexus-collection-revision', collectionSlug, revisionNumber))[0];
          const now = Date.now();
          if (!!revisionInfo) {
            this.updateRevisionCacheState(store, revisionId, revisionInfo, now);
          }
          else {
            store.dispatch((0, persistent_1.updateRevisionInfo)(revisionId, null, now));
          }
          const result = await revisionInfo;
          delete this.mCacheRevRequests[revisionId];
          return result !== null && result !== void 0 ? result : null;
        }
      }
      exports["default"] = InfoCache;


/***/ }),

/***/ "./src/util/InstallDriver.ts":
/*!***********************************!*\
  !*** ./src/util/InstallDriver.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const Promise = __webpack_require__(/*! bluebird */ "bluebird");
      const path = __webpack_require__(/*! path */ "path");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const persistent_1 = __webpack_require__(/*! ../actions/persistent */ "./src/actions/persistent.ts");
      const collectionInstall_1 = __webpack_require__(/*! ../collectionInstall */ "./src/collectionInstall.ts");
      const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
      const binaryPatching_1 = __webpack_require__(/*! ./binaryPatching */ "./src/util/binaryPatching.ts");
      const importCollection_1 = __webpack_require__(/*! ./importCollection */ "./src/util/importCollection.ts");
      const InfoCache_1 = __webpack_require__(/*! ./InfoCache */ "./src/util/InfoCache.ts");
      const util_1 = __webpack_require__(/*! ./util */ "./src/util/util.ts");
      class InstallDriver {
        get requiredMods() {
          return this.mDependentMods.filter(_ => _.type === 'requires');
        }
        get recommendedMods() {
          return this.mDependentMods.filter(_ => _.type === 'recommends');
        }
        constructor(api) {
          this.mStep = 'prepare';
          this.mUpdateHandlers = [];
          this.mInstalledMods = [];
          this.mDependentMods = [];
          this.mInstallDone = false;
          this.mPrepare = Promise.resolve();
          this.mDebounce = new vortex_api_1.util.Debouncer((collectionSlug, revisionNumber) => {
            this.mApi.events.emit('analytics-track-event-with-payload', 'Collection Installation Failed', {
              collection_slug: collectionSlug,
              collection_revision_number: revisionNumber
            });
            return null;
          }, 1000);
          this.startInstall = async () => {
            let _a, _b;
            (_b = (_a = this.mApi.ext).withSuppressedTests) === null || _b === void 0 ? void 0 : _b.call(_a, ['plugins-changed', 'settings-changed', 'mod-activated', 'mod-installed'], () => new Promise(resolve => {
              this.mOnStop = () => {
                resolve(undefined);
                this.mOnStop = undefined;
              };
            }));
            return this.startImpl();
          };
          this.startImpl = async () => {
            let _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            this.mApi.events.emit('analytics-track-event-with-payload', 'Collection Installation Started', {
              collection_slug: this.collectionSlug,
              collection_revision_number: this.revisionNumber
            });
            if ((((_a = this.mCollection) === null || _a === void 0 ? void 0 : _a.archiveId) === undefined) || (this.mProfile === undefined)) {
              return false;
            }
            this.mInstalledMods = [];
            this.mInstallingMod = undefined;
            this.mInstallDone = false;
            this.mStep = 'start';
            const collection = this.mCollection;
            const profile = this.mProfile;
            const gameId = this.mGameId;
            const state = this.mApi.store.getState();
            const mods = (_b = state.persistent.mods[gameId]) !== null && _b !== void 0 ? _b : {};
            const modInfo = (_c = state.persistent.downloads.files[collection.archiveId]) === null || _c === void 0 ? void 0 : _c.modInfo;
            const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
            const slug = this.collectionSlug;
            const revisionId = this.revisionId;
            if (revisionId !== undefined) {
              try {
                this.mRevisionInfo = (_d = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.revisionInfo) !== null && _d !== void 0 ? _d : await this.mInfoCache.getRevisionInfo(revisionId, slug, this.revisionNumber);
              }
              catch (err) {
                (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                  revisionId, slug, revisionNumber: this.revisionNumber, error: err.message
                });
              }
            }
            const { userInfo } = (_e = state.persistent['nexus']) !== null && _e !== void 0 ? _e : {};
            if (((_h = (_g = (_f = this.mRevisionInfo) === null || _f === void 0 ? void 0 : _f.collection) === null || _g === void 0 ? void 0 : _g.user) === null || _h === void 0 ? void 0 : _h.memberId) !== (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId)) {
              this.mApi.store.dispatch((0, persistent_1.setPendingVote)(revisionId, slug, this.revisionNumber, Date.now()));
            }
            const gameMode = gameId;
            const currentgame = vortex_api_1.util.getGame(gameMode);
            const discovery = vortex_api_1.selectors.discoveryByGame(state, gameMode);
            const gameVersion = await currentgame.getInstalledVersion(discovery);
            const gvMatch = gv => gv.reference === gameVersion;
            const revGameVersions = (_k = (_j = this.mRevisionInfo) === null || _j === void 0 ? void 0 : _j.gameVersions) !== null && _k !== void 0 ? _k : [];
            if (((_l = revGameVersions.length) !== null && _l !== void 0 ? _l : 0 !== 0)
                && (revGameVersions.find(gvMatch) === undefined)) {
              const choice = await this.mApi.showDialog('question', 'Game version mismatch', {
                bbcode: 'The version of the game you have installed is different to the one the curator used when creating this collection.'
                        + '[br][/br][br][/br]'
                        + 'Your game version: [style=dialog-success-text]{{actual}}[/style][br][/br]'
                        + 'Recommended game version: [style=dialog-danger-text]{{intended}}[/style]'
                        + '[br][/br][br][/br]'
                        + 'If you choose to continue, some or all of the mods included in the collection may not work properly for you. This will '
                        + 'require manual troubleshooting to correct. For users who are not familiar with modding, we do not recommend continuing with installation.'
                        + '[br][/br][br][/br]'
                        + 'You can also check the description, comments and bug reports on the Collection page to see if others have been successful'
                        + 'while playing with the game version you have installed or to request advice from the curator.',
                parameters: {
                  actual: gameVersion,
                  intended: revGameVersions.map(gv => gv.reference).join(' or '),
                },
              }, [
                { label: 'Cancel' },
                { label: 'Continue' },
              ]);
              if (choice.action === 'Cancel') {
                this.mInstallDone = true;
                return false;
              }
            }
            this.mApi.events.emit('will-install-collection', gameId, collection.id);
            this.mApi.events.emit('view-collection', collection.id);
            this.updateProgress(profile, gameId, collection);
            this.augmentRules(gameId, collection);
            this.mApi.dismissNotification((0, util_1.getUnfulfilledNotificationId)(collection.id));
            this.mApi.store.dispatch(vortex_api_1.actions.setModEnabled(profile.id, collection.id, true));
            const required = ((_m = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _m !== void 0 ? _m : [])
              .filter(rule => ['requires', 'recommends'].includes(rule.type));
            const dependencies = required
              .reduce((accum, rule) => {
                let _a;
                const modRef = {
                  ...rule.reference,
                  patches: ((_a = rule === null || rule === void 0 ? void 0 : rule.extra) === null || _a === void 0 ? void 0 : _a.patches) ? { ...rule.extra.patches } : undefined,
                  fileList: rule === null || rule === void 0 ? void 0 : rule.fileList,
                };
                const mod = vortex_api_1.util.findModByRef(modRef, mods);
                if (mod === undefined) {
                  accum.push(rule);
                }
                return accum;
              }, []);
            this.mDependentMods = dependencies;
            if (this.requiredMods.length === 0) {
              this.mInstallDone = false;
            }
            (0, vortex_api_1.log)('info', 'starting install of collection', {
              totalMods: required.length,
              missing: this.requiredMods.length,
            });
          };
          this.begin = () => {
            let _a;
            if ((this.mCollection === undefined) || (((_a = this.mProfile) === null || _a === void 0 ? void 0 : _a.id) === undefined)) {
              return;
            }
            this.mApi.events.emit('install-dependencies', this.mProfile.id, this.mGameId, [this.mCollection.id], true);
            this.mStep = 'installing';
          };
          this.closeDisclaimers = () => {
            this.mStep = 'installing';
          };
          this.finishInstalling = () => {
            this.mStep = 'review';
          };
          this.close = () => {
            if ((this.mGameId !== undefined) && (this.mCollection !== undefined)) {
              this.mApi.events.emit('did-install-collection', this.mGameId, this.mCollection.id);
            }
            this.mCollection = undefined;
            this.mInstallDone = true;
            this.triggerUpdate();
          };
          this.mApi = api;
          this.mInfoCache = new InfoCache_1.default(api);
          api.onAsync('will-install-mod', (gameId, archiveId, modId) => {
            const state = api.store.getState();
            const download = state.persistent.downloads.files[archiveId];
            if (download !== undefined) {
              this.mInstallingMod = download.localPath;
            }
            return Promise.resolve();
          });
          api.events.on('did-install-mod', (gameId, archiveId, modId) => {
            let _a, _b, _c, _d;
            const state = api.store.getState();
            const mod = vortex_api_1.util.getSafe(state.persistent.mods, [gameId, modId], undefined);
            const dependent = this.mDependentMods.find(iter => vortex_api_1.util.testModReference(mod, iter.reference));
            if ((mod !== undefined) && (dependent !== undefined)) {
              if (dependent.type === 'requires') {
                this.mInstalledMods.push(mod);
              }
              if ((((_a = this.mCollection) === null || _a === void 0 ? void 0 : _a.installationPath) !== undefined)
                    && (dependent.reference.description !== undefined)) {
                if (dependent.type === 'requires') {
                  this.updateProgress(this.mProfile, this.mGameId, this.mCollection);
                }
                (0, binaryPatching_1.applyPatches)(api, this.mCollection, gameId, dependent.reference.description, modId, (_b = dependent.extra) === null || _b === void 0 ? void 0 : _b.patches);
                vortex_api_1.util.batchDispatch(api.store, [
                  vortex_api_1.actions.setFileOverride(gameId, modId, (_c = dependent.extra) === null || _c === void 0 ? void 0 : _c.fileOverrides),
                  vortex_api_1.actions.setModAttribute(gameId, modId, 'patches', (_d = dependent.extra) === null || _d === void 0 ? void 0 : _d.patches),
                  vortex_api_1.actions.setModAttribute(gameId, modId, 'fileList', dependent.fileList),
                ]);
              }
            }
            this.triggerUpdate();
          });
          api.events.on('did-finish-download', () => {
            this.updateProgress(this.mProfile, this.mGameId, this.mCollection);
          });
          api.events.on('will-install-dependencies', (profileId, modId, recommendations, onCancel) => {
            let _a, _b;
            const state = api.getState();
            const profile = this.profile || vortex_api_1.selectors.profileById(state, profileId);
            const gameId = this.mGameId || (profile === null || profile === void 0 ? void 0 : profile.gameId);
            if (gameId === undefined) {
              return;
            }
            const mods = state.persistent.mods[gameId];
            if ((this.mCollection === undefined)
                && (((_a = mods[modId]) === null || _a === void 0 ? void 0 : _a.type) === constants_1.MOD_TYPE)
                && recommendations) {
              this.mLastCollection = this.mCollection = mods[modId];
              this.mStep = 'installing';
            }
            const isCollectionMod = rule => { let _a; return ((_a = vortex_api_1.util.findModByRef(rule.reference, mods)) === null || _a === void 0 ? void 0 : _a.id) === modId; };
            if ((this.mCollection !== undefined)
                && recommendations
                && ((_b = this.mCollection.rules) !== null && _b !== void 0 ? _b : []).find(isCollectionMod)) {
              onCancel();
            }
          });
          api.events.on('did-install-dependencies', (gameId, modId, recommendations) => {
            this.onDidInstallDependencies(gameId, modId, recommendations);
          });
        }
        async prepare(func) {
          this.mPrepare = this.mPrepare.then(func);
        }
        async query(profile, collection) {
          let _a;
          await this.mPrepare;
          this.mPrepare = Promise.resolve();
          if ((collection === null || collection === void 0 ? void 0 : collection.archiveId) === undefined) {
            return;
          }
          if (!this.mInstallDone && (this.mCollection !== undefined)) {
            this.mApi.sendNotification({
              type: 'warning',
              message: 'Already installing a collection',
            });
            return;
          }
          this.mProfile = profile;
          this.mLastCollection = this.mCollection = collection;
          this.mGameId = (_a = profile === null || profile === void 0 ? void 0 : profile.gameId) !== null && _a !== void 0 ? _a : vortex_api_1.selectors.activeGameId(this.mApi.getState());
          this.mStep = 'query';
          await this.initCollectionInfo();
          this.triggerUpdate();
        }
        async start(profile, collection) {
          let _a;
          await this.mPrepare;
          this.mPrepare = Promise.resolve();
          if ((collection === null || collection === void 0 ? void 0 : collection.archiveId) === undefined) {
            return;
          }
          if (!this.mInstallDone && (this.mCollection !== undefined)) {
            this.mApi.sendNotification({
              type: 'warning',
              message: 'Already installing a collection',
              displayMS: 5000,
            });
            (0, vortex_api_1.log)('warn', 'already installing a collection');
            return;
          }
          this.mProfile = profile;
          this.mLastCollection = this.mCollection = collection;
          this.mGameId = (_a = profile === null || profile === void 0 ? void 0 : profile.gameId) !== null && _a !== void 0 ? _a : vortex_api_1.selectors.activeGameId(this.mApi.getState());
          this.mTotalSize = (0, util_1.calculateCollectionSize)(this.getModsEx(profile, this.mGameId, collection));
          await this.startInstall();
          await this.initCollectionInfo();
          this.triggerUpdate();
        }
        onUpdate(cb) {
          this.mUpdateHandlers.push(cb);
        }
        get profile() {
          return this.mProfile;
        }
        set profile(val) {
          this.mProfile = val;
          if (val !== undefined) {
            this.mGameId = val === null || val === void 0 ? void 0 : val.gameId;
          }
        }
        get infoCache() {
          return this.mInfoCache;
        }
        get step() {
          return this.mStep;
        }
        get installedMods() {
          return this.mInstalledMods;
        }
        get numRequired() {
          return this.requiredMods.length;
        }
        get installingMod() {
          return this.mInstallingMod;
        }
        get collection() {
          return this.mCollection;
        }
        get lastCollection() {
          return this.mLastCollection;
        }
        get collectionId() {
          let _a, _b, _c;
          const state = this.mApi.store.getState();
          const modInfo = (this.mCollection !== undefined)
            ? (_a = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _a === void 0 ? void 0 : _a.modInfo
            : undefined;
          const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
          return ((_b = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.ids) === null || _b === void 0 ? void 0 : _b.collectionId) || ((_c = modInfo === null || modInfo === void 0 ? void 0 : modInfo.ids) === null || _c === void 0 ? void 0 : _c.collectionId);
        }
        get collectionSlug() {
          let _a, _b, _c;
          const state = this.mApi.store.getState();
          const modInfo = (this.mCollection !== undefined)
            ? (_a = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _a === void 0 ? void 0 : _a.modInfo
            : undefined;
          const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
          return ((_b = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.ids) === null || _b === void 0 ? void 0 : _b.collectionSlug) || ((_c = modInfo === null || modInfo === void 0 ? void 0 : modInfo.ids) === null || _c === void 0 ? void 0 : _c.collectionSlug);
        }
        get revisionNumber() {
          let _a, _b, _c;
          const state = this.mApi.store.getState();
          const modInfo = (this.mCollection !== undefined)
            ? (_a = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _a === void 0 ? void 0 : _a.modInfo
            : undefined;
          const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
          return ((_b = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.ids) === null || _b === void 0 ? void 0 : _b.revisionNumber) || ((_c = modInfo === null || modInfo === void 0 ? void 0 : modInfo.ids) === null || _c === void 0 ? void 0 : _c.revisionNumber);
        }
        get revisionId() {
          let _a, _b, _c;
          const state = this.mApi.store.getState();
          const modInfo = (this.mCollection !== undefined)
            ? (_a = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _a === void 0 ? void 0 : _a.modInfo
            : undefined;
          const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
          return ((_b = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.ids) === null || _b === void 0 ? void 0 : _b.revisionId) || ((_c = modInfo === null || modInfo === void 0 ? void 0 : modInfo.ids) === null || _c === void 0 ? void 0 : _c.revisionId);
        }
        get collectionInfo() {
          return this.mCollectionInfo;
        }
        get revisionInfo() {
          return this.mRevisionInfo;
        }
        get installDone() {
          return this.mInstallDone;
        }
        cancel() {
          this.onStop();
          this.triggerUpdate();
        }
        installRecommended() {
          this.mApi.emitAndAwait('install-from-dependencies', this.mCollection.id, this.mCollection.rules, true);
          this.mStep = 'recommendations';
          this.triggerUpdate();
        }
        async continue() {
          let _a, _b;
          if (this.canContinue() && (((_a = this.mCollection) === null || _a === void 0 ? void 0 : _a.archiveId) !== undefined)) {
            await this.initCollectionInfo();
            const steps = {
              query: this.startInstall,
              start: this.begin,
              disclaimer: this.closeDisclaimers,
              installing: this.finishInstalling,
              recommendations: this.finishInstalling,
              review: this.close,
            };
            const res = await ((_b = steps[this.mStep]) === null || _b === void 0 ? void 0 : _b.call(steps));
            if (res !== false) {
              this.triggerUpdate();
            }
          }
        }
        canContinue() {
          if (this.mCollection === undefined) {
            return false;
          }
          if (this.mStep === 'installing') {
            return this.mInstallDone;
          }
          else if (this.mStep === 'disclaimer') {
            return (this.mInstalledMods.length > 0) || this.mInstallDone;
          }
          else {
            return true;
          }
        }
        canClose() {
          return ['start'].indexOf(this.mStep) !== -1;
        }
        canHide() {
          return ['disclaimer', 'installing'].indexOf(this.mStep) !== -1;
        }
        async initCollectionInfo() {
          let _a, _b, _c, _d, _e;
          if (((_a = this.mCollection) === null || _a === void 0 ? void 0 : _a.archiveId) === undefined) {
            return;
          }
          const slug = this.collectionSlug;
          const state = this.mApi.store.getState();
          const modInfo = (_b = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _b === void 0 ? void 0 : _b.modInfo;
          const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
          this.mCollectionInfo = (_d = (_c = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.collectionInfo) !== null && _c !== void 0 ? _c : await this.mInfoCache.getCollectionInfo(slug)) !== null && _d !== void 0 ? _d : (_e = this.mRevisionInfo) === null || _e === void 0 ? void 0 : _e.collection;
        }
        async onDidInstallDependencies(gameId, modId, recommendations) {
          let _a, _b, _c;
          const mods = this.mApi.getState().persistent.mods[gameId];
          if (((_a = mods[modId]) === null || _a === void 0 ? void 0 : _a.type) === constants_1.MOD_TYPE) {
            (0, vortex_api_1.log)('info', 'did install dependencies', { gameId, modId });
          }
          if ((this.mCollection !== undefined) && (modId === this.mCollection.id)) {
            this.mLastCollection = this.mCollection = mods[modId];
            if (this.mCollection !== undefined) {
              if (!recommendations) {
                const filter = rule => (rule.type === 'requires')
                        && (rule['ignored'] !== true)
                        && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined);
                const incomplete = ((_b = this.mCollection.rules) !== null && _b !== void 0 ? _b : []).find(filter);
                if (incomplete === undefined) {
                  await this.initCollectionInfo();
                  this.mStep = 'review';
                }
                else {
                  this.mInstallDone = true;
                  this.mInstallingMod = undefined;
                }
                this.mApi.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + modId);
                this.triggerUpdate();
              }
              else {
                const filter = rule => (['requires', 'recommends'].includes(rule.type))
                        && (rule['ignored'] !== true)
                        && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined);
                const incomplete = ((_c = this.mCollection.rules) !== null && _c !== void 0 ? _c : []).find(filter);
                this.mApi.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + modId);
                if (incomplete === undefined) {
                  await this.initCollectionInfo();
                  this.mStep = 'review';
                }
                else {
                  this.onStop();
                }
              }
            }
          }
          const stagingPath = vortex_api_1.selectors.installPathForGame(this.mApi.getState(), gameId);
          const mod = mods[modId];
          if ((mod !== undefined) && (mod.type === constants_1.MOD_TYPE)) {
            try {
              const collectionInfo = await (0, importCollection_1.readCollection)(this.mApi, path.join(stagingPath, mod.installationPath, 'collection.json'));
              await (0, collectionInstall_1.postprocessCollection)(this.mApi, gameId, mod, collectionInfo, mods);
              this.mApi.events.emit('analytics-track-event-with-payload', 'Collection Installation Completed', {
                collection_slug: this.collectionSlug,
                collection_revision_number: this.revisionNumber
              });
            }
            catch (err) {
              (0, vortex_api_1.log)('info', 'Failed to apply mod rules from collection. This is normal if this is the '
                    + 'platform where the collection has been created.');
              this.mDebounce.schedule(undefined, this.collectionSlug, this.revisionNumber);
            }
          }
        }
        onStop() {
          let _a;
          if (this.mCollection !== undefined) {
            this.mApi.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + this.mCollection.id);
          }
          this.mCollection = undefined;
          this.mProfile = undefined;
          this.mGameId = undefined;
          this.mInstalledMods = [];
          this.mStep = 'prepare';
          (_a = this.mOnStop) === null || _a === void 0 ? void 0 : _a.call(this);
        }
        getModsEx(profile, gameId, collection) {
          let _a;
          if (profile === undefined) {
            profile = this.mProfile;
          }
          if (profile === undefined) {
            return {};
          }
          const mods = this.mApi.getState().persistent.mods[gameId];
          if (mods === undefined) {
            (0, vortex_api_1.log)('error', 'no mods for game', { gameId });
            return {};
          }
          return ((_a = collection.rules) !== null && _a !== void 0 ? _a : []).reduce((prev, rule) => {
            if (!['requires', 'recommends'].includes(rule.type)) {
              return prev;
            }
            const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
            prev[(0, util_1.modRuleId)(rule)] = { ...mod, collectionRule: rule };
            return prev;
          }, {});
        }
        matchRepo(rule, ref) {
          let _a, _b;
          if (ref === null) {
            return false;
          }
          const modId = (_a = rule.reference.repo) === null || _a === void 0 ? void 0 : _a.modId;
          const fileId = (_b = rule.reference.repo) === null || _b === void 0 ? void 0 : _b.fileId;
          if ((modId === undefined) || (fileId === undefined)
            || !ref.modId || !ref.fileId) {
            return false;
          }
          return modId.toString() === ref.modId.toString()
            && fileId.toString() === ref.fileId.toString();
        }
        augmentRules(gameId, collection) {
          let _a;
          vortex_api_1.util.batchDispatch(this.mApi.store, ((_a = collection.rules) !== null && _a !== void 0 ? _a : []).map(rule => {
            let _a, _b;
            if (rule.reference.repo === undefined) {
              return undefined;
            }
            const revMod = ((_b = (_a = this.mRevisionInfo) === null || _a === void 0 ? void 0 : _a.modFiles) !== null && _b !== void 0 ? _b : []).find(iter => this.matchRepo(rule, iter.file));
            if ((revMod === null || revMod === void 0 ? void 0 : revMod.file) !== undefined) {
              const newRule = vortex_api_1.util.setSafe(rule, ['extra', 'fileName'], revMod.file.uri);
              return vortex_api_1.actions.addModRule(gameId, collection.id, newRule);
            }
          })
            .filter(rule => rule !== undefined));
        }
        triggerUpdate() {
          this.mUpdateHandlers.forEach(cb => {
            cb();
          });
        }
        installProgress(profile, gameId, collection) {
          const mods = this.getModsEx(profile, gameId, collection);
          const downloads = this.mApi.getState().persistent.downloads.files;
          const downloadProgress = Object.values(mods).reduce((prev, mod) => {
            let _a;
            let size = 0;
            if ((mod.state === 'downloading') || (mod.state === null)) {
              const download = downloads[mod.archiveId];
              size += (download === null || download === void 0 ? void 0 : download.received) || 0;
            }
            else {
              size += ((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.fileSize) || 0;
            }
            return prev + size;
          }, 0);
          const installedMods = Object.values(mods).filter(mod => mod.state === 'installed');
          const totalMods = Object.values(mods).filter(util_1.isRelevant);
          const dlPerc = downloadProgress / this.mTotalSize;
          const instPerc = installedMods.length / totalMods.length;
          return (dlPerc + instPerc) * 50.0;
        }
        updateProgress(profile, gameId, collection) {
          if (collection === undefined) {
            return;
          }
          if (this.mTotalSize === undefined) {
            this.mTotalSize = (0, util_1.calculateCollectionSize)(this.getModsEx(profile, gameId, collection));
          }
          this.mApi.sendNotification({
            id: constants_1.INSTALLING_NOTIFICATION_ID + collection.id,
            type: 'activity',
            title: 'Installing Collection',
            message: vortex_api_1.util.renderModName(collection),
            progress: this.installProgress(profile, gameId, collection),
            actions: [
              {
                title: 'Show',
                action: () => {
                  this.mApi.events.emit('view-collection', collection.id);
                },
              },
            ],
          });
        }
      }
      exports["default"] = InstallDriver;


/***/ }),

/***/ "./src/util/binaryPatching.ts":
/*!************************************!*\
  !*** ./src/util/binaryPatching.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.applyPatches = exports.scanForDiffs = void 0;
      const crc32 = __webpack_require__(/*! crc-32 */ "./node_modules/crc-32/crc32.js");
      const path = __webpack_require__(/*! path */ "path");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
      const bsdiff = vortex_api_1.util.lazyRequire(() => __webpack_require__(/*! bsdiff-node */ "./node_modules/bsdiff-node/index.js"));
      function crcFromBuf(data) {
        return (crc32.buf(data) >>> 0).toString(16).toUpperCase().padStart(8, '0');
      }
      async function validatePatch(srcFilePath, patchFilePath) {
        const srcStats = await vortex_api_1.fs.statAsync(srcFilePath);
        const patchStats = await vortex_api_1.fs.statAsync(patchFilePath);
        if ((patchStats.size - constants_1.PATCH_OVERHEAD) > (srcStats.size * constants_1.MAX_PATCH_SIZE)) {
          throw new vortex_api_1.util.DataInvalid('patch too large');
        }
      }
      const queue = vortex_api_1.util.makeQueue();
      async function scanForDiffs(api, gameId, modId, destPath, onProgress) {
        let _a;
        const state = api.getState();
        const mod = state.persistent.mods[gameId][modId];
        const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
        const localPath = path.join(stagingPath, mod.installationPath);
        const archive = state.persistent.downloads.files[mod.archiveId];
        if (archive === undefined) {
          throw new vortex_api_1.util.ProcessCanceled('Archive not found');
        }
        const choices = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.installerChoices;
        return queue(() => new Promise((resolve, reject) => {
          api.events.emit('simulate-installer', gameId, mod.archiveId, { choices }, async (instRes, tempPath) => {
            try {
              const dlPath = vortex_api_1.selectors.downloadPathForGame(state, archive.game[0]);
              const archivePath = path.join(dlPath, archive.localPath);
              const sourceChecksums = {};
              const szip = new vortex_api_1.util.SevenZip();
              await szip.list(archivePath, undefined, async (entries) => {
                for (const entry of entries) {
                  if (entry.attr !== 'D') {
                    try {
                      sourceChecksums[entry.name] = entry['crc'].toUpperCase();
                    }
                    catch (err) {
                      api.showErrorNotification('Failed to determine checksum for file', err, {
                        message: entry.name,
                      });
                    }
                  }
                }
              });
              const result = {};
              for (const file of instRes.instructions.filter(instr => instr.type === 'copy')) {
                const srcCRC = sourceChecksums[file.source];
                const dstFilePath = path.join(localPath, file.destination);
                const dat = await vortex_api_1.fs.readFileAsync(dstFilePath);
                const dstCRC = crcFromBuf(dat);
                if (srcCRC !== dstCRC) {
                  onProgress(undefined, api.translate('Creating patch for {{fileName}}', { replace: {
                    fileName: path.basename(file.source),
                  } }));
                  (0, vortex_api_1.log)('debug', 'found modified file', { filePath: file.source, srcCRC, dstCRC });
                  const srcFilePath = path.join(tempPath, file.source);
                  const patchPath = path.join(destPath, file.destination + '.diff');
                  await vortex_api_1.fs.ensureDirWritableAsync(path.dirname(patchPath));
                  await bsdiff.diff(srcFilePath, dstFilePath, patchPath, progress => {
                  });
                  try {
                    await validatePatch(srcFilePath, patchPath);
                    result[file.destination] = srcCRC;
                  }
                  catch (err) {
                    await vortex_api_1.fs.removeAsync(patchPath);
                    const res = await api.showDialog('error', 'Can\'t save local edits', {
                      text: 'The local modifications to file "{{fileName}}" can not be included in '
                                    + 'the collection.\n'
                                    + 'We don\'t allow edits that exceed a certain percentage '
                                    + 'of the original file size.\n'
                                    + 'If you continue anyway this file will be installed unmodified for users.',
                      parameters: {
                        fileName: file.source,
                      },
                    }, [
                      { label: 'Cancel' },
                      { label: 'Continue' },
                    ]);
                    if (res.action === 'Cancel') {
                      err['mayIgnore'] = false;
                      throw err;
                    }
                  }
                  (0, vortex_api_1.log)('debug', 'patch created at', patchPath);
                }
              }
              resolve(result);
            }
            catch (err) {
              reject(err);
            }
          });
        }), false);
      }
      exports.scanForDiffs = scanForDiffs;
      async function applyPatches(api, collection, gameId, modName, modId, patches) {
        const state = api.getState();
        const installPath = vortex_api_1.selectors.installPathForGame(state, gameId);
        const mod = state.persistent.mods[gameId][modId];
        const modPath = path.join(installPath, mod.installationPath);
        const patchesPath = path.join(installPath, collection.installationPath, constants_1.PATCHES_PATH, modName);
        for (const filePath of Object.keys(patches !== null && patches !== void 0 ? patches : {})) {
          try {
            const srcPath = path.join(modPath, filePath);
            const diffPath = path.join(patchesPath, filePath) + '.diff';
            await vortex_api_1.fs.statAsync(diffPath);
            const srcDat = await vortex_api_1.fs.readFileAsync(srcPath);
            const srcCRC = crcFromBuf(srcDat);
            if (srcCRC === patches[filePath]) {
              await bsdiff.patch(srcPath, srcPath + '.patched', diffPath);
              await vortex_api_1.fs.removeAsync(srcPath);
              await vortex_api_1.fs.renameAsync(srcPath + '.patched', srcPath);
              (0, vortex_api_1.log)('info', 'patched', srcPath);
            }
            else {
              (0, vortex_api_1.log)('warn', 'patch not applied because reference CRC differs', { filePath, srcCRC });
            }
          }
          catch (err) {
            err['Collection'] = vortex_api_1.util.renderModName(collection);
            api.showErrorNotification('failed to patch', err, {
              message: filePath,
            });
          }
        }
      }
      exports.applyPatches = applyPatches;


/***/ }),

/***/ "./src/util/checksumMatcher.ts":
/*!*************************************!*\
  !*** ./src/util/checksumMatcher.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.matchChecksums = void 0;
      const crc32 = __webpack_require__(/*! crc-32 */ "./node_modules/crc-32/crc32.js");
      const path = __webpack_require__(/*! path */ "path");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const errors_1 = __webpack_require__(/*! ../util/errors */ "./src/util/errors.ts");
      async function matchChecksums(api, gameId, modId) {
        const state = api.getState();
        const mod = state.persistent.mods[gameId][modId];
        if (!(mod === null || mod === void 0 ? void 0 : mod.archiveId)) {
          throw new vortex_api_1.util.ProcessCanceled('Mod not found');
        }
        const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
        const localPath = path.join(stagingPath, mod.installationPath);
        const archive = state.persistent.downloads.files[mod.archiveId];
        if (archive === undefined) {
          throw new vortex_api_1.util.ProcessCanceled('Archive not found');
        }
        const dlPath = vortex_api_1.selectors.downloadPathForGame(state, archive.game[0]);
        const archivePath = path.join(dlPath, archive.localPath);
        const sourceChecksums = new Set();
        const szip = new vortex_api_1.util.SevenZip();
        await szip.list(archivePath, undefined, async (entries) => {
          for (const entry of entries) {
            if (entry.attr !== 'D') {
              try {
                if (!!entry['crc']) {
                  sourceChecksums.add(entry['crc'].toUpperCase());
                }
              }
              catch (err) {
                api.showErrorNotification('Failed to determine checksum for file', err, {
                  message: entry.name,
                });
              }
            }
          }
        });
        let entries = [];
        await vortex_api_1.util.walk(localPath, async (input) => {
          entries = [].concat(entries, input);
        }, {});
        const localChecksums = new Set();
        const computeCRC32Stream = (filePath) => {
          return new Promise((resolve, reject) => {
            const stream = vortex_api_1.fs.createReadStream(filePath);
            let crc = 0;
            stream.on('data', (chunk) => {
              crc = crc32.buf(chunk, crc);
            });
            stream.on('end', () => {
              resolve((crc >>> 0).toString(16).toUpperCase().padStart(8, '0'));
            });
            stream.on('error', (err) => {
              reject(err);
            });
          });
        };
        for (const entry of entries) {
          const isDirectory = (await vortex_api_1.fs.statAsync(entry)).isDirectory();
          if (isDirectory) {
            continue;
          }
          const crc = await computeCRC32Stream(entry);
          localChecksums.add(crc);
        }
        const missingChecksums = [];
        for (const crc of localChecksums) {
          if (!sourceChecksums.has(crc)) {
            missingChecksums.push(crc);
          }
        }
        if (missingChecksums.length > 0) {
          throw new errors_1.ReplicateHashMismatchError();
        }
      }
      exports.matchChecksums = matchChecksums;


/***/ }),

/***/ "./src/util/collectionConfig/index.ts":
/*!********************************************!*\
  !*** ./src/util/collectionConfig/index.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.parseConfig = exports.generateConfig = void 0;
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const configDefaults = {
        recommendNewProfile: false,
      };
      async function generateConfig(props) {
        const { collectionMod } = props;
        const config = vortex_api_1.util.getSafe(collectionMod, ['attributes', 'collection', 'collectionConfig'], configDefaults);
        return {
          ...config,
        };
      }
      exports.generateConfig = generateConfig;
      async function parseConfig(props) {
        const { collection } = props;
        const config = vortex_api_1.util.getSafe(collection, ['collectionConfig'], configDefaults);
        return config;
      }
      exports.parseConfig = parseConfig;


/***/ }),

/***/ "./src/util/defaults.ts":
/*!******************************!*\
  !*** ./src/util/defaults.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.genDefaultsAction = void 0;
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function applyDefaultInstallMode(prev, mod) {
        let _a, _b, _c;
        if (((_a = prev === null || prev === void 0 ? void 0 : prev.installMode) === null || _a === void 0 ? void 0 : _a[mod.id]) === undefined) {
          const { installerChoices } = (_b = mod === null || mod === void 0 ? void 0 : mod.attributes) !== null && _b !== void 0 ? _b : {};
          if (((installerChoices === null || installerChoices === void 0 ? void 0 : installerChoices.type) === 'fomod') && (((_c = installerChoices === null || installerChoices === void 0 ? void 0 : installerChoices.options) === null || _c === void 0 ? void 0 : _c.length) > 0)) {
            prev = vortex_api_1.util.setSafe(prev, ['installMode', mod.id], 'choices');
          }
        }
        return prev;
      }
      function applyDefaultSource(prev, mod) {
        let _a, _b, _c;
        if (((_a = prev === null || prev === void 0 ? void 0 : prev.source) === null || _a === void 0 ? void 0 : _a[mod.id]) === undefined) {
          if (((_b = mod === null || mod === void 0 ? void 0 : mod.attributes) === null || _b === void 0 ? void 0 : _b.source) === 'website') {
            prev = vortex_api_1.util.setSafe(prev, ['source', mod.id], {
              type: 'browse',
              url: (_c = mod === null || mod === void 0 ? void 0 : mod.attributes) === null || _c === void 0 ? void 0 : _c.url,
            });
          }
        }
        return prev;
      }
      function genDefaultsAction(api, collectionId, mods, gameId) {
        if (mods.length === 0) {
          return undefined;
        }
        const state = api.getState();
        const collection = vortex_api_1.util.getSafe(state, ['persistent', 'mods', gameId, collectionId], undefined);
        if (collection === undefined) {
          const error = new vortex_api_1.util.ProcessCanceled('Unable to find collection mod', { collectionId: collection.id });
          api.showErrorNotification('Failed to ascertain default install mode', error);
          return undefined;
        }
        const attr = vortex_api_1.util.getSafe(collection.attributes, ['collection'], {});
        const resAttr = mods.reduce((prev, mod) => {
          prev = applyDefaultInstallMode(prev, mod);
          prev = applyDefaultSource(prev, mod);
          return prev;
        }, attr);
        return vortex_api_1.actions.setModAttribute(gameId, collection.id, 'collection', resAttr);
      }
      exports.genDefaultsAction = genDefaultsAction;


/***/ }),

/***/ "./src/util/errors.ts":
/*!****************************!*\
  !*** ./src/util/errors.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.ReplicateHashMismatchError = void 0;
      class ReplicateHashMismatchError extends Error {
        constructor() {
          super('Replicate install mode can only work if the checksums of the installed files match those in the archive. Please try to reinstall the mod or use binary patching instead.');
          this.mayIgnore = false;
          this.name = 'ReplicateHashMismatchError';
          this.mayIgnore = false;
        }
      }
      exports.ReplicateHashMismatchError = ReplicateHashMismatchError;


/***/ }),

/***/ "./src/util/extension.ts":
/*!*******************************!*\
  !*** ./src/util/extension.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.findExtensions = exports.addExtension = void 0;
      const features = [];
      function addExtension(feature) {
        features.push(feature);
      }
      exports.addExtension = addExtension;
      function findExtensions(state, gameId) {
        return features.filter(iter => (iter.condition === undefined) || iter.condition(state, gameId));
      }
      exports.findExtensions = findExtensions;


/***/ }),

/***/ "./src/util/findModByRef.ts":
/*!**********************************!*\
  !*** ./src/util/findModByRef.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.testDownloadReference = void 0;
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function testDownloadReference(download, reference) {
        if (download === undefined) {
          return false;
        }
        return vortex_api_1.util.testModReference(vortex_api_1.util.lookupFromDownload(download), reference);
      }
      exports.testDownloadReference = testDownloadReference;


/***/ }),

/***/ "./src/util/gameSupport/gamebryo.tsx":
/*!*******************************************!*\
  !*** ./src/util/gameSupport/gamebryo.tsx ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.Interface = exports.PluginRule = exports.parser = exports.generate = void 0;
      const path = __webpack_require__(/*! path */ "path");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function getEnabledPlugins(state, plugins) {
        const gamebryoLO = state['loadOrder'];
        return plugins.map(pluginName => ({
          ...gamebryoLO[pluginName.toLowerCase()],
          name: pluginName,
        }))
          .filter(lo => (lo !== undefined) && (lo.name !== undefined) && (lo.enabled === true))
          .sort((lhs, rhs) => lhs.loadOrder - rhs.loadOrder)
          .map(lo => ({ name: lo.name, enabled: lo.enabled }));
      }
      function extractPluginRules(state, plugins) {
        const installedPlugins = new Set(plugins.map(name => name.toLowerCase()));
        const customisedPlugins = state['userlist'].plugins.filter((plug) => installedPlugins.has(plug.name.toLowerCase())
        && ((plug.after !== undefined) || (plug.group !== undefined)));
        return {
          plugins: customisedPlugins,
          groups: state['userlist'].groups,
        };
      }
      async function getIncludedPlugins(gameId, stagingPath, mods, modIds) {
        const extensions = ['fallout4', 'skyrimse'].includes(gameId)
          ? new Set(['.esp', '.esm', '.esl'])
          : new Set(['.esp', '.esm']);
        const includedPlugins = [];
        await Promise.all(modIds.map(async (modId) => {
          if (mods[modId] !== undefined) {
            try {
              const files = await vortex_api_1.fs.readdirAsync(path.join(stagingPath, mods[modId].installationPath));
              const plugins = files.filter(fileName => extensions.has(path.extname(fileName).toLowerCase()));
              includedPlugins.push(...plugins);
            }
            catch (err) {
              (0, vortex_api_1.log)('warn', 'failed to read plugins included in mod', err.message);
            }
          }
        }));
        return includedPlugins;
      }
      async function generate(state, gameId, stagingPath, modIds, mods) {
        const includedPlugins = await getIncludedPlugins(gameId, stagingPath, mods, modIds);
        return {
          plugins: getEnabledPlugins(state, includedPlugins),
          pluginRules: extractPluginRules(state, includedPlugins),
        };
      }
      exports.generate = generate;
      function toLootType(type) {
        switch (type) {
          case 'requires': return 'req';
          case 'incompatible': return 'inc';
          default: return 'after';
        }
      }
      function refName(iter) {
        if (typeof (iter) === 'string') {
          return iter;
        }
        else {
          return iter.name;
        }
      }
      async function parser(api, gameId, collection, collectionMod) {
        let _a, _b, _c;
        const state = api.getState();
        if (state.userlist === undefined) {
          return;
        }
        const mods = state.persistent.mods[gameId];
        vortex_api_1.util.batchDispatch(api.store, ((_a = collection.pluginRules.groups) !== null && _a !== void 0 ? _a : []).reduce((prev, group) => {
          if (state.userlist.groups[group.name] === undefined) {
            prev.push({
              type: 'ADD_PLUGIN_GROUP', payload: {
                group: group.name,
              },
            });
          }
          group.after.forEach(after => {
            prev.push({
              type: 'ADD_GROUP_RULE', payload: {
                groupId: group.name,
                reference: after,
              },
            });
          });
          return prev;
        }, []));
        const collectionModIds = collectionMod.rules
          .filter(rule => ['requires', 'recommends'].includes(rule.type))
          .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
          .filter(mod => !!mod)
          .map(mod => mod.id);
        const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
        const includedPlugins = await getIncludedPlugins(gameId, stagingPath, mods, collectionModIds);
        const isEnabled = (pluginName) => collection.plugins.find(plugin => ((plugin.name === pluginName) && (plugin.enabled))) !== undefined;
        vortex_api_1.util.batchDispatch(api.store, includedPlugins.map(plugin => {
          return {
            type: 'SET_PLUGIN_ENABLED', payload: {
              pluginName: plugin,
              enabled: isEnabled(plugin),
            }
          };
        }));
        state.session.notifications.notifications
          .filter(noti => noti.id.startsWith('multiple-plugins-'))
          .forEach(noti => api.dismissNotification(noti.id));
        vortex_api_1.util.batchDispatch(api.store, ((_c = (_b = collection.pluginRules) === null || _b === void 0 ? void 0 : _b.plugins) !== null && _c !== void 0 ? _c : []).reduce((prev, plugin) => {
          const existing = state.userlist.plugins.find(plug => plug.name.toUpperCase() === plugin.name.toUpperCase());
          if ((plugin.group !== undefined) && ((existing === null || existing === void 0 ? void 0 : existing.group) === undefined)) {
            prev.push({
              type: 'SET_PLUGIN_GROUP',
              payload: {
                pluginId: plugin.name.toLowerCase(),
                group: plugin.group,
              },
            });
          }
          ['requires', 'incompatible', 'after'].forEach(type => {
            const lootType = toLootType(type);
            (plugin[type] || []).forEach(ref => {
              const match = iter => refName(iter).toUpperCase() === ref.toUpperCase();
              if (vortex_api_1.util.getSafe(existing, [lootType], []).find(match) === undefined) {
                prev.push({
                  type: 'ADD_USERLIST_RULE',
                  payload: {
                    pluginId: plugin.name.toLowerCase(),
                    reference: ref,
                    type,
                  },
                });
              }
            });
          });
          return prev;
        }, []));
      }
      exports.parser = parser;
      function ruleName(rule) {
        let _a;
        if (typeof (rule) === 'string') {
          return rule;
        }
        else {
          return (_a = rule.display) !== null && _a !== void 0 ? _a : rule.name;
        }
      }
      function ruleId(rule) {
        if (typeof (rule) === 'string') {
          return rule.toLowerCase();
        }
        else {
          return rule.name.toLowerCase();
        }
      }
      function ruleType(t, type) {
        switch (type) {
          case 'after': return t('after');
          case 'requires': return t('requires');
          case 'incompatible': return t('incompatible with');
          default: return '???';
        }
      }
      function renderRefName(rule) {
        return typeof (rule.ref) === 'string'
          ? rule.ref
          : rule.ref.display;
      }
      function renderType(t, type) {
        if (type === 'assigned') {
          return t('assigned to group');
        }
        else {
          return t(type);
        }
      }
      function PluginRule(props) {
        const { t, onRemove, rule } = props;
        const remove = React.useCallback((evt) => {
          onRemove(rule);
        }, [rule]);
        return (React.createElement(react_bootstrap_1.ListGroupItem, null,
                                    React.createElement("div", { className: 'rule-name' },
                                                        rule.isGroup ? t('Group') + ' ' : '',
                                                        rule.name),
                                    React.createElement("div", { className: 'rule-type' }, renderType(t, rule.type)),
                                    React.createElement("div", { className: 'rule-name' }, renderRefName(rule)),
                                    React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed remove-btn', icon: 'remove', tooltip: t('Remove plugin rule'), onClick: remove })));
      }
      exports.PluginRule = PluginRule;
      function Interface(props) {
        let _a;
        const { t, collection } = props;
        const [pluginRules, setPluginRules] = React.useState(null);
        const [groupAssignments, setGroupAssignments] = React.useState(null);
        const store = (0, react_redux_1.useStore)();
        const gameId = (0, react_redux_1.useSelector)(vortex_api_1.selectors.activeGameId);
        const mods = (0, react_redux_1.useSelector)((selState) => selState.persistent.mods[gameId]);
        const userlist = (0, react_redux_1.useSelector)((selState) => selState.userlist);
        const state = store.getState();
        React.useEffect(() => {
          const modIds = collection.rules
            .map(rule => rule.reference.id)
            .filter(modId => modId !== undefined);
          const stagingPath = vortex_api_1.selectors.installPath(state);
          getIncludedPlugins(gameId, stagingPath, mods, modIds)
            .then(plugins => {
              let _a, _b, _c, _d;
              const pluginsL = plugins.map(plug => plug.toLowerCase());
              const rules = [];
              const assignments = {};
              for (const plugin of plugins) {
                const plug = ((_a = userlist === null || userlist === void 0 ? void 0 : userlist.plugins) !== null && _a !== void 0 ? _a : [])
                  .find(iter => iter.name.toLowerCase() === plugin.toLowerCase());
                const byRef = (name) => pluginsL.includes(ruleId(name));
                const toRule = (ref, type) => ({
                  name: plugin,
                  ref,
                  type,
                });
                if (plug !== undefined) {
                  rules.push(...((_b = plug.after) !== null && _b !== void 0 ? _b : []).filter(byRef).map(aft => toRule(aft, 'after')));
                  rules.push(...((_c = plug.req) !== null && _c !== void 0 ? _c : []).filter(byRef).map(req => toRule(req, 'requires')));
                  rules.push(...((_d = plug.inc) !== null && _d !== void 0 ? _d : []).filter(byRef).map(inc => toRule(inc, 'incompatible')));
                  if (plug.group !== undefined) {
                    assignments[plug.name] = plug.group;
                  }
                }
              }
              setPluginRules(rules);
              setGroupAssignments(assignments);
            });
        }, [collection, mods, userlist, setPluginRules]);
        const removeRule = React.useCallback((rule) => {
          store.dispatch({ type: 'REMOVE_USERLIST_RULE', payload: {
            pluginId: rule.name.toLowerCase(), reference: rule.ref, type: rule.type,
          } });
        }, [store]);
        const removeGroupRule = React.useCallback((rule) => {
          store.dispatch({ type: 'REMOVE_GROUP_RULE', payload: {
            groupId: rule.name.toLowerCase(), reference: rule.ref,
          } });
        }, [store]);
        const unassignGroup = React.useCallback((rule) => {
          store.dispatch({ type: 'SET_PLUGIN_GROUP', payload: {
            pluginId: rule.name.toLowerCase(), group: undefined,
          } });
        }, [store]);
        if (userlist === undefined) {
          return (React.createElement(react_bootstrap_1.Panel, null, t('No userlist loaded, is the gamebryo-plugin-management extension disabled?')));
        }
        const grpsFlattened = ((_a = userlist === null || userlist === void 0 ? void 0 : userlist.groups) !== null && _a !== void 0 ? _a : []).reduce((prev, grp) => {
          let _a;
          ((_a = grp.after) !== null && _a !== void 0 ? _a : []).forEach(aft => {
            prev.push({ name: grp.name, ref: aft, type: 'after' });
          });
          return prev;
        }, []);
        return (React.createElement("div", { className: 'collection-rules-edit collection-scrollable' },
                                    React.createElement(react_bootstrap_1.ControlLabel, null,
                                                        React.createElement("p", null,
                                                                            t('The collection will include your custom load order rules so that '
                    + 'users of your collection will get the same load order.'),
                                                                            React.createElement("br", null),
                                                                            t('Rules you remove here are also removed from your actual setup.'))),
                                    (pluginRules !== null) ? (React.createElement(react_bootstrap_1.ListGroup, null, pluginRules.map(rule => (React.createElement(PluginRule, { t: t, key: `${rule.name}_after_${rule.ref}`, rule: rule, onRemove: removeRule }))))) : React.createElement(vortex_api_1.Spinner, null),
                                    (groupAssignments !== null) ? (React.createElement(react_bootstrap_1.ListGroup, null, Object.keys(groupAssignments).map(pluginName => (React.createElement(PluginRule, { t: t, key: `${pluginName}_assigned_${groupAssignments[pluginName]}`, rule: { name: pluginName, type: 'assigned', ref: groupAssignments[pluginName] }, onRemove: unassignGroup }))))) : React.createElement(vortex_api_1.Spinner, null),
                                    React.createElement(react_bootstrap_1.ListGroup, null, (grpsFlattened.map(grp => (React.createElement(PluginRule, { t: t, key: `${grp.name}_after_${grp.ref}`, rule: grp, onRemove: removeGroupRule })))))));
      }
      exports.Interface = Interface;


/***/ }),

/***/ "./src/util/gameSupport/index.ts":
/*!***************************************!*\
  !*** ./src/util/gameSupport/index.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.getInterface = exports.parseGameSpecifics = exports.generateGameSpecifics = void 0;
      const gamebryo = __webpack_require__(/*! ./gamebryo */ "./src/util/gameSupport/gamebryo.tsx");
      const gameSupport = {
        skyrim: {
          generator: gamebryo.generate,
          parser: gamebryo.parser,
          interface: gamebryo.Interface,
        },
        skyrimse: {
          generator: gamebryo.generate,
          parser: gamebryo.parser,
          interface: gamebryo.Interface,
        },
        skyrimvr: {
          generator: gamebryo.generate,
          parser: gamebryo.parser,
          interface: gamebryo.Interface,
        },
        fallout3: {
          generator: gamebryo.generate,
          parser: gamebryo.parser,
          interface: gamebryo.Interface,
        },
        fallout4: {
          generator: gamebryo.generate,
          parser: gamebryo.parser,
          interface: gamebryo.Interface,
        },
        fallout4vr: {
          generator: gamebryo.generate,
          parser: gamebryo.parser,
          interface: gamebryo.Interface,
        },
        falloutnv: {
          generator: gamebryo.generate,
          parser: gamebryo.parser,
          interface: gamebryo.Interface,
        },
        starfield: {
          generator: gamebryo.generate,
          parser: gamebryo.parser,
          interface: gamebryo.Interface,
        },
        oblivion: {
          generator: gamebryo.generate,
          parser: gamebryo.parser,
          interface: gamebryo.Interface,
        },
        enderal: {
          generator: gamebryo.generate,
          parser: gamebryo.parser,
          interface: gamebryo.Interface,
        },
        enderalspecialedition: {
          generator: gamebryo.generate,
          parser: gamebryo.parser,
          interface: gamebryo.Interface,
        },
      };
      function generateGameSpecifics(state, gameId, stagingPath, modIds, mods) {
        if ((gameSupport[gameId] !== undefined) && (gameSupport[gameId].generator !== undefined)) {
          return gameSupport[gameId].generator(state, gameId, stagingPath, modIds, mods);
        }
        else {
          return Promise.resolve({});
        }
      }
      exports.generateGameSpecifics = generateGameSpecifics;
      function parseGameSpecifics(api, gameId, collection, collectionMod) {
        if ((gameSupport[gameId] !== undefined) && (gameSupport[gameId].parser !== undefined)) {
          return gameSupport[gameId].parser(api, gameId, collection, collectionMod);
        }
        else {
          return Promise.resolve();
        }
      }
      exports.parseGameSpecifics = parseGameSpecifics;
      function getInterface(gameId) {
        if (gameSupport[gameId] === undefined) {
          return null;
        }
        else {
          return gameSupport[gameId].interface;
        }
      }
      exports.getInterface = getInterface;


/***/ }),

/***/ "./src/util/importCollection.ts":
/*!**************************************!*\
  !*** ./src/util/importCollection.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.readCollection = void 0;
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const validation_1 = __webpack_require__(/*! ../validationCode/validation */ "./src/validationCode/validation.ts");
      function isFuzzyVersion(input) {
        if (!input) {
          return false;
        }
        return input.endsWith('+prefer') || (input === '*');
      }
      function postProcessRule(rule) {
        const result = JSON.parse(JSON.stringify(rule));
        if (isFuzzyVersion(result.reference.versionMatch)
        && !!result.reference.logicalFileName) {
          delete result.reference.fileExpression;
        }
        if (isFuzzyVersion(result.source.versionMatch)
        && !!result.source.logicalFileName) {
          delete result.source.fileExpression;
        }
        return result;
      }
      function validationMessage(msg) {
        return `${(msg.instancePath || '/')} ${msg.message}`;
      }
      async function readCollection(api, manifest) {
        let _a;
        const collectionData = await vortex_api_1.fs.readFileAsync(manifest, { encoding: 'utf-8' });
        const collection = JSON.parse(collectionData);
        const readErrors = (0, validation_1.validateICollection)(collection);
        if (readErrors.length > 0) {
          api.showErrorNotification('Collection validation mismatch', 'There was a validation issue with this collection. '
            + 'During the testing phase, this is likely caused by the checks being too strict and '
            + 'the collection itself should still work correctly.\n'
            + 'To help us improve the validation, please report this error once on each '
            + 'collection it appears for.\n\n'
            + readErrors.map(validationMessage).join('\n'));
        }
        collection.modRules = ((_a = collection.modRules) !== null && _a !== void 0 ? _a : []).map(rule => postProcessRule(rule));
        return collection;
      }
      exports.readCollection = readCollection;


/***/ }),

/***/ "./src/util/transformCollection.ts":
/*!*****************************************!*\
  !*** ./src/util/transformCollection.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.createCollectionFromProfile = exports.showQuickCollectionRestrictionsDialog = exports.validateName = exports.createCollection = exports.cloneCollection = exports.makeCollectionId = exports.modToCollection = exports.collectionModToRule = exports.makeBiDirRule = exports.generateCollection = void 0;
      const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
      const binaryPatching_1 = __webpack_require__(/*! ./binaryPatching */ "./src/util/binaryPatching.ts");
      const extension_1 = __webpack_require__(/*! ./extension */ "./src/util/extension.ts");
      const gameSupport_1 = __webpack_require__(/*! ./gameSupport */ "./src/util/gameSupport/index.ts");
      const collectionConfig_1 = __webpack_require__(/*! ./collectionConfig */ "./src/util/collectionConfig/index.ts");
      const util_1 = __webpack_require__(/*! ./util */ "./src/util/util.ts");
      const _ = __webpack_require__(/*! lodash */ "lodash");
      const path = __webpack_require__(/*! path */ "path");
      const shortid_1 = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
      const turbowalk_1 = __webpack_require__(/*! turbowalk */ "turbowalk");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const util_2 = __webpack_require__(/*! ./util */ "./src/util/util.ts");
      const checksumMatcher_1 = __webpack_require__(/*! ./checksumMatcher */ "./src/util/checksumMatcher.ts");
      const initweaks_1 = __webpack_require__(/*! ../initweaks */ "./src/initweaks.ts");
      const errors_1 = __webpack_require__(/*! ./errors */ "./src/util/errors.ts");
      function sanitizeExpression(fileName) {
        return path.basename(fileName, path.extname(fileName))
          .replace(/\.\d+$/, '')
          .replace(/ \(\d+\)$/, '');
      }
      function toInt(input) {
        if (!input) {
          return 0;
        }
        if (typeof (input) === 'string') {
          return parseInt(input, 10);
        }
        return input;
      }
      function deduceSource(mod, sourceInfo, versionMatcher, metaInfo, tag) {
        let _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const res = (sourceInfo !== undefined)
          ? { ...sourceInfo }
          : { type: 'nexus' };
        const assign = (obj, key, value) => {
          if (obj[key] === undefined) {
            obj[key] = value;
          }
        };
        if (res.type === 'nexus') {
          if (((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.source) !== 'nexus') {
            throw new Error(`"${vortex_api_1.util.renderModName(mod)}" doesn't have Nexus as its source`);
          }
          const modId = (mod.type === constants_1.MOD_TYPE) ? (_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.collectionId : (_c = mod.attributes) === null || _c === void 0 ? void 0 : _c.modId;
          const fileId = (mod.type === constants_1.MOD_TYPE) ? (_d = mod.attributes) === null || _d === void 0 ? void 0 : _d.revisionId : (_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.fileId;
          if (!modId || !fileId || isNaN(modId) || isNaN(fileId)) {
            throw new Error(`"${mod.id}" is missing mod id or file id`);
          }
          res.modId = toInt(modId);
          res.fileId = toInt(fileId);
        }
        else {
          assign(res, 'adultContent', sourceInfo === null || sourceInfo === void 0 ? void 0 : sourceInfo.adultContent);
        }
        if (['browse', 'direct'].includes(res.type) && !res.url) {
          throw new Error(`"${mod.id}" has no URL set`);
        }
        if ((sourceInfo === null || sourceInfo === void 0 ? void 0 : sourceInfo.type) !== 'bundle') {
          assign(res, 'md5', (_f = mod.attributes) === null || _f === void 0 ? void 0 : _f.fileMD5);
        }
        assign(res, 'fileSize', (_g = mod.attributes) === null || _g === void 0 ? void 0 : _g.fileSize);
        assign(res, 'logicalFilename', (_k = (_j = (_h = metaInfo === null || metaInfo === void 0 ? void 0 : metaInfo[0]) === null || _h === void 0 ? void 0 : _h.value) === null || _j === void 0 ? void 0 : _j.logicalFileName) !== null && _k !== void 0 ? _k : (_l = mod.attributes) === null || _l === void 0 ? void 0 : _l.logicalFileName);
        if ((sourceInfo === null || sourceInfo === void 0 ? void 0 : sourceInfo.updatePolicy) !== undefined) {
          assign(res, 'updatePolicy', sourceInfo.updatePolicy);
        }
        else if ((sourceInfo === null || sourceInfo === void 0 ? void 0 : sourceInfo.type) === 'bundle') {
          assign(res, 'updatePolicy', 'exact');
        }
        else {
          if (versionMatcher === '*') {
            assign(res, 'updatePolicy', 'latest');
          }
          else if ((versionMatcher === undefined)
            || versionMatcher.endsWith('+prefer')) {
            assign(res, 'updatePolicy', 'prefer');
          }
          else {
            assign(res, 'updatePolicy', 'exact');
          }
        }
        if ((res.md5 === undefined)
        && (res.logicalFilename === undefined)
        && (res.fileExpression === undefined)
        && (((_m = mod.attributes) === null || _m === void 0 ? void 0 : _m.fileName) !== undefined)) {
          assign(res, 'fileExpression', sanitizeExpression(mod.attributes.fileName));
        }
        assign(res, 'tag', tag);
        return res;
      }
      function generateCollection(info, mods, modRules) {
        return {
          info,
          mods,
          modRules,
        };
      }
      exports.generateCollection = generateCollection;
      async function rulesToCollectionMods(api, collection, resolvedRules, mods, stagingPath, game, collectionInfo, bundleTags, onProgress, onError) {
        let _a;
        let total = resolvedRules.length;
        let finished = 0;
        const collectionPath = path.join(stagingPath, collection.installationPath);
        await vortex_api_1.fs.removeAsync(path.join(collectionPath, constants_1.BUNDLED_PATH));
        await vortex_api_1.fs.removeAsync(path.join(collectionPath, constants_1.PATCHES_PATH));
        await vortex_api_1.fs.ensureDirAsync(path.join(collectionPath, constants_1.BUNDLED_PATH));
        await vortex_api_1.fs.ensureDirAsync(path.join(collectionPath, constants_1.PATCHES_PATH));
        const state = api.getState();
        const downloads = state.persistent.downloads.files;
        const downloadPath = vortex_api_1.selectors.downloadPathForGame(state, game.id);
        const fileOverridesIds = new Set(Object.keys((_a = collectionInfo.fileOverrides) !== null && _a !== void 0 ? _a : {})
          .filter(modId => collectionInfo.fileOverrides[modId]));
        const result = await Promise.all(resolvedRules.map(async (resolvedRule) => {
          let _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
          const { mod, rule } = resolvedRule;
          const fileName = (_a = downloads[mod.archiveId]) === null || _a === void 0 ? void 0 : _a.localPath;
          const refMD5 = (((_c = (_b = collectionInfo.source) === null || _b === void 0 ? void 0 : _b[mod.id]) === null || _c === void 0 ? void 0 : _c.type) === 'bundle')
            ? undefined
            : (_d = mod.attributes) === null || _d === void 0 ? void 0 : _d.fileMD5;
          const meta = await api.lookupModMeta({
            fileName,
            filePath: fileName !== undefined ? path.join(downloadPath, fileName) : undefined,
            fileMD5: refMD5,
            fileSize: (_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.fileSize,
            gameId: game.id,
          });
          const modName = vortex_api_1.util.renderModName(mod, { version: false });
          try {
            const source = deduceSource(mod, (_f = collectionInfo.source) === null || _f === void 0 ? void 0 : _f[mod.id], rule.reference.versionMatch, meta, bundleTags[mod.id]);
            let hashes;
            let choices;
            let entries = [];
            const installMode = (_h = (_g = collectionInfo.installMode) === null || _g === void 0 ? void 0 : _g[mod.id]) !== null && _h !== void 0 ? _h : 'fresh';
            const modPath = path.join(stagingPath, mod.installationPath);
            if (installMode === 'clone') {
              await (0, checksumMatcher_1.matchChecksums)(api, game.id, mod.id);
              await (0, turbowalk_1.default)(modPath, async (input) => {
                entries = [].concat(entries, input);
              }, {});
              hashes = await Promise.all(entries
                .filter(iter => !iter.isDirectory)
                .map(async (iter) => ({
                  path: path.relative(modPath, iter.filePath),
                  md5: await (0, util_2.fileMD5Async)(iter.filePath),
                })));
              onProgress(undefined, modName);
              ++finished;
            }
            else if (installMode === 'choices') {
              choices = (_j = mod === null || mod === void 0 ? void 0 : mod.attributes) === null || _j === void 0 ? void 0 : _j.installerChoices;
              --total;
            }
            else {
              --total;
            }
            let patches;
            if (((_k = collectionInfo.saveEdits) === null || _k === void 0 ? void 0 : _k[mod.id]) === true) {
              const destPath = path.join(collectionPath, constants_1.PATCHES_PATH, modName);
              await vortex_api_1.fs.ensureDirWritableAsync(destPath);
              patches = await (0, binaryPatching_1.scanForDiffs)(api, game.id, mod.id, destPath, onProgress);
            }
            if (((_m = (_l = collectionInfo.source) === null || _l === void 0 ? void 0 : _l[mod.id]) === null || _m === void 0 ? void 0 : _m.type) === 'bundle') {
              const tlFiles = await vortex_api_1.fs.readdirAsync(modPath);
              const generatedName = `Bundled - ${vortex_api_1.util.sanitizeFilename(vortex_api_1.util.renderModName(mod, { version: true }))}`;
              const destPath = path.join(collectionPath, constants_1.BUNDLED_PATH, generatedName);
              try {
                await vortex_api_1.fs.removeAsync(destPath);
              }
              catch (err) {
                if (err.code !== 'ENOENT') {
                  throw err;
                }
              }
              await Promise.all(tlFiles.map(async (name) => {
                await vortex_api_1.fs.copyAsync(path.join(modPath, name), path.join(destPath, name));
              }));
              source.fileExpression = generatedName;
              let totalSize = 0;
              await (0, turbowalk_1.default)(destPath, items => totalSize += items.reduce((sub, entry) => sub + entry.size, 0));
              source.fileSize = totalSize;
            }
            onProgress(Math.floor((finished / total) * 100), modName);
            const dlGame = (((_o = mod.attributes) === null || _o === void 0 ? void 0 : _o.downloadGame) !== undefined)
              ? vortex_api_1.util.getGame(mod.attributes.downloadGame)
              : game;
            const domainName = (dlGame !== undefined)
              ? vortex_api_1.util.nexusGameId(dlGame) : (_p = mod.attributes) === null || _p === void 0 ? void 0 : _p.downloadGame;
            const res = {
              name: modName,
              version: (_r = (_q = mod.attributes) === null || _q === void 0 ? void 0 : _q.version) !== null && _r !== void 0 ? _r : '1.0.0',
              optional: rule.type === 'recommends',
              domainName,
              source,
              hashes,
              choices,
              patches,
              instructions: !!((_s = collectionInfo.instructions) === null || _s === void 0 ? void 0 : _s[mod.id])
                ? (_t = collectionInfo.instructions) === null || _t === void 0 ? void 0 : _t[mod.id]
                : undefined,
              author: (_u = mod.attributes) === null || _u === void 0 ? void 0 : _u.author,
              details: {
                category: vortex_api_1.util.resolveCategoryName((_v = mod.attributes) === null || _v === void 0 ? void 0 : _v.category, state),
                type: mod.type,
              },
              phase: (_x = (_w = rule.extra) === null || _w === void 0 ? void 0 : _w['phase']) !== null && _x !== void 0 ? _x : 0,
              fileOverrides: fileOverridesIds.has(mod.id) ? mod.fileOverrides : undefined,
            };
            return res;
          }
          catch (err) {
            --total;
            onError('failed to pack "{{modName}}": {{error}}', {
              modName, error: err.message, stack: err.stack,
            }, (_y = err['mayIgnore']) !== null && _y !== void 0 ? _y : true);
            if (err instanceof errors_1.ReplicateHashMismatchError) {
              api.showDialog('error', 'Collection export failed', {
                bbcode: '"{{modName}}" cannot be exported using the replicate install mode.[br][/br][br][/br]The hashes of '
                        + 'the below files in your staging folder do not match the hashes of the files in the mod\'s '
                        + 'archive, which is guaranteed to cause issues for the end user.[br][/br][br][/br] Please consider using '
                        + 'binary patching or bundle your changes instead.',
                parameters: {
                  modName: vortex_api_1.util.renderModName(mod),
                },
                message: err.affectedFiles.map(file => vortex_api_1.util.sanitizeFilename(file)).join('\n'),
                options: {
                  order: ['bbcode', 'message'],
                }
              }, [
                {
                  label: 'Close',
                },
              ], 'replicate-hash-mismatch-error-dialog');
            }
            return undefined;
          }
        }));
        return result.filter(mod => (mod !== undefined) && (Object.keys(mod.source).length > 0));
      }
      function makeBiDirRule(source, rule) {
        if (rule === undefined) {
          return undefined;
        }
        return {
          type: rule.type,
          reference: rule.reference,
          source,
        };
      }
      exports.makeBiDirRule = makeBiDirRule;
      function makeTransferrable(mods, collection, rule) {
        let newRef = { ...rule.reference };
        const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
        if ((rule.reference.fileMD5 === undefined)
        && (rule.reference.logicalFileName === undefined)
        && (rule.reference.fileExpression === undefined)) {
          if (rule.reference.id === undefined) {
            (0, vortex_api_1.log)('warn', 'invalid rule couldn\'t be included in the collection', JSON.stringify(rule));
            return undefined;
          }
          if (mod === undefined) {
            (0, vortex_api_1.log)('warn', 'mod enabled in collection isn\'t installed', JSON.stringify(rule));
            return undefined;
          }
          newRef = vortex_api_1.util.makeModReference(mod);
        }
        if (mod !== undefined) {
          const mpRule = collection.rules.find(iter => vortex_api_1.util.testModReference(mod, iter.reference));
          if ((mpRule !== undefined) && ((mpRule.reference.versionMatch === undefined)
            || (mpRule.reference.versionMatch === '*')
            || (mpRule.reference.versionMatch.startsWith('>=')))) {
            newRef.versionMatch = '*';
          }
        }
        return {
          type: rule.type,
          fileList: rule.fileList,
          comment: rule.comment,
          reference: newRef,
        };
      }
      function ruleEnabled(rule, mods, collection) {
        let _a, _b, _c, _d;
        if (rule === undefined) {
          return false;
        }
        const ruleEx = {
          ...rule,
          sourceName: (0, util_1.renderReference)(rule.source, mods),
          referenceName: (0, util_1.renderReference)(rule.reference, mods),
        };
        const id = (0, util_1.ruleId)(ruleEx);
        return (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.rule) === null || _c === void 0 ? void 0 : _c[id]) !== null && _d !== void 0 ? _d : true;
      }
      function extractModRules(collectionRules, collection, mods, collectionAttributes, bundleTags) {
        return collectionRules.reduce((prev, resolvedRule) => {
          let _a, _b;
          const { mod } = resolvedRule;
          const source = vortex_api_1.util.makeModReference(mod);
          const sourceOrig = JSON.parse(JSON.stringify(source));
          const mpRule = collection.rules.find(iter => vortex_api_1.util.testModReference(mod, iter.reference));
          if ((mpRule !== undefined) && ((mpRule.reference.versionMatch === undefined)
            || (mpRule.reference.versionMatch === '*')
            || (mpRule.reference.versionMatch.startsWith('>=')))) {
            source.versionMatch = '*';
          }
          if (((_b = (_a = collectionAttributes.source) === null || _a === void 0 ? void 0 : _a[mod.id]) === null || _b === void 0 ? void 0 : _b.type) === 'bundle') {
            source.fileMD5 = undefined;
            source.tag = bundleTags[mod.id];
          }
          const includedRules = (mod.rules || [])
            .filter(rule => !['requires', 'recommends'].includes(rule.type));
          return [].concat(prev, includedRules.map((input) => {
            let _a, _b, _c, _d;
            if (((_a = input.extra) === null || _a === void 0 ? void 0 : _a['automatic']) === true) {
              return undefined;
            }
            const target = JSON.parse(JSON.stringify(input));
            const targetRef = vortex_api_1.util.findModByRef(target.reference, mods);
            const targetId = (_b = targetRef === null || targetRef === void 0 ? void 0 : targetRef.id) !== null && _b !== void 0 ? _b : target.reference.idHint;
            const targetRule = makeTransferrable(mods, collection, target);
            if (((_d = (_c = collectionAttributes.source) === null || _c === void 0 ? void 0 : _c[targetId]) === null || _d === void 0 ? void 0 : _d.type) === 'bundle') {
              target.reference.fileMD5 = undefined;
              if (targetRule !== undefined) {
                targetRule.reference.tag = bundleTags[targetId];
              }
            }
            if ((targetRule === undefined)
                || !ruleEnabled(makeBiDirRule(sourceOrig, targetRule), mods, collection)) {
              return undefined;
            }
            return makeBiDirRule(source, targetRule);
          }));
        }, [])
          .filter(rule => rule !== undefined);
      }
      function collectionModToRule(knownGames, mod) {
        let _a, _b, _c, _d;
        const downloadHint = ['manual', 'browse', 'direct'].includes(mod.source.type)
          ? {
            url: mod.source.url,
            instructions: mod.source.instructions,
            mode: mod.source.type,
          }
          : undefined;
        const coerced = vortex_api_1.util.coerceToSemver(mod.version);
        let versionMatch = !!coerced
          ? `>=${coerced !== null && coerced !== void 0 ? coerced : '0.0.0'}+prefer`
          : vortex_api_1.util.coerceToSemver(mod.version);
        const { updatePolicy } = mod.source;
        if ((updatePolicy === 'exact')
        || (mod.source.type === 'bundle')
        || (mod.hashes !== undefined)) {
          versionMatch = !!coerced ? coerced : vortex_api_1.util.coerceToSemver(mod.version);
        }
        else if (updatePolicy === 'latest') {
          versionMatch = '*';
        }
        const refMD5 = (mod.source.type === 'bundle')
          ? undefined
          : mod.source.md5;
        const fileExpression = (updatePolicy === 'exact') || (mod.source.logicalFilename === undefined)
          ? mod.source.fileExpression
          : undefined;
        const reference = {
          description: mod.name,
          fileMD5: refMD5,
          gameId: vortex_api_1.util.convertGameIdReverse(knownGames, mod.domainName),
          fileSize: mod.source.fileSize,
          versionMatch,
          logicalFileName: mod.source.logicalFilename,
          fileExpression,
          tag: (_a = mod.source.tag) !== null && _a !== void 0 ? _a : (0, shortid_1.generate)(),
        };
        if (['latest', 'prefer'].includes(updatePolicy)) {
          reference['md5Hint'] = mod.source.md5;
        }
        if (mod.source.type === 'nexus') {
          if (!mod.source.modId || !mod.source.fileId) {
            const err = new Error('Invalid nexus repo specification');
            err['mod'] = mod;
            throw err;
          }
          reference['repo'] = {
            repository: 'nexus',
            gameId: mod.domainName,
            modId: mod.source.modId.toString(),
            fileId: mod.source.fileId.toString(),
            campaign: 'collection',
          };
        }
        const res = {
          type: mod.optional ? 'recommends' : 'requires',
          reference,
          fileList: mod.hashes,
          installerChoices: mod.choices,
          downloadHint,
          extra: {
            author: mod.author,
            type: (_b = mod.details) === null || _b === void 0 ? void 0 : _b.type,
            category: (_c = mod.details) === null || _c === void 0 ? void 0 : _c.category,
            version: mod.version,
            url: mod.source.url,
            name: mod.name,
            instructions: !!mod.instructions
              ? mod.instructions
              : undefined,
            phase: (_d = mod.phase) !== null && _d !== void 0 ? _d : 0,
            patches: mod.patches,
            fileOverrides: mod.fileOverrides,
          },
        };
        if (mod.source.type === 'bundle') {
          res.extra.localPath = path.join('bundled', mod.source.fileExpression);
        }
        return res;
      }
      exports.collectionModToRule = collectionModToRule;
      async function modToCollection(api, gameId, stagingPath, collection, mods, onProgress, onError) {
        let _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const state = api.getState();
        if (vortex_api_1.selectors.activeGameId(state) !== gameId) {
          return Promise.reject(new Error('Can only export collection for the active profile'));
        }
        const includedMods = collection.rules
          .map(rule => {
            let id = rule.reference.id;
            if (id === undefined) {
              const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
              if (mod !== undefined) {
                id = mod.id;
              }
            }
            return id;
          })
          .filter(id => id !== undefined);
        const missing = includedMods.find(modId => mods[modId] === undefined);
        if (missing !== undefined) {
          return Promise.reject(new Error('Can only export collections that are fully installed'));
        }
        const exts = (0, extension_1.findExtensions)(state, gameId);
        const extData = {};
        for (const ext of exts) {
          Object.assign(extData, await ext.generate(gameId, includedMods, collection));
        }
        const gameSpecific = await (0, gameSupport_1.generateGameSpecifics)(state, gameId, stagingPath, includedMods, mods);
        const game = vortex_api_1.util.getGame(gameId);
        const discovery = vortex_api_1.selectors.discoveryByGame(state, gameId);
        const gameVersions = (game !== undefined)
          ? [await game.getInstalledVersion(discovery)]
          : [];
        const collectionAttributes = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) !== null && _b !== void 0 ? _b : {};
        const collectionConfig = await (0, collectionConfig_1.generateConfig)({ gameId, collectionMod: collection });
        const collectionInfo = {
          author: (_d = (_c = collection.attributes) === null || _c === void 0 ? void 0 : _c.uploader) !== null && _d !== void 0 ? _d : 'Anonymous',
          authorUrl: (_f = (_e = collection.attributes) === null || _e === void 0 ? void 0 : _e.authorURL) !== null && _f !== void 0 ? _f : '',
          name: vortex_api_1.util.renderModName(collection),
          description: (_h = (_g = collection.attributes) === null || _g === void 0 ? void 0 : _g.shortDescription) !== null && _h !== void 0 ? _h : '',
          installInstructions: (_j = collectionAttributes.installInstructions) !== null && _j !== void 0 ? _j : '',
          domainName: vortex_api_1.util.nexusGameId(game),
          gameVersions,
        };
        const bundleTags = includedMods.reduce((prev, modId) => {
          prev[modId] = (0, shortid_1.generate)();
          return prev;
        }, {});
        const resolvedRules = collection.rules.reduce((prev, rule) => {
          const mod = (rule.reference.id !== undefined)
            ? mods[rule.reference.id]
            : vortex_api_1.util.findModByRef(rule.reference, mods);
          if (mod === undefined) {
            onError('Not packaging mod that isn\'t installed: "{{id}}"', { id: rule.reference.id }, true);
          }
          else if (mod.type === constants_1.MOD_TYPE) {
          }
          else {
            prev.push({ mod, rule });
          }
          return prev;
        }, []);
        const modRules = extractModRules(resolvedRules, collection, mods, collectionAttributes, bundleTags);
        const res = {
          info: collectionInfo,
          mods: await rulesToCollectionMods(api, collection, resolvedRules, mods, stagingPath, game, collectionAttributes, bundleTags, onProgress, onError),
          modRules,
          ...extData,
          ...gameSpecific,
          collectionConfig: { ...collectionConfig },
        };
        return res;
      }
      exports.modToCollection = modToCollection;
      async function createTweaksFromProfile(api, profile, mods, existingId) {
        let _a;
        return (0, initweaks_1.importTweaks)(api, profile, api.getState().persistent.mods[profile.gameId], (_a = api.getState().persistent.mods[profile.gameId]) === null || _a === void 0 ? void 0 : _a[existingId]);
      }
      function createRulesFromProfile(profile, mods, existingRules, existingId, filterFunc, isQuickCollection) {
        let _a;
        return Object.keys((_a = profile.modState) !== null && _a !== void 0 ? _a : {})
          .filter(modId => {
            let _a, _b;
            return ((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[modId]) === null || _b === void 0 ? void 0 : _b.enabled)
            && (mods[modId] !== undefined)
            && (modId !== existingId)
            && (mods[modId].type !== constants_1.MOD_TYPE)
            && filterFunc(mods[modId]);
          })
          .map(modId => {
            let versionMatch;
            const oldRule = existingRules
              .find(iter => vortex_api_1.util.testModReference(mods[modId], iter.reference));
            if ((oldRule !== undefined) && (oldRule.reference.versionMatch !== undefined)) {
              versionMatch = (oldRule.reference.versionMatch === '*')
                ? '*'
                : mods[modId].attributes.version;
            }
            if (isQuickCollection) {
              versionMatch = mods[modId].attributes.version;
            }
            return {
              type: 'requires',
              reference: {
                id: modId,
                archiveId: mods[modId].archiveId,
                versionMatch,
              },
            };
          });
      }
      function makeCollectionId(baseId) {
        return `vortex_collection_${baseId}`;
      }
      exports.makeCollectionId = makeCollectionId;
      function deduceCollectionAttributes(collectionMod, collection, mods) {
        let _a;
        const res = {
          installMode: {},
          instructions: {},
          source: {},
          saveEdits: {},
        };
        ((_a = collectionMod.rules) !== null && _a !== void 0 ? _a : []).forEach(rule => {
          let _a, _b, _c, _d, _e, _f, _g;
          const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
          if (mod === undefined) {
            return;
          }
          res.installMode[mod.id] = (rule.installerChoices !== undefined)
            ? 'choices'
            : (rule.fileList !== undefined)
              ? 'clone'
              : 'fresh';
          res.instructions[mod.id] = (_a = rule.extra) === null || _a === void 0 ? void 0 : _a.instructions;
          res.source[mod.id] = {
            type: (_c = (_b = rule.downloadHint) === null || _b === void 0 ? void 0 : _b.mode) !== null && _c !== void 0 ? _c : ((((_d = rule.reference.repo) === null || _d === void 0 ? void 0 : _d.repository) === 'nexus') ? 'nexus' : 'bundle'),
            url: (_e = rule.downloadHint) === null || _e === void 0 ? void 0 : _e.url,
            instructions: (_f = rule.downloadHint) === null || _f === void 0 ? void 0 : _f.instructions,
          };
          res.saveEdits[mod.id] = ((_g = rule.extra) === null || _g === void 0 ? void 0 : _g.patches) !== undefined;
        });
        return res;
      }
      async function cloneCollection(api, gameId, id, sourceId) {
        let _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const state = api.getState();
        const t = api.translate;
        const { userInfo } = (_a = state.persistent['nexus']) !== null && _a !== void 0 ? _a : {};
        const mods = ((_b = state.persistent.mods[gameId]) !== null && _b !== void 0 ? _b : {});
        const existingCollection = mods[sourceId];
        const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
        let collection;
        try {
          const collectionData = await vortex_api_1.fs.readFileAsync(path.join(stagingPath, existingCollection.installationPath, 'collection.json'), { encoding: 'utf-8' });
          collection = JSON.parse(collectionData);
        }
        catch (err) {
          api.showErrorNotification('Failed to clone collection', err);
          return undefined;
        }
        const ruleFilter = (rule) => {
          if (rule.ignored) {
            return false;
          }
          if (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined) {
            return false;
          }
          return true;
        };
        const ruleSimplify = (rule) => {
          const referencedMod = vortex_api_1.util.findModByRef(rule.reference, mods);
          return ({
            ...rule,
            reference: {
              archiveId: referencedMod.archiveId,
              id: referencedMod.id,
              idHint: referencedMod.id,
              versionMatch: rule.reference.versionMatch,
            },
          });
        };
        const ownCollection = ((_c = existingCollection.attributes) === null || _c === void 0 ? void 0 : _c.uploaderId) === (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId);
        let name = 'Copy of ' + ((_d = existingCollection.attributes) === null || _d === void 0 ? void 0 : _d.name);
        if (name.length > constants_1.MAX_COLLECTION_NAME_LENGTH) {
          name = name.slice(0, constants_1.MAX_COLLECTION_NAME_LENGTH) + '...';
        }
        const customFileName = ownCollection
          ? (_e = existingCollection.attributes) === null || _e === void 0 ? void 0 : _e.customFileName
          : t('Copy of {{name}}', { replace: { name: (_f = existingCollection.attributes) === null || _f === void 0 ? void 0 : _f.customFileName } });
        const ownCollectionAttributes = ownCollection ? ({
          pictureUrl: existingCollection.attributes.pictureUrl,
          uploader: userInfo.name,
          uploaderAvatar: existingCollection.attributes.uploaderAvatar,
        }) : {};
        const mod = {
          id,
          type: constants_1.MOD_TYPE,
          state: 'installed',
          attributes: {
            name,
            customFileName,
            version: ownCollection ? (_g = existingCollection.attributes) === null || _g === void 0 ? void 0 : _g.version : '0',
            installTime: new Date(),
            author: (_h = userInfo === null || userInfo === void 0 ? void 0 : userInfo.name) !== null && _h !== void 0 ? _h : 'Anonymous',
            uploader: (_j = userInfo === null || userInfo === void 0 ? void 0 : userInfo.name) !== null && _j !== void 0 ? _j : 'Anonymous',
            uploaderId: userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId,
            editable: true,
            collectionId: ownCollection ? (_k = existingCollection.attributes) === null || _k === void 0 ? void 0 : _k.collectionId : undefined,
            revisionId: ownCollection ? (_l = existingCollection.attributes) === null || _l === void 0 ? void 0 : _l.revisionId : undefined,
            collectionSlug: ownCollection ? (_m = existingCollection.attributes) === null || _m === void 0 ? void 0 : _m.collectionSlug : undefined,
            revisionNumber: ownCollection
              ? (((_o = existingCollection.attributes) === null || _o === void 0 ? void 0 : _o.revisionNumber) + 1) : undefined,
            collection: deduceCollectionAttributes(existingCollection, collection, mods),
            ...ownCollectionAttributes,
          },
          installationPath: id,
          rules: existingCollection.rules
            .filter(ruleFilter)
            .map(ruleSimplify),
        };
        try {
          await new Promise((resolve, reject) => {
            api.events.emit('create-mod', gameId, mod, (error) => {
              if (error !== null) {
                reject(error);
              }
              else {
                resolve();
              }
            });
          });
          const deployPath = vortex_api_1.selectors.installPathForGame(state, gameId);
          const sourcePath = path.join(deployPath, sourceId);
          const clonePath = path.join(deployPath, id);
          const files = await vortex_api_1.fs.readdirAsync(sourcePath);
          for (const file of files) {
            await vortex_api_1.fs.copyAsync(path.join(sourcePath, file), path.join(clonePath, file));
          }
          const exts = (0, extension_1.findExtensions)(api.getState(), gameId);
          for (const ext of exts) {
            if (ext.clone !== undefined) {
              await ext.clone(gameId, collection, existingCollection, mod);
            }
          }
          return id;
        }
        catch (err) {
          api.showErrorNotification('Failed to clone collection', err);
          return undefined;
        }
      }
      exports.cloneCollection = cloneCollection;
      async function createCollection(api, gameId, id, name, rules) {
        let _a, _b, _c, _d, _e, _f, _g, _h;
        const state = api.store.getState();
        const mod = {
          id,
          type: constants_1.MOD_TYPE,
          state: 'installed',
          attributes: {
            name,
            version: '0',
            installTime: new Date(),
            author: (_c = (_b = (_a = state.persistent['nexus']) === null || _a === void 0 ? void 0 : _a.userInfo) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : 'Anonymous',
            uploader: (_f = (_e = (_d = state.persistent['nexus']) === null || _d === void 0 ? void 0 : _d.userInfo) === null || _e === void 0 ? void 0 : _e.name) !== null && _f !== void 0 ? _f : 'Anonymous',
            uploaderId: (_h = (_g = state.persistent['nexus']) === null || _g === void 0 ? void 0 : _g.userInfo) === null || _h === void 0 ? void 0 : _h.user_id,
            editable: true,
            source: 'user-generated',
            recommendNewProfile: false,
          },
          installationPath: id,
          rules,
        };
        try {
          await new Promise((resolve, reject) => {
            api.events.emit('create-mod', gameId, mod, (error) => {
              if (error !== null) {
                reject(error);
              }
              else {
                resolve();
              }
            });
          });
        }
        catch (err) {
          api.showErrorNotification('Failed to create collection', err);
        }
      }
      exports.createCollection = createCollection;
      function updateCollection(api, gameId, mod, newRules) {
        let _a;
        api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, mod.id, 'editable', true));
        const removedRules = [];
        vortex_api_1.util.batchDispatch(api.store, ((_a = mod.rules) !== null && _a !== void 0 ? _a : []).reduce((prev, rule) => {
          if (newRules.find(iter => _.isEqual(rule, iter)) === undefined) {
            removedRules.push(rule);
            prev.push(vortex_api_1.actions.removeModRule(gameId, mod.id, rule));
          }
          return prev;
        }, []));
        vortex_api_1.util.batchDispatch(api.store, newRules.reduce((prev, rule) => {
          let _a;
          if (((_a = mod.rules) !== null && _a !== void 0 ? _a : []).find(iter => _.isEqual(rule, iter)) === undefined) {
            prev.push(vortex_api_1.actions.addModRule(gameId, mod.id, rule));
          }
          return prev;
        }, []));
      }
      function validateName(t, content) {
        const input = content.input[0].value || '';
        if ((input.length >= constants_1.MIN_COLLECTION_NAME_LENGTH)
        && (input.length <= constants_1.MAX_COLLECTION_NAME_LENGTH)) {
          return [];
        }
        else {
          return [{
            id: 'name',
            errorText: t('Name must be between {{min}}-{{max}} characters long', {
              replace: {
                min: constants_1.MIN_COLLECTION_NAME_LENGTH,
                max: constants_1.MAX_COLLECTION_NAME_LENGTH,
              },
            }),
            actions: ['Create'],
          }];
        }
      }
      exports.validateName = validateName;
      async function showQuickCollectionRestrictionsDialog(api) {
        let _a;
        const t = api.translate;
        const state = api.store.getState();
        const profileId = (_a = vortex_api_1.selectors.activeProfile(state)) === null || _a === void 0 ? void 0 : _a.id;
        if (!profileId) {
          return;
        }
        const restrictionsDialog = await api.showDialog('info', 'Quick Collection', {
          bbcode: t('Quick Collections create a backup of your mod list for easy import by another PC or mod manager. '
            + 'They can be created in a few clicks but do not include all the features of a "full" collection.[br][/br][br][/br]'
            + 'Your Quick Collection will include:[br][/br]'
            + '[list]'
            + '[*] All mods downloaded from Nexus Mods that are currently enabled and deployed.'
            + '[*] Installer choices for mods that support installers (such as FOMODs).'
            + '[*] File conflict rules.'
            + '[*] Load order rules.'
            + '[/list][br][/br]'
            + 'Quick Collections do NOT include:[br][/br]'
            + '[list]'
            + '[*] Mods from sources other than Nexus Mods.'
            + '[*] Alterations you have made mods after installing them.'
            + '[*] Outputs of automated tools generated on your PC (FNIS, Script Merger, etc).'
            + '[*] Mods that you have created on your PC and added to Vortex.'
            + '[/list][br][/br]'
            + 'If you are using this feature migrate your mod list to the Nexus Mods app, see the '
            + `[url=https://nexus-mods.github.io/NexusMods.App/users/gettingstarted/MovingToTheApp/]full guide here.[/url]`),
        }, [
          { label: 'Cancel' },
          { label: 'Proceed' },
        ]);
        return (restrictionsDialog.action === 'Cancel')
          ? Promise.reject(new vortex_api_1.util.UserCanceled())
          : Promise.resolve();
      }
      exports.showQuickCollectionRestrictionsDialog = showQuickCollectionRestrictionsDialog;
      async function createCollectionFromProfile(api, profileId, forceName) {
        let _a, _b, _c, _d, _e;
        const state = api.store.getState();
        const profile = state.persistent.profiles[profileId];
        const isQuickCollection = forceName !== undefined;
        const id = (isQuickCollection)
          ? makeCollectionId(`${profileId}_${(0, shortid_1.generate)()}`)
          : makeCollectionId(profileId);
        const mod = (_a = state.persistent.mods[profile.gameId]) === null || _a === void 0 ? void 0 : _a[id];
        const isNexusSourced = (m) => { let _a; return (((_a = m === null || m === void 0 ? void 0 : m.attributes) === null || _a === void 0 ? void 0 : _a.source) === 'nexus'); };
        const isGeneratedMod = (m) => { let _a; return (((_a = m === null || m === void 0 ? void 0 : m.attributes) === null || _a === void 0 ? void 0 : _a.generated) === true); };
        const filterFunc = (m) => forceName ? (isNexusSourced(m) && !isGeneratedMod(m)) : true;
        const rules = createRulesFromProfile(profile, (_b = state.persistent.mods[profile.gameId]) !== null && _b !== void 0 ? _b : {}, (_c = mod === null || mod === void 0 ? void 0 : mod.rules) !== null && _c !== void 0 ? _c : [], mod === null || mod === void 0 ? void 0 : mod.id, filterFunc, isQuickCollection);
        let name = forceName !== null && forceName !== void 0 ? forceName : profile.name;
        const uploadLabel = 'Create and Upload';
        let wantsToUpload = false;
        if (mod === undefined) {
          const t = api.translate;
          const result = await api.showDialog('question', 'New collection from profile', {
            text: 'Create a collection containing the mods enabled in your current profile.',
            input: [{
              id: 'name',
              label: 'Please enter a name for your new collection',
              type: 'text',
              value: name,
            }],
            condition: content => validateName(t, content),
          }, [
            { label: 'Cancel' },
            { label: forceName ? uploadLabel : 'Create', default: true },
          ]);
          const cancelled = result.action === 'Cancel';
          if (cancelled) {
            throw new vortex_api_1.util.UserCanceled();
          }
          wantsToUpload = result.action === uploadLabel;
          name = result.input['name'];
          await createCollection(api, profile.gameId, id, name, rules);
          await createTweaksFromProfile(api, profile, (_d = state.persistent.mods[profile.gameId]) !== null && _d !== void 0 ? _d : {}, id);
        }
        else {
          name = (_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.name;
          updateCollection(api, profile.gameId, mod, rules);
        }
        return { id, name, updated: mod !== undefined, wantsToUpload };
      }
      exports.createCollectionFromProfile = createCollectionFromProfile;


/***/ }),

/***/ "./src/util/util.ts":
/*!**************************!*\
  !*** ./src/util/util.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.uploadCollection = exports.isEmpty = exports.walkPath = exports.fileMD5Async = exports.calculateCollectionSize = exports.isRelevant = exports.modRuleId = exports.ruleId = exports.renderReference = exports.md5sum = exports.getUnfulfilledNotificationId = exports.bbProm = exports.makeProgressFunction = void 0;
      const PromiseBB = __webpack_require__(/*! bluebird */ "bluebird");
      const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const collectionExport_1 = __webpack_require__(/*! ../collectionExport */ "./src/collectionExport.ts");
      const vortexmt_1 = __webpack_require__(/*! vortexmt */ "vortexmt");
      const turbowalk_1 = __webpack_require__(/*! turbowalk */ "turbowalk");
      const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
      function makeProgressFunction(api) {
        const notificationId = api.sendNotification({
          type: 'activity',
          title: 'Building Collection',
          message: '',
          progress: 0,
        });
        let notiPerc = 0;
        let notiText = '';
        const items = new Set();
        const progress = (percent, text) => {
          let change = false;
          if ((percent !== undefined)) {
            if (percent > notiPerc) {
              change = true;
              notiPerc = percent;
            }
            if (text !== undefined) {
              items.delete(text);
              if (items.size > 0) {
                const itemList = Array.from(items);
                const newText = itemList[itemList.length - 1];
                if (newText !== notiText) {
                  change = true;
                  notiText = newText;
                }
              }
            }
          }
          if ((percent === undefined) && (text !== undefined) && (text !== notiText)) {
            change = true;
            notiText = text;
            if (percent === undefined) {
              items.add(text);
            }
          }
          if (change) {
            api.sendNotification({
              id: notificationId,
              type: 'activity',
              title: 'Building Collection',
              progress: notiPerc,
              message: notiText,
            });
          }
        };
        const progressEnd = () => {
          api.dismissNotification(notificationId);
        };
        return { progress, progressEnd };
      }
      exports.makeProgressFunction = makeProgressFunction;
      function bbProm(func) {
        return (...args) => PromiseBB.resolve(func(...args));
      }
      exports.bbProm = bbProm;
      function getUnfulfilledNotificationId(collectionId) {
        return `collection-incomplete-${collectionId}`;
      }
      exports.getUnfulfilledNotificationId = getUnfulfilledNotificationId;
      function md5sum(input) {
        const hash = (0, crypto_1.createHash)('md5');
        hash.update(input);
        return hash.digest('hex');
      }
      exports.md5sum = md5sum;
      function renderReference(ref, mods) {
        const mod = vortex_api_1.util.findModByRef(ref, mods);
        return vortex_api_1.util.renderModReference(ref, mod);
      }
      exports.renderReference = renderReference;
      function ruleId(rule) {
        return md5sum(`${rule.sourceName}-${rule.type}-${rule.referenceName}`);
      }
      exports.ruleId = ruleId;
      function modRuleId(input) {
        return input.type + '_' + (input.reference.fileMD5
        || input.reference.id
        || input.reference.logicalFileName
        || input.reference.fileExpression
        || input.reference.description);
      }
      exports.modRuleId = modRuleId;
      function isRelevant(mod) {
        if (!!mod.state) {
          return true;
        }
        if (mod.collectionRule['ignored']) {
          return false;
        }
        if (mod.collectionRule.type !== 'requires') {
          return false;
        }
        return true;
      }
      exports.isRelevant = isRelevant;
      function calculateCollectionSize(mods) {
        return Object.values(mods).reduce((prev, mod) => {
          let _a, _b, _c;
          if (!isRelevant(mod)) {
            return prev;
          }
          const size = (_c = (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.fileSize) !== null && _b !== void 0 ? _b : mod.collectionRule.reference.fileSize) !== null && _c !== void 0 ? _c : 0;
          return prev + size;
        }, 0);
      }
      exports.calculateCollectionSize = calculateCollectionSize;
      async function fileMD5Async(fileName) {
        return new Promise((resolve, reject) => {
          (0, vortexmt_1.fileMD5)(fileName, (err, result) => (err !== null) ? reject(err) : resolve(result), () => null);
        });
      }
      exports.fileMD5Async = fileMD5Async;
      async function walkPath(dirPath, walkOptions) {
        walkOptions = walkOptions || { skipLinks: true, skipHidden: true, skipInaccessible: true };
        const walkResults = [];
        return new Promise(async (resolve, reject) => {
          await (0, turbowalk_1.default)(dirPath, async (entries) => {
            for (const entry of entries) {
              const md5 = await fileMD5Async(entry.filePath);
              const extendedEntry = { ...entry, fileMD5: md5 };
              walkResults.push(extendedEntry);
            }
            return Promise.resolve();
          }, walkOptions).catch(err => err.code === 'ENOENT' ? Promise.resolve() : Promise.reject(err));
          return resolve(walkResults);
        });
      }
      exports.walkPath = walkPath;
      function isEmpty(value) {
        return (!value)
        || (value.hasOwnProperty('length') && value.length === 0)
        || (value.constructor === Object && Object.keys(value).length === 0);
      }
      exports.isEmpty = isEmpty;
      async function uploadCollection(api, profileId, collectionId) {
        let _a, _b;
        if (!profileId || !collectionId) {
          return;
        }
        const state = api.getState();
        const profile = vortex_api_1.selectors.profileById(state, profileId);
        const userInfo = vortex_api_1.util.getSafe(state, ['persistent', 'nexus', 'userInfo'], undefined);
        if (userInfo === undefined) {
          api.showErrorNotification('Not logged in', 'You have to be logged into nexusmods.com to upload collections.');
          return;
        }
        const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', profile.gameId], {});
        if (mods[collectionId] === undefined) {
          return;
        }
        api.events.emit('analytics-track-click-event', 'Collections', 'Upload collection');
        const missing = ((_b = (_a = mods[collectionId]) === null || _a === void 0 ? void 0 : _a.rules) !== null && _b !== void 0 ? _b : []).filter(rule => ['requires', 'recommends'].includes(rule.type)
        && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined));
        if (missing.length > 0) {
          await api.showDialog('error', 'Collection isn\'t fully installed', {
            text: 'You can only upload collections that are fully installed on this system.\n'
                + 'If you have removed mods that were part of this collection you may want to remove '
                + 'them from the collection as well. If this collection is connected to a '
                + 'profile you can simply update from that.',
            message: missing.map(rule => vortex_api_1.util.renderModReference(rule.reference)).join('\n'),
          }, [
            { label: 'Close' },
          ]);
          return;
        }
        const choice = await api.showDialog('question', 'Share on Nexus Mods', {
          bbcode: 'You are about to upload "{{collectionName}}" to Nexus Mods in a draft state. '
            + 'You will be able to add additional metadata and media before sharing it with '
            + 'the community.'
            + '\n\n'
            + 'Please ensure that your collection complies with our '
            + `[url=${constants_1.TOS_URL}]Collections Guidelines[/url] before publishing.`,
          parameters: {
            collectionName: vortex_api_1.util.renderModName(mods[collectionId]),
          },
        }, [
          { label: 'Cancel' },
          { label: 'Upload' },
        ]);
        if (choice.action === 'Upload') {
          try {
            const { slug, revisionNumber } = await (0, collectionExport_1.doExportToAPI)(api, profile.gameId, collectionId, userInfo.name);
            if ((slug !== undefined) && (revisionNumber !== undefined)) {
              api.sendNotification({
                type: 'success',
                message: 'Collection submitted',
                actions: [
                  {
                    title: 'Open in Browser', action: () => {
                      const game = vortex_api_1.selectors.gameById(api.getState(), profile.gameId);
                      const domainName = vortex_api_1.util.nexusGameId(game);
                      const url = vortex_api_1.util.nexusModsURL([domainName, 'collections', slug, 'revisions', revisionNumber.toString()], {
                        campaign: vortex_api_1.util.Campaign.ViewCollection,
                        section: vortex_api_1.util.Section.Collections,
                      });
                      vortex_api_1.util.opn(url).catch(() => null);
                    },
                  },
                ],
              });
            }
          }
          catch (err) {
            if (!(err instanceof vortex_api_1.util.UserCanceled)
                && !(err instanceof vortex_api_1.util.ProcessCanceled)) {
              api.showErrorNotification('Failed to upload to API', err, {
                allowReport: false,
              });
            }
          }
        }
      }
      exports.uploadCollection = uploadCollection;


/***/ }),

/***/ "./src/validationCode/ICollection.validate.js":
/*!****************************************************!*\
  !*** ./src/validationCode/ICollection.validate.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";
      module.exports = validate10;module.exports["default"] = validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","anyOf":[{"$ref":"#/definitions/ICollection"}],"definitions":{"ICollection":{"type":"object","properties":{"plugins":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"enabled":{"type":"boolean"}},"required":["name"]}},"pluginRules":{"type":"object","properties":{"plugins":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"group":{"type":"string"},"after":{"type":"array","items":{"type":"string"}}},"required":["name"]}},"groups":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"group":{"type":"string"},"after":{"type":"array","items":{"type":"string"}}},"required":["name"]}}},"required":["plugins"]},"info":{"$ref":"#/definitions/ICollectionInfo"},"mods":{"type":"array","items":{"$ref":"#/definitions/ICollectionMod"}},"modRules":{"type":"array","items":{"$ref":"#/definitions/ICollectionModRule"}}},"required":["info","mods","modRules"]},"ICollectionInfo":{"type":"object","properties":{"author":{"type":"string"},"authorUrl":{"type":"string"},"name":{"type":"string"},"description":{"type":"string"},"domainName":{"type":"string"},"gameVersions":{"type":"array","items":{"type":"string"}}},"required":["author","authorUrl","name","description","domainName"]},"ICollectionMod":{"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"},"optional":{"type":"boolean"},"domainName":{"type":"string"},"source":{"$ref":"#/definitions/ICollectionSourceInfo"},"hashes":{},"choices":{},"patches":{"type":"object","additionalProperties":{"type":"string"}},"instructions":{"type":"string"},"author":{"type":"string"},"details":{"$ref":"#/definitions/ICollectionModDetails"},"phase":{"type":"number"},"fileOverrides":{"type":"array","items":{"type":"string"}}},"required":["name","version","optional","domainName","source"]},"ICollectionSourceInfo":{"type":"object","properties":{"type":{"$ref":"#/definitions/SourceType"},"url":{"type":"string"},"instructions":{"type":"string"},"modId":{"type":"number"},"fileId":{"type":"number"},"updatePolicy":{"$ref":"#/definitions/UpdatePolicy"},"adultContent":{"type":"boolean"},"md5":{"type":"string"},"fileSize":{"type":"number"},"logicalFilename":{"type":"string"},"fileExpression":{"type":"string"},"tag":{"type":"string"}},"required":["type"]},"SourceType":{"type":"string","enum":["browse","manual","direct","nexus","bundle"]},"UpdatePolicy":{"type":"string","enum":["exact","latest","prefer"]},"ICollectionModDetails":{"type":"object","properties":{"type":{"type":"string"},"category":{"type":"string"}}},"ICollectionModRule":{"type":"object","properties":{"source":{"$ref":"#/definitions/IModReference"},"type":{"$ref":"#/definitions/RuleType"},"reference":{"$ref":"#/definitions/IModReference"}},"required":["source","type","reference"]},"IModReference":{"type":"object","properties":{"fileMD5":{"type":"string"},"fileSize":{"type":"number"},"gameId":{"type":"string"},"versionMatch":{"type":"string"},"logicalFileName":{"type":"string"},"fileExpression":{"type":"string"},"id":{"type":"string"},"idHint":{"type":"string"},"md5Hint":{"type":"string"},"tag":{"type":"string"},"archiveId":{"type":"string"},"repo":{"type":"object","properties":{"gameId":{"type":"string"},"modId":{"type":"string"},"fileId":{"type":"string"},"repository":{"type":"string"},"campaign":{"type":"string"}},"required":["fileId","repository"]},"description":{"type":"string"},"instructions":{"type":"string"}}},"RuleType":{"type":"string","enum":["before","after","requires","conflicts","recommends","provides"]}},"exported":["ICollection"]};const schema12 = {"type":"object","properties":{"plugins":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"enabled":{"type":"boolean"}},"required":["name"]}},"pluginRules":{"type":"object","properties":{"plugins":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"group":{"type":"string"},"after":{"type":"array","items":{"type":"string"}}},"required":["name"]}},"groups":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"group":{"type":"string"},"after":{"type":"array","items":{"type":"string"}}},"required":["name"]}}},"required":["plugins"]},"info":{"$ref":"#/definitions/ICollectionInfo"},"mods":{"type":"array","items":{"$ref":"#/definitions/ICollectionMod"}},"modRules":{"type":"array","items":{"$ref":"#/definitions/ICollectionModRule"}}},"required":["info","mods","modRules"]};const schema13 = {"type":"object","properties":{"author":{"type":"string"},"authorUrl":{"type":"string"},"name":{"type":"string"},"description":{"type":"string"},"domainName":{"type":"string"},"gameVersions":{"type":"array","items":{"type":"string"}}},"required":["author","authorUrl","name","description","domainName"]};const schema14 = {"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"},"optional":{"type":"boolean"},"domainName":{"type":"string"},"source":{"$ref":"#/definitions/ICollectionSourceInfo"},"hashes":{},"choices":{},"patches":{"type":"object","additionalProperties":{"type":"string"}},"instructions":{"type":"string"},"author":{"type":"string"},"details":{"$ref":"#/definitions/ICollectionModDetails"},"phase":{"type":"number"},"fileOverrides":{"type":"array","items":{"type":"string"}}},"required":["name","version","optional","domainName","source"]};const schema18 = {"type":"object","properties":{"type":{"type":"string"},"category":{"type":"string"}}};const schema15 = {"type":"object","properties":{"type":{"$ref":"#/definitions/SourceType"},"url":{"type":"string"},"instructions":{"type":"string"},"modId":{"type":"number"},"fileId":{"type":"number"},"updatePolicy":{"$ref":"#/definitions/UpdatePolicy"},"adultContent":{"type":"boolean"},"md5":{"type":"string"},"fileSize":{"type":"number"},"logicalFilename":{"type":"string"},"fileExpression":{"type":"string"},"tag":{"type":"string"}},"required":["type"]};const schema16 = {"type":"string","enum":["browse","manual","direct","nexus","bundle"]};const schema17 = {"type":"string","enum":["exact","latest","prefer"]};const func0 = (__webpack_require__(/*! ./dummy */ "./src/validationCode/dummy.js")["default"]);function validate13(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(data && typeof data == "object" && !Array.isArray(data)){if(data.type === undefined){const err0 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "type"},message:"must have required property '"+"type"+"'",schema:schema15.required,parentSchema:schema15,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}if(data.type !== undefined){const data0 = data.type;if(typeof data0 !== "string"){const err1 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/SourceType/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema16.type,parentSchema:schema16,data:data0};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}if(!(((((data0 === "browse") || (data0 === "manual")) || (data0 === "direct")) || (data0 === "nexus")) || (data0 === "bundle"))){const err2 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/SourceType/enum",keyword:"enum",params:{allowedValues: schema16.enum},message:"must be equal to one of the allowed values",schema:schema16.enum,parentSchema:schema16,data:data0};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}}if(data.url !== undefined){const data1 = data.url;if(typeof data1 !== "string"){const err3 = {instancePath:instancePath+"/url",schemaPath:"#/properties/url/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.url.type,parentSchema:schema15.properties.url,data:data1};if(vErrors === null){vErrors = [err3];}else {vErrors.push(err3);}errors++;}}if(data.instructions !== undefined){const data2 = data.instructions;if(typeof data2 !== "string"){const err4 = {instancePath:instancePath+"/instructions",schemaPath:"#/properties/instructions/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.instructions.type,parentSchema:schema15.properties.instructions,data:data2};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}}if(data.modId !== undefined){const data3 = data.modId;if(!((typeof data3 == "number") && (isFinite(data3)))){const err5 = {instancePath:instancePath+"/modId",schemaPath:"#/properties/modId/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema15.properties.modId.type,parentSchema:schema15.properties.modId,data:data3};if(vErrors === null){vErrors = [err5];}else {vErrors.push(err5);}errors++;}}if(data.fileId !== undefined){const data4 = data.fileId;if(!((typeof data4 == "number") && (isFinite(data4)))){const err6 = {instancePath:instancePath+"/fileId",schemaPath:"#/properties/fileId/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema15.properties.fileId.type,parentSchema:schema15.properties.fileId,data:data4};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}}if(data.updatePolicy !== undefined){const data5 = data.updatePolicy;if(typeof data5 !== "string"){const err7 = {instancePath:instancePath+"/updatePolicy",schemaPath:"#/definitions/UpdatePolicy/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema17.type,parentSchema:schema17,data:data5};if(vErrors === null){vErrors = [err7];}else {vErrors.push(err7);}errors++;}if(!(((data5 === "exact") || (data5 === "latest")) || (data5 === "prefer"))){const err8 = {instancePath:instancePath+"/updatePolicy",schemaPath:"#/definitions/UpdatePolicy/enum",keyword:"enum",params:{allowedValues: schema17.enum},message:"must be equal to one of the allowed values",schema:schema17.enum,parentSchema:schema17,data:data5};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}}if(data.adultContent !== undefined){const data6 = data.adultContent;if(typeof data6 !== "boolean"){const err9 = {instancePath:instancePath+"/adultContent",schemaPath:"#/properties/adultContent/type",keyword:"type",params:{type: "boolean"},message:"must be boolean",schema:schema15.properties.adultContent.type,parentSchema:schema15.properties.adultContent,data:data6};if(vErrors === null){vErrors = [err9];}else {vErrors.push(err9);}errors++;}}if(data.md5 !== undefined){const data7 = data.md5;if(typeof data7 !== "string"){const err10 = {instancePath:instancePath+"/md5",schemaPath:"#/properties/md5/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.md5.type,parentSchema:schema15.properties.md5,data:data7};if(vErrors === null){vErrors = [err10];}else {vErrors.push(err10);}errors++;}}if(data.fileSize !== undefined){const data8 = data.fileSize;if(!((typeof data8 == "number") && (isFinite(data8)))){const err11 = {instancePath:instancePath+"/fileSize",schemaPath:"#/properties/fileSize/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema15.properties.fileSize.type,parentSchema:schema15.properties.fileSize,data:data8};if(vErrors === null){vErrors = [err11];}else {vErrors.push(err11);}errors++;}}if(data.logicalFilename !== undefined){const data9 = data.logicalFilename;if(typeof data9 !== "string"){const err12 = {instancePath:instancePath+"/logicalFilename",schemaPath:"#/properties/logicalFilename/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.logicalFilename.type,parentSchema:schema15.properties.logicalFilename,data:data9};if(vErrors === null){vErrors = [err12];}else {vErrors.push(err12);}errors++;}}if(data.fileExpression !== undefined){const data10 = data.fileExpression;if(typeof data10 !== "string"){const err13 = {instancePath:instancePath+"/fileExpression",schemaPath:"#/properties/fileExpression/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.fileExpression.type,parentSchema:schema15.properties.fileExpression,data:data10};if(vErrors === null){vErrors = [err13];}else {vErrors.push(err13);}errors++;}}if(data.tag !== undefined){const data11 = data.tag;if(typeof data11 !== "string"){const err14 = {instancePath:instancePath+"/tag",schemaPath:"#/properties/tag/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.tag.type,parentSchema:schema15.properties.tag,data:data11};if(vErrors === null){vErrors = [err14];}else {vErrors.push(err14);}errors++;}}}else {const err15 = {instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema15.type,parentSchema:schema15,data};if(vErrors === null){vErrors = [err15];}else {vErrors.push(err15);}errors++;}validate13.errors = vErrors;return errors === 0;}function validate12(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(data && typeof data == "object" && !Array.isArray(data)){if(data.name === undefined){const err0 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}if(data.version === undefined){const err1 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "version"},message:"must have required property '"+"version"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}if(data.optional === undefined){const err2 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "optional"},message:"must have required property '"+"optional"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}if(data.domainName === undefined){const err3 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "domainName"},message:"must have required property '"+"domainName"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err3];}else {vErrors.push(err3);}errors++;}if(data.source === undefined){const err4 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "source"},message:"must have required property '"+"source"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}if(data.name !== undefined){const data0 = data.name;if(typeof data0 !== "string"){const err5 = {instancePath:instancePath+"/name",schemaPath:"#/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.name.type,parentSchema:schema14.properties.name,data:data0};if(vErrors === null){vErrors = [err5];}else {vErrors.push(err5);}errors++;}}if(data.version !== undefined){const data1 = data.version;if(typeof data1 !== "string"){const err6 = {instancePath:instancePath+"/version",schemaPath:"#/properties/version/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.version.type,parentSchema:schema14.properties.version,data:data1};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}}if(data.optional !== undefined){const data2 = data.optional;if(typeof data2 !== "boolean"){const err7 = {instancePath:instancePath+"/optional",schemaPath:"#/properties/optional/type",keyword:"type",params:{type: "boolean"},message:"must be boolean",schema:schema14.properties.optional.type,parentSchema:schema14.properties.optional,data:data2};if(vErrors === null){vErrors = [err7];}else {vErrors.push(err7);}errors++;}}if(data.domainName !== undefined){const data3 = data.domainName;if(typeof data3 !== "string"){const err8 = {instancePath:instancePath+"/domainName",schemaPath:"#/properties/domainName/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.domainName.type,parentSchema:schema14.properties.domainName,data:data3};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}}if(data.source !== undefined){if(!(validate13(data.source, {instancePath:instancePath+"/source",parentData:data,parentDataProperty:"source",rootData}))){vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);errors = vErrors.length;}}if(data.patches !== undefined){const data5 = data.patches;if(data5 && typeof data5 == "object" && !Array.isArray(data5)){for(const key0 in data5){const data6 = data5[key0];if(typeof data6 !== "string"){const err9 = {instancePath:instancePath+"/patches/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"),schemaPath:"#/properties/patches/additionalProperties/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.patches.additionalProperties.type,parentSchema:schema14.properties.patches.additionalProperties,data:data6};if(vErrors === null){vErrors = [err9];}else {vErrors.push(err9);}errors++;}}}else {const err10 = {instancePath:instancePath+"/patches",schemaPath:"#/properties/patches/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema14.properties.patches.type,parentSchema:schema14.properties.patches,data:data5};if(vErrors === null){vErrors = [err10];}else {vErrors.push(err10);}errors++;}}if(data.instructions !== undefined){const data7 = data.instructions;if(typeof data7 !== "string"){const err11 = {instancePath:instancePath+"/instructions",schemaPath:"#/properties/instructions/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.instructions.type,parentSchema:schema14.properties.instructions,data:data7};if(vErrors === null){vErrors = [err11];}else {vErrors.push(err11);}errors++;}}if(data.author !== undefined){const data8 = data.author;if(typeof data8 !== "string"){const err12 = {instancePath:instancePath+"/author",schemaPath:"#/properties/author/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.author.type,parentSchema:schema14.properties.author,data:data8};if(vErrors === null){vErrors = [err12];}else {vErrors.push(err12);}errors++;}}if(data.details !== undefined){const data9 = data.details;if(data9 && typeof data9 == "object" && !Array.isArray(data9)){if(data9.type !== undefined){const data10 = data9.type;if(typeof data10 !== "string"){const err13 = {instancePath:instancePath+"/details/type",schemaPath:"#/definitions/ICollectionModDetails/properties/type/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema18.properties.type.type,parentSchema:schema18.properties.type,data:data10};if(vErrors === null){vErrors = [err13];}else {vErrors.push(err13);}errors++;}}if(data9.category !== undefined){const data11 = data9.category;if(typeof data11 !== "string"){const err14 = {instancePath:instancePath+"/details/category",schemaPath:"#/definitions/ICollectionModDetails/properties/category/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema18.properties.category.type,parentSchema:schema18.properties.category,data:data11};if(vErrors === null){vErrors = [err14];}else {vErrors.push(err14);}errors++;}}}else {const err15 = {instancePath:instancePath+"/details",schemaPath:"#/definitions/ICollectionModDetails/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema18.type,parentSchema:schema18,data:data9};if(vErrors === null){vErrors = [err15];}else {vErrors.push(err15);}errors++;}}if(data.phase !== undefined){const data12 = data.phase;if(!((typeof data12 == "number") && (isFinite(data12)))){const err16 = {instancePath:instancePath+"/phase",schemaPath:"#/properties/phase/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema14.properties.phase.type,parentSchema:schema14.properties.phase,data:data12};if(vErrors === null){vErrors = [err16];}else {vErrors.push(err16);}errors++;}}if(data.fileOverrides !== undefined){const data13 = data.fileOverrides;if(Array.isArray(data13)){const len0 = data13.length;for(let i0=0; i0<len0; i0++){const data14 = data13[i0];if(typeof data14 !== "string"){const err17 = {instancePath:instancePath+"/fileOverrides/" + i0,schemaPath:"#/properties/fileOverrides/items/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.fileOverrides.items.type,parentSchema:schema14.properties.fileOverrides.items,data:data14};if(vErrors === null){vErrors = [err17];}else {vErrors.push(err17);}errors++;}}}else {const err18 = {instancePath:instancePath+"/fileOverrides",schemaPath:"#/properties/fileOverrides/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema14.properties.fileOverrides.type,parentSchema:schema14.properties.fileOverrides,data:data13};if(vErrors === null){vErrors = [err18];}else {vErrors.push(err18);}errors++;}}}else {const err19 = {instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema14.type,parentSchema:schema14,data};if(vErrors === null){vErrors = [err19];}else {vErrors.push(err19);}errors++;}validate12.errors = vErrors;return errors === 0;}const schema19 = {"type":"object","properties":{"source":{"$ref":"#/definitions/IModReference"},"type":{"$ref":"#/definitions/RuleType"},"reference":{"$ref":"#/definitions/IModReference"}},"required":["source","type","reference"]};const schema20 = {"type":"object","properties":{"fileMD5":{"type":"string"},"fileSize":{"type":"number"},"gameId":{"type":"string"},"versionMatch":{"type":"string"},"logicalFileName":{"type":"string"},"fileExpression":{"type":"string"},"id":{"type":"string"},"idHint":{"type":"string"},"md5Hint":{"type":"string"},"tag":{"type":"string"},"archiveId":{"type":"string"},"repo":{"type":"object","properties":{"gameId":{"type":"string"},"modId":{"type":"string"},"fileId":{"type":"string"},"repository":{"type":"string"},"campaign":{"type":"string"}},"required":["fileId","repository"]},"description":{"type":"string"},"instructions":{"type":"string"}}};const schema21 = {"type":"string","enum":["before","after","requires","conflicts","recommends","provides"]};function validate16(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(data && typeof data == "object" && !Array.isArray(data)){if(data.source === undefined){const err0 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "source"},message:"must have required property '"+"source"+"'",schema:schema19.required,parentSchema:schema19,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}if(data.type === undefined){const err1 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "type"},message:"must have required property '"+"type"+"'",schema:schema19.required,parentSchema:schema19,data};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}if(data.reference === undefined){const err2 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "reference"},message:"must have required property '"+"reference"+"'",schema:schema19.required,parentSchema:schema19,data};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}if(data.source !== undefined){const data0 = data.source;if(data0 && typeof data0 == "object" && !Array.isArray(data0)){if(data0.fileMD5 !== undefined){const data1 = data0.fileMD5;if(typeof data1 !== "string"){const err3 = {instancePath:instancePath+"/source/fileMD5",schemaPath:"#/definitions/IModReference/properties/fileMD5/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.fileMD5.type,parentSchema:schema20.properties.fileMD5,data:data1};if(vErrors === null){vErrors = [err3];}else {vErrors.push(err3);}errors++;}}if(data0.fileSize !== undefined){const data2 = data0.fileSize;if(!((typeof data2 == "number") && (isFinite(data2)))){const err4 = {instancePath:instancePath+"/source/fileSize",schemaPath:"#/definitions/IModReference/properties/fileSize/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema20.properties.fileSize.type,parentSchema:schema20.properties.fileSize,data:data2};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}}if(data0.gameId !== undefined){const data3 = data0.gameId;if(typeof data3 !== "string"){const err5 = {instancePath:instancePath+"/source/gameId",schemaPath:"#/definitions/IModReference/properties/gameId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.gameId.type,parentSchema:schema20.properties.gameId,data:data3};if(vErrors === null){vErrors = [err5];}else {vErrors.push(err5);}errors++;}}if(data0.versionMatch !== undefined){const data4 = data0.versionMatch;if(typeof data4 !== "string"){const err6 = {instancePath:instancePath+"/source/versionMatch",schemaPath:"#/definitions/IModReference/properties/versionMatch/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.versionMatch.type,parentSchema:schema20.properties.versionMatch,data:data4};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}}if(data0.logicalFileName !== undefined){const data5 = data0.logicalFileName;if(typeof data5 !== "string"){const err7 = {instancePath:instancePath+"/source/logicalFileName",schemaPath:"#/definitions/IModReference/properties/logicalFileName/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.logicalFileName.type,parentSchema:schema20.properties.logicalFileName,data:data5};if(vErrors === null){vErrors = [err7];}else {vErrors.push(err7);}errors++;}}if(data0.fileExpression !== undefined){const data6 = data0.fileExpression;if(typeof data6 !== "string"){const err8 = {instancePath:instancePath+"/source/fileExpression",schemaPath:"#/definitions/IModReference/properties/fileExpression/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.fileExpression.type,parentSchema:schema20.properties.fileExpression,data:data6};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}}if(data0.id !== undefined){const data7 = data0.id;if(typeof data7 !== "string"){const err9 = {instancePath:instancePath+"/source/id",schemaPath:"#/definitions/IModReference/properties/id/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.id.type,parentSchema:schema20.properties.id,data:data7};if(vErrors === null){vErrors = [err9];}else {vErrors.push(err9);}errors++;}}if(data0.idHint !== undefined){const data8 = data0.idHint;if(typeof data8 !== "string"){const err10 = {instancePath:instancePath+"/source/idHint",schemaPath:"#/definitions/IModReference/properties/idHint/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.idHint.type,parentSchema:schema20.properties.idHint,data:data8};if(vErrors === null){vErrors = [err10];}else {vErrors.push(err10);}errors++;}}if(data0.md5Hint !== undefined){const data9 = data0.md5Hint;if(typeof data9 !== "string"){const err11 = {instancePath:instancePath+"/source/md5Hint",schemaPath:"#/definitions/IModReference/properties/md5Hint/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.md5Hint.type,parentSchema:schema20.properties.md5Hint,data:data9};if(vErrors === null){vErrors = [err11];}else {vErrors.push(err11);}errors++;}}if(data0.tag !== undefined){const data10 = data0.tag;if(typeof data10 !== "string"){const err12 = {instancePath:instancePath+"/source/tag",schemaPath:"#/definitions/IModReference/properties/tag/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.tag.type,parentSchema:schema20.properties.tag,data:data10};if(vErrors === null){vErrors = [err12];}else {vErrors.push(err12);}errors++;}}if(data0.archiveId !== undefined){const data11 = data0.archiveId;if(typeof data11 !== "string"){const err13 = {instancePath:instancePath+"/source/archiveId",schemaPath:"#/definitions/IModReference/properties/archiveId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.archiveId.type,parentSchema:schema20.properties.archiveId,data:data11};if(vErrors === null){vErrors = [err13];}else {vErrors.push(err13);}errors++;}}if(data0.repo !== undefined){const data12 = data0.repo;if(data12 && typeof data12 == "object" && !Array.isArray(data12)){if(data12.fileId === undefined){const err14 = {instancePath:instancePath+"/source/repo",schemaPath:"#/definitions/IModReference/properties/repo/required",keyword:"required",params:{missingProperty: "fileId"},message:"must have required property '"+"fileId"+"'",schema:schema20.properties.repo.required,parentSchema:schema20.properties.repo,data:data12};if(vErrors === null){vErrors = [err14];}else {vErrors.push(err14);}errors++;}if(data12.repository === undefined){const err15 = {instancePath:instancePath+"/source/repo",schemaPath:"#/definitions/IModReference/properties/repo/required",keyword:"required",params:{missingProperty: "repository"},message:"must have required property '"+"repository"+"'",schema:schema20.properties.repo.required,parentSchema:schema20.properties.repo,data:data12};if(vErrors === null){vErrors = [err15];}else {vErrors.push(err15);}errors++;}if(data12.gameId !== undefined){const data13 = data12.gameId;if(typeof data13 !== "string"){const err16 = {instancePath:instancePath+"/source/repo/gameId",schemaPath:"#/definitions/IModReference/properties/repo/properties/gameId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.gameId.type,parentSchema:schema20.properties.repo.properties.gameId,data:data13};if(vErrors === null){vErrors = [err16];}else {vErrors.push(err16);}errors++;}}if(data12.modId !== undefined){const data14 = data12.modId;if(typeof data14 !== "string"){const err17 = {instancePath:instancePath+"/source/repo/modId",schemaPath:"#/definitions/IModReference/properties/repo/properties/modId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.modId.type,parentSchema:schema20.properties.repo.properties.modId,data:data14};if(vErrors === null){vErrors = [err17];}else {vErrors.push(err17);}errors++;}}if(data12.fileId !== undefined){const data15 = data12.fileId;if(typeof data15 !== "string"){const err18 = {instancePath:instancePath+"/source/repo/fileId",schemaPath:"#/definitions/IModReference/properties/repo/properties/fileId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.fileId.type,parentSchema:schema20.properties.repo.properties.fileId,data:data15};if(vErrors === null){vErrors = [err18];}else {vErrors.push(err18);}errors++;}}if(data12.repository !== undefined){const data16 = data12.repository;if(typeof data16 !== "string"){const err19 = {instancePath:instancePath+"/source/repo/repository",schemaPath:"#/definitions/IModReference/properties/repo/properties/repository/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.repository.type,parentSchema:schema20.properties.repo.properties.repository,data:data16};if(vErrors === null){vErrors = [err19];}else {vErrors.push(err19);}errors++;}}if(data12.campaign !== undefined){const data17 = data12.campaign;if(typeof data17 !== "string"){const err20 = {instancePath:instancePath+"/source/repo/campaign",schemaPath:"#/definitions/IModReference/properties/repo/properties/campaign/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.campaign.type,parentSchema:schema20.properties.repo.properties.campaign,data:data17};if(vErrors === null){vErrors = [err20];}else {vErrors.push(err20);}errors++;}}}else {const err21 = {instancePath:instancePath+"/source/repo",schemaPath:"#/definitions/IModReference/properties/repo/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema20.properties.repo.type,parentSchema:schema20.properties.repo,data:data12};if(vErrors === null){vErrors = [err21];}else {vErrors.push(err21);}errors++;}}if(data0.description !== undefined){const data18 = data0.description;if(typeof data18 !== "string"){const err22 = {instancePath:instancePath+"/source/description",schemaPath:"#/definitions/IModReference/properties/description/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.description.type,parentSchema:schema20.properties.description,data:data18};if(vErrors === null){vErrors = [err22];}else {vErrors.push(err22);}errors++;}}if(data0.instructions !== undefined){const data19 = data0.instructions;if(typeof data19 !== "string"){const err23 = {instancePath:instancePath+"/source/instructions",schemaPath:"#/definitions/IModReference/properties/instructions/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.instructions.type,parentSchema:schema20.properties.instructions,data:data19};if(vErrors === null){vErrors = [err23];}else {vErrors.push(err23);}errors++;}}}else {const err24 = {instancePath:instancePath+"/source",schemaPath:"#/definitions/IModReference/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema20.type,parentSchema:schema20,data:data0};if(vErrors === null){vErrors = [err24];}else {vErrors.push(err24);}errors++;}}if(data.type !== undefined){const data20 = data.type;if(typeof data20 !== "string"){const err25 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/RuleType/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema21.type,parentSchema:schema21,data:data20};if(vErrors === null){vErrors = [err25];}else {vErrors.push(err25);}errors++;}if(!((((((data20 === "before") || (data20 === "after")) || (data20 === "requires")) || (data20 === "conflicts")) || (data20 === "recommends")) || (data20 === "provides"))){const err26 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/RuleType/enum",keyword:"enum",params:{allowedValues: schema21.enum},message:"must be equal to one of the allowed values",schema:schema21.enum,parentSchema:schema21,data:data20};if(vErrors === null){vErrors = [err26];}else {vErrors.push(err26);}errors++;}}if(data.reference !== undefined){const data21 = data.reference;if(data21 && typeof data21 == "object" && !Array.isArray(data21)){if(data21.fileMD5 !== undefined){const data22 = data21.fileMD5;if(typeof data22 !== "string"){const err27 = {instancePath:instancePath+"/reference/fileMD5",schemaPath:"#/definitions/IModReference/properties/fileMD5/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.fileMD5.type,parentSchema:schema20.properties.fileMD5,data:data22};if(vErrors === null){vErrors = [err27];}else {vErrors.push(err27);}errors++;}}if(data21.fileSize !== undefined){const data23 = data21.fileSize;if(!((typeof data23 == "number") && (isFinite(data23)))){const err28 = {instancePath:instancePath+"/reference/fileSize",schemaPath:"#/definitions/IModReference/properties/fileSize/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema20.properties.fileSize.type,parentSchema:schema20.properties.fileSize,data:data23};if(vErrors === null){vErrors = [err28];}else {vErrors.push(err28);}errors++;}}if(data21.gameId !== undefined){const data24 = data21.gameId;if(typeof data24 !== "string"){const err29 = {instancePath:instancePath+"/reference/gameId",schemaPath:"#/definitions/IModReference/properties/gameId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.gameId.type,parentSchema:schema20.properties.gameId,data:data24};if(vErrors === null){vErrors = [err29];}else {vErrors.push(err29);}errors++;}}if(data21.versionMatch !== undefined){const data25 = data21.versionMatch;if(typeof data25 !== "string"){const err30 = {instancePath:instancePath+"/reference/versionMatch",schemaPath:"#/definitions/IModReference/properties/versionMatch/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.versionMatch.type,parentSchema:schema20.properties.versionMatch,data:data25};if(vErrors === null){vErrors = [err30];}else {vErrors.push(err30);}errors++;}}if(data21.logicalFileName !== undefined){const data26 = data21.logicalFileName;if(typeof data26 !== "string"){const err31 = {instancePath:instancePath+"/reference/logicalFileName",schemaPath:"#/definitions/IModReference/properties/logicalFileName/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.logicalFileName.type,parentSchema:schema20.properties.logicalFileName,data:data26};if(vErrors === null){vErrors = [err31];}else {vErrors.push(err31);}errors++;}}if(data21.fileExpression !== undefined){const data27 = data21.fileExpression;if(typeof data27 !== "string"){const err32 = {instancePath:instancePath+"/reference/fileExpression",schemaPath:"#/definitions/IModReference/properties/fileExpression/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.fileExpression.type,parentSchema:schema20.properties.fileExpression,data:data27};if(vErrors === null){vErrors = [err32];}else {vErrors.push(err32);}errors++;}}if(data21.id !== undefined){const data28 = data21.id;if(typeof data28 !== "string"){const err33 = {instancePath:instancePath+"/reference/id",schemaPath:"#/definitions/IModReference/properties/id/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.id.type,parentSchema:schema20.properties.id,data:data28};if(vErrors === null){vErrors = [err33];}else {vErrors.push(err33);}errors++;}}if(data21.idHint !== undefined){const data29 = data21.idHint;if(typeof data29 !== "string"){const err34 = {instancePath:instancePath+"/reference/idHint",schemaPath:"#/definitions/IModReference/properties/idHint/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.idHint.type,parentSchema:schema20.properties.idHint,data:data29};if(vErrors === null){vErrors = [err34];}else {vErrors.push(err34);}errors++;}}if(data21.md5Hint !== undefined){const data30 = data21.md5Hint;if(typeof data30 !== "string"){const err35 = {instancePath:instancePath+"/reference/md5Hint",schemaPath:"#/definitions/IModReference/properties/md5Hint/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.md5Hint.type,parentSchema:schema20.properties.md5Hint,data:data30};if(vErrors === null){vErrors = [err35];}else {vErrors.push(err35);}errors++;}}if(data21.tag !== undefined){const data31 = data21.tag;if(typeof data31 !== "string"){const err36 = {instancePath:instancePath+"/reference/tag",schemaPath:"#/definitions/IModReference/properties/tag/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.tag.type,parentSchema:schema20.properties.tag,data:data31};if(vErrors === null){vErrors = [err36];}else {vErrors.push(err36);}errors++;}}if(data21.archiveId !== undefined){const data32 = data21.archiveId;if(typeof data32 !== "string"){const err37 = {instancePath:instancePath+"/reference/archiveId",schemaPath:"#/definitions/IModReference/properties/archiveId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.archiveId.type,parentSchema:schema20.properties.archiveId,data:data32};if(vErrors === null){vErrors = [err37];}else {vErrors.push(err37);}errors++;}}if(data21.repo !== undefined){const data33 = data21.repo;if(data33 && typeof data33 == "object" && !Array.isArray(data33)){if(data33.fileId === undefined){const err38 = {instancePath:instancePath+"/reference/repo",schemaPath:"#/definitions/IModReference/properties/repo/required",keyword:"required",params:{missingProperty: "fileId"},message:"must have required property '"+"fileId"+"'",schema:schema20.properties.repo.required,parentSchema:schema20.properties.repo,data:data33};if(vErrors === null){vErrors = [err38];}else {vErrors.push(err38);}errors++;}if(data33.repository === undefined){const err39 = {instancePath:instancePath+"/reference/repo",schemaPath:"#/definitions/IModReference/properties/repo/required",keyword:"required",params:{missingProperty: "repository"},message:"must have required property '"+"repository"+"'",schema:schema20.properties.repo.required,parentSchema:schema20.properties.repo,data:data33};if(vErrors === null){vErrors = [err39];}else {vErrors.push(err39);}errors++;}if(data33.gameId !== undefined){const data34 = data33.gameId;if(typeof data34 !== "string"){const err40 = {instancePath:instancePath+"/reference/repo/gameId",schemaPath:"#/definitions/IModReference/properties/repo/properties/gameId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.gameId.type,parentSchema:schema20.properties.repo.properties.gameId,data:data34};if(vErrors === null){vErrors = [err40];}else {vErrors.push(err40);}errors++;}}if(data33.modId !== undefined){const data35 = data33.modId;if(typeof data35 !== "string"){const err41 = {instancePath:instancePath+"/reference/repo/modId",schemaPath:"#/definitions/IModReference/properties/repo/properties/modId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.modId.type,parentSchema:schema20.properties.repo.properties.modId,data:data35};if(vErrors === null){vErrors = [err41];}else {vErrors.push(err41);}errors++;}}if(data33.fileId !== undefined){const data36 = data33.fileId;if(typeof data36 !== "string"){const err42 = {instancePath:instancePath+"/reference/repo/fileId",schemaPath:"#/definitions/IModReference/properties/repo/properties/fileId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.fileId.type,parentSchema:schema20.properties.repo.properties.fileId,data:data36};if(vErrors === null){vErrors = [err42];}else {vErrors.push(err42);}errors++;}}if(data33.repository !== undefined){const data37 = data33.repository;if(typeof data37 !== "string"){const err43 = {instancePath:instancePath+"/reference/repo/repository",schemaPath:"#/definitions/IModReference/properties/repo/properties/repository/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.repository.type,parentSchema:schema20.properties.repo.properties.repository,data:data37};if(vErrors === null){vErrors = [err43];}else {vErrors.push(err43);}errors++;}}if(data33.campaign !== undefined){const data38 = data33.campaign;if(typeof data38 !== "string"){const err44 = {instancePath:instancePath+"/reference/repo/campaign",schemaPath:"#/definitions/IModReference/properties/repo/properties/campaign/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.campaign.type,parentSchema:schema20.properties.repo.properties.campaign,data:data38};if(vErrors === null){vErrors = [err44];}else {vErrors.push(err44);}errors++;}}}else {const err45 = {instancePath:instancePath+"/reference/repo",schemaPath:"#/definitions/IModReference/properties/repo/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema20.properties.repo.type,parentSchema:schema20.properties.repo,data:data33};if(vErrors === null){vErrors = [err45];}else {vErrors.push(err45);}errors++;}}if(data21.description !== undefined){const data39 = data21.description;if(typeof data39 !== "string"){const err46 = {instancePath:instancePath+"/reference/description",schemaPath:"#/definitions/IModReference/properties/description/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.description.type,parentSchema:schema20.properties.description,data:data39};if(vErrors === null){vErrors = [err46];}else {vErrors.push(err46);}errors++;}}if(data21.instructions !== undefined){const data40 = data21.instructions;if(typeof data40 !== "string"){const err47 = {instancePath:instancePath+"/reference/instructions",schemaPath:"#/definitions/IModReference/properties/instructions/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.instructions.type,parentSchema:schema20.properties.instructions,data:data40};if(vErrors === null){vErrors = [err47];}else {vErrors.push(err47);}errors++;}}}else {const err48 = {instancePath:instancePath+"/reference",schemaPath:"#/definitions/IModReference/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema20.type,parentSchema:schema20,data:data21};if(vErrors === null){vErrors = [err48];}else {vErrors.push(err48);}errors++;}}}else {const err49 = {instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema19.type,parentSchema:schema19,data};if(vErrors === null){vErrors = [err49];}else {vErrors.push(err49);}errors++;}validate16.errors = vErrors;return errors === 0;}function validate11(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(data && typeof data == "object" && !Array.isArray(data)){if(data.info === undefined){const err0 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "info"},message:"must have required property '"+"info"+"'",schema:schema12.required,parentSchema:schema12,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}if(data.mods === undefined){const err1 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "mods"},message:"must have required property '"+"mods"+"'",schema:schema12.required,parentSchema:schema12,data};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}if(data.modRules === undefined){const err2 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "modRules"},message:"must have required property '"+"modRules"+"'",schema:schema12.required,parentSchema:schema12,data};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}if(data.plugins !== undefined){const data0 = data.plugins;if(Array.isArray(data0)){const len0 = data0.length;for(let i0=0; i0<len0; i0++){const data1 = data0[i0];if(data1 && typeof data1 == "object" && !Array.isArray(data1)){if(data1.name === undefined){const err3 = {instancePath:instancePath+"/plugins/" + i0,schemaPath:"#/properties/plugins/items/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema12.properties.plugins.items.required,parentSchema:schema12.properties.plugins.items,data:data1};if(vErrors === null){vErrors = [err3];}else {vErrors.push(err3);}errors++;}if(data1.name !== undefined){const data2 = data1.name;if(typeof data2 !== "string"){const err4 = {instancePath:instancePath+"/plugins/" + i0+"/name",schemaPath:"#/properties/plugins/items/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.plugins.items.properties.name.type,parentSchema:schema12.properties.plugins.items.properties.name,data:data2};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}}if(data1.enabled !== undefined){const data3 = data1.enabled;if(typeof data3 !== "boolean"){const err5 = {instancePath:instancePath+"/plugins/" + i0+"/enabled",schemaPath:"#/properties/plugins/items/properties/enabled/type",keyword:"type",params:{type: "boolean"},message:"must be boolean",schema:schema12.properties.plugins.items.properties.enabled.type,parentSchema:schema12.properties.plugins.items.properties.enabled,data:data3};if(vErrors === null){vErrors = [err5];}else {vErrors.push(err5);}errors++;}}}else {const err6 = {instancePath:instancePath+"/plugins/" + i0,schemaPath:"#/properties/plugins/items/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.properties.plugins.items.type,parentSchema:schema12.properties.plugins.items,data:data1};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}}}else {const err7 = {instancePath:instancePath+"/plugins",schemaPath:"#/properties/plugins/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.plugins.type,parentSchema:schema12.properties.plugins,data:data0};if(vErrors === null){vErrors = [err7];}else {vErrors.push(err7);}errors++;}}if(data.pluginRules !== undefined){const data4 = data.pluginRules;if(data4 && typeof data4 == "object" && !Array.isArray(data4)){if(data4.plugins === undefined){const err8 = {instancePath:instancePath+"/pluginRules",schemaPath:"#/properties/pluginRules/required",keyword:"required",params:{missingProperty: "plugins"},message:"must have required property '"+"plugins"+"'",schema:schema12.properties.pluginRules.required,parentSchema:schema12.properties.pluginRules,data:data4};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}if(data4.plugins !== undefined){const data5 = data4.plugins;if(Array.isArray(data5)){const len1 = data5.length;for(let i1=0; i1<len1; i1++){const data6 = data5[i1];if(data6 && typeof data6 == "object" && !Array.isArray(data6)){if(data6.name === undefined){const err9 = {instancePath:instancePath+"/pluginRules/plugins/" + i1,schemaPath:"#/properties/pluginRules/properties/plugins/items/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema12.properties.pluginRules.properties.plugins.items.required,parentSchema:schema12.properties.pluginRules.properties.plugins.items,data:data6};if(vErrors === null){vErrors = [err9];}else {vErrors.push(err9);}errors++;}if(data6.name !== undefined){const data7 = data6.name;if(typeof data7 !== "string"){const err10 = {instancePath:instancePath+"/pluginRules/plugins/" + i1+"/name",schemaPath:"#/properties/pluginRules/properties/plugins/items/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.plugins.items.properties.name.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items.properties.name,data:data7};if(vErrors === null){vErrors = [err10];}else {vErrors.push(err10);}errors++;}}if(data6.group !== undefined){const data8 = data6.group;if(typeof data8 !== "string"){const err11 = {instancePath:instancePath+"/pluginRules/plugins/" + i1+"/group",schemaPath:"#/properties/pluginRules/properties/plugins/items/properties/group/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.plugins.items.properties.group.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items.properties.group,data:data8};if(vErrors === null){vErrors = [err11];}else {vErrors.push(err11);}errors++;}}if(data6.after !== undefined){const data9 = data6.after;if(Array.isArray(data9)){const len2 = data9.length;for(let i2=0; i2<len2; i2++){const data10 = data9[i2];if(typeof data10 !== "string"){const err12 = {instancePath:instancePath+"/pluginRules/plugins/" + i1+"/after/" + i2,schemaPath:"#/properties/pluginRules/properties/plugins/items/properties/after/items/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.plugins.items.properties.after.items.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items.properties.after.items,data:data10};if(vErrors === null){vErrors = [err12];}else {vErrors.push(err12);}errors++;}}}else {const err13 = {instancePath:instancePath+"/pluginRules/plugins/" + i1+"/after",schemaPath:"#/properties/pluginRules/properties/plugins/items/properties/after/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.pluginRules.properties.plugins.items.properties.after.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items.properties.after,data:data9};if(vErrors === null){vErrors = [err13];}else {vErrors.push(err13);}errors++;}}}else {const err14 = {instancePath:instancePath+"/pluginRules/plugins/" + i1,schemaPath:"#/properties/pluginRules/properties/plugins/items/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.properties.pluginRules.properties.plugins.items.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items,data:data6};if(vErrors === null){vErrors = [err14];}else {vErrors.push(err14);}errors++;}}}else {const err15 = {instancePath:instancePath+"/pluginRules/plugins",schemaPath:"#/properties/pluginRules/properties/plugins/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.pluginRules.properties.plugins.type,parentSchema:schema12.properties.pluginRules.properties.plugins,data:data5};if(vErrors === null){vErrors = [err15];}else {vErrors.push(err15);}errors++;}}if(data4.groups !== undefined){const data11 = data4.groups;if(Array.isArray(data11)){const len3 = data11.length;for(let i3=0; i3<len3; i3++){const data12 = data11[i3];if(data12 && typeof data12 == "object" && !Array.isArray(data12)){if(data12.name === undefined){const err16 = {instancePath:instancePath+"/pluginRules/groups/" + i3,schemaPath:"#/properties/pluginRules/properties/groups/items/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema12.properties.pluginRules.properties.groups.items.required,parentSchema:schema12.properties.pluginRules.properties.groups.items,data:data12};if(vErrors === null){vErrors = [err16];}else {vErrors.push(err16);}errors++;}if(data12.name !== undefined){const data13 = data12.name;if(typeof data13 !== "string"){const err17 = {instancePath:instancePath+"/pluginRules/groups/" + i3+"/name",schemaPath:"#/properties/pluginRules/properties/groups/items/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.groups.items.properties.name.type,parentSchema:schema12.properties.pluginRules.properties.groups.items.properties.name,data:data13};if(vErrors === null){vErrors = [err17];}else {vErrors.push(err17);}errors++;}}if(data12.group !== undefined){const data14 = data12.group;if(typeof data14 !== "string"){const err18 = {instancePath:instancePath+"/pluginRules/groups/" + i3+"/group",schemaPath:"#/properties/pluginRules/properties/groups/items/properties/group/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.groups.items.properties.group.type,parentSchema:schema12.properties.pluginRules.properties.groups.items.properties.group,data:data14};if(vErrors === null){vErrors = [err18];}else {vErrors.push(err18);}errors++;}}if(data12.after !== undefined){const data15 = data12.after;if(Array.isArray(data15)){const len4 = data15.length;for(let i4=0; i4<len4; i4++){const data16 = data15[i4];if(typeof data16 !== "string"){const err19 = {instancePath:instancePath+"/pluginRules/groups/" + i3+"/after/" + i4,schemaPath:"#/properties/pluginRules/properties/groups/items/properties/after/items/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.groups.items.properties.after.items.type,parentSchema:schema12.properties.pluginRules.properties.groups.items.properties.after.items,data:data16};if(vErrors === null){vErrors = [err19];}else {vErrors.push(err19);}errors++;}}}else {const err20 = {instancePath:instancePath+"/pluginRules/groups/" + i3+"/after",schemaPath:"#/properties/pluginRules/properties/groups/items/properties/after/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.pluginRules.properties.groups.items.properties.after.type,parentSchema:schema12.properties.pluginRules.properties.groups.items.properties.after,data:data15};if(vErrors === null){vErrors = [err20];}else {vErrors.push(err20);}errors++;}}}else {const err21 = {instancePath:instancePath+"/pluginRules/groups/" + i3,schemaPath:"#/properties/pluginRules/properties/groups/items/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.properties.pluginRules.properties.groups.items.type,parentSchema:schema12.properties.pluginRules.properties.groups.items,data:data12};if(vErrors === null){vErrors = [err21];}else {vErrors.push(err21);}errors++;}}}else {const err22 = {instancePath:instancePath+"/pluginRules/groups",schemaPath:"#/properties/pluginRules/properties/groups/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.pluginRules.properties.groups.type,parentSchema:schema12.properties.pluginRules.properties.groups,data:data11};if(vErrors === null){vErrors = [err22];}else {vErrors.push(err22);}errors++;}}}else {const err23 = {instancePath:instancePath+"/pluginRules",schemaPath:"#/properties/pluginRules/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.properties.pluginRules.type,parentSchema:schema12.properties.pluginRules,data:data4};if(vErrors === null){vErrors = [err23];}else {vErrors.push(err23);}errors++;}}if(data.info !== undefined){const data17 = data.info;if(data17 && typeof data17 == "object" && !Array.isArray(data17)){if(data17.author === undefined){const err24 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "author"},message:"must have required property '"+"author"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err24];}else {vErrors.push(err24);}errors++;}if(data17.authorUrl === undefined){const err25 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "authorUrl"},message:"must have required property '"+"authorUrl"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err25];}else {vErrors.push(err25);}errors++;}if(data17.name === undefined){const err26 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err26];}else {vErrors.push(err26);}errors++;}if(data17.description === undefined){const err27 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "description"},message:"must have required property '"+"description"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err27];}else {vErrors.push(err27);}errors++;}if(data17.domainName === undefined){const err28 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "domainName"},message:"must have required property '"+"domainName"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err28];}else {vErrors.push(err28);}errors++;}if(data17.author !== undefined){const data18 = data17.author;if(typeof data18 !== "string"){const err29 = {instancePath:instancePath+"/info/author",schemaPath:"#/definitions/ICollectionInfo/properties/author/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.author.type,parentSchema:schema13.properties.author,data:data18};if(vErrors === null){vErrors = [err29];}else {vErrors.push(err29);}errors++;}}if(data17.authorUrl !== undefined){const data19 = data17.authorUrl;if(typeof data19 !== "string"){const err30 = {instancePath:instancePath+"/info/authorUrl",schemaPath:"#/definitions/ICollectionInfo/properties/authorUrl/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.authorUrl.type,parentSchema:schema13.properties.authorUrl,data:data19};if(vErrors === null){vErrors = [err30];}else {vErrors.push(err30);}errors++;}}if(data17.name !== undefined){const data20 = data17.name;if(typeof data20 !== "string"){const err31 = {instancePath:instancePath+"/info/name",schemaPath:"#/definitions/ICollectionInfo/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.name.type,parentSchema:schema13.properties.name,data:data20};if(vErrors === null){vErrors = [err31];}else {vErrors.push(err31);}errors++;}}if(data17.description !== undefined){const data21 = data17.description;if(typeof data21 !== "string"){const err32 = {instancePath:instancePath+"/info/description",schemaPath:"#/definitions/ICollectionInfo/properties/description/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.description.type,parentSchema:schema13.properties.description,data:data21};if(vErrors === null){vErrors = [err32];}else {vErrors.push(err32);}errors++;}}if(data17.domainName !== undefined){const data22 = data17.domainName;if(typeof data22 !== "string"){const err33 = {instancePath:instancePath+"/info/domainName",schemaPath:"#/definitions/ICollectionInfo/properties/domainName/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.domainName.type,parentSchema:schema13.properties.domainName,data:data22};if(vErrors === null){vErrors = [err33];}else {vErrors.push(err33);}errors++;}}if(data17.gameVersions !== undefined){const data23 = data17.gameVersions;if(Array.isArray(data23)){const len5 = data23.length;for(let i5=0; i5<len5; i5++){const data24 = data23[i5];if(typeof data24 !== "string"){const err34 = {instancePath:instancePath+"/info/gameVersions/" + i5,schemaPath:"#/definitions/ICollectionInfo/properties/gameVersions/items/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.gameVersions.items.type,parentSchema:schema13.properties.gameVersions.items,data:data24};if(vErrors === null){vErrors = [err34];}else {vErrors.push(err34);}errors++;}}}else {const err35 = {instancePath:instancePath+"/info/gameVersions",schemaPath:"#/definitions/ICollectionInfo/properties/gameVersions/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema13.properties.gameVersions.type,parentSchema:schema13.properties.gameVersions,data:data23};if(vErrors === null){vErrors = [err35];}else {vErrors.push(err35);}errors++;}}}else {const err36 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema13.type,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err36];}else {vErrors.push(err36);}errors++;}}if(data.mods !== undefined){const data25 = data.mods;if(Array.isArray(data25)){const len6 = data25.length;for(let i6=0; i6<len6; i6++){if(!(validate12(data25[i6], {instancePath:instancePath+"/mods/" + i6,parentData:data25,parentDataProperty:i6,rootData}))){vErrors = vErrors === null ? validate12.errors : vErrors.concat(validate12.errors);errors = vErrors.length;}}}else {const err37 = {instancePath:instancePath+"/mods",schemaPath:"#/properties/mods/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.mods.type,parentSchema:schema12.properties.mods,data:data25};if(vErrors === null){vErrors = [err37];}else {vErrors.push(err37);}errors++;}}if(data.modRules !== undefined){const data27 = data.modRules;if(Array.isArray(data27)){const len7 = data27.length;for(let i7=0; i7<len7; i7++){if(!(validate16(data27[i7], {instancePath:instancePath+"/modRules/" + i7,parentData:data27,parentDataProperty:i7,rootData}))){vErrors = vErrors === null ? validate16.errors : vErrors.concat(validate16.errors);errors = vErrors.length;}}}else {const err38 = {instancePath:instancePath+"/modRules",schemaPath:"#/properties/modRules/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.modRules.type,parentSchema:schema12.properties.modRules,data:data27};if(vErrors === null){vErrors = [err38];}else {vErrors.push(err38);}errors++;}}}else {const err39 = {instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.type,parentSchema:schema12,data};if(vErrors === null){vErrors = [err39];}else {vErrors.push(err39);}errors++;}validate11.errors = vErrors;return errors === 0;}function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;const _errs0 = errors;let valid0 = false;const _errs1 = errors;if(!(validate11(data, {instancePath,parentData,parentDataProperty,rootData}))){vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);errors = vErrors.length;}const _valid0 = _errs1 === errors;valid0 = valid0 || _valid0;if(!valid0){const err0 = {instancePath,schemaPath:"#/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf",schema:schema11.anyOf,parentSchema:schema11,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}else {errors = _errs0;if(vErrors !== null){if(_errs0){vErrors.length = _errs0;}else {vErrors = null;}}}validate10.errors = vErrors;return errors === 0;}


/***/ }),

/***/ "./src/validationCode/dummy.js":
/*!*************************************!*\
  !*** ./src/validationCode/dummy.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

      function dummyFunc() {
        console.error('Standalone validation code relies on AJV module; validation may fail');
        return;
      }
      exports["default"] = dummyFunc;

/***/ }),

/***/ "./src/validationCode/validation.ts":
/*!******************************************!*\
  !*** ./src/validationCode/validation.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.validateICollection = void 0;
      const ICollection_validate_1 = __webpack_require__(/*! ./ICollection.validate */ "./src/validationCode/ICollection.validate.js");
      function validateICollection(data) {
        const res = (0, ICollection_validate_1.default)(data);
        return (res === false) ? ICollection_validate_1.default.prototype.constructor.errors : [];
      }
      exports.validateICollection = validateICollection;


/***/ }),

/***/ "./src/views/AddModsDialog.tsx":
/*!*************************************!*\
  !*** ./src/views/AddModsDialog.tsx ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const react_1 = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const session_1 = __webpack_require__(/*! ../actions/session */ "./src/actions/session.ts");
      const collectionCreate_1 = __webpack_require__(/*! ../collectionCreate */ "./src/collectionCreate.ts");
      const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
      function makeColumns(onSelect) {
        let collator;
        return [
          {
            id: 'name',
            name: 'Mod Name',
            description: 'Mod Name',
            calc: (mod) => vortex_api_1.util.renderModName(mod.mod),
            placement: 'table',
            edit: {},
            isDefaultSort: true,
            isSortable: true,
            filter: new vortex_api_1.TableTextFilter(true),
            sortFunc: (lhs, rhs, locale) => {
              if (collator === undefined) {
                collator = new Intl.Collator(locale, { sensitivity: 'base' });
              }
              return collator.compare(lhs, rhs);
            },
          }, {
            id: 'variant',
            name: 'Variant',
            description: 'The variant',
            calc: (mod) => { let _a, _b; return (_b = (_a = mod.mod.attributes) === null || _a === void 0 ? void 0 : _a.variant) !== null && _b !== void 0 ? _b : ''; },
            placement: 'table',
            edit: {},
          }, {
            id: 'version',
            name: 'Version',
            description: 'The version',
            calc: (mod) => { let _a, _b; return (_b = (_a = mod.mod.attributes) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : ''; },
            placement: 'table',
            edit: {},
          },
        ];
      }
      function AddModsDialog(props) {
        let _a;
        const { onAddSelection } = props;
        const { t } = (0, react_i18next_1.useTranslation)(constants_1.NAMESPACE);
        const store = (0, react_redux_1.useStore)();
        const dispatch = (0, react_redux_1.useDispatch)();
        const hide = React.useCallback(() => {
          dispatch((0, session_1.startAddModsToCollection)(undefined));
        }, []);
        const [selection, setSelection] = (0, react_1.useState)(new Set());
        const state = store.getState();
        const gameId = vortex_api_1.selectors.activeGameId(state);
        const collectionId = (0, react_redux_1.useSelector)(stateSel => stateSel.session.collections.addModsId);
        const collection = collectionId !== undefined
          ? (_a = state.persistent.mods[gameId]) === null || _a === void 0 ? void 0 : _a[collectionId]
          : undefined;
        const mods = state.persistent.mods[gameId];
        const modsWithState = React.useMemo(() => Object.keys(mods !== null && mods !== void 0 ? mods : {})
          .reduce((prev, modId) => {
            if (!(0, collectionCreate_1.alreadyIncluded)(collection === null || collection === void 0 ? void 0 : collection.rules, modId)
            && (mods[modId].type !== constants_1.MOD_TYPE)) {
              prev[modId] = {
                selected: selection.has(modId),
                mod: mods[modId],
              };
            }
            return prev;
          }, {}), [selection, collectionId]);
        const changeSelection = React.useCallback((modIds, selected) => {
          if (selected) {
            setSelection(new Set([].concat(Array.from(selection), modIds)));
          }
          else {
            setSelection(new Set(Array.from(selection).filter(modId => !modIds.includes(modId))));
          }
        }, [selection, setSelection, collectionId]);
        const columns = React.useMemo(() => makeColumns(changeSelection), [selection, setSelection, collectionId]);
        const addSelection = React.useCallback(() => {
          onAddSelection(collectionId, Array.from(selection));
          hide();
        }, [onAddSelection, hide, selection, collectionId]);
        const updateSelection = React.useCallback((modIds) => {
          setSelection(new Set(modIds));
        }, [setSelection]);
        const TableX = vortex_api_1.Table;
        return (React.createElement(vortex_api_1.Modal, { id: 'add-mods-to-collection-dialog', className: 'collection-add-mods-dialog', show: collection !== undefined, onHide: hide },
                                    React.createElement(vortex_api_1.Modal.Header, null,
                                                        React.createElement(vortex_api_1.Modal.Title, null, vortex_api_1.util.renderModName(collection))),
                                    React.createElement(vortex_api_1.Modal.Body, null, (Object.keys(modsWithState).length > 0)
                                      ? (React.createElement(React.Fragment, null,
                                                             t('Select (click, shift-click, ...) installed mods you want to add to your collection below:'),
                                                             React.createElement(TableX, { tableId: 'collection-add-mods', data: modsWithState, staticElements: columns, actions: [], showDetails: false, hasActions: false, onChangeSelection: updateSelection }))) : (React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'folder-download', fill: true, text: t('You don\'t have any installed mods') }))),
                                    React.createElement(vortex_api_1.Usage, { persistent: true, infoId: 'add-mods-from-mods-page' },
                                                        React.createElement("p", null, t('You can also add mods to a collection from the mods screen: '
                + 'Right-click > Add to Collection')),
                                                        React.createElement("p", null, t('Mods need to be in an installed state in order to add them to a collection. '
                + 'If the mod you want to add is not in this list, make sure it\'s installed.'))),
                                    React.createElement(vortex_api_1.Modal.Footer, null,
                                                        React.createElement(react_bootstrap_1.Button, { onClick: hide }, t('Close')),
                                                        React.createElement(react_bootstrap_1.Button, { onClick: addSelection }, t('Add Selection')))));
      }
      exports["default"] = React.memo(AddModsDialog);


/***/ }),

/***/ "./src/views/CollectionList/StartPage.tsx":
/*!************************************************!*\
  !*** ./src/views/CollectionList/StartPage.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const settings_1 = __webpack_require__(/*! ../../actions/settings */ "./src/actions/settings.ts");
      const collectionCreate_1 = __webpack_require__(/*! ../../collectionCreate */ "./src/collectionCreate.ts");
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
      const transformCollection_1 = __webpack_require__(/*! ../../util/transformCollection */ "./src/util/transformCollection.ts");
      const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
      const RemoteTile_1 = __webpack_require__(/*! ../CollectionTile/RemoteTile */ "./src/views/CollectionTile/RemoteTile.tsx");
      const _ = __webpack_require__(/*! lodash */ "lodash");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const react_select_1 = __webpack_require__(/*! react-select */ "react-select");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const FEEDBACK_URL = 'https://docs.google.com/forms/d/e/1FAIpQLSc3csy4ycVBECvHQDgri37Gqq1gOuTQ7LcpiIaOkGHpDsW4kA/viewform?usp=sf_link';
      const BUG_REPORT_URL = 'https://docs.google.com/forms/d/e/1FAIpQLSdmDBdGjTQVRa7wRouN4yP6zMvqsxTT86R-DwmQXZq7SWGCSg/viewform?usp=sf_link';
      function dateCompare(lhs, rhs) {
        return (new Date(lhs !== null && lhs !== void 0 ? lhs : 0)).getTime() - (new Date(rhs !== null && rhs !== void 0 ? rhs : 0)).getTime();
      }
      const nop = () => null;
      const validRE = /^[\p{L}\p{N} -]*$/u;
      function validateCollectionName(t, input) {
        if ((input.length < constants_1.MIN_COLLECTION_NAME_LENGTH) || (input.length > constants_1.MAX_COLLECTION_NAME_LENGTH)) {
          return t('The name bust be between {{min}}-{{max}} characters long', {
            replace: {
              min: constants_1.MIN_COLLECTION_NAME_LENGTH,
              max: constants_1.MAX_COLLECTION_NAME_LENGTH,
            },
          });
        }
        if (input.match(validRE) === null) {
          return t('Invalid characters, only letters, numbers, space and - are allowed.');
        }
        return undefined;
      }
      function AddCard(props) {
        const { t, onClick } = props;
        const classes = ['collection-add-btn'];
        return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' '), bsStyle: 'default', onClick: onClick },
                                    React.createElement(react_bootstrap_1.Panel.Body, { className: 'collection-thumbnail-body' },
                                                        React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'folder-add', text: t('Discover more collections') }))));
      }
      function CreateCard(props) {
        const { t, onTrackClick } = props;
        const classes = ['collection-add-btn'];
        const actions = React.useRef([]);
        React.useEffect(() => {
          actions.current = [
            {
              title: 'From Profile',
              icon: 'profile',
              action: () => {
                onTrackClick('Collections', 'From profile');
                props.onCreateFromProfile();
              },
            }, {
              title: 'Empty',
              icon: 'show',
              action: () => {
                onTrackClick('Collections', 'Empty');
                props.onCreateEmpty();
              },
            }, {
              title: 'Quick Collection',
              icon: 'highlight-lab',
              action: () => {
                onTrackClick('Collections', 'Quick Collection');
                props.onCreateQuickCollection();
              },
            },
          ];
        }, [props.onCreateFromProfile, props.onCreateEmpty, props.onCreateQuickCollection]);
        return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' '), bsStyle: 'default' },
                                    React.createElement(react_bootstrap_1.Panel.Body, { className: 'collection-thumbnail-body' },
                                                        React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'add', text: t('Create a collection'), fill: true }),
                                                        React.createElement("div", { className: 'hover-menu' },
                                                                            React.createElement("div", { key: 'primary-buttons', className: 'hover-content' },
                                                                                                React.createElement(vortex_api_1.IconBar, { className: 'buttons', group: 'collection-actions', staticElements: actions.current, collapse: false, buttonType: 'text', orientation: 'vertical', clickAnywhere: true, t: t }))))));
      }
      class StartPage extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.setSortAdded = (value) => {
            if (!!value) {
              this.props.onSetSortAdded(value.value);
            }
          };
          this.setSortWorkshop = (value) => {
            if (!!value) {
              this.props.onSetSortWorkshop(value.value);
            }
          };
          this.setActiveTab = (tabId) => {
            this.props.onSetActiveTab(tabId);
            this.context.api.events.emit('analytics-track-navigation', `collections/${tabId}`);
          };
          this.openCollections = () => {
            const { game } = this.props;
            this.context.api.events.emit('analytics-track-click-event', 'Collections', 'Discover more');
            vortex_api_1.util.opn(`${constants_1.NEXUS_BASE_GAMES_URL}/${vortex_api_1.util.nexusGameId(game)}/collections`).catch(() => null);
          };
          this.openMyCollectionsPage = () => {
            this.context.api.events.emit('analytics-track-click-event', 'Collections', 'Open My Collections');
            vortex_api_1.util.opn(`${constants_1.NEXUS_BASE_URL}/my-collections`).catch(() => null);
          };
          this.trackEvent = (namespace, eventName) => {
            this.context.api.events.emit('analytics-track-click-event', namespace, eventName);
          };
          this.openFeedback = () => {
            vortex_api_1.util.opn(FEEDBACK_URL).catch(() => null);
          };
          this.openBugReport = () => {
            vortex_api_1.util.opn(BUG_REPORT_URL).catch(() => null);
          };
          this.quickCollection = async () => {
            try {
              await (0, collectionCreate_1.initFromProfile)(this.context.api);
              this.refreshImages();
            }
            catch (err) {
              if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                this.context.api.showErrorNotification('Failed to create quick collection', err);
              }
            }
          };
          this.fromProfile = async () => {
            const { profile } = this.props;
            try {
              await (0, collectionCreate_1.initFromProfile)(this.context.api, profile.id);
              this.refreshImages();
            }
            catch (err) {
              if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                this.context.api.showErrorNotification('Failed to init collection', err);
              }
            }
          };
          this.fromEmpty = async () => {
            const { t, onCreateCollection } = this.props;
            try {
              const result = await this.context.api.showDialog('question', 'New empty Collection', {
                text: 'Create an empty collection which you can manually add mods to.',
                input: [{ id: 'name', label: 'Collection Name', type: 'text' }],
                condition: content => (0, transformCollection_1.validateName)(t, content),
              }, [
                { label: 'Cancel' },
                { label: 'Create', default: true },
              ]);
              if (result.action === 'Create') {
                await onCreateCollection(result.input['name']);
                this.refreshImages();
              }
            }
            catch (err) {
              this.context.api.showErrorNotification('Failed to init collection', err);
            }
          };
          this.initState({
            createOpen: false,
            imageTime: Date.now(),
            mousePosition: { x: 0, y: 0 },
            collectionsEx: { added: [], workshop: [] },
          });
        }
        componentDidMount() {
          const collectionsNow = Object.values(this.props.mods).filter(mod => mod.type === constants_1.MOD_TYPE);
          this.updateSorted(collectionsNow, this.props.sortAdded, this.props.sortWorkshop, false)
            .then(() => this.updateSorted(collectionsNow, this.props.sortAdded, this.props.sortWorkshop, false))
            .catch(err => {
              (0, vortex_api_1.log)('error', 'failed to update list of collections', {
                error: err.message,
              });
            });
        }
        componentDidUpdate(prevProps, prevState) {
          const collectionsPrev = Object.values(prevProps.mods).filter(mod => mod.type === constants_1.MOD_TYPE);
          const collectionsNow = Object.values(this.props.mods).filter(mod => mod.type === constants_1.MOD_TYPE);
          if (!_.isEqual(collectionsPrev, collectionsNow)
            || (prevProps.sortAdded !== this.props.sortAdded)
            || (prevProps.sortWorkshop !== this.props.sortWorkshop)
            || (prevProps.localState.ownCollections !== this.props.localState.ownCollections)) {
            this.updateSorted(collectionsNow, this.props.sortAdded, this.props.sortWorkshop, true);
          }
        }
        render() {
          const { t, activeTab, installing, profile, matchedReferences, mods, onClone, onEdit, onPause, onInstallCollection, onRemove, onResume, onUpdate, onUpload, onView, sortAdded, sortWorkshop } = this.props;
          const { imageTime, collectionsEx } = this.state;
          const { added, workshop } = collectionsEx;
          return (React.createElement(react_bootstrap_1.Tabs, { id: 'collection-start-page', activeKey: activeTab, onSelect: this.setActiveTab },
                                      React.createElement(react_bootstrap_1.Tab, { tabClassName: 'collection-tab', eventKey: 'active-collections', title: React.createElement(React.Fragment, null,
                                                                                                                                                                              React.createElement(vortex_api_1.Icon, { name: 'add' }),
                                                                                                                                                                              t('Added Collections')) },
                                                          React.createElement(react_bootstrap_1.Panel, null,
                                                                              React.createElement(react_bootstrap_1.Panel.Heading, null,
                                                                                                  React.createElement(react_bootstrap_1.Panel.Title, null, t('View and manage collections created by other users.')),
                                                                                                  React.createElement("div", { className: 'flex-fill' }),
                                                                                                  React.createElement("div", { className: 'collection-sort-container' },
                                                                                                                      t('Sort by:'),
                                                                                                                      React.createElement(react_select_1.default, { className: 'select-compact', options: [
                                                                                                                        { value: 'alphabetical', label: t('Name A-Z') },
                                                                                                                        { value: 'datedownloaded', label: t('Date downloaded') },
                                                                                                                        { value: 'recentlyupdated', label: t('Recently updated') },
                                                                                                                      ], value: sortAdded, onChange: this.setSortAdded, clearable: false, autosize: false, searchable: false }))),
                                                                              React.createElement(react_bootstrap_1.Panel.Body, null,
                                                                                                  React.createElement("div", { className: 'collection-list' },
                                                                                                                      React.createElement(AddCard, { t: t, onClick: this.openCollections }),
                                                                                                                      added.map(mod => {
                                                                                                                        let _a, _b;
                                                                                                                        return React.createElement(CollectionTile_1.default, { key: mod.mod.id, t: t, gameId: profile.gameId, imageTime: imageTime, installing: installing, mods: mods, incomplete: (_b = (_a = matchedReferences[mod.mod.id]) === null || _a === void 0 ? void 0 : _a.includes) === null || _b === void 0 ? void 0 : _b.call(_a, null), collection: mod.mod, infoCache: this.props.infoCache, onView: onView, onRemove: onRemove, onResume: onResume, onPause: onPause, onUpdate: onUpdate, details: true });
                                                                                                                      }))))),
                                      React.createElement(react_bootstrap_1.Tab, { tabClassName: 'collection-tab', eventKey: 'collection-workshop', title: React.createElement(React.Fragment, null,
                                                                                                                                                                               React.createElement(vortex_api_1.Icon, { name: 'highlight-tool' }),
                                                                                                                                                                               t('Workshop')) },
                                                          React.createElement(react_bootstrap_1.Panel, null,
                                                                              React.createElement(react_bootstrap_1.Panel.Heading, null,
                                                                                                  React.createElement(react_bootstrap_1.Panel.Title, null,
                                                                                                                      React.createElement(react_i18next_1.Trans, { ns: constants_1.NAMESPACE, i18nKey: 'collection-own-page' },
                                                                                                                                          "Build your own collections and share them with the Nexus Mods community. You can view all your uploaded collections\u00A0",
                                                                                                                                          React.createElement("a", { onClick: this.openMyCollectionsPage, className: 'my-collections-page-link', title: t('Open My Collections Page') }, "here."))),
                                                                                                  React.createElement("div", { className: 'flex-fill' }),
                                                                                                  React.createElement("div", { className: 'collection-sort-container' },
                                                                                                                      t('Sort by:'),
                                                                                                                      React.createElement(react_select_1.default, { className: 'select-compact', options: [
                                                                                                                        { value: 'alphabetical', label: t('Name A-Z') },
                                                                                                                        { value: 'datecreated', label: t('Date created') },
                                                                                                                        { value: 'recentlyupdated', label: t('Recently updated') },
                                                                                                                      ], value: sortWorkshop, onChange: this.setSortWorkshop, clearable: false, autosize: false, searchable: false }))),
                                                                              React.createElement(react_bootstrap_1.Panel.Body, null,
                                                                                                  React.createElement("div", { className: 'collection-list' },
                                                                                                                      React.createElement(CreateCard, { t: t, onCreateFromProfile: this.fromProfile, onCreateQuickCollection: this.quickCollection, onCreateEmpty: this.fromEmpty, onTrackClick: this.trackEvent }),
                                                                                                                      workshop.map(mod => {
                                                                                                                        let _a, _b, _c, _d;
                                                                                                                        return (mod.mod !== undefined)
                                                                                                                          ? (React.createElement(CollectionTile_1.default, { t: t, key: mod.mod.id, gameId: profile.gameId, collection: mod.mod, infoCache: this.props.infoCache, imageTime: imageTime, mods: mods, incomplete: (mod.mod === undefined)
                                            || ((_b = (_a = matchedReferences[mod.mod.id]) === null || _a === void 0 ? void 0 : _a.includes) === null || _b === void 0 ? void 0 : _b.call(_a, null)), onEdit: onEdit, onRemove: onRemove, onUpload: onUpload, details: true })) : (React.createElement(RemoteTile_1.default, { t: t, key: mod.revision.id, revision: mod.revision, added: mod.added, incomplete: (mod.added === undefined)
                                        || ((_d = (_c = matchedReferences[mod.added.id]) === null || _c === void 0 ? void 0 : _c.includes) === null || _d === void 0 ? void 0 : _d.call(_c, null)), onInstallCollection: onInstallCollection, onCloneCollection: onClone, onResumeCollection: onResume }));
                                                                                                                      })))))));
        }
        name(input) {
          let _a, _b, _c;
          return (input.mod !== undefined)
            ? vortex_api_1.util.renderModName(input.mod)
            : ((_c = (_b = (_a = input.revision) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : '');
        }
        sorter(sorting) {
          let _a;
          const alphabetical = (lhs, rhs) => this.name(lhs).localeCompare(this.name(rhs));
          return (_a = {
            alphabetical,
            datedownloaded: (lhs, rhs) => { let _a, _b, _c, _d; return dateCompare((_b = (_a = rhs.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.installTime, (_d = (_c = lhs.mod) === null || _c === void 0 ? void 0 : _c.attributes) === null || _d === void 0 ? void 0 : _d.installTime); },
            datecreated: (lhs, rhs) => {
              let _a, _b, _c, _d, _e, _f, _g, _h;
              return dateCompare((_c = (_b = (_a = rhs.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.installTime) !== null && _c !== void 0 ? _c : (_d = rhs.revision) === null || _d === void 0 ? void 0 : _d.createdAt, (_g = (_f = (_e = lhs.mod) === null || _e === void 0 ? void 0 : _e.attributes) === null || _f === void 0 ? void 0 : _f.installTime) !== null && _g !== void 0 ? _g : (_h = lhs.revision) === null || _h === void 0 ? void 0 : _h.createdAt);
            },
            recentlyupdated: (lhs, rhs) => {
              let _a, _b, _c, _d, _e, _f;
              return dateCompare((_b = (_a = rhs.revision) === null || _a === void 0 ? void 0 : _a.updatedAt) !== null && _b !== void 0 ? _b : (_c = rhs.mod.attributes) === null || _c === void 0 ? void 0 : _c.installTime, (_e = (_d = lhs.revision) === null || _d === void 0 ? void 0 : _d.updatedAt) !== null && _e !== void 0 ? _e : (_f = lhs.mod.attributes) === null || _f === void 0 ? void 0 : _f.installTime);
            },
          }[sorting]) !== null && _a !== void 0 ? _a : alphabetical;
        }
        updateSorted(collections, sortAdded, sortWorkshop, allowMetaUpdate) {
          return Promise.all(collections.map(async (mod) => {
            let _a;
            const { revisionId, collectionSlug, revisionNumber } = (_a = mod.attributes) !== null && _a !== void 0 ? _a : {};
            const revision = revisionNumber !== undefined
              ? await this.props.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber, allowMetaUpdate ? 'allow' : 'avoid')
              : undefined;
            return { mod, revision };
          }))
            .then((result) => {
              let { foreign, own } = result.reduce((prev, mod) => {
                if (vortex_api_1.util.getSafe(mod.mod.attributes, ['editable'], false)) {
                  prev.own.push(mod);
                }
                else {
                  prev.foreign.push(mod);
                }
                return prev;
              }, { foreign: [], own: [] });
              const installed = new Set(own.map(res => { let _a; return (_a = res.mod.attributes) === null || _a === void 0 ? void 0 : _a['collectionSlug']; }));
              own.push(...this.props.localState.ownCollections
                .filter(coll => { let _a; return !installed.has((_a = coll.collection) === null || _a === void 0 ? void 0 : _a.slug); })
                .map(coll => {
                  let _a;
                  return ({
                    mod: undefined,
                    added: (_a = foreign.find(iter => { let _a, _b, _c; return ((_b = (_a = iter.revision) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.slug) === ((_c = coll.collection) === null || _c === void 0 ? void 0 : _c.slug); })) === null || _a === void 0 ? void 0 : _a.mod,
                    revision: coll,
                  });
                }));
              foreign = foreign.sort(this.sorter(sortAdded));
              own = own.sort(this.sorter(sortWorkshop));
              this.nextState.collectionsEx = { added: foreign, workshop: own };
            });
        }
        refreshImages() {
          this.nextState.imageTime = Date.now();
        }
      }
      function mapStateToProps(state) {
        let _a, _b, _c;
        return {
          userInfo: (_a = state.persistent['nexus']) === null || _a === void 0 ? void 0 : _a.userInfo,
          sortAdded: (_b = state.settings.collections.sortAdded) !== null && _b !== void 0 ? _b : 'datedownloaded',
          sortWorkshop: (_c = state.settings.collections.sortWorkshop) !== null && _c !== void 0 ? _c : 'recentlyupdated',
        };
      }
      function mapDispatchToProps(dispatch) {
        return {
          onSetSortAdded: (sorting) => dispatch((0, settings_1.setSortAdded)(sorting)),
          onSetSortWorkshop: (sorting) => dispatch((0, settings_1.setSortWorkshop)(sorting)),
        };
      }
      exports["default"] = (0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(StartPage);


/***/ }),

/***/ "./src/views/CollectionList/index.tsx":
/*!********************************************!*\
  !*** ./src/views/CollectionList/index.tsx ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const persistent_1 = __webpack_require__(/*! ../../actions/persistent */ "./src/actions/persistent.ts");
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
      const extension_1 = __webpack_require__(/*! ../../util/extension */ "./src/util/extension.ts");
      const CollectionPageEdit_1 = __webpack_require__(/*! ../CollectionPageEdit */ "./src/views/CollectionPageEdit/index.tsx");
      const CollectionPageView_1 = __webpack_require__(/*! ../CollectionPageView */ "./src/views/CollectionPageView/index.tsx");
      const StartPage_1 = __webpack_require__(/*! ./StartPage */ "./src/views/CollectionList/StartPage.tsx");
      const React = __webpack_require__(/*! react */ "react");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
      const emptyObj = {};
      const emptyArr = [];
      class CollectionsMainPage extends vortex_api_1.ComponentEx {
        constructor(props) {
          let _a;
          super(props);
          this.onUpdateMeta = () => {
            this.props.onUpdateMeta();
            this.context.api.events.emit('analytics-track-click-event', 'Collections', 'Refresh');
          };
          this.setActiveTab = (tabId) => {
            this.nextState.activeTab = tabId;
          };
          this.createCollection = (name) => {
            const { profile, onCreateCollection } = this.props;
            onCreateCollection(profile, name);
          };
          this.deselectCollection = () => {
            this.nextState.selectedCollection = undefined;
          };
          this.resetMainPage = () => {
            this.deselectCollection();
          };
          this.view = (modId) => {
            this.showPage('view', modId);
          };
          this.edit = async (modId) => {
            let _a, _b;
            const { mods, userInfo } = this.props;
            const { api } = this.context;
            if (mods[modId] === undefined) {
              return;
            }
            const author = (_a = mods[modId].attributes) === null || _a === void 0 ? void 0 : _a['uploaderId'];
            if ((author !== undefined) && (author !== (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId))) {
              const result = await api.showDialog('question', 'Edit Collection', {
                text: 'This collection has been uploaded with a different account ({{uploadAuthor}}) '
                        + 'than you\'re using now ({{currentUser}}). '
                        + 'If you edit and upload this collection now it will be uploaded as a new '
                        + 'collection by your current user.',
                parameters: {
                  uploadAuthor: mods[modId].attributes['uploader'],
                  currentUser: (_b = userInfo === null || userInfo === void 0 ? void 0 : userInfo.name) !== null && _b !== void 0 ? _b : '<Logged out>',
                },
              }, [
                { label: 'Cancel' },
                { label: 'Continue' },
              ]);
              if (result.action === 'Cancel') {
                return;
              }
            }
            this.showPage('edit', modId);
          };
          this.pause = async (modId, silent) => {
            let _a;
            const { downloads, mods } = this.props;
            const collection = mods[modId];
            if (collection === undefined) {
              return;
            }
            ((_a = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _a !== void 0 ? _a : []).forEach(rule => {
              const dlId = vortex_api_1.util.findDownloadByRef(rule.reference, downloads);
              if (dlId !== undefined) {
                this.context.api.events.emit('pause-download', dlId);
              }
            });
            const { api } = this.context;
            await api.emitAndAwait('cancel-dependency-install', modId);
            this.props.driver.cancel();
            api.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + modId);
            if (silent !== true) {
              api.sendNotification({
                id: 'collection-pausing',
                type: 'success',
                title: 'Collection pausing',
                message: 'Already queued mod installations will still finish',
              });
            }
          };
          this.clone = async (collectionId) => {
            const id = await this.props.onCloneCollection(collectionId);
            if (id !== undefined) {
              this.showPage('edit', id);
            }
          };
          this.cancel = async (modId, cancel) => {
            const { profile } = this.props;
            return this.props.onRemoveCollection(profile.gameId, modId, cancel !== null && cancel !== void 0 ? cancel : true);
          };
          this.voteSuccess = async (modId, success) => {
            const { mods } = this.props;
            const { api } = this.context;
            const collection = mods[modId];
            if (collection === undefined) {
              return;
            }
            const { revisionId } = collection.attributes;
            if (revisionId === undefined) {
              return;
            }
            const vote = success ? 'positive' : 'negative';
            const voted = (await api.emitAndAwait('rate-nexus-collection-revision', parseInt(revisionId, 10), vote))[0];
            if (voted.success) {
              api.store.dispatch((0, persistent_1.updateSuccessRate)(revisionId, vote, voted.averageRating.average, voted.averageRating.total));
            }
          };
          this.remove = (modId) => {
            let _a, _b;
            const { mods } = this.props;
            const { api } = this.context;
            if (mods[modId] === undefined) {
              return;
            }
            try {
              if ((_b = (_a = mods[modId]) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.editable) {
                api.events.emit('analytics-track-click-event', 'Collections', 'Remove Workshop Collection');
                return this.removeWorkshop(modId)
                  .catch(err => {
                    const allowReport = !['EPERM'].includes(err.code)
                            && !(err instanceof vortex_api_1.util.ProcessCanceled)
                            && !(err instanceof vortex_api_1.util.UserCanceled);
                    api.showErrorNotification('Failed to remove collection', err, { allowReport });
                  });
              }
              else {
                api.events.emit('analytics-track-click-event', 'Collections', 'Remove Added Collection');
                return this.cancel(modId, false)
                  .catch(err => {
                    api.showErrorNotification('Failed to remove collection', err, {
                      allowReport: !['EPERM'].includes(err.code),
                    });
                  });
              }
            }
            catch (err) {
              if (err instanceof vortex_api_1.util.UserCanceled) {
                (0, vortex_api_1.log)('info', 'collection removal canceled by user');
              }
              else if (err instanceof vortex_api_1.util.ProcessCanceled) {
                api.sendNotification({
                  type: 'warning',
                  title: 'Removal failed',
                  message: err.message,
                });
              }
              else {
                api.showErrorNotification('Failed to remove collection', err);
              }
            }
          };
          this.update = async (collectionId) => {
            const { mods } = this.props;
            const { api } = this.context;
            const state = api.getState();
            const gameMode = vortex_api_1.selectors.activeGameId(state);
            const mod = mods[collectionId];
            if (mod === undefined) {
              return;
            }
            const downloadGame = vortex_api_1.util.getSafe(mod.attributes, ['downloadGame'], gameMode);
            const newestFileId = vortex_api_1.util.getSafe(mod.attributes, ['newestVersion'], undefined);
            await vortex_api_1.util.toPromise(cb => {
              let _a, _b;
              return this.context.api.events.emit('collection-update', downloadGame, (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.collectionSlug, newestFileId, (_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.source, collectionId, cb);
            });
          };
          this.upload = async (collectionId) => {
            let _a;
            (0, util_1.uploadCollection)(this.context.api, (_a = this.props.profile) === null || _a === void 0 ? void 0 : _a.id, collectionId);
          };
          this.installManually = (collectionId, rules) => {
            const { api } = this.context;
            const ruleGroups = rules.reduce((prev, rule) => {
              if (prev[rule.type] !== undefined) {
                prev[rule.type].push(rule);
              }
              else {
                (0, vortex_api_1.log)('error', 'unexpected rule encountered', { collectionId, ruleType: rule.type });
              }
              return prev;
            }, { requires: [], recommends: [] });
            const eaa = (ruleList, recommended) => {
              if (ruleList.length === 0) {
                return Promise.resolve();
              }
              else {
                return api.emitAndAwait('install-from-dependencies', collectionId, ruleList, recommended);
              }
            };
            eaa(ruleGroups.requires, false)
              .then(() => eaa(ruleGroups.recommends, true))
              .catch(err => {
                if (err instanceof vortex_api_1.util.UserCanceled) {
                  return;
                }
                api.showErrorNotification('Failed to install dependencies', err, {
                  allowReport: !(err instanceof vortex_api_1.util.ProcessCanceled),
                });
              });
          };
          this.resume = async (modId) => {
            const { driver, mods, profile, userInfo } = this.props;
            if (mods[modId] === undefined) {
              return;
            }
            if ((userInfo === null) || (userInfo === undefined)) {
              const { api } = this.context;
              api.showDialog('info', 'Not logged in', {
                text: 'You have to be logged in with Nexus Mods to install collections.',
              }, [{ label: 'Continue' }]);
            }
            else if (mods[modId] !== undefined) {
              driver.start(profile, mods[modId]);
            }
          };
          this.initState({
            selectedCollection: undefined,
            matchedReferences: this.updateMatchedReferences(this.props),
            viewMode: 'view',
            activeTab: 'active-collections',
          });
          if (props.onAddCallback !== undefined) {
            props.onAddCallback('viewCollection', (collectionId) => {
              this.showPage('view', collectionId);
            });
            props.onAddCallback('editCollection', () => (collectionId) => {
              this.showPage('edit', collectionId);
            });
          }
          (_a = props.resetCB) === null || _a === void 0 ? void 0 : _a.call(props, this.resetMainPage);
          this.mMatchRefDebouncer = new vortex_api_1.util.Debouncer(() => {
            this.nextState.matchedReferences = this.updateMatchedReferences(this.props);
            return Promise.resolve();
          }, 2000);
        }
        UNSAFE_componentWillReceiveProps(newProps) {
          if (this.props.mods !== newProps.mods) {
            this.mMatchRefDebouncer.schedule();
          }
        }
        componentWillUnmount() {
          this.mMatchRefDebouncer.clear();
        }
        render() {
          const { t, downloads, driver, game, localState, mods, notifications, profile, pathTool } = this.props;
          const { activeTab, matchedReferences, selectedCollection, viewMode } = this.state;
          if (profile === undefined) {
            return null;
          }
          const collection = (selectedCollection !== undefined)
            ? mods[selectedCollection]
            : undefined;
          let content = null;
          if (collection === undefined) {
            content = (React.createElement(React.Fragment, null,
                                           React.createElement(vortex_api_1.tooltip.IconButton, { className: 'collections-refresh-meta', icon: 'refresh', tooltip: t('Download the latest meta information about your installed and owned collections. '
                        + 'This will reset local changes to names of collections in your workshop.'), onClick: this.onUpdateMeta }, t('Refresh')),
                                           React.createElement(StartPage_1.default, { t: t, game: game, localState: localState, installing: driver.installDone ? undefined : driver.collection, infoCache: driver.infoCache, profile: profile, mods: mods, matchedReferences: matchedReferences !== null && matchedReferences !== void 0 ? matchedReferences : emptyObj, activeTab: activeTab, onView: this.view, onEdit: this.edit, onRemove: this.remove, onUpdate: this.update, onUpload: this.upload, onClone: this.clone, onCreateCollection: this.createCollection, onResume: this.resume, onPause: this.pause, onSetActiveTab: this.setActiveTab, onInstallCollection: this.props.onInstallCollection })));
          }
          else {
            content = (React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                                           React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                               React.createElement(vortex_api_1.tooltip.IconButton, { className: 'collection-back-btn', tooltip: 'Return to overview', icon: 'nav-back', onClick: this.deselectCollection }, t('View All Collections'))),
                                           React.createElement(vortex_api_1.FlexLayout.Flex, null, (viewMode === 'view') ? (React.createElement(CollectionPageView_1.default, { t: t, className: 'collection-details', driver: this.props.driver, profile: profile, collection: collection, mods: mods, downloads: downloads, notifications: notifications, onAddCallback: this.props.onAddCallback, onView: this.view, onPause: this.pause, onCancel: this.cancel, onClone: this.clone, onResume: this.resume, onInstallManually: this.installManually, onVoteSuccess: this.voteSuccess }))
                                           : (React.createElement(CollectionPageEdit_1.default, { profile: profile, collection: collection, mods: mods, driver: this.props.driver, onRemove: this.remove, onUpload: this.upload, exts: this.props.exts, pathTool: pathTool })))));
          }
          return (React.createElement(vortex_api_1.MainPage, { id: 'collection-page' },
                                      React.createElement(vortex_api_1.MainPage.Body, null, content)));
        }
        showPage(page, modId) {
          this.nextState.selectedCollection = modId;
          this.nextState.viewMode = page;
        }
        async removeWorkshop(modId) {
          const { mods, profile } = this.props;
          const { api } = this.context;
          const result = await api.showDialog('question', 'Remove Collection (Workshop)', {
            text: 'Deleting a collection will not remove the mods that have been added to it.\n\n'
                + 'Any changes made to this collection since the last upload to Nexus Mods will '
                + 'be lost.\n\n'
                + 'Are you sure you want to remove "{{collectionName}}" from your Workshop?',
            parameters: {
              collectionName: vortex_api_1.util.renderModName(mods[modId]),
            },
          }, [
            { label: 'Cancel' },
            { label: 'Remove' },
          ]);
          if (result.action === 'Remove') {
            await vortex_api_1.util.toPromise(cb => api.events.emit('remove-mod', profile.gameId, modId, cb, {
              incomplete: true,
            }));
          }
        }
        updateMatchedReferences(props) {
          const { mods, profile } = props;
          const collections = Object.values(mods).filter(mod => mod.type === constants_1.MOD_TYPE);
          return collections.reduce((prev, collection) => {
            prev[collection.id] =
                (collection.rules || [])
                  .filter(rule => (rule.type === 'requires') && !rule['ignored'])
                  .map(rule => {
                    let _a, _b;
                    const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
                    if ((mod !== undefined) && !((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[mod.id]) === null || _b === void 0 ? void 0 : _b.enabled)) {
                      return null;
                    }
                    return mod !== null && mod !== void 0 ? mod : null;
                  });
            return prev;
          }, {});
        }
      }
      function mapStateToProps(state) {
        let _a, _b;
        const profile = vortex_api_1.selectors.activeProfile(state);
        const game = profile !== undefined ? vortex_api_1.selectors.gameById(state, profile.gameId) : undefined;
        return {
          game,
          profile,
          mods: profile !== undefined ? ((_a = state.persistent.mods[profile.gameId]) !== null && _a !== void 0 ? _a : emptyObj) : emptyObj,
          notifications: state.session.notifications.notifications,
          downloads: state.persistent.downloads.files,
          userInfo: (_b = state.persistent['nexus']) === null || _b === void 0 ? void 0 : _b.userInfo,
          exts: profile !== undefined ? (0, extension_1.findExtensions)(state, profile.gameId) : emptyArr,
        };
      }
      function mapDispatchToProps(dispatch) {
        return {
          removeMod: (gameId, modId) => dispatch(vortex_api_1.actions.removeMod(gameId, modId)),
        };
      }
      exports["default"] = (0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)((0, react_i18next_1.withTranslation)([constants_1.NAMESPACE, 'common'])(CollectionsMainPage));


/***/ }),

/***/ "./src/views/CollectionModsPageAttributeRenderer.tsx":
/*!***********************************************************!*\
  !*** ./src/views/CollectionModsPageAttributeRenderer.tsx ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function TooltipItem(props) {
        const { name } = props;
        return (React.createElement("li", null, name));
      }
      function Tooltip(props) {
        const { collectionNames } = props;
        return (React.createElement("ul", { className: 'collection-mods-page-attrib-tooltip' }, collectionNames.map((name, idx) => React.createElement(TooltipItem, { key: `${name}${idx}`, name: name }))));
      }
      function nop() {
      }
      function CollectionCount(props) {
        const { collectionNames, modId } = props;
        const filtered = collectionNames.slice(1);
        const tip = React.createElement(Tooltip, { collectionNames: filtered });
        return (React.createElement(vortex_api_1.tooltip.Button, { id: `${modId}-collection-count`, className: 'collection-mods-page-attr-addendum', tooltip: tip, onClick: nop }, `+${filtered.length}`));
      }
      function CollectionModsPageAttributeRenderer(props) {
        const { collections, detailCell, modId } = props;
        const collectionNames = collections.map(collection => vortex_api_1.util.renderModName(collection));
        const count = collectionNames.length;
        return (count > 0)
          ? (React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-mods-page-attribute-renderer' },
                                 React.createElement(vortex_api_1.FlexLayout.Fixed, null, detailCell ? (React.createElement("ul", null, collectionNames.map(name => (React.createElement("li", { key: name }, name))))) : (React.createElement("div", null, collectionNames[0]))),
                                 ((count > 1) && !detailCell) ? (React.createElement(CollectionCount, { collectionNames: collectionNames, modId: modId })) : null)) : null;
      }
      exports["default"] = CollectionModsPageAttributeRenderer;


/***/ }),

/***/ "./src/views/CollectionPageEdit/FileOverrides.tsx":
/*!********************************************************!*\
  !*** ./src/views/CollectionPageEdit/FileOverrides.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function FileOverrides(props) {
        let _a;
        const { t, collection, mods, onSetCollectionAttribute, pathTool } = props;
        const { discovery } = (0, react_redux_1.useSelector)(mapStateToProps);
        const [showOverlay, setShowOverlay] = React.useState(undefined);
        const target = React.useRef();
        const container = React.useRef();
        const modsWithOverrides = React.useMemo(() => {
          let _a;
          return ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type))
            .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
            .filter(mod => { let _a; return ((_a = mod === null || mod === void 0 ? void 0 : mod.fileOverrides) !== null && _a !== void 0 ? _a : []).length > 0; });
        }, [collection, mods]);
        const toggleOverride = React.useCallback((value, dataId) => {
          onSetCollectionAttribute(['fileOverrides', dataId], value);
        }, []);
        const togglePopover = React.useCallback((evt) => {
          const modId = evt.currentTarget.getAttribute('data-modid');
          if (showOverlay === modId) {
            setShowOverlay(undefined);
          }
          else {
            target.current = evt.currentTarget;
            setShowOverlay(modId);
          }
        }, [setShowOverlay, showOverlay]);
        const hide = React.useCallback((evt) => {
          evt.preventDefault();
          setShowOverlay(undefined);
        }, []);
        const getBounds = React.useCallback(() => {
          return container.current !== undefined ? container.current.getBoundingClientRect() : {
            left: 0,
            top: 0,
            width: window.innerWidth,
            height: window.innerHeight,
            right: window.innerWidth,
            bottom: window.innerHeight,
          };
        }, [container.current]);
        const mod = mods[showOverlay];
        const toRelPath = (filePath) => pathTool.relative(discovery.path, filePath);
        const popover = showOverlay === undefined ? React.createElement(react_bootstrap_1.Popover, null) : (React.createElement(react_bootstrap_1.Popover, { id: 'file-overrides-popover' },
                                                                                                                                React.createElement(react_bootstrap_1.ListGroup, null, ((_a = mod.fileOverrides) !== null && _a !== void 0 ? _a : []).map(override => (React.createElement("div", { key: override }, toRelPath(override)))))));
        const isEnabled = (id) => { let _a, _b, _c, _d; return (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.fileOverrides) === null || _c === void 0 ? void 0 : _c[id]) !== null && _d !== void 0 ? _d : false; };
        return (React.createElement("div", { ref: container, id: 'collection-file-overrides', className: 'collection-file-overrides' },
                                    React.createElement(react_bootstrap_1.ControlLabel, null,
                                                        React.createElement("p", null, t('File overrides can be considered as a type of ignore list. This page will allow you to export file overrides that '
                + 'are defined for your selected mod list. As of Vortex 1.10.x, the file overrides are generated automatically based on '
                + 'mod rules you export as part of your collection.')),
                                                        React.createElement("p", null, t('Please note that these pre-generated file overrides are toggled off by default as Vortex will '
                + 'generate them on the users machine as part of the collection installation automatically. Therefore there\'s no '
                + 'explicit need to export these overrides unless you have manually set certain overrides which are not generated by the mod dependency system.')),
                                                        React.createElement("p", null, t('Any mods enabled below will NOT be deployed on the user\'s machine. '
                + 'Please use this feature sparingly as most users are not aware that Vortex offers this functionality and may '
                + 'encounter trouble when trying to tweak/remove them.'))),
                                    React.createElement(react_bootstrap_1.Table, null,
                                                        React.createElement("tbody", null, modsWithOverrides.map(mod => {
                                                          let _a;
                                                          return (React.createElement("tr", { key: mod.id },
                                                                                      React.createElement("td", null,
                                                                                                          React.createElement(vortex_api_1.Toggle, { checked: isEnabled(mod.id), dataId: mod.id, onToggle: toggleOverride },
                                                                                                                              vortex_api_1.util.renderModName(mod),
                                                                                                                              "\u00A0",
                                                                                                                              React.createElement(vortex_api_1.Overlay, { rootClose: true, show: showOverlay !== undefined, onHide: hide, orientation: 'horizontal', getBounds: getBounds, target: target.current }, popover))),
                                                                                      React.createElement("td", null,
                                                                                                          React.createElement("a", { "data-modid": mod.id, onClick: togglePopover }, t('contains {{count}} file override', {
                                                                                                            count: ((_a = mod.fileOverrides) !== null && _a !== void 0 ? _a : []).length,
                                                                                                          })))));
                                                        })))));
      }
      function mapStateToProps(state) {
        const gameId = vortex_api_1.selectors.activeGameId(state);
        return {
          gameId,
          discovery: vortex_api_1.selectors.discoveryByGame(state, gameId),
        };
      }
      exports["default"] = FileOverrides;


/***/ }),

/***/ "./src/views/CollectionPageEdit/InstallModeRenderer.tsx":
/*!**************************************************************!*\
  !*** ./src/views/CollectionPageEdit/InstallModeRenderer.tsx ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
      class InstallModeRenderer extends vortex_api_1.ComponentEx {
        constructor() {
          super(...arguments);
          this.renderIconTooltip = () => {
            const { t, hasInstallerOptions } = this.props;
            return hasInstallerOptions ? (React.createElement(vortex_api_1.FlexLayout.Fixed, { style: { marginLeft: '5px', marginTop: '3px' } },
                                                              React.createElement(vortex_api_1.tooltip.Icon, { name: 'options', tooltip: t('This mod has installer options') }))) : null;
          };
          this.renderOption = (option) => {
            const { t, options, modId } = this.props;
            const text = t(options[option]);
            return React.createElement("option", { key: option, value: option, "data-id": modId }, text);
          };
          this.selectInstallMode = (evt) => {
            let _a;
            const { onSetInstallMode } = this.props;
            const modId = (_a = evt.target.selectedOptions[0]) === null || _a === void 0 ? void 0 : _a.getAttribute('data-id');
            const newVal = evt.target.value;
            onSetInstallMode(modId, newVal);
          };
        }
        render() {
          const { options, currentInstallMode } = this.props;
          return (React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                      React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                          React.createElement(react_bootstrap_1.FormControl, { componentClass: 'select', onChange: this.selectInstallMode, value: currentInstallMode }, Object.keys(options).map(this.renderOption))),
                                      this.renderIconTooltip()));
        }
      }
      function mapStateToProps(state) {
        const activeGameId = vortex_api_1.selectors.activeGameId(state);
        return {
          mods: vortex_api_1.util.getSafe(state, ['persistent', 'mods', activeGameId], {}),
        };
      }
      exports["default"] = (0, react_i18next_1.withTranslation)([constants_1.NAMESPACE, 'common'])((0, react_redux_1.connect)(mapStateToProps)(InstallModeRenderer));


/***/ }),

/***/ "./src/views/CollectionPageEdit/Instructions.tsx":
/*!*******************************************************!*\
  !*** ./src/views/CollectionPageEdit/Instructions.tsx ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
      function CollectionGeneralInfo(props) {
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                    instructions(props),
                                    settings(props)));
      }
      const settings = (props) => {
        let _a, _b, _c;
        const [t] = (0, react_i18next_1.useTranslation)([constants_1.NAMESPACE, 'common']);
        const { onSetCollectionAttribute, collection } = props;
        const [recommendNewProfile, setRecommendNewProfile] = React.useState((_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.collectionConfig) === null || _c === void 0 ? void 0 : _c.recommendNewProfile);
        const toggleRecommendNewProfile = React.useCallback(() => {
          const newValue = !recommendNewProfile;
          setRecommendNewProfile(newValue);
          onSetCollectionAttribute(['collectionConfig', 'recommendNewProfile'], newValue);
        }, [onSetCollectionAttribute, recommendNewProfile, setRecommendNewProfile]);
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', id: 'collection-settings-edit', className: 'collection-settings-edit' },
                                    React.createElement("h4", null, t('Options')),
                                    React.createElement("p", null, t('The below settings can optionally be changed to customize this collection')),
                                    React.createElement(vortex_api_1.Toggle, { id: 'settings-recommend-new-profile', onToggle: toggleRecommendNewProfile, checked: recommendNewProfile },
                                                        t('Recommend new profile'),
                                                        React.createElement(vortex_api_1.More, { id: 'collection-settings-recommendnewprofile', name: t('Recommend new profile') }, t('If enabled, Vortex will recommend creating a new profile when installing this collection. If disabled, the collection will be installed into the currently active profile.')))));
      };
      const instructions = (props) => {
        let _a, _b;
        const [t] = (0, react_i18next_1.useTranslation)([constants_1.NAMESPACE, 'common']);
        const { collection, onSetCollectionAttribute } = props;
        const [input, setInput] = React.useState((_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a['collection']) === null || _b === void 0 ? void 0 : _b['installInstructions']);
        const [placeholder, setPlaceholder] = React.useState(t(constants_1.INSTRUCTIONS_PLACEHOLDER));
        const [hasChanged, setHasChanged] = React.useState(false);
        React.useEffect(() => {
          let _a, _b;
          setInput((_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a['collection']) === null || _b === void 0 ? void 0 : _b['installInstructions']);
        }, [collection]);
        const assignInstructions = React.useCallback((evt) => {
          setInput(evt.currentTarget.value);
          setHasChanged(true);
        }, [setInput]);
        const saveInstructions = React.useCallback(() => {
          onSetCollectionAttribute(['installInstructions'], input);
          setHasChanged(false);
        }, [input]);
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', id: 'collection-instructions-edit', className: 'collection-instructions-edit' },
                                    React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-instructions-container' },
                                                        React.createElement("h4", null, t('Instructions')),
                                                        React.createElement("p", null, t('Instructions will be shown to the user before installation starts and can be reviewed in the Instructions tab. You can also add individual mod instructions in the Mods tab.')),
                                                        React.createElement(react_bootstrap_1.FormControl, { id: 'collection-instructions-area', componentClass: 'textarea', value: input, onChange: assignInstructions, placeholder: placeholder, onFocus: (e) => setPlaceholder(''), onBlur: (e) => setPlaceholder(t(constants_1.INSTRUCTIONS_PLACEHOLDER)), rows: 8 })),
                                    React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-instructions-buttons' },
                                                        React.createElement(vortex_api_1.tooltip.Button, { disabled: !hasChanged, tooltip: t('Save Instructions'), onClick: saveInstructions }, t('Save')))));
      };
      exports["default"] = CollectionGeneralInfo;


/***/ }),

/***/ "./src/views/CollectionPageEdit/ModRules.tsx":
/*!***************************************************!*\
  !*** ./src/views/CollectionPageEdit/ModRules.tsx ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
      class ModRulesPage extends vortex_api_1.ComponentEx {
        constructor() {
          super(...arguments);
          this.mAugmentedRules = (0, memoize_one_1.default)((rules) => rules.map(rule => this.augmentRule(rule)));
          this.mFilteredRules = (0, memoize_one_1.default)((collection, rules) => rules.filter(rule => !vortex_api_1.util.testModReference(collection, rule.source)));
          this.enableAllRules = () => {
            this.setRulesEnabled(true);
          };
          this.disableAllRules = () => {
            this.setRulesEnabled(false);
          };
          this.ruleSort = (lhs, rhs) => {
            return lhs.sourceName.localeCompare(rhs.sourceName);
          };
          this.toggleRule = (newValue, dataId) => {
            const { onSetCollectionAttribute } = this.props;
            onSetCollectionAttribute(['rule', dataId], newValue);
          };
        }
        shouldComponentUpdate(nextProps) {
          return (this.props.t !== nextProps.t)
            || (this.props.collection !== nextProps.collection)
            || (this.props.mods !== nextProps.mods)
            || (this.props.rules !== nextProps.rules)
            || (this.props.onSetCollectionAttribute !== nextProps.onSetCollectionAttribute);
        }
        render() {
          const { t, collection } = this.props;
          const rules = this.mAugmentedRules(this.props.rules);
          const filtered = this.mFilteredRules(collection, rules);
          let lastSourceName;
          return (React.createElement("div", { id: 'collection-mod-rules', className: 'collection-rules-edit' },
                                      React.createElement(react_bootstrap_1.ControlLabel, null,
                                                          React.createElement("p", null,
                                                                              t('By default the collection will replicate all your custom rules that dictate '
                        + 'the deployment order of mods.'),
                                                                              "\u00A0",
                                                                              t('If you disable rules here your collection may produce unresolved file conflicts '
                        + 'that the user has to resolve.'))),
                                      React.createElement("div", null,
                                                          React.createElement("a", { onClick: this.enableAllRules }, t('Enable all')),
                                                          React.createElement("span", { className: 'link-action-seperator' }, "\u00A0 | \u00A0"),
                                                          React.createElement("a", { onClick: this.disableAllRules }, t('Disable all'))),
                                      React.createElement(react_bootstrap_1.ListGroup, null, filtered
                                        .sort(this.ruleSort)
                                        .map((rule, idx) => {
                                          const separator = rule.sourceName !== lastSourceName;
                                          lastSourceName = rule.sourceName;
                                          return this.renderRule(rule, idx, separator);
                                        }))));
        }
        augmentRule(rule) {
          return {
            ...rule,
            sourceName: (0, util_1.renderReference)(rule.source, this.props.mods),
            referenceName: (0, util_1.renderReference)(rule.reference, this.props.mods),
          };
        }
        setRulesEnabled(enable) {
          const { collection, onSetCollectionAttribute } = this.props;
          const rules = this.mAugmentedRules(this.props.rules);
          const filtered = this.mFilteredRules(collection, rules);
          filtered.forEach(rule => {
            onSetCollectionAttribute(['rule', (0, util_1.ruleId)(rule)], enable);
          });
        }
        renderRule(rule, idx, separator) {
          let _a, _b, _c, _d;
          const { collection } = this.props;
          const id = (0, util_1.ruleId)(rule);
          const checked = (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.rule) === null || _c === void 0 ? void 0 : _c[id]) !== null && _d !== void 0 ? _d : true;
          return (React.createElement(react_bootstrap_1.ListGroupItem, { className: separator ? 'collection-rule-separator' : undefined, key: idx.toString() },
                                      React.createElement(vortex_api_1.Toggle, { checked: checked, dataId: id, onToggle: this.toggleRule },
                                                          React.createElement("div", { className: 'rule-name' }, rule.sourceName),
                                                          React.createElement("div", { className: 'rule-type' }, rule.type),
                                                          React.createElement("div", { className: 'rule-name' }, rule.referenceName))));
        }
      }
      exports["default"] = ModRulesPage;


/***/ }),

/***/ "./src/views/CollectionPageEdit/ModsEditPage.tsx":
/*!*******************************************************!*\
  !*** ./src/views/CollectionPageEdit/ModsEditPage.tsx ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const _ = __webpack_require__(/*! lodash */ "lodash");
      const path = __webpack_require__(/*! path */ "path");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const InstallModeRenderer_1 = __webpack_require__(/*! ./InstallModeRenderer */ "./src/views/CollectionPageEdit/InstallModeRenderer.tsx");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");

      const SOURCES = {
        nexus: 'Nexus Mods',
        direct: 'Direct download',
        browse: 'Browse a website',
        bundle: 'Bundle with collection',
      };
      const INSTALL_MODES = {
        fresh: 'Fresh Install',
        choices: 'Same Installer Options',
        clone: 'Replicate',
      };
      const getCollator = (() => {
        let lang;
        let collator;
        return (locale) => {
          if ((collator === undefined) || (locale !== lang)) {
            lang = locale;
            collator = new Intl.Collator(locale, { sensitivity: 'base' });
          }
          return collator;
        };
      })();
      function undefSort(lhs, rhs) {
        return (lhs !== undefined)
          ? 1 : (rhs !== undefined)
            ? -1 : 0;
      }
      function modNameSort(lhs, rhs, collator, sortDir) {
        const lhsName = vortex_api_1.util.renderModName(lhs);
        const rhsName = vortex_api_1.util.renderModName(rhs);
        return ((lhsName === undefined) || (rhsName === undefined))
          ? undefSort(lhsName, rhsName)
          : collator.compare(lhsName, rhsName) * (sortDir !== 'desc' ? 1 : -1);
      }
      function sortCategories(lhs, rhs, collator, state, sortDir) {
        let _a, _b;
        const lhsCat = vortex_api_1.util.resolveCategoryName((_a = lhs === null || lhs === void 0 ? void 0 : lhs.attributes) === null || _a === void 0 ? void 0 : _a.category, state);
        const rhsCat = vortex_api_1.util.resolveCategoryName((_b = rhs === null || rhs === void 0 ? void 0 : rhs.attributes) === null || _b === void 0 ? void 0 : _b.category, state);
        return (lhsCat === rhsCat)
          ? modNameSort(lhs, rhs, collator, sortDir)
          : collator.compare(lhsCat, rhsCat);
      }
      const coerceableRE = /^v?[0-9.]+$/;
      function safeCoerce(input) {
        let _a;
        return coerceableRE.test(input)
          ? (_a = vortex_api_1.util.coerceToSemver(input)) !== null && _a !== void 0 ? _a : input
          : input;
      }
      class ModsEditPage extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.mActions = [
            {
              title: 'Requires',
              icon: 'requires',
              singleRowAction: false,
              multiRowAction: true,
              condition: (instanceIds) => instanceIds.find(id => { let _a, _b; return ((_b = (_a = this.state.entries[id]) === null || _a === void 0 ? void 0 : _a.rule) === null || _b === void 0 ? void 0 : _b.type) === 'recommends'; }) !== undefined,
              action: (instanceIds) => {
                const { onAddRule, onRemoveRule } = this.props;
                const { entries } = this.state;
                instanceIds.forEach(id => {
                  let _a, _b;
                  if (((_b = (_a = entries[id]) === null || _a === void 0 ? void 0 : _a.rule) === null || _b === void 0 ? void 0 : _b.type) === 'recommends') {
                    const newRule = _.cloneDeep(entries[id].rule);
                    onRemoveRule(entries[id].rule);
                    newRule.type = 'requires';
                    onAddRule(newRule);
                  }
                });
              },
            },
            {
              title: 'Recommends',
              icon: 'recommends',
              singleRowAction: false,
              multiRowAction: true,
              condition: (instanceIds) => instanceIds.find(id => { let _a, _b; return ((_b = (_a = this.state.entries[id]) === null || _a === void 0 ? void 0 : _a.rule) === null || _b === void 0 ? void 0 : _b.type) === 'requires'; }) !== undefined,
              action: (instanceIds) => {
                const { onAddRule, onRemoveRule } = this.props;
                const { entries } = this.state;
                instanceIds.forEach(id => {
                  let _a;
                  if (((_a = entries[id].rule) === null || _a === void 0 ? void 0 : _a.type) === 'requires') {
                    const newRule = _.cloneDeep(entries[id].rule);
                    onRemoveRule(entries[id].rule);
                    newRule.type = 'recommends';
                    onAddRule(newRule);
                  }
                });
              },
            },
            {
              title: 'Set Install Type',
              icon: 'edit',
              singleRowAction: false,
              multiRowAction: true,
              action: (instanceIds) => {
                let _a, _b, _c, _d;
                const { onSetCollectionAttribute, collection } = this.props;
                const refMode = (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.installMode) === null || _c === void 0 ? void 0 : _c[instanceIds[0]]) !== null && _d !== void 0 ? _d : 'fresh';
                this.context.api.showDialog('question', 'Install Type', {
                  text: 'Please select the install mode to apply to all selected mods',
                  choices: [
                    { id: 'fresh', text: 'Fresh Install', value: refMode === 'fresh' },
                    { id: 'choices', text: 'Same Installer Options', value: refMode === 'choices' },
                    { id: 'clone', text: 'Replicate', value: refMode === 'clone' },
                  ],
                }, [
                  { label: 'Cancel' },
                  { label: 'Apply' },
                ]).then(result => {
                  if (result.action === 'Apply') {
                    const selected = Object.keys(result.input).find(iter => result.input[iter]);
                    instanceIds.forEach(modId => {
                      onSetCollectionAttribute(['installMode', modId], selected);
                    });
                  }
                });
              },
            },
            {
              title: 'Set Version',
              icon: 'auto-update',
              singleRowAction: false,
              multiRowAction: true,
              action: (instanceIds) => {
                this.context.api.showDialog('question', 'Version Match', {
                  text: 'Please choose how Vortex should choose the version of the mod to be installed. '
                            + '"Exact" means that the user should install the same version as you have '
                            + 'installed right now. "Latest" means it should get the newest version at '
                            + 'the time of installation.',
                  choices: [
                    { id: 'prefer', text: 'Prefer exact', value: true },
                    { id: 'latest', text: 'Latest', value: false },
                    { id: 'exact', text: 'Exact only', value: false },
                  ],
                }, [
                  { label: 'Cancel' },
                  { label: 'Apply' },
                ]).then(result => {
                  if (result.action === 'Apply') {
                    const { onAddRule, onRemoveRule } = this.props;
                    const { entries } = this.state;
                    const selected = Object.keys(result.input).find(iter => result.input[iter]);
                    instanceIds.forEach(modId => {
                      const entry = entries[modId];
                      if (entry.mod !== undefined) {
                        const newRule = _.cloneDeep(entry.rule);
                        newRule.reference.versionMatch = (selected === 'exact')
                          ? entry.mod.attributes['version']
                          : (selected === 'prefer')
                            ? '>=' + entry.mod.attributes['version'] + '+prefer'
                            : '*';
                        onRemoveRule(entry.rule);
                        onAddRule(newRule);
                      }
                    });
                  }
                });
              },
            },
            {
              title: 'Remove',
              icon: 'delete',
              singleRowAction: true,
              multiRowAction: true,
              action: (instanceIds) => {
                const { entries } = this.state;
                const filteredIds = instanceIds.filter(id => entries[id] !== undefined);
                this.context.api.showDialog('question', 'Confirm removal', {
                  text: 'Are you sure you want to remove these mods from this collection? Removing the mods from the collection will not remove them from Vortex.',
                  message: filteredIds.map(id => entries[id].mod !== undefined
                    ? vortex_api_1.util.renderModName(entries[id].mod)
                    : vortex_api_1.util.renderModReference(entries[id].rule.reference)).join('\n'),
                }, [
                  { label: 'Cancel' },
                  { label: 'Remove', action: () => {
                    filteredIds.forEach(id => {
                      if (entries[id] !== undefined) {
                        this.props.onRemoveRule(entries[id].rule);
                        delete this.nextState.entries[id];
                      }
                    });
                  } },
                ]);
              },
            },
            {
              icon: 'sort-none',
              title: 'Assign order',
              subMenus: (instanceIds) => {
                const { t } = this.props;
                const ids = Array.isArray(instanceIds)
                  ? instanceIds
                  : [instanceIds];
                const maxPhase = Object.values(this.state.entries).reduce((prev, entry) => { let _a, _b; return Math.max(prev, (_b = (_a = entry.rule.extra) === null || _a === void 0 ? void 0 : _a['phase']) !== null && _b !== void 0 ? _b : 0); }, 0);
                return (new Array(maxPhase + 1)).fill(0).map((ignore, idx) => {
                  const item = {
                    title: t('Phase {{num}}', { replace: { num: idx } }),
                    action: () => {
                      ids.forEach(id => { this.setPhase(this.state.entries[id], idx); });
                    },
                  };
                  return item;
                })
                  .concat({
                    title: t('Create & Add to Phase {{num}}', { replace: { num: maxPhase + 1 } }),
                    action: () => {
                      ids.forEach(id => { this.setPhase(this.state.entries[id], maxPhase + 1); });
                    },
                  });
              },
              singleRowAction: true,
            },
          ];
          this.addMods = () => {
            const { collection, onAddModsDialog } = this.props;
            onAddModsDialog(collection.id);
          };
          this.setPhase = (mod, phase) => {
            const { onAddRule, onDismissPhaseUsage, onShowPhaseColumn, showPhaseUsage } = this.props;
            const impl = async () => {
              const newRule = _.cloneDeep(mod.rule);
              vortex_api_1.util.setdefault(newRule, 'extra', {})['phase'] = phase;
              onAddRule(newRule);
              if (phase !== 0) {
                onShowPhaseColumn();
              }
              if (showPhaseUsage) {
                const result = await this.context.api.showDialog('info', 'Installation Phase', {
                  text: 'When installing your collection Vortex will process installation phases '
                            + 'one by one and ensure all mods from a given phase are both '
                            + 'installed and deployed before continuing to the next phase. '
                            + 'That way, mods that require other mods being present can be set to '
                            + 'install after their requirements by being put in different phases.\n'
                            + 'Please note that Vortex will need to deploy after each phase which will '
                            + 'slow down the installation process. '
                            + 'It is advised to only utilise this feature when necessary.',
                  checkboxes: [
                    { id: 'dismiss', text: 'Don\'t show this in the future', value: false },
                  ],
                }, [
                  { label: 'Understood' },
                ]);
                if (result.input['dismiss']) {
                  onDismissPhaseUsage();
                }
              }
            };
            impl();
          };
          this.showProblems = (evt) => {
            const { t, mods } = this.props;
            const modId = evt.currentTarget.getAttribute('data-modid');
            const mod = mods[modId];
            const problems = this.state.problems[modId];
            const { api } = this.context;
            const solutions = new Map([
              ['invalid-ids', () => this.fixInvalidIds(api, mod)],
              ['no-version-set', () => this.fixMissingVersion(api, mod)],
              ['replicate-fuzzy-version', () => this.setCurrentVersion(this.state.entries[modId])],
              ['choices-fuzzy-version', () => this.setPreferVersion(this.state.entries[modId])],
            ]);
            const modName = vortex_api_1.util.renderModName(mod);
            api.showDialog('info', modName, {
              bbcode: '[list]' + problems.map((prob, idx) => {
                if (solutions.has(prob.type)) {
                  return `[*]${prob.message} [url="cb://selectproblem/${idx}"]${t('Fix it')}[/url][/*]`;
                }
                else {
                  return `[*]${prob.message}[/*]`;
                }
              }).join('') + '[/list]',
              options: {
                translated: true,
                bbcodeContext: {
                  callbacks: {
                    selectproblem: (idx) => {
                      solutions.get(problems[idx].type)();
                      api.closeDialog('collection-problem');
                    },
                  },
                },
              },
            }, [
              { label: 'Close' },
            ], 'collection-problem');
          };
          this.changeInstallMode = (id, value) => {
            this.props.onSetCollectionAttribute(['installMode', id], value);
          };
          this.changeInstructions = (evt) => {
            let _a, _b, _c, _d;
            const { collection, onSetCollectionAttribute } = this.props;
            const modId = evt.currentTarget.getAttribute('data-modid');
            const value = (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.instructions) === null || _c === void 0 ? void 0 : _c[modId]) !== null && _d !== void 0 ? _d : '';
            this.context.api.showDialog('info', 'Instructions', {
              md: 'Instructions added to **required mods** will display alongside the mod as it installs.  \n'
                    + 'Instructions added to **optional mods** will display before the mod installs, the user '
                    + 'will be given the option to either install or skip the mod.  \n'
                    + 'All added instructions will be available in the "Instructions" tab on the Collections page.',
              input: [{ label: 'Instructions', id: 'instructions', type: 'multiline', value, placeholder: constants_1.INSTRUCTIONS_PLACEHOLDER }],
            }, [
              { label: 'Cancel' },
              { label: 'Save' },
            ], 'collection-set-instructions')
              .then(result => {
                if (result.action === 'Save') {
                  onSetCollectionAttribute(['instructions', modId], result.input['instructions']);
                }
              });
          };
          this.onQuerySource = (evt) => {
            let _a, _b, _c, _d, _e;
            const { collection } = this.props;
            const modId = evt.currentTarget.getAttribute('data-modid');
            const type = (_e = (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.source) === null || _c === void 0 ? void 0 : _c[modId]) === null || _d === void 0 ? void 0 : _d.type) !== null && _e !== void 0 ? _e : 'nexus';
            return this.querySource(modId, type);
          };
          const entries = this.generateEntries(props);
          this.initState({
            entries,
            problems: this.checkProblems(props, entries),
          });
          this.mColumns = [
            {
              id: 'name',
              name: 'Mod Name',
              description: 'Mod Name',
              calc: (entry) => (entry.mod !== undefined)
                ? vortex_api_1.util.renderModName(entry.mod)
                : vortex_api_1.util.renderModReference(entry.rule.reference),
              placement: 'table',
              edit: {},
              isDefaultSort: true,
              isSortable: true,
              filter: new vortex_api_1.TableTextFilter(true),
              sortFunc: (lhs, rhs, locale) => {
                if ((this.mCollator === undefined) || (locale !== this.mLang)) {
                  this.mLang = locale;
                  this.mCollator = new Intl.Collator(locale, { sensitivity: 'base' });
                }
                return this.mCollator.compare(lhs, rhs);
              },
            }, {
              id: 'tags',
              name: 'Tag',
              description: 'Mod Highlights',
              customRenderer: (entry) => {
                if (entry.mod === undefined) {
                  return (React.createElement(vortex_api_1.tooltip.Icon, { name: 'feedback-error', tooltip: this.props.t('This mod isn\'t installed.') }));
                }
                const color = vortex_api_1.util.getSafe(entry.mod.attributes, ['color'], '');
                const icon = vortex_api_1.util.getSafe(entry.mod.attributes, ['icon'], '');
                const hasProblem = (this.state.problems[entry.mod.id] !== undefined)
                        && (this.state.problems[entry.mod.id].length > 0);
                const hasHighlight = color || icon;
                if (!color && !icon && !hasProblem) {
                  return null;
                }
                return (React.createElement(React.Fragment, null,
                                            hasHighlight ? (React.createElement(vortex_api_1.Icon, { className: 'highlight-base ' + (color !== '' ? color : 'highlight-default'), name: icon !== '' ? icon : 'highlight' })) : null,
                                            hasProblem ? (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'incompatible', className: 'btn-embed', tooltip: this.state.problems[entry.mod.id]
                                              .map(problem => problem.summary).join('\n'), "data-modid": entry.mod.id, onClick: this.showProblems })) : null));
              },
              calc: (entry) => {
                let _a, _b, _c, _d;
                if (entry.mod === undefined) {
                  return ['not-installed', 'has-problems'];
                }
                const color = (_b = (_a = entry.mod.attributes) === null || _a === void 0 ? void 0 : _a.color) !== null && _b !== void 0 ? _b : '';
                const icon = (_d = (_c = entry.mod.attributes) === null || _c === void 0 ? void 0 : _c.icon) !== null && _d !== void 0 ? _d : '';
                const problems = this.state.problems[entry.mod.id] || [];
                return [color, icon, problems.length > 0 ? 'has-problems' : 'no-problems'];
              },
              placement: 'table',
              edit: {},
              filter: new vortex_api_1.OptionsFilter([{ value: 'has-problems', label: 'Has Problems' }], false, false),
            }, {
              id: 'category',
              name: 'Category',
              description: 'Mod Category',
              icon: 'sitemap',
              placement: 'table',
              calc: (mod) => {
                let _a, _b;
                return vortex_api_1.util.resolveCategoryName((_b = (_a = mod.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.category, this.context.api.store.getState());
              },
              isToggleable: true,
              edit: {},
              isSortable: true,
              isGroupable: (mod, t) => {
                let _a, _b;
                return vortex_api_1.util.resolveCategoryName((_b = (_a = mod.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.category, this.context.api.store.getState()) || t('<No category>');
              },
              filter: new vortex_api_1.OptionsFilter(() => {
                const state = this.context.api.getState();
                return Array.from(new Set(Object.values(this.state.entries)
                  .map(entry => { let _a, _b; return (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.category; })
                  .filter(entry => !!entry)
                  .map(entry => vortex_api_1.util.resolveCategoryName(entry, state))
                  .sort()))
                  .map(name => {
                    return { value: name, label: name };
                  });
              }, false, false),
              sortFuncRaw: (lhs, rhs, locale) => sortCategories(lhs.mod, rhs.mod, getCollator(locale), this.context.api.store.getState(), this.categorySort()),
            }, {
              id: 'required',
              name: 'Required',
              description: 'Whether the entire collection will fail if this mod is missing',
              calc: (mod) => {
                return mod.rule.type === 'requires'
                  ? true
                  : false;
              },
              placement: 'table',
              edit: {
                inline: true,
                actions: false,
                choices: () => [
                  { key: 'required', bool: true },
                  { key: 'optional', bool: false },
                ],
                onChangeValue: (source, value) => {
                  this.props.onRemoveRule(source.rule);
                  const newRule = _.cloneDeep(source.rule);
                  newRule.type = value ? 'requires' : 'recommends';
                  this.props.onAddRule(newRule);
                },
              },
            }, {
              id: 'source',
              name: 'Source',
              description: 'How the user acquires the mod',
              calc: (entry) => {
                let _a, _b, _c, _d;
                const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                const { collection } = this.props;
                const type = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'source', id, 'type'], 'nexus');
                return SOURCES[type];
              },
              placement: 'table',
              edit: {
                inline: true,
                actions: false,
                choices: () => Object.keys(SOURCES).map(key => ({ key, text: SOURCES[key] })),
                onChangeValue: (entry, value) => {
                  let _a, _b, _c, _d;
                  const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                  if (id !== undefined) {
                    this.querySource(id, value);
                  }
                },
              },
            }, {
              id: 'edit-source',
              placement: 'table',
              edit: {},
              calc: (entry) => {
                let _a, _b, _c, _d;
                const { collection } = this.props;
                const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                const type = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'source', id, 'type'], 'nexus');
                return SOURCES[type];
              },
              customRenderer: (entry) => {
                let _a, _b, _c, _d;
                const { t, collection } = this.props;
                const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                const type = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'source', id, 'type'], 'nexus');
                return (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'edit', disabled: (entry.mod === undefined) || ['nexus', 'bundle'].includes(type), tooltip: t('Edit Source'), "data-modid": id, onClick: this.onQuerySource }));
              },
            }, {
              id: 'version-match',
              name: 'Version',
              description: 'The version to install',
              calc: (entry) => {
                let _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
                const { collection } = this.props;
                const { t } = this.props;
                const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                const version = (_g = (_f = (_e = entry.mod) === null || _e === void 0 ? void 0 : _e.attributes) === null || _f === void 0 ? void 0 : _f['version']) !== null && _g !== void 0 ? _g : t('N/A');
                if (((_l = (_k = (_j = (_h = collection.attributes) === null || _h === void 0 ? void 0 : _h.collection) === null || _j === void 0 ? void 0 : _j.source) === null || _k === void 0 ? void 0 : _k[id]) === null || _l === void 0 ? void 0 : _l.type) === 'bundle') {
                  return t('Exact only ({{version}})', { replace: { version } });
                }
                if (entry.rule.reference.versionMatch === '*') {
                  return t('Latest');
                }
                else if ((entry.rule.reference.versionMatch === undefined)
                        || (entry.rule.reference.versionMatch || '').endsWith('+prefer')) {
                  return t('Prefer exact ({{version}})', { replace: { version } });
                }
                else {
                  return t('Exact only ({{version}})', { replace: { version } });
                }
              },
              placement: 'table',
              edit: {
                inline: true,
                actions: false,
                choices: (entry) => {
                  let _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
                  const { t, collection } = this.props;
                  const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                  const version = (_g = (_f = (_e = entry.mod) === null || _e === void 0 ? void 0 : _e.attributes) === null || _f === void 0 ? void 0 : _f['version']) !== null && _g !== void 0 ? _g : t('N/A');
                  if (((_l = (_k = (_j = (_h = collection.attributes) === null || _h === void 0 ? void 0 : _h.collection) === null || _j === void 0 ? void 0 : _j.source) === null || _k === void 0 ? void 0 : _k[id]) === null || _l === void 0 ? void 0 : _l.type) === 'bundle') {
                    return [
                      { key: 'exact', text: t('Exact only ({{version}})', { replace: { version } }) },
                    ];
                  }
                  return [
                    { key: 'exact', text: t('Exact only ({{version}})', { replace: { version } }) },
                    { key: 'prefer', text: t('Prefer exact ({{version}})', { replace: { version } }) },
                    { key: 'newest', text: t('Latest') },
                  ];
                },
                onChangeValue: (entry, value) => {
                  if (entry.mod === undefined) {
                    return;
                  }
                  const newRule = _.cloneDeep(entry.rule);
                  this.props.onRemoveRule(entry.rule);
                  newRule.reference.versionMatch = (value === 'exact')
                    ? entry.mod.attributes['version']
                    : (value === 'prefer')
                      ? '>=' + entry.mod.attributes['version'] + '+prefer'
                      : '*';
                  this.props.onAddRule(newRule);
                },
              },
            }, {
              id: 'install-type',
              name: 'Install',
              description: 'How the mod should be installed on the user system',
              filter: new vortex_api_1.OptionsFilter([
                { value: 'has-install-options', label: 'Has Installation Options' }
              ], false, false),
              calc: (entry) => {
                let _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                const { collection } = this.props;
                const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                if (((_h = (_g = (_f = (_e = collection.attributes) === null || _e === void 0 ? void 0 : _e.collection) === null || _f === void 0 ? void 0 : _f.source) === null || _g === void 0 ? void 0 : _g[id]) === null || _h === void 0 ? void 0 : _h.type) === 'bundle') {
                  return INSTALL_MODES['clone'];
                }
                const hasInstallerOptions = ((_m = (_l = (_k = (_j = entry.mod) === null || _j === void 0 ? void 0 : _j.attributes) === null || _k === void 0 ? void 0 : _k.installerChoices) === null || _l === void 0 ? void 0 : _l.options) !== null && _m !== void 0 ? _m : []).length > 0;
                const installMode = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'installMode', id], 'fresh');
                return [INSTALL_MODES[installMode], hasInstallerOptions ? 'has-install-options' : 'no-options'];
              },
              placement: 'table',
              help: 'If set to "Fresh Install" the mod will simply be installed fresh on the users system, '
                    + 'installer (if applicable) and everything.\n'
                    + 'If set to "Replicate" Vortex will try to replicate your exact setup for this mod. '
                    + 'This does not bundle the mod itself but the list of files to install and patches if '
                    + 'necessary. This may increase the size of the collection and the time it takes to '
                    + 'export it considerably.',
              edit: {},
              customRenderer: (entry) => {
                let _a, _b, _c, _d, _e, _f, _g, _h;
                const { t, collection } = this.props;
                const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                const hasInstallerOptions = ((_h = (_g = (_f = (_e = entry.mod) === null || _e === void 0 ? void 0 : _e.attributes) === null || _f === void 0 ? void 0 : _f.installerChoices) === null || _g === void 0 ? void 0 : _g.options) !== null && _h !== void 0 ? _h : []).length > 0;
                const installMode = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'installMode', id], 'fresh');
                return (React.createElement(InstallModeRenderer_1.default, { hasInstallerOptions: hasInstallerOptions, currentInstallMode: installMode, modId: id, onSetInstallMode: this.changeInstallMode, options: INSTALL_MODES }));
              },
            }, {
              id: 'instructions',
              name: 'Instructions',
              icon: 'edit',
              calc: (entry) => {
                let _a, _b, _c;
                const { collection } = this.props;
                if (entry.mod === undefined) {
                  return null;
                }
                return (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.instructions) === null || _c === void 0 ? void 0 : _c[entry.mod.id];
              },
              customRenderer: (entry, detailCell, t) => {
                let _a, _b, _c;
                const { collection } = this.props;
                if (entry.mod === undefined) {
                  return null;
                }
                const instructions = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.instructions) === null || _c === void 0 ? void 0 : _c[entry.mod.id];
                return (!!instructions) ? (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'edit', tooltip: t('Edit Instructions'), "data-modid": entry.mod.id, onClick: this.changeInstructions }, t('Edit'))) : (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'add', tooltip: t('Add Instructions'), "data-modid": entry.mod.id, onClick: this.changeInstructions }, t('Add')));
              },
              placement: 'table',
              edit: {},
            }, {
              id: 'local_edits',
              name: 'Binary patching',
              icon: 'edit',
              help: 'With this option enabled, any changes you did to the files in this mods will '
                    + 'also be included in the Collection.',
              placement: 'table',
              calc: (entry) => {
                let _a, _b, _c, _d;
                const { collection } = this.props;
                if (entry.mod === undefined) {
                  return false;
                }
                return (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.saveEdits) === null || _c === void 0 ? void 0 : _c[entry.mod.id]) !== null && _d !== void 0 ? _d : false;
              },
              edit: {
                choices: () => [
                  { key: 'ignore', bool: false },
                  { key: 'save', bool: true },
                ],
                inline: true,
                actions: false,
                onChangeValue: (source, value) => {
                  (async () => {
                    if (source.mod === undefined) {
                      return;
                    }
                    if (value && this.props.showBinpatchWarning) {
                      const result = await this.context.api.showDialog('question', 'Save Local Edits', {
                        bbcode: 'With this option enabled, when you upload the Collection Vortex will '
                                        + 'compare your files on disk against the archive provided by the mod author '
                                        + 'and include patches so that any modifications get replicated when a user '
                                        + 'installs your collection.\n'
                                        + 'This allows for more customization but there are considerable drawbacks:\n'
                                        + '[list]'
                                        + '[*]Uploading the collection will take longer - a lot if it\'s a big mod\n'
                                        + '[*]these patches apply only to the exact same version&variant of the mod, '
                                        + 'if the user updates the mod the patch will be undone.'
                                        + '[/list]\n'
                                        + 'Therefore please only use this option if you absolutely have to.',
                        checkboxes: [
                          { id: 'dont_show_again', value: false, text: 'Don\'t show again' },
                        ],
                      }, [
                        { label: 'Cancel' },
                        { label: 'Enable' },
                      ]);
                      if (result.action === 'Enable') {
                        const state = this.context.api.getState();
                        if (result.input['dont_show_again']) {
                          this.props.onDismissBinpatchWarning();
                        }
                        const gameMode = vortex_api_1.selectors.activeGameId(state);
                        const archive = state.persistent.downloads.files[source.mod.archiveId];
                        const dlPath = vortex_api_1.selectors.downloadPathForGame(state, gameMode);
                        if (archive !== undefined) {
                          try {
                            await vortex_api_1.fs.statAsync(path.join(dlPath, archive.localPath));
                            this.props.onSetCollectionAttribute(['saveEdits', source.mod.id], value);
                          }
                          catch (err) {
                            if (err.code === 'ENOENT') {
                              this.context.api.showErrorNotification('Failed to enable "Local Edits"', 'To enable this feature, the corresponding archive has to exist to '
                                                    + 'compare against.', { allowReport: false });
                            }
                            else {
                              this.context.api.showErrorNotification('Failed to enable "Local Edits"', err);
                            }
                          }
                        }
                      }
                    }
                    else {
                      this.props.onSetCollectionAttribute(['saveEdits', source.mod.id], value);
                    }
                  })();
                },
              },
            }, {
              id: 'phase',
              name: 'Phase',
              placement: 'table',
              isToggleable: true,
              isSortable: true,
              isDefaultVisible: false,
              groupName: (phase) => this.props.t('Phase {{phase}}', {
                replace: { phase: (phase || 0).toString() },
              }),
              isGroupable: true,
              calc: mod => { let _a, _b; return (_b = (_a = mod.rule.extra) === null || _a === void 0 ? void 0 : _a['phase']) !== null && _b !== void 0 ? _b : 0; },
              edit: {},
            },
          ];
        }
        UNSAFE_componentWillMount() {
          const entries = this.generateEntries(this.props);
          this.nextState.entries = entries;
          this.nextState.problems = this.checkProblems(this.props, entries);
        }
        UNSAFE_componentWillReceiveProps(newProps) {
          if ((newProps.mods !== this.props.mods)
            || (newProps.collection !== this.props.collection)) {
            const entries = this.generateEntries(newProps);
            this.nextState.entries = entries;
            this.nextState.problems = this.checkProblems(newProps, entries);
          }
        }
        render() {
          const { t } = this.props;
          const { entries } = this.state;
          const addModsButton = () => {
            return (React.createElement(react_bootstrap_1.Button, { id: 'btn-more-mods', className: 'collection-add-mods-btn', onClick: this.addMods },
                                        React.createElement(vortex_api_1.Icon, { name: 'add' }),
                                        t('Add more mods')));
          };
          if (Object.keys(entries).length === 0) {
            return (React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'layout-list', text: t('There are no mods in this collection'), subtext: addModsButton(), fill: true }));
          }
          return (React.createElement("div", { className: 'collection-mods-container' },
                                      React.createElement(vortex_api_1.Table, { tableId: 'collection-mods', data: entries, staticElements: this.mColumns, actions: this.mActions, showDetails: false },
                                                          React.createElement("div", { id: 'collection-add-mods-container' }, addModsButton())),
                                      React.createElement(vortex_api_1.Usage, { infoId: 'collection-mods' },
                                                          React.createElement("p", null, t('Here you can configure which mods to install and how.')),
                                                          React.createElement("p", null, t('Version: Choose whether the collection will install exactly the version you '
                    + 'have yourself or whatever is current on Nexus Mods.')),
                                                          React.createElement("p", null, t('Required: Select whether the user has to install the mod or whether it\'s an optional recommendation, recommended mods are presented last and the user is given the choice to install them or not.')),
                                                          React.createElement("p", null, t('Install: "Fresh Install" will install the mod as Vortex would usually do, '
                    + 'installer dialog and everything. "Replicate" will extract only the files you have '
                    + 'extracted yourself, in exactly the same location. This basically ensures the user '
                    + 'gets the same options as you without having to pick them but it only works when you '
                    + 'have selected "Exact version" in the Version column. It will also considerably '
                    + 'increase the time it takes to build the pack.')),
                                                          React.createElement("p", null, t('Source: Decides how the user downloads the mod. "Nexus Mods" is easiest, use the '
                    + 'other options when the mod in only hosted on a different source. '
                    + 'The options also include "pack" which bundles the mod directly into the collection. '
                    + 'Do this only for stuff created during setup (e.g. generated LODs, '
                    + 'customized configuration files and such). '
                    + 'You must not include any material you don\'t hold the copyright to. '
                    + 'Also: Do not provide direct download links unless you have express permission to '
                    + 'do so.')))));
        }
        categorySort() {
          let _a, _b, _c;
          const state = this.context.api.getState();
          return (_c = (_b = (_a = state.settings.tables.mods.attributes) === null || _a === void 0 ? void 0 : _a['category']) === null || _b === void 0 ? void 0 : _b.sortDirection) !== null && _c !== void 0 ? _c : 'none';
        }
        generateEntries(props) {
          const { collection, mods } = props;
          if ((collection === undefined) || (collection.rules === undefined)) {
            return {};
          }
          return Object.values(collection.rules)
            .filter(rule => ['requires', 'recommends'].indexOf(rule.type) !== -1)
            .reduce((prev, rule) => {
              let _a, _b;
              const mod = vortex_api_1.util.findModByRef(_.omit(rule.reference, ['versionMatch']), mods);
              const id = (_b = (_a = mod === null || mod === void 0 ? void 0 : mod.id) !== null && _a !== void 0 ? _a : rule.reference.id) !== null && _b !== void 0 ? _b : rule.reference.idHint;
              if (id !== undefined) {
                prev[id] = { rule, mod };
              }
              return prev;
            }, {});
        }
        checkProblems(props, entries) {
          return Object.values(entries).reduce((prev, entry) => {
            let _a, _b, _c;
            const id = (_c = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : entry.rule.reference.id) !== null && _c !== void 0 ? _c : entry.rule.reference.idHint;
            if (id !== undefined) {
              prev[id] = this.updateProblems(props, entry);
            }
            return prev;
          }, {});
        }
        updateProblems(props, entry) {
          let _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
          const { t, collection } = props;
          if (entry.mod === undefined) {
            return;
          }
          const res = [];
          const attributes = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection;
          const source = (_b = attributes === null || attributes === void 0 ? void 0 : attributes.source) === null || _b === void 0 ? void 0 : _b[entry.mod.id];
          const sourceType = (_c = source === null || source === void 0 ? void 0 : source.type) !== null && _c !== void 0 ? _c : 'nexus';
          const installMode = (_e = (_d = attributes === null || attributes === void 0 ? void 0 : attributes.installMode) === null || _d === void 0 ? void 0 : _d[entry.mod.id]) !== null && _e !== void 0 ? _e : 'fresh';
          const saveEdits = (_g = (_f = attributes === null || attributes === void 0 ? void 0 : attributes.saveEdits) === null || _f === void 0 ? void 0 : _f[entry.mod.id]) !== null && _g !== void 0 ? _g : false;
          const { versionMatch } = entry.rule.reference;
          if ((sourceType === 'nexus')
            && (isNaN(parseInt((_h = entry.mod.attributes) === null || _h === void 0 ? void 0 : _h.modId, 10))
                || isNaN(parseInt((_j = entry.mod.attributes) === null || _j === void 0 ? void 0 : _j.fileId, 10)))) {
            res.push({
              type: 'invalid-ids',
              summary: t('Missing file identifiers'),
              message: t('When using "Nexus Mods" as a source, both the mod id and file id have to be '
                    + 'known. If you didn\'t download the mod through Vortex they may not be set. '
                    + 'To solve this you have to change the source of the mod to "Nexus Mods" '
                    + 'and use the options below "Nexus Mods IDs" to fill in the '
                    + 'missing data (the automated options should be quite reliable).'),
            });
          }
          if (((versionMatch === '*') || ((_k = versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch.endsWith) === null || _k === void 0 ? void 0 : _k.call(versionMatch, '+prefer')))
            && (installMode === 'clone')) {
            res.push({
              type: 'replicate-fuzzy-version',
              summary: t('"Replicate" requires "Exact only" as the version'),
              message: t('"Replicate" install can only be used when installing '
                    + 'a specific version of a mod. This will definitively break '
                    + 'as soon as the mod gets updated.'),
            });
          }
          if ((versionMatch === '*') && (installMode === 'choices')) {
            res.push({
              type: 'choices-fuzzy-version',
              summary: t('"Same Installer Options" should not be used with "Latest" version'),
              message: t('Installing with "Same choices options" may break if the mod gets updated, '
                    + 'you may want to switch to "Prefer exact" to be safe.'),
            });
          }
          if ((sourceType === 'bundle')
            && ((versionMatch === '*') || ((_l = versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch.endsWith) === null || _l === void 0 ? void 0 : _l.call(versionMatch, '+prefer')))) {
            res.push({
              type: 'bundled-fuzzy-version',
              summary: t('Version choice has no effect on "Bundled" mod'),
              message: t('If you bundle a mod the user gets exactly the version of the mod you '
                    + 'have, the Version selection is pointless in this case.'),
            });
          }
          else if (['browse', 'direct'].includes(sourceType)) {
            if ((_m = versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch.endsWith) === null || _m === void 0 ? void 0 : _m.call(versionMatch, '+prefer')) {
              res.push({
                type: 'web-fuzzy-version',
                summary: t('Version choice has no effect on mods using generic download.'),
                message: t('The option to "prefer exact version" only works with sources that '
                        + 'support mod updates (Nexus Mods). For other sources your options '
                        + 'are to use the exact same version you have locally or to accept whatever '
                        + 'version the user downloads.'),
              });
            }
            if (!source.url) {
              res.push({
                type: 'web-url-missing',
                summary: t('No URL set'),
                message: t('The sources "Browse a website" and "Direct download" require that '
                        + 'you provide a URL to download from.'),
              });
            }
          }
          if (saveEdits) {
            if ((versionMatch === '*') || ((_o = versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch.endsWith) === null || _o === void 0 ? void 0 : _o.call(versionMatch, '+prefer'))) {
              res.push({
                type: 'local-edits-fuzzy-version',
                summary: t('Version choice incompatible with saving local edits.'),
                message: t('Local edits can only be applied if the user gets the exact same files '
                        + 'as you have installed locally, meaning they have to use the exact '
                        + 'same version of the mod.'),
              });
            }
            if (sourceType === 'bundle') {
              res.push({
                type: 'local-edits-bundle',
                summary: t('Combining the option to save edits and bundling makes no sense.'),
                message: t('The option to "bundle" already bundles the edited files, storing '
                        + 'the edits separately would not be useful as they can\'t and '
                        + 'don\'t have to be applied.'),
              });
            }
            if (installMode === 'clone') {
              res.push({
                type: 'replicate-vs-binpatch',
                summary: t('"Replicate" installation can\'t be combined with "Binary patching"'),
                message: t('"Replicate" depends on files being unchanged '
                        + 'from the originals in the archive. If you modified mod files '
                        + '(as Binary Patching implies), "Replicate" will fail.'),
              });
            }
          }
          if (sourceType === 'bundle') {
            res.push({
              type: 'bundle-copyright',
              summary: t('Only bundle mods you have the right to do so'),
              message: t('Mods are copyright protected, only pack mods if you are sure you '
                    + 'have the right to do so, e.g. if it\'s dynamically generated content '
                    + 'or if it\'s your own mod.'),
            });
          }
          else if (sourceType === 'direct') {
            res.push({
              type: 'direct-download',
              summary: t('Please verify you are allowed to do direct download on this site'),
              message: t('Most websites don\'t allow direct downloads, Plese make sure you are '
                    + 'allowed to use direct links to the specified page.'),
            });
          }
          if ((installMode === 'choices')
            && (((_r = (_q = (_p = entry.mod.attributes) === null || _p === void 0 ? void 0 : _p.installerChoices) === null || _q === void 0 ? void 0 : _q.options) !== null && _r !== void 0 ? _r : []).length === 0)) {
            res.push({
              type: 'installer-choices-not-saved',
              summary: t('No Installer Options saved for this mod'),
              message: t('The installer choices for this mod haven\'t been saved. '
                    + 'This currently only works with xml-based fomods installed with '
                    + 'Vortex 1.5.0 or later. '
                    + 'You may have to reinstall the mod for this to work.'),
            });
          }
          if (versionMatch === '') {
            res.push({
              type: 'no-version-set',
              summary: t('No version set for this mod'),
              message: t('The mod has no version number set. This isn\'t strictly necessary, we use the '
                    + 'file id to identify the exact version but for the purpose of informing the '
                    + 'user it would be nicer if a version was specified. '
                    + '(Please don\'t forget to update the collection)'),
            });
          }
          return res;
        }
        async fixInvalidIds(api, mod) {
          const modName = vortex_api_1.util.renderModName(mod);
          const result = await api.showDialog('question', modName, {
            text: 'You have to either fix the IDs for this mod or change how the collection '
                + 'acquires this mod.',
          }, [
            { label: 'Change Source' },
            { label: 'Fix IDs' },
          ]);
          if (result.action === 'Fix IDs') {
            api.events.emit('show-main-page', 'Mods');
            setTimeout(() => {
              api.events.emit('mods-select-item', mod.id, true);
              api.highlightControl(`.table-detail-modSource`, 4000);
              api.highlightControl(`.table-detail-nexusModId`, 4000);
            }, 200);
          }
          else {
            api.highlightControl(`#${vortex_api_1.util.sanitizeCSSId(mod.id)} > .cell-source`, 4000, undefined, true);
            api.highlightControl(`#${vortex_api_1.util.sanitizeCSSId(mod.id)} > .cell-edit-source`, 4000, undefined, true);
          }
        }
        async fixMissingVersion(api, mod) {
          api.events.emit('show-main-page', 'Mods');
          setTimeout(() => {
            api.events.emit('mods-select-item', mod.id, true);
            api.highlightControl(`.table-detail-versionDetail`, 4000);
          }, 200);
        }
        setCurrentVersion(entry) {
          this.props.onRemoveRule(entry.rule);
          const newRule = _.cloneDeep(entry.rule);
          newRule.reference.versionMatch = entry.mod.attributes['version'];
          this.props.onAddRule(newRule);
        }
        setPreferVersion(entry) {
          this.props.onRemoveRule(entry.rule);
          const newRule = _.cloneDeep(entry.rule);
          newRule.reference.versionMatch = '>=' + safeCoerce(entry.mod.attributes['version']) + '+prefer';
          this.props.onAddRule(newRule);
        }
        querySource(modId, type) {
          let _a;
          const { collection } = this.props;
          const src = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'source', modId], { type });
          const input = [];
          let text;
          if (type === 'bundle') {
            text = 'These files will be bundled with the collection. '
                + 'This means they will be distributed alongside the collection and '
                + 'released into the public domain.\n\n'
                + 'Bundled content should not be used to distribute mods or mod files. '
                + 'It is intended to allow curators to include configuration files or '
                + 'outputs from automated tools for the convenience of users. '
                + 'Any content that would qualify as a "mod" should be uploaded to a '
                + 'Nexus Mods mod page and included in the collection, rather than being bundled.\n\n'
                + 'You should only include content that you have permission to share freely. '
                + 'Failure to respect the permissions/license of mod authors may result in '
                + 'moderation against your account.';
          }
          else if (['direct', 'browse', 'manual'].includes(type)) {
            text = 'Please provide information the user needs to find the mod';
          }
          if (['direct', 'browse'].includes(type)) {
            input.push({ id: 'url', type: 'url', label: 'URL', value: src.url });
          }
          if (['browse', 'manual'].includes(type)) {
            input.push({
              id: 'instructions', type: 'text', label: 'Instructions',
              value: src.instructions,
            });
          }
          if ((input.length > 0) || (text !== undefined)) {
            this.context.api.showDialog('question', 'Provide mod metadata', {
              text,
              input,
              checkboxes: [
                {
                  id: 'adult',
                  bbcode: 'Mod contains adult content. '
                            + `([url=${constants_1.ADULT_CONTENT_URL}]Adult Content Guidelines[/url])`,
                  value: (_a = src.adultContent) !== null && _a !== void 0 ? _a : false,
                },
              ],
            }, [
              { label: 'Save' },
            ]).then((result => {
              this.props.onSetCollectionAttribute(['source', modId], {
                type,
                url: result.input.url,
                instructions: result.input.instructions,
                adultContent: result.input.adult === true,
              });
            }));
          }
          else {
            this.props.onSetCollectionAttribute(['source', modId], { type });
          }
        }
      }
      exports["default"] = ModsEditPage;


/***/ }),

/***/ "./src/views/CollectionPageEdit/index.tsx":
/*!************************************************!*\
  !*** ./src/views/CollectionPageEdit/index.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const gameSupport_1 = __webpack_require__(/*! ../../util/gameSupport */ "./src/util/gameSupport/index.ts");
      const transformCollection_1 = __webpack_require__(/*! ../../util/transformCollection */ "./src/util/transformCollection.ts");
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
      const session_1 = __webpack_require__(/*! ../../actions/session */ "./src/actions/session.ts");
      const FileOverrides_1 = __webpack_require__(/*! ./FileOverrides */ "./src/views/CollectionPageEdit/FileOverrides.tsx");
      const Instructions_1 = __webpack_require__(/*! ./Instructions */ "./src/views/CollectionPageEdit/Instructions.tsx");
      const ModRules_1 = __webpack_require__(/*! ./ModRules */ "./src/views/CollectionPageEdit/ModRules.tsx");
      const ModsEditPage_1 = __webpack_require__(/*! ./ModsEditPage */ "./src/views/CollectionPageEdit/ModsEditPage.tsx");
      const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const INIT_PAGE = 'mods';
      const emptyCollectionInfo = {
        domainName: '',
        author: '',
        authorUrl: '',
        name: '',
        description: '',
        installInstructions: '',
        gameVersions: [],
      };
      const emptyList = [];
      class CollectionEdit extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.collectionRules = (0, memoize_one_1.default)((rules, mods) => {
            const includedMods = rules
              .filter(rule => ['requires', 'recommends'].includes(rule.type))
              .reduce((prev, rule) => {
                const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
                if (mod !== undefined) {
                  prev[mod.id] = mod;
                }
                return prev;
              }, {});
            return Object.values(includedMods)
              .reduce((prev, mod) => {
                const source = vortex_api_1.util.makeModReference(mod);
                prev = [].concat(prev, (mod.rules || [])
                  .filter(rule => {
                    let _a;
                    return !['requires', 'recommends'].includes(rule.type)
                        && (((_a = rule.extra) === null || _a === void 0 ? void 0 : _a['automatic']) !== true);
                  })
                  .map(rule => (0, transformCollection_1.makeBiDirRule)(source, rule)));
                return prev;
              }, []);
          });
          this.trackTabChange = (page) => {
            const game = vortex_api_1.util.getGame(this.props.profile.gameId);
            const pageTracking = page === 'gamespecific' ? game.name : page;
            this.context.api.events.emit('analytics-track-navigation', `collections/workshop/collection/${pageTracking}`);
          };
          this.setCurrentPage = (page) => {
            this.trackTabChange(page);
            this.nextState.page = page;
          };
          this.remove = () => {
            const { collection, onRemove } = this.props;
            onRemove(collection.id);
          };
          this.upload = () => {
            const { collection, onUpload } = this.props;
            onUpload(collection.id);
          };
          this.openUrl = () => {
            let _a, _b, _c, _d;
            const collectionSlug = (_c = (_b = (_a = this.state.revision) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.slug) !== null && _c !== void 0 ? _c : (_d = this.props.collection.attributes) === null || _d === void 0 ? void 0 : _d.collectionSlug;
            if (collectionSlug === undefined) {
              return;
            }
            const { revision } = this.state;
            const { collection } = revision;
            if (((collection === null || collection === void 0 ? void 0 : collection.game) !== undefined) && ((revision === null || revision === void 0 ? void 0 : revision.revisionNumber) !== undefined)) {
              this.context.api.events.emit('analytics-track-click-event', 'Collections', 'View on site Workshop Collection');
              vortex_api_1.util.opn(vortex_api_1.util.nexusModsURL([collection.game.domainName,
                'collections', collection.slug,
                'revisions', revision.revisionNumber.toString()], {
                campaign: vortex_api_1.util.Campaign.ViewCollectionAsCurator,
                section: vortex_api_1.util.Section.Collections
              }));
            }
          };
          this.addRule = (rule) => {
            const { profile, collection } = this.props;
            this.props.onAddRule(profile.gameId, collection.id, rule);
          };
          this.removeRule = (rule) => {
            const { profile, collection } = this.props;
            this.props.onRemoveRule(profile.gameId, collection.id, rule);
          };
          this.setCollectionAttribute = (attrPath, value) => {
            const { profile, collection } = this.props;
            if (this.mAttributes === undefined) {
              this.mAttributes = collection.attributes;
            }
            const attr = vortex_api_1.util.getSafe(this.mAttributes, ['collection'], {});
            const updated = vortex_api_1.util.setSafe(attr, attrPath, value);
            this.mAttributes = vortex_api_1.util.setSafe(this.mAttributes, ['collection'], updated);
            this.props.onSetModAttribute(profile.gameId, collection.id, 'collection', updated);
          };
          this.addModsDialog = (collectionId) => {
            this.props.onAddModsDialog(collectionId);
          };
          this.showPhaseColumn = () => {
            if (this.props.phaseColumnVisible === undefined) {
              this.props.onShowPhaseColumn();
            }
          };
          this.initState({
            page: INIT_PAGE,
            collectionInfo: emptyCollectionInfo,
            revision: undefined,
          });
        }
        componentDidMount() {
          this.updateState(this.props);
        }
        UNSAFE_componentWillReceiveProps(newProps) {
          let _a;
          this.mAttributes = (_a = newProps.collection) === null || _a === void 0 ? void 0 : _a.attributes;
          if (vortex_api_1.util.getSafe(newProps.collection, ['id'], undefined)
            !== vortex_api_1.util.getSafe(this.props.collection, ['id'], undefined)) {
            this.updateState(newProps);
          }
        }
        render() {
          let _a, _b;
          const { t, mods, collection, showBinpatchWarning, exts, onDismissBinpatchWarning, onDismissPhaseUsage, profile, showPhaseUsage, pathTool } = this.props;
          const { page, revision } = this.state;
          if (profile === undefined) {
            return null;
          }
          const game = vortex_api_1.util.getGame(profile.gameId);
          const extInterfaces = exts.filter(ext => ext.editComponent !== undefined);
          const uploadDisabled = this.testUploadPossible();
          const Interface = (0, gameSupport_1.getInterface)(profile.gameId);
          const nextRev = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.revisionNumber;
          const requiredModRules = this.collectionRules((_b = collection.rules) !== null && _b !== void 0 ? _b : emptyList, mods);
          return (React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                                      React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-edit-header' },
                                                          React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                                                              React.createElement("h3", null,
                                                                                                  t('Edit Collection'),
                                                                                                  " / ",
                                                                                                  vortex_api_1.util.renderModName(collection)),
                                                                              React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'delete', tooltip: t('Remove this collection'), onClick: this.remove }, t('Remove')),
                                                                              React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'collection-export', tooltip: uploadDisabled !== null && uploadDisabled !== void 0 ? uploadDisabled : t('Upload to Nexus Mods'), onClick: this.upload, disabled: uploadDisabled !== undefined }, t(nextRev !== undefined ? 'Upload Update' : 'Upload New')),
                                                                              React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'open-ext', tooltip: t('Open site'), onClick: this.openUrl, disabled: (revision === undefined) }, t('View Site'))),
                                                          t('Set up your mod collection\'s rules and site preferences.')),
                                      React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                                          React.createElement(react_bootstrap_1.Tabs, { id: 'collection-edit-tabs', activeKey: page, onSelect: this.setCurrentPage },
                                                                              React.createElement(react_bootstrap_1.Tab, { key: 'mods', eventKey: 'mods', title: React.createElement("div", null,
                                                                                                                                                                                     t('Mods'),
                                                                                                                                                                                     React.createElement(react_bootstrap_1.Badge, null, (collection.rules || []).length)) },
                                                                                                  React.createElement(react_bootstrap_1.Panel, { style: { position: 'relative' } },
                                                                                                                      React.createElement(ModsEditPage_1.default, { mods: mods, collection: collection, t: t, onSetModVersion: null, showPhaseUsage: showPhaseUsage, showBinpatchWarning: showBinpatchWarning, onAddRule: this.addRule, onRemoveRule: this.removeRule, onSetCollectionAttribute: this.setCollectionAttribute, onAddModsDialog: this.addModsDialog, onDismissPhaseUsage: onDismissPhaseUsage, onDismissBinpatchWarning: onDismissBinpatchWarning, onShowPhaseColumn: this.showPhaseColumn }))),
                                                                              React.createElement(react_bootstrap_1.Tab, { key: 'mod-rules', eventKey: 'mod-rules', title: t('Mod Rules') },
                                                                                                  React.createElement(react_bootstrap_1.Panel, null,
                                                                                                                      React.createElement(ModRules_1.default, { t: t, collection: collection, mods: mods, rules: requiredModRules, onSetCollectionAttribute: this.setCollectionAttribute }))),
                                                                              React.createElement(react_bootstrap_1.Tab, { key: 'file-overrides', eventKey: 'file-overrides', title: t('File Overrides') },
                                                                                                  React.createElement(react_bootstrap_1.Panel, null,
                                                                                                                      React.createElement(FileOverrides_1.default, { t: t, collection: collection, mods: mods, onSetCollectionAttribute: this.setCollectionAttribute, pathTool: pathTool }))),
                                                                              React.createElement(react_bootstrap_1.Tab, { key: 'collection-instructions', eventKey: 'collection-instructions', title: t('Collection Instructions') },
                                                                                                  React.createElement(react_bootstrap_1.Panel, null,
                                                                                                                      React.createElement(Instructions_1.default, { collection: collection, onSetCollectionAttribute: this.setCollectionAttribute }))),
                                                                              extInterfaces.map(ext => (React.createElement(react_bootstrap_1.Tab, { key: ext.id, eventKey: ext.id, title: ext.title(t) },
                                                                                                                            React.createElement(react_bootstrap_1.Panel, null,
                                                                                                                                                React.createElement(ext.editComponent, { t: t, gameId: profile.gameId, collection: collection, revisionInfo: revision, onSetCollectionAttribute: this.setCollectionAttribute }))))),
                                                                              !!Interface ? (React.createElement(react_bootstrap_1.Tab, { key: 'gamespecific', eventKey: 'gamespecific', title: game.name },
                                                                                                                 React.createElement(react_bootstrap_1.Panel, null,
                                                                                                                                     React.createElement(Interface, { t: t, gameId: profile.gameId, collection: collection, revisionInfo: revision, onSetCollectionAttribute: this.setCollectionAttribute })))) : null))));
        }
        testUploadPossible() {
          let _a;
          const { t, collection } = this.props;
          const refMods = ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type));
          if (refMods.length === 0) {
            return (t('Can\'t upload an empty collection'));
          }
          else {
            return undefined;
          }
        }
        async updateState(props) {
          let _a, _b;
          this.nextState.page = INIT_PAGE;
          if (props.collection !== undefined) {
            const { collection } = props;
            const { revisionId, collectionSlug, revisionNumber } = (_a = collection.attributes) !== null && _a !== void 0 ? _a : {};
            if ((revisionId !== undefined) || (collectionSlug !== undefined)) {
              try {
                this.nextState.revision = (_b = (await this.props.driver.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber))) !== null && _b !== void 0 ? _b : undefined;
              }
              catch (err) {
                (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                  revisionId, collectionSlug, revisionNumber,
                  error: err.message,
                });
              }
            }
          }
        }
      }
      function mapStateToProps(state, ownProps) {
        let _a, _b, _c, _d, _e, _f;
        const { settings } = state;
        return {
          phaseColumnVisible: (_d = (_c = (_b = (_a = settings.tables['collection-mods']) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.phase) === null || _c === void 0 ? void 0 : _c.enabled) !== null && _d !== void 0 ? _d : false,
          showPhaseUsage: (_e = settings.interface.usage['collection-phase']) !== null && _e !== void 0 ? _e : true,
          showBinpatchWarning: (_f = settings.interface.usage['binpatch-warning']) !== null && _f !== void 0 ? _f : true,
        };
      }
      function mapDispatchToProps(dispatch) {
        return {
          onSetModAttribute: (gameId, modId, key, value) => dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, key, value)),
          onAddRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.addModRule(gameId, modId, rule)),
          onRemoveRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.removeModRule(gameId, modId, rule)),
          onAddModsDialog: (collectionId) => dispatch((0, session_1.startAddModsToCollection)(collectionId)),
          onDismissPhaseUsage: () => dispatch(vortex_api_1.actions.showUsageInstruction('collection-phase', false)),
          onDismissBinpatchWarning: () => dispatch(vortex_api_1.actions.showUsageInstruction('binpatch-warning', false)),
          onShowPhaseColumn: () => dispatch(vortex_api_1.actions.setAttributeVisible('collection-mods', 'phase', true)),
        };
      }
      exports["default"] = (0, react_i18next_1.withTranslation)([constants_1.NAMESPACE, 'common'])((0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(CollectionEdit));


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionBanner.tsx":
/*!***********************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionBanner.tsx ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
      class CollectionBanner extends vortex_api_1.ComponentEx {
        constructor() {
          super(...arguments);
          this.goGetPremium = () => {
            this.context.api.events.emit('analytics-track-click-event', 'Go Premium', 'Collections Added Collection');
            vortex_api_1.util.opn(vortex_api_1.util.nexusModsURL(constants_1.PREMIUM_PATH, {
              section: vortex_api_1.util.Section.Users,
              campaign: vortex_api_1.util.Campaign.BuyPremium,
              source: vortex_api_1.util.Source.CollectionsAd
            }))
              .catch(err => undefined);
          };
        }
        render() {
          const { t } = this.props;
          const electricBoltIconPath = 'assets/icons/electric-bolt.svg';
          const premiumPictogramPath = 'assets/pictograms/premium-pictogram.svg';
          return (React.createElement("div", { id: 'collection-premium-banner' },
                                      React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                                                          React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                                              React.createElement(vortex_api_1.FlexLayout, { type: 'row', id: 'collection-premium-banner-header' },
                                                                                                  React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                                                                                      React.createElement(vortex_api_1.Image, { className: 'premium-pictogram', srcs: [premiumPictogramPath] })),
                                                                                                  React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                                                                                                      React.createElement("div", { className: 'collections-premium-banner-title' }, t('Premium'))))),
                                                          React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                                                              React.createElement("div", { className: 'collections-premium-banner-body' }, t('Auto-download collections at max speed'))),
                                                          React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                                              React.createElement(react_bootstrap_1.Button, { id: 'get-premium-button', className: 'small', onClick: this.goGetPremium },
                                                                                                  React.createElement(vortex_api_1.Image, { srcs: [electricBoltIconPath] }),
                                                                                                  t('Unlock max download speeds'))))));
        }
      }
      exports["default"] = CollectionBanner;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionInstructions.tsx":
/*!*****************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionInstructions.tsx ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
      const ReactMarkdown = __webpack_require__(/*! react-markdown */ "../../node_modules/react-markdown/src/react-markdown.js");
      const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
      function Instructions(props) {
        let _a, _b, _c;
        const { t, collection, mods, onToggleInstructions } = props;
        const { required, optional } = React.useMemo(() => {
          let _a;
          return ((_a = collection.rules) !== null && _a !== void 0 ? _a : []).reduce((prev, rule) => {
            let _a, _b;
            if (((0, util_1.isEmpty)((_a = rule.extra) === null || _a === void 0 ? void 0 : _a.instructions))
                || !['requires', 'recommends'].includes(rule.type)) {
              return prev;
            }
            const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
            if (mod !== undefined) {
              const entry = {
                rule,
                mod,
                name: vortex_api_1.util.renderModReference(rule.reference),
                instructions: (_b = rule.extra) === null || _b === void 0 ? void 0 : _b.instructions
              };
              if (rule.type === 'requires') {
                prev.required.push(entry);
              }
              else {
                prev.optional.push(entry);
              }
            }
            return prev;
          }, { required: [], optional: [] });
        }, [mods, collection]);
        const installInstructions = (((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.installInstructions) === undefined ||
        ((_b = collection.attributes) === null || _b === void 0 ? void 0 : _b.installInstructions) === '') &&
        (required.length === 0) &&
        (optional.length === 0) ?
          t(constants_1.DEFAULT_INSTRUCTIONS) :
          (_c = collection.attributes) === null || _c === void 0 ? void 0 : _c.installInstructions;
        return (React.createElement(React.Fragment, null,
                                    React.createElement(ReactMarkdown, { className: 'collection-instructions-text', allowedElements: ['p', 'br', 'a', 'em', 'strong'], unwrapDisallowed: true }, installInstructions),
                                    (required.length > 0) ? (React.createElement(React.Fragment, null,
                                                                                 React.createElement("h4", null, t('Instructions - Required Mods')),
                                                                                 React.createElement("div", { className: 'collection-instructions-container' },
                                                                                                     React.createElement("table", null,
                                                                                                                         React.createElement("tbody", null, required.map((iter) => {
                                                                                                                           let _a;
                                                                                                                           return (React.createElement("tr", { key: iter.name },
                                                                                                                                                       React.createElement("td", { className: 'collection-mod-name' }, iter.name),
                                                                                                                                                       React.createElement("td", { className: 'collection-mod-instructions' },
                                                                                                                                                                           React.createElement(ReactMarkdown, { allowedElements: ['p', 'br', 'a', 'em', 'strong'], unwrapDisallowed: true }, iter.instructions)),
                                                                                                                                                       React.createElement("td", { className: 'collection-mod-actions' },
                                                                                                                                                                           React.createElement(react_bootstrap_1.Button, { "data-modid": (_a = iter.mod) === null || _a === void 0 ? void 0 : _a.id, onClick: onToggleInstructions }, t('Open instructions')))));
                                                                                                                         })))))) : null,
                                    (optional.length > 0) ? (React.createElement(React.Fragment, null,
                                                                                 React.createElement("h4", null, t('Instructions - Optional Mods')),
                                                                                 React.createElement("div", { className: 'collection-instructions-container' },
                                                                                                     React.createElement("table", null,
                                                                                                                         React.createElement("tbody", null, optional.map(iter => {
                                                                                                                           let _a;
                                                                                                                           return (React.createElement("tr", { key: iter.name },
                                                                                                                                                       React.createElement("td", { className: 'collection-mod-name' }, iter.name),
                                                                                                                                                       React.createElement("td", { className: 'collection-mod-instructions' },
                                                                                                                                                                           React.createElement(ReactMarkdown, { allowedElements: ['p', 'br', 'a', 'em', 'strong'], unwrapDisallowed: true }, iter.instructions)),
                                                                                                                                                       React.createElement("td", { className: 'collection-mod-actions' },
                                                                                                                                                                           React.createElement(react_bootstrap_1.Button, { "data-modid": (_a = iter.mod) === null || _a === void 0 ? void 0 : _a.id, onClick: onToggleInstructions }, t('Open instructions')))));
                                                                                                                         })))))) : null));
      }
      exports["default"] = Instructions;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionItemStatus.tsx":
/*!***************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionItemStatus.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const RadialProgressT = vortex_api_1.RadialProgress;
      class CollectionItemStatus extends React.Component {
        render() {
          let _a, _b;
          const { t, download, mod } = this.props;
          if (mod.collectionRule['ignored'] === true) {
            return (React.createElement("div", { className: 'collection-status-ignored' },
                                        React.createElement(vortex_api_1.Icon, { name: 'toggle-disabled' }),
                                        t('Ignored')));
          }
          if (mod.state === 'installed') {
            if (mod.enabled) {
              return (React.createElement("div", { className: 'collection-status-enabled' },
                                          React.createElement(vortex_api_1.Icon, { name: 'toggle-enabled' }),
                                          t('Enabled')));
            }
            else {
              return (React.createElement("div", { className: 'collection-status-disabled' },
                                          React.createElement(vortex_api_1.Icon, { name: 'toggle-disabled' }),
                                          t('Disabled')));
            }
          }
          else if (mod.state === 'installing') {
            const progressBarData = {
              min: 0,
              max: 100,
              value: ((_a = mod.progress) !== null && _a !== void 0 ? _a : 0) * 100,
              class: 'collection-install-progress',
            };
            return (React.createElement("div", { className: 'collection-status-progress' },
                                        React.createElement(RadialProgressT, { className: 'collection-progress-radial', data: [progressBarData], totalRadius: 32 }),
                                        React.createElement("div", { className: 'progress-title' }, t('Installing...'))));
          }
          else if (mod.state === 'downloading') {
            if ((download === null || download === void 0 ? void 0 : download.state) === 'paused') {
              return (React.createElement("div", { className: 'collection-status-paused' },
                                          React.createElement(vortex_api_1.Icon, { name: 'pause' }),
                                          t('Download paused')));
            }
            else if ((download === null || download === void 0 ? void 0 : download.state) === 'failed') {
              return (React.createElement("div", { className: 'collection-status-failed' },
                                          React.createElement(vortex_api_1.Icon, { name: 'warning' }),
                                          t('Download failed')));
            }
            const progressBarData = {
              min: 0,
              max: 100,
              value: ((_b = mod.progress) !== null && _b !== void 0 ? _b : 0) * 100,
              class: 'collection-install-progress',
            };
            return (React.createElement("div", { className: 'collection-status-progress' },
                                        React.createElement(RadialProgressT, { className: 'collection-progress-radial', data: [progressBarData], totalRadius: 32 }),
                                        React.createElement("div", { className: 'progress-title' }, t('Downloading...'))));
          }
          else {
            if (mod.collectionRule.type === 'recommends') {
              return (React.createElement("div", { className: 'collection-status-notinstalled' },
                                          React.createElement(vortex_api_1.Icon, { name: 'install' }),
                                          " ",
                                          t('Not installed')));
            }
            else {
              if (mod.state === 'downloaded') {
                return (React.createElement("div", { className: 'collection-status-pending' },
                                            React.createElement(vortex_api_1.Icon, { name: 'install' }),
                                            t('Install pending')));
              }
              else {
                return (React.createElement("div", { className: 'collection-status-pending' },
                                            React.createElement(vortex_api_1.Icon, { name: 'download' }),
                                            t('Download pending')));
              }
            }
          }
        }
      }
      exports["default"] = CollectionItemStatus;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionModDetails.tsx":
/*!***************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionModDetails.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
      function CollectionModDetails(props) {
        let _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17;
        const { t, gameId, local, remote } = props;
        const uploaderName = (_e = (_b = (_a = local === null || local === void 0 ? void 0 : local.attributes) === null || _a === void 0 ? void 0 : _a.uploader) !== null && _b !== void 0 ? _b : (_d = (_c = remote === null || remote === void 0 ? void 0 : remote.file) === null || _c === void 0 ? void 0 : _c.owner) === null || _d === void 0 ? void 0 : _d.name) !== null && _e !== void 0 ? _e : constants_1.AUTHOR_UNKNOWN;
        const uploaderId = (_g = (_f = local === null || local === void 0 ? void 0 : local.attributes) === null || _f === void 0 ? void 0 : _f.uploaderId) !== null && _g !== void 0 ? _g : (_j = (_h = remote === null || remote === void 0 ? void 0 : remote.file) === null || _h === void 0 ? void 0 : _h.owner) === null || _j === void 0 ? void 0 : _j.memberId;
        const uploaderAvatar = (_m = (_l = (_k = remote === null || remote === void 0 ? void 0 : remote.file) === null || _k === void 0 ? void 0 : _k.owner) === null || _l === void 0 ? void 0 : _l.avatar) !== null && _m !== void 0 ? _m : 'assets/images/noavatar.png';
        const authorName = (_s = (_p = (_o = local === null || local === void 0 ? void 0 : local.attributes) === null || _o === void 0 ? void 0 : _o.author) !== null && _p !== void 0 ? _p : (_r = (_q = remote === null || remote === void 0 ? void 0 : remote.file) === null || _q === void 0 ? void 0 : _q.mod) === null || _r === void 0 ? void 0 : _r.author) !== null && _s !== void 0 ? _s : constants_1.AUTHOR_UNKNOWN;
        const modTitle = (_w = (_t = vortex_api_1.util.renderModName(local)) !== null && _t !== void 0 ? _t : (_v = (_u = remote === null || remote === void 0 ? void 0 : remote.file) === null || _u === void 0 ? void 0 : _u.mod) === null || _v === void 0 ? void 0 : _v.name) !== null && _w !== void 0 ? _w : '';
        const version = (_0 = (_y = (_x = local === null || local === void 0 ? void 0 : local.attributes) === null || _x === void 0 ? void 0 : _x.version) !== null && _y !== void 0 ? _y : (_z = remote === null || remote === void 0 ? void 0 : remote.file) === null || _z === void 0 ? void 0 : _z.version) !== null && _0 !== void 0 ? _0 : '???';
        const description = (_5 = (_2 = (_1 = local === null || local === void 0 ? void 0 : local.attributes) === null || _1 === void 0 ? void 0 : _1.shortDescription) !== null && _2 !== void 0 ? _2 : (_4 = (_3 = remote === null || remote === void 0 ? void 0 : remote.file) === null || _3 === void 0 ? void 0 : _3.mod) === null || _4 === void 0 ? void 0 : _4.summary) !== null && _5 !== void 0 ? _5 : '';
        const image = (_7 = (_6 = local === null || local === void 0 ? void 0 : local.attributes) === null || _6 === void 0 ? void 0 : _6.pictureUrl) !== null && _7 !== void 0 ? _7 : (_9 = (_8 = remote === null || remote === void 0 ? void 0 : remote.file) === null || _8 === void 0 ? void 0 : _8.mod) === null || _9 === void 0 ? void 0 : _9.pictureUrl;
        const domainName = (_12 = (_11 = (_10 = remote === null || remote === void 0 ? void 0 : remote.file) === null || _10 === void 0 ? void 0 : _10.game) === null || _11 === void 0 ? void 0 : _11.domainName) !== null && _12 !== void 0 ? _12 : vortex_api_1.util.nexusGameId(vortex_api_1.util.getGame((_14 = (_13 = local === null || local === void 0 ? void 0 : local.attributes) === null || _13 === void 0 ? void 0 : _13.gameId) !== null && _14 !== void 0 ? _14 : gameId));
        const modId = (_16 = (_15 = local === null || local === void 0 ? void 0 : local.attributes) === null || _15 === void 0 ? void 0 : _15.modId) !== null && _16 !== void 0 ? _16 : (_17 = remote === null || remote === void 0 ? void 0 : remote.file) === null || _17 === void 0 ? void 0 : _17.modId;
        const visitUploader = React.useCallback(() => {
          vortex_api_1.util.opn(`${constants_1.NEXUS_BASE_URL}/users/${uploaderId}`);
        }, [uploaderId]);
        const visitPage = React.useCallback(() => {
          vortex_api_1.util.opn(`${constants_1.NEXUS_BASE_URL}/${domainName}/mods/${modId}`);
        }, [uploaderId]);
        return (React.createElement("div", { className: 'installing-mod-overview' },
                                    React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                                        React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-mod-detail-imagecontainer' }, (image)
                                                          ? React.createElement(vortex_api_1.ZoomableImage, { className: 'installing-mod-image', url: image })
                                                          : null),
                                                        React.createElement(vortex_api_1.FlexLayout.Flex, { fill: true },
                                                                            React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                                                                                                React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                                                                                    React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                                                                                                                        React.createElement("div", { className: 'installing-mod-title' }, modTitle),
                                                                                                                                        (modId !== undefined) ? (React.createElement(vortex_api_1.tooltip.IconButton, { className: 'collection-open-mod-in-browser', icon: 'open-in-browser', tooltip: t('Open Mod in Webbrowser'), onClick: visitPage })) : null)),
                                                                                                React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                                                                                                    React.createElement("div", { className: 'collection-description' }, vortex_api_1.util.bbcodeToReact(description))),
                                                                                                React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                                                                                    React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                                                                                                                        React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell' },
                                                                                                                                                            React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                                                                                                                                                                React.createElement(vortex_api_1.Image, { srcs: [uploaderAvatar], circle: true }),
                                                                                                                                                                                React.createElement("div", null,
                                                                                                                                                                                                    React.createElement("div", { className: 'title' }, t('Uploaded by')),
                                                                                                                                                                                                    React.createElement("div", null, (uploaderName !== constants_1.AUTHOR_UNKNOWN)
                                                                                                                                                                                                      ? React.createElement("a", { onClick: visitUploader }, uploaderName)
                                                                                                                                                                                                      : uploaderName)))),
                                                                                                                                        React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell' },
                                                                                                                                                            React.createElement("div", { className: 'title' }, t('Created by')),
                                                                                                                                                            React.createElement("div", null, authorName)),
                                                                                                                                        React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell' },
                                                                                                                                                            React.createElement("div", { className: 'title' }, t('Version')),
                                                                                                                                                            React.createElement("div", null, version)))))))));
      }
      exports["default"] = CollectionModDetails;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionOverview.tsx":
/*!*************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionOverview.tsx ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const CollectionReleaseStatus_1 = __webpack_require__(/*! ../CollectionReleaseStatus */ "./src/views/CollectionReleaseStatus.tsx");
      const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
      const HealthIndicator_1 = __webpack_require__(/*! ./HealthIndicator */ "./src/views/CollectionPageView/HealthIndicator.tsx");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const persistent_1 = __webpack_require__(/*! ../../actions/persistent */ "./src/actions/persistent.ts");
      const session_1 = __webpack_require__(/*! ../../actions/session */ "./src/actions/session.ts");
      const ENDORSE_DELAY_MS = 43200000;
      function EndorseButton(props) {
        let _a, _b, _c, _d;
        const { t, collection, gameId, mod, voteAllowed } = props;
        const context = React.useContext(vortex_api_1.MainContext);
        const endorse = React.useCallback(async () => {
          let _a, _b;
          const endorsedStatus = (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.endorsed) !== null && _b !== void 0 ? _b : 'Undecided';
          context.api.events.emit('endorse-mod', gameId, mod.id, endorsedStatus);
          context.api.events.emit('analytics-track-click-event', 'Collections', endorsedStatus);
          setTimeout(async () => {
            refreshCollection(context.api, collection);
          }, 500);
        }, [mod, collection]);
        const endorsedStatus = (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.endorsed) !== null && _b !== void 0 ? _b : 'Undecided';
        const endorsed = (((_c = mod.attributes) === null || _c === void 0 ? void 0 : _c.endorsed) === 'Endorsed');
        const classes = `collection-ghost-button ${endorsed ? 'endorse-yes' : 'endorse-maybe'}`;
        const { icon, toolTip } = {
          undecided: { icon: 'endorse-maybe', toolTip: t('Undecided') },
          abstained: { icon: 'endorse-maybe', toolTip: t('Abstained') },
          endorsed: { icon: 'endorse-yes', toolTip: t('Endorsed') },
          disabled: { icon: 'endorse-disabled', toolTip: t('Endorsement disabled by author') },
          pending: { icon: 'spinner_new', toolTip: t('Pending') }
        }[endorsedStatus.toLowerCase()] || { icon: 'like-maybe', toolTip: t('Undecided') };
        return (React.createElement(vortex_api_1.tooltip.IconButton, { icon: icon, tooltip: toolTip, className: classes, onClick: endorse, disabled: !voteAllowed || ((collection === null || collection === void 0 ? void 0 : collection.endorsements) === undefined), spin: endorsedStatus.toLowerCase() === 'pending' }, (_d = collection === null || collection === void 0 ? void 0 : collection.endorsements) !== null && _d !== void 0 ? _d : '?'));
      }
      function CommentButton(props) {
        let _a, _b;
        const { t, collection } = props;
        const context = React.useContext(vortex_api_1.MainContext);
        const click = React.useCallback(() => {
          if ((collection === null || collection === void 0 ? void 0 : collection['commentLink']) !== undefined) {
            context.api.events.emit('analytics-track-click-event', 'Collections', 'Comments');
            vortex_api_1.util.opn(collection['commentLink']);
          }
        }, [collection]);
        return (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'comments', className: 'collection-ghost-button', tooltip: t('Comments'), onClick: click, disabled: (collection === null || collection === void 0 ? void 0 : collection['commentLink']) === undefined }, (_b = (_a = collection === null || collection === void 0 ? void 0 : collection.forumTopic) === null || _a === void 0 ? void 0 : _a.postsCount) !== null && _b !== void 0 ? _b : 0));
      }
      async function refreshCollection(api, collection) {
        if (!(collection === null || collection === void 0 ? void 0 : collection.slug)) {
          return;
        }
        (0, vortex_api_1.log)('info', `refreshCollection ${collection.slug}`);
        const result = (await api.emitAndAwait('get-nexus-collection', collection.slug))[0];
        api.store.dispatch((0, persistent_1.updateCollectionInfo)(collection.id.toString(), result, Date.now()));
      }
      class CollectionOverview extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.enable = () => {
            this.props.onSetEnabled(true);
          };
          this.disable = () => {
            this.props.onSetEnabled(false);
          };
          this.openUrl = () => {
            const { revision } = this.props;
            const { collection } = revision;
            if (collection !== undefined && (revision === null || revision === void 0 ? void 0 : revision.revisionNumber) !== undefined) {
              this.context.api.events.emit('analytics-track-click-event', 'Collections', 'View on site Added Collection');
              vortex_api_1.util.opn(vortex_api_1.util.nexusModsURL([
                collection.game.domainName,
                'collections',
                collection.slug,
                'revisions',
                revision.revisionNumber.toString(),
              ], {
                campaign: vortex_api_1.util.Campaign.ViewCollection,
                section: vortex_api_1.util.Section.Collections,
              }));
            }
          };
          this.cloneCollection = () => {
            const { onClone, collection } = this.props;
            if (onClone !== undefined && collection !== undefined) {
              onClone(collection.id);
              this.context.api.events.emit('analytics-track-click-event', 'Collections', 'Clone');
            }
          };
          this.remove = () => {
            const { onRemove, collection } = this.props;
            if (onRemove !== undefined && collection !== undefined) {
              onRemove(collection.id);
            }
          };
          this.voteSuccess = (success) => {
            let _a, _b;
            const { collection, profile, revision, showDownvoteResponse, showUpvoteResponse, onSuppressVoteResponse, onVoteSuccess, } = this.props;
            if (revision.collection === undefined) {
              (0, vortex_api_1.log)('error', 'failed to show vote response dialog, missing collection info');
              return;
            }
            const bugLink = `https://next.nexusmods.com/${revision.collection.game.domainName}/collections/${revision.collection.slug}?tab=Bugs`;
            const endorsedStatus = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.endorsed) !== null && _b !== void 0 ? _b : 'Undecided';
            if (success && showUpvoteResponse) {
              onVoteSuccess === null || onVoteSuccess === void 0 ? void 0 : onVoteSuccess(collection.id, success);
              if (endorsedStatus === 'Endorsed')
                return;
              this.context.api.showDialog('question', 'Collection was successful', {
                text: 'Congratulations! Please consider endorsing this collection if you are enjoying it. ' +
                        'Endorsing helps others discover this collection and lets the curator know you enjoyed it.',
                checkboxes: [
                  { id: 'dont_show_again', value: false, text: "Don't show again" },
                ],
              }, [
                { label: 'Close' },
                {
                  label: 'Endorse',
                  action: () => {
                    this.context.api.events.emit('endorse-mod', profile.gameId, collection.id, endorsedStatus);
                    this.context.api.events.emit('analytics-track-click-event', 'Collections', endorsedStatus);
                  },
                },
              ])
                .then((result) => {
                  if (result.input['dont_show_again']) {
                    onSuppressVoteResponse('upvote');
                  }
                });
            }
            else if (!success && showDownvoteResponse) {
              this.context.api.store.dispatch((0, session_1.healthDownvoteDialog)(collection.id));
            }
          };
          this.initState({ selIdx: 0 });
          this.mWorkshopActions = [
            {
              title: 'Enable',
              action: this.enable,
              condition: () => {
                let _a, _b;
                const { collection, incomplete, profile } = this.props;
                return (!incomplete && ((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[collection.id]) === null || _b === void 0 ? void 0 : _b.enabled) !== true);
              },
              icon: 'toggle-enabled',
            },
            {
              title: 'View on Nexus Mods',
              action: this.openUrl,
              condition: () => {
                let _a;
                return ((_a = this.props.collection.attributes) === null || _a === void 0 ? void 0 : _a.collectionSlug) !== undefined &&
                        this.props.revision !== undefined;
              },
              icon: 'open-in-browser',
            },
            {
              title: 'Disable',
              action: this.disable,
              condition: () => {
                let _a, _b;
                const { collection, incomplete, profile } = this.props;
                return (!incomplete && ((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[collection.id]) === null || _b === void 0 ? void 0 : _b.enabled) === true);
              },
              icon: 'toggle-disabled',
            },
            {
              title: 'Show in Mods',
              action: this.props.onShowMods,
              icon: 'inspect',
            },
            {
              title: 'Edit (Workshop)',
              action: this.cloneCollection,
              condition: () => this.props.onClone !== undefined,
              icon: 'clone',
            },
            {
              title: 'Remove',
              action: this.remove,
              condition: () => this.props.onRemove !== undefined,
              icon: 'remove',
            },
          ];
        }
        componentDidMount() {
          const { revision } = this.props;
          refreshCollection(this.context.api, revision.collection);
        }
        render() {
          let _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
          const { t, collection, incomplete, profile, revision, votedSuccess } = this.props;
          const classes = ['collection-overview'];
          const timeSinceInstall = Date.now() - new Date(((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.installCompleted) ? (_b = collection.attributes) === null || _b === void 0 ? void 0 : _b.installCompleted : (_d = (_c = collection.attributes) === null || _c === void 0 ? void 0 : _c.installTime) !== null && _d !== void 0 ? _d : 0).getTime();
          const voteAllowed = timeSinceInstall >= ENDORSE_DELAY_MS;
          const rating = {
            average: parseFloat((_f = (_e = revision.collection) === null || _e === void 0 ? void 0 : _e.overallRating) !== null && _f !== void 0 ? _f : '100'),
            total: (_h = (_g = revision.collection) === null || _g === void 0 ? void 0 : _g.overallRatingCount) !== null && _h !== void 0 ? _h : 0,
          };
          return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' ') },
                                      React.createElement(react_bootstrap_1.Media, null,
                                                          React.createElement(react_bootstrap_1.Media.Left, null,
                                                                              React.createElement(CollectionTile_1.default, { t: t, imageTime: Date.now(), collection: collection, gameId: profile.gameId, details: false })),
                                                          React.createElement(react_bootstrap_1.Media.Body, null,
                                                                              React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                                                                                                  React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                                                                                      React.createElement("div", { className: 'collection-overview-title' },
                                                                                                                                          React.createElement("div", { className: 'collection-title' }, vortex_api_1.util.renderModName(collection)),
                                                                                                                                          React.createElement(CollectionReleaseStatus_1.default, { t: t, active: true, enabled: (_l = (_k = (_j = profile.modState) === null || _j === void 0 ? void 0 : _j[collection.id]) === null || _k === void 0 ? void 0 : _k.enabled) !== null && _l !== void 0 ? _l : false, collection: collection, incomplete: incomplete }),
                                                                                                                                          React.createElement("div", { className: 'flex-filler' }))),
                                                                                                  React.createElement(vortex_api_1.FlexLayout.Flex, { className: 'collection-description-container' },
                                                                                                                      React.createElement("div", { className: 'collection-description' }, (_o = (_m = collection.attributes) === null || _m === void 0 ? void 0 : _m.shortDescription) !== null && _o !== void 0 ? _o : t('No description'))),
                                                                                                  React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-page-detail-bar' },
                                                                                                                      React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                                                                                                                          React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell ' },
                                                                                                                                                              React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                                                                                                                                                                  React.createElement(vortex_api_1.Image, { srcs: [
                                                                                                                                                                                    (_q = (_p = collection.attributes) === null || _p === void 0 ? void 0 : _p.uploaderAvatar) !== null && _q !== void 0 ? _q : 'assets/images/noavatar.png',
                                                                                                                                                                                  ], circle: true }),
                                                                                                                                                                                  React.createElement("div", null,
                                                                                                                                                                                                      React.createElement("div", { className: 'title' }, t('Curated by')),
                                                                                                                                                                                                      React.createElement("div", null, (_r = collection.attributes) === null || _r === void 0 ? void 0 : _r.uploader)))),
                                                                                                                                          React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell hideable' },
                                                                                                                                                              React.createElement("div", { className: 'title' }, t('Revision')),
                                                                                                                                                              React.createElement("div", null, (_s = collection.attributes) === null || _s === void 0 ? void 0 : _s.revisionNumber)),
                                                                                                                                          React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell' },
                                                                                                                                                              React.createElement("div", { className: 'title' }, t('Last updated')),
                                                                                                                                                              React.createElement("div", null, this.renderTime((_t = collection.attributes) === null || _t === void 0 ? void 0 : _t.updatedTimestamp))),
                                                                                                                                          React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell hideable' },
                                                                                                                                                              React.createElement("div", { className: 'title' }, t('Uploaded')),
                                                                                                                                                              React.createElement("div", null, this.renderTime((_u = collection.attributes) === null || _u === void 0 ? void 0 : _u.uploadedTimestamp))),
                                                                                                                                          React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                                                                                                                              React.createElement(EndorseButton, { t: t, collection: revision.collection, mod: collection, gameId: profile.gameId, voteAllowed: voteAllowed })),
                                                                                                                                          React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                                                                                                                              React.createElement(CommentButton, { t: t, collection: revision.collection })),
                                                                                                                                          React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                                                                                                                                              React.createElement("div", null)))))),
                                                          React.createElement(react_bootstrap_1.Media.Right, null,
                                                                              React.createElement("div", { className: 'collection-health-container' },
                                                                                                  React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                                                                                                                      React.createElement(vortex_api_1.FlexLayout.Fixed, null, (revision === null || revision === void 0 ? void 0 : revision.revisionStatus) !== 'is_private' ? (React.createElement(HealthIndicator_1.default, { t: t, revisionNumber: (_v = revision === null || revision === void 0 ? void 0 : revision.revisionNumber) !== null && _v !== void 0 ? _v : 0, value: rating, onVoteSuccess: this.voteSuccess, ownSuccess: votedSuccess, voteAllowed: voteAllowed, gameVersion: (_y = (_x = (_w = this.context.api.getState().persistent) === null || _w === void 0 ? void 0 : _w.gameMode) === null || _x === void 0 ? void 0 : _x.versions[profile.gameId]) !== null && _y !== void 0 ? _y : '?', collectionGameVersion: (_1 = (_0 = (_z = revision === null || revision === void 0 ? void 0 : revision.gameVersions) === null || _z === void 0 ? void 0 : _z[0]) === null || _0 === void 0 ? void 0 : _0.reference) !== null && _1 !== void 0 ? _1 : '?' })) : null),
                                                                                                                      React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                                                                                                                          React.createElement("div", { className: 'collection-workshop-actions' },
                                                                                                                                                              React.createElement(vortex_api_1.ActionDropdown, { t: t, id: 'collection-workshop-actions', staticElements: this.mWorkshopActions })))))))));
        }
        renderTime(timestamp) {
          const { t, language } = this.props;
          if (timestamp === undefined) {
            return t('Never');
          }
          return new Date(timestamp).toLocaleDateString(language);
        }
      }
      exports["default"] = CollectionOverview;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionOverviewSelection.tsx":
/*!**********************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionOverviewSelection.tsx ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const CollectionModDetails_1 = __webpack_require__(/*! ./CollectionModDetails */ "./src/views/CollectionPageView/CollectionModDetails.tsx");
      const CollectionReleaseStatus_1 = __webpack_require__(/*! ../CollectionReleaseStatus */ "./src/views/CollectionReleaseStatus.tsx");
      const SlideshowControls_1 = __webpack_require__(/*! ./SlideshowControls */ "./src/views/CollectionPageView/SlideshowControls.tsx");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      class CollectionOverview extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.setSelection = (idx) => {
            this.nextState.selIdx = (this.props.modSelection.length === 0)
              ? 0
              : idx % this.props.modSelection.length;
          };
          this.initState({ selIdx: 0 });
        }
        render() {
          let _a, _b, _c, _d, _e;
          const { t, collection, incomplete, modSelection, profile } = this.props;
          let { selIdx } = this.state;
          if (selIdx >= modSelection.length) {
            selIdx = 0;
          }
          const modDetails = modSelection.length > 0;
          const classes = ['collection-overview'];
          if (modDetails) {
            classes.push('collection-mod-selection');
          }
          return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' ') },
                                      React.createElement("div", { className: 'collection-overview-title' },
                                                          React.createElement("div", { className: 'collection-title' }, vortex_api_1.util.renderModName(collection)),
                                                          React.createElement(CollectionReleaseStatus_1.default, { t: t, active: true, enabled: (_c = (_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[collection.id]) === null || _b === void 0 ? void 0 : _b.enabled) !== null && _c !== void 0 ? _c : false, collection: collection, incomplete: incomplete }),
                                                          modSelection.length > 1 ? (React.createElement(React.Fragment, null,
                                                                                                         React.createElement(SlideshowControls_1.default, { t: t, numItems: modSelection.length, onChangeItem: this.setSelection, autoProgressTimeMS: 5000 }),
                                                                                                         React.createElement("div", { className: 'flex-filler' }),
                                                                                                         React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed', tooltip: t('Deselects mods'), icon: 'close', onClick: this.props.onDeselectMods }))) : null),
                                      React.createElement(CollectionModDetails_1.default, { t: t, local: (_d = modSelection[selIdx]) === null || _d === void 0 ? void 0 : _d.local, remote: (_e = modSelection[selIdx]) === null || _e === void 0 ? void 0 : _e.remote, gameId: profile.gameId })));
        }
      }
      exports["default"] = CollectionOverview;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionProgress.tsx":
/*!*************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionProgress.tsx ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const CollectionBanner_1 = __webpack_require__(/*! ./CollectionBanner */ "./src/views/CollectionPageView/CollectionBanner.tsx");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
      class CollectionProgress extends vortex_api_1.ComponentEx {
        static getDerivedStateFromProps(props, state) {
          return {
            totalSize: (0, util_1.calculateCollectionSize)(props.mods),
          };
        }
        constructor(props) {
          super(props);
          this.initState({
            totalSize: 0,
          });
        }
        render() {
          let _a;
          const { t, activity, downloads, isPremium, mods, profile, totalSize, onCancel, onPause, onResume } = this.props;
          const group = (mod, download) => {
            let _a, _b, _c;
            if ((mod.state === 'downloading') && ((download === null || download === void 0 ? void 0 : download.state) === 'paused')) {
              return 'pending';
            }
            if ((mod.state === 'installed') && !((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[mod.id]) === null || _b === void 0 ? void 0 : _b.enabled)) {
              return 'disabled';
            }
            return (_c = {
              null: 'pending',
              installed: 'done',
              downloaded: 'pending',
              installing: 'installing',
              downloading: 'downloading',
            }[mod.state]) !== null && _c !== void 0 ? _c : 'pending';
          };
          const { pending, downloading, installing, disabled, done } = Object.values(mods).reduce((prev, mod) => {
            if ((mod.collectionRule.type === 'requires') && !mod.collectionRule['ignored']) {
              prev[group(mod, downloads[mod.archiveId])].push(mod);
            }
            return prev;
          }, { pending: [], downloading: [], installing: [], disabled: [], done: [] });
          if ((downloading.length === 0)
            && (installing.length === 0)
            && (pending.length === 0)
            && (disabled.length === 0)) {
            return null;
          }
          return (React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                      React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                                          React.createElement(react_bootstrap_1.Panel, null,
                                                                              React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-progress-flex' },
                                                                                                  (((_a = activity['dependencies']) !== null && _a !== void 0 ? _a : []).length > 0)
                                                                                                    ? this.renderActivity(t('Checking Dependencies'))
                                                                                                    : this.renderBars(installing, done),
                                                                                                  React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                                                                                      React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-pause-cancel-flex' },
                                                                                                                                          (onResume !== undefined) ? (React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed btn-pause-resume', onClick: onResume, disabled: onResume === null, tooltip: t('Resume'), icon: 'resume' })) : null,
                                                                                                                                          (onPause !== undefined) ? (React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed btn-pause-resume', onClick: onPause, tooltip: t('Pause'), icon: 'pause' })) : null,
                                                                                                                                          React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed btn-cancel', onClick: onCancel, icon: 'stop', tooltip: t('Cancel') }, t('Cancel'))))))),
                                      isPremium ? null : (React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-banner-container' },
                                                                              React.createElement(CollectionBanner_1.default, { t: t, totalSize: totalSize })))));
        }
        renderActivity(message) {
          return (React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                      React.createElement(vortex_api_1.Spinner, null),
                                      ' ',
                                      message));
        }
        renderBars(installing, done) {
          const { t, downloads, mods } = this.props;
          const { totalSize } = this.state;
          const curInstall = (installing.length > 0)
            ? installing.find(iter => iter.state === 'installing')
            : undefined;
          const downloadProgress = Object.values(mods).reduce((prev, mod) => {
            let _a;
            let size = 0;
            if ((mod.state === 'downloading') || (mod.state === null)) {
              const download = downloads[mod.archiveId];
              size += (download === null || download === void 0 ? void 0 : download.received) || 0;
            }
            else {
              size += ((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.fileSize) || 0;
            }
            return prev + size;
          }, 0);
          const relevant = Object.values(mods).filter(util_1.isRelevant);
          return (React.createElement(React.Fragment, null,
                                      React.createElement(vortex_api_1.ProgressBar, { now: downloadProgress, max: totalSize, showPercentage: true, labelLeft: t('Downloading'), labelRight: `${vortex_api_1.util.bytesToString(downloadProgress)} / ${vortex_api_1.util.bytesToString(totalSize)}` }),
                                      React.createElement(vortex_api_1.ProgressBar, { now: done.length, max: relevant.length, showPercentage: true, labelLeft: installing.length > 0 ? t('Installing') : t('Waiting to install'), labelRight: curInstall !== undefined ? vortex_api_1.util.renderModName(curInstall) : undefined })));
        }
      }
      exports["default"] = CollectionProgress;


/***/ }),

/***/ "./src/views/CollectionPageView/HealthDownvoteDialog.tsx":
/*!***************************************************************!*\
  !*** ./src/views/CollectionPageView/HealthDownvoteDialog.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const session_1 = __webpack_require__(/*! ../../actions/session */ "./src/actions/session.ts");
      const persistent_1 = __webpack_require__(/*! ../../actions/persistent */ "./src/actions/persistent.ts");
      function HealthDownvoteDialog(props) {
        let _a, _b, _c, _d, _e, _f, _g, _h;
        const [optionValue, setOptionValue] = React.useState(undefined);
        const [confirmationCheck, setConfirmationCheck] = React.useState(false);
        const context = React.useContext(vortex_api_1.MainContext);
        const { t } = (0, react_i18next_1.useTranslation)(constants_1.NAMESPACE);
        const dispatch = (0, react_redux_1.useDispatch)();
        const state = context.api.store.getState();
        const gameId = vortex_api_1.selectors.activeGameId(state);
        const collectionId = (0, react_redux_1.useSelector)((state) => { let _a; return (_a = state.session.collections.healthDownvoteDialog) !== null && _a !== void 0 ? _a : undefined; });
        const collection = (collectionId !== undefined)
          ? (_a = state.persistent.mods[gameId]) === null || _a === void 0 ? void 0 : _a[collectionId]
          : undefined;
        let revisionInfo;
        let collectionInfo;
        let commentLink = '#';
        let bugLink = '#';
        if (((_b = collection === null || collection === void 0 ? void 0 : collection.attributes) === null || _b === void 0 ? void 0 : _b.revisionId) !== undefined) {
          revisionInfo = (_d = (_c = state.persistent.collections.revisions) === null || _c === void 0 ? void 0 : _c[collection.attributes.revisionId]) === null || _d === void 0 ? void 0 : _d.info;
          if ((revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.collection) !== undefined) {
            collectionInfo = (_f = (_e = state.persistent.collections.collections) === null || _e === void 0 ? void 0 : _e[revisionInfo.collection.id]) === null || _f === void 0 ? void 0 : _f.info;
            commentLink = (_g = collectionInfo === null || collectionInfo === void 0 ? void 0 : collectionInfo['commentLink']) !== null && _g !== void 0 ? _g : '#';
            bugLink = (_h = `https://next.nexusmods.com/${collectionInfo.game.domainName}/collections/${collectionInfo.slug}?tab=Bugs`) !== null && _h !== void 0 ? _h : '#';
          }
        }
        const hide = React.useCallback(() => {
          dispatch((0, session_1.healthDownvoteDialog)(undefined));
        }, []);
        const downvote = () => {
          sendRating(false);
          hide();
        };
        const onChecked = (evt) => {
          setConfirmationCheck(evt.currentTarget.checked);
        };
        const sendRating = async (success) => {
          let _a, _b;
          const revisionId = (_b = (_a = collection === null || collection === void 0 ? void 0 : collection.attributes) === null || _a === void 0 ? void 0 : _a.revisionId) !== null && _b !== void 0 ? _b : undefined;
          const vote = success ? 'positive' : 'negative';
          const voted = (await context.api.emitAndAwait('rate-nexus-collection-revision', parseInt(revisionId, 10), vote))[0];
          if (voted.success) {
            dispatch((0, persistent_1.updateSuccessRate)(revisionId, vote, voted.averageRating.average, voted.averageRating.total));
          }
        };
        return (React.createElement(vortex_api_1.Modal, { id: 'collection-health-downvote-dialog', className: 'collection-health-downvote-dialog', show: collection !== undefined, onHide: hide },
                                    React.createElement(vortex_api_1.Modal.Header, null,
                                                        React.createElement(vortex_api_1.Modal.Title, null, t('Downvote Success Rating'))),
                                    React.createElement(vortex_api_1.Modal.Body, null,
                                                        React.createElement("p", null, t(`Sorry to hear that the collection \"${vortex_api_1.util.renderModName(collection)}\" isn't working for you. Here are some steps that could help:`)),
                                                        React.createElement("ol", null,
                                                                            React.createElement("li", null, "Make sure your game version matches the game version the collection was created for."),
                                                                            React.createElement("li", null, "Read the collection instructions and check if you've missed any steps."),
                                                                            React.createElement("li", null,
                                                                                                React.createElement("a", { href: commentLink }, "Check comments on Nexus Mods"),
                                                                                                " for advice and to reach out to the collection curator."),
                                                                            React.createElement("li", null,
                                                                                                React.createElement("a", { href: bugLink }, "View bug reports on Nexus Mods"),
                                                                                                " or report a new bug to help the curator fix the issue.")),
                                                        React.createElement("h5", null, t(`Success ratings help others know if a collection installs and runs correctly. They are not a vote on whether you liked the collection or not.`)),
                                                        React.createElement(react_bootstrap_1.FormGroup, null,
                                                                            React.createElement(react_bootstrap_1.Checkbox, { onChange: onChecked }, t('I have tried the above steps and confirm this collection does not work.')))),
                                    React.createElement(vortex_api_1.Modal.Footer, null,
                                                        React.createElement(react_bootstrap_1.Button, { onClick: hide }, t('Cancel')),
                                                        React.createElement(react_bootstrap_1.Button, { onClick: downvote, disabled: !confirmationCheck }, t('Submit')))));
      }
      exports["default"] = HealthDownvoteDialog;


/***/ }),

/***/ "./src/views/CollectionPageView/HealthIndicator.tsx":
/*!**********************************************************!*\
  !*** ./src/views/CollectionPageView/HealthIndicator.tsx ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function HealthIndicator(props) {
        const context = React.useContext(vortex_api_1.MainContext);
        const { t, onVoteSuccess, ownSuccess, revisionNumber, value, voteAllowed, gameVersion, collectionGameVersion } = props;
        const voteSuccess = React.useCallback((evt) => {
          const { success } = evt.currentTarget.dataset;
          const isUpvote = success === 'true';
          if (ownSuccess) {
            if (ownSuccess === 'positive' && isUpvote) {
              return;
            }
            if (ownSuccess === 'negative' && !isUpvote) {
              return;
            }
          }
          onVoteSuccess(isUpvote);
          context.api.events.emit('analytics-track-click-event', 'Collections', isUpvote ? 'Upvote Collection' : 'Downvote Collection');
        }, [ownSuccess]);
        if (value === undefined) {
          return null;
        }
        const RadialProgressT = vortex_api_1.RadialProgress;
        const rating = value.average;
        let cssClass = 'success-rating-good';
        if (rating === undefined) {
          cssClass = 'success-rating-insufficient';
        }
        else if (rating < 50) {
          cssClass = 'success-rating-bad';
        }
        else if (rating < 75) {
          cssClass = 'success-rating-dubious';
        }
        const versionMismatch = gameVersion !== collectionGameVersion;
        const gameVersionClassName = versionMismatch ? 'dialog-danger-text' : '';
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', className: 'collection-health-indicator' },
                                    React.createElement("div", { className: 'collection-health-header' },
                                                        React.createElement("div", { className: 'collection-health-header-title' },
                                                                            React.createElement(vortex_api_1.Icon, { name: 'revision' }),
                                                                            t('Revision {{number}}', { replace: { number: revisionNumber } })),
                                                        React.createElement("div", { className: 'collection-health-header-gameversion' },
                                                                            t('Game Version: '),
                                                                            React.createElement("span", { className: gameVersionClassName }, collectionGameVersion),
                                                                            (versionMismatch) ? (React.createElement(vortex_api_1.More, { id: 'collection-health-version-mismatch', name: t('Version Mismatch') }, t('This collection was created using a different version of the game than you have and is the most common reason why a collection doesn\'t work correctly.\n\n'
                    + 'Your version: {{gameVersion}}\n\n'
                    + 'Collection version: {{collectionGameVersion}}', { replace: { collectionGameVersion: collectionGameVersion, gameVersion: gameVersion } }))) : null)),
                                    React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-health-body' },
                                                        React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-revition-rating-parent' },
                                                                            React.createElement("div", { className: 'collection-revision-rating-container' },
                                                                                                React.createElement(RadialProgressT, { data: [
                                                                                                  { class: cssClass, min: 0, max: 100, value: value.average },
                                                                                                ], totalRadius: 32, innerGap: 10, restOverlap: false }),
                                                                                                React.createElement("div", { className: 'centered-overlay' },
                                                                                                                    value.average,
                                                                                                                    "%")),
                                                                            React.createElement("div", { className: 'collection-revision-rating-numvotes' }, t('{{numVotes}} votes', { replace: { numVotes: value.total } }))),
                                                        React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                                                            React.createElement(vortex_api_1.FlexLayout, { type: 'column' }, (!voteAllowed) ? (React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-health-rating-text' }, t('Collection Success Rating'))) : (React.createElement(React.Fragment, null,
                                                                                                                                                                                                                                                                                                                          React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-health-rating-text' }, t('Did this collection work successfully?')),
                                                                                                                                                                                                                                                                                                                          React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                                                                                                                                                                                                                                                                                                              React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-voting-pill' },
                                                                                                                                                                                                                                                                                                                                                                  React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                                                                                                                                                                                                                                                                                                                                                      React.createElement(vortex_api_1.tooltip.Button, { className: 'collection-ghost-button ' +
                                        (ownSuccess === 'positive' ? 'voted' : ''), tooltip: voteAllowed
                                                                                                                                                                                                                                                                                                                                                                                        ? t('Collection worked (mostly)')
                                                                                                                                                                                                                                                                                                                                                                                        : t('You must wait for 12 hours between downloading a collection revision and rating it'), "data-success": true, onClick: voteSuccess, disabled: !voteAllowed }, t('Yes'))),
                                                                                                                                                                                                                                                                                                                                                                  React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                                                                                                                                                                                                                                                                                                                                                      React.createElement(vortex_api_1.tooltip.Button, { className: 'collection-ghost-button ' +
                                        (ownSuccess === 'negative' ? 'voted' : ''), tooltip: voteAllowed
                                                                                                                                                                                                                                                                                                                                                                                        ? t("Collection didn't work (in a significant way)")
                                                                                                                                                                                                                                                                                                                                                                                        : t('You must wait for 12 hours between downloading a collection revision and rating it'), "data-success": false, onClick: voteSuccess, disabled: !voteAllowed }, t('No'))))))))))));
      }
      exports["default"] = HealthIndicator;


/***/ }),

/***/ "./src/views/CollectionPageView/SlideshowControls.tsx":
/*!************************************************************!*\
  !*** ./src/views/CollectionPageView/SlideshowControls.tsx ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const Timer_1 = __webpack_require__(/*! ./Timer */ "./src/views/CollectionPageView/Timer.tsx");
      function SlideshowControls(props) {
        const { t, autoProgressTimeMS, numItems, onChangeItem } = props;
        const [paused, setPaused] = React.useState(false);
        const [idx, setIdx] = React.useState(0);
        const [lastChange, setLastChange] = React.useState(0);
        const isMounted = React.useRef(false);
        React.useEffect(() => {
          isMounted.current = true;
          return () => { isMounted.current = false; };
        }, []);
        const next = React.useCallback(() => {
          if (!isMounted.current) {
            return;
          }
          let value;
          setIdx(oldValue => {
            value = (oldValue + 1) % numItems;
            return value;
          });
          setLastChange(Date.now());
          onChangeItem(value);
        }, [numItems, onChangeItem, setIdx, setLastChange]);
        const prev = React.useCallback(() => {
          let value;
          setIdx(oldValue => {
            value = oldValue > 0 ? (oldValue - 1) : (numItems - 1);
            return value;
          });
          setLastChange(Date.now());
          onChangeItem(value);
        }, [numItems, onChangeItem, setIdx, setLastChange]);
        const togglePause = React.useCallback(() => {
          setPaused(old => !old);
        }, [setPaused]);
        return (React.createElement("div", { className: 'slideshow-controls' },
                                    React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'collection-previous', tooltip: t('Show previous mod'), disabled: idx === 0, onClick: prev }),
                                    t('{{pos}} of {{count}}', { replace: { pos: idx + 1, count: numItems } }),
                                    React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'collection-next', tooltip: t('Show next mod'), disabled: idx === numItems - 1, onClick: next }),
                                    (autoProgressTimeMS !== undefined) ? (React.createElement(vortex_api_1.tooltip.IconButton, { className: 'button-with-timer', icon: paused ? 'resume' : 'pause', tooltip: t('Start/Pause automatic advancement'), onClick: togglePause },
                                                                                              React.createElement(Timer_1.default, { className: 'slideshow-timer', started: lastChange, paused: paused, duration: autoProgressTimeMS, onTrigger: next }))) : null));
      }
      exports["default"] = SlideshowControls;


/***/ }),

/***/ "./src/views/CollectionPageView/Timer.tsx":
/*!************************************************!*\
  !*** ./src/views/CollectionPageView/Timer.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const circumference = 100;
      const radius = circumference / (2 * Math.PI);
      const stroke = Math.ceil(radius / 6);
      const width = radius * 2 + stroke;
      const center = width / 2;
      function Timer(props) {
        const { className, duration, onTrigger, paused, started } = props;
        const [timer, setTimer] = React.useState(null);
        const [active, setActive] = React.useState(true);
        const [elapsed, setElapsed] = React.useState(null);
        React.useEffect(() => {
          return () => {
            if (timer !== null) {
              clearTimeout(timer);
            }
          };
        }, []);
        React.useEffect(() => {
          setActive(false);
          setElapsed(null);
          setTimeout(() => {
            setActive(true);
          }, 10);
        }, [setActive, setElapsed, started]);
        React.useEffect(() => {
          if (timer !== null) {
            clearTimeout(timer);
          }
          if (paused) {
            setElapsed(Date.now() - started);
          }
          else {
            let remaining = duration;
            if (elapsed !== null) {
              remaining = duration - elapsed;
              setElapsed(null);
            }
            else {
              remaining = (started + duration) - Date.now();
            }
            if (remaining < 0) {
              remaining = duration;
            }
            setTimer(setTimeout(() => {
              onTrigger();
            }, remaining));
          }
        }, [setTimer, setElapsed, paused, started]);
        return (React.createElement("svg", { className: className, viewBox: `0 0 ${width} ${width}`, style: { strokeWidth: stroke } },
                                    React.createElement("circle", { className: 'timer-background', fill: 'none', cx: center, cy: center, r: radius }),
                                    React.createElement("circle", { className: 'timer-circle', style: {
                                      animationDuration: duration.toString() + 'ms',
                                      animationDirection: 'reverse',
                                      animationIterationCount: 'infinite',
                                      animationTimingFunction: 'linear',
                                      animationPlayState: paused ? 'paused' : 'running',
                                      transform: 'rotate(-90deg)',
                                      transformOrigin: 'center',
                                      display: active ? undefined : 'none',
                                    }, strokeDasharray: `${circumference},${circumference}`, strokeLinecap: 'round', fill: 'none', cx: center, cy: center, r: radius })));
      }
      exports["default"] = Timer;


/***/ }),

/***/ "./src/views/CollectionPageView/index.tsx":
/*!************************************************!*\
  !*** ./src/views/CollectionPageView/index.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
      const findModByRef_1 = __webpack_require__(/*! ../../util/findModByRef */ "./src/util/findModByRef.ts");
      const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
      const CollectionInstructions_1 = __webpack_require__(/*! ./CollectionInstructions */ "./src/views/CollectionPageView/CollectionInstructions.tsx");
      const CollectionItemStatus_1 = __webpack_require__(/*! ./CollectionItemStatus */ "./src/views/CollectionPageView/CollectionItemStatus.tsx");
      const CollectionOverview_1 = __webpack_require__(/*! ./CollectionOverview */ "./src/views/CollectionPageView/CollectionOverview.tsx");
      const CollectionOverviewSelection_1 = __webpack_require__(/*! ./CollectionOverviewSelection */ "./src/views/CollectionPageView/CollectionOverviewSelection.tsx");
      const CollectionProgress_1 = __webpack_require__(/*! ./CollectionProgress */ "./src/views/CollectionPageView/CollectionProgress.tsx");
      const Promise = __webpack_require__(/*! bluebird */ "bluebird");
      const _ = __webpack_require__(/*! lodash */ "lodash");
      const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const ReactDOM = __webpack_require__(/*! react-dom */ "react-dom");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const semver = __webpack_require__(/*! semver */ "semver");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const getCollator = (() => {
        let collator;
        let language;
        return (locale) => {
          if ((collator === undefined) || (locale !== language)) {
            language = locale;
            collator = new Intl.Collator(locale, { sensitivity: 'base' });
          }
          return collator;
        };
      })();
      const STATUS_ORDER = ['Installing', 'Downloading',
        'Install Pending', 'Download Pending',
        'Enabled', 'Disabled', 'Recommended', 'Ignored'];
      function arr(input) {
        return Array.isArray(input) ? input : [input];
      }
      function matchRepo(mod, ref) {
        let _a, _b, _c, _d, _e, _f, _g, _h;
        if (ref === null) {
          return false;
        }
        const modId = ((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.modId) || ((_d = (_c = (_b = mod.collectionRule) === null || _b === void 0 ? void 0 : _b.reference) === null || _c === void 0 ? void 0 : _c.repo) === null || _d === void 0 ? void 0 : _d.modId);
        const fileId = ((_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.fileId) || ((_h = (_g = (_f = mod.collectionRule) === null || _f === void 0 ? void 0 : _f.reference) === null || _g === void 0 ? void 0 : _g.repo) === null || _h === void 0 ? void 0 : _h.fileId);
        if ((modId === undefined) || (fileId === undefined)
        || (ref.modId === undefined) || (ref.fileId === undefined)) {
          return false;
        }
        return modId.toString() === ref.modId.toString()
        && fileId.toString() === ref.fileId.toString();
      }
      class CollectionPage extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.mInstalling = false;
          this.revisionMerged = (0, memoize_one_1.default)((collection, revision) => ({
            ...revision,
            collection,
          }));
          this.selectTab = (tab) => {
            this.context.api.events.emit('analytics-track-navigation', `collections/view/collection/${tab}`);
            this.nextState.currentTab = tab;
          };
          this.extractAndRemoveComparators = (versionString) => {
            const comparatorPattern = /[\~\^><=]+/;
            const match = versionString.match(comparatorPattern);
            const comparator = match ? match[0] : null;
            const cleanedVersion = versionString.replace(comparatorPattern, '').trim();
            return { version: cleanedVersion, comparator: comparator };
          };
          this.pause = () => {
            this.props.onPause(this.props.collection.id);
          };
          this.cancel = () => {
            this.props.onCancel(this.props.collection.id);
          };
          this.resume = () => {
            this.props.onResume(this.props.collection.id);
          };
          this.setEnabled = (enable) => {
            const { collection, profile } = this.props;
            vortex_api_1.actions.setModsEnabled(this.context.api, profile.id, [collection.id], enable);
          };
          this.showMods = () => {
            const { collection } = this.props;
            const { api } = this.context;
            const batch = [];
            batch.push(vortex_api_1.actions.setAttributeFilter('mods', undefined, undefined));
            batch.push(vortex_api_1.actions.setAttributeFilter('mods', 'dependencies', ['depends', collection.id, vortex_api_1.util.renderModName(collection)]));
            batch.push(vortex_api_1.actions.setAttributeSort('mods', 'dependencies', 'asc'));
            vortex_api_1.util.batchDispatch(api.store, batch);
            api.events.emit('show-main-page', 'Mods');
          };
          this.close = () => {
            this.props.onView(undefined);
          };
          this.unselectMods = () => {
            this.nextState.modSelection = [];
          };
          this.clone = (collectionId) => {
            const { modsEx } = this.state;
            const incomplete = Object.values(modsEx)
              .filter(mod => (mod.state !== 'installed'));
            if (incomplete.length > 0) {
              return this.context.api.showDialog('info', 'Cloning incomplete', {
                text: 'The collection you\'re trying to clone is incomplete. Vortex can '
                        + 'not include a mod in a collection that isn\'t installed so if you continue, '
                        + 'the clone will not include these missing mods..',
                message: incomplete.map(mod => vortex_api_1.util.renderModName(mod)).join('\n'),
              }, [
                { label: 'Cancel' },
                { label: 'Clone anyway', action: () => { this.props.onClone(collectionId); } },
              ]);
            }
            else {
              this.props.onClone(collectionId);
            }
          };
          this.remove = (collectionId) => {
            this.props.onCancel(collectionId);
          };
          this.changeModSelection = (modIds) => {
            const { revisionInfo } = this.props;
            const { modsEx } = this.state;
            this.nextState.modSelection = modIds.map(modId => {
              let _a, _b;
              const mod = modsEx[modId];
              return {
                local: mod,
                remote: (_b = (_a = revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.modFiles) === null || _a === void 0 ? void 0 : _a.find) === null || _b === void 0 ? void 0 : _b.call(_a, file => matchRepo(mod, file.file)),
              };
            });
          };
          this.setTableContainerRef = (ref) => {
            this.mTableContainerRef = (ref !== null)
              ? ReactDOM.findDOMNode(ref)
              : null;
          };
          this.toggleInstructions = (evt) => {
            let _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const modId = evt.currentTarget.getAttribute('data-modid');
            const { mods, onShowError, overlays } = this.props;
            const instructions = this.getModInstructions(modId);
            if (instructions === undefined) {
              const err = new vortex_api_1.util.ProcessCanceled('No instructions found', modId);
              err['attachLogOnReport'] = true;
              err['Collection'] = (_b = (_a = this.props.collection) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.collectionSlug;
              err['Revision'] = (_d = (_c = this.props.collection) === null || _c === void 0 ? void 0 : _c.attributes) === null || _d === void 0 ? void 0 : _d.revisionNumber;
              onShowError('Failed to display instructions', err, true);
              return;
            }
            const mod = mods[modId];
            const modName = vortex_api_1.util.renderModName(mod);
            if (((_e = overlays[modId]) === null || _e === void 0 ? void 0 : _e.content) !== undefined) {
              (_g = (_f = this.context.api.ext).dismissOverlay) === null || _g === void 0 ? void 0 : _g.call(_f, modId);
            }
            else {
              (_j = (_h = this.context.api.ext).showOverlay) === null || _j === void 0 ? void 0 : _j.call(_h, modId, modName, instructions, {
                x: evt.pageX, y: evt.pageY
              });
            }
          };
          this.getModInstructions = (modId) => {
            let _a, _b;
            const { collection, mods } = this.props;
            const mod = mods[modId];
            const modRule = (_a = collection.rules) === null || _a === void 0 ? void 0 : _a.find(rule => vortex_api_1.util.testModReference(mod, rule.reference));
            return (_b = modRule === null || modRule === void 0 ? void 0 : modRule['extra']) === null || _b === void 0 ? void 0 : _b['instructions'];
          };
          this.modAtLeastDownloaded = (instanceIds) => {
            const instanceId = Array.isArray(instanceIds) ? instanceIds[0] : instanceIds;
            const mod = this.state.modsEx[instanceId];
            return mod.state !== null;
          };
          this.ignoreSelected = (modIds) => {
            const { collection, profile } = this.props;
            const { modsEx } = this.state;
            vortex_api_1.util.batchDispatch(this.context.api.store, modIds.reduce((prev, modId) => {
              prev.push(vortex_api_1.actions.addModRule(profile.gameId, collection.id, {
                ...modsEx[modId].collectionRule,
                ignored: true,
              }));
              return prev;
            }, []));
          };
          this.unignoreSelected = (modIds) => {
            const { collection, profile } = this.props;
            const { modsEx } = this.state;
            vortex_api_1.util.batchDispatch(this.context.api.store, modIds.reduce((prev, modId) => {
              prev.push(vortex_api_1.actions.addModRule(profile.gameId, collection.id, {
                ...modsEx[modId].collectionRule,
                ignored: false,
              }));
              return prev;
            }, []));
          };
          this.installManually = (modIds) => {
            const { collection } = this.props;
            const { modsEx } = this.state;
            const rules = modIds.map(modId => modsEx[modId].collectionRule);
            this.props.onInstallManually(collection.id, rules);
          };
          this.removeSelected = (modIds) => {
            let _a;
            const { t, collection, profile, onRemoveRule } = this.props;
            const { modsEx } = this.state;
            const filteredIds = modIds
              .filter(modId => modsEx[modId] !== undefined)
              .filter(modId => ['downloaded', 'installed', null].indexOf(modsEx[modId].state) !== -1);
            if (filteredIds.length === 0) {
              return;
            }
            const modNames = filteredIds
              .map(modId => (modsEx[modId].state !== null)
                ? vortex_api_1.util.renderModName(modsEx[modId], { version: true })
                : vortex_api_1.util.renderModReference(modsEx[modId].collectionRule.reference, undefined));
            const checkboxes = [
              { id: 'mod', text: t('Remove Mod'), value: true },
              { id: 'archive', text: t('Delete Archive'), value: false },
            ];
            if (((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.editable) === true) {
              checkboxes.push({ id: 'collection', text: t('Remove from Collection'), value: false });
            }
            this.context.api.showDialog('question', 'Confirm removal', {
              text: t('Do you really want to remove this mod?', {
                count: filteredIds.length,
                replace: { count: filteredIds.length },
              }),
              message: modNames.join('\n'),
              checkboxes,
            }, [{ label: 'Cancel' }, { label: 'Remove' }])
              .then((result) => {
                const removeMods = result.action === 'Remove' && result.input.mod;
                const removeArchive = result.action === 'Remove' && result.input.archive;
                const removeRule = result.action === 'Remove' && result.input.collection;
                const wereInstalled = filteredIds
                  .filter(key => (modsEx[key] !== undefined) && (modsEx[key].state === 'installed'))
                  .map(key => modsEx[key].id);
                const archiveIds = filteredIds
                  .filter(key => (modsEx[key] !== undefined)
                    && (['downloaded', 'installed'].includes(modsEx[key].state))
                    && (modsEx[key].archiveId !== undefined))
                  .map(key => modsEx[key].archiveId);
                const rulesToRemove = filteredIds.filter(key => modsEx[key] !== undefined);
                return (removeMods
                  ? vortex_api_1.util.removeMods(this.context.api, profile.gameId, wereInstalled)
                  : Promise.resolve())
                  .then(() => {
                    if (removeArchive) {
                      archiveIds.forEach(archiveId => {
                        this.context.api.events.emit('remove-download', archiveId);
                      });
                    }
                    return Promise.resolve();
                  })
                  .then(() => {
                    if (removeRule) {
                      rulesToRemove.forEach(key => {
                        onRemoveRule(profile.gameId, collection.id, modsEx[key].collectionRule);
                      });
                    }
                  });
              })
              .catch(vortex_api_1.util.ProcessCanceled, err => {
                this.context.api.sendNotification({
                  id: 'cant-remove-mod',
                  type: 'warning',
                  title: 'Failed to remove mods',
                  message: err.message,
                });
              })
              .catch(vortex_api_1.util.UserCanceled, () => null)
              .catch(err => {
                this.context.api.showErrorNotification('Failed to remove selected mods', err);
              });
          };
          this.showInMods = (modIds) => {
            const { modsEx } = this.state;
            this.showMods();
            const modId = modsEx[modIds[0]].id;
            setTimeout(() => {
              this.context.api.events.emit('mods-scroll-to', modId);
              this.context.api.highlightControl('.' + vortex_api_1.util.sanitizeCSSId(modId), 5000);
            }, 2000);
          };
          this.initState({
            modsEx: {},
            modSelection: [],
            currentTab: 'instructions',
          });
          this.mModActions = [
            {
              icon: 'install',
              title: 'Install',
              action: this.installManually,
              condition: instanceIds => {
                const instanceId = Array.isArray(instanceIds) ? instanceIds[0] : instanceIds;
                const mod = this.state.modsEx[instanceId];
                return [null, 'downloaded'].includes(mod.state);
              },
            },
            {
              icon: 'delete',
              title: 'Remove',
              action: this.removeSelected,
              condition: instanceId => (typeof (instanceId) === 'string')
                ? (['downloaded', 'installed'].includes(this.state.modsEx[instanceId].state))
                : true,
              hotKey: { code: 46 },
            },
            {
              icon: 'show',
              title: 'Show in Mods',
              action: this.showInMods,
              condition: instanceId => this.modAtLeastDownloaded(instanceId),
              singleRowAction: true,
              multiRowAction: false,
            },
            {
              icon: 'toggle-disabled',
              title: 'Ignore',
              action: this.ignoreSelected,
              condition: instanceIds => arr(instanceIds).find(id => this.state.modsEx[id].collectionRule['ignored'] !== true) !== undefined,
            },
            {
              icon: 'toggle-enabled',
              title: 'Stop Ignoring',
              action: this.unignoreSelected,
              condition: instanceIds => arr(instanceIds).find(id => this.state.modsEx[id].collectionRule['ignored'] === true) !== undefined,
            },
          ];
          this.mAttributes = [
            {
              id: 'collection_status',
              name: 'Status',
              description: 'Is mod enabled in current profile',
              icon: 'check-o',
              customRenderer: (mod) => {
                const download = (mod.archiveId !== undefined)
                  ? this.props.downloads[mod.archiveId]
                  : undefined;
                return (React.createElement(CollectionItemStatus_1.default, { t: this.props.t, mod: mod, download: download, notifications: this.props.notifications, container: this.mTableContainerRef, installing: this.mInstalling }));
              },
              calc: (mod) => {
                if (mod.collectionRule['ignored']) {
                  return ['Ignored'];
                }
                else if (mod.state === 'installing') {
                  return ['Installing', Math.floor(mod.progress * 100.0) / 100.0];
                }
                else if (mod.state === 'downloading') {
                  return ['Downloading', Math.floor(mod.progress * 100.0) / 100.0];
                }
                else if (mod.state === null) {
                  if (mod.collectionRule.type === 'recommends') {
                    return ['Recommended'];
                  }
                  else {
                    return ['Download Pending', 'Pending'];
                  }
                }
                else if (mod.state === 'downloaded') {
                  if (mod.collectionRule.type === 'recommends') {
                    return ['Recommended'];
                  }
                  else {
                    return ['Install Pending', 'Pending'];
                  }
                }
                return [mod.enabled === true ? 'Enabled' : 'Disabled'];
              },
              placement: 'table',
              isToggleable: false,
              edit: {},
              isSortable: true,
              sortFunc: (lhs, rhs) => {
                return STATUS_ORDER.indexOf(lhs[0]) - STATUS_ORDER.indexOf(rhs[0]);
              },
              filter: new vortex_api_1.OptionsFilter([
                { value: 'Enabled', label: 'Enabled' },
                { value: 'Disabled', label: 'Disabled' },
                { value: 'Installing', label: 'Installing' },
                { value: 'Downloading', label: 'Downloading' },
                { value: 'Pending', label: 'Pending' },
                { value: 'Recommended', label: 'Not installed' },
                { value: 'Ignored', label: 'Ignored' },
              ], true, false),
            },
            {
              id: 'required',
              name: 'Required',
              description: 'Is the mod required for this collection',
              placement: 'table',
              calc: (mod) => mod.collectionRule.type === 'requires',
              edit: {},
              filter: new vortex_api_1.OptionsFilter([
                { value: false, label: 'Recommended' },
                { value: true, label: 'Required' },
              ], false, false),
            },
            {
              id: 'name',
              name: 'Name',
              calc: mod => (mod.state !== null)
                ? vortex_api_1.util.renderModReference(mod.collectionRule.reference, mod, { version: false })
                : vortex_api_1.util.renderModReference(mod.collectionRule.reference, undefined, { version: false }),
              placement: 'table',
              edit: {},
              isToggleable: false,
              isDefaultSort: true,
              isSortable: true,
              filter: new vortex_api_1.TableTextFilter(true),
              sortFunc: (lhs, rhs, locale) => getCollator(locale).compare(lhs, rhs),
            },
            {
              id: 'version',
              name: 'Version',
              calc: mod => {
                let _a, _b;
                const prefer = '+prefer';
                let verString = (_b = ((mod.state !== null)
                  ? (_a = mod.attributes.version) !== null && _a !== void 0 ? _a : mod.collectionRule.reference.versionMatch
                  : mod.collectionRule.reference.versionMatch)) !== null && _b !== void 0 ? _b : '0.0.0';
                if (verString.endsWith(prefer)) {
                  let sv;
                  try {
                    sv = semver.minVersion(verString);
                  }
                  catch (e) {
                    const { version, comparator } = this.extractAndRemoveComparators(verString);
                    const coerced = vortex_api_1.util.coerceToSemver(version.slice(0, -(prefer.length)));
                    const range = (comparator !== null && comparator !== void 0 ? comparator : '') + coerced + prefer;
                    try {
                      sv = semver.minVersion(range);
                    }
                    catch (e2) {
                      sv = { version: coerced };
                    }
                  }
                  verString = sv.version;
                }
                return verString;
              },
              placement: 'table',
              edit: {},
            },
            {
              id: 'uploader',
              name: 'Uploader',
              customRenderer: (mod) => {
                let _a, _b, _c, _d, _e, _f, _g, _h, _j;
                const { t } = this.props;
                let name;
                let avatar;
                if (this.props.revisionInfo !== undefined) {
                  const revMods = ((_a = this.props.revisionInfo) === null || _a === void 0 ? void 0 : _a.modFiles) || [];
                  const revMod = revMods.find(iter => matchRepo(mod, iter.file));
                  name = ((_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.uploader) || ((_d = (_c = revMod === null || revMod === void 0 ? void 0 : revMod.file) === null || _c === void 0 ? void 0 : _c.owner) === null || _d === void 0 ? void 0 : _d.name);
                  avatar = ((_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.uploaderAvatar)
                            || ((_g = (_f = revMod === null || revMod === void 0 ? void 0 : revMod.file) === null || _f === void 0 ? void 0 : _f.owner) === null || _g === void 0 ? void 0 : _g.avatar);
                }
                else if (mod.attributes !== undefined) {
                  name = (_h = mod.attributes) === null || _h === void 0 ? void 0 : _h.uploader;
                  avatar = (_j = mod.attributes) === null || _j === void 0 ? void 0 : _j.uploaderAvatar;
                }
                return (React.createElement("div", null,
                                            React.createElement(react_bootstrap_1.Image, { circle: true, src: avatar || constants_1.AVATAR_FALLBACK }),
                                            name || t(constants_1.AUTHOR_UNKNOWN)));
              },
              calc: mod => { let _a; return ((_a = mod === null || mod === void 0 ? void 0 : mod.attributes) === null || _a === void 0 ? void 0 : _a.author) || this.props.t(constants_1.AUTHOR_UNKNOWN); },
              placement: 'table',
              edit: {},
              isToggleable: false,
              isSortable: true,
            },
            {
              id: 'instructions',
              name: 'Instructions',
              customRenderer: (mod) => {
                const instructions = this.getModInstructions(mod.id);
                if (instructions === undefined) {
                  return null;
                }
                return (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'details', tooltip: instructions, "data-modid": mod.id, onClick: this.toggleInstructions }));
              },
              calc: mod => {
                return this.getModInstructions(mod.id);
              },
              placement: 'table',
              edit: {},
            },
          ];
          props.onAddCallback('viewCollectionTab', (tab) => {
            if (['instructions', 'mods'].includes(tab)) {
              this.nextState.currentTab = tab;
            }
          });
        }
        async componentDidMount() {
          const { collection, userInfo } = this.props;
          const { attributes } = collection !== null && collection !== void 0 ? collection : {};
          const { revisionId, collectionSlug, revisionNumber } = attributes !== null && attributes !== void 0 ? attributes : {};
          if (((revisionId !== undefined) || (collectionSlug !== undefined))
            && (userInfo !== undefined)) {
            const { infoCache } = this.props.driver;
            try {
              await infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber);
            }
            catch (err) {
              (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                revisionId, collectionSlug, revisionNumber,
                error: err.message,
              });
            }
          }
          const modsEx = this.initModsEx(this.props);
          this.nextState.modsEx = modsEx;
        }
        async UNSAFE_componentWillReceiveProps(newProps) {
          if ((this.props.mods !== newProps.mods)
            || (this.props.profile !== newProps.profile)
            || (this.props.collection !== newProps.collection)
            || (this.props.downloads !== newProps.downloads)
            || this.installingNotificationsChanged(this.props, newProps)) {
            this.nextState.modsEx = this.updateModsEx(this.props, newProps);
            const { collection } = this.props;
            const { attributes } = collection;
            const { revisionId, collectionSlug, revisionNumber } = attributes !== null && attributes !== void 0 ? attributes : {};
            if ((revisionId !== undefined) || (collectionSlug !== undefined)) {
              try {
                await this.props.driver.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber);
              }
              catch (err) {
                (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                  revisionId, collectionSlug, revisionNumber,
                  error: err.message,
                });
              }
            }
          }
        }
        shouldComponentUpdate(newProps, newState) {
          if ((this.props.mods !== newProps.mods)
            || (this.props.profile !== newProps.profile)
            || (this.props.downloads !== newProps.downloads)
            || (this.props.collection !== newProps.collection)
            || this.installingNotificationsChanged(this.props, newProps)
            || (this.props.activity.mods !== newProps.activity.mods)
            || (this.props.revisionInfo !== newProps.revisionInfo)
            || (this.props.showUpvoteResponse !== newProps.showUpvoteResponse)
            || (this.props.showDownvoteResponse !== newProps.showDownvoteResponse)
            || (this.state.currentTab !== newState.currentTab)
            || (this.state.modSelection !== newState.modSelection)
            || (this.state.modsEx !== newState.modsEx)) {
            return true;
          }
          return false;
        }
        render() {
          let _a, _b, _c, _d;
          const { t, activity, className, collection, collectionInfo, driver, downloads, language, mods, onSuppressVoteResponse, onVoteSuccess, profile, revisionInfo, showUpvoteResponse, showDownvoteResponse, userInfo, votedSuccess } = this.props;
          const { currentTab, modSelection, modsEx } = this.state;
          if (collection === undefined) {
            return null;
          }
          const incomplete = Object.values(modsEx)
            .find(mod => (mod.state !== 'installed')
            && !mod.collectionRule['ignored']
            && (mod.collectionRule.type === 'requires')) !== undefined;
          const totalSize = Object.values(modsEx).reduce((prev, mod) => {
            const size = vortex_api_1.util.getSafe(mod, ['attributes', 'fileSize'], 0);
            return prev + size;
          }, 0);
          if (collection !== undefined) {
            this.mInstalling = incomplete
                && !driver.installDone
                && (((_a = driver.collection) === null || _a === void 0 ? void 0 : _a.id) === (collection === null || collection === void 0 ? void 0 : collection.id));
          }
          else {
            this.mInstalling = undefined;
          }
          const selection = (_d = ((this.mInstalling && (driver.collectionInfo !== undefined))
            ? (_c = (_b = revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.modFiles) === null || _b === void 0 ? void 0 : _b.map) === null || _c === void 0 ? void 0 : _c.call(_b, file => ({ local: undefined, remote: file }))
            : modSelection)) !== null && _d !== void 0 ? _d : [];
          return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', className: className },
                                      React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-overview-panel' }, (selection.length > 0)
                                        ? (React.createElement(CollectionOverviewSelection_1.default, { t: t, profile: profile, collection: collection, onDeselectMods: this.unselectMods, incomplete: incomplete, modSelection: selection }))
                                        : (React.createElement(CollectionOverview_1.default, { t: t, language: language, profile: profile, collection: collection, totalSize: totalSize, showUpvoteResponse: showUpvoteResponse, showDownvoteResponse: showDownvoteResponse, revision: this.revisionMerged(collectionInfo, revisionInfo), votedSuccess: votedSuccess, onSetEnabled: this.setEnabled, onShowMods: this.showMods, onClose: this.close, onClone: this.clone, onRemove: this.remove, onVoteSuccess: onVoteSuccess, onSuppressVoteResponse: onSuppressVoteResponse, incomplete: incomplete }))),
                                      React.createElement(vortex_api_1.FlexLayout.Flex, { className: 'collection-mods-panel' },
                                                          React.createElement(react_bootstrap_1.Tabs, { id: 'collection-view-tabs', activeKey: currentTab, onSelect: this.selectTab, unmountOnExit: true, mountOnEnter: true },
                                                                              React.createElement(react_bootstrap_1.Tab, { key: 'instructions', eventKey: 'instructions', title: t('Instructions') },
                                                                                                  React.createElement(react_bootstrap_1.Panel, null,
                                                                                                                      React.createElement(react_bootstrap_1.Panel.Body, null,
                                                                                                                                          React.createElement(CollectionInstructions_1.default, { t: t, collection: collection, mods: mods, onToggleInstructions: this.toggleInstructions })))),
                                                                              React.createElement(react_bootstrap_1.Tab, { key: 'mods', eventKey: 'mods', title: t('Mods') },
                                                                                                  React.createElement(react_bootstrap_1.Panel, { ref: this.setTableContainerRef },
                                                                                                                      React.createElement(react_bootstrap_1.Panel.Body, null,
                                                                                                                                          React.createElement(vortex_api_1.Table, { tableId: 'collection-mods', showDetails: false, data: modsEx, staticElements: this.mAttributes, actions: this.mModActions, onChangeSelection: this.changeModSelection })))))),
                                      React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                                          React.createElement(CollectionProgress_1.default, { t: t, isPremium: userInfo === null || userInfo === void 0 ? void 0 : userInfo.isPremium, mods: modsEx, profile: profile, downloads: downloads, totalSize: totalSize, activity: activity, onCancel: this.cancel, onPause: this.mInstalling ? this.pause : undefined, onResume: this.mInstalling
                                                            ? undefined
                                                            : (driver.collection !== undefined) && !driver.installDone
                                                              ? null
                                                              : this.resume }))));
        }
        progress(props, mod) {
          let _a;
          const { downloads, notifications } = props;
          if (mod.state === 'downloading') {
            const { received, size } = downloads[mod.archiveId];
            if (!!size) {
              return received / size;
            }
          }
          else if (mod.state === 'installing') {
            const notification = notifications.find(noti => noti.id === 'install_' + mod.id);
            if (notification !== undefined) {
              return ((_a = notification.progress) !== null && _a !== void 0 ? _a : 100) / 100;
            }
            else {
              return 1;
            }
          }
          return 0;
        }
        installingNotificationsChanged(oldProps, newProps) {
          if (oldProps.notifications !== newProps.notifications) {
            const oldInstalling = oldProps.notifications
              .filter(noti => noti.id.startsWith(constants_1.INSTALLING_NOTIFICATION_ID));
            const newInstalling = newProps.notifications
              .filter(noti => noti.id.startsWith(constants_1.INSTALLING_NOTIFICATION_ID));
            return !_.isEqual(oldInstalling, newInstalling);
          }
          else {
            return false;
          }
        }
        updateModsEx(oldProps, newProps) {
          let _a, _b;
          const result = { ...this.state.modsEx };
          const modifiedDownloads = vortex_api_1.util.objDiff(oldProps.downloads, newProps.downloads);
          const modifiedMods = vortex_api_1.util.objDiff(oldProps.mods, newProps.mods);
          const modifiedState = vortex_api_1.util.objDiff((_a = oldProps.profile.modState) !== null && _a !== void 0 ? _a : {}, (_b = newProps.profile.modState) !== null && _b !== void 0 ? _b : {});
          const genRuleMap = (rules) => {
            return (rules || []).reduce((prev, rule) => {
              prev[(0, util_1.modRuleId)(rule)] = rule;
              return prev;
            }, {});
          };
          const modifiedRules = vortex_api_1.util.objDiff(genRuleMap(oldProps.collection.rules), genRuleMap(newProps.collection.rules));
          Object.keys(modifiedDownloads)
            .filter(dlId => dlId.startsWith('-'))
            .forEach(dlId => {
              const refId = Object.keys(result).find(iter => { let _a; return ((_a = result[iter]) === null || _a === void 0 ? void 0 : _a.archiveId) === dlId.slice(1); });
              delete result[refId];
            });
          const invalidateMod = modId => {
            const realId = modId.slice(1);
            const refId = Object.keys(result).find(iter => { let _a; return ((_a = result[iter]) === null || _a === void 0 ? void 0 : _a.id) === realId; });
            delete result[refId];
          };
          Object.keys(modifiedMods)
            .filter(modId => modId.startsWith('-'))
            .forEach(invalidateMod);
          Object.keys(modifiedState)
            .filter(modId => {
              let _a;
              return modId.startsWith('-')
                || ((_a = modifiedState[modId]) === null || _a === void 0 ? void 0 : _a['-enabled']) !== undefined;
            })
            .forEach(invalidateMod);
          const { collection } = newProps;
          (collection.rules || [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type))
            .forEach(rule => {
              const id = (0, util_1.modRuleId)(rule);
              if ((result[id] === undefined) || (modifiedRules[id] !== undefined)) {
                result[id] = this.modFromRule(newProps, rule);
              }
            });
          Object.keys(modifiedRules)
            .forEach(ruleId => {
              if (ruleId.startsWith('-')) {
                delete result[ruleId.slice(1)];
              }
              else if (ruleId.startsWith('+')) {
                result[ruleId.slice(1)] = this.modFromRule(newProps, modifiedRules[ruleId]);
              }
            });
          const { profile } = newProps;
          const { modsEx } = this.state;
          const pendingDL = Object.keys(modsEx).filter(modId => { let _a; return ((_a = modsEx[modId]) === null || _a === void 0 ? void 0 : _a.state) === null; });
          const pendingInstall = Object.keys(modsEx)
            .filter(modId => { let _a; return ['downloading', 'downloaded', null].includes((_a = modsEx[modId]) === null || _a === void 0 ? void 0 : _a.state); });
          const pendingFinish = Object.keys(modsEx)
            .filter(modId => { let _a; return ['installing', 'installed'].includes((_a = modsEx[modId]) === null || _a === void 0 ? void 0 : _a.state); });
          Object.keys(modifiedDownloads)
            .filter(dlId => dlId.startsWith('+'))
            .forEach(dlId => {
              const download = newProps.downloads[dlId.slice(1)];
              const match = pendingDL.find(modId => (0, findModByRef_1.testDownloadReference)(download, modsEx[modId].collectionRule.reference));
              if (match !== undefined) {
                result[match] = this.modFromDownload(dlId.slice(1), download, modsEx[match].collectionRule);
              }
            });
          const updateMod = modId => {
            const realId = modId.startsWith('+') ? modId.slice(1) : modId;
            const mod = newProps.mods[realId];
            if (mod === undefined) {
              return;
            }
            if (mod.state === 'installing') {
              const dlId = mod.archiveId;
              const download = newProps.downloads[dlId];
              const match = pendingInstall.find(iter => (0, findModByRef_1.testDownloadReference)(download, modsEx[iter].collectionRule.reference));
              if (match !== undefined) {
                result[match] = {
                  ...this.modFromDownload(dlId, download, modsEx[match].collectionRule),
                  id: modId.slice(1),
                  state: 'installing',
                };
              }
            }
            else {
              const match = pendingFinish.find(iter => vortex_api_1.util.testModReference(mod, modsEx[iter].collectionRule.reference));
              if (match !== undefined) {
                result[match] = {
                  ...mod,
                  ...(profile.modState || {})[mod.id],
                  collectionRule: modsEx[match].collectionRule,
                };
              }
            }
          };
          Object.keys(modifiedMods)
            .filter(modId => !modId.startsWith('-')
            && (modId.startsWith('+')
                || (modifiedMods[modId]['+state'] !== undefined)
                || (modifiedMods[modId]['attributes'] !== undefined)))
            .forEach(updateMod);
          Object.keys(modifiedState)
            .filter(modId => { let _a; return ((_a = modifiedState[modId]) === null || _a === void 0 ? void 0 : _a['+enabled']) !== undefined; })
            .forEach(updateMod);
          Object.keys(modifiedDownloads)
            .filter(dlId => !dlId.startsWith('-') && !dlId.startsWith('+'))
            .forEach(dlId => {
              let _a, _b, _c;
              let ruleId = Object.keys(result).find(modId => { let _a; return ((_a = result[modId]) === null || _a === void 0 ? void 0 : _a.archiveId) === dlId; });
              if ((ruleId === undefined)
                && (((_b = (_a = newProps.downloads[dlId]) === null || _a === void 0 ? void 0 : _a.modInfo) === null || _b === void 0 ? void 0 : _b.referenceTag) !== undefined)) {
                ruleId = Object.keys(result).find(id => {
                  let _a, _b;
                  return (((_a = result[id]) === null || _a === void 0 ? void 0 : _a.archiveId) === undefined)
                        && (0, findModByRef_1.testDownloadReference)(newProps.downloads[dlId], (_b = result[id]) === null || _b === void 0 ? void 0 : _b.collectionRule.reference);
                });
                if (ruleId !== undefined) {
                  result[ruleId] = {
                    ...result[ruleId],
                    archiveId: dlId,
                    state: 'downloading',
                  };
                }
              }
              if (ruleId !== undefined) {
                result[ruleId] = {
                  ...result[ruleId],
                  progress: this.progress(newProps, result[ruleId]),
                };
                const dl = newProps.downloads[(_c = result[ruleId]) === null || _c === void 0 ? void 0 : _c.archiveId];
                if (['finished', 'failed'].includes(dl.state) && !pendingFinish.includes(ruleId)) {
                  result[ruleId].state = 'downloaded';
                }
              }
            });
          newProps.notifications.forEach(noti => {
            if ((noti.id !== undefined) && (noti.id.startsWith('install_'))) {
              const modId = noti.id.slice(8);
              const ruleId = Object.keys(result).find(iter => { let _a; return ((_a = result[iter]) === null || _a === void 0 ? void 0 : _a.id) === modId; });
              if (ruleId !== undefined) {
                result[ruleId] = {
                  ...result[ruleId],
                  progress: this.progress(newProps, result[ruleId]),
                };
              }
            }
          });
          return result;
        }
        modFromDownload(dlId, download, rule) {
          let _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6;
          const modId = (_d = (_c = (_b = (_a = download.modInfo) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.details) === null || _c === void 0 ? void 0 : _c.modId) !== null && _d !== void 0 ? _d : (_g = (_f = (_e = download.modInfo) === null || _e === void 0 ? void 0 : _e.nexus) === null || _f === void 0 ? void 0 : _f.ids) === null || _g === void 0 ? void 0 : _g.modId;
          return {
            id: dlId,
            type: '',
            installationPath: undefined,
            archiveId: dlId,
            enabledTime: 0,
            state: download.state === 'finished' ? 'downloaded' : 'downloading',
            enabled: false,
            collectionRule: rule,
            attributes: {
              customFileName: (_h = download === null || download === void 0 ? void 0 : download.modInfo) === null || _h === void 0 ? void 0 : _h.name,
              fileName: (_m = (_l = (_k = (_j = download.modInfo) === null || _j === void 0 ? void 0 : _j.nexus) === null || _k === void 0 ? void 0 : _k.fileInfo) === null || _l === void 0 ? void 0 : _l.name) !== null && _m !== void 0 ? _m : vortex_api_1.util.renderModReference(rule.reference),
              fileSize: (_o = download.size) !== null && _o !== void 0 ? _o : rule.reference.fileSize,
              name: dlId,
              version: (_r = (_q = (_p = download.modInfo) === null || _p === void 0 ? void 0 : _p.nexus) === null || _q === void 0 ? void 0 : _q.fileInfo) === null || _r === void 0 ? void 0 : _r.mod_version,
              author: (_u = (_t = (_s = download.modInfo) === null || _s === void 0 ? void 0 : _s.nexus) === null || _t === void 0 ? void 0 : _t.modInfo) === null || _u === void 0 ? void 0 : _u.author,
              uploader: (_y = (_x = (_w = (_v = download.modInfo) === null || _v === void 0 ? void 0 : _v.nexus) === null || _w === void 0 ? void 0 : _w.modInfo) === null || _x === void 0 ? void 0 : _x.user) === null || _y === void 0 ? void 0 : _y.name,
              uploaderId: (_2 = (_1 = (_0 = (_z = download.modInfo) === null || _z === void 0 ? void 0 : _z.nexus) === null || _0 === void 0 ? void 0 : _0.modInfo) === null || _1 === void 0 ? void 0 : _1.user) === null || _2 === void 0 ? void 0 : _2.id,
              category: (_5 = (_4 = (_3 = download.modInfo) === null || _3 === void 0 ? void 0 : _3.nexus) === null || _4 === void 0 ? void 0 : _4.modInfo) === null || _5 === void 0 ? void 0 : _5.category_id,
              source: ((_6 = download.modInfo) === null || _6 === void 0 ? void 0 : _6.nexus) !== undefined ? 'nexus' : undefined,
              modId,
              downloadGame: Array.isArray(download.game) ? download.game[0] : download.game,
            },
          };
        }
        modFromRule(props, rule) {
          let _a, _b;
          const { downloads, mods, profile } = props;
          const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
          if (mod !== undefined) {
            return {
              ...mods[mod.id],
              ...(_a = profile.modState) === null || _a === void 0 ? void 0 : _a[mod.id],
              collectionRule: rule,
            };
          }
          else {
            const dlId = vortex_api_1.util.findDownloadByRef(rule.reference, downloads);
            if (dlId !== undefined) {
              return this.modFromDownload(dlId, downloads[dlId], rule);
            }
            else {
              const name = vortex_api_1.util.renderModReference(rule.reference, undefined);
              return {
                id: name,
                state: null,
                type: '',
                installationPath: undefined,
                enabledTime: 0,
                attributes: {
                  fileSize: rule.reference.fileSize,
                  ...(rule.extra || {}),
                  fileName: (_b = rule.extra) === null || _b === void 0 ? void 0 : _b.name,
                },
                enabled: false,
                collectionRule: rule,
              };
            }
          }
        }
        initModsEx(props) {
          let _a;
          const { collection } = props;
          return ((_a = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type))
            .reduce((prev, rule) => {
              const id = (0, util_1.modRuleId)(rule);
              prev[id] = this.modFromRule(props, rule);
              return prev;
            }, {});
        }
      }
      function mapStateToProps(state, ownProps) {
        let _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const { nexus } = state.persistent;
        const { collection } = ownProps;
        let votedSuccess;
        let revisionInfo;
        let collectionInfo;
        if (((_a = collection === null || collection === void 0 ? void 0 : collection.attributes) === null || _a === void 0 ? void 0 : _a.revisionId) !== undefined) {
          revisionInfo =
            (_c = (_b = state.persistent.collections.revisions) === null || _b === void 0 ? void 0 : _b[collection.attributes.revisionId]) === null || _c === void 0 ? void 0 : _c.info;
          if ((revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.collection) !== undefined) {
            collectionInfo =
                (_e = (_d = state.persistent.collections.collections) === null || _d === void 0 ? void 0 : _d[revisionInfo.collection.id]) === null || _e === void 0 ? void 0 : _e.info;
          }
          votedSuccess = (_g = (_f = revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.metadata) === null || _f === void 0 ? void 0 : _f.ratingValue) !== null && _g !== void 0 ? _g : 'abstained';
        }
        return {
          userInfo: nexus.userInfo,
          votedSuccess,
          activity: state.session.base.activity,
          language: state.settings.interface.language,
          overlays: state.session.overlays.overlays,
          collectionInfo,
          revisionInfo,
          showUpvoteResponse: (_h = state.settings.interface.usage['collection-upvote-response-dialog']) !== null && _h !== void 0 ? _h : true,
          showDownvoteResponse: (_j = state.settings.interface.usage['collection-downvote-response-dialog']) !== null && _j !== void 0 ? _j : true,
        };
      }
      function mapDispatchToProps(dispatch) {
        return {
          onSetModEnabled: (profileId, modId, enable) => dispatch(vortex_api_1.actions.setModEnabled(profileId, modId, enable)),
          onSetAttributeFilter: (tableId, filterId, filterValue) => dispatch(vortex_api_1.actions.setAttributeFilter(tableId, filterId, filterValue)),
          onRemoveRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.removeModRule(gameId, modId, rule)),
          onShowError: (message, details, allowReport) => vortex_api_1.util.showError(dispatch, message, details, { allowReport }),
          onSuppressVoteResponse: (response) => dispatch(vortex_api_1.actions.showUsageInstruction(`collection-${response}-response-dialog`, false)),
        };
      }
      exports["default"] = (0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(CollectionPage);


/***/ }),

/***/ "./src/views/CollectionReleaseStatus.tsx":
/*!***********************************************!*\
  !*** ./src/views/CollectionReleaseStatus.tsx ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function CollectionReleaseStatus(props) {
        const { t, active, collection, enabled, incomplete } = props;
        if (active) {
          if (incomplete) {
            return React.createElement("div", { className: 'collection-status incomplete' }, t('Incomplete'));
          }
          else if ((vortex_api_1.util.getSafe(collection.attributes, ['collectionId'], undefined) !== undefined)
            && vortex_api_1.util.getSafe(collection.attributes, ['editable'], false)) {
            return React.createElement("div", { className: 'collection-status published' }, t('Published'));
          }
          else if (enabled) {
            return React.createElement("div", { className: 'collection-status enabled' }, t('Enabled'));
          }
          else {
            return React.createElement("div", { className: 'collection-status disabled' }, t('Disabled'));
          }
        }
        else {
          return null;
        }
      }
      exports["default"] = CollectionReleaseStatus;


/***/ }),

/***/ "./src/views/CollectionTile/NewRevisionMarker.tsx":
/*!********************************************************!*\
  !*** ./src/views/CollectionTile/NewRevisionMarker.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function NewRevisionMarker(props) {
        let _a, _b, _c;
        const { t, collection, updating } = props;
        if ((((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a['newestVersion']) === undefined)
        || (parseInt((_b = collection.attributes) === null || _b === void 0 ? void 0 : _b['newestVersion'], 10)
            <= parseInt((_c = collection.attributes) === null || _c === void 0 ? void 0 : _c['version'], 10))) {
          return null;
        }
        return (React.createElement("div", { className: 'collections-new-revision' },
                                    React.createElement(vortex_api_1.Icon, { name: updating ? 'spinner_new' : 'details' }),
                                    t('Update')));
      }
      exports["default"] = NewRevisionMarker;


/***/ }),

/***/ "./src/views/CollectionTile/RemoteTile.tsx":
/*!*************************************************!*\
  !*** ./src/views/CollectionTile/RemoteTile.tsx ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const path = __webpack_require__(/*! path */ "path");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function HoverMenu(props) {
        const { t, added, incomplete, revision, onCloneCollection, onInstallCollection, onResumeCollection, } = props;
        const installOwnCollection = React.useCallback(() => {
          if (added !== undefined) {
            onResumeCollection(added.id);
          }
          else {
            onInstallCollection(revision);
          }
        }, [added, revision, onInstallCollection, onResumeCollection]);
        const cloneOwnCollection = React.useCallback(() => {
          onCloneCollection(added.id);
        }, [onCloneCollection, added]);
        const staticElements = [];
        if ((added !== undefined) && !incomplete) {
          staticElements.push({
            title: 'Edit (Requires clone)',
            icon: 'edit',
            action: () => cloneOwnCollection(),
          });
        }
        else {
          staticElements.push({
            title: 'Install',
            icon: 'install',
            action: () => installOwnCollection(),
          }, {
            title: 'Edit',
            icon: 'edit',
            condition: (instanceId, data) => t('Your collection must be installed first and then cloned to make edits.'),
            action: () => {
            },
          });
        }
        staticElements.push();
        return (React.createElement("div", { className: 'thumbnail-hover-menu' },
                                    React.createElement("div", { key: 'primary-buttons', className: 'hover-content' },
                                                        React.createElement(vortex_api_1.IconBar, { t: t, id: `collection-thumbnail-${revision.collection.slug}`, className: 'buttons', group: 'collection-actions', instanceId: revision.collection.slug, staticElements: staticElements, collapse: false, buttonType: 'both', orientation: 'vertical', clickAnywhere: true }))));
      }
      function RemoteTile(props) {
        let _a;
        const { t, revision, onCloneCollection, onInstallCollection, onResumeCollection } = props;
        const classes = ['collection-thumbnail', 'collection-remote'];
        const images = [];
        if (!!((_a = revision.collection.tileImage) === null || _a === void 0 ? void 0 : _a.url)) {
          images.push(revision.collection.tileImage.url);
        }
        images.push(path.join(__dirname, 'fallback_tile.png'));
        return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' ') },
                                    React.createElement(react_bootstrap_1.Panel.Body, { className: 'collection-thumbnail-body' },
                                                        React.createElement(vortex_api_1.Image, { className: 'thumbnail-img', srcs: images, circle: false }),
                                                        React.createElement("div", { className: 'bottom' },
                                                                            React.createElement("div", { className: 'collection-revision-and-rating' },
                                                                                                React.createElement("div", { className: 'revision-number' }, t('Revision {{number}}', {
                                                                                                  replace: {
                                                                                                    number: revision.revisionNumber,
                                                                                                  }
                                                                                                })),
                                                                                                React.createElement("div", { className: classes.join(' ') },
                                                                                                                    React.createElement(vortex_api_1.Icon, { name: 'health' }),
                                                                                                                    t('{{rating}}%', { replace: { rating: revision.rating.average } }))),
                                                                            React.createElement("div", { className: 'name no-hover' }, revision.collection.name),
                                                                            React.createElement("div", { className: 'details' },
                                                                                                React.createElement("div", { className: 'author' }, t('By {{uploader}}', {
                                                                                                  replace: {
                                                                                                    uploader: revision.collection.user.name,
                                                                                                  },
                                                                                                })),
                                                                                                React.createElement("div", null,
                                                                                                                    React.createElement(vortex_api_1.Icon, { name: 'mods' }),
                                                                                                                    revision.modFiles.length))),
                                                        React.createElement(HoverMenu, { t: t, revision: revision, added: props.added, incomplete: props.incomplete, onInstallCollection: onInstallCollection, onCloneCollection: onCloneCollection, onResumeCollection: onResumeCollection }))));
      }
      exports["default"] = RemoteTile;


/***/ }),

/***/ "./src/views/CollectionTile/SuccessRating.tsx":
/*!****************************************************!*\
  !*** ./src/views/CollectionTile/SuccessRating.tsx ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.SuccessRating = void 0;
      const React = __webpack_require__(/*! react */ "react");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function SuccessRating(props) {
        const { t, collectionSlug, infoCache, revisionNumber, revisionId } = props;
        const [rating, setRating] = React.useState(undefined);
        React.useEffect(() => {
          (async () => {
            let _a, _b;
            try {
              const rev = await infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber);
              if (((_b = (_a = rev === null || rev === void 0 ? void 0 : rev.rating) === null || _a === void 0 ? void 0 : _a.total) !== null && _b !== void 0 ? _b : 0) < 3) {
                setRating(undefined);
              }
              else {
                setRating(rev.rating.average);
              }
            }
            catch (err) {
              (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                revisionId, collectionSlug, revisionNumber,
                error: err.message,
              });
            }
          })();
        }, [revisionId]);
        const classes = [
          'collection-success-indicator',
        ];
        if (rating === undefined) {
          classes.push('success-rating-insufficient');
        }
        else if (rating < 50) {
          classes.push('success-rating-bad');
        }
        else if (rating < 75) {
          classes.push('success-rating-dubious');
        }
        else {
          classes.push('success-rating-good');
        }
        return (React.createElement("div", { className: classes.join(' ') },
                                    React.createElement(vortex_api_1.Icon, { name: 'health' }),
                                    (rating === undefined)
                                      ? t('Awaiting')
                                      : t('{{rating}}%', { replace: { rating } })));
      }
      exports.SuccessRating = SuccessRating;


/***/ }),

/***/ "./src/views/CollectionTile/index.tsx":
/*!********************************************!*\
  !*** ./src/views/CollectionTile/index.tsx ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
      const path = __webpack_require__(/*! path */ "path");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
      const CollectionReleaseStatus_1 = __webpack_require__(/*! ../CollectionReleaseStatus */ "./src/views/CollectionReleaseStatus.tsx");
      const NewRevisionMarker_1 = __webpack_require__(/*! ./NewRevisionMarker */ "./src/views/CollectionTile/NewRevisionMarker.tsx");
      const SuccessRating_1 = __webpack_require__(/*! ./SuccessRating */ "./src/views/CollectionTile/SuccessRating.tsx");
      function ModNameField(props) {
        const { t, name, onChange } = props;
        const [editing, setEditing] = React.useState(false);
        const [tempName, setTempName] = React.useState(name);
        const changeInput = React.useCallback((evt) => {
          setTempName(evt.currentTarget.value.slice(0, constants_1.MAX_COLLECTION_NAME_LENGTH));
        }, [setTempName]);
        const validationState = React.useCallback(() => {
          if ((tempName.length < constants_1.MIN_COLLECTION_NAME_LENGTH)
            || (tempName.length > constants_1.MAX_COLLECTION_NAME_LENGTH)) {
            return 'error';
          }
          else {
            return 'success';
          }
        }, [tempName]);
        const apply = React.useCallback(() => {
          if (validationState() === 'success') {
            onChange(tempName);
            setEditing(false);
          }
        }, [setEditing, tempName]);
        const keyPress = React.useCallback((evt) => {
          if (evt.key === 'Enter') {
            apply();
          }
        }, [apply]);
        const startEdit = React.useCallback(() => {
          setEditing(true);
        }, [setEditing]);
        return (React.createElement("div", { className: `collection-name ${editing ? 'editing' : 'displaying'}` }, editing ? (React.createElement(React.Fragment, null,
                                                                                                                                                  React.createElement(react_bootstrap_1.FormGroup, { controlId: 'formBasicText', validationState: validationState() },
                                                                                                                                                                      React.createElement(react_bootstrap_1.FormControl, { type: 'text', value: tempName, placeholder: t('Collection Name'), onChange: changeInput, autoFocus: true, onKeyPress: keyPress })),
                                                                                                                                                  React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'input-confirm', tooltip: t('Save name'), onClick: apply }))) : (React.createElement(React.Fragment, null,
                                                                                                                                                                                                                                                                                                    React.createElement("div", { className: 'name' }, tempName),
                                                                                                                                                                                                                                                                                                    React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'edit', tooltip: t('Change name'), onClick: startEdit })))));
      }
      class CollectionThumbnail extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.imageURLs = (0, memoize_one_1.default)((collection) => {
            let _a;
            return [(_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.pictureUrl, path.join(__dirname, 'fallback_tile.png')]
              .filter(iter => iter !== undefined);
          });
          this.changeName = (name) => {
            const { collection, onSetModAttribute, profile } = this.props;
            onSetModAttribute(profile.gameId, collection.id, 'customFileName', name);
          };
          this.initState({
            updating: false
          });
        }
        render() {
          let _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
          const { t, collection, details, infoCache, incomplete, mods, onEdit, profile, forceRevisionDisplay } = this.props;
          if (collection === undefined) {
            return null;
          }
          const active = vortex_api_1.util.getSafe(profile, ['modState', collection.id, 'enabled'], false);
          const refMods = ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type));
          const totalSize = Object.values((_b = collection.rules) !== null && _b !== void 0 ? _b : []).reduce((prev, rule) => {
            let _a, _b, _c;
            if (rule.reference.fileSize !== undefined) {
              return prev + rule.reference.fileSize;
            }
            else if ((rule.reference.id !== undefined) && (mods !== undefined)) {
              return prev + ((_c = (_b = (_a = mods[rule.reference.id]) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.fileSize) !== null && _c !== void 0 ? _c : 0);
            }
            else {
              return prev;
            }
          }, 0);
          const classes = ['collection-thumbnail'];
          const hasMenu = (this.actions.length > 0);
          if (this.props.className !== undefined) {
            classes.push(this.props.className);
          }
          if (hasMenu) {
            classes.push('has-menu');
          }
          const { revisionId, collectionSlug, revisionNumber } = (_c = collection.attributes) !== null && _c !== void 0 ? _c : {};
          const validRemote = (revisionId !== undefined)
            && (collectionSlug !== undefined)
            && (revisionNumber !== undefined);
          return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' '), bsStyle: active ? 'primary' : 'default' },
                                      React.createElement(react_bootstrap_1.Panel.Body, { className: 'collection-thumbnail-body' },
                                                          (details === true)
                                                            ? React.createElement(NewRevisionMarker_1.default, { t: t, collection: collection, updating: this.state.updating })
                                                            : null,
                                                          React.createElement(vortex_api_1.Image, { className: 'thumbnail-img', srcs: this.imageURLs(collection), circle: false }),
                                                          (details !== false) ? React.createElement("div", { className: 'gradient' }) : null,
                                                          (details !== false) ? (React.createElement("div", { className: `bottom ${onEdit !== undefined ? 'editable' : ''}` },
                                                                                                     React.createElement(CollectionReleaseStatus_1.default, { t: t, active: active, enabled: (_f = (_e = (_d = profile === null || profile === void 0 ? void 0 : profile.modState) === null || _d === void 0 ? void 0 : _d[collection.id]) === null || _e === void 0 ? void 0 : _e.enabled) !== null && _f !== void 0 ? _f : false, collection: collection, incomplete: incomplete }),
                                                                                                     React.createElement("div", { className: 'collection-revision-and-rating' },
                                                                                                                         React.createElement("div", { className: 'revision-number' }, t('Revision {{number}}{{forceRevision}}', { replace: {
                                                                                                                           number: (_h = (_g = collection.attributes) === null || _g === void 0 ? void 0 : _g.version) !== null && _h !== void 0 ? _h : '0',
                                                                                                                           forceRevision: forceRevisionDisplay === undefined ? '' : ' ➔ ' + forceRevisionDisplay,
                                                                                                                         } })),
                                                                                                                         (infoCache !== undefined) && validRemote
                                                                                                                           ? React.createElement(SuccessRating_1.SuccessRating, { t: t, infoCache: infoCache, collectionSlug: collectionSlug, revisionNumber: revisionNumber, revisionId: revisionId })
                                                                                                                           : null),
                                                                                                     React.createElement("div", { className: 'name no-hover' }, vortex_api_1.util.renderModName(collection, { version: false })),
                                                                                                     onEdit !== undefined ? (React.createElement("div", { className: 'hover' },
                                                                                                                                                 React.createElement(ModNameField, { t: t, name: vortex_api_1.util.renderModName(collection, { version: false }), onChange: this.changeName }))) : null,
                                                                                                     React.createElement("div", { className: 'details' },
                                                                                                                         React.createElement("div", { className: 'author' }, t('By {{uploader}}', { replace: {
                                                                                                                           uploader: (_k = (_j = collection.attributes) === null || _j === void 0 ? void 0 : _j.uploader) !== null && _k !== void 0 ? _k : t(constants_1.AUTHOR_UNKNOWN)
                                                                                                                         },
                                                                                                                         })),
                                                                                                                         React.createElement("div", null,
                                                                                                                                             React.createElement(vortex_api_1.Icon, { name: 'mods' }),
                                                                                                                                             refMods.length)))) : null,
                                                          hasMenu ? (React.createElement("div", { className: 'thumbnail-hover-menu' }, this.renderMenu(refMods, totalSize))) : null)));
        }
        invoke(action, inst) {
          if ((action !== undefined) && (inst !== undefined) && (inst.length > 0)) {
            return action(inst[0]);
          }
        }
        get actions() {
          let _a;
          const { t, collection, incomplete, installing, onEdit, onPause, onUpload, onRemove, onResume, onUpdate, onView } = this.props;
          const result = [];
          if (onUpdate) {
            result.push({
              title: 'Update',
              icon: 'auto-update',
              group: 'optional',
              condition: () => {
                const { attributes } = this.props.collection;
                if (this.state.updating) {
                  return t('Already updating');
                }
                return ((attributes === null || attributes === void 0 ? void 0 : attributes.newestVersion) !== undefined)
                        && (parseInt(attributes.newestVersion, 10) > parseInt(attributes.version, 10));
              },
              action: (instanceIds) => {
                const prom = this.invoke(onUpdate, instanceIds);
                if (prom !== undefined) {
                  this.nextState.updating = true;
                  prom
                    .catch(err => {
                      if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                        this.context.api.showErrorNotification('Failed to update collection', err);
                      }
                    })
                    .finally(() => {
                      this.nextState.updating = false;
                    });
                }
              },
            });
          }
          if (onView) {
            result.push({
              title: 'View',
              icon: 'show',
              action: (instanceIds) => {
                this.invoke(onView, instanceIds);
              },
            });
            if (incomplete && (onResume !== undefined)) {
              result.push({
                title: 'Resume',
                icon: 'resume',
                condition: () => {
                  if (installing === undefined) {
                    return true;
                  }
                  return (installing.id === collection.id)
                    ? false
                    : t('Another collection is being installed');
                },
                action: (instanceIds) => {
                  if (onResume !== undefined) {
                    this.invoke(onResume, instanceIds);
                  }
                  this.invoke(onView, instanceIds);
                },
              });
            }
            if (incomplete && (onPause !== undefined)) {
              result.push({
                title: 'Pause',
                icon: 'pause',
                condition: () => (installing === null || installing === void 0 ? void 0 : installing.id) === collection.id,
                action: (instanceIds) => {
                  this.invoke(onPause, instanceIds);
                  this.invoke(onView, instanceIds);
                },
              });
            }
          }
          if (onEdit) {
            result.push({
              title: 'Edit',
              icon: 'edit',
              action: (instanceIds) => this.invoke(onEdit, instanceIds),
            });
          }
          if (onRemove) {
            result.push({
              title: 'Remove',
              icon: 'remove',
              action: (instanceIds) => this.invoke(onRemove, instanceIds),
            });
          }
          if (onUpload) {
            const nextRev = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.revisionNumber;
            result.push({
              title: t(nextRev !== undefined ? 'Upload Update' : 'Upload New'),
              icon: 'upload',
              action: (instanceIds) => this.invoke(onUpload, instanceIds),
              condition: () => {
                let _a;
                const refMods = ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
                  .filter(rule => ['requires', 'recommends'].includes(rule.type));
                if (refMods.length === 0) {
                  return (this.props.t('Can\'t upload an empty collection'));
                }
                else {
                  return true;
                }
              },
            });
          }
          return result;
        }
        renderMenu(refMods, totalSize) {
          const { t, collection } = this.props;
          return [(React.createElement("div", { key: 'primary-buttons', className: 'hover-content' },
                                       React.createElement(vortex_api_1.IconBar, { id: `collection-thumbnail-${collection.id}`, className: 'buttons', group: 'collection-actions', instanceId: collection.id, staticElements: this.actions, collapse: false, buttonType: 'both', orientation: 'vertical', clickAnywhere: true, t: t })))];
        }
      }
      const emptyObj = {};
      function mapStateToProps(state, ownProps) {
        return {
          profile: vortex_api_1.selectors.activeProfile(state),
        };
      }
      function mapDispatchToProps(dispatch) {
        return {
          onSetModAttribute: (gameId, modId, key, value) => dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, key, value)),
        };
      }
      exports["default"] = (0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(CollectionThumbnail);


/***/ }),

/***/ "./src/views/IniTweaks.tsx":
/*!*********************************!*\
  !*** ./src/views/IniTweaks.tsx ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
      const path = __webpack_require__(/*! path */ "path");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      class Tweak extends vortex_api_1.PureComponentEx {
        constructor() {
          super(...arguments);
          this.mStatusActions = [
            {
              icon: 'toggle-enabled',
              title: 'Enabled',
              action: () => this.disable(),
              condition: () => this.props.enabled,
            },
            {
              icon: 'toggle-disabled',
              title: 'Disabled',
              action: () => this.enable(),
              condition: () => !this.props.enabled,
            },
            {
              icon: 'delete',
              title: 'Remove',
              action: () => this.remove(),
            },
          ];
          this.edit = () => {
            const { tweaksPath, fileName } = this.props;
            vortex_api_1.util.opn(path.join(tweaksPath, fileName)).catch(() => null);
          };
          this.enable = () => {
            this.toggle(true);
          };
          this.disable = () => {
            this.toggle(false);
          };
          this.remove = () => {
            const { fileName, onRemoveTweak } = this.props;
            onRemoveTweak({ fileName });
          };
          this.toggle = (enabled) => {
            const { fileName, onToggle } = this.props;
            onToggle(fileName, enabled);
          };
        }
        render() {
          const { t, fileName } = this.props;
          const match = fileName.match(/(.*)\[(.*)\]\.ini/);
          if (!match || (match.length < 3)) {
            return null;
          }
          return (React.createElement("tr", null,
                                      React.createElement("td", { className: 'cell-status' }, this.renderStatusActions()),
                                      React.createElement("td", { className: 'cell-tweak-name' }, match[1]),
                                      React.createElement("td", { className: 'cell-filename' }, `${match[2]}.ini`),
                                      React.createElement("td", { className: 'cell-edit' },
                                                          React.createElement("a", { onClick: this.edit },
                                                                              React.createElement(vortex_api_1.Icon, { name: 'edit' })))));
        }
        renderStatusActions() {
          const { t } = this.props;
          return (React.createElement(vortex_api_1.ActionDropdown, { t: t, buttonType: 'text', staticElements: this.mStatusActions, className: 'collections-ini-tweaks-actions' }));
        }
      }
      class TweakList extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.addIniTweak = () => {
            const { collection, modsPath, onAddIniTweak, settingsFiles } = this.props;
            if ((collection === null || collection === void 0 ? void 0 : collection.installationPath) && modsPath) {
              const modPath = path.join(modsPath, collection.installationPath);
              onAddIniTweak(modPath, settingsFiles)
                .then(() => this.refreshTweaks());
            }
          };
          this.refreshTweaks = () => {
            const { collection, modsPath, onRefreshTweaks } = this.props;
            if ((collection === null || collection === void 0 ? void 0 : collection.installationPath) && modsPath) {
              const modPath = path.join(modsPath, collection.installationPath);
              onRefreshTweaks(modPath).then((newTweaks) => this.nextState.tweaks = newTweaks);
            }
          };
          this.renderTweak = (tweak) => {
            const { t, collection, modsPath } = this.props;
            const { fileName } = tweak;
            const isEnabled = vortex_api_1.util.getSafe(collection, ['enabledINITweaks'], []).indexOf(fileName) !== -1;
            return (React.createElement(Tweak, { t: t, key: `tweak-${fileName}`, tweaksPath: path.join(modsPath, collection.installationPath, constants_1.INI_TWEAKS_PATH), fileName: fileName, enabled: isEnabled, onToggle: this.toggle, onRemoveTweak: this.removeTweak }));
          };
          this.removeTweak = (tweak) => {
            const { collection, modsPath, onRemoveIniTweak } = this.props;
            if ((collection === null || collection === void 0 ? void 0 : collection.installationPath) && modsPath) {
              const modPath = path.join(modsPath, collection.installationPath);
              onRemoveIniTweak(modPath, tweak)
                .then(() => this.refreshTweaks());
            }
          };
          this.toggle = (fileName, enabled) => {
            const { collection, gameId, onSetINITweakEnabled } = this.props;
            onSetINITweakEnabled(gameId, collection.id, fileName, enabled);
          };
          this.initState({
            tweaks: [],
          });
        }
        componentDidMount() {
          this.refreshTweaks();
        }
        render() {
          const { t, collection } = this.props;
          const { tweaks } = this.state;
          if (collection === undefined) {
            return null;
          }
          return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', className: 'ini-tweaks-container' },
                                      React.createElement(react_bootstrap_1.ControlLabel, null,
                                                          React.createElement("p", null, t('This screen lets you set up tweaks for the game ini file that will be applied '
                    + 'to a user\'s setup when they use your collection.')),
                                                          React.createElement("p", null, t('Users can toggle these ini tweaks individually so you may want to set up '
                    + 'multiple tweaks to give users granular control.'))),
                                      React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                                          React.createElement("div", { id: 'collection-initweaks-table-panel' },
                                                                              React.createElement(react_bootstrap_1.Table, { id: 'collection-initweaks-table' },
                                                                                                  React.createElement("thead", null,
                                                                                                                      React.createElement("tr", null,
                                                                                                                                          React.createElement("th", { className: 'header-status' }, t('Status')),
                                                                                                                                          React.createElement("th", { className: 'header-tweak-name' }, t('Tweak Name')),
                                                                                                                                          React.createElement("th", { className: 'header-filename' }, t('Ini File')),
                                                                                                                                          React.createElement("th", { className: 'header-edit' },
                                                                                                                                                              t('Edit'),
                                                                                                                                                              React.createElement(vortex_api_1.More, { id: 'edit-ini-file', name: t('Edit Ini File') }, t('"Edit" allows you to input the ini tweak you want to '
                                        + 'apply to the target ini file. Please provide the section as '
                                        + 'well as your tweak(s). e.g.:\n\n[General]\nsIntroSequence=0'))))),
                                                                                                  React.createElement("tbody", null, tweaks.map(tweak => this.renderTweak(tweak)))),
                                                                              React.createElement(react_bootstrap_1.Button, { onClick: this.addIniTweak }, t('Add')))),
                                      React.createElement(vortex_api_1.Usage, { infoId: 'ini-tweaks' },
                                                          React.createElement("p", null, t('To assist in the testing of INI configuration application - any enabled INI modification '
                    + 'on this page will be applied to your own environment in the next deployment event; IF '
                    + 'the collection mod is enabled.')),
                                                          React.createElement("p", null, t('To disable/enable an INI tweak, simply click on the button itself (in the status column). '
                    + 'If needed, INI tweak can be removed by clicking the arrow next to the button and selecting "Remove"')))));
        }
      }
      function mapStateToProps(state, ownProps) {
        return {
          modsPath: vortex_api_1.selectors.installPath(state),
        };
      }
      function mapDispatchToProps(dispatch) {
        return {
          onSetINITweakEnabled: (gameId, modId, tweak, enabled) => {
            dispatch(vortex_api_1.actions.setINITweakEnabled(gameId, modId, tweak, enabled));
          },
        };
      }
      const TweakListConnected = (0, react_i18next_1.withTranslation)([constants_1.NAMESPACE, 'common'])((0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(TweakList));
      exports["default"] = TweakListConnected;


/***/ }),

/***/ "./src/views/InstallDialog/InstallChangelogDialog.tsx":
/*!************************************************************!*\
  !*** ./src/views/InstallDialog/InstallChangelogDialog.tsx ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.InstallChangelogDialog = void 0;
      const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const ReactMarkdown = __webpack_require__(/*! react-markdown */ "../../node_modules/react-markdown/src/react-markdown.js");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      function nop() {
      }
      function InstallChangelogDialogImpl(props) {
        const { collection, gameId, onCancel, onContinue, revisionInfo } = props;
        const { t } = (0, react_i18next_1.useTranslation)();
        const lang = (0, react_redux_1.useSelector)(state => state.settings.interface.language);
        const context = React.useContext(vortex_api_1.MainContext);
        const openUrl = React.useCallback(() => {
          context.api.events.emit('analytics-track-click-event', 'Collections', 'View on site Updated Collection');
          vortex_api_1.util.opn(vortex_api_1.util.nexusModsURL([revisionInfo.collection.game.domainName, 'collections', revisionInfo.collection.slug], {
            campaign: vortex_api_1.util.Campaign.ViewCollection,
            section: vortex_api_1.util.Section.Collections,
          }));
        }, [collection]);
        if (collection === undefined) {
          return null;
        }
        const changelog = revisionInfo.collectionChangelog;
        const changelogDate = new Date(changelog.createdAt);
        return (React.createElement(react_bootstrap_1.Modal, { id: 'install-changelog-dialog', show: collection !== undefined, onHide: nop },
                                    React.createElement(react_bootstrap_1.Modal.Header, null,
                                                        React.createElement(react_bootstrap_1.Modal.Title, null, t('{{collectionName}} update', { replace: { collectionName: vortex_api_1.util.renderModName(collection) } }))),
                                    React.createElement(react_bootstrap_1.Modal.Body, null,
                                                        React.createElement(react_bootstrap_1.Media.Left, null,
                                                                            React.createElement(CollectionTile_1.default, { t: t, gameId: gameId, collection: collection, details: 'some', imageTime: 42, forceRevisionDisplay: revisionInfo.revisionNumber })),
                                                        React.createElement(react_bootstrap_1.Media.Right, null,
                                                                            React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                                                                                React.createElement("h4", null, t('Revision {{revNum}} Changelog', { replace: { revNum: revisionInfo.revisionNumber } })),
                                                                                                React.createElement("div", { className: 'changelog-time' }, changelogDate.toLocaleDateString(lang))),
                                                                            React.createElement("div", { className: 'changelog-scroll' },
                                                                                                React.createElement(ReactMarkdown, null, changelog.description))),
                                                        React.createElement(vortex_api_1.tooltip.IconButton, { className: 'collection-open-button', icon: 'open-in-browser', tooltip: t('Open Page'), onClick: openUrl }, t('View Collection'))),
                                    React.createElement(react_bootstrap_1.Modal.Footer, null,
                                                        React.createElement(react_bootstrap_1.Button, { onClick: onCancel }, t('Later')),
                                                        React.createElement(react_bootstrap_1.Button, { onClick: onContinue }, t('Download Update')))));
      }
      const localState = vortex_api_1.util.makeReactive({
        job: {
          collection: undefined,
          gameId: undefined,
          onCancel: () => {
          },
          onContinue: () => {
          },
          revisionInfo: undefined,
        },
      });
      class InstallChangelogDialog extends React.Component {
        componentDidMount() {
          let _a;
          (_a = localState['attach']) === null || _a === void 0 ? void 0 : _a.call(localState, this);
        }
        componentWillUnmount() {
          let _a;
          (_a = localState['detach']) === null || _a === void 0 ? void 0 : _a.call(localState, this);
        }
        render() {
          const { job } = localState;
          return (React.createElement(InstallChangelogDialogImpl, { collection: job === null || job === void 0 ? void 0 : job.collection, gameId: job === null || job === void 0 ? void 0 : job.gameId, revisionInfo: job === null || job === void 0 ? void 0 : job.revisionInfo, onContinue: job === null || job === void 0 ? void 0 : job.onContinue, onCancel: job === null || job === void 0 ? void 0 : job.onCancel }));
        }
      }
      exports.InstallChangelogDialog = InstallChangelogDialog;
      function showChangelog(collection, gameId, revisionInfo) {
        return new Promise((resolve, reject) => {
          localState.job = {
            collection,
            gameId,
            revisionInfo,
            onContinue: () => {
              localState.job = undefined;
              resolve();
            },
            onCancel: () => {
              localState.job = undefined;
              reject(new vortex_api_1.util.UserCanceled());
            },
          };
        });
      }
      exports["default"] = showChangelog;


/***/ }),

/***/ "./src/views/InstallDialog/InstallFinishedDialog.tsx":
/*!***********************************************************!*\
  !*** ./src/views/InstallDialog/InstallFinishedDialog.tsx ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
      const YouCuratedThisTag_1 = __webpack_require__(/*! ./YouCuratedThisTag */ "./src/views/InstallDialog/YouCuratedThisTag.tsx");
      const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
      function nop() {
      }
      const emptyObject = {};
      function InstallFinishedDialog(props) {
        let _a, _b, _c, _d, _e, _f;
        const { api, driver, onClone } = props;
        const { t } = (0, react_i18next_1.useTranslation)(api.NAMESPACE);
        const userInfo = (0, react_redux_1.useSelector)(state => { let _a, _b; return (_b = (_a = state.persistent['nexus']) === null || _a === void 0 ? void 0 : _a.userInfo) !== null && _b !== void 0 ? _b : emptyObject; });
        const forceUpdate = React.useState(0)[1];
        React.useEffect(() => {
          driver.onUpdate(() => {
            if (((driver === null || driver === void 0 ? void 0 : driver.collection) !== undefined) && ((driver === null || driver === void 0 ? void 0 : driver.step) === 'review')) {
              forceUpdate(i => i + 1);
            }
          });
        }, [driver, forceUpdate]);
        const skip = React.useCallback(async () => {
          if (driver.collection !== undefined) {
            await driver.continue();
          }
          forceUpdate(i => i + 1);
        }, [driver]);
        const showOptionals = React.useCallback(async () => {
          if (driver.collection !== undefined) {
            api.events.emit('view-collection', driver.collection.id, 'mods');
            api.store.dispatch(vortex_api_1.actions.setAttributeFilter('collection-mods', undefined, undefined));
            api.store.dispatch(vortex_api_1.actions.setAttributeFilter('collection-mods', 'required', false));
            await driver.continue();
          }
          forceUpdate(i => i + 1);
        }, [driver]);
        const installAllOptionals = React.useCallback(() => {
          if ((driver.step === 'review') && (driver.collection !== undefined)) {
            driver.installRecommended();
          }
          forceUpdate(i => i + 1);
        }, []);
        const clone = React.useCallback(async () => {
          if (driver.collection === undefined) {
            return;
          }
          const id = await onClone(driver.collection.id);
          if (id !== undefined) {
            props.editCollection(id);
            driver.continue();
          }
        }, [driver, onClone]);
        const collection = driver.collection;
        const mods = (0, react_redux_1.useSelector)(state => {
          let _a;
          return (driver.profile !== undefined)
            ? state.persistent.mods[(_a = driver.profile) === null || _a === void 0 ? void 0 : _a.gameId]
            : emptyObject;
        });
        const optionals = React.useMemo(() => {
          let _a;
          return ((_a = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => (rule.type === 'recommends')
            && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined));
        }, [collection === null || collection === void 0 ? void 0 : collection.rules, mods]);
        const game = driver.profile !== undefined ? vortex_api_1.util.getGame(driver.profile.gameId) : undefined;
        const ownCollection = ((_b = (_a = driver.collectionInfo) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.memberId) === (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId);
        return (React.createElement(vortex_api_1.Modal, { id: 'install-finished-dialog', show: (driver.collection !== undefined) && (driver.step === 'review'), onHide: nop },
                                    React.createElement(vortex_api_1.Modal.Header, null,
                                                        React.createElement(vortex_api_1.Modal.Title, null, t('Collection installation complete'))),
                                    React.createElement(vortex_api_1.Modal.Body, null,
                                                        React.createElement("div", { className: 'collection-finished-body' },
                                                                            React.createElement(react_bootstrap_1.Media.Left, null,
                                                                                                React.createElement(CollectionTile_1.default, { t: t, gameId: (_c = driver.profile) === null || _c === void 0 ? void 0 : _c.gameId, collection: driver.collection, details: true, imageTime: 42 })),
                                                                            React.createElement(react_bootstrap_1.Media.Right, null,
                                                                                                React.createElement("h5", null, game === null || game === void 0 ? void 0 : game.name),
                                                                                                React.createElement("h3", null, vortex_api_1.util.renderModName(driver.collection)), (_f = (_e = (_d = driver.collection) === null || _d === void 0 ? void 0 : _d.attributes) === null || _e === void 0 ? void 0 : _e.shortDescription) !== null && _f !== void 0 ? _f : t('No description'),
                                                                                                ownCollection && (optionals.length > 0) ? (React.createElement("div", null,
                                                                                                                                                               React.createElement(YouCuratedThisTag_1.default, { t: t }),
                                                                                                                                                               t('To edit this collection you must install all of the optional mods'))) : null)),
                                                        (optionals.length > 0) ? (React.createElement("div", { className: 'collection-finished-optionals' },
                                                                                                      React.createElement("div", { className: 'collection-finished-optionals-text' }, t('{{numOptionals}} optional mods available', { replace: { numOptionals: optionals.length } })),
                                                                                                      React.createElement("p", null, t('This collection has {{count}} optional mods which are not required to '
                    + 'complete the installation but may provide additional features or options. '
                    + 'You can view these mods before installing as they may change the default '
                    + 'behavior of the collection or have additional requirements.', {
                                                                                                        count: optionals.length,
                                                                                                        ns: constants_1.NAMESPACE,
                                                                                                      })),
                                                                                                      React.createElement("div", { className: 'collection-finished-optional-buttons' }))) : ownCollection ? (React.createElement("div", { className: 'collection-can-clone-container' },
                                                                                                                                                                                                                                 React.createElement(YouCuratedThisTag_1.default, { t: t }),
                                                                                                                                                                                                                                 t('You now have the whole collection installed, you can start editing '
                    + 'your collection by cloning it.'),
                                                                                                                                                                                                                                 React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'clone', tooltip: t('Clone the collection to the workshop for editing'), onClick: clone }, t('Edit')))) : null),
                                    (optionals.length > 0) ? (React.createElement(vortex_api_1.Modal.Footer, null,
                                                                                  React.createElement(react_bootstrap_1.Button, { onClick: skip }, t('No Thanks')),
                                                                                  React.createElement(react_bootstrap_1.Button, { onClick: showOptionals }, t('View optional mods')),
                                                                                  React.createElement(react_bootstrap_1.Button, { onClick: installAllOptionals }, t('Install optional mods')))) : (React.createElement(vortex_api_1.Modal.Footer, null,
                                                                                                                                                                                                                       React.createElement(react_bootstrap_1.Button, { onClick: skip }, t('Done'))))));
      }
      exports["default"] = React.memo(InstallFinishedDialog);


/***/ }),

/***/ "./src/views/InstallDialog/InstallStartDialog.tsx":
/*!********************************************************!*\
  !*** ./src/views/InstallDialog/InstallStartDialog.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
      const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
      const YouCuratedThisTag_1 = __webpack_require__(/*! ./YouCuratedThisTag */ "./src/views/InstallDialog/YouCuratedThisTag.tsx");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const react_select_1 = __webpack_require__(/*! react-select */ "react-select");
      const shortid_1 = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const ReactMarkdown = __webpack_require__(/*! react-markdown */ "../../node_modules/react-markdown/src/react-markdown.js");
      function nop() {
      }
      function InstallDialogSelectProfile(props) {
        const { t, allProfiles, onSelectProfile, profile, selectedProfile, recommendedNewProfile } = props;
        const profileOptions = Object.keys(allProfiles)
          .filter(profId => allProfiles[profId].gameId === profile.gameId)
          .map(profId => ({
            value: profId,
            label: profId === profile.id
              ? t('{{name}} (Current)', { replace: { name: profile.name } })
              : allProfiles[profId].name,
          }))
          .concat({
            value: '__new', label: t('Create new profile{{recommended}}', { replace: { recommended: recommendedNewProfile ? t(' (Recommended by curator)') : '' } })
          });
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'row', id: 'collections-profile-select' },
                                    React.createElement(vortex_api_1.FlexLayout.Fixed, null, t('Install this collection to profile') + ':'),
                                    React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                                        React.createElement(react_select_1.default, { options: profileOptions, value: selectedProfile !== null && selectedProfile !== void 0 ? selectedProfile : profile.id, onChange: onSelectProfile, clearable: false }))));
      }
      function InstallDialogConfirmProfile(props) {
        let _a;
        const { t, collectionName, selectedProfile } = props;
        const profileName = (_a = selectedProfile === null || selectedProfile === void 0 ? void 0 : selectedProfile.name) !== null && _a !== void 0 ? _a : collectionName;
        return (React.createElement(React.Fragment, null,
                                    React.createElement("p", null, t('Currently installing to profile: {{profileName}}', {
                                      replace: {
                                        profileName,
                                      },
                                    })),
                                    React.createElement("p", null, t('Do you want to switch to this profile?'))));
      }
      class InstallDialog extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.changeProfile = (value) => {
            if (!!value) {
              this.nextState.selectedProfile = value.value;
            }
          };
          this.cancel = () => {
            this.props.driver.cancel();
          };
          this.next = () => {
            let _a, _b;
            if (!this.state.confirmProfile
                && (this.state.selectedProfile !== undefined)
                && (this.state.selectedProfile !== ((_b = (_a = this.props.driver) === null || _a === void 0 ? void 0 : _a.profile) === null || _b === void 0 ? void 0 : _b.id))) {
              if (this.state.selectedProfile === '__new') {
                const { driver, onAddProfile, onSetProfilesVisible } = this.props;
                const { profile } = driver;
                const profileId = (0, shortid_1.generate)();
                const name = vortex_api_1.util.renderModName(driver.collection);
                const newProfile = {
                  id: profileId,
                  gameId: profile.gameId,
                  name,
                  modState: {},
                  lastActivated: 0,
                };
                onAddProfile(newProfile);
                onSetProfilesVisible();
                this.nextState.selectedProfile = profileId;
              }
              this.nextState.confirmProfile = true;
            }
            else {
              this.startInstall();
            }
          };
          this.switchProfile = async () => {
            const { selectedProfile } = this.state;
            await this.props.onSwitchProfile(selectedProfile);
            this.props.onSetProfilesVisible();
            this.startInstall();
          };
          this.initState({
            selectedProfile: undefined,
            confirmProfile: false,
            recommendedNewProfile: false,
          });
          if (props.driver !== undefined) {
            this.props.driver.onUpdate(() => this.forceUpdate());
          }
        }
        static getDerivedStateFromProps(props, state) {
          let _a, _b, _c;
          if (!state.selectedProfile && !!((_c = (_b = (_a = props.driver) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.attributes) === null || _c === void 0 ? void 0 : _c.recommendNewProfile)) {
            return {
              recommendedNewProfile: true,
              selectedProfile: '__new',
            };
          }
          return null;
        }
        componentDidUpdate(prevProps) {
          const { driver } = this.props;
          if (driver !== undefined) {
            if (driver !== prevProps.driver) {
              driver.onUpdate(() => this.forceUpdate());
            }
            if (driver.collection !== this.mLastCollection) {
              this.nextState.confirmProfile = false;
              this.nextState.selectedProfile = undefined;
              this.mLastCollection = driver.collection;
            }
          }
        }
        render() {
          let _a, _b, _c, _d;
          const { t, driver, allProfiles, nextProfileId, userInfo } = this.props;
          const { selectedProfile, recommendedNewProfile } = this.state;
          if ((driver === null || driver === void 0 ? void 0 : driver.profile) === undefined) {
            return null;
          }
          const { profile } = driver;
          if (nextProfileId !== profile.id) {
            return null;
          }
          let installInstructions = ((_b = (_a = driver.collection) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.installInstructions) || t(constants_1.DEFAULT_INSTRUCTIONS);
          installInstructions = installInstructions.replace(/\r?\n/g, "  \r\n");
          const game = vortex_api_1.util.getGame(profile.gameId);
          const ownCollection = ((userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId) !== undefined)
            && (((_d = (_c = driver.collectionInfo) === null || _c === void 0 ? void 0 : _c.user) === null || _d === void 0 ? void 0 : _d.memberId) === (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId));
          const collectionName = vortex_api_1.util.renderModName(driver.collection);
          return (React.createElement(vortex_api_1.Modal, { show: (driver.collection !== undefined) && (driver.step === 'query'), onHide: nop },
                                      React.createElement(vortex_api_1.Modal.Header, null,
                                                          React.createElement(vortex_api_1.Modal.Title, null, t('{{gameName}} collection added', { replace: { gameName: game.name } }))),
                                      React.createElement(vortex_api_1.Modal.Body, null,
                                                          React.createElement(react_bootstrap_1.Media, null,
                                                                              React.createElement(react_bootstrap_1.Media.Left, null,
                                                                                                  React.createElement(CollectionTile_1.default, { t: t, gameId: profile.gameId, collection: driver.collection, details: true, imageTime: 42 })),
                                                                              React.createElement(react_bootstrap_1.Media.Right, { style: { width: '100%', display: 'flex' } },
                                                                                                  React.createElement(react_bootstrap_1.Media.Body, null,
                                                                                                                      React.createElement(react_bootstrap_1.Media.Heading, null, "Collection instructions"),
                                                                                                                      React.createElement("p", { className: 'collections-instructions-canbereviewed' }, "Instructions can be reviewed during installation."),
                                                                                                                      ownCollection ? React.createElement(YouCuratedThisTag_1.default, { t: t }) : null,
                                                                                                                      React.createElement(ReactMarkdown, { className: 'textarea-install-collection-instructions', allowedElements: ['p', 'br', 'a', 'em', 'strong'], unwrapDisallowed: true }, installInstructions)))),
                                                          React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                                                              React.createElement("p", null,
                                                                                                  t('Profiles allow you to have multiple mod set-ups for a game at once and quickly switch between them.'),
                                                                                                  React.createElement(vortex_api_1.More, { id: 'more-profile-instcollection', name: t('Profiles'), wikiId: 'profiles' }, vortex_api_1.util.getText('profile', 'profiles', t)))),
                                                          (this.state.confirmProfile && (selectedProfile !== undefined)) ? (React.createElement(InstallDialogConfirmProfile, { t: t, collectionName: collectionName, selectedProfile: selectedProfile === '__new' ? undefined : allProfiles[selectedProfile] })) : (React.createElement(InstallDialogSelectProfile, { t: t, allProfiles: allProfiles, profile: profile, selectedProfile: selectedProfile, onSelectProfile: this.changeProfile, recommendedNewProfile: recommendedNewProfile })),
                                                          React.createElement(vortex_api_1.Toggle, { checked: this.props.collectionsInstallWhileDownloading, onToggle: this.props.onSetCollectionConcurrency }, t('Install mods during collection downloads'))),
                                      React.createElement(vortex_api_1.Modal.Footer, null, this.state.confirmProfile ? (React.createElement(React.Fragment, null,
                                                                                                                                            React.createElement(react_bootstrap_1.Button, { onClick: this.next }, t('No')),
                                                                                                                                            React.createElement(react_bootstrap_1.Button, { onClick: this.switchProfile }, t('Yes')))) : (React.createElement(React.Fragment, null,
                                                                                                                                                                                                                                                              React.createElement(react_bootstrap_1.Button, { onClick: this.cancel }, t('Later')),
                                                                                                                                                                                                                                                              React.createElement(react_bootstrap_1.Button, { onClick: this.next }, t('Install Now')))))));
        }
        startInstall() {
          const { allProfiles, driver } = this.props;
          const { selectedProfile } = this.state;
          const { profile } = driver;
          if ((selectedProfile !== undefined) && (selectedProfile !== profile.id)) {
            driver.profile = allProfiles[selectedProfile];
          }
          driver.continue();
        }
      }
      const emptyObject = {};
      function mapStateToProps(state, ownProps) {
        let _a, _b, _c;
        const { editCollectionId } = state.session.collections;
        const gameMode = (_b = (_a = ownProps.driver) === null || _a === void 0 ? void 0 : _a.profile) === null || _b === void 0 ? void 0 : _b.gameId;
        const isPremium = vortex_api_1.util.getSafe(state, ['persistent', 'nexus', 'userInfo', 'isPremium'], false);
        const collectionsInstallWhileDownloading = vortex_api_1.util.getSafe(state, ['settings', 'downloads', 'collectionsInstallWhileDownloading'], true);
        const { userInfo } = (_c = state.persistent['nexus']) !== null && _c !== void 0 ? _c : {};
        return {
          allProfiles: state.persistent.profiles,
          mods: editCollectionId !== undefined ? state.persistent.mods[gameMode] : emptyObject,
          isPremium,
          userInfo,
          nextProfileId: state.settings.profiles.nextProfileId,
          collectionsInstallWhileDownloading,
        };
      }
      function mapDispatchToProps(dispatch) {
        return {
          onSetModAttribute: (gameId, modId, key, value) => dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, key, value)),
          onSetModAttributes: (gameId, modId, attributes) => dispatch(vortex_api_1.actions.setModAttributes(gameId, modId, attributes)),
          onAddRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.addModRule(gameId, modId, rule)),
          onRemoveRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.removeModRule(gameId, modId, rule)),
          onAddProfile: (profile) => dispatch(vortex_api_1.actions.setProfile(profile)),
          onSetProfilesVisible: () => dispatch(vortex_api_1.actions.setProfilesVisible(true)),
          onSetCollectionConcurrency: (enabled) => dispatch(vortex_api_1.actions.setCollectionConcurrency(enabled)),
        };
      }
      exports["default"] = (0, react_i18next_1.withTranslation)(['common', constants_1.NAMESPACE])((0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(React.memo(InstallDialog)));


/***/ }),

/***/ "./src/views/InstallDialog/YouCuratedThisTag.tsx":
/*!*******************************************************!*\
  !*** ./src/views/InstallDialog/YouCuratedThisTag.tsx ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __webpack_require__(/*! react */ "react");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function Tag(props) {
        const { t } = props;
        return (React.createElement("div", { className: 'collections-you-curated-tag' },
                                    React.createElement(vortex_api_1.Icon, { name: 'completed' }),
                                    t('You curated this collection')));
      }
      exports["default"] = Tag;


/***/ }),

/***/ "./src/views/InstallDialog/index.tsx":
/*!*******************************************!*\
  !*** ./src/views/InstallDialog/index.tsx ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.InstallStartDialog = exports.InstallFinishDialog = exports.InstallChangelogDialog = void 0;
      const InstallChangelogDialog_1 = __webpack_require__(/*! ./InstallChangelogDialog */ "./src/views/InstallDialog/InstallChangelogDialog.tsx");
      Object.defineProperty(exports, "InstallChangelogDialog", ({ enumerable: true, get: function () { return InstallChangelogDialog_1.InstallChangelogDialog; } }));
      const InstallFinishedDialog_1 = __webpack_require__(/*! ./InstallFinishedDialog */ "./src/views/InstallDialog/InstallFinishedDialog.tsx");
      exports.InstallFinishDialog = InstallFinishedDialog_1.default;
      const InstallStartDialog_1 = __webpack_require__(/*! ./InstallStartDialog */ "./src/views/InstallDialog/InstallStartDialog.tsx");
      exports.InstallStartDialog = InstallStartDialog_1.default;


/***/ }),

/***/ "./src/views/Tools.tsx":
/*!*****************************!*\
  !*** ./src/views/Tools.tsx ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const path = __webpack_require__(/*! path */ "path");
      const React = __webpack_require__(/*! react */ "react");
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const url_1 = __webpack_require__(/*! url */ "url");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function ToolIcon(props) {
        const { gameId, imageUrl } = props;
        if (imageUrl !== undefined) {
          const src = (0, url_1.pathToFileURL)(path.join(vortex_api_1.util.getVortexPath('userData'), gameId, 'icons', imageUrl)).href;
          return (React.createElement(react_bootstrap_1.Image, { src: src, className: 'tool-icon valid' }));
        }
        else {
          return (React.createElement(vortex_api_1.Icon, { name: 'executable', className: 'tool-icon valid' }));
        }
      }
      function ToolItem(props) {
        let _a, _b;
        const { enabled, gameId, onToggle, tool } = props;
        return (React.createElement("tr", null,
                                    React.createElement("td", null,
                                                        React.createElement(vortex_api_1.Toggle, { dataId: tool.id, checked: enabled, onToggle: onToggle })),
                                    React.createElement("td", null,
                                                        React.createElement(ToolIcon, { gameId: gameId, imageUrl: tool.logo })),
                                    React.createElement("td", null, tool.name),
                                    React.createElement("td", null, tool.path),
                                    React.createElement("td", null, ((_a = tool.parameters) !== null && _a !== void 0 ? _a : []).join(' ')),
                                    React.createElement("td", null, Object.keys((_b = tool.environment) !== null && _b !== void 0 ? _b : {})
                                      .map(key => `${key}=${tool.environment[key]}`).join(', '))));
      }
      const emptyArray = [];
      function Tools(props) {
        const { t, collection, onSetCollectionAttribute } = props;
        const gameMode = (0, react_redux_1.useSelector)(vortex_api_1.selectors.activeGameId);
        const includedTools = (0, react_redux_1.useSelector)(state => {
          let _a, _b, _c;
          return (_c = (_b = (_a = state.persistent.mods[gameMode][collection.id].attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.includedTools) !== null && _c !== void 0 ? _c : emptyArray;
        });
        const toggleCB = React.useCallback((newValue, toolId) => {
          onSetCollectionAttribute(['includedTools'], newValue
            ? [].concat(includedTools, [toolId])
            : includedTools.filter(id => id !== toolId));
        }, [includedTools, onSetCollectionAttribute]);
        const tools = (0, react_redux_1.useSelector)((state) => state.settings.gameMode.discovered[gameMode].tools);
        const custom = Object.values(tools !== null && tools !== void 0 ? tools : {})
          .filter(tool => tool.custom && !tool.hidden);
        return (React.createElement("div", { className: 'collection-scrollable' },
                                    React.createElement(react_bootstrap_1.ControlLabel, null,
                                                        React.createElement("p", null, t('This screen lets you include tools you manually configured to be run from Vortex.')),
                                                        React.createElement("p", null, t('Obviously users will need to have these tools installed. If they aren\'t '
                + 'included in the game and not installed as a mod through this collection, '
                + 'you should include instructions for the user on how to get the tool.'))),
                                    React.createElement(react_bootstrap_1.Table, { id: 'collection-tools-table' },
                                                        React.createElement("thead", null,
                                                                            React.createElement("tr", null,
                                                                                                React.createElement("th", { className: 'header-status' }, t('Status')),
                                                                                                React.createElement("th", { className: 'header-icon' }, t('Icon')),
                                                                                                React.createElement("th", { className: 'header-name' }, t('Name')),
                                                                                                React.createElement("th", { className: 'header-path' }, t('Path')),
                                                                                                React.createElement("th", { className: 'header-args' }, t('Args')),
                                                                                                React.createElement("th", { className: 'header-env' }, t('Environment')))),
                                                        React.createElement("tbody", null, custom.map(item => (React.createElement(ToolItem, { key: item.id, t: t, tool: item, gameId: gameMode, enabled: includedTools.includes(item.id), onToggle: toggleCB })))))));
      }
      exports["default"] = Tools;


/***/ }),

/***/ "bluebird":
/*!***************************!*\
  !*** external "bluebird" ***!
  \***************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("bluebird");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

      "use strict";
      module.exports = require("fs");

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("lodash");

/***/ }),

/***/ "node-7z":
/*!**************************!*\
  !*** external "node-7z" ***!
  \**************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("node-7z");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

      "use strict";
      module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

      "use strict";
      module.exports = require("path");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react");

/***/ }),

/***/ "react-bootstrap":
/*!**********************************!*\
  !*** external "react-bootstrap" ***!
  \**********************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react-bootstrap");

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react-dom");

/***/ }),

/***/ "react-i18next":
/*!********************************!*\
  !*** external "react-i18next" ***!
  \********************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react-i18next");

/***/ }),

/***/ "react-redux":
/*!******************************!*\
  !*** external "react-redux" ***!
  \******************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react-redux");

/***/ }),

/***/ "react-select":
/*!*******************************!*\
  !*** external "react-select" ***!
  \*******************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react-select");

/***/ }),

/***/ "redux-act":
/*!****************************!*\
  !*** external "redux-act" ***!
  \****************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("redux-act");

/***/ }),

/***/ "semver":
/*!*************************!*\
  !*** external "semver" ***!
  \*************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("semver");

/***/ }),

/***/ "turbowalk":
/*!****************************!*\
  !*** external "turbowalk" ***!
  \****************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("turbowalk");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

      "use strict";
      module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

      "use strict";
      module.exports = require("util");

/***/ }),

/***/ "vortex-api":
/*!*****************************!*\
  !*** external "vortex-api" ***!
  \*****************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("vortex-api");

/***/ }),

/***/ "vortexmt":
/*!***************************!*\
  !*** external "vortexmt" ***!
  \***************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("vortexmt");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	const __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		const cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		const module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(const key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
  const __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
  (() => {
    "use strict";
    const exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

    Object.defineProperty(exports, "__esModule", ({ value: true }));
    const persistent_1 = __webpack_require__(/*! ./actions/persistent */ "./src/actions/persistent.ts");
    const persistent_2 = __webpack_require__(/*! ./reducers/persistent */ "./src/reducers/persistent.ts");
    const session_1 = __webpack_require__(/*! ./reducers/session */ "./src/reducers/session.ts");
    const settings_1 = __webpack_require__(/*! ./reducers/settings */ "./src/reducers/settings.ts");
    const defaults_1 = __webpack_require__(/*! ./util/defaults */ "./src/util/defaults.ts");
    const extension_1 = __webpack_require__(/*! ./util/extension */ "./src/util/extension.ts");
    const InstallDriver_1 = __webpack_require__(/*! ./util/InstallDriver */ "./src/util/InstallDriver.ts");
    const transformCollection_1 = __webpack_require__(/*! ./util/transformCollection */ "./src/util/transformCollection.ts");
    const util_1 = __webpack_require__(/*! ./util/util */ "./src/util/util.ts");
    const AddModsDialog_1 = __webpack_require__(/*! ./views/AddModsDialog */ "./src/views/AddModsDialog.tsx");
    const HealthDownvoteDialog_1 = __webpack_require__(/*! ./views/CollectionPageView/HealthDownvoteDialog */ "./src/views/CollectionPageView/HealthDownvoteDialog.tsx");
    const CollectionList_1 = __webpack_require__(/*! ./views/CollectionList */ "./src/views/CollectionList/index.tsx");
    const InstallDialog_1 = __webpack_require__(/*! ./views/InstallDialog */ "./src/views/InstallDialog/index.tsx");
    const CollectionModsPageAttributeRenderer_1 = __webpack_require__(/*! ./views/CollectionModsPageAttributeRenderer */ "./src/views/CollectionModsPageAttributeRenderer.tsx");
    const collectionCreate_1 = __webpack_require__(/*! ./collectionCreate */ "./src/collectionCreate.ts");
    const collectionInstall_1 = __webpack_require__(/*! ./collectionInstall */ "./src/collectionInstall.ts");
    const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
    const eventHandlers_1 = __webpack_require__(/*! ./eventHandlers */ "./src/eventHandlers.ts");
    const initweaks_1 = __webpack_require__(/*! ./initweaks */ "./src/initweaks.ts");
    const tools_1 = __webpack_require__(/*! ./tools */ "./src/tools.ts");
    const PromiseBB = __webpack_require__(/*! bluebird */ "bluebird");
    const _ = __webpack_require__(/*! lodash */ "lodash");
    const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
    const path = __webpack_require__(/*! path */ "path");
    const React = __webpack_require__(/*! react */ "react");
    const shortid_1 = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
    const url_1 = __webpack_require__(/*! url */ "url");
    const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
    function isEditableCollection(state, modIds) {
      const gameMode = vortex_api_1.selectors.activeGameId(state);
      const mod = state.persistent.mods[gameMode][modIds[0]];
      if (mod === undefined) {
        return false;
      }
      return vortex_api_1.util.getSafe(mod.attributes, ['editable'], false);
    }
    function profileCollectionExists(api, profileId) {
      const state = api.store.getState();
      const gameMode = vortex_api_1.selectors.activeGameId(state);
      const mods = state.persistent.mods[gameMode];
      return mods[(0, transformCollection_1.makeCollectionId)(profileId)] !== undefined;
    }
    function onlyLocalRules(rule) {
      return ['requires', 'recommends'].includes(rule.type)
        && (rule.reference.fileExpression === undefined)
        && (rule.reference.fileMD5 === undefined)
        && (rule.reference.logicalFileName === undefined)
        && (rule.reference.repo === undefined);
    }
    const modsBeingRemoved = new Set();
    function makeModKey(gameId, modId) {
      return `${gameId}_${modId}`;
    }
    function makeWillRemoveMods() {
      return (gameId, modIds) => {
        modIds.forEach(modId => modsBeingRemoved.add(makeModKey(gameId, modId)));
        return Promise.resolve();
      };
    }
    function makeDidRemoveMods() {
      return (gameId, modIds) => {
        modIds.forEach(modId => modsBeingRemoved.delete(makeModKey(gameId, modId)));
        return Promise.resolve();
      };
    }
    function makeOnUnfulfilledRules(api) {
      const reported = new Set();
      return (profileId, modId, rules) => {
        let _a;
        const state = api.store.getState();
        const profile = vortex_api_1.selectors.profileById(state, profileId);
        const gameId = profile.gameId;
        if (modsBeingRemoved.has(makeModKey(gameId, modId))) {
          return PromiseBB.resolve(false);
        }
        const collection = vortex_api_1.util.getSafe(state.persistent.mods, [gameId, modId], undefined);
        if ((collection !== undefined)
            && !reported.has(modId)
            && (state.persistent.mods[gameId][modId].type === constants_1.MOD_TYPE)
            && !((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.editable)) {
          const collectionProfile = Object.keys(state.persistent.profiles)
            .find(iter => (0, transformCollection_1.makeCollectionId)(iter) === modId);
          const notiActions = [{
            title: 'Disable',
            action: dismiss => {
              dismiss();
              if (profile !== undefined) {
                api.store.dispatch(vortex_api_1.actions.setModEnabled(profile.id, modId, false));
              }
            },
          }];
          if (collectionProfile !== undefined) {
            notiActions.unshift({
              title: 'Update',
              action: dismiss => {
                (0, collectionCreate_1.initFromProfile)(api, collectionProfile)
                  .then(dismiss)
                  .catch(err => api.showErrorNotification('Failed to update collection', err));
              },
            });
          }
          else if (profile !== undefined) {
            notiActions.unshift({
              title: 'Resume',
              action: dismiss => {
                driver.start(profile, collection);
                dismiss();
              },
            });
          }
          reported.add(modId);
          api.sendNotification({
            id: (0, util_1.getUnfulfilledNotificationId)(collection.id),
            type: 'info',
            title: 'Collection incomplete',
            message: vortex_api_1.util.renderModName(collection),
            actions: notiActions,
          });
          return PromiseBB.resolve(true);
        }
        else {
          return PromiseBB.resolve(false);
        }
      };
    }
    let driver;
    async function cloneInstalledCollection(api, collectionId) {
      const state = api.getState();
      const gameMode = vortex_api_1.selectors.activeGameId(state);
      const mods = state.persistent.mods[gameMode];
      const result = await api.showDialog('question', 'Clone collection "{{collectionName}}"?', {
        text: 'Cloning a collection means you can make edits to the collection in the workshop '
            + 'and share your changes with the community.\n'
            + 'If this collection is your own, your uploads will be revisions of that existing '
            + 'collection, otherwise you will create a new collection associated with your own '
            + 'account.',
        parameters: {
          collectionName: vortex_api_1.util.renderModName(mods[collectionId]),
        },
      }, [
        { label: 'Cancel' },
        { label: 'Clone' },
      ]);
      if (result.action === 'Clone') {
        const id = (0, transformCollection_1.makeCollectionId)((0, shortid_1.generate)());
        return (0, transformCollection_1.cloneCollection)(api, gameMode, id, collectionId);
      }
      else {
        return Promise.resolve(undefined);
      }
    }
    async function createNewCollection(api, profile, name) {
      const id = (0, transformCollection_1.makeCollectionId)((0, shortid_1.generate)());
      await (0, transformCollection_1.createCollection)(api, profile.gameId, id, name, []);
      api.sendNotification({
        type: 'success',
        id: 'collection-created',
        title: 'Collection created',
        message: name,
        actions: [
          {
            title: 'Edit',
            action: dismiss => {
              api.events.emit('edit-collection', id);
              dismiss();
            },
          },
        ],
      });
    }
    async function installCollection(api, revision) {
      return api.showDialog('question', 'Collection not installed', {
        text: 'You can only edit collections that are fully installed in this '
            + 'setup. Please ensure you install the collection with all '
            + 'optional items, then clone the collection into the Workshop.'
      }, [
        { label: 'Cancel' },
        { label: 'Install' },
      ])
        .then(result => {
          if (result.action === 'Install') {
            const gameId = revision.collection.game.domainName;
            api.events.emit('start-download', [`nxm://${gameId}/collections/${revision.collection.slug}/revisions/${revision.revisionNumber}`], {}, undefined, (err) => {
              if ((err !== null) && !(err instanceof vortex_api_1.util.UserCanceled)) {
                api.showErrorNotification('Failed to download collection', err);
              }
            }, undefined, { allowInstall: 'force' });
          }
        });
    }
    async function pauseCollection(api, gameId, modId, silent) {
      let _a;
      const state = api.getState();
      const mods = state.persistent.mods[gameId];
      const downloads = state.persistent.downloads.files;
      const collection = mods[modId];
      if (collection === undefined) {
        return;
      }
      ((_a = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _a !== void 0 ? _a : []).forEach(rule => {
        const dlId = vortex_api_1.util.findDownloadByRef(rule.reference, downloads);
        if (dlId !== undefined) {
          api.events.emit('pause-download', dlId);
        }
      });
      await api.emitAndAwait('cancel-dependency-install', modId);
      driver.cancel();
      api.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + modId);
      if (silent !== true) {
        api.sendNotification({
          id: 'collection-pausing',
          type: 'success',
          title: 'Collection pausing',
          message: 'Already queued mod installations will still finish',
        });
      }
    }
    async function removeCollection(api, gameId, modId, cancel) {
      let _a, _b, _c;
      const state = api.getState();
      const mods = state.persistent.mods[gameId];
      const t = api.translate;
      const collection = mods[modId];
      if (collection === undefined) {
        return;
      }
      const filter = rule => (rule.type === 'requires')
        && (rule['ignored'] !== true)
        && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined);
      const incomplete = ((_a = collection.rules) !== null && _a !== void 0 ? _a : []).find(filter);
      const message = cancel && incomplete
        ? 'Are you sure you want to cancel the installation?'
        : 'Are you sure you want to remove the collection?';
      const result = await api.showDialog('question', message, {
        text: 'This collection will be removed from Vortex and unlinked from any associated mods. '
            + 'You can also choose to uninstall mods related to this collection and delete the '
            + 'downloaded archives.\n'
            + '\nPlease note, some mods may be required by multiple collections.\n'
            + '\nAre you sure you want to remove "{{collectionName}}" from your collections?',
        parameters: {
          collectionName: vortex_api_1.util.renderModName(collection),
        },
        checkboxes: [
          { id: 'delete_mods', text: t('Remove mods'), value: false },
          { id: 'delete_archives', text: t('Delete mod archives'), value: false },
        ],
      }, [
        { label: 'Cancel' },
        { label: 'Remove Collection' },
      ]);
      if (result.action === 'Cancel') {
        return;
      }
      const deleteArchives = result.input.delete_archives;
      const deleteMods = result.input.delete_mods;
      modsBeingRemoved.add(makeModKey(gameId, modId));
      await pauseCollection(api, gameId, modId, true);
      let progress = 0;
      const notiId = (0, shortid_1.generate)();
      const modName = vortex_api_1.util.renderModName(collection);
      const doProgress = (step, value) => {
        if (value <= progress) {
          return;
        }
        progress = value;
        api.sendNotification({
          id: notiId,
          type: 'activity',
          title: 'Removing {{name}}',
          message: step,
          progress,
          replace: {
            name: modName,
          },
        });
      };
      try {
        doProgress('Removing downloads', 0);
        const downloads = state.persistent.downloads.files;
        let completed = 0;
        await Promise.all(((_b = collection.rules) !== null && _b !== void 0 ? _b : []).map(async (rule) => {
          const dlId = vortex_api_1.util.findDownloadByRef(rule.reference, downloads);
          if (dlId !== undefined) {
            const download = state.persistent.downloads.files[dlId];
            if ((download !== undefined)
                    && (deleteArchives || (download.state !== 'finished'))) {
              await vortex_api_1.util.toPromise(cb => api.events.emit('remove-download', dlId, cb));
            }
          }
          doProgress('Removing downloads', 50 * ((completed++) / collection.rules.length));
        }));
        doProgress('Removing mods', 50);
        completed = 0;
        if (deleteMods) {
          const removeMods = ((_c = collection.rules) !== null && _c !== void 0 ? _c : [])
            .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
            .filter(mod => mod !== undefined)
            .map(mod => mod.id);
          await vortex_api_1.util.toPromise(cb => api.events.emit('remove-mods', gameId, removeMods, cb, {
            progressCB: (idx, length, name) => {
              doProgress(name, 50 + (50 * idx) / length);
            },
          }));
        }
        {
          doProgress('Removing collection', 0.99);
          const download = state.persistent.downloads.files[collection.archiveId];
          if (download !== undefined) {
            await vortex_api_1.util.toPromise(cb => api.events.emit('remove-download', collection.archiveId, cb));
          }
          await vortex_api_1.util.toPromise(cb => api.events.emit('remove-mod', gameId, modId, cb, {
            incomplete: true,
          }));
        }
      }
      catch (err) {
        if (!(err instanceof vortex_api_1.util.UserCanceled)) {
          api.showErrorNotification('Failed to remove mods', err, {
            message: modName,
            allowReport: !(err instanceof vortex_api_1.util.ProcessCanceled),
            warning: (err instanceof vortex_api_1.util.ProcessCanceled),
          });
        }
      }
      finally {
        modsBeingRemoved.delete(makeModKey(gameId, modId));
        api.dismissNotification(notiId);
      }
    }
    function genAttributeExtractor(api) {
      return (modInfo, modPath) => {
        let _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        const collectionId = (_d = (_c = (_b = (_a = modInfo.download) === null || _a === void 0 ? void 0 : _a.modInfo) === null || _b === void 0 ? void 0 : _b.nexus) === null || _c === void 0 ? void 0 : _c.ids) === null || _d === void 0 ? void 0 : _d.collectionId;
        const revisionId = (_h = (_g = (_f = (_e = modInfo.download) === null || _e === void 0 ? void 0 : _e.modInfo) === null || _f === void 0 ? void 0 : _f.nexus) === null || _g === void 0 ? void 0 : _g.ids) === null || _h === void 0 ? void 0 : _h.revisionId;
        const collectionSlug = (_m = (_l = (_k = (_j = modInfo.download) === null || _j === void 0 ? void 0 : _j.modInfo) === null || _k === void 0 ? void 0 : _k.nexus) === null || _l === void 0 ? void 0 : _l.ids) === null || _m === void 0 ? void 0 : _m.collectionSlug;
        const revisionNumber = (_r = (_q = (_p = (_o = modInfo.download) === null || _o === void 0 ? void 0 : _o.modInfo) === null || _p === void 0 ? void 0 : _p.nexus) === null || _q === void 0 ? void 0 : _q.ids) === null || _r === void 0 ? void 0 : _r.revisionNumber;
        const referenceTag = (_t = (_s = modInfo.download) === null || _s === void 0 ? void 0 : _s.modInfo) === null || _t === void 0 ? void 0 : _t.referenceTag;
        const result = {
          collectionId,
          revisionId,
          collectionSlug,
          revisionNumber,
          referenceTag,
        };
        return PromiseBB.resolve(result);
      };
    }
    function generateCollectionMap(mods) {
      const collections = Object.values(mods).filter(mod => mod.type === constants_1.MOD_TYPE);
      const result = {};
      collections.forEach(coll => {
        let _a;
        return ((_a = coll.rules) !== null && _a !== void 0 ? _a : []).forEach(rule => {
          if (rule.reference.id !== undefined) {
            vortex_api_1.util.setdefault(result, rule.reference.id, []).push(coll);
          }
          else {
            const installed = vortex_api_1.util.findModByRef(rule.reference, mods);
            if (installed !== undefined) {
              vortex_api_1.util.setdefault(result, installed.id, []).push(coll);
            }
          }
        });
      });
      return result;
    }
    function collectionListEqual(lArgs, rArgs) {
      const lhs = lArgs[0];
      const rhs = rArgs[0];
      if (lhs === rhs) {
        return true;
      }
      const keys = Object.keys(lhs);
      if (!_.isEqual(keys, Object.keys(rhs))) {
        return false;
      }
      const ruleDiff = keys.find(modId => (lhs[modId].state !== rhs[modId].state) || (lhs[modId].rules !== rhs[modId].rules));
      return ruleDiff === undefined;
    }
    function generateCollectionOptions(mods) {
      return Object.values(mods)
        .filter(mod => mod.type === constants_1.MOD_TYPE)
        .map(mod => ({ label: vortex_api_1.util.renderModName(mod), value: mod.id }));
    }
    async function updateMeta(api) {
      let _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const state = api.getState();
      const gameMode = vortex_api_1.selectors.activeGameId(state);
      const mods = (_a = state.persistent.mods[gameMode]) !== null && _a !== void 0 ? _a : {};
      const collections = Object.keys(mods)
        .filter(modId => mods[modId].type === constants_1.MOD_TYPE);
      const notiId = (0, shortid_1.generate)();
      const progress = (name, idx) => {
        api.sendNotification({
          id: notiId,
          type: 'activity',
          title: 'Updating Collection Information',
          message: name,
          progress: (idx * 100) / collections.length,
        });
      };
      for (let i = 0; i < collections.length; ++i) {
        const modId = collections[i];
        const { revisionId, collectionSlug, revisionNumber } = (_b = mods[modId].attributes) !== null && _b !== void 0 ? _b : {};
        try {
          if ((revisionId !== undefined) || (collectionSlug !== undefined)) {
            progress(vortex_api_1.util.renderModName(mods[modId]), i);
            const info = await driver.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber, 'force');
            if (!!info) {
              const currentRevision = info.collection.revisions
                .filter(rev => rev.revisionStatus === 'published')
                .sort((lhs, rhs) => rhs.revisionNumber - lhs.revisionNumber)[0];
              api.store.dispatch(vortex_api_1.actions.setModAttributes(gameMode, modId, {
                collectionSlug: info.collection.slug,
                revisionNumber: info.revisionNumber,
                author: (_c = info.collection.user) === null || _c === void 0 ? void 0 : _c.name,
                uploader: (_d = info.collection.user) === null || _d === void 0 ? void 0 : _d.name,
                uploaderAvatar: (_e = info.collection.user) === null || _e === void 0 ? void 0 : _e.avatar,
                uploaderId: (_f = info.collection.user) === null || _f === void 0 ? void 0 : _f.memberId,
                pictureUrl: (_g = info.collection.tileImage) === null || _g === void 0 ? void 0 : _g.url,
                description: info.collection.description,
                shortDescription: info.collection.summary,
                newestFileId: currentRevision === null || currentRevision === void 0 ? void 0 : currentRevision.revisionNumber,
                newestVersion: (_j = (_h = currentRevision === null || currentRevision === void 0 ? void 0 : currentRevision.revisionNumber) === null || _h === void 0 ? void 0 : _h.toString) === null || _j === void 0 ? void 0 : _j.call(_h),
                metadata: info.metadata,
                rating: info.rating,
              }));
            }
          }
        }
        catch (err) {
          api.showErrorNotification('Failed to check collection for update', err);
        }
      }
      localState.ownCollections = (await api.emitAndAwait('get-my-collections', gameMode))[0] || [];
      api.dismissNotification(notiId);
    }
    let collectionChangedCB;
    function onAddSelectionImpl(api, collectionId, modIds) {
      const state = api.getState();
      const gameId = vortex_api_1.selectors.activeGameId(state);
      const collection = state.persistent.mods[gameId][collectionId];
      if (collection !== undefined) {
        modIds.forEach(modId => {
          if (!(0, collectionCreate_1.alreadyIncluded)(collection.rules, modId)) {
            api.store.dispatch(vortex_api_1.actions.addModRule(gameId, collectionId, {
              type: 'requires',
              reference: {
                id: modId,
              },
            }));
          }
        });
      }
      else {
        (0, vortex_api_1.log)('warn', 'failed to add mods to collection, collection no longer found', { gameId, collectionId, modIds });
      }
    }
    const localState = vortex_api_1.util.makeReactive({
      ownCollections: [],
    });
    function register(context, collectionsCB) {
      context.registerReducer(['session', 'collections'], session_1.default);
      context.registerReducer(['settings', 'collections'], settings_1.default);
      context.registerReducer(['persistent', 'collections'], persistent_2.default);
      const onSwitchProfile = (profileId) => {
        return new Promise((resolve, reject) => {
          context.api.events.once('profile-did-change', (newProfileId) => {
            if (newProfileId === profileId) {
              resolve();
            }
            else {
              (0, vortex_api_1.log)('warn', `Failed to switch to profile ${profileId}; got ${newProfileId}`);
              const profile = vortex_api_1.selectors.profileById(context.api.getState(), profileId);
              if (profile === undefined) {
                reject(new Error(`Failed to switch to profile ${profileId}; got ${newProfileId}`));
              }
              context.api.store.dispatch(vortex_api_1.actions.setNextProfile(profileId));
              resolve();
            }
          });
          context.api.store.dispatch(vortex_api_1.actions.setNextProfile(profileId));
        });
      };
      context.registerDialog('collection-install', InstallDialog_1.InstallStartDialog, () => ({
        driver,
        onSwitchProfile,
      }));
      const onClone = (collectionId) => cloneInstalledCollection(context.api, collectionId);
      const onCreateCollection = (profile, name) => createNewCollection(context.api, profile, name);
      const onRemoveCollection = (gameId, modId, cancel) => removeCollection(context.api, gameId, modId, cancel);
      const onUpdateMeta = () => updateMeta(context.api);
      const editCollection = (id) => collectionsCB.editCollection(id);
      const onInstallCollection = (revision) => installCollection(context.api, revision);
      context.registerDialog('collection-finish', InstallDialog_1.InstallFinishDialog, () => ({
        api: context.api,
        driver,
        onClone,
        editCollection,
      }));
      context.registerDialog('collection-changelog', InstallDialog_1.InstallChangelogDialog, () => ({}));
      const onAddSelection = (collectionId, modIds) => onAddSelectionImpl(context.api, collectionId, modIds);
      context.registerDialog('add-mod-to-collection', AddModsDialog_1.default, () => ({
        onAddSelection,
      }));
      context.registerDialog('collection-health-downvote', HealthDownvoteDialog_1.default, () => ({}));
      let resetPageCB;
      const resetCB = (cb) => resetPageCB = cb;
      const onAddCallback = (cbName, cb) => {
        collectionsCB[cbName] = cb;
      };
      context.registerMainPage('collection', 'Collections', CollectionList_1.default, {
        hotkey: 'C',
        group: 'per-game',
        visible: () => vortex_api_1.selectors.activeGameId(context.api.store.getState()) !== undefined,
        props: () => ({
          driver,
          localState,
          onInstallCollection,
          onAddCallback,
          onRemoveCollection,
          onCloneCollection: onClone,
          onCreateCollection,
          onUpdateMeta,
          resetCB,
          pathTool,
        }),
        onReset: () => resetPageCB === null || resetPageCB === void 0 ? void 0 : resetPageCB(),
        priority: 90,
      });
      context.registerModType(constants_1.MOD_TYPE, 200, () => true, () => undefined, () => PromiseBB.resolve(false), {
        name: 'Collection',
        customDependencyManagement: true,
        noConflicts: true,
      });
      const stateFunc = () => context.api.store.getState();
      const emptyArray = [];
      const emptyObj = {};
      const collectionsMapFunc = (0, memoize_one_1.default)(generateCollectionMap, collectionListEqual);
      const collectionsMap = () => {
        let _a;
        return collectionsMapFunc((_a = stateFunc().persistent.mods[vortex_api_1.selectors.activeGameId(stateFunc())]) !== null && _a !== void 0 ? _a : emptyObj);
      };
      const collectionOptions = (0, memoize_one_1.default)(generateCollectionOptions);
      const collectionChanged = new vortex_api_1.util.Debouncer(() => {
        collectionChangedCB === null || collectionChangedCB === void 0 ? void 0 : collectionChangedCB();
        return null;
      }, 500);
      const collectionAttribute = {
        id: 'collection',
        name: 'Collection',
        description: 'Collection(s) this mod was installed from (if any)',
        icon: 'collection',
        placement: 'both',
        customRenderer: (mod, detailCell) => {
          const collections = collectionsMap()[mod.id] || emptyArray;
          return React.createElement(CollectionModsPageAttributeRenderer_1.default, { modId: mod.id, collections, detailCell }, []);
        },
        calc: (mod) => {
          const collections = collectionsMap()[mod.id];
          return (collections === undefined)
            ? '' : collections.map(iter => iter.id);
        },
        externalData: (onChanged) => {
          collectionChangedCB = onChanged;
        },
        isToggleable: true,
        edit: {},
        filter: new vortex_api_1.OptionsFilter((() => {
          let _a;
          const mods = (_a = stateFunc().persistent.mods[vortex_api_1.selectors.activeGameId(stateFunc())]) !== null && _a !== void 0 ? _a : {};
          return [
            { label: `<${context.api.translate('None')}>`, value: vortex_api_1.OptionsFilter.EMPTY },
            ...collectionOptions(mods),
          ];
        }), false, false),
        isGroupable: true,
        groupName: (modId) => { let _a; return vortex_api_1.util.renderModName((_a = stateFunc().persistent.mods[vortex_api_1.selectors.activeGameId(stateFunc())]) === null || _a === void 0 ? void 0 : _a[modId]); },
        isDefaultVisible: false,
      };
      context.registerTableAttribute('mods', collectionAttribute);
      context.registerAction('mods-action-icons', 25, 'collection-edit', {}, 'Edit Collection', (modIds) => {
        context.api.events.emit('show-main-page', 'Collections');
        setTimeout(() => {
          if ((collectionsCB !== undefined) && (collectionsCB.editCollection !== undefined)) {
            collectionsCB.editCollection(modIds[0]);
          }
        }, 100);
      }, (modIds) => isEditableCollection(context.api.getState(), modIds));
      context.registerAction('mods-action-icons', 50, 'conflict', {}, 'Apply Collection Rules', (modIds) => {
        const state = context.api.getState();
        const gameId = vortex_api_1.selectors.activeGameId(state);
        context.api.events.emit('did-install-dependencies', gameId, modIds[0], false);
      }, (modIds) => {
        const state = context.api.getState();
        const gameId = vortex_api_1.selectors.activeGameId(state);
        const mod = state.persistent.mods[gameId][modIds[0]];
        if (mod === undefined) {
          return false;
        }
        return (mod.type === constants_1.MOD_TYPE);
      });
      context.registerAction('profile-actions', 150, 'highlight-lab', {}, 'Init Collection', (profileIds) => {
        (0, collectionCreate_1.initFromProfile)(context.api, profileIds[0])
          .catch(err => context.api.showErrorNotification('Failed to init collection', err));
      }, (profileIds) => !profileCollectionExists(context.api, profileIds[0]));
      context.registerAction('profile-actions', 150, 'highlight-lab', {}, 'Update Collection', (profileIds) => {
        (0, collectionCreate_1.initFromProfile)(context.api, profileIds[0])
          .catch(err => context.api.showErrorNotification('Failed to update collection', err));
      }, (profileIds) => profileCollectionExists(context.api, profileIds[0]));
      context.registerAction('mods-action-icons', 300, 'collection', {}, 'Add to Collection...', (instanceIds) => (0, collectionCreate_1.addCollectionAction)(context.api, instanceIds)
        .then(() => collectionChanged.schedule())
        .catch(err => context.api.showErrorNotification('failed to add mod to collection', err)), (instanceIds) => (0, collectionCreate_1.addCollectionCondition)(context.api, instanceIds));
      context.registerAction('mods-multirow-actions', 300, 'collection', {}, 'Add to Collection...', (instanceIds) => (0, collectionCreate_1.addCollectionAction)(context.api, instanceIds)
        .then(() => collectionChanged.schedule())
        .catch(err => context.api.showErrorNotification('failed to add mod to collection', err)), (instanceIds) => (0, collectionCreate_1.addCollectionCondition)(context.api, instanceIds));
      context.registerAction('mods-action-icons', 300, 'collection', {}, 'Remove from Collection...', (instanceIds) => (0, collectionCreate_1.removeCollectionAction)(context.api, instanceIds)
        .then(() => collectionChanged.schedule())
        .catch(err => context.api.showErrorNotification('failed to remove mod from collection', err)), (instanceIds) => (0, collectionCreate_1.removeCollectionCondition)(context.api, instanceIds));
      context.registerAction('mods-multirow-actions', 300, 'collection', {}, 'Remove from Collection...', (instanceIds) => (0, collectionCreate_1.removeCollectionAction)(context.api, instanceIds)
        .then(() => collectionChanged.schedule())
        .catch(err => context.api.showErrorNotification('failed to remove mod from collection', err)), (instanceIds) => (0, collectionCreate_1.removeCollectionCondition)(context.api, instanceIds));
      context.registerAttributeExtractor(100, genAttributeExtractor(context.api));
      context.registerInstaller('collection', 5, (0, util_1.bbProm)(collectionInstall_1.testSupported), (0, util_1.bbProm)((0, collectionInstall_1.makeInstall)(context.api)));
      context['registerCollectionFeature'] =
        (id, generate, parse, clone, title, condition, editComponent) => {
          (0, extension_1.addExtension)({ id, generate, parse, clone, condition, title, editComponent });
        };
      context.registerActionCheck('ADD_NOTIFICATION', (state, action) => {
        let _a, _b, _c;
        const notification = action['payload'];
        const ruleMatches = rule => { let _a; return rule.reference.tag === ((_a = notification.replace) === null || _a === void 0 ? void 0 : _a.tag); };
        let collection;
        if (((driver === null || driver === void 0 ? void 0 : driver.collection) !== undefined) && notification.id.startsWith('multiple-plugins-')) {
          if (driver.profile !== undefined) {
            collection = (_b = (_a = state.persistent.mods[driver.profile.gameId]) === null || _a === void 0 ? void 0 : _a[driver.collection.id]) !== null && _b !== void 0 ? _b : driver.collection;
          }
          else {
            collection = driver.collection;
          }
        }
        if (((_c = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _c !== void 0 ? _c : []).find(ruleMatches) !== undefined) {
          return false;
        }
        return undefined;
      });
    }
    async function triggerVoteNotification(api, revisionId, collectionSlug, revisionNumber) {
      if ((collectionSlug === undefined) || (revisionNumber === undefined)) {
        return Promise.resolve();
      }
      const revInfo = await driver.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber);
      if (!revInfo) {
        return Promise.resolve();
      }
      const sendRating = async (success) => {
        const vote = success ? 'positive' : 'negative';
        const voted = (await api.emitAndAwait('rate-nexus-collection-revision', parseInt(revisionId, 10), vote))[0];
        if (voted.success) {
          api.store.dispatch((0, persistent_1.updateSuccessRate)(revisionId, vote, voted.averageRating.average, voted.averageRating.total));
        }
      };
      return new Promise((resolve, reject) => {
        api.sendNotification({
          type: 'info',
          message: revInfo.collection.name,
          title: 'Did the Collection work for you?',
          noDismiss: true,
          actions: [
            {
              title: 'Yes',
              action: dismiss => {
                api.events.emit('analytics-track-click-event', 'Notifications', 'Success rating - Yes');
                sendRating(true);
                resolve();
                dismiss();
              },
            },
            {
              title: 'No',
              action: dismiss => {
                api.events.emit('analytics-track-click-event', 'Notifications', 'Success rating - No');
                sendRating(false);
                resolve();
                dismiss();
              },
            },
            {
              icon: 'close',
              action: dismiss => {
                api.events.emit('analytics-track-click-event', 'Notifications', 'Success rating - Dismiss');
                resolve();
                dismiss();
              },
            },
          ],
        });
      });
    }
    async function checkVoteRequest(api) {
      let _a;
      let elapsed = 0;
      const state = api.getState();
      const pendingVotes = (_a = state.persistent['collections'].pendingVotes) !== null && _a !== void 0 ? _a : {};
      const now = Date.now();
      for (const revisionId of Object.keys(pendingVotes)) {
        const pendingInfo = pendingVotes[revisionId];
        if (now - pendingInfo.time >= constants_1.TIME_BEFORE_VOTE) {
          await triggerVoteNotification(api, revisionId, pendingInfo.collectionSlug, pendingInfo.revisionNumber);
          api.store.dispatch((0, persistent_1.clearPendingVote)(revisionId));
        }
        else {
          elapsed = Math.max(elapsed, now - pendingInfo.time);
        }
      }
      return constants_1.TIME_BEFORE_VOTE - elapsed;
    }
    function once(api, collectionsCB) {
      const { store } = api;
      const applyCollectionModDefaults = new vortex_api_1.util.Debouncer(() => {
        const gameMode = vortex_api_1.selectors.activeGameId(state());
        const mods = vortex_api_1.util.getSafe(state(), ['persistent', 'mods', gameMode], {});
        const collectionIds = Object.keys(mods).filter(id => { let _a; return (((_a = mods[id]) === null || _a === void 0 ? void 0 : _a.type) === constants_1.MOD_TYPE); });
        const redActions = collectionIds.reduce((accum, id) => {
          let _a;
          const collection = mods[id];
          if ((collection === undefined) || (collection.attributes['editable'] !== true)) {
            return accum;
          }
          const collMods = ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
            .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
            .filter(rule => rule !== undefined);
          const action = (0, defaults_1.genDefaultsAction)(api, id, collMods, gameMode);
          if (action !== undefined) {
            accum.push(action);
          }
          return accum;
        }, []);
        if (redActions.length > 0) {
          vortex_api_1.util.batchDispatch(api.store, redActions);
        }
        return null;
      }, 1000);
      driver = new InstallDriver_1.default(api);
      driver.onUpdate(() => {
        if (driver.step === 'start') {
          driver.continue();
        }
        if (driver.step === 'review') {
          if (driver.collection === undefined)
            return;
          const gameId = driver.profile.gameId;
          const modId = driver.collection.id;
          api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'installCompleted', Date.now()));
        }
      });
      const doCheckVoteRequest = () => {
        checkVoteRequest(api)
          .then((nextCheck) => {
            setTimeout(doCheckVoteRequest, nextCheck);
          });
      };
      setTimeout(doCheckVoteRequest, constants_1.DELAY_FIRST_VOTE_REQUEST);
      api.setStylesheet('collections', path.join(__dirname, 'style.scss'));
      const state = () => store.getState();
      api.onStateChange(['persistent', 'mods'], (prev, cur) => {
        let _a, _b;
        const gameMode = vortex_api_1.selectors.activeGameId(api.getState());
        const prevG = (_a = prev[gameMode]) !== null && _a !== void 0 ? _a : {};
        const curG = (_b = cur[gameMode]) !== null && _b !== void 0 ? _b : {};
        const allIds = Array.from(new Set([].concat(Object.keys(prevG), Object.keys(curG))));
        const collections = allIds.filter(id => { let _a, _b; return (((_a = prevG[id]) === null || _a === void 0 ? void 0 : _a.type) === constants_1.MOD_TYPE) || (((_b = curG[id]) === null || _b === void 0 ? void 0 : _b.type) === constants_1.MOD_TYPE); });
        const changed = collections.find(modId => { let _a, _b, _c, _d; return (((_b = (_a = prevG[modId]) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.customFileName) !== ((_d = (_c = curG[modId]) === null || _c === void 0 ? void 0 : _c.attributes) === null || _d === void 0 ? void 0 : _d.customFileName)); });
        if (changed !== undefined) {
          collectionChangedCB === null || collectionChangedCB === void 0 ? void 0 : collectionChangedCB();
        }
        const foundRuleChanges = collections.find((id) => {
          let _a, _b, _c, _d, _e, _f;
          if (((_a = prevG[id]) === null || _a === void 0 ? void 0 : _a.rules) === ((_b = curG[id]) === null || _b === void 0 ? void 0 : _b.rules)) {
            return false;
          }
          const added = _.difference((_c = curG[id]) === null || _c === void 0 ? void 0 : _c.rules, (_d = prevG[id]) === null || _d === void 0 ? void 0 : _d.rules);
          const removed = _.difference((_e = prevG[id]) === null || _e === void 0 ? void 0 : _e.rules, (_f = curG[id]) === null || _f === void 0 ? void 0 : _f.rules);
          return (removed.length > 0) || (added.find(rule => ['requires', 'recommends'].includes(rule.type)) !== undefined);
        }) !== undefined;
        if (foundRuleChanges) {
          applyCollectionModDefaults.schedule();
          if (changed === undefined) {
            collectionChangedCB === null || collectionChangedCB === void 0 ? void 0 : collectionChangedCB();
          }
        }
      });
      api.events.on('did-dismiss-overlay', (overlayId, itemId) => {
        let _a, _b, _c;
        const OVERLAY_ID = 'collection-instructions-overlay';
        const state = api.getState();
        const { gameId } = (_a = driver.profile) !== null && _a !== void 0 ? _a : {};
        const mods = (_b = state.persistent.mods[gameId]) !== null && _b !== void 0 ? _b : {};
        if ((driver.lastCollection !== undefined)
            && (mods[driver.lastCollection.id] !== undefined)
            && (itemId !== undefined)
            && (state.settings.notifications.suppress[OVERLAY_ID] !== true)) {
          const collections = mods[driver.lastCollection.id];
          const match = ((_c = collections.rules) !== null && _c !== void 0 ? _c : [])
            .find(rule => (rule.type === 'requires') && (rule.reference.tag === itemId));
          if (match !== undefined) {
            api.showDialog('info', 'Mod instructions', {
              text: 'You can refer back to closed mod instructions at any time in the Instructions tab on '
                        + 'the Collections page.',
              checkboxes: [
                { id: 'dont_show_again', value: false, text: 'Don\'t show again' },
              ],
            }, [
              { label: 'Take me to instructions' },
              { label: 'Close' },
            ], OVERLAY_ID)
              .then((result) => {
                if (result.input['dont_show_again']) {
                  api.store.dispatch(vortex_api_1.actions.suppressNotification(OVERLAY_ID, true));
                }
                if (result.action === 'Take me to instructions') {
                  api.events.emit('show-main-page', 'Collections');
                  setTimeout(() => {
                    let _a, _b;
                    (_b = (_a = collectionsCB()).viewCollection) === null || _b === void 0 ? void 0 : _b.call(_a, driver.lastCollection.id);
                  }, 100);
                }
              })
              .catch(err => {
                (0, vortex_api_1.log)('warn', 'failed to show mod instructions suppress dialog', { error: err.message });
              });
          }
        }
      });
      api.events.on('did-install-mod', async (gameId, archiveId, modId) => {
        let _a, _b, _c;
        const profileId = vortex_api_1.selectors.lastActiveProfileForGame(state(), gameId);
        const profile = vortex_api_1.selectors.profileById(state(), profileId);
        if (profile === undefined) {
          return;
        }
        const mod = vortex_api_1.util.getSafe(state().persistent.mods, [gameId, modId], undefined);
        if (mod === undefined) {
          return;
        }
        if (mod.type === constants_1.MOD_TYPE) {
          if (driver.collection === undefined) {
            const awaitProfileSwitch = (_b = (_a = api.ext) === null || _a === void 0 ? void 0 : _a.awaitProfileSwitch) !== null && _b !== void 0 ? _b : (() => Promise.resolve());
            await awaitProfileSwitch();
            driver.query(profile, mod);
          }
          else {
            api.sendNotification({
              type: 'info',
              message: 'Collection can\'t be installed as another one is being installed already',
            });
          }
        }
        else if (driver.collection !== undefined) {
          const { collection, revisionId } = driver;
          const isDependency = ((_c = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _c !== void 0 ? _c : []).find(rule => {
            const validType = ['requires', 'recommends'].includes(rule.type);
            if (!validType) {
              return false;
            }
            const matchedRule = vortex_api_1.util.testModReference(mod, rule.reference);
            return matchedRule;
          }) !== undefined;
          if (isDependency) {
            const modRules = await driver.infoCache.getCollectionModRules(revisionId, collection, gameId);
            vortex_api_1.util.batchDispatch(api.store, (modRules !== null && modRules !== void 0 ? modRules : []).reduce((prev, rule) => {
              if (vortex_api_1.util.testModReference(mod, rule.source)) {
                prev.push(vortex_api_1.actions.addModRule(gameId, modId, {
                  type: rule.type,
                  reference: rule.reference,
                  extra: {
                    fromCollection: collection.id,
                  },
                }));
              }
              return prev;
            }, []));
          }
        }
      });
      api.onAsync('will-remove-mods', makeWillRemoveMods());
      api.onAsync('did-remove-mods', makeDidRemoveMods());
      api.onAsync('unfulfilled-rules', makeOnUnfulfilledRules(api));
      api.events.on('collection-update', (0, eventHandlers_1.onCollectionUpdate)(api, driver));
      api.events.on('did-finish-download', (dlId, outcome) => {
        if (outcome === 'finished') {
          const download = state().persistent.downloads.files[dlId];
          if (download === undefined) {
            return;
          }
        }
      });
      api.events.on('did-download-collection', async (dlId) => {
        let _a, _b, _c;
        try {
          const dlInfo = vortex_api_1.util.getSafe(state().persistent.downloads.files, [dlId], undefined);
          const profile = vortex_api_1.selectors.activeProfile(state());
          if ((profile === undefined) || (dlInfo === undefined)) {
            return;
          }
          if (!dlInfo.game.includes(profile.gameId)) {
            (0, vortex_api_1.log)('info', 'Collection downloaded for a different game than is being managed', { gameMode: profile.gameId, game: dlInfo.game });
            const expectedGame = vortex_api_1.util.getGame(dlInfo.game[0]);
            const actualGame = vortex_api_1.util.getGame(profile.gameId);
            api.sendNotification({
              message: '"{{collectionName}}" - This collection is intended for {{expectedGame}} '
                        + 'and cannot be installed to {{actualGame}}',
              type: 'info',
              replace: {
                collectionName: (_b = (_a = dlInfo.modInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : dlInfo.localPath,
                expectedGame: (_c = expectedGame === null || expectedGame === void 0 ? void 0 : expectedGame.name) !== null && _c !== void 0 ? _c : api.translate('an unsupported game'),
                actualGame: actualGame.name,
              },
            });
            return;
          }
          else {
            await vortex_api_1.util.toPromise(cb => api.events.emit('start-install-download', dlId, {
              allowAutoEnable: false,
            }, cb));
          }
        }
        catch (err) {
          if (!(err instanceof vortex_api_1.util.UserCanceled)) {
            api.showErrorNotification('Failed to add collection', err, {
              allowReport: !(err instanceof vortex_api_1.util.ProcessCanceled),
            });
          }
        }
      });
      api.events.on('view-collection', (modId, tabId) => {
        api.events.emit('show-main-page', 'Collections');
        setTimeout(() => {
          let _a, _b, _c, _d;
          (_b = (_a = collectionsCB()).viewCollection) === null || _b === void 0 ? void 0 : _b.call(_a, modId);
          (_d = (_c = collectionsCB()).viewCollectionTab) === null || _d === void 0 ? void 0 : _d.call(_c, tabId);
        }, 100);
      });
      api.events.on('edit-collection', (modId) => {
        api.events.emit('show-main-page', 'Collections');
        setTimeout(() => {
          let _a, _b;
          (_b = (_a = collectionsCB()).editCollection) === null || _b === void 0 ? void 0 : _b.call(_a, modId);
        }, 100);
      });
      api.events.on('resume-collection', (gameId, modId) => {
        let _a;
        const state = api.getState();
        const profileId = vortex_api_1.selectors.lastActiveProfileForGame(state, gameId);
        const profile = state.persistent.profiles[profileId];
        const mod = (_a = state.persistent.mods[gameId]) === null || _a === void 0 ? void 0 : _a[modId];
        (0, vortex_api_1.log)('info', 'resume collection', { gameId, modId, archiveId: mod === null || mod === void 0 ? void 0 : mod.archiveId });
        driver.start(profile, mod);
      });
      api.onStateChange(['persistent', 'collections', 'collections'], (prev, cur) => {
        const state = api.getState();
        const changedIds = Object.keys(cur).filter(id => { let _a; return cur[id].info !== ((_a = prev[id]) === null || _a === void 0 ? void 0 : _a.info); });
        const knownGames = vortex_api_1.selectors.knownGames(state);
        const { mods } = state.persistent;
        changedIds.forEach(collId => {
          const coll = cur[collId].info;
          const gameId = vortex_api_1.util.convertGameIdReverse(knownGames, coll.game.domainName);
          const collModId = Object.keys(mods[gameId])
            .find(modId => mods[gameId][modId].attributes['collectionId'] === coll.id);
          if ((collModId !== undefined) && !mods[gameId][collModId].attributes.editable) {
            const newestVersion = coll.revisions
              .filter(rev => rev.revisionStatus === 'published')
              .sort((lhs, rhs) => rhs.revisionNumber - lhs.revisionNumber);
            if (newestVersion.length > 0) {
              api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, collModId, 'newestVersion', newestVersion[0].revisionNumber.toString()));
            }
          }
        });
      });
      vortex_api_1.util.installIconSet('collections', path.join(__dirname, 'icons.svg'))
        .catch(err => api.showErrorNotification('failed to install icon set', err));
      const iconPath = path.join(__dirname, 'collectionicon.svg');
      document.getElementById('content').style
        .setProperty('--collection-icon', `url(${(0, url_1.pathToFileURL)(iconPath).href})`);
      const updateOwnCollectionsCB = (gameId) => api.emitAndAwait('get-my-collections', gameId)
        .then(result => {
          let _a;
          localState.ownCollections = (_a = result[0]) !== null && _a !== void 0 ? _a : [];
        });
      api.events.on('gamemode-activated', updateOwnCollectionsCB);
      api.onStateChange(['persistent', 'nexus', 'userInfo'], (prev, cur) => {
        const gameMode = vortex_api_1.selectors.activeGameId(api.getState());
        updateOwnCollectionsCB(gameMode);
      });
      driver.infoCache.clearCache();
    }
    const pathTool = {
      relative: path.relative,
    };
    function init(context) {
      const collectionsCB = {};
      register(context, collectionsCB);
      (0, initweaks_1.default)(context);
      (0, tools_1.default)(context);
      context.once(() => {
        once(context.api, () => collectionsCB);
      });
      return true;
    }
    exports["default"] = init;

  })();

  module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=bundledPlugins/collections/modpacks.js.map