/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/bail/index.js":
/*!****************************************!*\
  !*** ../../node_modules/bail/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


module.exports = bail

function bail(err) {
  if (err) {
    throw err
  }
}


/***/ }),

/***/ "../../node_modules/comma-separated-tokens/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/comma-separated-tokens/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.parse = parse
exports.stringify = stringify

var comma = ','
var space = ' '
var empty = ''

// Parse comma-separated tokens to an array.
function parse(value) {
  var values = []
  var input = String(value || empty)
  var index = input.indexOf(comma)
  var lastIndex = 0
  var end = false
  var val

  while (!end) {
    if (index === -1) {
      index = input.length
      end = true
    }

    val = input.slice(lastIndex, index).trim()

    if (val || !end) {
      values.push(val)
    }

    lastIndex = index + 1
    index = input.indexOf(comma, lastIndex)
  }

  return values
}

// Compile an array to comma-separated tokens.
// `options.padLeft` (default: `true`) pads a space left of each token, and
// `options.padRight` (default: `false`) pads a space to the right of each token.
function stringify(values, options) {
  var settings = options || {}
  var left = settings.padLeft === false ? empty : space
  var right = settings.padRight ? space : empty

  // Ensure the last empty entry is seen.
  if (values[values.length - 1] === empty) {
    values = values.concat(empty)
  }

  return values.join(right + comma + left).trim()
}


/***/ }),

/***/ "../../node_modules/extend/index.js":
/*!******************************************!*\
  !*** ../../node_modules/extend/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};


/***/ }),

/***/ "../../node_modules/inline-style-parser/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/inline-style-parser/index.js ***!
  \*******************************************************/
/***/ ((module) => {

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;

var NEWLINE_REGEX = /\n/g;
var WHITESPACE_REGEX = /^\s*/;

// declaration
var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var COLON_REGEX = /^:\s*/;
var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var SEMICOLON_REGEX = /^[;\s]*/;

// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
var TRIM_REGEX = /^\s+|\s+$/g;

// strings
var NEWLINE = '\n';
var FORWARD_SLASH = '/';
var ASTERISK = '*';
var EMPTY_STRING = '';

// types
var TYPE_COMMENT = 'comment';
var TYPE_DECLARATION = 'declaration';

/**
 * @param {String} style
 * @param {Object} [options]
 * @return {Object[]}
 * @throws {TypeError}
 * @throws {Error}
 */
module.exports = function(style, options) {
  if (typeof style !== 'string') {
    throw new TypeError('First argument must be a string');
  }

  if (!style) return [];

  options = options || {};

  /**
   * Positional.
   */
  var lineno = 1;
  var column = 1;

  /**
   * Update lineno and column based on `str`.
   *
   * @param {String} str
   */
  function updatePosition(str) {
    var lines = str.match(NEWLINE_REGEX);
    if (lines) lineno += lines.length;
    var i = str.lastIndexOf(NEWLINE);
    column = ~i ? str.length - i : column + str.length;
  }

  /**
   * Mark position and patch `node.position`.
   *
   * @return {Function}
   */
  function position() {
    var start = { line: lineno, column: column };
    return function(node) {
      node.position = new Position(start);
      whitespace();
      return node;
    };
  }

  /**
   * Store position information for a node.
   *
   * @constructor
   * @property {Object} start
   * @property {Object} end
   * @property {undefined|String} source
   */
  function Position(start) {
    this.start = start;
    this.end = { line: lineno, column: column };
    this.source = options.source;
  }

  /**
   * Non-enumerable source string.
   */
  Position.prototype.content = style;

  var errorsList = [];

  /**
   * Error `msg`.
   *
   * @param {String} msg
   * @throws {Error}
   */
  function error(msg) {
    var err = new Error(
      options.source + ':' + lineno + ':' + column + ': ' + msg
    );
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = style;

    if (options.silent) {
      errorsList.push(err);
    } else {
      throw err;
    }
  }

  /**
   * Match `re` and return captures.
   *
   * @param {RegExp} re
   * @return {undefined|Array}
   */
  function match(re) {
    var m = re.exec(style);
    if (!m) return;
    var str = m[0];
    updatePosition(str);
    style = style.slice(str.length);
    return m;
  }

  /**
   * Parse whitespace.
   */
  function whitespace() {
    match(WHITESPACE_REGEX);
  }

  /**
   * Parse comments.
   *
   * @param {Object[]} [rules]
   * @return {Object[]}
   */
  function comments(rules) {
    var c;
    rules = rules || [];
    while ((c = comment())) {
      if (c !== false) {
        rules.push(c);
      }
    }
    return rules;
  }

  /**
   * Parse comment.
   *
   * @return {Object}
   * @throws {Error}
   */
  function comment() {
    var pos = position();
    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;

    var i = 2;
    while (
      EMPTY_STRING != style.charAt(i) &&
      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))
    ) {
      ++i;
    }
    i += 2;

    if (EMPTY_STRING === style.charAt(i - 1)) {
      return error('End of comment missing');
    }

    var str = style.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    style = style.slice(i);
    column += 2;

    return pos({
      type: TYPE_COMMENT,
      comment: str
    });
  }

  /**
   * Parse declaration.
   *
   * @return {Object}
   * @throws {Error}
   */
  function declaration() {
    var pos = position();

    // prop
    var prop = match(PROPERTY_REGEX);
    if (!prop) return;
    comment();

    // :
    if (!match(COLON_REGEX)) return error("property missing ':'");

    // val
    var val = match(VALUE_REGEX);

    var ret = pos({
      type: TYPE_DECLARATION,
      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
      value: val
        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))
        : EMPTY_STRING
    });

    // ;
    match(SEMICOLON_REGEX);

    return ret;
  }

  /**
   * Parse declarations.
   *
   * @return {Object[]}
   */
  function declarations() {
    var decls = [];

    comments(decls);

    // declarations
    var decl;
    while ((decl = declaration())) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }

    return decls;
  }

  whitespace();
  return declarations();
};

/**
 * Trim `str`.
 *
 * @param {String} str
 * @return {String}
 */
function trim(str) {
  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}


/***/ }),

/***/ "../../node_modules/is-plain-obj/index.js":
/*!************************************************!*\
  !*** ../../node_modules/is-plain-obj/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = value => {
	if (Object.prototype.toString.call(value) !== '[object Object]') {
		return false;
	}

	const prototype = Object.getPrototypeOf(value);
	return prototype === null || prototype === Object.prototype;
};


/***/ }),

/***/ "../../node_modules/mdast-util-definitions/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/mdast-util-definitions/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var visit = __webpack_require__(/*! unist-util-visit */ "../../node_modules/unist-util-visit/index.js")

module.exports = getDefinitionFactory

var own = {}.hasOwnProperty

// Get a definition in `node` by `identifier`.
function getDefinitionFactory(node, options) {
  return getterFactory(gather(node, options))
}

// Gather all definitions in `node`
function gather(node) {
  var cache = {}

  if (!node || !node.type) {
    throw new Error('mdast-util-definitions expected node')
  }

  visit(node, 'definition', ondefinition)

  return cache

  function ondefinition(definition) {
    var id = normalise(definition.identifier)
    if (!own.call(cache, id)) {
      cache[id] = definition
    }
  }
}

// Factory to get a node from the given definition-cache.
function getterFactory(cache) {
  return getter

  // Get a node from the bound definition-cache.
  function getter(identifier) {
    var id = identifier && normalise(identifier)
    return id && own.call(cache, id) ? cache[id] : null
  }
}

function normalise(identifier) {
  return identifier.toUpperCase()
}


/***/ }),

/***/ "../../node_modules/mdast-util-from-markdown/dist/index.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/mdast-util-from-markdown/dist/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = fromMarkdown

// These three are compiled away in the `dist/`

var toString = __webpack_require__(/*! mdast-util-to-string */ "../../node_modules/mdast-util-to-string/index.js")
var assign = __webpack_require__(/*! micromark/dist/constant/assign */ "../../node_modules/micromark/dist/constant/assign.js")
var own = __webpack_require__(/*! micromark/dist/constant/has-own-property */ "../../node_modules/micromark/dist/constant/has-own-property.js")
var normalizeIdentifier = __webpack_require__(/*! micromark/dist/util/normalize-identifier */ "../../node_modules/micromark/dist/util/normalize-identifier.js")
var safeFromInt = __webpack_require__(/*! micromark/dist/util/safe-from-int */ "../../node_modules/micromark/dist/util/safe-from-int.js")
var parser = __webpack_require__(/*! micromark/dist/parse */ "../../node_modules/micromark/dist/parse.js")
var preprocessor = __webpack_require__(/*! micromark/dist/preprocess */ "../../node_modules/micromark/dist/preprocess.js")
var postprocess = __webpack_require__(/*! micromark/dist/postprocess */ "../../node_modules/micromark/dist/postprocess.js")
var decode = __webpack_require__(/*! parse-entities/decode-entity */ "../../node_modules/parse-entities/decode-entity.browser.js")
var stringifyPosition = __webpack_require__(/*! unist-util-stringify-position */ "../../node_modules/unist-util-stringify-position/index.js")

function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== 'string') {
    options = encoding
    encoding = undefined
  }

  return compiler(options)(
    postprocess(
      parser(options).document().write(preprocessor()(value, encoding, true))
    )
  )
}

// Note this compiler only understand complete buffering, not streaming.
function compiler(options) {
  var settings = options || {}
  var config = configure(
    {
      transforms: [],
      canContainEols: [
        'emphasis',
        'fragment',
        'heading',
        'paragraph',
        'strong'
      ],

      enter: {
        autolink: opener(link),
        autolinkProtocol: onenterdata,
        autolinkEmail: onenterdata,
        atxHeading: opener(heading),
        blockQuote: opener(blockQuote),
        characterEscape: onenterdata,
        characterReference: onenterdata,
        codeFenced: opener(codeFlow),
        codeFencedFenceInfo: buffer,
        codeFencedFenceMeta: buffer,
        codeIndented: opener(codeFlow, buffer),
        codeText: opener(codeText, buffer),
        codeTextData: onenterdata,
        data: onenterdata,
        codeFlowValue: onenterdata,
        definition: opener(definition),
        definitionDestinationString: buffer,
        definitionLabelString: buffer,
        definitionTitleString: buffer,
        emphasis: opener(emphasis),
        hardBreakEscape: opener(hardBreak),
        hardBreakTrailing: opener(hardBreak),
        htmlFlow: opener(html, buffer),
        htmlFlowData: onenterdata,
        htmlText: opener(html, buffer),
        htmlTextData: onenterdata,
        image: opener(image),
        label: buffer,
        link: opener(link),
        listItem: opener(listItem),
        listItemValue: onenterlistitemvalue,
        listOrdered: opener(list, onenterlistordered),
        listUnordered: opener(list),
        paragraph: opener(paragraph),
        reference: onenterreference,
        referenceString: buffer,
        resourceDestinationString: buffer,
        resourceTitleString: buffer,
        setextHeading: opener(heading),
        strong: opener(strong),
        thematicBreak: opener(thematicBreak)
      },

      exit: {
        atxHeading: closer(),
        atxHeadingSequence: onexitatxheadingsequence,
        autolink: closer(),
        autolinkEmail: onexitautolinkemail,
        autolinkProtocol: onexitautolinkprotocol,
        blockQuote: closer(),
        characterEscapeValue: onexitdata,
        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
        characterReferenceValue: onexitcharacterreferencevalue,
        codeFenced: closer(onexitcodefenced),
        codeFencedFence: onexitcodefencedfence,
        codeFencedFenceInfo: onexitcodefencedfenceinfo,
        codeFencedFenceMeta: onexitcodefencedfencemeta,
        codeFlowValue: onexitdata,
        codeIndented: closer(onexitcodeindented),
        codeText: closer(onexitcodetext),
        codeTextData: onexitdata,
        data: onexitdata,
        definition: closer(),
        definitionDestinationString: onexitdefinitiondestinationstring,
        definitionLabelString: onexitdefinitionlabelstring,
        definitionTitleString: onexitdefinitiontitlestring,
        emphasis: closer(),
        hardBreakEscape: closer(onexithardbreak),
        hardBreakTrailing: closer(onexithardbreak),
        htmlFlow: closer(onexithtmlflow),
        htmlFlowData: onexitdata,
        htmlText: closer(onexithtmltext),
        htmlTextData: onexitdata,
        image: closer(onexitimage),
        label: onexitlabel,
        labelText: onexitlabeltext,
        lineEnding: onexitlineending,
        link: closer(onexitlink),
        listItem: closer(),
        listOrdered: closer(),
        listUnordered: closer(),
        paragraph: closer(),
        referenceString: onexitreferencestring,
        resourceDestinationString: onexitresourcedestinationstring,
        resourceTitleString: onexitresourcetitlestring,
        resource: onexitresource,
        setextHeading: closer(onexitsetextheading),
        setextHeadingLineSequence: onexitsetextheadinglinesequence,
        setextHeadingText: onexitsetextheadingtext,
        strong: closer(),
        thematicBreak: closer()
      }
    },

    settings.mdastExtensions || []
  )

  var data = {}

  return compile

  function compile(events) {
    var tree = {type: 'root', children: []}
    var stack = [tree]
    var tokenStack = []
    var listStack = []
    var index = -1
    var handler
    var listStart

    var context = {
      stack: stack,
      tokenStack: tokenStack,
      config: config,
      enter: enter,
      exit: exit,
      buffer: buffer,
      resume: resume,
      setData: setData,
      getData: getData
    }

    while (++index < events.length) {
      // We preprocess lists to add `listItem` tokens, and to infer whether
      // items the list itself are spread out.
      if (
        events[index][1].type === 'listOrdered' ||
        events[index][1].type === 'listUnordered'
      ) {
        if (events[index][0] === 'enter') {
          listStack.push(index)
        } else {
          listStart = listStack.pop(index)
          index = prepareList(events, listStart, index)
        }
      }
    }

    index = -1

    while (++index < events.length) {
      handler = config[events[index][0]]

      if (own.call(handler, events[index][1].type)) {
        handler[events[index][1].type].call(
          assign({sliceSerialize: events[index][2].sliceSerialize}, context),
          events[index][1]
        )
      }
    }

    if (tokenStack.length) {
      throw new Error(
        'Cannot close document, a token (`' +
          tokenStack[tokenStack.length - 1].type +
          '`, ' +
          stringifyPosition({
            start: tokenStack[tokenStack.length - 1].start,
            end: tokenStack[tokenStack.length - 1].end
          }) +
          ') is still open'
      )
    }

    // Figure out `root` position.
    tree.position = {
      start: point(
        events.length ? events[0][1].start : {line: 1, column: 1, offset: 0}
      ),

      end: point(
        events.length
          ? events[events.length - 2][1].end
          : {line: 1, column: 1, offset: 0}
      )
    }

    index = -1
    while (++index < config.transforms.length) {
      tree = config.transforms[index](tree) || tree
    }

    return tree
  }

  function prepareList(events, start, length) {
    var index = start - 1
    var containerBalance = -1
    var listSpread = false
    var listItem
    var tailIndex
    var lineIndex
    var tailEvent
    var event
    var firstBlankLineIndex
    var atMarker

    while (++index <= length) {
      event = events[index]

      if (
        event[1].type === 'listUnordered' ||
        event[1].type === 'listOrdered' ||
        event[1].type === 'blockQuote'
      ) {
        if (event[0] === 'enter') {
          containerBalance++
        } else {
          containerBalance--
        }

        atMarker = undefined
      } else if (event[1].type === 'lineEndingBlank') {
        if (event[0] === 'enter') {
          if (
            listItem &&
            !atMarker &&
            !containerBalance &&
            !firstBlankLineIndex
          ) {
            firstBlankLineIndex = index
          }

          atMarker = undefined
        }
      } else if (
        event[1].type === 'linePrefix' ||
        event[1].type === 'listItemValue' ||
        event[1].type === 'listItemMarker' ||
        event[1].type === 'listItemPrefix' ||
        event[1].type === 'listItemPrefixWhitespace'
      ) {
        // Empty.
      } else {
        atMarker = undefined
      }

      if (
        (!containerBalance &&
          event[0] === 'enter' &&
          event[1].type === 'listItemPrefix') ||
        (containerBalance === -1 &&
          event[0] === 'exit' &&
          (event[1].type === 'listUnordered' ||
            event[1].type === 'listOrdered'))
      ) {
        if (listItem) {
          tailIndex = index
          lineIndex = undefined

          while (tailIndex--) {
            tailEvent = events[tailIndex]

            if (
              tailEvent[1].type === 'lineEnding' ||
              tailEvent[1].type === 'lineEndingBlank'
            ) {
              if (tailEvent[0] === 'exit') continue

              if (lineIndex) {
                events[lineIndex][1].type = 'lineEndingBlank'
                listSpread = true
              }

              tailEvent[1].type = 'lineEnding'
              lineIndex = tailIndex
            } else if (
              tailEvent[1].type === 'linePrefix' ||
              tailEvent[1].type === 'blockQuotePrefix' ||
              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||
              tailEvent[1].type === 'blockQuoteMarker' ||
              tailEvent[1].type === 'listItemIndent'
            ) {
              // Empty
            } else {
              break
            }
          }

          if (
            firstBlankLineIndex &&
            (!lineIndex || firstBlankLineIndex < lineIndex)
          ) {
            listItem._spread = true
          }

          // Fix position.
          listItem.end = point(
            lineIndex ? events[lineIndex][1].start : event[1].end
          )

          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])
          index++
          length++
        }

        // Create a new list item.
        if (event[1].type === 'listItemPrefix') {
          listItem = {
            type: 'listItem',
            _spread: false,
            start: point(event[1].start)
          }

          events.splice(index, 0, ['enter', listItem, event[2]])
          index++
          length++
          firstBlankLineIndex = undefined
          atMarker = true
        }
      }
    }

    events[start][1]._spread = listSpread
    return length
  }

  function setData(key, value) {
    data[key] = value
  }

  function getData(key) {
    return data[key]
  }

  function point(d) {
    return {line: d.line, column: d.column, offset: d.offset}
  }

  function opener(create, and) {
    return open

    function open(token) {
      enter.call(this, create(token), token)
      if (and) and.call(this, token)
    }
  }

  function buffer() {
    this.stack.push({type: 'fragment', children: []})
  }

  function enter(node, token) {
    this.stack[this.stack.length - 1].children.push(node)
    this.stack.push(node)
    this.tokenStack.push(token)
    node.position = {start: point(token.start)}
    return node
  }

  function closer(and) {
    return close

    function close(token) {
      if (and) and.call(this, token)
      exit.call(this, token)
    }
  }

  function exit(token) {
    var node = this.stack.pop()
    var open = this.tokenStack.pop()

    if (!open) {
      throw new Error(
        'Cannot close `' +
          token.type +
          '` (' +
          stringifyPosition({start: token.start, end: token.end}) +
          '): it’s not open'
      )
    } else if (open.type !== token.type) {
      throw new Error(
        'Cannot close `' +
          token.type +
          '` (' +
          stringifyPosition({start: token.start, end: token.end}) +
          '): a different token (`' +
          open.type +
          '`, ' +
          stringifyPosition({start: open.start, end: open.end}) +
          ') is open'
      )
    }

    node.position.end = point(token.end)
    return node
  }

  function resume() {
    return toString(this.stack.pop())
  }

  //
  // Handlers.
  //

  function onenterlistordered() {
    setData('expectingFirstListItemValue', true)
  }

  function onenterlistitemvalue(token) {
    if (getData('expectingFirstListItemValue')) {
      this.stack[this.stack.length - 2].start = parseInt(
        this.sliceSerialize(token),
        10
      )

      setData('expectingFirstListItemValue')
    }
  }

  function onexitcodefencedfenceinfo() {
    var data = this.resume()
    this.stack[this.stack.length - 1].lang = data
  }

  function onexitcodefencedfencemeta() {
    var data = this.resume()
    this.stack[this.stack.length - 1].meta = data
  }

  function onexitcodefencedfence() {
    // Exit if this is the closing fence.
    if (getData('flowCodeInside')) return
    this.buffer()
    setData('flowCodeInside', true)
  }

  function onexitcodefenced() {
    var data = this.resume()
    this.stack[this.stack.length - 1].value = data.replace(
      /^(\r?\n|\r)|(\r?\n|\r)$/g,
      ''
    )

    setData('flowCodeInside')
  }

  function onexitcodeindented() {
    var data = this.resume()
    this.stack[this.stack.length - 1].value = data
  }

  function onexitdefinitionlabelstring(token) {
    // Discard label, use the source content instead.
    var label = this.resume()
    this.stack[this.stack.length - 1].label = label
    this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase()
  }

  function onexitdefinitiontitlestring() {
    var data = this.resume()
    this.stack[this.stack.length - 1].title = data
  }

  function onexitdefinitiondestinationstring() {
    var data = this.resume()
    this.stack[this.stack.length - 1].url = data
  }

  function onexitatxheadingsequence(token) {
    if (!this.stack[this.stack.length - 1].depth) {
      this.stack[this.stack.length - 1].depth = this.sliceSerialize(
        token
      ).length
    }
  }

  function onexitsetextheadingtext() {
    setData('setextHeadingSlurpLineEnding', true)
  }

  function onexitsetextheadinglinesequence(token) {
    this.stack[this.stack.length - 1].depth =
      this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2
  }

  function onexitsetextheading() {
    setData('setextHeadingSlurpLineEnding')
  }

  function onenterdata(token) {
    var siblings = this.stack[this.stack.length - 1].children
    var tail = siblings[siblings.length - 1]

    if (!tail || tail.type !== 'text') {
      // Add a new text node.
      tail = text()
      tail.position = {start: point(token.start)}
      this.stack[this.stack.length - 1].children.push(tail)
    }

    this.stack.push(tail)
  }

  function onexitdata(token) {
    var tail = this.stack.pop()
    tail.value += this.sliceSerialize(token)
    tail.position.end = point(token.end)
  }

  function onexitlineending(token) {
    var context = this.stack[this.stack.length - 1]

    // If we’re at a hard break, include the line ending in there.
    if (getData('atHardBreak')) {
      context.children[context.children.length - 1].position.end = point(
        token.end
      )

      setData('atHardBreak')
      return
    }

    if (
      !getData('setextHeadingSlurpLineEnding') &&
      config.canContainEols.indexOf(context.type) > -1
    ) {
      onenterdata.call(this, token)
      onexitdata.call(this, token)
    }
  }

  function onexithardbreak() {
    setData('atHardBreak', true)
  }

  function onexithtmlflow() {
    var data = this.resume()
    this.stack[this.stack.length - 1].value = data
  }

  function onexithtmltext() {
    var data = this.resume()
    this.stack[this.stack.length - 1].value = data
  }

  function onexitcodetext() {
    var data = this.resume()
    this.stack[this.stack.length - 1].value = data
  }

  function onexitlink() {
    var context = this.stack[this.stack.length - 1]

    // To do: clean.
    if (getData('inReference')) {
      context.type += 'Reference'
      context.referenceType = getData('referenceType') || 'shortcut'
      delete context.url
      delete context.title
    } else {
      delete context.identifier
      delete context.label
      delete context.referenceType
    }

    setData('referenceType')
  }

  function onexitimage() {
    var context = this.stack[this.stack.length - 1]

    // To do: clean.
    if (getData('inReference')) {
      context.type += 'Reference'
      context.referenceType = getData('referenceType') || 'shortcut'
      delete context.url
      delete context.title
    } else {
      delete context.identifier
      delete context.label
      delete context.referenceType
    }

    setData('referenceType')
  }

  function onexitlabeltext(token) {
    this.stack[this.stack.length - 2].identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase()
  }

  function onexitlabel() {
    var fragment = this.stack[this.stack.length - 1]
    var value = this.resume()

    this.stack[this.stack.length - 1].label = value

    // Assume a reference.
    setData('inReference', true)

    if (this.stack[this.stack.length - 1].type === 'link') {
      this.stack[this.stack.length - 1].children = fragment.children
    } else {
      this.stack[this.stack.length - 1].alt = value
    }
  }

  function onexitresourcedestinationstring() {
    var data = this.resume()
    this.stack[this.stack.length - 1].url = data
  }

  function onexitresourcetitlestring() {
    var data = this.resume()
    this.stack[this.stack.length - 1].title = data
  }

  function onexitresource() {
    setData('inReference')
  }

  function onenterreference() {
    setData('referenceType', 'collapsed')
  }

  function onexitreferencestring(token) {
    var label = this.resume()
    this.stack[this.stack.length - 1].label = label
    this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase()
    setData('referenceType', 'full')
  }

  function onexitcharacterreferencemarker(token) {
    setData('characterReferenceType', token.type)
  }

  function onexitcharacterreferencevalue(token) {
    var data = this.sliceSerialize(token)
    var type = getData('characterReferenceType')
    var value
    var tail

    if (type) {
      value = safeFromInt(
        data,
        type === 'characterReferenceMarkerNumeric' ? 10 : 16
      )

      setData('characterReferenceType')
    } else {
      value = decode(data)
    }

    tail = this.stack.pop()
    tail.value += value
    tail.position.end = point(token.end)
  }

  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token)
    this.stack[this.stack.length - 1].url = this.sliceSerialize(token)
  }

  function onexitautolinkemail(token) {
    onexitdata.call(this, token)
    this.stack[this.stack.length - 1].url =
      'mailto:' + this.sliceSerialize(token)
  }

  //
  // Creaters.
  //

  function blockQuote() {
    return {type: 'blockquote', children: []}
  }

  function codeFlow() {
    return {type: 'code', lang: null, meta: null, value: ''}
  }

  function codeText() {
    return {type: 'inlineCode', value: ''}
  }

  function definition() {
    return {
      type: 'definition',
      identifier: '',
      label: null,
      title: null,
      url: ''
    }
  }

  function emphasis() {
    return {type: 'emphasis', children: []}
  }

  function heading() {
    return {type: 'heading', depth: undefined, children: []}
  }

  function hardBreak() {
    return {type: 'break'}
  }

  function html() {
    return {type: 'html', value: ''}
  }

  function image() {
    return {type: 'image', title: null, url: '', alt: null}
  }

  function link() {
    return {type: 'link', title: null, url: '', children: []}
  }

  function list(token) {
    return {
      type: 'list',
      ordered: token.type === 'listOrdered',
      start: null,
      spread: token._spread,
      children: []
    }
  }

  function listItem(token) {
    return {
      type: 'listItem',
      spread: token._spread,
      checked: null,
      children: []
    }
  }

  function paragraph() {
    return {type: 'paragraph', children: []}
  }

  function strong() {
    return {type: 'strong', children: []}
  }

  function text() {
    return {type: 'text', value: ''}
  }

  function thematicBreak() {
    return {type: 'thematicBreak'}
  }
}

function configure(config, extensions) {
  var index = -1

  while (++index < extensions.length) {
    extension(config, extensions[index])
  }

  return config
}

function extension(config, extension) {
  var key
  var left

  for (key in extension) {
    left = own.call(config, key) ? config[key] : (config[key] = {})

    if (key === 'canContainEols' || key === 'transforms') {
      config[key] = [].concat(left, extension[key])
    } else {
      Object.assign(left, extension[key])
    }
  }
}


/***/ }),

/***/ "../../node_modules/mdast-util-from-markdown/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/mdast-util-from-markdown/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! ./dist */ "../../node_modules/mdast-util-from-markdown/dist/index.js")


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(/*! ./lib */ "../../node_modules/mdast-util-to-hast/lib/index.js")


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/all.js":
/*!********************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/all.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = all

var one = __webpack_require__(/*! ./one */ "../../node_modules/mdast-util-to-hast/lib/one.js")

function all(h, parent) {
  var nodes = parent.children || []
  var length = nodes.length
  var values = []
  var index = -1
  var result
  var head

  while (++index < length) {
    result = one(h, nodes[index], parent)

    if (result) {
      if (index && nodes[index - 1].type === 'break') {
        if (result.value) {
          result.value = result.value.replace(/^\s+/, '')
        }

        head = result.children && result.children[0]

        if (head && head.value) {
          head.value = head.value.replace(/^\s+/, '')
        }
      }

      values = values.concat(result)
    }
  }

  return values
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/footer.js":
/*!***********************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/footer.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = generateFootnotes

var thematicBreak = __webpack_require__(/*! ./handlers/thematic-break */ "../../node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js")
var list = __webpack_require__(/*! ./handlers/list */ "../../node_modules/mdast-util-to-hast/lib/handlers/list.js")
var wrap = __webpack_require__(/*! ./wrap */ "../../node_modules/mdast-util-to-hast/lib/wrap.js")

function generateFootnotes(h) {
  var footnoteById = h.footnoteById
  var footnoteOrder = h.footnoteOrder
  var length = footnoteOrder.length
  var index = -1
  var listItems = []
  var def
  var backReference
  var content
  var tail

  while (++index < length) {
    def = footnoteById[footnoteOrder[index].toUpperCase()]

    if (!def) {
      continue
    }

    content = def.children.concat()
    tail = content[content.length - 1]
    backReference = {
      type: 'link',
      url: '#fnref-' + def.identifier,
      data: {hProperties: {className: ['footnote-backref']}},
      children: [{type: 'text', value: '↩'}]
    }

    if (!tail || tail.type !== 'paragraph') {
      tail = {type: 'paragraph', children: []}
      content.push(tail)
    }

    tail.children.push(backReference)

    listItems.push({
      type: 'listItem',
      data: {hProperties: {id: 'fn-' + def.identifier}},
      children: content,
      position: def.position
    })
  }

  if (listItems.length === 0) {
    return null
  }

  return h(
    null,
    'div',
    {className: ['footnotes']},
    wrap(
      [
        thematicBreak(h),
        list(h, {type: 'list', ordered: true, children: listItems})
      ],
      true
    )
  )
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/blockquote.js":
/*!************************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/blockquote.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = blockquote

var wrap = __webpack_require__(/*! ../wrap */ "../../node_modules/mdast-util-to-hast/lib/wrap.js")
var all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

function blockquote(h, node) {
  return h(node, 'blockquote', wrap(all(h, node), true))
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/break.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/break.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = hardBreak

var u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

function hardBreak(h, node) {
  return [h(node, 'br'), u('text', '\n')]
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/code.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/code.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = code

var u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

function code(h, node) {
  var value = node.value ? node.value + '\n' : ''
  // To do: next major, use `node.lang` w/o regex, the splitting’s been going
  // on for years in remark now.
  var lang = node.lang && node.lang.match(/^[^ \t]+(?=[ \t]|$)/)
  var props = {}
  var code

  if (lang) {
    props.className = ['language-' + lang]
  }

  code = h(node, 'code', props, [u('text', value)])

  if (node.meta) {
    code.data = {meta: node.meta}
  }

  return h(node.position, 'pre', [code])
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/delete.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/delete.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = strikethrough

var all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

function strikethrough(h, node) {
  return h(node, 'del', all(h, node))
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/emphasis.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/emphasis.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = emphasis

var all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

function emphasis(h, node) {
  return h(node, 'em', all(h, node))
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = footnoteReference

var u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

function footnoteReference(h, node) {
  var footnoteOrder = h.footnoteOrder
  var identifier = String(node.identifier)

  if (footnoteOrder.indexOf(identifier) === -1) {
    footnoteOrder.push(identifier)
  }

  return h(node.position, 'sup', {id: 'fnref-' + identifier}, [
    h(node, 'a', {href: '#fn-' + identifier, className: ['footnote-ref']}, [
      u('text', node.label || identifier)
    ])
  ])
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/footnote.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/footnote.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = footnote

var footnoteReference = __webpack_require__(/*! ./footnote-reference */ "../../node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js")

function footnote(h, node) {
  var footnoteById = h.footnoteById
  var footnoteOrder = h.footnoteOrder
  var identifier = 1

  while (identifier in footnoteById) {
    identifier++
  }

  identifier = String(identifier)

  // No need to check if `identifier` exists in `footnoteOrder`, it’s guaranteed
  // to not exist because we just generated it.
  footnoteOrder.push(identifier)

  footnoteById[identifier] = {
    type: 'footnoteDefinition',
    identifier: identifier,
    children: [{type: 'paragraph', children: node.children}],
    position: node.position
  }

  return footnoteReference(h, {
    type: 'footnoteReference',
    identifier: identifier,
    position: node.position
  })
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/heading.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/heading.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = heading

var all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

function heading(h, node) {
  return h(node, 'h' + node.depth, all(h, node))
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/html.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/html.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = html

var u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

// Return either a `raw` node in dangerous mode, otherwise nothing.
function html(h, node) {
  return h.dangerous ? h.augment(node, u('raw', node.value)) : null
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/image-reference.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/image-reference.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = imageReference

var normalize = __webpack_require__(/*! mdurl/encode */ "../../node_modules/mdurl/encode.js")
var revert = __webpack_require__(/*! ../revert */ "../../node_modules/mdast-util-to-hast/lib/revert.js")

function imageReference(h, node) {
  var def = h.definition(node.identifier)
  var props

  if (!def) {
    return revert(h, node)
  }

  props = {src: normalize(def.url || ''), alt: node.alt}

  if (def.title !== null && def.title !== undefined) {
    props.title = def.title
  }

  return h(node, 'img', props)
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/image.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/image.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var normalize = __webpack_require__(/*! mdurl/encode */ "../../node_modules/mdurl/encode.js")

module.exports = image

function image(h, node) {
  var props = {src: normalize(node.url), alt: node.alt}

  if (node.title !== null && node.title !== undefined) {
    props.title = node.title
  }

  return h(node, 'img', props)
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/index.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/index.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  blockquote: __webpack_require__(/*! ./blockquote */ "../../node_modules/mdast-util-to-hast/lib/handlers/blockquote.js"),
  break: __webpack_require__(/*! ./break */ "../../node_modules/mdast-util-to-hast/lib/handlers/break.js"),
  code: __webpack_require__(/*! ./code */ "../../node_modules/mdast-util-to-hast/lib/handlers/code.js"),
  delete: __webpack_require__(/*! ./delete */ "../../node_modules/mdast-util-to-hast/lib/handlers/delete.js"),
  emphasis: __webpack_require__(/*! ./emphasis */ "../../node_modules/mdast-util-to-hast/lib/handlers/emphasis.js"),
  footnoteReference: __webpack_require__(/*! ./footnote-reference */ "../../node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js"),
  footnote: __webpack_require__(/*! ./footnote */ "../../node_modules/mdast-util-to-hast/lib/handlers/footnote.js"),
  heading: __webpack_require__(/*! ./heading */ "../../node_modules/mdast-util-to-hast/lib/handlers/heading.js"),
  html: __webpack_require__(/*! ./html */ "../../node_modules/mdast-util-to-hast/lib/handlers/html.js"),
  imageReference: __webpack_require__(/*! ./image-reference */ "../../node_modules/mdast-util-to-hast/lib/handlers/image-reference.js"),
  image: __webpack_require__(/*! ./image */ "../../node_modules/mdast-util-to-hast/lib/handlers/image.js"),
  inlineCode: __webpack_require__(/*! ./inline-code */ "../../node_modules/mdast-util-to-hast/lib/handlers/inline-code.js"),
  linkReference: __webpack_require__(/*! ./link-reference */ "../../node_modules/mdast-util-to-hast/lib/handlers/link-reference.js"),
  link: __webpack_require__(/*! ./link */ "../../node_modules/mdast-util-to-hast/lib/handlers/link.js"),
  listItem: __webpack_require__(/*! ./list-item */ "../../node_modules/mdast-util-to-hast/lib/handlers/list-item.js"),
  list: __webpack_require__(/*! ./list */ "../../node_modules/mdast-util-to-hast/lib/handlers/list.js"),
  paragraph: __webpack_require__(/*! ./paragraph */ "../../node_modules/mdast-util-to-hast/lib/handlers/paragraph.js"),
  root: __webpack_require__(/*! ./root */ "../../node_modules/mdast-util-to-hast/lib/handlers/root.js"),
  strong: __webpack_require__(/*! ./strong */ "../../node_modules/mdast-util-to-hast/lib/handlers/strong.js"),
  table: __webpack_require__(/*! ./table */ "../../node_modules/mdast-util-to-hast/lib/handlers/table.js"),
  text: __webpack_require__(/*! ./text */ "../../node_modules/mdast-util-to-hast/lib/handlers/text.js"),
  thematicBreak: __webpack_require__(/*! ./thematic-break */ "../../node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js"),
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
}

// Return nothing for nodes that are ignored.
function ignore() {
  return null
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/inline-code.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/inline-code.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = inlineCode

var u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

function inlineCode(h, node) {
  var value = node.value.replace(/\r?\n|\r/g, ' ')
  return h(node, 'code', [u('text', value)])
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/link-reference.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/link-reference.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = linkReference

var normalize = __webpack_require__(/*! mdurl/encode */ "../../node_modules/mdurl/encode.js")
var revert = __webpack_require__(/*! ../revert */ "../../node_modules/mdast-util-to-hast/lib/revert.js")
var all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

function linkReference(h, node) {
  var def = h.definition(node.identifier)
  var props

  if (!def) {
    return revert(h, node)
  }

  props = {href: normalize(def.url || '')}

  if (def.title !== null && def.title !== undefined) {
    props.title = def.title
  }

  return h(node, 'a', props, all(h, node))
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/link.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/link.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var normalize = __webpack_require__(/*! mdurl/encode */ "../../node_modules/mdurl/encode.js")
var all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

module.exports = link

function link(h, node) {
  var props = {href: normalize(node.url)}

  if (node.title !== null && node.title !== undefined) {
    props.title = node.title
  }

  return h(node, 'a', props, all(h, node))
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/list-item.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/list-item.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = listItem

var u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")
var all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

function listItem(h, node, parent) {
  var result = all(h, node)
  var head = result[0]
  var loose = parent ? listLoose(parent) : listItemLoose(node)
  var props = {}
  var wrapped = []
  var length
  var index
  var child

  if (typeof node.checked === 'boolean') {
    if (!head || head.tagName !== 'p') {
      head = h(null, 'p', [])
      result.unshift(head)
    }

    if (head.children.length > 0) {
      head.children.unshift(u('text', ' '))
    }

    head.children.unshift(
      h(null, 'input', {
        type: 'checkbox',
        checked: node.checked,
        disabled: true
      })
    )

    // According to github-markdown-css, this class hides bullet.
    // See: <https://github.com/sindresorhus/github-markdown-css>.
    props.className = ['task-list-item']
  }

  length = result.length
  index = -1

  while (++index < length) {
    child = result[index]

    // Add eols before nodes, except if this is a loose, first paragraph.
    if (loose || index !== 0 || child.tagName !== 'p') {
      wrapped.push(u('text', '\n'))
    }

    if (child.tagName === 'p' && !loose) {
      wrapped = wrapped.concat(child.children)
    } else {
      wrapped.push(child)
    }
  }

  // Add a final eol.
  if (length && (loose || child.tagName !== 'p')) {
    wrapped.push(u('text', '\n'))
  }

  return h(node, 'li', props, wrapped)
}

function listLoose(node) {
  var loose = node.spread
  var children = node.children
  var length = children.length
  var index = -1

  while (!loose && ++index < length) {
    loose = listItemLoose(children[index])
  }

  return loose
}

function listItemLoose(node) {
  var spread = node.spread

  return spread === undefined || spread === null
    ? node.children.length > 1
    : spread
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/list.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/list.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = list

var wrap = __webpack_require__(/*! ../wrap */ "../../node_modules/mdast-util-to-hast/lib/wrap.js")
var all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

function list(h, node) {
  var props = {}
  var name = node.ordered ? 'ol' : 'ul'
  var items
  var index = -1
  var length

  if (typeof node.start === 'number' && node.start !== 1) {
    props.start = node.start
  }

  items = all(h, node)
  length = items.length

  // Like GitHub, add a class for custom styling.
  while (++index < length) {
    if (
      items[index].properties.className &&
      items[index].properties.className.indexOf('task-list-item') !== -1
    ) {
      props.className = ['contains-task-list']
      break
    }
  }

  return h(node, name, props, wrap(items, true))
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/paragraph.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/paragraph.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = paragraph

var all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

function paragraph(h, node) {
  return h(node, 'p', all(h, node))
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/root.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/root.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = root

var u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")
var wrap = __webpack_require__(/*! ../wrap */ "../../node_modules/mdast-util-to-hast/lib/wrap.js")
var all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

function root(h, node) {
  return h.augment(node, u('root', wrap(all(h, node))))
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/strong.js":
/*!********************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/strong.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = strong

var all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

function strong(h, node) {
  return h(node, 'strong', all(h, node))
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/table.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/table.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = table

var position = __webpack_require__(/*! unist-util-position */ "../../node_modules/unist-util-position/index.js")
var wrap = __webpack_require__(/*! ../wrap */ "../../node_modules/mdast-util-to-hast/lib/wrap.js")
var all = __webpack_require__(/*! ../all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

function table(h, node) {
  var rows = node.children
  var index = rows.length
  var align = node.align || []
  var alignLength = align.length
  var result = []
  var pos
  var row
  var out
  var name
  var cell

  while (index--) {
    row = rows[index].children
    name = index === 0 ? 'th' : 'td'
    pos = alignLength || row.length
    out = []

    while (pos--) {
      cell = row[pos]
      out[pos] = h(cell, name, {align: align[pos]}, cell ? all(h, cell) : [])
    }

    result[index] = h(rows[index], 'tr', wrap(out, true))
  }

  return h(
    node,
    'table',
    wrap(
      [h(result[0].position, 'thead', wrap([result[0]], true))].concat(
        result[1]
          ? h(
              {
                start: position.start(result[1]),
                end: position.end(result[result.length - 1])
              },
              'tbody',
              wrap(result.slice(1), true)
            )
          : []
      ),
      true
    )
  )
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/text.js":
/*!******************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/text.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = text

var u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

function text(h, node) {
  return h.augment(
    node,
    u('text', String(node.value).replace(/[ \t]*(\r?\n|\r)[ \t]*/g, '$1'))
  )
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = thematicBreak

function thematicBreak(h, node) {
  return h(node, 'hr')
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = toHast

var u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")
var visit = __webpack_require__(/*! unist-util-visit */ "../../node_modules/unist-util-visit/index.js")
var position = __webpack_require__(/*! unist-util-position */ "../../node_modules/unist-util-position/index.js")
var generated = __webpack_require__(/*! unist-util-generated */ "../../node_modules/unist-util-generated/index.js")
var definitions = __webpack_require__(/*! mdast-util-definitions */ "../../node_modules/mdast-util-definitions/index.js")
var one = __webpack_require__(/*! ./one */ "../../node_modules/mdast-util-to-hast/lib/one.js")
var footer = __webpack_require__(/*! ./footer */ "../../node_modules/mdast-util-to-hast/lib/footer.js")
var handlers = __webpack_require__(/*! ./handlers */ "../../node_modules/mdast-util-to-hast/lib/handlers/index.js")

var own = {}.hasOwnProperty

var deprecationWarningIssued = false

// Factory to transform.
function factory(tree, options) {
  var settings = options || {}

  // Issue a warning if the deprecated tag 'allowDangerousHTML' is used
  if (settings.allowDangerousHTML !== undefined && !deprecationWarningIssued) {
    deprecationWarningIssued = true
    console.warn(
      'mdast-util-to-hast: deprecation: `allowDangerousHTML` is nonstandard, use `allowDangerousHtml` instead'
    )
  }

  var dangerous = settings.allowDangerousHtml || settings.allowDangerousHTML
  var footnoteById = {}

  h.dangerous = dangerous
  h.definition = definitions(tree)
  h.footnoteById = footnoteById
  h.footnoteOrder = []
  h.augment = augment
  h.handlers = Object.assign({}, handlers, settings.handlers)
  h.unknownHandler = settings.unknownHandler
  h.passThrough = settings.passThrough

  visit(tree, 'footnoteDefinition', onfootnotedefinition)

  return h

  // Finalise the created `right`, a hast node, from `left`, an mdast node.
  function augment(left, right) {
    var data
    var ctx

    // Handle `data.hName`, `data.hProperties, `data.hChildren`.
    if (left && left.data) {
      data = left.data

      if (data.hName) {
        if (right.type !== 'element') {
          right = {
            type: 'element',
            tagName: '',
            properties: {},
            children: []
          }
        }

        right.tagName = data.hName
      }

      if (right.type === 'element' && data.hProperties) {
        right.properties = Object.assign({}, right.properties, data.hProperties)
      }

      if (right.children && data.hChildren) {
        right.children = data.hChildren
      }
    }

    ctx = left && left.position ? left : {position: left}

    if (!generated(ctx)) {
      right.position = {
        start: position.start(ctx),
        end: position.end(ctx)
      }
    }

    return right
  }

  // Create an element for `node`.
  function h(node, tagName, props, children) {
    if (
      (children === undefined || children === null) &&
      typeof props === 'object' &&
      'length' in props
    ) {
      children = props
      props = {}
    }

    return augment(node, {
      type: 'element',
      tagName: tagName,
      properties: props || {},
      children: children || []
    })
  }

  function onfootnotedefinition(definition) {
    var id = String(definition.identifier).toUpperCase()

    // Mimick CM behavior of link definitions.
    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.
    if (!own.call(footnoteById, id)) {
      footnoteById[id] = definition
    }
  }
}

// Transform `tree`, which is an mdast node, to a hast node.
function toHast(tree, options) {
  var h = factory(tree, options)
  var node = one(h, tree)
  var foot = footer(h)

  if (foot) {
    node.children = node.children.concat(u('text', '\n'), foot)
  }

  return node
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/one.js":
/*!********************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/one.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = one

var u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")
var all = __webpack_require__(/*! ./all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

var own = {}.hasOwnProperty

// Transform an unknown node.
function unknown(h, node) {
  if (text(node)) {
    return h.augment(node, u('text', node.value))
  }

  return h(node, 'div', all(h, node))
}

// Visit a node.
function one(h, node, parent) {
  var type = node && node.type
  var fn

  // Fail on non-nodes.
  if (!type) {
    throw new Error('Expected node, got `' + node + '`')
  }

  if (own.call(h.handlers, type)) {
    fn = h.handlers[type]
  } else if (h.passThrough && h.passThrough.indexOf(type) > -1) {
    fn = returnNode
  } else {
    fn = h.unknownHandler
  }

  return (typeof fn === 'function' ? fn : unknown)(h, node, parent)
}

// Check if the node should be renderered as a text node.
function text(node) {
  var data = node.data || {}

  if (
    own.call(data, 'hName') ||
    own.call(data, 'hProperties') ||
    own.call(data, 'hChildren')
  ) {
    return false
  }

  return 'value' in node
}

function returnNode(h, node) {
  var clone

  if (node.children) {
    clone = Object.assign({}, node)
    clone.children = all(h, node)
    return clone
  }

  return node
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/revert.js":
/*!***********************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/revert.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = revert

var u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")
var all = __webpack_require__(/*! ./all */ "../../node_modules/mdast-util-to-hast/lib/all.js")

// Return the content of a reference without definition as Markdown.
function revert(h, node) {
  var subtype = node.referenceType
  var suffix = ']'
  var contents
  var head
  var tail

  if (subtype === 'collapsed') {
    suffix += '[]'
  } else if (subtype === 'full') {
    suffix += '[' + (node.label || node.identifier) + ']'
  }

  if (node.type === 'imageReference') {
    return u('text', '![' + node.alt + suffix)
  }

  contents = all(h, node)
  head = contents[0]

  if (head && head.type === 'text') {
    head.value = '[' + head.value
  } else {
    contents.unshift(u('text', '['))
  }

  tail = contents[contents.length - 1]

  if (tail && tail.type === 'text') {
    tail.value += suffix
  } else {
    contents.push(u('text', suffix))
  }

  return contents
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-hast/lib/wrap.js":
/*!*********************************************************!*\
  !*** ../../node_modules/mdast-util-to-hast/lib/wrap.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = wrap

var u = __webpack_require__(/*! unist-builder */ "../../node_modules/unist-builder/index.js")

// Wrap `nodes` with line feeds between each entry.
// Optionally adds line feeds at the start and end.
function wrap(nodes, loose) {
  var result = []
  var index = -1
  var length = nodes.length

  if (loose) {
    result.push(u('text', '\n'))
  }

  while (++index < length) {
    if (index) {
      result.push(u('text', '\n'))
    }

    result.push(nodes[index])
  }

  if (loose && nodes.length > 0) {
    result.push(u('text', '\n'))
  }

  return result
}


/***/ }),

/***/ "../../node_modules/mdast-util-to-string/index.js":
/*!********************************************************!*\
  !*** ../../node_modules/mdast-util-to-string/index.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


module.exports = toString

// Get the text content of a node.
// Prefer the node’s plain-text fields, otherwise serialize its children,
// and if the given value is an array, serialize the nodes in it.
function toString(node) {
  return (
    (node &&
      (node.value ||
        node.alt ||
        node.title ||
        ('children' in node && all(node.children)) ||
        ('length' in node && all(node)))) ||
    ''
  )
}

function all(values) {
  var result = []
  var index = -1

  while (++index < values.length) {
    result[index] = toString(values[index])
  }

  return result.join('')
}


/***/ }),

/***/ "../../node_modules/mdurl/encode.js":
/*!******************************************!*\
  !*** ../../node_modules/mdurl/encode.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";




var encodeCache = {};


// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) { return cache; }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}


// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i, l, code, nextCode, cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped  = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";


module.exports = encode;


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-alpha.js":
/*!******************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-alpha.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

var asciiAlpha = regexCheck(/[A-Za-z]/)

module.exports = asciiAlpha


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-alphanumeric.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-alphanumeric.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/)

module.exports = asciiAlphanumeric


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-atext.js":
/*!******************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-atext.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/)

module.exports = asciiAtext


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-control.js":
/*!********************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-control.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


// Note: EOF is seen as ASCII control here, because `null < 32 == true`.
function asciiControl(code) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code < 32 || code === 127
  )
}

module.exports = asciiControl


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-digit.js":
/*!******************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-digit.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

var asciiDigit = regexCheck(/\d/)

module.exports = asciiDigit


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-hex-digit.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-hex-digit.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

var asciiHexDigit = regexCheck(/[\dA-Fa-f]/)

module.exports = asciiHexDigit


/***/ }),

/***/ "../../node_modules/micromark/dist/character/ascii-punctuation.js":
/*!************************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/ascii-punctuation.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)

module.exports = asciiPunctuation


/***/ }),

/***/ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";


function markdownLineEndingOrSpace(code) {
  return code < 0 || code === 32
}

module.exports = markdownLineEndingOrSpace


/***/ }),

/***/ "../../node_modules/micromark/dist/character/markdown-line-ending.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/markdown-line-ending.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";


function markdownLineEnding(code) {
  return code < -2
}

module.exports = markdownLineEnding


/***/ }),

/***/ "../../node_modules/micromark/dist/character/markdown-space.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/markdown-space.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


function markdownSpace(code) {
  return code === -2 || code === -1 || code === 32
}

module.exports = markdownSpace


/***/ }),

/***/ "../../node_modules/micromark/dist/character/unicode-punctuation.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/unicode-punctuation.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var unicodePunctuationRegex = __webpack_require__(/*! ../constant/unicode-punctuation-regex.js */ "../../node_modules/micromark/dist/constant/unicode-punctuation-regex.js")
var regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

// In fact adds to the bundle size.

var unicodePunctuation = regexCheck(unicodePunctuationRegex)

module.exports = unicodePunctuation


/***/ }),

/***/ "../../node_modules/micromark/dist/character/unicode-whitespace.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/micromark/dist/character/unicode-whitespace.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexCheck = __webpack_require__(/*! ../util/regex-check.js */ "../../node_modules/micromark/dist/util/regex-check.js")

var unicodeWhitespace = regexCheck(/\s/)

module.exports = unicodeWhitespace


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/assign.js":
/*!************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/assign.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


var assign = Object.assign

module.exports = assign


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/from-char-code.js":
/*!********************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/from-char-code.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var fromCharCode = String.fromCharCode

module.exports = fromCharCode


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/has-own-property.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/has-own-property.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


var own = {}.hasOwnProperty

module.exports = own


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/html-block-names.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/html-block-names.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


// This module is copied from <https://spec.commonmark.org/0.29/#html-blocks>.
var basics = [
  'address',
  'article',
  'aside',
  'base',
  'basefont',
  'blockquote',
  'body',
  'caption',
  'center',
  'col',
  'colgroup',
  'dd',
  'details',
  'dialog',
  'dir',
  'div',
  'dl',
  'dt',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'frame',
  'frameset',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hr',
  'html',
  'iframe',
  'legend',
  'li',
  'link',
  'main',
  'menu',
  'menuitem',
  'nav',
  'noframes',
  'ol',
  'optgroup',
  'option',
  'p',
  'param',
  'section',
  'source',
  'summary',
  'table',
  'tbody',
  'td',
  'tfoot',
  'th',
  'thead',
  'title',
  'tr',
  'track',
  'ul'
]

module.exports = basics


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/html-raw-names.js":
/*!********************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/html-raw-names.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


// This module is copied from <https://spec.commonmark.org/0.29/#html-blocks>.
var raws = ['pre', 'script', 'style', 'textarea']

module.exports = raws


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/splice.js":
/*!************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/splice.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


var splice = [].splice

module.exports = splice


/***/ }),

/***/ "../../node_modules/micromark/dist/constant/unicode-punctuation-regex.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/micromark/dist/constant/unicode-punctuation-regex.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";


// This module is generated by `script/`.
//
// CommonMark handles attention (emphasis, strong) markers based on what comes
// before or after them.
// One such difference is if those characters are Unicode punctuation.
// This script is generated from the Unicode data.
var unicodePunctuation = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/

module.exports = unicodePunctuation


/***/ }),

/***/ "../../node_modules/micromark/dist/constructs.js":
/*!*******************************************************!*\
  !*** ../../node_modules/micromark/dist/constructs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({value: true}))

var text$1 = __webpack_require__(/*! ./initialize/text.js */ "../../node_modules/micromark/dist/initialize/text.js")
var attention = __webpack_require__(/*! ./tokenize/attention.js */ "../../node_modules/micromark/dist/tokenize/attention.js")
var autolink = __webpack_require__(/*! ./tokenize/autolink.js */ "../../node_modules/micromark/dist/tokenize/autolink.js")
var blockQuote = __webpack_require__(/*! ./tokenize/block-quote.js */ "../../node_modules/micromark/dist/tokenize/block-quote.js")
var characterEscape = __webpack_require__(/*! ./tokenize/character-escape.js */ "../../node_modules/micromark/dist/tokenize/character-escape.js")
var characterReference = __webpack_require__(/*! ./tokenize/character-reference.js */ "../../node_modules/micromark/dist/tokenize/character-reference.js")
var codeFenced = __webpack_require__(/*! ./tokenize/code-fenced.js */ "../../node_modules/micromark/dist/tokenize/code-fenced.js")
var codeIndented = __webpack_require__(/*! ./tokenize/code-indented.js */ "../../node_modules/micromark/dist/tokenize/code-indented.js")
var codeText = __webpack_require__(/*! ./tokenize/code-text.js */ "../../node_modules/micromark/dist/tokenize/code-text.js")
var definition = __webpack_require__(/*! ./tokenize/definition.js */ "../../node_modules/micromark/dist/tokenize/definition.js")
var hardBreakEscape = __webpack_require__(/*! ./tokenize/hard-break-escape.js */ "../../node_modules/micromark/dist/tokenize/hard-break-escape.js")
var headingAtx = __webpack_require__(/*! ./tokenize/heading-atx.js */ "../../node_modules/micromark/dist/tokenize/heading-atx.js")
var htmlFlow = __webpack_require__(/*! ./tokenize/html-flow.js */ "../../node_modules/micromark/dist/tokenize/html-flow.js")
var htmlText = __webpack_require__(/*! ./tokenize/html-text.js */ "../../node_modules/micromark/dist/tokenize/html-text.js")
var labelEnd = __webpack_require__(/*! ./tokenize/label-end.js */ "../../node_modules/micromark/dist/tokenize/label-end.js")
var labelStartImage = __webpack_require__(/*! ./tokenize/label-start-image.js */ "../../node_modules/micromark/dist/tokenize/label-start-image.js")
var labelStartLink = __webpack_require__(/*! ./tokenize/label-start-link.js */ "../../node_modules/micromark/dist/tokenize/label-start-link.js")
var lineEnding = __webpack_require__(/*! ./tokenize/line-ending.js */ "../../node_modules/micromark/dist/tokenize/line-ending.js")
var list = __webpack_require__(/*! ./tokenize/list.js */ "../../node_modules/micromark/dist/tokenize/list.js")
var setextUnderline = __webpack_require__(/*! ./tokenize/setext-underline.js */ "../../node_modules/micromark/dist/tokenize/setext-underline.js")
var thematicBreak = __webpack_require__(/*! ./tokenize/thematic-break.js */ "../../node_modules/micromark/dist/tokenize/thematic-break.js")

var document = {
  42: list,
  // Asterisk
  43: list,
  // Plus sign
  45: list,
  // Dash
  48: list,
  // 0
  49: list,
  // 1
  50: list,
  // 2
  51: list,
  // 3
  52: list,
  // 4
  53: list,
  // 5
  54: list,
  // 6
  55: list,
  // 7
  56: list,
  // 8
  57: list,
  // 9
  62: blockQuote // Greater than
}
var contentInitial = {
  91: definition // Left square bracket
}
var flowInitial = {
  '-2': codeIndented,
  // Horizontal tab
  '-1': codeIndented,
  // Virtual space
  32: codeIndented // Space
}
var flow = {
  35: headingAtx,
  // Number sign
  42: thematicBreak,
  // Asterisk
  45: [setextUnderline, thematicBreak],
  // Dash
  60: htmlFlow,
  // Less than
  61: setextUnderline,
  // Equals to
  95: thematicBreak,
  // Underscore
  96: codeFenced,
  // Grave accent
  126: codeFenced // Tilde
}
var string = {
  38: characterReference,
  // Ampersand
  92: characterEscape // Backslash
}
var text = {
  '-5': lineEnding,
  // Carriage return
  '-4': lineEnding,
  // Line feed
  '-3': lineEnding,
  // Carriage return + line feed
  33: labelStartImage,
  // Exclamation mark
  38: characterReference,
  // Ampersand
  42: attention,
  // Asterisk
  60: [autolink, htmlText],
  // Less than
  91: labelStartLink,
  // Left square bracket
  92: [hardBreakEscape, characterEscape],
  // Backslash
  93: labelEnd,
  // Right square bracket
  95: attention,
  // Underscore
  96: codeText // Grave accent
}
var insideSpan = {
  null: [attention, text$1.resolver]
}
var disable = {
  null: []
}

exports.contentInitial = contentInitial
exports.disable = disable
exports.document = document
exports.flow = flow
exports.flowInitial = flowInitial
exports.insideSpan = insideSpan
exports.string = string
exports.text = text


/***/ }),

/***/ "../../node_modules/micromark/dist/initialize/content.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/initialize/content.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({value: true}))

var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var factorySpace = __webpack_require__(/*! ../tokenize/factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

var tokenize = initializeContent

function initializeContent(effects) {
  var contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  )
  var previous
  return contentStart

  function afterContentStartConstruct(code) {
    if (code === null) {
      effects.consume(code)
      return
    }

    effects.enter('lineEnding')
    effects.consume(code)
    effects.exit('lineEnding')
    return factorySpace(effects, contentStart, 'linePrefix')
  }

  function paragraphInitial(code) {
    effects.enter('paragraph')
    return lineStart(code)
  }

  function lineStart(code) {
    var token = effects.enter('chunkText', {
      contentType: 'text',
      previous: previous
    })

    if (previous) {
      previous.next = token
    }

    previous = token
    return data(code)
  }

  function data(code) {
    if (code === null) {
      effects.exit('chunkText')
      effects.exit('paragraph')
      effects.consume(code)
      return
    }

    if (markdownLineEnding(code)) {
      effects.consume(code)
      effects.exit('chunkText')
      return lineStart
    } // Data.

    effects.consume(code)
    return data
  }
}

exports.tokenize = tokenize


/***/ }),

/***/ "../../node_modules/micromark/dist/initialize/document.js":
/*!****************************************************************!*\
  !*** ../../node_modules/micromark/dist/initialize/document.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({value: true}))

var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var factorySpace = __webpack_require__(/*! ../tokenize/factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")
var partialBlankLine = __webpack_require__(/*! ../tokenize/partial-blank-line.js */ "../../node_modules/micromark/dist/tokenize/partial-blank-line.js")

var tokenize = initializeDocument
var containerConstruct = {
  tokenize: tokenizeContainer
}
var lazyFlowConstruct = {
  tokenize: tokenizeLazyFlow
}

function initializeDocument(effects) {
  var self = this
  var stack = []
  var continued = 0
  var inspectConstruct = {
    tokenize: tokenizeInspect,
    partial: true
  }
  var inspectResult
  var childFlow
  var childToken
  return start

  function start(code) {
    if (continued < stack.length) {
      self.containerState = stack[continued][1]
      return effects.attempt(
        stack[continued][0].continuation,
        documentContinue,
        documentContinued
      )(code)
    }

    return documentContinued(code)
  }

  function documentContinue(code) {
    continued++
    return start(code)
  }

  function documentContinued(code) {
    // If we’re in a concrete construct (such as when expecting another line of
    // HTML, or we resulted in lazy content), we can immediately start flow.
    if (inspectResult && inspectResult.flowContinue) {
      return flowStart(code)
    }

    self.interrupt =
      childFlow &&
      childFlow.currentConstruct &&
      childFlow.currentConstruct.interruptible
    self.containerState = {}
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code)
  }

  function containerContinue(code) {
    stack.push([self.currentConstruct, self.containerState])
    self.containerState = undefined
    return documentContinued(code)
  }

  function flowStart(code) {
    if (code === null) {
      exitContainers(0, true)
      effects.consume(code)
      return
    }

    childFlow = childFlow || self.parser.flow(self.now())
    effects.enter('chunkFlow', {
      contentType: 'flow',
      previous: childToken,
      _tokenizer: childFlow
    })
    return flowContinue(code)
  }

  function flowContinue(code) {
    if (code === null) {
      continueFlow(effects.exit('chunkFlow'))
      return flowStart(code)
    }

    if (markdownLineEnding(code)) {
      effects.consume(code)
      continueFlow(effects.exit('chunkFlow'))
      return effects.check(inspectConstruct, documentAfterPeek)
    }

    effects.consume(code)
    return flowContinue
  }

  function documentAfterPeek(code) {
    exitContainers(
      inspectResult.continued,
      inspectResult && inspectResult.flowEnd
    )
    continued = 0
    return start(code)
  }

  function continueFlow(token) {
    if (childToken) childToken.next = token
    childToken = token
    childFlow.lazy = inspectResult && inspectResult.lazy
    childFlow.defineSkip(token.start)
    childFlow.write(self.sliceStream(token))
  }

  function exitContainers(size, end) {
    var index = stack.length // Close the flow.

    if (childFlow && end) {
      childFlow.write([null])
      childToken = childFlow = undefined
    } // Exit open containers.

    while (index-- > size) {
      self.containerState = stack[index][1]
      stack[index][0].exit.call(self, effects)
    }

    stack.length = size
  }

  function tokenizeInspect(effects, ok) {
    var subcontinued = 0
    inspectResult = {}
    return inspectStart

    function inspectStart(code) {
      if (subcontinued < stack.length) {
        self.containerState = stack[subcontinued][1]
        return effects.attempt(
          stack[subcontinued][0].continuation,
          inspectContinue,
          inspectLess
        )(code)
      } // If we’re continued but in a concrete flow, we can’t have more
      // containers.

      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        inspectResult.flowContinue = true
        return inspectDone(code)
      }

      self.interrupt =
        childFlow.currentConstruct && childFlow.currentConstruct.interruptible
      self.containerState = {}
      return effects.attempt(
        containerConstruct,
        inspectFlowEnd,
        inspectDone
      )(code)
    }

    function inspectContinue(code) {
      subcontinued++
      return self.containerState._closeFlow
        ? inspectFlowEnd(code)
        : inspectStart(code)
    }

    function inspectLess(code) {
      if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {
        // Maybe another container?
        self.containerState = {}
        return effects.attempt(
          containerConstruct,
          inspectFlowEnd, // Maybe flow, or a blank line?
          effects.attempt(
            lazyFlowConstruct,
            inspectFlowEnd,
            effects.check(partialBlankLine, inspectFlowEnd, inspectLazy)
          )
        )(code)
      } // Otherwise we’re interrupting.

      return inspectFlowEnd(code)
    }

    function inspectLazy(code) {
      // Act as if all containers are continued.
      subcontinued = stack.length
      inspectResult.lazy = true
      inspectResult.flowContinue = true
      return inspectDone(code)
    } // We’re done with flow if we have more containers, or an interruption.

    function inspectFlowEnd(code) {
      inspectResult.flowEnd = true
      return inspectDone(code)
    }

    function inspectDone(code) {
      inspectResult.continued = subcontinued
      self.interrupt = self.containerState = undefined
      return ok(code)
    }
  }
}

function tokenizeContainer(effects, ok, nok) {
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok, nok),
    'linePrefix',
    this.parser.constructs.disable.null.indexOf('codeIndented') > -1
      ? undefined
      : 4
  )
}

function tokenizeLazyFlow(effects, ok, nok) {
  return factorySpace(
    effects,
    effects.lazy(this.parser.constructs.flow, ok, nok),
    'linePrefix',
    this.parser.constructs.disable.null.indexOf('codeIndented') > -1
      ? undefined
      : 4
  )
}

exports.tokenize = tokenize


/***/ }),

/***/ "../../node_modules/micromark/dist/initialize/flow.js":
/*!************************************************************!*\
  !*** ../../node_modules/micromark/dist/initialize/flow.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({value: true}))

var content = __webpack_require__(/*! ../tokenize/content.js */ "../../node_modules/micromark/dist/tokenize/content.js")
var factorySpace = __webpack_require__(/*! ../tokenize/factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")
var partialBlankLine = __webpack_require__(/*! ../tokenize/partial-blank-line.js */ "../../node_modules/micromark/dist/tokenize/partial-blank-line.js")

var tokenize = initializeFlow

function initializeFlow(effects) {
  var self = this
  var initial = effects.attempt(
    // Try to parse a blank line.
    partialBlankLine,
    atBlankEnding, // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content, afterConstruct)
        ),
        'linePrefix'
      )
    )
  )
  return initial

  function atBlankEnding(code) {
    if (code === null) {
      effects.consume(code)
      return
    }

    effects.enter('lineEndingBlank')
    effects.consume(code)
    effects.exit('lineEndingBlank')
    self.currentConstruct = undefined
    return initial
  }

  function afterConstruct(code) {
    if (code === null) {
      effects.consume(code)
      return
    }

    effects.enter('lineEnding')
    effects.consume(code)
    effects.exit('lineEnding')
    self.currentConstruct = undefined
    return initial
  }
}

exports.tokenize = tokenize


/***/ }),

/***/ "../../node_modules/micromark/dist/initialize/text.js":
/*!************************************************************!*\
  !*** ../../node_modules/micromark/dist/initialize/text.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({value: true}))

var assign = __webpack_require__(/*! ../constant/assign.js */ "../../node_modules/micromark/dist/constant/assign.js")
var shallow = __webpack_require__(/*! ../util/shallow.js */ "../../node_modules/micromark/dist/util/shallow.js")

var text = initializeFactory('text')
var string = initializeFactory('string')
var resolver = {
  resolveAll: createResolver()
}

function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === 'text' ? resolveAllLineSuffixes : undefined
    )
  }

  function initializeText(effects) {
    var self = this
    var constructs = this.parser.constructs[field]
    var text = effects.attempt(constructs, start, notText)
    return start

    function start(code) {
      return atBreak(code) ? text(code) : notText(code)
    }

    function notText(code) {
      if (code === null) {
        effects.consume(code)
        return
      }

      effects.enter('data')
      effects.consume(code)
      return data
    }

    function data(code) {
      if (atBreak(code)) {
        effects.exit('data')
        return text(code)
      } // Data.

      effects.consume(code)
      return data
    }

    function atBreak(code) {
      var list = constructs[code]
      var index = -1

      if (code === null) {
        return true
      }

      if (list) {
        while (++index < list.length) {
          if (
            !list[index].previous ||
            list[index].previous.call(self, self.previous)
          ) {
            return true
          }
        }
      }
    }
  }
}

function createResolver(extraResolver) {
  return resolveAllText

  function resolveAllText(events, context) {
    var index = -1
    var enter // A rather boring computation (to merge adjacent `data` events) which
    // improves mm performance by 29%.

    while (++index <= events.length) {
      if (enter === undefined) {
        if (events[index] && events[index][1].type === 'data') {
          enter = index
          index++
        }
      } else if (!events[index] || events[index][1].type !== 'data') {
        // Don’t do anything if there is one data token.
        if (index !== enter + 2) {
          events[enter][1].end = events[index - 1][1].end
          events.splice(enter + 2, index - enter - 2)
          index = enter + 2
        }

        enter = undefined
      }
    }

    return extraResolver ? extraResolver(events, context) : events
  }
} // A rather ugly set of instructions which again looks at chunks in the input
// stream.
// The reason to do this here is that it is *much* faster to parse in reverse.
// And that we can’t hook into `null` to split the line suffix before an EOF.
// To do: figure out if we can make this into a clean utility, or even in core.
// As it will be useful for GFMs literal autolink extension (and maybe even
// tables?)

function resolveAllLineSuffixes(events, context) {
  var eventIndex = -1
  var chunks
  var data
  var chunk
  var index
  var bufferIndex
  var size
  var tabs
  var token

  while (++eventIndex <= events.length) {
    if (
      (eventIndex === events.length ||
        events[eventIndex][1].type === 'lineEnding') &&
      events[eventIndex - 1][1].type === 'data'
    ) {
      data = events[eventIndex - 1][1]
      chunks = context.sliceStream(data)
      index = chunks.length
      bufferIndex = -1
      size = 0
      tabs = undefined

      while (index--) {
        chunk = chunks[index]

        if (typeof chunk === 'string') {
          bufferIndex = chunk.length

          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++
            bufferIndex--
          }

          if (bufferIndex) break
          bufferIndex = -1
        } // Number
        else if (chunk === -2) {
          tabs = true
          size++
        } else if (chunk === -1);
        else {
          // Replacement character, exit.
          index++
          break
        }
      }

      if (size) {
        token = {
          type:
            eventIndex === events.length || tabs || size < 2
              ? 'lineSuffix'
              : 'hardBreakTrailing',
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index,
            _bufferIndex: index
              ? bufferIndex
              : data.start._bufferIndex + bufferIndex
          },
          end: shallow(data.end)
        }
        data.end = shallow(token.start)

        if (data.start.offset === data.end.offset) {
          assign(data, token)
        } else {
          events.splice(
            eventIndex,
            0,
            ['enter', token, context],
            ['exit', token, context]
          )
          eventIndex += 2
        }
      }

      eventIndex++
    }
  }

  return events
}

exports.resolver = resolver
exports.string = string
exports.text = text


/***/ }),

/***/ "../../node_modules/micromark/dist/parse.js":
/*!**************************************************!*\
  !*** ../../node_modules/micromark/dist/parse.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var content = __webpack_require__(/*! ./initialize/content.js */ "../../node_modules/micromark/dist/initialize/content.js")
var document = __webpack_require__(/*! ./initialize/document.js */ "../../node_modules/micromark/dist/initialize/document.js")
var flow = __webpack_require__(/*! ./initialize/flow.js */ "../../node_modules/micromark/dist/initialize/flow.js")
var text = __webpack_require__(/*! ./initialize/text.js */ "../../node_modules/micromark/dist/initialize/text.js")
var combineExtensions = __webpack_require__(/*! ./util/combine-extensions.js */ "../../node_modules/micromark/dist/util/combine-extensions.js")
var createTokenizer = __webpack_require__(/*! ./util/create-tokenizer.js */ "../../node_modules/micromark/dist/util/create-tokenizer.js")
var miniflat = __webpack_require__(/*! ./util/miniflat.js */ "../../node_modules/micromark/dist/util/miniflat.js")
var constructs = __webpack_require__(/*! ./constructs.js */ "../../node_modules/micromark/dist/constructs.js")

function parse(options) {
  var settings = options || {}
  var parser = {
    defined: [],
    constructs: combineExtensions(
      [constructs].concat(miniflat(settings.extensions))
    ),
    content: create(content),
    document: create(document),
    flow: create(flow),
    string: create(text.string),
    text: create(text.text)
  }
  return parser

  function create(initializer) {
    return creator

    function creator(from) {
      return createTokenizer(parser, initializer, from)
    }
  }
}

module.exports = parse


/***/ }),

/***/ "../../node_modules/micromark/dist/postprocess.js":
/*!********************************************************!*\
  !*** ../../node_modules/micromark/dist/postprocess.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var subtokenize = __webpack_require__(/*! ./util/subtokenize.js */ "../../node_modules/micromark/dist/util/subtokenize.js")

function postprocess(events) {
  while (!subtokenize(events)) {
    // Empty
  }

  return events
}

module.exports = postprocess


/***/ }),

/***/ "../../node_modules/micromark/dist/preprocess.js":
/*!*******************************************************!*\
  !*** ../../node_modules/micromark/dist/preprocess.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


var search = /[\0\t\n\r]/g

function preprocess() {
  var start = true
  var column = 1
  var buffer = ''
  var atCarriageReturn
  return preprocessor

  function preprocessor(value, encoding, end) {
    var chunks = []
    var match
    var next
    var startPosition
    var endPosition
    var code
    value = buffer + value.toString(encoding)
    startPosition = 0
    buffer = ''

    if (start) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++
      }

      start = undefined
    }

    while (startPosition < value.length) {
      search.lastIndex = startPosition
      match = search.exec(value)
      endPosition = match ? match.index : value.length
      code = value.charCodeAt(endPosition)

      if (!match) {
        buffer = value.slice(startPosition)
        break
      }

      if (code === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3)
        atCarriageReturn = undefined
      } else {
        if (atCarriageReturn) {
          chunks.push(-5)
          atCarriageReturn = undefined
        }

        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition))
          column += endPosition - startPosition
        }

        if (code === 0) {
          chunks.push(65533)
          column++
        } else if (code === 9) {
          next = Math.ceil(column / 4) * 4
          chunks.push(-2)

          while (column++ < next) chunks.push(-1)
        } else if (code === 10) {
          chunks.push(-4)
          column = 1
        } // Must be carriage return.
        else {
          atCarriageReturn = true
          column = 1
        }
      }

      startPosition = endPosition + 1
    }

    if (end) {
      if (atCarriageReturn) chunks.push(-5)
      if (buffer) chunks.push(buffer)
      chunks.push(null)
    }

    return chunks
  }
}

module.exports = preprocess


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/attention.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/attention.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var chunkedPush = __webpack_require__(/*! ../util/chunked-push.js */ "../../node_modules/micromark/dist/util/chunked-push.js")
var chunkedSplice = __webpack_require__(/*! ../util/chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
var classifyCharacter = __webpack_require__(/*! ../util/classify-character.js */ "../../node_modules/micromark/dist/util/classify-character.js")
var movePoint = __webpack_require__(/*! ../util/move-point.js */ "../../node_modules/micromark/dist/util/move-point.js")
var resolveAll = __webpack_require__(/*! ../util/resolve-all.js */ "../../node_modules/micromark/dist/util/resolve-all.js")
var shallow = __webpack_require__(/*! ../util/shallow.js */ "../../node_modules/micromark/dist/util/shallow.js")

var attention = {
  name: 'attention',
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
}

function resolveAllAttention(events, context) {
  var index = -1
  var open
  var group
  var text
  var openingSequence
  var closingSequence
  var use
  var nextEvents
  var offset // Walk through all events.
  //
  // Note: performance of this is fine on an mb of normal markdown, but it’s
  // a bottleneck for malicious stuff.

  while (++index < events.length) {
    // Find a token that can close.
    if (
      events[index][0] === 'enter' &&
      events[index][1].type === 'attentionSequence' &&
      events[index][1]._close
    ) {
      open = index // Now walk back to find an opener.

      while (open--) {
        // Find a token that can open the closer.
        if (
          events[open][0] === 'exit' &&
          events[open][1].type === 'attentionSequence' &&
          events[open][1]._open && // If the markers are the same:
          context.sliceSerialize(events[open][1]).charCodeAt(0) ===
            context.sliceSerialize(events[index][1]).charCodeAt(0)
        ) {
          // If the opening can close or the closing can open,
          // and the close size *is not* a multiple of three,
          // but the sum of the opening and closing size *is* multiple of three,
          // then don’t match.
          if (
            (events[open][1]._close || events[index][1]._open) &&
            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&
            !(
              (events[open][1].end.offset -
                events[open][1].start.offset +
                events[index][1].end.offset -
                events[index][1].start.offset) %
              3
            )
          ) {
            continue
          } // Number of markers to use from the sequence.

          use =
            events[open][1].end.offset - events[open][1].start.offset > 1 &&
            events[index][1].end.offset - events[index][1].start.offset > 1
              ? 2
              : 1
          openingSequence = {
            type: use > 1 ? 'strongSequence' : 'emphasisSequence',
            start: movePoint(shallow(events[open][1].end), -use),
            end: shallow(events[open][1].end)
          }
          closingSequence = {
            type: use > 1 ? 'strongSequence' : 'emphasisSequence',
            start: shallow(events[index][1].start),
            end: movePoint(shallow(events[index][1].start), use)
          }
          text = {
            type: use > 1 ? 'strongText' : 'emphasisText',
            start: shallow(events[open][1].end),
            end: shallow(events[index][1].start)
          }
          group = {
            type: use > 1 ? 'strong' : 'emphasis',
            start: shallow(openingSequence.start),
            end: shallow(closingSequence.end)
          }
          events[open][1].end = shallow(openingSequence.start)
          events[index][1].start = shallow(closingSequence.end)
          nextEvents = [] // If there are more markers in the opening, add them before.

          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = chunkedPush(nextEvents, [
              ['enter', events[open][1], context],
              ['exit', events[open][1], context]
            ])
          } // Opening.

          nextEvents = chunkedPush(nextEvents, [
            ['enter', group, context],
            ['enter', openingSequence, context],
            ['exit', openingSequence, context],
            ['enter', text, context]
          ]) // Between.

          nextEvents = chunkedPush(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index),
              context
            )
          ) // Closing.

          nextEvents = chunkedPush(nextEvents, [
            ['exit', text, context],
            ['enter', closingSequence, context],
            ['exit', closingSequence, context],
            ['exit', group, context]
          ]) // If there are more markers in the closing, add them after.

          if (events[index][1].end.offset - events[index][1].start.offset) {
            offset = 2
            nextEvents = chunkedPush(nextEvents, [
              ['enter', events[index][1], context],
              ['exit', events[index][1], context]
            ])
          } else {
            offset = 0
          }

          chunkedSplice(events, open - 1, index - open + 3, nextEvents)
          index = open + nextEvents.length - offset - 2
          break
        }
      }
    }
  } // Remove remaining sequences.

  index = -1

  while (++index < events.length) {
    if (events[index][1].type === 'attentionSequence') {
      events[index][1].type = 'data'
    }
  }

  return events
}

function tokenizeAttention(effects, ok) {
  var before = classifyCharacter(this.previous)
  var marker
  return start

  function start(code) {
    effects.enter('attentionSequence')
    marker = code
    return sequence(code)
  }

  function sequence(code) {
    var token
    var after
    var open
    var close

    if (code === marker) {
      effects.consume(code)
      return sequence
    }

    token = effects.exit('attentionSequence')
    after = classifyCharacter(code)
    open = !after || (after === 2 && before)
    close = !before || (before === 2 && after)
    token._open = marker === 42 ? open : open && (before || !close)
    token._close = marker === 42 ? close : close && (after || !open)
    return ok(code)
  }
}

module.exports = attention


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/autolink.js":
/*!**************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/autolink.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var asciiAlpha = __webpack_require__(/*! ../character/ascii-alpha.js */ "../../node_modules/micromark/dist/character/ascii-alpha.js")
var asciiAlphanumeric = __webpack_require__(/*! ../character/ascii-alphanumeric.js */ "../../node_modules/micromark/dist/character/ascii-alphanumeric.js")
var asciiAtext = __webpack_require__(/*! ../character/ascii-atext.js */ "../../node_modules/micromark/dist/character/ascii-atext.js")
var asciiControl = __webpack_require__(/*! ../character/ascii-control.js */ "../../node_modules/micromark/dist/character/ascii-control.js")

var autolink = {
  name: 'autolink',
  tokenize: tokenizeAutolink
}

function tokenizeAutolink(effects, ok, nok) {
  var size = 1
  return start

  function start(code) {
    effects.enter('autolink')
    effects.enter('autolinkMarker')
    effects.consume(code)
    effects.exit('autolinkMarker')
    effects.enter('autolinkProtocol')
    return open
  }

  function open(code) {
    if (asciiAlpha(code)) {
      effects.consume(code)
      return schemeOrEmailAtext
    }

    return asciiAtext(code) ? emailAtext(code) : nok(code)
  }

  function schemeOrEmailAtext(code) {
    return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)
      ? schemeInsideOrEmailAtext(code)
      : emailAtext(code)
  }

  function schemeInsideOrEmailAtext(code) {
    if (code === 58) {
      effects.consume(code)
      return urlInside
    }

    if (
      (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) &&
      size++ < 32
    ) {
      effects.consume(code)
      return schemeInsideOrEmailAtext
    }

    return emailAtext(code)
  }

  function urlInside(code) {
    if (code === 62) {
      effects.exit('autolinkProtocol')
      return end(code)
    }

    if (code === 32 || code === 60 || asciiControl(code)) {
      return nok(code)
    }

    effects.consume(code)
    return urlInside
  }

  function emailAtext(code) {
    if (code === 64) {
      effects.consume(code)
      size = 0
      return emailAtSignOrDot
    }

    if (asciiAtext(code)) {
      effects.consume(code)
      return emailAtext
    }

    return nok(code)
  }

  function emailAtSignOrDot(code) {
    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)
  }

  function emailLabel(code) {
    if (code === 46) {
      effects.consume(code)
      size = 0
      return emailAtSignOrDot
    }

    if (code === 62) {
      // Exit, then change the type.
      effects.exit('autolinkProtocol').type = 'autolinkEmail'
      return end(code)
    }

    return emailValue(code)
  }

  function emailValue(code) {
    if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {
      effects.consume(code)
      return code === 45 ? emailValue : emailLabel
    }

    return nok(code)
  }

  function end(code) {
    effects.enter('autolinkMarker')
    effects.consume(code)
    effects.exit('autolinkMarker')
    effects.exit('autolink')
    return ok
  }
}

module.exports = autolink


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/block-quote.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/block-quote.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

var blockQuote = {
  name: 'blockQuote',
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit: exit
}

function tokenizeBlockQuoteStart(effects, ok, nok) {
  var self = this
  return start

  function start(code) {
    if (code === 62) {
      if (!self.containerState.open) {
        effects.enter('blockQuote', {
          _container: true
        })
        self.containerState.open = true
      }

      effects.enter('blockQuotePrefix')
      effects.enter('blockQuoteMarker')
      effects.consume(code)
      effects.exit('blockQuoteMarker')
      return after
    }

    return nok(code)
  }

  function after(code) {
    if (markdownSpace(code)) {
      effects.enter('blockQuotePrefixWhitespace')
      effects.consume(code)
      effects.exit('blockQuotePrefixWhitespace')
      effects.exit('blockQuotePrefix')
      return ok
    }

    effects.exit('blockQuotePrefix')
    return ok(code)
  }
}

function tokenizeBlockQuoteContinuation(effects, ok, nok) {
  return factorySpace(
    effects,
    effects.attempt(blockQuote, ok, nok),
    'linePrefix',
    this.parser.constructs.disable.null.indexOf('codeIndented') > -1
      ? undefined
      : 4
  )
}

function exit(effects) {
  effects.exit('blockQuote')
}

module.exports = blockQuote


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/character-escape.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/character-escape.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var asciiPunctuation = __webpack_require__(/*! ../character/ascii-punctuation.js */ "../../node_modules/micromark/dist/character/ascii-punctuation.js")

var characterEscape = {
  name: 'characterEscape',
  tokenize: tokenizeCharacterEscape
}

function tokenizeCharacterEscape(effects, ok, nok) {
  return start

  function start(code) {
    effects.enter('characterEscape')
    effects.enter('escapeMarker')
    effects.consume(code)
    effects.exit('escapeMarker')
    return open
  }

  function open(code) {
    if (asciiPunctuation(code)) {
      effects.enter('characterEscapeValue')
      effects.consume(code)
      effects.exit('characterEscapeValue')
      effects.exit('characterEscape')
      return ok
    }

    return nok(code)
  }
}

module.exports = characterEscape


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/character-reference.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/character-reference.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var decodeEntity = __webpack_require__(/*! parse-entities/decode-entity.js */ "../../node_modules/parse-entities/decode-entity.browser.js")
var asciiAlphanumeric = __webpack_require__(/*! ../character/ascii-alphanumeric.js */ "../../node_modules/micromark/dist/character/ascii-alphanumeric.js")
var asciiDigit = __webpack_require__(/*! ../character/ascii-digit.js */ "../../node_modules/micromark/dist/character/ascii-digit.js")
var asciiHexDigit = __webpack_require__(/*! ../character/ascii-hex-digit.js */ "../../node_modules/micromark/dist/character/ascii-hex-digit.js")

function _interopDefaultLegacy(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {default: e}
}

var decodeEntity__default = /*#__PURE__*/ _interopDefaultLegacy(decodeEntity)

var characterReference = {
  name: 'characterReference',
  tokenize: tokenizeCharacterReference
}

function tokenizeCharacterReference(effects, ok, nok) {
  var self = this
  var size = 0
  var max
  var test
  return start

  function start(code) {
    effects.enter('characterReference')
    effects.enter('characterReferenceMarker')
    effects.consume(code)
    effects.exit('characterReferenceMarker')
    return open
  }

  function open(code) {
    if (code === 35) {
      effects.enter('characterReferenceMarkerNumeric')
      effects.consume(code)
      effects.exit('characterReferenceMarkerNumeric')
      return numeric
    }

    effects.enter('characterReferenceValue')
    max = 31
    test = asciiAlphanumeric
    return value(code)
  }

  function numeric(code) {
    if (code === 88 || code === 120) {
      effects.enter('characterReferenceMarkerHexadecimal')
      effects.consume(code)
      effects.exit('characterReferenceMarkerHexadecimal')
      effects.enter('characterReferenceValue')
      max = 6
      test = asciiHexDigit
      return value
    }

    effects.enter('characterReferenceValue')
    max = 7
    test = asciiDigit
    return value(code)
  }

  function value(code) {
    var token

    if (code === 59 && size) {
      token = effects.exit('characterReferenceValue')

      if (
        test === asciiAlphanumeric &&
        !decodeEntity__default['default'](self.sliceSerialize(token))
      ) {
        return nok(code)
      }

      effects.enter('characterReferenceMarker')
      effects.consume(code)
      effects.exit('characterReferenceMarker')
      effects.exit('characterReference')
      return ok
    }

    if (test(code) && size++ < max) {
      effects.consume(code)
      return value
    }

    return nok(code)
  }
}

module.exports = characterReference


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/code-fenced.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/code-fenced.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
var prefixSize = __webpack_require__(/*! ../util/prefix-size.js */ "../../node_modules/micromark/dist/util/prefix-size.js")
var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

var codeFenced = {
  name: 'codeFenced',
  tokenize: tokenizeCodeFenced,
  concrete: true
}

function tokenizeCodeFenced(effects, ok, nok) {
  var self = this
  var closingFenceConstruct = {
    tokenize: tokenizeClosingFence,
    partial: true
  }
  var initialPrefix = prefixSize(this.events, 'linePrefix')
  var sizeOpen = 0
  var marker
  return start

  function start(code) {
    effects.enter('codeFenced')
    effects.enter('codeFencedFence')
    effects.enter('codeFencedFenceSequence')
    marker = code
    return sequenceOpen(code)
  }

  function sequenceOpen(code) {
    if (code === marker) {
      effects.consume(code)
      sizeOpen++
      return sequenceOpen
    }

    effects.exit('codeFencedFenceSequence')
    return sizeOpen < 3
      ? nok(code)
      : factorySpace(effects, infoOpen, 'whitespace')(code)
  }

  function infoOpen(code) {
    if (code === null || markdownLineEnding(code)) {
      return openAfter(code)
    }

    effects.enter('codeFencedFenceInfo')
    effects.enter('chunkString', {
      contentType: 'string'
    })
    return info(code)
  }

  function info(code) {
    if (code === null || markdownLineEndingOrSpace(code)) {
      effects.exit('chunkString')
      effects.exit('codeFencedFenceInfo')
      return factorySpace(effects, infoAfter, 'whitespace')(code)
    }

    if (code === 96 && code === marker) return nok(code)
    effects.consume(code)
    return info
  }

  function infoAfter(code) {
    if (code === null || markdownLineEnding(code)) {
      return openAfter(code)
    }

    effects.enter('codeFencedFenceMeta')
    effects.enter('chunkString', {
      contentType: 'string'
    })
    return meta(code)
  }

  function meta(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('chunkString')
      effects.exit('codeFencedFenceMeta')
      return openAfter(code)
    }

    if (code === 96 && code === marker) return nok(code)
    effects.consume(code)
    return meta
  }

  function openAfter(code) {
    effects.exit('codeFencedFence')
    return self.interrupt ? ok(code) : content(code)
  }

  function content(code) {
    if (code === null) {
      return after(code)
    }

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      return effects.attempt(
        closingFenceConstruct,
        after,
        initialPrefix
          ? factorySpace(effects, content, 'linePrefix', initialPrefix + 1)
          : content
      )
    }

    effects.enter('codeFlowValue')
    return contentContinue(code)
  }

  function contentContinue(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('codeFlowValue')
      return content(code)
    }

    effects.consume(code)
    return contentContinue
  }

  function after(code) {
    effects.exit('codeFenced')
    return ok(code)
  }

  function tokenizeClosingFence(effects, ok, nok) {
    var size = 0
    return factorySpace(
      effects,
      closingSequenceStart,
      'linePrefix',
      this.parser.constructs.disable.null.indexOf('codeIndented') > -1
        ? undefined
        : 4
    )

    function closingSequenceStart(code) {
      effects.enter('codeFencedFence')
      effects.enter('codeFencedFenceSequence')
      return closingSequence(code)
    }

    function closingSequence(code) {
      if (code === marker) {
        effects.consume(code)
        size++
        return closingSequence
      }

      if (size < sizeOpen) return nok(code)
      effects.exit('codeFencedFenceSequence')
      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)
    }

    function closingSequenceEnd(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit('codeFencedFence')
        return ok(code)
      }

      return nok(code)
    }
  }
}

module.exports = codeFenced


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/code-indented.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/code-indented.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var chunkedSplice = __webpack_require__(/*! ../util/chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
var prefixSize = __webpack_require__(/*! ../util/prefix-size.js */ "../../node_modules/micromark/dist/util/prefix-size.js")
var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

var codeIndented = {
  name: 'codeIndented',
  tokenize: tokenizeCodeIndented,
  resolve: resolveCodeIndented
}
var indentedContentConstruct = {
  tokenize: tokenizeIndentedContent,
  partial: true
}

function resolveCodeIndented(events, context) {
  var code = {
    type: 'codeIndented',
    start: events[0][1].start,
    end: events[events.length - 1][1].end
  }
  chunkedSplice(events, 0, 0, [['enter', code, context]])
  chunkedSplice(events, events.length, 0, [['exit', code, context]])
  return events
}

function tokenizeCodeIndented(effects, ok, nok) {
  return effects.attempt(indentedContentConstruct, afterPrefix, nok)

  function afterPrefix(code) {
    if (code === null) {
      return ok(code)
    }

    if (markdownLineEnding(code)) {
      return effects.attempt(indentedContentConstruct, afterPrefix, ok)(code)
    }

    effects.enter('codeFlowValue')
    return content(code)
  }

  function content(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('codeFlowValue')
      return afterPrefix(code)
    }

    effects.consume(code)
    return content
  }
}

function tokenizeIndentedContent(effects, ok, nok) {
  var self = this
  return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)

  function afterPrefix(code) {
    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)
    }

    return prefixSize(self.events, 'linePrefix') < 4 ? nok(code) : ok(code)
  }
}

module.exports = codeIndented


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/code-text.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/code-text.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")

var codeText = {
  name: 'codeText',
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous: previous
}

function resolveCodeText(events) {
  var tailExitIndex = events.length - 4
  var headEnterIndex = 3
  var index
  var enter // If we start and end with an EOL or a space.

  if (
    (events[headEnterIndex][1].type === 'lineEnding' ||
      events[headEnterIndex][1].type === 'space') &&
    (events[tailExitIndex][1].type === 'lineEnding' ||
      events[tailExitIndex][1].type === 'space')
  ) {
    index = headEnterIndex // And we have data.

    while (++index < tailExitIndex) {
      if (events[index][1].type === 'codeTextData') {
        // Then we have padding.
        events[tailExitIndex][1].type = events[headEnterIndex][1].type =
          'codeTextPadding'
        headEnterIndex += 2
        tailExitIndex -= 2
        break
      }
    }
  } // Merge adjacent spaces and data.

  index = headEnterIndex - 1
  tailExitIndex++

  while (++index <= tailExitIndex) {
    if (enter === undefined) {
      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {
        enter = index
      }
    } else if (
      index === tailExitIndex ||
      events[index][1].type === 'lineEnding'
    ) {
      events[enter][1].type = 'codeTextData'

      if (index !== enter + 2) {
        events[enter][1].end = events[index - 1][1].end
        events.splice(enter + 2, index - enter - 2)
        tailExitIndex -= index - enter - 2
        index = enter + 2
      }

      enter = undefined
    }
  }

  return events
}

function previous(code) {
  // If there is a previous code, there will always be a tail.
  return (
    code !== 96 ||
    this.events[this.events.length - 1][1].type === 'characterEscape'
  )
}

function tokenizeCodeText(effects, ok, nok) {
  var sizeOpen = 0
  var size
  var token
  return start

  function start(code) {
    effects.enter('codeText')
    effects.enter('codeTextSequence')
    return openingSequence(code)
  }

  function openingSequence(code) {
    if (code === 96) {
      effects.consume(code)
      sizeOpen++
      return openingSequence
    }

    effects.exit('codeTextSequence')
    return gap(code)
  }

  function gap(code) {
    // EOF.
    if (code === null) {
      return nok(code)
    } // Closing fence?
    // Could also be data.

    if (code === 96) {
      token = effects.enter('codeTextSequence')
      size = 0
      return closingSequence(code)
    } // Tabs don’t work, and virtual spaces don’t make sense.

    if (code === 32) {
      effects.enter('space')
      effects.consume(code)
      effects.exit('space')
      return gap
    }

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      return gap
    } // Data.

    effects.enter('codeTextData')
    return data(code)
  } // In code.

  function data(code) {
    if (
      code === null ||
      code === 32 ||
      code === 96 ||
      markdownLineEnding(code)
    ) {
      effects.exit('codeTextData')
      return gap(code)
    }

    effects.consume(code)
    return data
  } // Closing fence.

  function closingSequence(code) {
    // More.
    if (code === 96) {
      effects.consume(code)
      size++
      return closingSequence
    } // Done!

    if (size === sizeOpen) {
      effects.exit('codeTextSequence')
      effects.exit('codeText')
      return ok(code)
    } // More or less accents: mark as data.

    token.type = 'codeTextData'
    return data(code)
  }
}

module.exports = codeText


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/content.js":
/*!*************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/content.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var prefixSize = __webpack_require__(/*! ../util/prefix-size.js */ "../../node_modules/micromark/dist/util/prefix-size.js")
var subtokenize = __webpack_require__(/*! ../util/subtokenize.js */ "../../node_modules/micromark/dist/util/subtokenize.js")
var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

// No name because it must not be turned off.
var content = {
  tokenize: tokenizeContent,
  resolve: resolveContent,
  interruptible: true,
  lazy: true
}
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
} // Content is transparent: it’s parsed right now. That way, definitions are also
// parsed right now: before text in paragraphs (specifically, media) are parsed.

function resolveContent(events) {
  subtokenize(events)
  return events
}

function tokenizeContent(effects, ok) {
  var previous
  return start

  function start(code) {
    effects.enter('content')
    previous = effects.enter('chunkContent', {
      contentType: 'content'
    })
    return data(code)
  }

  function data(code) {
    if (code === null) {
      return contentEnd(code)
    }

    if (markdownLineEnding(code)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code)
    } // Data.

    effects.consume(code)
    return data
  }

  function contentEnd(code) {
    effects.exit('chunkContent')
    effects.exit('content')
    return ok(code)
  }

  function contentContinue(code) {
    effects.consume(code)
    effects.exit('chunkContent')
    previous = previous.next = effects.enter('chunkContent', {
      contentType: 'content',
      previous: previous
    })
    return data
  }
}

function tokenizeContinuation(effects, ok, nok) {
  var self = this
  return startLookahead

  function startLookahead(code) {
    effects.enter('lineEnding')
    effects.consume(code)
    effects.exit('lineEnding')
    return factorySpace(effects, prefixed, 'linePrefix')
  }

  function prefixed(code) {
    if (code === null || markdownLineEnding(code)) {
      return nok(code)
    }

    if (
      self.parser.constructs.disable.null.indexOf('codeIndented') > -1 ||
      prefixSize(self.events, 'linePrefix') < 4
    ) {
      return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)
    }

    return ok(code)
  }
}

module.exports = content


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/definition.js":
/*!****************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/definition.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
var normalizeIdentifier = __webpack_require__(/*! ../util/normalize-identifier.js */ "../../node_modules/micromark/dist/util/normalize-identifier.js")
var factoryDestination = __webpack_require__(/*! ./factory-destination.js */ "../../node_modules/micromark/dist/tokenize/factory-destination.js")
var factoryLabel = __webpack_require__(/*! ./factory-label.js */ "../../node_modules/micromark/dist/tokenize/factory-label.js")
var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")
var factoryWhitespace = __webpack_require__(/*! ./factory-whitespace.js */ "../../node_modules/micromark/dist/tokenize/factory-whitespace.js")
var factoryTitle = __webpack_require__(/*! ./factory-title.js */ "../../node_modules/micromark/dist/tokenize/factory-title.js")

var definition = {
  name: 'definition',
  tokenize: tokenizeDefinition
}
var titleConstruct = {
  tokenize: tokenizeTitle,
  partial: true
}

function tokenizeDefinition(effects, ok, nok) {
  var self = this
  var identifier
  return start

  function start(code) {
    effects.enter('definition')
    return factoryLabel.call(
      self,
      effects,
      labelAfter,
      nok,
      'definitionLabel',
      'definitionLabelMarker',
      'definitionLabelString'
    )(code)
  }

  function labelAfter(code) {
    identifier = normalizeIdentifier(
      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
    )

    if (code === 58) {
      effects.enter('definitionMarker')
      effects.consume(code)
      effects.exit('definitionMarker') // Note: blank lines can’t exist in content.

      return factoryWhitespace(
        effects,
        factoryDestination(
          effects,
          effects.attempt(
            titleConstruct,
            factorySpace(effects, after, 'whitespace'),
            factorySpace(effects, after, 'whitespace')
          ),
          nok,
          'definitionDestination',
          'definitionDestinationLiteral',
          'definitionDestinationLiteralMarker',
          'definitionDestinationRaw',
          'definitionDestinationString'
        )
      )
    }

    return nok(code)
  }

  function after(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('definition')

      if (self.parser.defined.indexOf(identifier) < 0) {
        self.parser.defined.push(identifier)
      }

      return ok(code)
    }

    return nok(code)
  }
}

function tokenizeTitle(effects, ok, nok) {
  return start

  function start(code) {
    return markdownLineEndingOrSpace(code)
      ? factoryWhitespace(effects, before)(code)
      : nok(code)
  }

  function before(code) {
    if (code === 34 || code === 39 || code === 40) {
      return factoryTitle(
        effects,
        factorySpace(effects, after, 'whitespace'),
        nok,
        'definitionTitle',
        'definitionTitleMarker',
        'definitionTitleString'
      )(code)
    }

    return nok(code)
  }

  function after(code) {
    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)
  }
}

module.exports = definition


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/factory-destination.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/factory-destination.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var asciiControl = __webpack_require__(/*! ../character/ascii-control.js */ "../../node_modules/micromark/dist/character/ascii-control.js")
var markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")

// eslint-disable-next-line max-params
function destinationFactory(
  effects,
  ok,
  nok,
  type,
  literalType,
  literalMarkerType,
  rawType,
  stringType,
  max
) {
  var limit = max || Infinity
  var balance = 0
  return start

  function start(code) {
    if (code === 60) {
      effects.enter(type)
      effects.enter(literalType)
      effects.enter(literalMarkerType)
      effects.consume(code)
      effects.exit(literalMarkerType)
      return destinationEnclosedBefore
    }

    if (asciiControl(code) || code === 41) {
      return nok(code)
    }

    effects.enter(type)
    effects.enter(rawType)
    effects.enter(stringType)
    effects.enter('chunkString', {
      contentType: 'string'
    })
    return destinationRaw(code)
  }

  function destinationEnclosedBefore(code) {
    if (code === 62) {
      effects.enter(literalMarkerType)
      effects.consume(code)
      effects.exit(literalMarkerType)
      effects.exit(literalType)
      effects.exit(type)
      return ok
    }

    effects.enter(stringType)
    effects.enter('chunkString', {
      contentType: 'string'
    })
    return destinationEnclosed(code)
  }

  function destinationEnclosed(code) {
    if (code === 62) {
      effects.exit('chunkString')
      effects.exit(stringType)
      return destinationEnclosedBefore(code)
    }

    if (code === null || code === 60 || markdownLineEnding(code)) {
      return nok(code)
    }

    effects.consume(code)
    return code === 92 ? destinationEnclosedEscape : destinationEnclosed
  }

  function destinationEnclosedEscape(code) {
    if (code === 60 || code === 62 || code === 92) {
      effects.consume(code)
      return destinationEnclosed
    }

    return destinationEnclosed(code)
  }

  function destinationRaw(code) {
    if (code === 40) {
      if (++balance > limit) return nok(code)
      effects.consume(code)
      return destinationRaw
    }

    if (code === 41) {
      if (!balance--) {
        effects.exit('chunkString')
        effects.exit(stringType)
        effects.exit(rawType)
        effects.exit(type)
        return ok(code)
      }

      effects.consume(code)
      return destinationRaw
    }

    if (code === null || markdownLineEndingOrSpace(code)) {
      if (balance) return nok(code)
      effects.exit('chunkString')
      effects.exit(stringType)
      effects.exit(rawType)
      effects.exit(type)
      return ok(code)
    }

    if (asciiControl(code)) return nok(code)
    effects.consume(code)
    return code === 92 ? destinationRawEscape : destinationRaw
  }

  function destinationRawEscape(code) {
    if (code === 40 || code === 41 || code === 92) {
      effects.consume(code)
      return destinationRaw
    }

    return destinationRaw(code)
  }
}

module.exports = destinationFactory


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/factory-label.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/factory-label.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")

// eslint-disable-next-line max-params
function labelFactory(effects, ok, nok, type, markerType, stringType) {
  var self = this
  var size = 0
  var data
  return start

  function start(code) {
    effects.enter(type)
    effects.enter(markerType)
    effects.consume(code)
    effects.exit(markerType)
    effects.enter(stringType)
    return atBreak
  }

  function atBreak(code) {
    if (
      code === null ||
      code === 91 ||
      (code === 93 && !data) ||
      /* c8 ignore next */
      (code === 94 &&
        /* c8 ignore next */
        !size &&
        /* c8 ignore next */
        '_hiddenFootnoteSupport' in self.parser.constructs) ||
      size > 999
    ) {
      return nok(code)
    }

    if (code === 93) {
      effects.exit(stringType)
      effects.enter(markerType)
      effects.consume(code)
      effects.exit(markerType)
      effects.exit(type)
      return ok
    }

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      return atBreak
    }

    effects.enter('chunkString', {
      contentType: 'string'
    })
    return label(code)
  }

  function label(code) {
    if (
      code === null ||
      code === 91 ||
      code === 93 ||
      markdownLineEnding(code) ||
      size++ > 999
    ) {
      effects.exit('chunkString')
      return atBreak(code)
    }

    effects.consume(code)
    data = data || !markdownSpace(code)
    return code === 92 ? labelEscape : label
  }

  function labelEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code)
      size++
      return label
    }

    return label(code)
  }
}

module.exports = labelFactory


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/factory-space.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/factory-space.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")

function spaceFactory(effects, ok, type, max) {
  var limit = max ? max - 1 : Infinity
  var size = 0
  return start

  function start(code) {
    if (markdownSpace(code)) {
      effects.enter(type)
      return prefix(code)
    }

    return ok(code)
  }

  function prefix(code) {
    if (markdownSpace(code) && size++ < limit) {
      effects.consume(code)
      return prefix
    }

    effects.exit(type)
    return ok(code)
  }
}

module.exports = spaceFactory


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/factory-title.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/factory-title.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

function titleFactory(effects, ok, nok, type, markerType, stringType) {
  var marker
  return start

  function start(code) {
    effects.enter(type)
    effects.enter(markerType)
    effects.consume(code)
    effects.exit(markerType)
    marker = code === 40 ? 41 : code
    return atFirstTitleBreak
  }

  function atFirstTitleBreak(code) {
    if (code === marker) {
      effects.enter(markerType)
      effects.consume(code)
      effects.exit(markerType)
      effects.exit(type)
      return ok
    }

    effects.enter(stringType)
    return atTitleBreak(code)
  }

  function atTitleBreak(code) {
    if (code === marker) {
      effects.exit(stringType)
      return atFirstTitleBreak(marker)
    }

    if (code === null) {
      return nok(code)
    } // Note: blank lines can’t exist in content.

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      return factorySpace(effects, atTitleBreak, 'linePrefix')
    }

    effects.enter('chunkString', {
      contentType: 'string'
    })
    return title(code)
  }

  function title(code) {
    if (code === marker || code === null || markdownLineEnding(code)) {
      effects.exit('chunkString')
      return atTitleBreak(code)
    }

    effects.consume(code)
    return code === 92 ? titleEscape : title
  }

  function titleEscape(code) {
    if (code === marker || code === 92) {
      effects.consume(code)
      return title
    }

    return title(code)
  }
}

module.exports = titleFactory


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/factory-whitespace.js":
/*!************************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/factory-whitespace.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

function whitespaceFactory(effects, ok) {
  var seen
  return start

  function start(code) {
    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      seen = true
      return start
    }

    if (markdownSpace(code)) {
      return factorySpace(
        effects,
        start,
        seen ? 'linePrefix' : 'lineSuffix'
      )(code)
    }

    return ok(code)
  }
}

module.exports = whitespaceFactory


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/hard-break-escape.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/hard-break-escape.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")

var hardBreakEscape = {
  name: 'hardBreakEscape',
  tokenize: tokenizeHardBreakEscape
}

function tokenizeHardBreakEscape(effects, ok, nok) {
  return start

  function start(code) {
    effects.enter('hardBreakEscape')
    effects.enter('escapeMarker')
    effects.consume(code)
    return open
  }

  function open(code) {
    if (markdownLineEnding(code)) {
      effects.exit('escapeMarker')
      effects.exit('hardBreakEscape')
      return ok(code)
    }

    return nok(code)
  }
}

module.exports = hardBreakEscape


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/heading-atx.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/heading-atx.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
var markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
var chunkedSplice = __webpack_require__(/*! ../util/chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

var headingAtx = {
  name: 'headingAtx',
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
}

function resolveHeadingAtx(events, context) {
  var contentEnd = events.length - 2
  var contentStart = 3
  var content
  var text // Prefix whitespace, part of the opening.

  if (events[contentStart][1].type === 'whitespace') {
    contentStart += 2
  } // Suffix whitespace, part of the closing.

  if (
    contentEnd - 2 > contentStart &&
    events[contentEnd][1].type === 'whitespace'
  ) {
    contentEnd -= 2
  }

  if (
    events[contentEnd][1].type === 'atxHeadingSequence' &&
    (contentStart === contentEnd - 1 ||
      (contentEnd - 4 > contentStart &&
        events[contentEnd - 2][1].type === 'whitespace'))
  ) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4
  }

  if (contentEnd > contentStart) {
    content = {
      type: 'atxHeadingText',
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    }
    text = {
      type: 'chunkText',
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: 'text'
    }
    chunkedSplice(events, contentStart, contentEnd - contentStart + 1, [
      ['enter', content, context],
      ['enter', text, context],
      ['exit', text, context],
      ['exit', content, context]
    ])
  }

  return events
}

function tokenizeHeadingAtx(effects, ok, nok) {
  var self = this
  var size = 0
  return start

  function start(code) {
    effects.enter('atxHeading')
    effects.enter('atxHeadingSequence')
    return fenceOpenInside(code)
  }

  function fenceOpenInside(code) {
    if (code === 35 && size++ < 6) {
      effects.consume(code)
      return fenceOpenInside
    }

    if (code === null || markdownLineEndingOrSpace(code)) {
      effects.exit('atxHeadingSequence')
      return self.interrupt ? ok(code) : headingBreak(code)
    }

    return nok(code)
  }

  function headingBreak(code) {
    if (code === 35) {
      effects.enter('atxHeadingSequence')
      return sequence(code)
    }

    if (code === null || markdownLineEnding(code)) {
      effects.exit('atxHeading')
      return ok(code)
    }

    if (markdownSpace(code)) {
      return factorySpace(effects, headingBreak, 'whitespace')(code)
    }

    effects.enter('atxHeadingText')
    return data(code)
  }

  function sequence(code) {
    if (code === 35) {
      effects.consume(code)
      return sequence
    }

    effects.exit('atxHeadingSequence')
    return headingBreak(code)
  }

  function data(code) {
    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {
      effects.exit('atxHeadingText')
      return headingBreak(code)
    }

    effects.consume(code)
    return data
  }
}

module.exports = headingAtx


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/html-flow.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/html-flow.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var asciiAlpha = __webpack_require__(/*! ../character/ascii-alpha.js */ "../../node_modules/micromark/dist/character/ascii-alpha.js")
var asciiAlphanumeric = __webpack_require__(/*! ../character/ascii-alphanumeric.js */ "../../node_modules/micromark/dist/character/ascii-alphanumeric.js")
var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
var markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
var fromCharCode = __webpack_require__(/*! ../constant/from-char-code.js */ "../../node_modules/micromark/dist/constant/from-char-code.js")
var htmlBlockNames = __webpack_require__(/*! ../constant/html-block-names.js */ "../../node_modules/micromark/dist/constant/html-block-names.js")
var htmlRawNames = __webpack_require__(/*! ../constant/html-raw-names.js */ "../../node_modules/micromark/dist/constant/html-raw-names.js")
var partialBlankLine = __webpack_require__(/*! ./partial-blank-line.js */ "../../node_modules/micromark/dist/tokenize/partial-blank-line.js")

var htmlFlow = {
  name: 'htmlFlow',
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
}
var nextBlankConstruct = {
  tokenize: tokenizeNextBlank,
  partial: true
}

function resolveToHtmlFlow(events) {
  var index = events.length

  while (index--) {
    if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {
      break
    }
  }

  if (index > 1 && events[index - 2][1].type === 'linePrefix') {
    // Add the prefix start to the HTML token.
    events[index][1].start = events[index - 2][1].start // Add the prefix start to the HTML line token.

    events[index + 1][1].start = events[index - 2][1].start // Remove the line prefix.

    events.splice(index - 2, 2)
  }

  return events
}

function tokenizeHtmlFlow(effects, ok, nok) {
  var self = this
  var kind
  var startTag
  var buffer
  var index
  var marker
  return start

  function start(code) {
    effects.enter('htmlFlow')
    effects.enter('htmlFlowData')
    effects.consume(code)
    return open
  }

  function open(code) {
    if (code === 33) {
      effects.consume(code)
      return declarationStart
    }

    if (code === 47) {
      effects.consume(code)
      return tagCloseStart
    }

    if (code === 63) {
      effects.consume(code)
      kind = 3 // While we’re in an instruction instead of a declaration, we’re on a `?`
      // right now, so we do need to search for `>`, similar to declarations.

      return self.interrupt ? ok : continuationDeclarationInside
    }

    if (asciiAlpha(code)) {
      effects.consume(code)
      buffer = fromCharCode(code)
      startTag = true
      return tagName
    }

    return nok(code)
  }

  function declarationStart(code) {
    if (code === 45) {
      effects.consume(code)
      kind = 2
      return commentOpenInside
    }

    if (code === 91) {
      effects.consume(code)
      kind = 5
      buffer = 'CDATA['
      index = 0
      return cdataOpenInside
    }

    if (asciiAlpha(code)) {
      effects.consume(code)
      kind = 4
      return self.interrupt ? ok : continuationDeclarationInside
    }

    return nok(code)
  }

  function commentOpenInside(code) {
    if (code === 45) {
      effects.consume(code)
      return self.interrupt ? ok : continuationDeclarationInside
    }

    return nok(code)
  }

  function cdataOpenInside(code) {
    if (code === buffer.charCodeAt(index++)) {
      effects.consume(code)
      return index === buffer.length
        ? self.interrupt
          ? ok
          : continuation
        : cdataOpenInside
    }

    return nok(code)
  }

  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      effects.consume(code)
      buffer = fromCharCode(code)
      return tagName
    }

    return nok(code)
  }

  function tagName(code) {
    if (
      code === null ||
      code === 47 ||
      code === 62 ||
      markdownLineEndingOrSpace(code)
    ) {
      if (
        code !== 47 &&
        startTag &&
        htmlRawNames.indexOf(buffer.toLowerCase()) > -1
      ) {
        kind = 1
        return self.interrupt ? ok(code) : continuation(code)
      }

      if (htmlBlockNames.indexOf(buffer.toLowerCase()) > -1) {
        kind = 6

        if (code === 47) {
          effects.consume(code)
          return basicSelfClosing
        }

        return self.interrupt ? ok(code) : continuation(code)
      }

      kind = 7 // Do not support complete HTML when interrupting.

      return self.interrupt
        ? nok(code)
        : startTag
        ? completeAttributeNameBefore(code)
        : completeClosingTagAfter(code)
    }

    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code)
      buffer += fromCharCode(code)
      return tagName
    }

    return nok(code)
  }

  function basicSelfClosing(code) {
    if (code === 62) {
      effects.consume(code)
      return self.interrupt ? ok : continuation
    }

    return nok(code)
  }

  function completeClosingTagAfter(code) {
    if (markdownSpace(code)) {
      effects.consume(code)
      return completeClosingTagAfter
    }

    return completeEnd(code)
  }

  function completeAttributeNameBefore(code) {
    if (code === 47) {
      effects.consume(code)
      return completeEnd
    }

    if (code === 58 || code === 95 || asciiAlpha(code)) {
      effects.consume(code)
      return completeAttributeName
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return completeAttributeNameBefore
    }

    return completeEnd(code)
  }

  function completeAttributeName(code) {
    if (
      code === 45 ||
      code === 46 ||
      code === 58 ||
      code === 95 ||
      asciiAlphanumeric(code)
    ) {
      effects.consume(code)
      return completeAttributeName
    }

    return completeAttributeNameAfter(code)
  }

  function completeAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code)
      return completeAttributeValueBefore
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return completeAttributeNameAfter
    }

    return completeAttributeNameBefore(code)
  }

  function completeAttributeValueBefore(code) {
    if (
      code === null ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96
    ) {
      return nok(code)
    }

    if (code === 34 || code === 39) {
      effects.consume(code)
      marker = code
      return completeAttributeValueQuoted
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return completeAttributeValueBefore
    }

    marker = undefined
    return completeAttributeValueUnquoted(code)
  }

  function completeAttributeValueQuoted(code) {
    if (code === marker) {
      effects.consume(code)
      return completeAttributeValueQuotedAfter
    }

    if (code === null || markdownLineEnding(code)) {
      return nok(code)
    }

    effects.consume(code)
    return completeAttributeValueQuoted
  }

  function completeAttributeValueUnquoted(code) {
    if (
      code === null ||
      code === 34 ||
      code === 39 ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96 ||
      markdownLineEndingOrSpace(code)
    ) {
      return completeAttributeNameAfter(code)
    }

    effects.consume(code)
    return completeAttributeValueUnquoted
  }

  function completeAttributeValueQuotedAfter(code) {
    if (code === 47 || code === 62 || markdownSpace(code)) {
      return completeAttributeNameBefore(code)
    }

    return nok(code)
  }

  function completeEnd(code) {
    if (code === 62) {
      effects.consume(code)
      return completeAfter
    }

    return nok(code)
  }

  function completeAfter(code) {
    if (markdownSpace(code)) {
      effects.consume(code)
      return completeAfter
    }

    return code === null || markdownLineEnding(code)
      ? continuation(code)
      : nok(code)
  }

  function continuation(code) {
    if (code === 45 && kind === 2) {
      effects.consume(code)
      return continuationCommentInside
    }

    if (code === 60 && kind === 1) {
      effects.consume(code)
      return continuationRawTagOpen
    }

    if (code === 62 && kind === 4) {
      effects.consume(code)
      return continuationClose
    }

    if (code === 63 && kind === 3) {
      effects.consume(code)
      return continuationDeclarationInside
    }

    if (code === 93 && kind === 5) {
      effects.consume(code)
      return continuationCharacterDataInside
    }

    if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {
      return effects.check(
        nextBlankConstruct,
        continuationClose,
        continuationAtLineEnding
      )(code)
    }

    if (code === null || markdownLineEnding(code)) {
      return continuationAtLineEnding(code)
    }

    effects.consume(code)
    return continuation
  }

  function continuationAtLineEnding(code) {
    effects.exit('htmlFlowData')
    return htmlContinueStart(code)
  }

  function htmlContinueStart(code) {
    if (code === null) {
      return done(code)
    }

    if (markdownLineEnding(code)) {
      effects.enter('lineEnding')
      effects.consume(code)
      effects.exit('lineEnding')
      return htmlContinueStart
    }

    effects.enter('htmlFlowData')
    return continuation(code)
  }

  function continuationCommentInside(code) {
    if (code === 45) {
      effects.consume(code)
      return continuationDeclarationInside
    }

    return continuation(code)
  }

  function continuationRawTagOpen(code) {
    if (code === 47) {
      effects.consume(code)
      buffer = ''
      return continuationRawEndTag
    }

    return continuation(code)
  }

  function continuationRawEndTag(code) {
    if (code === 62 && htmlRawNames.indexOf(buffer.toLowerCase()) > -1) {
      effects.consume(code)
      return continuationClose
    }

    if (asciiAlpha(code) && buffer.length < 8) {
      effects.consume(code)
      buffer += fromCharCode(code)
      return continuationRawEndTag
    }

    return continuation(code)
  }

  function continuationCharacterDataInside(code) {
    if (code === 93) {
      effects.consume(code)
      return continuationDeclarationInside
    }

    return continuation(code)
  }

  function continuationDeclarationInside(code) {
    if (code === 62) {
      effects.consume(code)
      return continuationClose
    }

    return continuation(code)
  }

  function continuationClose(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('htmlFlowData')
      return done(code)
    }

    effects.consume(code)
    return continuationClose
  }

  function done(code) {
    effects.exit('htmlFlow')
    return ok(code)
  }
}

function tokenizeNextBlank(effects, ok, nok) {
  return start

  function start(code) {
    effects.exit('htmlFlowData')
    effects.enter('lineEndingBlank')
    effects.consume(code)
    effects.exit('lineEndingBlank')
    return effects.attempt(partialBlankLine, ok, nok)
  }
}

module.exports = htmlFlow


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/html-text.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/html-text.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var asciiAlpha = __webpack_require__(/*! ../character/ascii-alpha.js */ "../../node_modules/micromark/dist/character/ascii-alpha.js")
var asciiAlphanumeric = __webpack_require__(/*! ../character/ascii-alphanumeric.js */ "../../node_modules/micromark/dist/character/ascii-alphanumeric.js")
var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
var markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

var htmlText = {
  name: 'htmlText',
  tokenize: tokenizeHtmlText
}

function tokenizeHtmlText(effects, ok, nok) {
  var self = this
  var marker
  var buffer
  var index
  var returnState
  return start

  function start(code) {
    effects.enter('htmlText')
    effects.enter('htmlTextData')
    effects.consume(code)
    return open
  }

  function open(code) {
    if (code === 33) {
      effects.consume(code)
      return declarationOpen
    }

    if (code === 47) {
      effects.consume(code)
      return tagCloseStart
    }

    if (code === 63) {
      effects.consume(code)
      return instruction
    }

    if (asciiAlpha(code)) {
      effects.consume(code)
      return tagOpen
    }

    return nok(code)
  }

  function declarationOpen(code) {
    if (code === 45) {
      effects.consume(code)
      return commentOpen
    }

    if (code === 91) {
      effects.consume(code)
      buffer = 'CDATA['
      index = 0
      return cdataOpen
    }

    if (asciiAlpha(code)) {
      effects.consume(code)
      return declaration
    }

    return nok(code)
  }

  function commentOpen(code) {
    if (code === 45) {
      effects.consume(code)
      return commentStart
    }

    return nok(code)
  }

  function commentStart(code) {
    if (code === null || code === 62) {
      return nok(code)
    }

    if (code === 45) {
      effects.consume(code)
      return commentStartDash
    }

    return comment(code)
  }

  function commentStartDash(code) {
    if (code === null || code === 62) {
      return nok(code)
    }

    return comment(code)
  }

  function comment(code) {
    if (code === null) {
      return nok(code)
    }

    if (code === 45) {
      effects.consume(code)
      return commentClose
    }

    if (markdownLineEnding(code)) {
      returnState = comment
      return atLineEnding(code)
    }

    effects.consume(code)
    return comment
  }

  function commentClose(code) {
    if (code === 45) {
      effects.consume(code)
      return end
    }

    return comment(code)
  }

  function cdataOpen(code) {
    if (code === buffer.charCodeAt(index++)) {
      effects.consume(code)
      return index === buffer.length ? cdata : cdataOpen
    }

    return nok(code)
  }

  function cdata(code) {
    if (code === null) {
      return nok(code)
    }

    if (code === 93) {
      effects.consume(code)
      return cdataClose
    }

    if (markdownLineEnding(code)) {
      returnState = cdata
      return atLineEnding(code)
    }

    effects.consume(code)
    return cdata
  }

  function cdataClose(code) {
    if (code === 93) {
      effects.consume(code)
      return cdataEnd
    }

    return cdata(code)
  }

  function cdataEnd(code) {
    if (code === 62) {
      return end(code)
    }

    if (code === 93) {
      effects.consume(code)
      return cdataEnd
    }

    return cdata(code)
  }

  function declaration(code) {
    if (code === null || code === 62) {
      return end(code)
    }

    if (markdownLineEnding(code)) {
      returnState = declaration
      return atLineEnding(code)
    }

    effects.consume(code)
    return declaration
  }

  function instruction(code) {
    if (code === null) {
      return nok(code)
    }

    if (code === 63) {
      effects.consume(code)
      return instructionClose
    }

    if (markdownLineEnding(code)) {
      returnState = instruction
      return atLineEnding(code)
    }

    effects.consume(code)
    return instruction
  }

  function instructionClose(code) {
    return code === 62 ? end(code) : instruction(code)
  }

  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      effects.consume(code)
      return tagClose
    }

    return nok(code)
  }

  function tagClose(code) {
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code)
      return tagClose
    }

    return tagCloseBetween(code)
  }

  function tagCloseBetween(code) {
    if (markdownLineEnding(code)) {
      returnState = tagCloseBetween
      return atLineEnding(code)
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return tagCloseBetween
    }

    return end(code)
  }

  function tagOpen(code) {
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code)
      return tagOpen
    }

    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code)
    }

    return nok(code)
  }

  function tagOpenBetween(code) {
    if (code === 47) {
      effects.consume(code)
      return end
    }

    if (code === 58 || code === 95 || asciiAlpha(code)) {
      effects.consume(code)
      return tagOpenAttributeName
    }

    if (markdownLineEnding(code)) {
      returnState = tagOpenBetween
      return atLineEnding(code)
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return tagOpenBetween
    }

    return end(code)
  }

  function tagOpenAttributeName(code) {
    if (
      code === 45 ||
      code === 46 ||
      code === 58 ||
      code === 95 ||
      asciiAlphanumeric(code)
    ) {
      effects.consume(code)
      return tagOpenAttributeName
    }

    return tagOpenAttributeNameAfter(code)
  }

  function tagOpenAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code)
      return tagOpenAttributeValueBefore
    }

    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeNameAfter
      return atLineEnding(code)
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return tagOpenAttributeNameAfter
    }

    return tagOpenBetween(code)
  }

  function tagOpenAttributeValueBefore(code) {
    if (
      code === null ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96
    ) {
      return nok(code)
    }

    if (code === 34 || code === 39) {
      effects.consume(code)
      marker = code
      return tagOpenAttributeValueQuoted
    }

    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueBefore
      return atLineEnding(code)
    }

    if (markdownSpace(code)) {
      effects.consume(code)
      return tagOpenAttributeValueBefore
    }

    effects.consume(code)
    marker = undefined
    return tagOpenAttributeValueUnquoted
  }

  function tagOpenAttributeValueQuoted(code) {
    if (code === marker) {
      effects.consume(code)
      return tagOpenAttributeValueQuotedAfter
    }

    if (code === null) {
      return nok(code)
    }

    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueQuoted
      return atLineEnding(code)
    }

    effects.consume(code)
    return tagOpenAttributeValueQuoted
  }

  function tagOpenAttributeValueQuotedAfter(code) {
    if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code)
    }

    return nok(code)
  }

  function tagOpenAttributeValueUnquoted(code) {
    if (
      code === null ||
      code === 34 ||
      code === 39 ||
      code === 60 ||
      code === 61 ||
      code === 96
    ) {
      return nok(code)
    }

    if (code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code)
    }

    effects.consume(code)
    return tagOpenAttributeValueUnquoted
  } // We can’t have blank lines in content, so no need to worry about empty
  // tokens.

  function atLineEnding(code) {
    effects.exit('htmlTextData')
    effects.enter('lineEnding')
    effects.consume(code)
    effects.exit('lineEnding')
    return factorySpace(
      effects,
      afterPrefix,
      'linePrefix',
      self.parser.constructs.disable.null.indexOf('codeIndented') > -1
        ? undefined
        : 4
    )
  }

  function afterPrefix(code) {
    effects.enter('htmlTextData')
    return returnState(code)
  }

  function end(code) {
    if (code === 62) {
      effects.consume(code)
      effects.exit('htmlTextData')
      effects.exit('htmlText')
      return ok
    }

    return nok(code)
  }
}

module.exports = htmlText


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/label-end.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/label-end.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
var chunkedPush = __webpack_require__(/*! ../util/chunked-push.js */ "../../node_modules/micromark/dist/util/chunked-push.js")
var chunkedSplice = __webpack_require__(/*! ../util/chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
var normalizeIdentifier = __webpack_require__(/*! ../util/normalize-identifier.js */ "../../node_modules/micromark/dist/util/normalize-identifier.js")
var resolveAll = __webpack_require__(/*! ../util/resolve-all.js */ "../../node_modules/micromark/dist/util/resolve-all.js")
var shallow = __webpack_require__(/*! ../util/shallow.js */ "../../node_modules/micromark/dist/util/shallow.js")
var factoryDestination = __webpack_require__(/*! ./factory-destination.js */ "../../node_modules/micromark/dist/tokenize/factory-destination.js")
var factoryLabel = __webpack_require__(/*! ./factory-label.js */ "../../node_modules/micromark/dist/tokenize/factory-label.js")
var factoryTitle = __webpack_require__(/*! ./factory-title.js */ "../../node_modules/micromark/dist/tokenize/factory-title.js")
var factoryWhitespace = __webpack_require__(/*! ./factory-whitespace.js */ "../../node_modules/micromark/dist/tokenize/factory-whitespace.js")

var labelEnd = {
  name: 'labelEnd',
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
}
var resourceConstruct = {
  tokenize: tokenizeResource
}
var fullReferenceConstruct = {
  tokenize: tokenizeFullReference
}
var collapsedReferenceConstruct = {
  tokenize: tokenizeCollapsedReference
}

function resolveAllLabelEnd(events) {
  var index = -1
  var token

  while (++index < events.length) {
    token = events[index][1]

    if (
      !token._used &&
      (token.type === 'labelImage' ||
        token.type === 'labelLink' ||
        token.type === 'labelEnd')
    ) {
      // Remove the marker.
      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)
      token.type = 'data'
      index++
    }
  }

  return events
}

function resolveToLabelEnd(events, context) {
  var index = events.length
  var offset = 0
  var group
  var label
  var text
  var token
  var open
  var close
  var media // Find an opening.

  while (index--) {
    token = events[index][1]

    if (open) {
      // If we see another link, or inactive link label, we’ve been here before.
      if (
        token.type === 'link' ||
        (token.type === 'labelLink' && token._inactive)
      ) {
        break
      } // Mark other link openings as inactive, as we can’t have links in
      // links.

      if (events[index][0] === 'enter' && token.type === 'labelLink') {
        token._inactive = true
      }
    } else if (close) {
      if (
        events[index][0] === 'enter' &&
        (token.type === 'labelImage' || token.type === 'labelLink') &&
        !token._balanced
      ) {
        open = index

        if (token.type !== 'labelLink') {
          offset = 2
          break
        }
      }
    } else if (token.type === 'labelEnd') {
      close = index
    }
  }

  group = {
    type: events[open][1].type === 'labelLink' ? 'link' : 'image',
    start: shallow(events[open][1].start),
    end: shallow(events[events.length - 1][1].end)
  }
  label = {
    type: 'label',
    start: shallow(events[open][1].start),
    end: shallow(events[close][1].end)
  }
  text = {
    type: 'labelText',
    start: shallow(events[open + offset + 2][1].end),
    end: shallow(events[close - 2][1].start)
  }
  media = [
    ['enter', group, context],
    ['enter', label, context]
  ] // Opening marker.

  media = chunkedPush(media, events.slice(open + 1, open + offset + 3)) // Text open.

  media = chunkedPush(media, [['enter', text, context]]) // Between.

  media = chunkedPush(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  ) // Text close, marker close, label close.

  media = chunkedPush(media, [
    ['exit', text, context],
    events[close - 2],
    events[close - 1],
    ['exit', label, context]
  ]) // Reference, resource, or so.

  media = chunkedPush(media, events.slice(close + 1)) // Media close.

  media = chunkedPush(media, [['exit', group, context]])
  chunkedSplice(events, open, events.length, media)
  return events
}

function tokenizeLabelEnd(effects, ok, nok) {
  var self = this
  var index = self.events.length
  var labelStart
  var defined // Find an opening.

  while (index--) {
    if (
      (self.events[index][1].type === 'labelImage' ||
        self.events[index][1].type === 'labelLink') &&
      !self.events[index][1]._balanced
    ) {
      labelStart = self.events[index][1]
      break
    }
  }

  return start

  function start(code) {
    if (!labelStart) {
      return nok(code)
    } // It’s a balanced bracket, but contains a link.

    if (labelStart._inactive) return balanced(code)
    defined =
      self.parser.defined.indexOf(
        normalizeIdentifier(
          self.sliceSerialize({
            start: labelStart.end,
            end: self.now()
          })
        )
      ) > -1
    effects.enter('labelEnd')
    effects.enter('labelMarker')
    effects.consume(code)
    effects.exit('labelMarker')
    effects.exit('labelEnd')
    return afterLabelEnd
  }

  function afterLabelEnd(code) {
    // Resource: `[asd](fgh)`.
    if (code === 40) {
      return effects.attempt(
        resourceConstruct,
        ok,
        defined ? ok : balanced
      )(code)
    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?

    if (code === 91) {
      return effects.attempt(
        fullReferenceConstruct,
        ok,
        defined
          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)
          : balanced
      )(code)
    } // Shortcut reference: `[asd]`?

    return defined ? ok(code) : balanced(code)
  }

  function balanced(code) {
    labelStart._balanced = true
    return nok(code)
  }
}

function tokenizeResource(effects, ok, nok) {
  return start

  function start(code) {
    effects.enter('resource')
    effects.enter('resourceMarker')
    effects.consume(code)
    effects.exit('resourceMarker')
    return factoryWhitespace(effects, open)
  }

  function open(code) {
    if (code === 41) {
      return end(code)
    }

    return factoryDestination(
      effects,
      destinationAfter,
      nok,
      'resourceDestination',
      'resourceDestinationLiteral',
      'resourceDestinationLiteralMarker',
      'resourceDestinationRaw',
      'resourceDestinationString',
      3
    )(code)
  }

  function destinationAfter(code) {
    return markdownLineEndingOrSpace(code)
      ? factoryWhitespace(effects, between)(code)
      : end(code)
  }

  function between(code) {
    if (code === 34 || code === 39 || code === 40) {
      return factoryTitle(
        effects,
        factoryWhitespace(effects, end),
        nok,
        'resourceTitle',
        'resourceTitleMarker',
        'resourceTitleString'
      )(code)
    }

    return end(code)
  }

  function end(code) {
    if (code === 41) {
      effects.enter('resourceMarker')
      effects.consume(code)
      effects.exit('resourceMarker')
      effects.exit('resource')
      return ok
    }

    return nok(code)
  }
}

function tokenizeFullReference(effects, ok, nok) {
  var self = this
  return start

  function start(code) {
    return factoryLabel.call(
      self,
      effects,
      afterLabel,
      nok,
      'reference',
      'referenceMarker',
      'referenceString'
    )(code)
  }

  function afterLabel(code) {
    return self.parser.defined.indexOf(
      normalizeIdentifier(
        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
      )
    ) < 0
      ? nok(code)
      : ok(code)
  }
}

function tokenizeCollapsedReference(effects, ok, nok) {
  return start

  function start(code) {
    effects.enter('reference')
    effects.enter('referenceMarker')
    effects.consume(code)
    effects.exit('referenceMarker')
    return open
  }

  function open(code) {
    if (code === 93) {
      effects.enter('referenceMarker')
      effects.consume(code)
      effects.exit('referenceMarker')
      effects.exit('reference')
      return ok
    }

    return nok(code)
  }
}

module.exports = labelEnd


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/label-start-image.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/label-start-image.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var labelEnd = __webpack_require__(/*! ./label-end.js */ "../../node_modules/micromark/dist/tokenize/label-end.js")

var labelStartImage = {
  name: 'labelStartImage',
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
}

function tokenizeLabelStartImage(effects, ok, nok) {
  var self = this
  return start

  function start(code) {
    effects.enter('labelImage')
    effects.enter('labelImageMarker')
    effects.consume(code)
    effects.exit('labelImageMarker')
    return open
  }

  function open(code) {
    if (code === 91) {
      effects.enter('labelMarker')
      effects.consume(code)
      effects.exit('labelMarker')
      effects.exit('labelImage')
      return after
    }

    return nok(code)
  }

  function after(code) {
    /* c8 ignore next */
    return code === 94 &&
      /* c8 ignore next */
      '_hiddenFootnoteSupport' in self.parser.constructs
      ? /* c8 ignore next */
        nok(code)
      : ok(code)
  }
}

module.exports = labelStartImage


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/label-start-link.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/label-start-link.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var labelEnd = __webpack_require__(/*! ./label-end.js */ "../../node_modules/micromark/dist/tokenize/label-end.js")

var labelStartLink = {
  name: 'labelStartLink',
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
}

function tokenizeLabelStartLink(effects, ok, nok) {
  var self = this
  return start

  function start(code) {
    effects.enter('labelLink')
    effects.enter('labelMarker')
    effects.consume(code)
    effects.exit('labelMarker')
    effects.exit('labelLink')
    return after
  }

  function after(code) {
    /* c8 ignore next */
    return code === 94 &&
      /* c8 ignore next */
      '_hiddenFootnoteSupport' in self.parser.constructs
      ? /* c8 ignore next */
        nok(code)
      : ok(code)
  }
}

module.exports = labelStartLink


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/line-ending.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/line-ending.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

var lineEnding = {
  name: 'lineEnding',
  tokenize: tokenizeLineEnding
}

function tokenizeLineEnding(effects, ok) {
  return start

  function start(code) {
    effects.enter('lineEnding')
    effects.consume(code)
    effects.exit('lineEnding')
    return factorySpace(effects, ok, 'linePrefix')
  }
}

module.exports = lineEnding


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/list.js":
/*!**********************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/list.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var asciiDigit = __webpack_require__(/*! ../character/ascii-digit.js */ "../../node_modules/micromark/dist/character/ascii-digit.js")
var markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
var prefixSize = __webpack_require__(/*! ../util/prefix-size.js */ "../../node_modules/micromark/dist/util/prefix-size.js")
var sizeChunks = __webpack_require__(/*! ../util/size-chunks.js */ "../../node_modules/micromark/dist/util/size-chunks.js")
var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")
var partialBlankLine = __webpack_require__(/*! ./partial-blank-line.js */ "../../node_modules/micromark/dist/tokenize/partial-blank-line.js")
var thematicBreak = __webpack_require__(/*! ./thematic-break.js */ "../../node_modules/micromark/dist/tokenize/thematic-break.js")

var list = {
  name: 'list',
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
}
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
}
var indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
}

function tokenizeListStart(effects, ok, nok) {
  var self = this
  var initialSize = prefixSize(self.events, 'linePrefix')
  var size = 0
  return start

  function start(code) {
    var kind =
      self.containerState.type ||
      (code === 42 || code === 43 || code === 45
        ? 'listUnordered'
        : 'listOrdered')

    if (
      kind === 'listUnordered'
        ? !self.containerState.marker || code === self.containerState.marker
        : asciiDigit(code)
    ) {
      if (!self.containerState.type) {
        self.containerState.type = kind
        effects.enter(kind, {
          _container: true
        })
      }

      if (kind === 'listUnordered') {
        effects.enter('listItemPrefix')
        return code === 42 || code === 45
          ? effects.check(thematicBreak, nok, atMarker)(code)
          : atMarker(code)
      }

      if (!self.interrupt || code === 49) {
        effects.enter('listItemPrefix')
        effects.enter('listItemValue')
        return inside(code)
      }
    }

    return nok(code)
  }

  function inside(code) {
    if (asciiDigit(code) && ++size < 10) {
      effects.consume(code)
      return inside
    }

    if (
      (!self.interrupt || size < 2) &&
      (self.containerState.marker
        ? code === self.containerState.marker
        : code === 41 || code === 46)
    ) {
      effects.exit('listItemValue')
      return atMarker(code)
    }

    return nok(code)
  }

  function atMarker(code) {
    effects.enter('listItemMarker')
    effects.consume(code)
    effects.exit('listItemMarker')
    self.containerState.marker = self.containerState.marker || code
    return effects.check(
      partialBlankLine, // Can’t be empty when interrupting.
      self.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    )
  }

  function onBlank(code) {
    self.containerState.initialBlankLine = true
    initialSize++
    return endOfPrefix(code)
  }

  function otherPrefix(code) {
    if (markdownSpace(code)) {
      effects.enter('listItemPrefixWhitespace')
      effects.consume(code)
      effects.exit('listItemPrefixWhitespace')
      return endOfPrefix
    }

    return nok(code)
  }

  function endOfPrefix(code) {
    self.containerState.size =
      initialSize + sizeChunks(self.sliceStream(effects.exit('listItemPrefix')))
    return ok(code)
  }
}

function tokenizeListContinuation(effects, ok, nok) {
  var self = this
  self.containerState._closeFlow = undefined
  return effects.check(partialBlankLine, onBlank, notBlank)

  function onBlank(code) {
    self.containerState.furtherBlankLines =
      self.containerState.furtherBlankLines ||
      self.containerState.initialBlankLine // We have a blank line.
    // Still, try to consume at most the items size.

    return factorySpace(
      effects,
      ok,
      'listItemIndent',
      self.containerState.size + 1
    )(code)
  }

  function notBlank(code) {
    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {
      self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined
      return notInCurrentItem(code)
    }

    self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined
    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)
  }

  function notInCurrentItem(code) {
    // While we do continue, we signal that the flow should be closed.
    self.containerState._closeFlow = true // As we’re closing flow, we’re no longer interrupting.

    self.interrupt = undefined
    return factorySpace(
      effects,
      effects.attempt(list, ok, nok),
      'linePrefix',
      self.parser.constructs.disable.null.indexOf('codeIndented') > -1
        ? undefined
        : 4
    )(code)
  }
}

function tokenizeIndent(effects, ok, nok) {
  var self = this
  return factorySpace(
    effects,
    afterPrefix,
    'listItemIndent',
    self.containerState.size + 1
  )

  function afterPrefix(code) {
    return prefixSize(self.events, 'listItemIndent') ===
      self.containerState.size
      ? ok(code)
      : nok(code)
  }
}

function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type)
}

function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
  var self = this
  return factorySpace(
    effects,
    afterPrefix,
    'listItemPrefixWhitespace',
    self.parser.constructs.disable.null.indexOf('codeIndented') > -1
      ? undefined
      : 4 + 1
  )

  function afterPrefix(code) {
    return markdownSpace(code) ||
      !prefixSize(self.events, 'listItemPrefixWhitespace')
      ? nok(code)
      : ok(code)
  }
}

module.exports = list


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/partial-blank-line.js":
/*!************************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/partial-blank-line.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

var partialBlankLine = {
  tokenize: tokenizePartialBlankLine,
  partial: true
}

function tokenizePartialBlankLine(effects, ok, nok) {
  return factorySpace(effects, afterWhitespace, 'linePrefix')

  function afterWhitespace(code) {
    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)
  }
}

module.exports = partialBlankLine


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/setext-underline.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/setext-underline.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var shallow = __webpack_require__(/*! ../util/shallow.js */ "../../node_modules/micromark/dist/util/shallow.js")
var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

var setextUnderline = {
  name: 'setextUnderline',
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
}

function resolveToSetextUnderline(events, context) {
  var index = events.length
  var content
  var text
  var definition
  var heading // Find the opening of the content.
  // It’ll always exist: we don’t tokenize if it isn’t there.

  while (index--) {
    if (events[index][0] === 'enter') {
      if (events[index][1].type === 'content') {
        content = index
        break
      }

      if (events[index][1].type === 'paragraph') {
        text = index
      }
    } // Exit
    else {
      if (events[index][1].type === 'content') {
        // Remove the content end (if needed we’ll add it later)
        events.splice(index, 1)
      }

      if (!definition && events[index][1].type === 'definition') {
        definition = index
      }
    }
  }

  heading = {
    type: 'setextHeading',
    start: shallow(events[text][1].start),
    end: shallow(events[events.length - 1][1].end)
  } // Change the paragraph to setext heading text.

  events[text][1].type = 'setextHeadingText' // If we have definitions in the content, we’ll keep on having content,
  // but we need move it.

  if (definition) {
    events.splice(text, 0, ['enter', heading, context])
    events.splice(definition + 1, 0, ['exit', events[content][1], context])
    events[content][1].end = shallow(events[definition][1].end)
  } else {
    events[content][1] = heading
  } // Add the heading exit at the end.

  events.push(['exit', heading, context])
  return events
}

function tokenizeSetextUnderline(effects, ok, nok) {
  var self = this
  var index = self.events.length
  var marker
  var paragraph // Find an opening.

  while (index--) {
    // Skip enter/exit of line ending, line prefix, and content.
    // We can now either have a definition or a paragraph.
    if (
      self.events[index][1].type !== 'lineEnding' &&
      self.events[index][1].type !== 'linePrefix' &&
      self.events[index][1].type !== 'content'
    ) {
      paragraph = self.events[index][1].type === 'paragraph'
      break
    }
  }

  return start

  function start(code) {
    if (!self.lazy && (self.interrupt || paragraph)) {
      effects.enter('setextHeadingLine')
      effects.enter('setextHeadingLineSequence')
      marker = code
      return closingSequence(code)
    }

    return nok(code)
  }

  function closingSequence(code) {
    if (code === marker) {
      effects.consume(code)
      return closingSequence
    }

    effects.exit('setextHeadingLineSequence')
    return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code)
  }

  function closingSequenceEnd(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('setextHeadingLine')
      return ok(code)
    }

    return nok(code)
  }
}

module.exports = setextUnderline


/***/ }),

/***/ "../../node_modules/micromark/dist/tokenize/thematic-break.js":
/*!********************************************************************!*\
  !*** ../../node_modules/micromark/dist/tokenize/thematic-break.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var markdownSpace = __webpack_require__(/*! ../character/markdown-space.js */ "../../node_modules/micromark/dist/character/markdown-space.js")
var factorySpace = __webpack_require__(/*! ./factory-space.js */ "../../node_modules/micromark/dist/tokenize/factory-space.js")

var thematicBreak = {
  name: 'thematicBreak',
  tokenize: tokenizeThematicBreak
}

function tokenizeThematicBreak(effects, ok, nok) {
  var size = 0
  var marker
  return start

  function start(code) {
    effects.enter('thematicBreak')
    marker = code
    return atBreak(code)
  }

  function atBreak(code) {
    if (code === marker) {
      effects.enter('thematicBreakSequence')
      return sequence(code)
    }

    if (markdownSpace(code)) {
      return factorySpace(effects, atBreak, 'whitespace')(code)
    }

    if (size < 3 || (code !== null && !markdownLineEnding(code))) {
      return nok(code)
    }

    effects.exit('thematicBreak')
    return ok(code)
  }

  function sequence(code) {
    if (code === marker) {
      effects.consume(code)
      size++
      return sequence
    }

    effects.exit('thematicBreakSequence')
    return atBreak(code)
  }
}

module.exports = thematicBreak


/***/ }),

/***/ "../../node_modules/micromark/dist/util/chunked-push.js":
/*!**************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/chunked-push.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var chunkedSplice = __webpack_require__(/*! ./chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")

function chunkedPush(list, items) {
  if (list.length) {
    chunkedSplice(list, list.length, 0, items)
    return list
  }

  return items
}

module.exports = chunkedPush


/***/ }),

/***/ "../../node_modules/micromark/dist/util/chunked-splice.js":
/*!****************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/chunked-splice.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var splice = __webpack_require__(/*! ../constant/splice.js */ "../../node_modules/micromark/dist/constant/splice.js")

// causes a stack overflow in V8 when trying to insert 100k items for instance.

function chunkedSplice(list, start, remove, items) {
  var end = list.length
  var chunkStart = 0
  var parameters // Make start between zero and `end` (included).

  if (start < 0) {
    start = -start > end ? 0 : end + start
  } else {
    start = start > end ? end : start
  }

  remove = remove > 0 ? remove : 0 // No need to chunk the items if there’s only a couple (10k) items.

  if (items.length < 10000) {
    parameters = Array.from(items)
    parameters.unshift(start, remove)
    splice.apply(list, parameters)
  } else {
    // Delete `remove` items starting from `start`
    if (remove) splice.apply(list, [start, remove]) // Insert the items in chunks to not cause stack overflows.

    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 10000)
      parameters.unshift(start, 0)
      splice.apply(list, parameters)
      chunkStart += 10000
      start += 10000
    }
  }
}

module.exports = chunkedSplice


/***/ }),

/***/ "../../node_modules/micromark/dist/util/classify-character.js":
/*!********************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/classify-character.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var markdownLineEndingOrSpace = __webpack_require__(/*! ../character/markdown-line-ending-or-space.js */ "../../node_modules/micromark/dist/character/markdown-line-ending-or-space.js")
var unicodePunctuation = __webpack_require__(/*! ../character/unicode-punctuation.js */ "../../node_modules/micromark/dist/character/unicode-punctuation.js")
var unicodeWhitespace = __webpack_require__(/*! ../character/unicode-whitespace.js */ "../../node_modules/micromark/dist/character/unicode-whitespace.js")

// Classify whether a character is unicode whitespace, unicode punctuation, or
// anything else.
// Used for attention (emphasis, strong), whose sequences can open or close
// based on the class of surrounding characters.
function classifyCharacter(code) {
  if (
    code === null ||
    markdownLineEndingOrSpace(code) ||
    unicodeWhitespace(code)
  ) {
    return 1
  }

  if (unicodePunctuation(code)) {
    return 2
  }
}

module.exports = classifyCharacter


/***/ }),

/***/ "../../node_modules/micromark/dist/util/combine-extensions.js":
/*!********************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/combine-extensions.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasOwnProperty = __webpack_require__(/*! ../constant/has-own-property.js */ "../../node_modules/micromark/dist/constant/has-own-property.js")
var chunkedSplice = __webpack_require__(/*! ./chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
var miniflat = __webpack_require__(/*! ./miniflat.js */ "../../node_modules/micromark/dist/util/miniflat.js")

function combineExtensions(extensions) {
  var all = {}
  var index = -1

  while (++index < extensions.length) {
    extension(all, extensions[index])
  }

  return all
}

function extension(all, extension) {
  var hook
  var left
  var right
  var code

  for (hook in extension) {
    left = hasOwnProperty.call(all, hook) ? all[hook] : (all[hook] = {})
    right = extension[hook]

    for (code in right) {
      left[code] = constructs(
        miniflat(right[code]),
        hasOwnProperty.call(left, code) ? left[code] : []
      )
    }
  }
}

function constructs(list, existing) {
  var index = -1
  var before = []

  while (++index < list.length) {
    ;(list[index].add === 'after' ? existing : before).push(list[index])
  }

  chunkedSplice(existing, 0, 0, before)
  return existing
}

module.exports = combineExtensions


/***/ }),

/***/ "../../node_modules/micromark/dist/util/create-tokenizer.js":
/*!******************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/create-tokenizer.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! ../constant/assign.js */ "../../node_modules/micromark/dist/constant/assign.js")
var markdownLineEnding = __webpack_require__(/*! ../character/markdown-line-ending.js */ "../../node_modules/micromark/dist/character/markdown-line-ending.js")
var chunkedPush = __webpack_require__(/*! ./chunked-push.js */ "../../node_modules/micromark/dist/util/chunked-push.js")
var chunkedSplice = __webpack_require__(/*! ./chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
var miniflat = __webpack_require__(/*! ./miniflat.js */ "../../node_modules/micromark/dist/util/miniflat.js")
var resolveAll = __webpack_require__(/*! ./resolve-all.js */ "../../node_modules/micromark/dist/util/resolve-all.js")
var serializeChunks = __webpack_require__(/*! ./serialize-chunks.js */ "../../node_modules/micromark/dist/util/serialize-chunks.js")
var shallow = __webpack_require__(/*! ./shallow.js */ "../../node_modules/micromark/dist/util/shallow.js")
var sliceChunks = __webpack_require__(/*! ./slice-chunks.js */ "../../node_modules/micromark/dist/util/slice-chunks.js")

// Create a tokenizer.
// Tokenizers deal with one type of data (e.g., containers, flow, text).
// The parser is the object dealing with it all.
// `initialize` works like other constructs, except that only its `tokenize`
// function is used, in which case it doesn’t receive an `ok` or `nok`.
// `from` can be given to set the point before the first character, although
// when further lines are indented, they must be set with `defineSkip`.
function createTokenizer(parser, initialize, from) {
  var point = from
    ? shallow(from)
    : {
        line: 1,
        column: 1,
        offset: 0
      }
  var columnStart = {}
  var resolveAllConstructs = []
  var chunks = []
  var stack = []

  var effects = {
    consume: consume,
    enter: enter,
    exit: exit,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    }),
    lazy: constructFactory(onsuccessfulcheck, {
      lazy: true
    })
  } // State and tools for resolving and serializing.

  var context = {
    previous: null,
    events: [],
    parser: parser,
    sliceStream: sliceStream,
    sliceSerialize: sliceSerialize,
    now: now,
    defineSkip: skip,
    write: write
  } // The state function.

  var state = initialize.tokenize.call(context, effects) // Track which character we expect to be consumed, to catch bugs.

  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize)
  } // Store where we are in the input stream.

  point._index = 0
  point._bufferIndex = -1
  return context

  function write(slice) {
    chunks = chunkedPush(chunks, slice)
    main() // Exit if we’re not done, resolve might change stuff.

    if (chunks[chunks.length - 1] !== null) {
      return []
    }

    addResult(initialize, 0) // Otherwise, resolve, and exit.

    context.events = resolveAll(resolveAllConstructs, context.events, context)
    return context.events
  } //
  // Tools.
  //

  function sliceSerialize(token) {
    return serializeChunks(sliceStream(token))
  }

  function sliceStream(token) {
    return sliceChunks(chunks, token)
  }

  function now() {
    return shallow(point)
  }

  function skip(value) {
    columnStart[value.line] = value.column
    accountForPotentialSkip()
  } //
  // State management.
  //
  // Main loop (note that `_index` and `_bufferIndex` in `point` are modified by
  // `consume`).
  // Here is where we walk through the chunks, which either include strings of
  // several characters, or numerical character codes.
  // The reason to do this in a loop instead of a call is so the stack can
  // drain.

  function main() {
    var chunkIndex
    var chunk

    while (point._index < chunks.length) {
      chunk = chunks[point._index] // If we’re in a buffer chunk, loop through it.

      if (typeof chunk === 'string') {
        chunkIndex = point._index

        if (point._bufferIndex < 0) {
          point._bufferIndex = 0
        }

        while (
          point._index === chunkIndex &&
          point._bufferIndex < chunk.length
        ) {
          go(chunk.charCodeAt(point._bufferIndex))
        }
      } else {
        go(chunk)
      }
    }
  } // Deal with one code.

  function go(code) {
    state = state(code)
  } // Move a character forward.

  function consume(code) {
    if (markdownLineEnding(code)) {
      point.line++
      point.column = 1
      point.offset += code === -3 ? 2 : 1
      accountForPotentialSkip()
    } else if (code !== -1) {
      point.column++
      point.offset++
    } // Not in a string chunk.

    if (point._bufferIndex < 0) {
      point._index++
    } else {
      point._bufferIndex++ // At end of string chunk.

      if (point._bufferIndex === chunks[point._index].length) {
        point._bufferIndex = -1
        point._index++
      }
    } // Expose the previous character.

    context.previous = code // Mark as consumed.
  } // Start a token.

  function enter(type, fields) {
    var token = fields || {}
    token.type = type
    token.start = now()
    context.events.push(['enter', token, context])
    stack.push(token)
    return token
  } // Stop a token.

  function exit(type) {
    var token = stack.pop()
    token.end = now()
    context.events.push(['exit', token, context])
    return token
  } // Use results.

  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from)
  } // Discard results.

  function onsuccessfulcheck(construct, info) {
    info.restore()
  } // Factory to attempt/check/interrupt.

  function constructFactory(onreturn, fields) {
    return hook // Handle either an object mapping codes to constructs, a list of
    // constructs, or a single construct.

    function hook(constructs, returnState, bogusState) {
      var listOfConstructs
      var constructIndex
      var currentConstruct
      var info
      return constructs.tokenize || 'length' in constructs
        ? handleListOfConstructs(miniflat(constructs))
        : handleMapOfConstructs

      function handleMapOfConstructs(code) {
        if (code in constructs || null in constructs) {
          return handleListOfConstructs(
            constructs.null
              ? /* c8 ignore next */
                miniflat(constructs[code]).concat(miniflat(constructs.null))
              : constructs[code]
          )(code)
        }

        return bogusState(code)
      }

      function handleListOfConstructs(list) {
        listOfConstructs = list
        constructIndex = 0
        return handleConstruct(list[constructIndex])
      }

      function handleConstruct(construct) {
        return start

        function start(code) {
          // To do: not nede to store if there is no bogus state, probably?
          // Currently doesn’t work because `inspect` in document does a check
          // w/o a bogus, which doesn’t make sense. But it does seem to help perf
          // by not storing.
          info = store()
          currentConstruct = construct

          if (!construct.partial) {
            context.currentConstruct = construct
          }

          if (
            construct.name &&
            context.parser.constructs.disable.null.indexOf(construct.name) > -1
          ) {
            return nok()
          }

          return construct.tokenize.call(
            fields ? assign({}, context, fields) : context,
            effects,
            ok,
            nok
          )(code)
        }
      }

      function ok(code) {
        onreturn(currentConstruct, info)
        return returnState
      }

      function nok(code) {
        info.restore()

        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex])
        }

        return bogusState
      }
    }
  }

  function addResult(construct, from) {
    if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {
      resolveAllConstructs.push(construct)
    }

    if (construct.resolve) {
      chunkedSplice(
        context.events,
        from,
        context.events.length - from,
        construct.resolve(context.events.slice(from), context)
      )
    }

    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context)
    }
  }

  function store() {
    var startPoint = now()
    var startPrevious = context.previous
    var startCurrentConstruct = context.currentConstruct
    var startEventsIndex = context.events.length
    var startStack = Array.from(stack)
    return {
      restore: restore,
      from: startEventsIndex
    }

    function restore() {
      point = startPoint
      context.previous = startPrevious
      context.currentConstruct = startCurrentConstruct
      context.events.length = startEventsIndex
      stack = startStack
      accountForPotentialSkip()
    }
  }

  function accountForPotentialSkip() {
    if (point.line in columnStart && point.column < 2) {
      point.column = columnStart[point.line]
      point.offset += columnStart[point.line] - 1
    }
  }
}

module.exports = createTokenizer


/***/ }),

/***/ "../../node_modules/micromark/dist/util/miniflat.js":
/*!**********************************************************!*\
  !*** ../../node_modules/micromark/dist/util/miniflat.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


function miniflat(value) {
  return value === null || value === undefined
    ? []
    : 'length' in value
    ? value
    : [value]
}

module.exports = miniflat


/***/ }),

/***/ "../../node_modules/micromark/dist/util/move-point.js":
/*!************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/move-point.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


// chunks (replacement characters, tabs, or line endings).

function movePoint(point, offset) {
  point.column += offset
  point.offset += offset
  point._bufferIndex += offset
  return point
}

module.exports = movePoint


/***/ }),

/***/ "../../node_modules/micromark/dist/util/normalize-identifier.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/normalize-identifier.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


function normalizeIdentifier(value) {
  return (
    value // Collapse Markdown whitespace.
      .replace(/[\t\n\r ]+/g, ' ') // Trim.
      .replace(/^ | $/g, '') // Some characters are considered “uppercase”, but if their lowercase
      // counterpart is uppercased will result in a different uppercase
      // character.
      // Hence, to get that form, we perform both lower- and uppercase.
      // Upper case makes sure keys will not interact with default prototypal
      // methods: no object method is uppercase.
      .toLowerCase()
      .toUpperCase()
  )
}

module.exports = normalizeIdentifier


/***/ }),

/***/ "../../node_modules/micromark/dist/util/prefix-size.js":
/*!*************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/prefix-size.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var sizeChunks = __webpack_require__(/*! ./size-chunks.js */ "../../node_modules/micromark/dist/util/size-chunks.js")

function prefixSize(events, type) {
  var tail = events[events.length - 1]
  if (!tail || tail[1].type !== type) return 0
  return sizeChunks(tail[2].sliceStream(tail[1]))
}

module.exports = prefixSize


/***/ }),

/***/ "../../node_modules/micromark/dist/util/regex-check.js":
/*!*************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/regex-check.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fromCharCode = __webpack_require__(/*! ../constant/from-char-code.js */ "../../node_modules/micromark/dist/constant/from-char-code.js")

function regexCheck(regex) {
  return check

  function check(code) {
    return regex.test(fromCharCode(code))
  }
}

module.exports = regexCheck


/***/ }),

/***/ "../../node_modules/micromark/dist/util/resolve-all.js":
/*!*************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/resolve-all.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


function resolveAll(constructs, events, context) {
  var called = []
  var index = -1
  var resolve

  while (++index < constructs.length) {
    resolve = constructs[index].resolveAll

    if (resolve && called.indexOf(resolve) < 0) {
      events = resolve(events, context)
      called.push(resolve)
    }
  }

  return events
}

module.exports = resolveAll


/***/ }),

/***/ "../../node_modules/micromark/dist/util/safe-from-int.js":
/*!***************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/safe-from-int.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fromCharCode = __webpack_require__(/*! ../constant/from-char-code.js */ "../../node_modules/micromark/dist/constant/from-char-code.js")

function safeFromInt(value, base) {
  var code = parseInt(value, base)

  if (
    // C0 except for HT, LF, FF, CR, space
    code < 9 ||
    code === 11 ||
    (code > 13 && code < 32) || // Control character (DEL) of the basic block and C1 controls.
    (code > 126 && code < 160) || // Lone high surrogates and low surrogates.
    (code > 55295 && code < 57344) || // Noncharacters.
    (code > 64975 && code < 65008) ||
    (code & 65535) === 65535 ||
    (code & 65535) === 65534 || // Out of range
    code > 1114111
  ) {
    return '\uFFFD'
  }

  return fromCharCode(code)
}

module.exports = safeFromInt


/***/ }),

/***/ "../../node_modules/micromark/dist/util/serialize-chunks.js":
/*!******************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/serialize-chunks.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fromCharCode = __webpack_require__(/*! ../constant/from-char-code.js */ "../../node_modules/micromark/dist/constant/from-char-code.js")

function serializeChunks(chunks) {
  var index = -1
  var result = []
  var chunk
  var value
  var atTab

  while (++index < chunks.length) {
    chunk = chunks[index]

    if (typeof chunk === 'string') {
      value = chunk
    } else if (chunk === -5) {
      value = '\r'
    } else if (chunk === -4) {
      value = '\n'
    } else if (chunk === -3) {
      value = '\r' + '\n'
    } else if (chunk === -2) {
      value = '\t'
    } else if (chunk === -1) {
      if (atTab) continue
      value = ' '
    } else {
      // Currently only replacement character.
      value = fromCharCode(chunk)
    }

    atTab = chunk === -2
    result.push(value)
  }

  return result.join('')
}

module.exports = serializeChunks


/***/ }),

/***/ "../../node_modules/micromark/dist/util/shallow.js":
/*!*********************************************************!*\
  !*** ../../node_modules/micromark/dist/util/shallow.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! ../constant/assign.js */ "../../node_modules/micromark/dist/constant/assign.js")

function shallow(object) {
  return assign({}, object)
}

module.exports = shallow


/***/ }),

/***/ "../../node_modules/micromark/dist/util/size-chunks.js":
/*!*************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/size-chunks.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


// Counts tabs based on their expanded size, and CR+LF as one character.

function sizeChunks(chunks) {
  var index = -1
  var size = 0

  while (++index < chunks.length) {
    size += typeof chunks[index] === 'string' ? chunks[index].length : 1
  }

  return size
}

module.exports = sizeChunks


/***/ }),

/***/ "../../node_modules/micromark/dist/util/slice-chunks.js":
/*!**************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/slice-chunks.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";


function sliceChunks(chunks, token) {
  var startIndex = token.start._index
  var startBufferIndex = token.start._bufferIndex
  var endIndex = token.end._index
  var endBufferIndex = token.end._bufferIndex
  var view

  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]
  } else {
    view = chunks.slice(startIndex, endIndex)

    if (startBufferIndex > -1) {
      view[0] = view[0].slice(startBufferIndex)
    }

    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex))
    }
  }

  return view
}

module.exports = sliceChunks


/***/ }),

/***/ "../../node_modules/micromark/dist/util/subtokenize.js":
/*!*************************************************************!*\
  !*** ../../node_modules/micromark/dist/util/subtokenize.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! ../constant/assign.js */ "../../node_modules/micromark/dist/constant/assign.js")
var chunkedSplice = __webpack_require__(/*! ./chunked-splice.js */ "../../node_modules/micromark/dist/util/chunked-splice.js")
var shallow = __webpack_require__(/*! ./shallow.js */ "../../node_modules/micromark/dist/util/shallow.js")

function subtokenize(events) {
  var jumps = {}
  var index = -1
  var event
  var lineIndex
  var otherIndex
  var otherEvent
  var parameters
  var subevents
  var more

  while (++index < events.length) {
    while (index in jumps) {
      index = jumps[index]
    }

    event = events[index] // Add a hook for the GFM tasklist extension, which needs to know if text
    // is in the first content of a list item.

    if (
      index &&
      event[1].type === 'chunkFlow' &&
      events[index - 1][1].type === 'listItemPrefix'
    ) {
      subevents = event[1]._tokenizer.events
      otherIndex = 0

      if (
        otherIndex < subevents.length &&
        subevents[otherIndex][1].type === 'lineEndingBlank'
      ) {
        otherIndex += 2
      }

      if (
        otherIndex < subevents.length &&
        subevents[otherIndex][1].type === 'content'
      ) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === 'content') {
            break
          }

          if (subevents[otherIndex][1].type === 'chunkText') {
            subevents[otherIndex][1].isInFirstContentOfListItem = true
            otherIndex++
          }
        }
      }
    } // Enter.

    if (event[0] === 'enter') {
      if (event[1].contentType) {
        assign(jumps, subcontent(events, index))
        index = jumps[index]
        more = true
      }
    } // Exit.
    else if (event[1]._container || event[1]._movePreviousLineEndings) {
      otherIndex = index
      lineIndex = undefined

      while (otherIndex--) {
        otherEvent = events[otherIndex]

        if (
          otherEvent[1].type === 'lineEnding' ||
          otherEvent[1].type === 'lineEndingBlank'
        ) {
          if (otherEvent[0] === 'enter') {
            if (lineIndex) {
              events[lineIndex][1].type = 'lineEndingBlank'
            }

            otherEvent[1].type = 'lineEnding'
            lineIndex = otherIndex
          }
        } else {
          break
        }
      }

      if (lineIndex) {
        // Fix position.
        event[1].end = shallow(events[lineIndex][1].start) // Switch container exit w/ line endings.

        parameters = events.slice(lineIndex, index)
        parameters.unshift(event)
        chunkedSplice(events, lineIndex, index - lineIndex + 1, parameters)
      }
    }
  }

  return !more
}

function subcontent(events, eventIndex) {
  var token = events[eventIndex][1]
  var context = events[eventIndex][2]
  var startPosition = eventIndex - 1
  var startPositions = []
  var tokenizer =
    token._tokenizer || context.parser[token.contentType](token.start)
  var childEvents = tokenizer.events
  var jumps = []
  var gaps = {}
  var stream
  var previous
  var index
  var entered
  var end
  var adjust // Loop forward through the linked tokens to pass them in order to the
  // subtokenizer.

  while (token) {
    // Find the position of the event for this token.
    while (events[++startPosition][1] !== token) {
      // Empty.
    }

    startPositions.push(startPosition)

    if (!token._tokenizer) {
      stream = context.sliceStream(token)

      if (!token.next) {
        stream.push(null)
      }

      if (previous) {
        tokenizer.defineSkip(token.start)
      }

      if (token.isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true
      }

      tokenizer.write(stream)

      if (token.isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = undefined
      }
    } // Unravel the next token.

    previous = token
    token = token.next
  } // Now, loop back through all events (and linked tokens), to figure out which
  // parts belong where.

  token = previous
  index = childEvents.length

  while (index--) {
    // Make sure we’ve at least seen something (final eol is part of the last
    // token).
    if (childEvents[index][0] === 'enter') {
      entered = true
    } else if (
      // Find a void token that includes a break.
      entered &&
      childEvents[index][1].type === childEvents[index - 1][1].type &&
      childEvents[index][1].start.line !== childEvents[index][1].end.line
    ) {
      add(childEvents.slice(index + 1, end))
      // Help GC.
      token._tokenizer = token.next = undefined
      token = token.previous
      end = index + 1
    }
  }

  // Help GC.
  tokenizer.events = token._tokenizer = token.next = undefined // Do head:

  add(childEvents.slice(0, end))
  index = -1
  adjust = 0

  while (++index < jumps.length) {
    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1]
    adjust += jumps[index][1] - jumps[index][0] - 1
  }

  return gaps

  function add(slice) {
    var start = startPositions.pop()
    jumps.unshift([start, start + slice.length - 1])
    chunkedSplice(events, start, 2, slice)
  }
}

module.exports = subtokenize


/***/ }),

/***/ "../../node_modules/object-assign/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/object-assign/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "../../node_modules/parse-entities/decode-entity.browser.js":
/*!******************************************************************!*\
  !*** ../../node_modules/parse-entities/decode-entity.browser.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";


/* eslint-env browser */

var el

var semicolon = 59 //  ';'

module.exports = decodeEntity

function decodeEntity(characters) {
  var entity = '&' + characters + ';'
  var char

  el = el || document.createElement('i')
  el.innerHTML = entity
  char = el.textContent

  // Some entities do not require the closing semicolon (`&not` - for instance),
  // which leads to situations where parsing the assumed entity of &notit; will
  // result in the string `¬it;`.  When we encounter a trailing semicolon after
  // parsing and the entity to decode was not a semicolon (`&semi;`), we can
  // assume that the matching was incomplete
  if (char.charCodeAt(char.length - 1) === semicolon && characters !== 'semi') {
    return false
  }

  // If the decoded string is equal to the input, the entity was not valid
  return char === entity ? false : char
}


/***/ }),

/***/ "../../node_modules/prop-types/checkPropTypes.js":
/*!*******************************************************!*\
  !*** ../../node_modules/prop-types/checkPropTypes.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = __webpack_require__(/*! ./lib/has */ "../../node_modules/prop-types/lib/has.js");

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) { /**/ }
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "../../node_modules/prop-types/factoryWithTypeCheckers.js":
/*!****************************************************************!*\
  !*** ../../node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "../../node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "../../node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js");
var has = __webpack_require__(/*! ./lib/has */ "../../node_modules/prop-types/lib/has.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "../../node_modules/prop-types/checkPropTypes.js");

var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bigint: createPrimitiveTypeChecker('bigint'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message, data) {
    this.message = message;
    this.data = data && typeof data === 'object' ? data: {};
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError(
          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
          {expectedType: expectedType}
        );
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      var expectedTypes = [];
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
        if (checkerResult == null) {
          return null;
        }
        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
          expectedTypes.push(checkerResult.data.expectedType);
        }
      }
      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function invalidValidatorError(componentName, location, propFullName, key, type) {
    return new PropTypeError(
      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
    );
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (has(shapeTypes, key) && typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "../../node_modules/prop-types/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/prop-types/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "../../node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "../../node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else // removed by dead control flow
{}


/***/ }),

/***/ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "../../node_modules/prop-types/lib/has.js":
/*!************************************************!*\
  !*** ../../node_modules/prop-types/lib/has.js ***!
  \************************************************/
/***/ ((module) => {

module.exports = Function.call.bind(Object.prototype.hasOwnProperty);


/***/ }),

/***/ "../../node_modules/property-information/find.js":
/*!*******************************************************!*\
  !*** ../../node_modules/property-information/find.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var normalize = __webpack_require__(/*! ./normalize */ "../../node_modules/property-information/normalize.js")
var DefinedInfo = __webpack_require__(/*! ./lib/util/defined-info */ "../../node_modules/property-information/lib/util/defined-info.js")
var Info = __webpack_require__(/*! ./lib/util/info */ "../../node_modules/property-information/lib/util/info.js")

var data = 'data'

module.exports = find

var valid = /^data[-\w.:]+$/i
var dash = /-[a-z]/g
var cap = /[A-Z]/g

function find(schema, value) {
  var normal = normalize(value)
  var prop = value
  var Type = Info

  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]]
  }

  if (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value)) {
    // Attribute or property.
    if (value.charAt(4) === '-') {
      prop = datasetToProperty(value)
    } else {
      value = datasetToAttribute(value)
    }

    Type = DefinedInfo
  }

  return new Type(prop, value)
}

function datasetToProperty(attribute) {
  var value = attribute.slice(5).replace(dash, camelcase)
  return data + value.charAt(0).toUpperCase() + value.slice(1)
}

function datasetToAttribute(property) {
  var value = property.slice(4)

  if (dash.test(value)) {
    return property
  }

  value = value.replace(cap, kebab)

  if (value.charAt(0) !== '-') {
    value = '-' + value
  }

  return data + value
}

function kebab($0) {
  return '-' + $0.toLowerCase()
}

function camelcase($0) {
  return $0.charAt(1).toUpperCase()
}


/***/ }),

/***/ "../../node_modules/property-information/hast-to-react.json":
/*!******************************************************************!*\
  !*** ../../node_modules/property-information/hast-to-react.json ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"classId":"classID","dataType":"datatype","itemId":"itemID","strokeDashArray":"strokeDasharray","strokeDashOffset":"strokeDashoffset","strokeLineCap":"strokeLinecap","strokeLineJoin":"strokeLinejoin","strokeMiterLimit":"strokeMiterlimit","typeOf":"typeof","xLinkActuate":"xlinkActuate","xLinkArcRole":"xlinkArcrole","xLinkHref":"xlinkHref","xLinkRole":"xlinkRole","xLinkShow":"xlinkShow","xLinkTitle":"xlinkTitle","xLinkType":"xlinkType","xmlnsXLink":"xmlnsXlink"}');

/***/ }),

/***/ "../../node_modules/property-information/html.js":
/*!*******************************************************!*\
  !*** ../../node_modules/property-information/html.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var merge = __webpack_require__(/*! ./lib/util/merge */ "../../node_modules/property-information/lib/util/merge.js")
var xlink = __webpack_require__(/*! ./lib/xlink */ "../../node_modules/property-information/lib/xlink.js")
var xml = __webpack_require__(/*! ./lib/xml */ "../../node_modules/property-information/lib/xml.js")
var xmlns = __webpack_require__(/*! ./lib/xmlns */ "../../node_modules/property-information/lib/xmlns.js")
var aria = __webpack_require__(/*! ./lib/aria */ "../../node_modules/property-information/lib/aria.js")
var html = __webpack_require__(/*! ./lib/html */ "../../node_modules/property-information/lib/html.js")

module.exports = merge([xml, xlink, xmlns, aria, html])


/***/ }),

/***/ "../../node_modules/property-information/lib/aria.js":
/*!***********************************************************!*\
  !*** ../../node_modules/property-information/lib/aria.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var types = __webpack_require__(/*! ./util/types */ "../../node_modules/property-information/lib/util/types.js")
var create = __webpack_require__(/*! ./util/create */ "../../node_modules/property-information/lib/util/create.js")

var booleanish = types.booleanish
var number = types.number
var spaceSeparated = types.spaceSeparated

module.exports = create({
  transform: ariaTransform,
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
})

function ariaTransform(_, prop) {
  return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase()
}


/***/ }),

/***/ "../../node_modules/property-information/lib/html.js":
/*!***********************************************************!*\
  !*** ../../node_modules/property-information/lib/html.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var types = __webpack_require__(/*! ./util/types */ "../../node_modules/property-information/lib/util/types.js")
var create = __webpack_require__(/*! ./util/create */ "../../node_modules/property-information/lib/util/create.js")
var caseInsensitiveTransform = __webpack_require__(/*! ./util/case-insensitive-transform */ "../../node_modules/property-information/lib/util/case-insensitive-transform.js")

var boolean = types.boolean
var overloadedBoolean = types.overloadedBoolean
var booleanish = types.booleanish
var number = types.number
var spaceSeparated = types.spaceSeparated
var commaSeparated = types.commaSeparated

module.exports = create({
  space: 'html',
  attributes: {
    acceptcharset: 'accept-charset',
    classname: 'class',
    htmlfor: 'for',
    httpequiv: 'http-equiv'
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    capture: boolean,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: commaSeparated,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextMenu: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: commaSeparated,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,

    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null, // Several. Use CSS `text-align` instead,
    aLink: null, // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated, // `<object>`. List of URIs to archives
    axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null, // `<body>`. Use CSS `background-image` instead
    bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead
    border: number, // `<table>`. Use CSS `border-width` instead,
    borderColor: null, // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number, // `<body>`
    cellPadding: null, // `<table>`
    cellSpacing: null, // `<table>`
    char: null, // Several table elements. When `align=char`, sets the character to align on
    charOff: null, // Several table elements. When `char`, offsets the alignment
    classId: null, // `<object>`
    clear: null, // `<br>`. Use CSS `clear` instead
    code: null, // `<object>`
    codeBase: null, // `<object>`
    codeType: null, // `<object>`
    color: null, // `<font>` and `<hr>`. Use CSS instead
    compact: boolean, // Lists. Use CSS to reduce space between items instead
    declare: boolean, // `<object>`
    event: null, // `<script>`
    face: null, // `<font>`. Use CSS instead
    frame: null, // `<table>`
    frameBorder: null, // `<iframe>`. Use CSS `border` instead
    hSpace: number, // `<img>` and `<object>`
    leftMargin: number, // `<body>`
    link: null, // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null, // `<img>`. Use a `<picture>`
    marginHeight: number, // `<body>`
    marginWidth: number, // `<body>`
    noResize: boolean, // `<frame>`
    noHref: boolean, // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean, // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean, // `<td>` and `<th>`
    object: null, // `<applet>`
    profile: null, // `<head>`
    prompt: null, // `<isindex>`
    rev: null, // `<link>`
    rightMargin: number, // `<body>`
    rules: null, // `<table>`
    scheme: null, // `<meta>`
    scrolling: booleanish, // `<frame>`. Use overflow in the child context
    standby: null, // `<object>`
    summary: null, // `<table>`
    text: null, // `<body>`. Use CSS `color` instead
    topMargin: number, // `<body>`
    valueType: null, // `<param>`
    version: null, // `<html>`. Use a doctype.
    vAlign: null, // Several. Use CSS `vertical-align` instead
    vLink: null, // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number, // `<img>` and `<object>`

    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
})


/***/ }),

/***/ "../../node_modules/property-information/lib/svg.js":
/*!**********************************************************!*\
  !*** ../../node_modules/property-information/lib/svg.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var types = __webpack_require__(/*! ./util/types */ "../../node_modules/property-information/lib/util/types.js")
var create = __webpack_require__(/*! ./util/create */ "../../node_modules/property-information/lib/util/create.js")
var caseSensitiveTransform = __webpack_require__(/*! ./util/case-sensitive-transform */ "../../node_modules/property-information/lib/util/case-sensitive-transform.js")

var boolean = types.boolean
var number = types.number
var spaceSeparated = types.spaceSeparated
var commaSeparated = types.commaSeparated
var commaOrSpaceSeparated = types.commaOrSpaceSeparated

module.exports = create({
  space: 'svg',
  attributes: {
    accentHeight: 'accent-height',
    alignmentBaseline: 'alignment-baseline',
    arabicForm: 'arabic-form',
    baselineShift: 'baseline-shift',
    capHeight: 'cap-height',
    className: 'class',
    clipPath: 'clip-path',
    clipRule: 'clip-rule',
    colorInterpolation: 'color-interpolation',
    colorInterpolationFilters: 'color-interpolation-filters',
    colorProfile: 'color-profile',
    colorRendering: 'color-rendering',
    crossOrigin: 'crossorigin',
    dataType: 'datatype',
    dominantBaseline: 'dominant-baseline',
    enableBackground: 'enable-background',
    fillOpacity: 'fill-opacity',
    fillRule: 'fill-rule',
    floodColor: 'flood-color',
    floodOpacity: 'flood-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    fontSizeAdjust: 'font-size-adjust',
    fontStretch: 'font-stretch',
    fontStyle: 'font-style',
    fontVariant: 'font-variant',
    fontWeight: 'font-weight',
    glyphName: 'glyph-name',
    glyphOrientationHorizontal: 'glyph-orientation-horizontal',
    glyphOrientationVertical: 'glyph-orientation-vertical',
    hrefLang: 'hreflang',
    horizAdvX: 'horiz-adv-x',
    horizOriginX: 'horiz-origin-x',
    horizOriginY: 'horiz-origin-y',
    imageRendering: 'image-rendering',
    letterSpacing: 'letter-spacing',
    lightingColor: 'lighting-color',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    navDown: 'nav-down',
    navDownLeft: 'nav-down-left',
    navDownRight: 'nav-down-right',
    navLeft: 'nav-left',
    navNext: 'nav-next',
    navPrev: 'nav-prev',
    navRight: 'nav-right',
    navUp: 'nav-up',
    navUpLeft: 'nav-up-left',
    navUpRight: 'nav-up-right',
    onAbort: 'onabort',
    onActivate: 'onactivate',
    onAfterPrint: 'onafterprint',
    onBeforePrint: 'onbeforeprint',
    onBegin: 'onbegin',
    onCancel: 'oncancel',
    onCanPlay: 'oncanplay',
    onCanPlayThrough: 'oncanplaythrough',
    onChange: 'onchange',
    onClick: 'onclick',
    onClose: 'onclose',
    onCopy: 'oncopy',
    onCueChange: 'oncuechange',
    onCut: 'oncut',
    onDblClick: 'ondblclick',
    onDrag: 'ondrag',
    onDragEnd: 'ondragend',
    onDragEnter: 'ondragenter',
    onDragExit: 'ondragexit',
    onDragLeave: 'ondragleave',
    onDragOver: 'ondragover',
    onDragStart: 'ondragstart',
    onDrop: 'ondrop',
    onDurationChange: 'ondurationchange',
    onEmptied: 'onemptied',
    onEnd: 'onend',
    onEnded: 'onended',
    onError: 'onerror',
    onFocus: 'onfocus',
    onFocusIn: 'onfocusin',
    onFocusOut: 'onfocusout',
    onHashChange: 'onhashchange',
    onInput: 'oninput',
    onInvalid: 'oninvalid',
    onKeyDown: 'onkeydown',
    onKeyPress: 'onkeypress',
    onKeyUp: 'onkeyup',
    onLoad: 'onload',
    onLoadedData: 'onloadeddata',
    onLoadedMetadata: 'onloadedmetadata',
    onLoadStart: 'onloadstart',
    onMessage: 'onmessage',
    onMouseDown: 'onmousedown',
    onMouseEnter: 'onmouseenter',
    onMouseLeave: 'onmouseleave',
    onMouseMove: 'onmousemove',
    onMouseOut: 'onmouseout',
    onMouseOver: 'onmouseover',
    onMouseUp: 'onmouseup',
    onMouseWheel: 'onmousewheel',
    onOffline: 'onoffline',
    onOnline: 'ononline',
    onPageHide: 'onpagehide',
    onPageShow: 'onpageshow',
    onPaste: 'onpaste',
    onPause: 'onpause',
    onPlay: 'onplay',
    onPlaying: 'onplaying',
    onPopState: 'onpopstate',
    onProgress: 'onprogress',
    onRateChange: 'onratechange',
    onRepeat: 'onrepeat',
    onReset: 'onreset',
    onResize: 'onresize',
    onScroll: 'onscroll',
    onSeeked: 'onseeked',
    onSeeking: 'onseeking',
    onSelect: 'onselect',
    onShow: 'onshow',
    onStalled: 'onstalled',
    onStorage: 'onstorage',
    onSubmit: 'onsubmit',
    onSuspend: 'onsuspend',
    onTimeUpdate: 'ontimeupdate',
    onToggle: 'ontoggle',
    onUnload: 'onunload',
    onVolumeChange: 'onvolumechange',
    onWaiting: 'onwaiting',
    onZoom: 'onzoom',
    overlinePosition: 'overline-position',
    overlineThickness: 'overline-thickness',
    paintOrder: 'paint-order',
    panose1: 'panose-1',
    pointerEvents: 'pointer-events',
    referrerPolicy: 'referrerpolicy',
    renderingIntent: 'rendering-intent',
    shapeRendering: 'shape-rendering',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strikethroughPosition: 'strikethrough-position',
    strikethroughThickness: 'strikethrough-thickness',
    strokeDashArray: 'stroke-dasharray',
    strokeDashOffset: 'stroke-dashoffset',
    strokeLineCap: 'stroke-linecap',
    strokeLineJoin: 'stroke-linejoin',
    strokeMiterLimit: 'stroke-miterlimit',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    tabIndex: 'tabindex',
    textAnchor: 'text-anchor',
    textDecoration: 'text-decoration',
    textRendering: 'text-rendering',
    typeOf: 'typeof',
    underlinePosition: 'underline-position',
    underlineThickness: 'underline-thickness',
    unicodeBidi: 'unicode-bidi',
    unicodeRange: 'unicode-range',
    unitsPerEm: 'units-per-em',
    vAlphabetic: 'v-alphabetic',
    vHanging: 'v-hanging',
    vIdeographic: 'v-ideographic',
    vMathematical: 'v-mathematical',
    vectorEffect: 'vector-effect',
    vertAdvY: 'vert-adv-y',
    vertOriginX: 'vert-origin-x',
    vertOriginY: 'vert-origin-y',
    wordSpacing: 'word-spacing',
    writingMode: 'writing-mode',
    xHeight: 'x-height',
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: 'playbackorder',
    timelineBegin: 'timelinebegin'
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null, // SEMI_COLON_SEPARATED
    keySplines: null, // SEMI_COLON_SEPARATED
    keyTimes: null, // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
})


/***/ }),

/***/ "../../node_modules/property-information/lib/util/case-insensitive-transform.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/case-insensitive-transform.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var caseSensitiveTransform = __webpack_require__(/*! ./case-sensitive-transform */ "../../node_modules/property-information/lib/util/case-sensitive-transform.js")

module.exports = caseInsensitiveTransform

function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase())
}


/***/ }),

/***/ "../../node_modules/property-information/lib/util/case-sensitive-transform.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/case-sensitive-transform.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = caseSensitiveTransform

function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute
}


/***/ }),

/***/ "../../node_modules/property-information/lib/util/create.js":
/*!******************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/create.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var normalize = __webpack_require__(/*! ../../normalize */ "../../node_modules/property-information/normalize.js")
var Schema = __webpack_require__(/*! ./schema */ "../../node_modules/property-information/lib/util/schema.js")
var DefinedInfo = __webpack_require__(/*! ./defined-info */ "../../node_modules/property-information/lib/util/defined-info.js")

module.exports = create

function create(definition) {
  var space = definition.space
  var mustUseProperty = definition.mustUseProperty || []
  var attributes = definition.attributes || {}
  var props = definition.properties
  var transform = definition.transform
  var property = {}
  var normal = {}
  var prop
  var info

  for (prop in props) {
    info = new DefinedInfo(
      prop,
      transform(attributes, prop),
      props[prop],
      space
    )

    if (mustUseProperty.indexOf(prop) !== -1) {
      info.mustUseProperty = true
    }

    property[prop] = info

    normal[normalize(prop)] = prop
    normal[normalize(info.attribute)] = prop
  }

  return new Schema(property, normal, space)
}


/***/ }),

/***/ "../../node_modules/property-information/lib/util/defined-info.js":
/*!************************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/defined-info.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Info = __webpack_require__(/*! ./info */ "../../node_modules/property-information/lib/util/info.js")
var types = __webpack_require__(/*! ./types */ "../../node_modules/property-information/lib/util/types.js")

module.exports = DefinedInfo

DefinedInfo.prototype = new Info()
DefinedInfo.prototype.defined = true

var checks = [
  'boolean',
  'booleanish',
  'overloadedBoolean',
  'number',
  'commaSeparated',
  'spaceSeparated',
  'commaOrSpaceSeparated'
]
var checksLength = checks.length

function DefinedInfo(property, attribute, mask, space) {
  var index = -1
  var check

  mark(this, 'space', space)

  Info.call(this, property, attribute)

  while (++index < checksLength) {
    check = checks[index]
    mark(this, check, (mask & types[check]) === types[check])
  }
}

function mark(values, key, value) {
  if (value) {
    values[key] = value
  }
}


/***/ }),

/***/ "../../node_modules/property-information/lib/util/info.js":
/*!****************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/info.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";


module.exports = Info

var proto = Info.prototype

proto.space = null
proto.attribute = null
proto.property = null
proto.boolean = false
proto.booleanish = false
proto.overloadedBoolean = false
proto.number = false
proto.commaSeparated = false
proto.spaceSeparated = false
proto.commaOrSpaceSeparated = false
proto.mustUseProperty = false
proto.defined = false

function Info(property, attribute) {
  this.property = property
  this.attribute = attribute
}


/***/ }),

/***/ "../../node_modules/property-information/lib/util/merge.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/merge.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var xtend = __webpack_require__(/*! xtend */ "../../node_modules/xtend/immutable.js")
var Schema = __webpack_require__(/*! ./schema */ "../../node_modules/property-information/lib/util/schema.js")

module.exports = merge

function merge(definitions) {
  var length = definitions.length
  var property = []
  var normal = []
  var index = -1
  var info
  var space

  while (++index < length) {
    info = definitions[index]
    property.push(info.property)
    normal.push(info.normal)
    space = info.space
  }

  return new Schema(
    xtend.apply(null, property),
    xtend.apply(null, normal),
    space
  )
}


/***/ }),

/***/ "../../node_modules/property-information/lib/util/schema.js":
/*!******************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/schema.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";


module.exports = Schema

var proto = Schema.prototype

proto.space = null
proto.normal = {}
proto.property = {}

function Schema(property, normal, space) {
  this.property = property
  this.normal = normal

  if (space) {
    this.space = space
  }
}


/***/ }),

/***/ "../../node_modules/property-information/lib/util/types.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/property-information/lib/util/types.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var powers = 0

exports.boolean = increment()
exports.booleanish = increment()
exports.overloadedBoolean = increment()
exports.number = increment()
exports.spaceSeparated = increment()
exports.commaSeparated = increment()
exports.commaOrSpaceSeparated = increment()

function increment() {
  return Math.pow(2, ++powers)
}


/***/ }),

/***/ "../../node_modules/property-information/lib/xlink.js":
/*!************************************************************!*\
  !*** ../../node_modules/property-information/lib/xlink.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var create = __webpack_require__(/*! ./util/create */ "../../node_modules/property-information/lib/util/create.js")

module.exports = create({
  space: 'xlink',
  transform: xlinkTransform,
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
})

function xlinkTransform(_, prop) {
  return 'xlink:' + prop.slice(5).toLowerCase()
}


/***/ }),

/***/ "../../node_modules/property-information/lib/xml.js":
/*!**********************************************************!*\
  !*** ../../node_modules/property-information/lib/xml.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var create = __webpack_require__(/*! ./util/create */ "../../node_modules/property-information/lib/util/create.js")

module.exports = create({
  space: 'xml',
  transform: xmlTransform,
  properties: {
    xmlLang: null,
    xmlBase: null,
    xmlSpace: null
  }
})

function xmlTransform(_, prop) {
  return 'xml:' + prop.slice(3).toLowerCase()
}


/***/ }),

/***/ "../../node_modules/property-information/lib/xmlns.js":
/*!************************************************************!*\
  !*** ../../node_modules/property-information/lib/xmlns.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var create = __webpack_require__(/*! ./util/create */ "../../node_modules/property-information/lib/util/create.js")
var caseInsensitiveTransform = __webpack_require__(/*! ./util/case-insensitive-transform */ "../../node_modules/property-information/lib/util/case-insensitive-transform.js")

module.exports = create({
  space: 'xmlns',
  attributes: {
    xmlnsxlink: 'xmlns:xlink'
  },
  transform: caseInsensitiveTransform,
  properties: {
    xmlns: null,
    xmlnsXLink: null
  }
})


/***/ }),

/***/ "../../node_modules/property-information/normalize.js":
/*!************************************************************!*\
  !*** ../../node_modules/property-information/normalize.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = normalize

function normalize(value) {
  return value.toLowerCase()
}


/***/ }),

/***/ "../../node_modules/property-information/svg.js":
/*!******************************************************!*\
  !*** ../../node_modules/property-information/svg.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var merge = __webpack_require__(/*! ./lib/util/merge */ "../../node_modules/property-information/lib/util/merge.js")
var xlink = __webpack_require__(/*! ./lib/xlink */ "../../node_modules/property-information/lib/xlink.js")
var xml = __webpack_require__(/*! ./lib/xml */ "../../node_modules/property-information/lib/xml.js")
var xmlns = __webpack_require__(/*! ./lib/xmlns */ "../../node_modules/property-information/lib/xmlns.js")
var aria = __webpack_require__(/*! ./lib/aria */ "../../node_modules/property-information/lib/aria.js")
var svg = __webpack_require__(/*! ./lib/svg */ "../../node_modules/property-information/lib/svg.js")

module.exports = merge([xml, xlink, xmlns, aria, svg])


/***/ }),

/***/ "../../node_modules/react-is/cjs/react-is.development.js":
/*!***************************************************************!*\
  !*** ../../node_modules/react-is/cjs/react-is.development.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "../../node_modules/react-is/index.js":
/*!********************************************!*\
  !*** ../../node_modules/react-is/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) // removed by dead control flow
{} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "../../node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "../../node_modules/react-markdown/node_modules/react-is/cjs/react-is.development.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/react-markdown/node_modules/react-is/cjs/react-is.development.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v17.0.2
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
var REACT_FRAGMENT_TYPE = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
          case REACT_SUSPENSE_LIST_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
}
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false;
var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
    }
  }

  return false;
}
function isConcurrentMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
    }
  }

  return false;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "../../node_modules/react-markdown/node_modules/react-is/index.js":
/*!************************************************************************!*\
  !*** ../../node_modules/react-markdown/node_modules/react-is/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) // removed by dead control flow
{} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "../../node_modules/react-markdown/node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "../../node_modules/react-markdown/src/ast-to-react.js":
/*!*************************************************************!*\
  !*** ../../node_modules/react-markdown/src/ast-to-react.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const React = __webpack_require__(/*! react */ "react")
const ReactIs = __webpack_require__(/*! react-is */ "../../node_modules/react-markdown/node_modules/react-is/index.js")
const svg = __webpack_require__(/*! property-information/svg */ "../../node_modules/property-information/svg.js")
const find = __webpack_require__(/*! property-information/find */ "../../node_modules/property-information/find.js")
const hastToReact = __webpack_require__(/*! property-information/hast-to-react.json */ "../../node_modules/property-information/hast-to-react.json")
const spaces = __webpack_require__(/*! space-separated-tokens */ "../../node_modules/space-separated-tokens/index.js")
const commas = __webpack_require__(/*! comma-separated-tokens */ "../../node_modules/comma-separated-tokens/index.js")
const style = __webpack_require__(/*! style-to-object */ "../../node_modules/style-to-object/index.js")

exports.hastToReact = toReact
exports.hastChildrenToReact = childrenToReact

/**
 * @typedef {JSX.IntrinsicElements} IntrinsicElements
 * @typedef {import('react').ReactNode} ReactNode
 * @typedef {import('unist').Position} Position
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Text} Text
 * @typedef {import('hast').Comment} Comment
 * @typedef {import('hast').DocType} Doctype
 */

/**
 * @typedef Info
 * @property {string?} space
 * @property {string?} attribute
 * @property {string?} property
 * @property {boolean} boolean
 * @property {boolean} booleanish
 * @property {boolean} overloadedBoolean
 * @property {boolean} number
 * @property {boolean} commaSeparated
 * @property {boolean} spaceSeparated
 * @property {boolean} commaOrSpaceSeparated
 * @property {boolean} mustUseProperty
 * @property {boolean} defined
 *
 * @typedef Schema
 * @property {Object.<string, Info>} property
 * @property {Object.<string, string>} normal
 * @property {string?} space
 *
 * @typedef Raw
 * @property {'raw'} type
 * @property {string} value
 *
 * @typedef Context
 * @property {TransformOptions} options
 * @property {Schema} schema
 * @property {number} listDepth
 *
 * @callback TransformLink
 * @param {string} href
 * @param {Array.<Comment|Element|Text>} children
 * @param {string?} title
 * @returns {string}
 *
 * @callback TransformImage
 * @param {string} src
 * @param {string} alt
 * @param {string?} title
 * @returns {string}
 *
 * @callback TransformLinkTarget
 * @param {string} href
 * @param {Array.<Comment|Element|Text>} children
 * @param {string?} title
 * @returns {string|undefined}
 *
 * @typedef {keyof IntrinsicElements} ReactMarkdownNames
 *
 * To do: is `data-sourcepos` typeable?
 *
 * @typedef ReactMarkdownProps
 * @property {Element} node
 * @property {string} key
 * @property {ReactNode[]} children
 * @property {Position?} [sourcePosition] Passed when `options.rawSourcePos` is given
 * @property {number} [index] Passed when `options.includeElementIndex` is given
 * @property {number} [siblingCount] Passed when `options.includeElementIndex` is given
 *
 * @callback CodeComponent
 * @param {JSX.IntrinsicElements['code'] & ReactMarkdownProps & {inline?: boolean}} props
 * @returns {ReactNode}
 *
 * @callback HeadingComponent
 * @param {JSX.IntrinsicElements['h1'] & ReactMarkdownProps & {level: number}} props
 * @returns {ReactNode}
 *
 * @callback LiComponent
 * @param {JSX.IntrinsicElements['li'] & ReactMarkdownProps & {checked: boolean|null, index: number, ordered: boolean}} props
 * @returns {ReactNode}
 *
 * @callback OrderedListComponent
 * @param {JSX.IntrinsicElements['ol'] & ReactMarkdownProps & {depth: number, ordered: true}} props
 * @returns {ReactNode}
 *
 * @callback TableCellComponent
 * @param {JSX.IntrinsicElements['table'] & ReactMarkdownProps & {style?: Object.<string, unknown>, isHeader: boolean}} props
 * @returns {ReactNode}
 *
 * @callback TableRowComponent
 * @param {JSX.IntrinsicElements['tr'] & ReactMarkdownProps & {isHeader: boolean}} props
 * @returns {ReactNode}
 *
 * @callback UnorderedListComponent
 * @param {JSX.IntrinsicElements['ul'] & ReactMarkdownProps & {depth: number, ordered: false}} props
 * @returns {ReactNode}
 *
 * @typedef SpecialComponents
 * @property {CodeComponent|ReactMarkdownNames} code
 * @property {HeadingComponent|ReactMarkdownNames} h1
 * @property {HeadingComponent|ReactMarkdownNames} h2
 * @property {HeadingComponent|ReactMarkdownNames} h3
 * @property {HeadingComponent|ReactMarkdownNames} h4
 * @property {HeadingComponent|ReactMarkdownNames} h5
 * @property {HeadingComponent|ReactMarkdownNames} h6
 * @property {LiComponent|ReactMarkdownNames} li
 * @property {OrderedListComponent|ReactMarkdownNames} ol
 * @property {TableCellComponent|ReactMarkdownNames} td
 * @property {TableCellComponent|ReactMarkdownNames} th
 * @property {TableRowComponent|ReactMarkdownNames} tr
 * @property {UnorderedListComponent|ReactMarkdownNames} ul
 *
 * @typedef {{[TagName in keyof IntrinsicElements]: TagName | ((props: IntrinsicElements[TagName] & ReactMarkdownProps) => ReactNode)}} NormalComponents
 * @typedef {Partial<Omit<NormalComponents, keyof SpecialComponents> & SpecialComponents>} Components
 */

/**
 * @typedef TransformOptions
 * @property {boolean} [sourcePos=false]
 * @property {boolean} [rawSourcePos=false]
 * @property {boolean} [skipHtml=false]
 * @property {boolean} [includeElementIndex=false]
 * @property {null|false|TransformLink} [transformLinkUri]
 * @property {TransformImage} [transformImageUri]
 * @property {string|TransformLinkTarget} [linkTarget]
 * @property {Components} [components]
 */

const own = {}.hasOwnProperty

// The table-related elements that must not contain whitespace text according
// to React.
const tableElements = new Set(['table', 'thead', 'tbody', 'tfoot', 'tr'])

/**
 * @param {Context} context
 * @param {Element|Root} node
 */
function childrenToReact(context, node) {
  /** @type {Array.<ReactNode>} */
  const children = []
  let childIndex = -1
  /** @type {Comment|Doctype|Element|Raw|Text} */
  let child

  while (++childIndex < node.children.length) {
    child = node.children[childIndex]

    if (child.type === 'element') {
      children.push(toReact(context, child, childIndex, node))
    } else if (child.type === 'text') {
      // React does not permit whitespace text elements as children of table:
      // cf. https://github.com/remarkjs/react-markdown/issues/576
      if (
        node.type !== 'element' ||
        !tableElements.has(node.tagName) ||
        child.value !== '\n'
      ) {
        children.push(child.value)
      }
    }
    // @ts-expect-error `raw` nodes are non-standard
    else if (child.type === 'raw' && !context.options.skipHtml) {
      // Default behavior is to show (encoded) HTML.
      // @ts-expect-error `raw` nodes are non-standard
      children.push(child.value)
    }
  }

  return children
}

/**
 * @param {Context} context
 * @param {Element} node
 * @param {number} index
 * @param {Element|Root} parent
 */
function toReact(context, node, index, parent) {
  const options = context.options
  const parentSchema = context.schema
  /** @type {ReactMarkdownNames} */
  // @ts-expect-error assume a known HTML/SVG element.
  const name = node.tagName
  /** @type {Object.<string, unknown>} */
  const properties = {}
  let schema = parentSchema
  /** @type {string} */
  let property

  if (parentSchema.space === 'html' && name === 'svg') {
    schema = svg
    context.schema = schema
  }

  /* istanbul ignore else - types say they’re optional. */
  if (node.properties) {
    for (property in node.properties) {
      /* istanbul ignore else - prototype polution. */
      if (own.call(node.properties, property)) {
        addProperty(properties, property, node.properties[property], context)
      }
    }
  }

  if (name === 'ol' || name === 'ul') {
    context.listDepth++
  }

  const children = childrenToReact(context, node)

  if (name === 'ol' || name === 'ul') {
    context.listDepth--
  }

  // Restore parent schema.
  context.schema = parentSchema

  // Nodes created by plugins do not have positional info, in which case we use
  // an object that matches the positon interface.
  const position = node.position || {
    start: {line: null, column: null, offset: null},
    end: {line: null, column: null, offset: null}
  }
  const component =
    options.components && own.call(options.components, name)
      ? options.components[name]
      : name
  const basic = typeof component === 'string' || component === React.Fragment

  if (!ReactIs.isValidElementType(component)) {
    throw new TypeError(
      `Component for name \`${name}\` not defined or is not renderable`
    )
  }

  properties.key = [
    name,
    position.start.line,
    position.start.column,
    index
  ].join('-')

  if (name === 'a' && options.linkTarget) {
    properties.target =
      typeof options.linkTarget === 'function'
        ? // @ts-expect-error assume `href` is a string
          options.linkTarget(properties.href, node.children, properties.title)
        : options.linkTarget
  }

  if (name === 'a' && options.transformLinkUri) {
    properties.href = options.transformLinkUri(
      // @ts-expect-error assume `href` is a string
      properties.href,
      node.children,
      properties.title
    )
  }

  if (
    !basic &&
    name === 'code' &&
    parent.type === 'element' &&
    parent.tagName !== 'pre'
  ) {
    properties.inline = true
  }

  if (
    !basic &&
    (name === 'h1' ||
      name === 'h2' ||
      name === 'h3' ||
      name === 'h4' ||
      name === 'h5' ||
      name === 'h6')
  ) {
    properties.level = parseInt(name.charAt(1), 10)
  }

  if (name === 'img' && options.transformImageUri) {
    properties.src = options.transformImageUri(
      // @ts-expect-error assume `src` is a string
      properties.src,
      properties.alt,
      properties.title
    )
  }

  if (!basic && name === 'li' && parent.type === 'element') {
    const input = getInputElement(node)
    properties.checked =
      input && input.properties ? Boolean(input.properties.checked) : null
    properties.index = getElementsBeforeCount(parent, node)
    properties.ordered = parent.tagName === 'ol'
  }

  if (!basic && (name === 'ol' || name === 'ul')) {
    properties.ordered = name === 'ol'
    properties.depth = context.listDepth
  }

  if (name === 'td' || name === 'th') {
    if (properties.align) {
      if (!properties.style) properties.style = {}
      // @ts-expect-error assume `style` is an object
      properties.style.textAlign = properties.align
      delete properties.align
    }

    if (!basic) {
      properties.isHeader = name === 'th'
    }
  }

  if (!basic && name === 'tr' && parent.type === 'element') {
    properties.isHeader = Boolean(parent.tagName === 'thead')
  }

  // If `sourcePos` is given, pass source information (line/column info from markdown source).
  if (options.sourcePos) {
    properties['data-sourcepos'] = flattenPosition(position)
  }

  if (!basic && options.rawSourcePos) {
    properties.sourcePosition = node.position
  }

  // If `includeElementIndex` is given, pass node index info to components.
  if (!basic && options.includeElementIndex) {
    properties.index = getElementsBeforeCount(parent, node)
    properties.siblingCount = getElementsBeforeCount(parent)
  }

  if (!basic) {
    properties.node = node
  }

  // Ensure no React warnings are emitted for void elements w/ children.
  return children.length > 0
    ? React.createElement(component, properties, children)
    : React.createElement(component, properties)
}

/**
 * @param {Element|Root} node
 * @returns {Element?}
 */
function getInputElement(node) {
  let index = -1

  while (++index < node.children.length) {
    const child = node.children[index]

    if (child.type === 'element' && child.tagName === 'input') {
      return child
    }
  }

  return null
}

/**
 * @param {Element|Root} parent
 * @param {Element} [node]
 * @returns {number}
 */
function getElementsBeforeCount(parent, node) {
  let index = -1
  let count = 0

  while (++index < parent.children.length) {
    if (parent.children[index] === node) break
    if (parent.children[index].type === 'element') count++
  }

  return count
}

/**
 * @param {Object.<string, unknown>} props
 * @param {string} prop
 * @param {unknown} value
 * @param {Context} ctx
 */
function addProperty(props, prop, value, ctx) {
  /** @type {Info} */
  const info = find(ctx.schema, prop)
  let result = value

  // Ignore nullish and `NaN` values.
  // eslint-disable-next-line no-self-compare
  if (result === null || result === undefined || result !== result) {
    return
  }

  // Accept `array`.
  // Most props are space-separated.
  if (result && typeof result === 'object' && 'length' in result) {
    // type-coverage:ignore-next-line remove when typed.
    result = (info.commaSeparated ? commas : spaces).stringify(result)
  }

  if (info.property === 'style' && typeof result === 'string') {
    result = parseStyle(result)
  }

  /* istanbul ignore else - types say they’re optional. */
  if (info.space && info.property) {
    props[
      own.call(hastToReact, info.property)
        ? hastToReact[info.property]
        : info.property
    ] = result
  } else if (info.attribute) {
    props[info.attribute] = result
  }
}

/**
 * @param {string} value
 * @returns {Object.<string, string>}
 */
function parseStyle(value) {
  /** @type {Object.<string, string>} */
  const result = {}

  try {
    style(value, iterator)
  } catch (/** @type {unknown} */ _) {
    // Silent.
  }

  return result

  /**
   * @param {string} name
   * @param {string} v
   */
  function iterator(name, v) {
    const k = name.slice(0, 4) === '-ms-' ? `ms-${name.slice(4)}` : name
    result[k.replace(/-([a-z])/g, styleReplacer)] = v
  }
}

/**
 * @param {unknown} _
 * @param {string} $1
 */
function styleReplacer(_, $1) {
  return $1.toUpperCase()
}

/**
 * @param {Position|{start: {line: null, column: null, offset: null}, end: {line: null, column: null, offset: null}}} pos
 * @returns {string}
 */
function flattenPosition(pos) {
  return [
    pos.start.line,
    ':',
    pos.start.column,
    '-',
    pos.end.line,
    ':',
    pos.end.column
  ]
    .map((d) => String(d))
    .join('')
}


/***/ }),

/***/ "../../node_modules/react-markdown/src/react-markdown.js":
/*!***************************************************************!*\
  !*** ../../node_modules/react-markdown/src/react-markdown.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const React = __webpack_require__(/*! react */ "react")
const vfile = __webpack_require__(/*! vfile */ "../../node_modules/vfile/index.js")
const unified = __webpack_require__(/*! unified */ "../../node_modules/unified/index.js")
const parse = __webpack_require__(/*! remark-parse */ "../../node_modules/remark-parse/index.js")
const remarkRehype = __webpack_require__(/*! remark-rehype */ "../../node_modules/remark-rehype/index.js")
const PropTypes = __webpack_require__(/*! prop-types */ "../../node_modules/prop-types/index.js")
const html = __webpack_require__(/*! property-information/html */ "../../node_modules/property-information/html.js")
const filter = __webpack_require__(/*! ./rehype-filter.js */ "../../node_modules/react-markdown/src/rehype-filter.js")
const uriTransformer = __webpack_require__(/*! ./uri-transformer.js */ "../../node_modules/react-markdown/src/uri-transformer.js")
const childrenToReact = (__webpack_require__(/*! ./ast-to-react.js */ "../../node_modules/react-markdown/src/ast-to-react.js").hastChildrenToReact)

/**
 * @typedef {import('react').ReactNode} ReactNode
 * @typedef {import('react').ReactElement<{}>} ReactElement
 * @typedef {import('unified').PluggableList} PluggableList
 * @typedef {import('hast').Root} Root
 * @typedef {import('./rehype-filter.js').RehypeFilterOptions} FilterOptions
 * @typedef {import('./ast-to-react.js').TransformOptions} TransformOptions
 *
 * @typedef CoreOptions
 * @property {string} children
 *
 * @typedef PluginOptions
 * @property {PluggableList} [plugins=[]] **deprecated**: use `remarkPlugins` instead
 * @property {PluggableList} [remarkPlugins=[]]
 * @property {PluggableList} [rehypePlugins=[]]
 *
 * @typedef LayoutOptions
 * @property {string} [className]
 *
 * @typedef {CoreOptions & PluginOptions & LayoutOptions & FilterOptions & TransformOptions} ReactMarkdownOptions
 */

module.exports = ReactMarkdown

const own = {}.hasOwnProperty
const changelog =
  'https://github.com/remarkjs/react-markdown/blob/main/changelog.md'

/**
 * @typedef Deprecation
 * @property {string} id
 * @property {string} [to]
 */

/**
 * @type {Object.<string, Deprecation>}
 */
const deprecated = {
  renderers: {to: 'components', id: 'change-renderers-to-components'},
  astPlugins: {id: 'remove-buggy-html-in-markdown-parser'},
  allowDangerousHtml: {id: 'remove-buggy-html-in-markdown-parser'},
  escapeHtml: {id: 'remove-buggy-html-in-markdown-parser'},
  source: {to: 'children', id: 'change-source-to-children'},
  allowNode: {
    to: 'allowElement',
    id: 'replace-allownode-allowedtypes-and-disallowedtypes'
  },
  allowedTypes: {
    to: 'allowedElements',
    id: 'replace-allownode-allowedtypes-and-disallowedtypes'
  },
  disallowedTypes: {
    to: 'disallowedElements',
    id: 'replace-allownode-allowedtypes-and-disallowedtypes'
  },
  includeNodeIndex: {
    to: 'includeElementIndex',
    id: 'change-includenodeindex-to-includeelementindex'
  }
}

/**
 * @param {ReactMarkdownOptions} options
 * @returns {ReactElement}
 */
function ReactMarkdown(options) {
  for (const key in deprecated) {
    if (own.call(deprecated, key) && own.call(options, key)) {
      /** @type {Deprecation} */
      const deprecation = deprecated[key]
      console.warn(
        `[react-markdown] Warning: please ${
          deprecation.to ? `use \`${deprecation.to}\` instead of` : 'remove'
        } \`${key}\` (see <${changelog}#${deprecation.id}> for more info)`
      )
      delete deprecated[key]
    }
  }

  const processor = unified()
    .use(parse)
    // TODO: deprecate `plugins` in v7.0.0.
    .use(options.remarkPlugins || options.plugins || [])
    .use(remarkRehype, {allowDangerousHtml: true})
    .use(options.rehypePlugins || [])
    .use(filter, options)

  /** @type {vfile} */
  let file

  if (typeof options.children === 'string') {
    file = vfile(options.children)
  } else {
    if (options.children !== undefined && options.children !== null) {
      console.warn(
        `[react-markdown] Warning: please pass a string as \`children\` (not: \`${options.children}\`)`
      )
    }

    file = vfile()
  }

  /** @type {Root} */
  // @ts-expect-error we’ll throw if it isn’t a root next.
  const hastNode = processor.runSync(processor.parse(file), file)

  if (hastNode.type !== 'root') {
    throw new TypeError('Expected a `root` node')
  }

  /** @type {ReactElement} */
  let result = React.createElement(
    React.Fragment,
    {},
    childrenToReact({options: options, schema: html, listDepth: 0}, hastNode)
  )

  if (options.className) {
    result = React.createElement('div', {className: options.className}, result)
  }

  return result
}

ReactMarkdown.defaultProps = {transformLinkUri: uriTransformer}

ReactMarkdown.propTypes = {
  // Core options:
  children: PropTypes.string,
  // Layout options:
  className: PropTypes.string,
  // Filter options:
  allowElement: PropTypes.func,
  allowedElements: PropTypes.arrayOf(PropTypes.string),
  disallowedElements: PropTypes.arrayOf(PropTypes.string),
  unwrapDisallowed: PropTypes.bool,
  // Plugin options:
  // type-coverage:ignore-next-line
  remarkPlugins: PropTypes.arrayOf(
    PropTypes.oneOfType([
      PropTypes.object,
      PropTypes.func,
      PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.object, PropTypes.func]))
    ])
  ),
  // type-coverage:ignore-next-line
  rehypePlugins: PropTypes.arrayOf(
    PropTypes.oneOfType([
      PropTypes.object,
      PropTypes.func,
      PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.object, PropTypes.func]))
    ])
  ),
  // Transform options:
  sourcePos: PropTypes.bool,
  rawSourcePos: PropTypes.bool,
  skipHtml: PropTypes.bool,
  includeElementIndex: PropTypes.bool,
  transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  transformImageUri: PropTypes.func,
  components: PropTypes.object
}

ReactMarkdown.uriTransformer = uriTransformer


/***/ }),

/***/ "../../node_modules/react-markdown/src/rehype-filter.js":
/*!**************************************************************!*\
  !*** ../../node_modules/react-markdown/src/rehype-filter.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const visit = __webpack_require__(/*! unist-util-visit */ "../../node_modules/unist-util-visit/index.js")

module.exports = rehypeFilter

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Element} Element
 *
 * @callback AllowElement
 * @param {Element} element
 * @param {number} index
 * @param {Element|Root} parent
 * @returns {boolean|undefined}
 *
 * @typedef RehypeFilterOptions
 * @property {Array.<string>} [allowedElements]
 * @property {Array.<string>} [disallowedElements=[]]
 * @property {AllowElement} [allowElement]
 * @property {boolean} [unwrapDisallowed=false]
 */

/**
 * @type {import('unified').Plugin<[RehypeFilterOptions]>}
 */
function rehypeFilter(options) {
  if (options.allowedElements && options.disallowedElements) {
    throw new TypeError(
      'Only one of `allowedElements` and `disallowedElements` should be defined'
    )
  }

  if (
    options.allowedElements ||
    options.disallowedElements ||
    options.allowElement
  ) {
    return (tree) => {
      const node = /** @type {Root} */ (tree)
      visit(node, 'element', onelement)
    }
  }

  /**
   * @param {Node} node_
   * @param {number|null|undefined} index
   * @param {Node|null|undefined} parent_
   * @returns {number|void}
   */
  function onelement(node_, index, parent_) {
    const node = /** @type {Element} */ (node_)
    const parent = /** @type {Element|Root} */ (parent_)
    /** @type {boolean|undefined} */
    let remove

    if (options.allowedElements) {
      remove = !options.allowedElements.includes(node.tagName)
    } else if (options.disallowedElements) {
      remove = options.disallowedElements.includes(node.tagName)
    }

    if (!remove && options.allowElement && typeof index === 'number') {
      remove = !options.allowElement(node, index, parent)
    }

    if (remove && typeof index === 'number') {
      if (options.unwrapDisallowed && node.children) {
        parent.children.splice(index, 1, ...node.children)
      } else {
        parent.children.splice(index, 1)
      }

      return index
    }

    return undefined
  }
}


/***/ }),

/***/ "../../node_modules/react-markdown/src/uri-transformer.js":
/*!****************************************************************!*\
  !*** ../../node_modules/react-markdown/src/uri-transformer.js ***!
  \****************************************************************/
/***/ ((module) => {

const protocols = ['http', 'https', 'mailto', 'tel']

module.exports = uriTransformer

/**
 * @param {string} uri
 * @returns {string}
 */
function uriTransformer(uri) {
  const url = (uri || '').trim()
  const first = url.charAt(0)

  if (first === '#' || first === '/') {
    return url
  }

  const colon = url.indexOf(':')
  if (colon === -1) {
    return url
  }

  let index = -1

  while (++index < protocols.length) {
    const protocol = protocols[index]

    if (
      colon === protocol.length &&
      url.slice(0, protocol.length).toLowerCase() === protocol
    ) {
      return url
    }
  }

  index = url.indexOf('?')
  if (index !== -1 && colon > index) {
    return url
  }

  index = url.indexOf('#')
  if (index !== -1 && colon > index) {
    return url
  }

  // eslint-disable-next-line no-script-url
  return 'javascript:void(0)'
}


/***/ }),

/***/ "../../node_modules/remark-parse/index.js":
/*!************************************************!*\
  !*** ../../node_modules/remark-parse/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = parse

var fromMarkdown = __webpack_require__(/*! mdast-util-from-markdown */ "../../node_modules/mdast-util-from-markdown/index.js")

function parse(options) {
  var self = this

  this.Parser = parse

  function parse(doc) {
    return fromMarkdown(
      doc,
      Object.assign({}, self.data('settings'), options, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: self.data('micromarkExtensions') || [],
        mdastExtensions: self.data('fromMarkdownExtensions') || []
      })
    )
  }
}


/***/ }),

/***/ "../../node_modules/remark-rehype/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/remark-rehype/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var mdast2hast = __webpack_require__(/*! mdast-util-to-hast */ "../../node_modules/mdast-util-to-hast/index.js")

module.exports = remark2rehype

// Attacher.
// If a destination is given, runs the destination with the new hast tree
// (bridge mode).
// Without destination, returns the tree: further plugins run on that tree
// (mutate mode).
function remark2rehype(destination, options) {
  if (destination && !destination.process) {
    options = destination
    destination = null
  }

  return destination ? bridge(destination, options) : mutate(options)
}

// Bridge mode.
// Runs the destination with the new hast tree.
function bridge(destination, options) {
  return transformer

  function transformer(node, file, next) {
    destination.run(mdast2hast(node, options), file, done)

    function done(error) {
      next(error)
    }
  }
}

// Mutate-mode.
// Further transformers run on the hast tree.
function mutate(options) {
  return transformer

  function transformer(node) {
    return mdast2hast(node, options)
  }
}


/***/ }),

/***/ "../../node_modules/space-separated-tokens/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/space-separated-tokens/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.parse = parse
exports.stringify = stringify

var empty = ''
var space = ' '
var whiteSpace = /[ \t\n\r\f]+/g

function parse(value) {
  var input = String(value || empty).trim()
  return input === empty ? [] : input.split(whiteSpace)
}

function stringify(values) {
  return values.join(space).trim()
}


/***/ }),

/***/ "../../node_modules/style-to-object/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/style-to-object/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parse = __webpack_require__(/*! inline-style-parser */ "../../node_modules/inline-style-parser/index.js");

/**
 * Parses inline style to object.
 *
 * @example
 * // returns { 'line-height': '42' }
 * StyleToObject('line-height: 42;');
 *
 * @param  {String}      style      - The inline style.
 * @param  {Function}    [iterator] - The iterator function.
 * @return {null|Object}
 */
function StyleToObject(style, iterator) {
  var output = null;
  if (!style || typeof style !== 'string') {
    return output;
  }

  var declaration;
  var declarations = parse(style);
  var hasIterator = typeof iterator === 'function';
  var property;
  var value;

  for (var i = 0, len = declarations.length; i < len; i++) {
    declaration = declarations[i];
    property = declaration.property;
    value = declaration.value;

    if (hasIterator) {
      iterator(property, value, declaration);
    } else if (value) {
      output || (output = {});
      output[property] = value;
    }
  }

  return output;
}

module.exports = StyleToObject;


/***/ }),

/***/ "../../node_modules/trough/index.js":
/*!******************************************!*\
  !*** ../../node_modules/trough/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var wrap = __webpack_require__(/*! ./wrap.js */ "../../node_modules/trough/wrap.js")

module.exports = trough

trough.wrap = wrap

var slice = [].slice

// Create new middleware.
function trough() {
  var fns = []
  var middleware = {}

  middleware.run = run
  middleware.use = use

  return middleware

  // Run `fns`.  Last argument must be a completion handler.
  function run() {
    var index = -1
    var input = slice.call(arguments, 0, -1)
    var done = arguments[arguments.length - 1]

    if (typeof done !== 'function') {
      throw new Error('Expected function as last argument, not ' + done)
    }

    next.apply(null, [null].concat(input))

    // Run the next `fn`, if any.
    function next(err) {
      var fn = fns[++index]
      var params = slice.call(arguments, 0)
      var values = params.slice(1)
      var length = input.length
      var pos = -1

      if (err) {
        done(err)
        return
      }

      // Copy non-nully input into values.
      while (++pos < length) {
        if (values[pos] === null || values[pos] === undefined) {
          values[pos] = input[pos]
        }
      }

      input = values

      // Next or done.
      if (fn) {
        wrap(fn, next).apply(null, input)
      } else {
        done.apply(null, [null].concat(input))
      }
    }
  }

  // Add `fn` to the list.
  function use(fn) {
    if (typeof fn !== 'function') {
      throw new Error('Expected `fn` to be a function, not ' + fn)
    }

    fns.push(fn)

    return middleware
  }
}


/***/ }),

/***/ "../../node_modules/trough/wrap.js":
/*!*****************************************!*\
  !*** ../../node_modules/trough/wrap.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


var slice = [].slice

module.exports = wrap

// Wrap `fn`.
// Can be sync or async; return a promise, receive a completion handler, return
// new values and errors.
function wrap(fn, callback) {
  var invoked

  return wrapped

  function wrapped() {
    var params = slice.call(arguments, 0)
    var callback = fn.length > params.length
    var result

    if (callback) {
      params.push(done)
    }

    try {
      result = fn.apply(null, params)
    } catch (error) {
      // Well, this is quite the pickle.
      // `fn` received a callback and invoked it (thus continuing the pipeline),
      // but later also threw an error.
      // We’re not about to restart the pipeline again, so the only thing left
      // to do is to throw the thing instead.
      if (callback && invoked) {
        throw error
      }

      return done(error)
    }

    if (!callback) {
      if (result && typeof result.then === 'function') {
        result.then(then, done)
      } else if (result instanceof Error) {
        done(result)
      } else {
        then(result)
      }
    }
  }

  // Invoke `next`, only once.
  function done() {
    if (!invoked) {
      invoked = true

      callback.apply(null, arguments)
    }
  }

  // Invoke `done` with one value.
  // Tracks if an error is passed, too.
  function then(value) {
    done(null, value)
  }
}


/***/ }),

/***/ "../../node_modules/unified/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/unified/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bail = __webpack_require__(/*! bail */ "../../node_modules/bail/index.js")
var buffer = __webpack_require__(/*! is-buffer */ "../../node_modules/unified/node_modules/is-buffer/index.js")
var extend = __webpack_require__(/*! extend */ "../../node_modules/extend/index.js")
var plain = __webpack_require__(/*! is-plain-obj */ "../../node_modules/is-plain-obj/index.js")
var trough = __webpack_require__(/*! trough */ "../../node_modules/trough/index.js")
var vfile = __webpack_require__(/*! vfile */ "../../node_modules/vfile/index.js")

// Expose a frozen processor.
module.exports = unified().freeze()

var slice = [].slice
var own = {}.hasOwnProperty

// Process pipeline.
var pipeline = trough()
  .use(pipelineParse)
  .use(pipelineRun)
  .use(pipelineStringify)

function pipelineParse(p, ctx) {
  ctx.tree = p.parse(ctx.file)
}

function pipelineRun(p, ctx, next) {
  p.run(ctx.tree, ctx.file, done)

  function done(error, tree, file) {
    if (error) {
      next(error)
    } else {
      ctx.tree = tree
      ctx.file = file
      next()
    }
  }
}

function pipelineStringify(p, ctx) {
  var result = p.stringify(ctx.tree, ctx.file)

  if (result === undefined || result === null) {
    // Empty.
  } else if (typeof result === 'string' || buffer(result)) {
    if ('value' in ctx.file) {
      ctx.file.value = result
    }

    ctx.file.contents = result
  } else {
    ctx.file.result = result
  }
}

// Function to create the first processor.
function unified() {
  var attachers = []
  var transformers = trough()
  var namespace = {}
  var freezeIndex = -1
  var frozen

  // Data management.
  processor.data = data

  // Lock.
  processor.freeze = freeze

  // Plugins.
  processor.attachers = attachers
  processor.use = use

  // API.
  processor.parse = parse
  processor.stringify = stringify
  processor.run = run
  processor.runSync = runSync
  processor.process = process
  processor.processSync = processSync

  // Expose.
  return processor

  // Create a new processor based on the processor in the current scope.
  function processor() {
    var destination = unified()
    var index = -1

    while (++index < attachers.length) {
      destination.use.apply(null, attachers[index])
    }

    destination.data(extend(true, {}, namespace))

    return destination
  }

  // Freeze: used to signal a processor that has finished configuration.
  //
  // For example, take unified itself: it’s frozen.
  // Plugins should not be added to it.
  // Rather, it should be extended, by invoking it, before modifying it.
  //
  // In essence, always invoke this when exporting a processor.
  function freeze() {
    var values
    var transformer

    if (frozen) {
      return processor
    }

    while (++freezeIndex < attachers.length) {
      values = attachers[freezeIndex]

      if (values[1] === false) {
        continue
      }

      if (values[1] === true) {
        values[1] = undefined
      }

      transformer = values[0].apply(processor, values.slice(1))

      if (typeof transformer === 'function') {
        transformers.use(transformer)
      }
    }

    frozen = true
    freezeIndex = Infinity

    return processor
  }

  // Data management.
  // Getter / setter for processor-specific informtion.
  function data(key, value) {
    if (typeof key === 'string') {
      // Set `key`.
      if (arguments.length === 2) {
        assertUnfrozen('data', frozen)
        namespace[key] = value
        return processor
      }

      // Get `key`.
      return (own.call(namespace, key) && namespace[key]) || null
    }

    // Set space.
    if (key) {
      assertUnfrozen('data', frozen)
      namespace = key
      return processor
    }

    // Get space.
    return namespace
  }

  // Plugin management.
  //
  // Pass it:
  // *   an attacher and options,
  // *   a preset,
  // *   a list of presets, attachers, and arguments (list of attachers and
  //     options).
  function use(value) {
    var settings

    assertUnfrozen('use', frozen)

    if (value === null || value === undefined) {
      // Empty.
    } else if (typeof value === 'function') {
      addPlugin.apply(null, arguments)
    } else if (typeof value === 'object') {
      if ('length' in value) {
        addList(value)
      } else {
        addPreset(value)
      }
    } else {
      throw new Error('Expected usable value, not `' + value + '`')
    }

    if (settings) {
      namespace.settings = extend(namespace.settings || {}, settings)
    }

    return processor

    function addPreset(result) {
      addList(result.plugins)

      if (result.settings) {
        settings = extend(settings || {}, result.settings)
      }
    }

    function add(value) {
      if (typeof value === 'function') {
        addPlugin(value)
      } else if (typeof value === 'object') {
        if ('length' in value) {
          addPlugin.apply(null, value)
        } else {
          addPreset(value)
        }
      } else {
        throw new Error('Expected usable value, not `' + value + '`')
      }
    }

    function addList(plugins) {
      var index = -1

      if (plugins === null || plugins === undefined) {
        // Empty.
      } else if (typeof plugins === 'object' && 'length' in plugins) {
        while (++index < plugins.length) {
          add(plugins[index])
        }
      } else {
        throw new Error('Expected a list of plugins, not `' + plugins + '`')
      }
    }

    function addPlugin(plugin, value) {
      var entry = find(plugin)

      if (entry) {
        if (plain(entry[1]) && plain(value)) {
          value = extend(true, entry[1], value)
        }

        entry[1] = value
      } else {
        attachers.push(slice.call(arguments))
      }
    }
  }

  function find(plugin) {
    var index = -1

    while (++index < attachers.length) {
      if (attachers[index][0] === plugin) {
        return attachers[index]
      }
    }
  }

  // Parse a file (in string or vfile representation) into a unist node using
  // the `Parser` on the processor.
  function parse(doc) {
    var file = vfile(doc)
    var Parser

    freeze()
    Parser = processor.Parser
    assertParser('parse', Parser)

    if (newable(Parser, 'parse')) {
      return new Parser(String(file), file).parse()
    }

    return Parser(String(file), file) // eslint-disable-line new-cap
  }

  // Run transforms on a unist node representation of a file (in string or
  // vfile representation), async.
  function run(node, file, cb) {
    assertNode(node)
    freeze()

    if (!cb && typeof file === 'function') {
      cb = file
      file = null
    }

    if (!cb) {
      return new Promise(executor)
    }

    executor(null, cb)

    function executor(resolve, reject) {
      transformers.run(node, vfile(file), done)

      function done(error, tree, file) {
        tree = tree || node
        if (error) {
          reject(error)
        } else if (resolve) {
          resolve(tree)
        } else {
          cb(null, tree, file)
        }
      }
    }
  }

  // Run transforms on a unist node representation of a file (in string or
  // vfile representation), sync.
  function runSync(node, file) {
    var result
    var complete

    run(node, file, done)

    assertDone('runSync', 'run', complete)

    return result

    function done(error, tree) {
      complete = true
      result = tree
      bail(error)
    }
  }

  // Stringify a unist node representation of a file (in string or vfile
  // representation) into a string using the `Compiler` on the processor.
  function stringify(node, doc) {
    var file = vfile(doc)
    var Compiler

    freeze()
    Compiler = processor.Compiler
    assertCompiler('stringify', Compiler)
    assertNode(node)

    if (newable(Compiler, 'compile')) {
      return new Compiler(node, file).compile()
    }

    return Compiler(node, file) // eslint-disable-line new-cap
  }

  // Parse a file (in string or vfile representation) into a unist node using
  // the `Parser` on the processor, then run transforms on that node, and
  // compile the resulting node using the `Compiler` on the processor, and
  // store that result on the vfile.
  function process(doc, cb) {
    freeze()
    assertParser('process', processor.Parser)
    assertCompiler('process', processor.Compiler)

    if (!cb) {
      return new Promise(executor)
    }

    executor(null, cb)

    function executor(resolve, reject) {
      var file = vfile(doc)

      pipeline.run(processor, {file: file}, done)

      function done(error) {
        if (error) {
          reject(error)
        } else if (resolve) {
          resolve(file)
        } else {
          cb(null, file)
        }
      }
    }
  }

  // Process the given document (in string or vfile representation), sync.
  function processSync(doc) {
    var file
    var complete

    freeze()
    assertParser('processSync', processor.Parser)
    assertCompiler('processSync', processor.Compiler)
    file = vfile(doc)

    process(file, done)

    assertDone('processSync', 'process', complete)

    return file

    function done(error) {
      complete = true
      bail(error)
    }
  }
}

// Check if `value` is a constructor.
function newable(value, name) {
  return (
    typeof value === 'function' &&
    value.prototype &&
    // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    (keys(value.prototype) || name in value.prototype)
  )
}

// Check if `value` is an object with keys.
function keys(value) {
  var key
  for (key in value) {
    return true
  }

  return false
}

// Assert a parser is available.
function assertParser(name, Parser) {
  if (typeof Parser !== 'function') {
    throw new Error('Cannot `' + name + '` without `Parser`')
  }
}

// Assert a compiler is available.
function assertCompiler(name, Compiler) {
  if (typeof Compiler !== 'function') {
    throw new Error('Cannot `' + name + '` without `Compiler`')
  }
}

// Assert the processor is not frozen.
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      'Cannot invoke `' +
        name +
        '` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.'
    )
  }
}

// Assert `node` is a unist node.
function assertNode(node) {
  if (!node || typeof node.type !== 'string') {
    throw new Error('Expected node, got `' + node + '`')
  }
}

// Assert that `complete` is `true`.
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      '`' + name + '` finished async. Use `' + asyncName + '` instead'
    )
  }
}


/***/ }),

/***/ "../../node_modules/unified/node_modules/is-buffer/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/unified/node_modules/is-buffer/index.js ***!
  \******************************************************************/
/***/ ((module) => {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}


/***/ }),

/***/ "../../node_modules/unist-builder/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/unist-builder/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


module.exports = u

function u(type, props, value) {
  var node

  if (
    (value === null || value === undefined) &&
    (typeof props !== 'object' || Array.isArray(props))
  ) {
    value = props
    props = {}
  }

  node = Object.assign({type: String(type)}, props)

  if (Array.isArray(value)) {
    node.children = value
  } else if (value !== null && value !== undefined) {
    node.value = String(value)
  }

  return node
}


/***/ }),

/***/ "../../node_modules/unist-util-generated/index.js":
/*!********************************************************!*\
  !*** ../../node_modules/unist-util-generated/index.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


module.exports = generated

function generated(node) {
  return (
    !node ||
    !node.position ||
    !node.position.start ||
    !node.position.start.line ||
    !node.position.start.column ||
    !node.position.end ||
    !node.position.end.line ||
    !node.position.end.column
  )
}


/***/ }),

/***/ "../../node_modules/unist-util-is/convert.js":
/*!***************************************************!*\
  !*** ../../node_modules/unist-util-is/convert.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = convert

function convert(test) {
  if (test == null) {
    return ok
  }

  if (typeof test === 'string') {
    return typeFactory(test)
  }

  if (typeof test === 'object') {
    return 'length' in test ? anyFactory(test) : allFactory(test)
  }

  if (typeof test === 'function') {
    return test
  }

  throw new Error('Expected function, string, or object as test')
}

// Utility assert each property in `test` is represented in `node`, and each
// values are strictly equal.
function allFactory(test) {
  return all

  function all(node) {
    var key

    for (key in test) {
      if (node[key] !== test[key]) return false
    }

    return true
  }
}

function anyFactory(tests) {
  var checks = []
  var index = -1

  while (++index < tests.length) {
    checks[index] = convert(tests[index])
  }

  return any

  function any() {
    var index = -1

    while (++index < checks.length) {
      if (checks[index].apply(this, arguments)) {
        return true
      }
    }

    return false
  }
}

// Utility to convert a string into a function which checks a given node’s type
// for said string.
function typeFactory(test) {
  return type

  function type(node) {
    return Boolean(node && node.type === test)
  }
}

// Utility to return true.
function ok() {
  return true
}


/***/ }),

/***/ "../../node_modules/unist-util-position/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/unist-util-position/index.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


var start = factory('start')
var end = factory('end')

module.exports = position

position.start = start
position.end = end

function position(node) {
  return {start: start(node), end: end(node)}
}

function factory(type) {
  point.displayName = type

  return point

  function point(node) {
    var point = (node && node.position && node.position[type]) || {}

    return {
      line: point.line || null,
      column: point.column || null,
      offset: isNaN(point.offset) ? null : point.offset
    }
  }
}


/***/ }),

/***/ "../../node_modules/unist-util-stringify-position/index.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/unist-util-stringify-position/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";


var own = {}.hasOwnProperty

module.exports = stringify

function stringify(value) {
  // Nothing.
  if (!value || typeof value !== 'object') {
    return ''
  }

  // Node.
  if (own.call(value, 'position') || own.call(value, 'type')) {
    return position(value.position)
  }

  // Position.
  if (own.call(value, 'start') || own.call(value, 'end')) {
    return position(value)
  }

  // Point.
  if (own.call(value, 'line') || own.call(value, 'column')) {
    return point(value)
  }

  // ?
  return ''
}

function point(point) {
  if (!point || typeof point !== 'object') {
    point = {}
  }

  return index(point.line) + ':' + index(point.column)
}

function position(pos) {
  if (!pos || typeof pos !== 'object') {
    pos = {}
  }

  return point(pos.start) + '-' + point(pos.end)
}

function index(value) {
  return value && typeof value === 'number' ? value : 1
}


/***/ }),

/***/ "../../node_modules/unist-util-visit-parents/color.browser.js":
/*!********************************************************************!*\
  !*** ../../node_modules/unist-util-visit-parents/color.browser.js ***!
  \********************************************************************/
/***/ ((module) => {

module.exports = identity
function identity(d) {
  return d
}


/***/ }),

/***/ "../../node_modules/unist-util-visit-parents/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/unist-util-visit-parents/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = visitParents

var convert = __webpack_require__(/*! unist-util-is/convert */ "../../node_modules/unist-util-is/convert.js")
var color = __webpack_require__(/*! ./color */ "../../node_modules/unist-util-visit-parents/color.browser.js")

var CONTINUE = true
var SKIP = 'skip'
var EXIT = false

visitParents.CONTINUE = CONTINUE
visitParents.SKIP = SKIP
visitParents.EXIT = EXIT

function visitParents(tree, test, visitor, reverse) {
  var step
  var is

  if (typeof test === 'function' && typeof visitor !== 'function') {
    reverse = visitor
    visitor = test
    test = null
  }

  is = convert(test)
  step = reverse ? -1 : 1

  factory(tree, null, [])()

  function factory(node, index, parents) {
    var value = typeof node === 'object' && node !== null ? node : {}
    var name

    if (typeof value.type === 'string') {
      name =
        typeof value.tagName === 'string'
          ? value.tagName
          : typeof value.name === 'string'
          ? value.name
          : undefined

      visit.displayName =
        'node (' + color(value.type + (name ? '<' + name + '>' : '')) + ')'
    }

    return visit

    function visit() {
      var grandparents = parents.concat(node)
      var result = []
      var subresult
      var offset

      if (!test || is(node, index, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node, parents))

        if (result[0] === EXIT) {
          return result
        }
      }

      if (node.children && result[0] !== SKIP) {
        offset = (reverse ? node.children.length : -1) + step

        while (offset > -1 && offset < node.children.length) {
          subresult = factory(node.children[offset], offset, grandparents)()

          if (subresult[0] === EXIT) {
            return subresult
          }

          offset =
            typeof subresult[1] === 'number' ? subresult[1] : offset + step
        }
      }

      return result
    }
  }
}

function toResult(value) {
  if (value !== null && typeof value === 'object' && 'length' in value) {
    return value
  }

  if (typeof value === 'number') {
    return [CONTINUE, value]
  }

  return [value]
}


/***/ }),

/***/ "../../node_modules/unist-util-visit/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/unist-util-visit/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = visit

var visitParents = __webpack_require__(/*! unist-util-visit-parents */ "../../node_modules/unist-util-visit-parents/index.js")

var CONTINUE = visitParents.CONTINUE
var SKIP = visitParents.SKIP
var EXIT = visitParents.EXIT

visit.CONTINUE = CONTINUE
visit.SKIP = SKIP
visit.EXIT = EXIT

function visit(tree, test, visitor, reverse) {
  if (typeof test === 'function' && typeof visitor !== 'function') {
    reverse = visitor
    visitor = test
    test = null
  }

  visitParents(tree, test, overload, reverse)

  function overload(node, parents) {
    var parent = parents[parents.length - 1]
    var index = parent ? parent.children.indexOf(node) : null
    return visitor(node, index, parent)
  }
}


/***/ }),

/***/ "../../node_modules/vfile-message/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/vfile-message/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(/*! unist-util-stringify-position */ "../../node_modules/unist-util-stringify-position/index.js")

module.exports = VMessage

// Inherit from `Error#`.
function VMessagePrototype() {}
VMessagePrototype.prototype = Error.prototype
VMessage.prototype = new VMessagePrototype()

// Message properties.
var proto = VMessage.prototype

proto.file = ''
proto.name = ''
proto.reason = ''
proto.message = ''
proto.stack = ''
proto.fatal = null
proto.column = null
proto.line = null

// Construct a new VMessage.
//
// Note: We cannot invoke `Error` on the created context, as that adds readonly
// `line` and `column` attributes on Safari 9, thus throwing and failing the
// data.
function VMessage(reason, position, origin) {
  var parts
  var range
  var location

  if (typeof position === 'string') {
    origin = position
    position = null
  }

  parts = parseOrigin(origin)
  range = stringify(position) || '1:1'

  location = {
    start: {line: null, column: null},
    end: {line: null, column: null}
  }

  // Node.
  if (position && position.position) {
    position = position.position
  }

  if (position) {
    // Position.
    if (position.start) {
      location = position
      position = position.start
    } else {
      // Point.
      location.start = position
    }
  }

  if (reason.stack) {
    this.stack = reason.stack
    reason = reason.message
  }

  this.message = reason
  this.name = range
  this.reason = reason
  this.line = position ? position.line : null
  this.column = position ? position.column : null
  this.location = location
  this.source = parts[0]
  this.ruleId = parts[1]
}

function parseOrigin(origin) {
  var result = [null, null]
  var index

  if (typeof origin === 'string') {
    index = origin.indexOf(':')

    if (index === -1) {
      result[1] = origin
    } else {
      result[0] = origin.slice(0, index)
      result[1] = origin.slice(index + 1)
    }
  }

  return result
}


/***/ }),

/***/ "../../node_modules/vfile/index.js":
/*!*****************************************!*\
  !*** ../../node_modules/vfile/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! ./lib */ "../../node_modules/vfile/lib/index.js")


/***/ }),

/***/ "../../node_modules/vfile/lib/core.js":
/*!********************************************!*\
  !*** ../../node_modules/vfile/lib/core.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var p = __webpack_require__(/*! ./minpath */ "../../node_modules/vfile/lib/minpath.browser.js")
var proc = __webpack_require__(/*! ./minproc */ "../../node_modules/vfile/lib/minproc.browser.js")
var buffer = __webpack_require__(/*! is-buffer */ "../../node_modules/vfile/node_modules/is-buffer/index.js")

module.exports = VFile

var own = {}.hasOwnProperty

// Order of setting (least specific to most), we need this because otherwise
// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
// stem can be set.
var order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']

VFile.prototype.toString = toString

// Access full path (`~/index.min.js`).
Object.defineProperty(VFile.prototype, 'path', {get: getPath, set: setPath})

// Access parent path (`~`).
Object.defineProperty(VFile.prototype, 'dirname', {
  get: getDirname,
  set: setDirname
})

// Access basename (`index.min.js`).
Object.defineProperty(VFile.prototype, 'basename', {
  get: getBasename,
  set: setBasename
})

// Access extname (`.js`).
Object.defineProperty(VFile.prototype, 'extname', {
  get: getExtname,
  set: setExtname
})

// Access stem (`index.min`).
Object.defineProperty(VFile.prototype, 'stem', {get: getStem, set: setStem})

// Construct a new file.
function VFile(options) {
  var prop
  var index

  if (!options) {
    options = {}
  } else if (typeof options === 'string' || buffer(options)) {
    options = {contents: options}
  } else if ('message' in options && 'messages' in options) {
    return options
  }

  if (!(this instanceof VFile)) {
    return new VFile(options)
  }

  this.data = {}
  this.messages = []
  this.history = []
  this.cwd = proc.cwd()

  // Set path related properties in the correct order.
  index = -1

  while (++index < order.length) {
    prop = order[index]

    if (own.call(options, prop)) {
      this[prop] = options[prop]
    }
  }

  // Set non-path related properties.
  for (prop in options) {
    if (order.indexOf(prop) < 0) {
      this[prop] = options[prop]
    }
  }
}

function getPath() {
  return this.history[this.history.length - 1]
}

function setPath(path) {
  assertNonEmpty(path, 'path')

  if (this.path !== path) {
    this.history.push(path)
  }
}

function getDirname() {
  return typeof this.path === 'string' ? p.dirname(this.path) : undefined
}

function setDirname(dirname) {
  assertPath(this.path, 'dirname')
  this.path = p.join(dirname || '', this.basename)
}

function getBasename() {
  return typeof this.path === 'string' ? p.basename(this.path) : undefined
}

function setBasename(basename) {
  assertNonEmpty(basename, 'basename')
  assertPart(basename, 'basename')
  this.path = p.join(this.dirname || '', basename)
}

function getExtname() {
  return typeof this.path === 'string' ? p.extname(this.path) : undefined
}

function setExtname(extname) {
  assertPart(extname, 'extname')
  assertPath(this.path, 'extname')

  if (extname) {
    if (extname.charCodeAt(0) !== 46 /* `.` */) {
      throw new Error('`extname` must start with `.`')
    }

    if (extname.indexOf('.', 1) > -1) {
      throw new Error('`extname` cannot contain multiple dots')
    }
  }

  this.path = p.join(this.dirname, this.stem + (extname || ''))
}

function getStem() {
  return typeof this.path === 'string'
    ? p.basename(this.path, this.extname)
    : undefined
}

function setStem(stem) {
  assertNonEmpty(stem, 'stem')
  assertPart(stem, 'stem')
  this.path = p.join(this.dirname || '', stem + (this.extname || ''))
}

// Get the value of the file.
function toString(encoding) {
  return (this.contents || '').toString(encoding)
}

// Assert that `part` is not a path (i.e., does not contain `p.sep`).
function assertPart(part, name) {
  if (part && part.indexOf(p.sep) > -1) {
    throw new Error(
      '`' + name + '` cannot be a path: did not expect `' + p.sep + '`'
    )
  }
}

// Assert that `part` is not empty.
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error('`' + name + '` cannot be empty')
  }
}

// Assert `path` exists.
function assertPath(path, name) {
  if (!path) {
    throw new Error('Setting `' + name + '` requires `path` to be set too')
  }
}


/***/ }),

/***/ "../../node_modules/vfile/lib/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/vfile/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var VMessage = __webpack_require__(/*! vfile-message */ "../../node_modules/vfile-message/index.js")
var VFile = __webpack_require__(/*! ./core.js */ "../../node_modules/vfile/lib/core.js")

module.exports = VFile

VFile.prototype.message = message
VFile.prototype.info = info
VFile.prototype.fail = fail

// Create a message with `reason` at `position`.
// When an error is passed in as `reason`, copies the stack.
function message(reason, position, origin) {
  var message = new VMessage(reason, position, origin)

  if (this.path) {
    message.name = this.path + ':' + message.name
    message.file = this.path
  }

  message.fatal = false

  this.messages.push(message)

  return message
}

// Fail: creates a vmessage, associates it with the file, and throws it.
function fail() {
  var message = this.message.apply(this, arguments)

  message.fatal = true

  throw message
}

// Info: creates a vmessage, associates it with the file, and marks the fatality
// as null.
function info() {
  var message = this.message.apply(this, arguments)

  message.fatal = null

  return message
}


/***/ }),

/***/ "../../node_modules/vfile/lib/minpath.browser.js":
/*!*******************************************************!*\
  !*** ../../node_modules/vfile/lib/minpath.browser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// A derivative work based on:
// <https://github.com/browserify/path-browserify>.
// Which is licensed:
//
// MIT License
//
// Copyright (c) 2013 James Halliday
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// A derivative work based on:
//
// Parts of that are extracted from Node’s internal `path` module:
// <https://github.com/nodejs/node/blob/master/lib/path.js>.
// Which is licensed:
//
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

exports.basename = basename
exports.dirname = dirname
exports.extname = extname
exports.join = join
exports.sep = '/'

function basename(path, ext) {
  var start = 0
  var end = -1
  var index
  var firstNonSlashEnd
  var seenNonSlash
  var extIndex

  if (ext !== undefined && typeof ext !== 'string') {
    throw new TypeError('"ext" argument must be a string')
  }

  assertPath(path)
  index = path.length

  if (ext === undefined || !ext.length || ext.length > path.length) {
    while (index--) {
      if (path.charCodeAt(index) === 47 /* `/` */) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now.
        if (seenNonSlash) {
          start = index + 1
          break
        }
      } else if (end < 0) {
        // We saw the first non-path separator, mark this as the end of our
        // path component.
        seenNonSlash = true
        end = index + 1
      }
    }

    return end < 0 ? '' : path.slice(start, end)
  }

  if (ext === path) {
    return ''
  }

  firstNonSlashEnd = -1
  extIndex = ext.length - 1

  while (index--) {
    if (path.charCodeAt(index) === 47 /* `/` */) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now.
      if (seenNonSlash) {
        start = index + 1
        break
      }
    } else {
      if (firstNonSlashEnd < 0) {
        // We saw the first non-path separator, remember this index in case
        // we need it if the extension ends up not matching.
        seenNonSlash = true
        firstNonSlashEnd = index + 1
      }

      if (extIndex > -1) {
        // Try to match the explicit extension.
        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            // We matched the extension, so mark this as the end of our path
            // component
            end = index
          }
        } else {
          // Extension does not match, so our result is the entire path
          // component
          extIndex = -1
          end = firstNonSlashEnd
        }
      }
    }
  }

  if (start === end) {
    end = firstNonSlashEnd
  } else if (end < 0) {
    end = path.length
  }

  return path.slice(start, end)
}

function dirname(path) {
  var end
  var unmatchedSlash
  var index

  assertPath(path)

  if (!path.length) {
    return '.'
  }

  end = -1
  index = path.length

  // Prefix `--` is important to not run on `0`.
  while (--index) {
    if (path.charCodeAt(index) === 47 /* `/` */) {
      if (unmatchedSlash) {
        end = index
        break
      }
    } else if (!unmatchedSlash) {
      // We saw the first non-path separator
      unmatchedSlash = true
    }
  }

  return end < 0
    ? path.charCodeAt(0) === 47 /* `/` */
      ? '/'
      : '.'
    : end === 1 && path.charCodeAt(0) === 47 /* `/` */
    ? '//'
    : path.slice(0, end)
}

function extname(path) {
  var startDot = -1
  var startPart = 0
  var end = -1
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find.
  var preDotState = 0
  var unmatchedSlash
  var code
  var index

  assertPath(path)

  index = path.length

  while (index--) {
    code = path.charCodeAt(index)

    if (code === 47 /* `/` */) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now.
      if (unmatchedSlash) {
        startPart = index + 1
        break
      }

      continue
    }

    if (end < 0) {
      // We saw the first non-path separator, mark this as the end of our
      // extension.
      unmatchedSlash = true
      end = index + 1
    }

    if (code === 46 /* `.` */) {
      // If this is our first dot, mark it as the start of our extension.
      if (startDot < 0) {
        startDot = index
      } else if (preDotState !== 1) {
        preDotState = 1
      }
    } else if (startDot > -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension.
      preDotState = -1
    }
  }

  if (
    startDot < 0 ||
    end < 0 ||
    // We saw a non-dot character immediately before the dot.
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly `..`.
    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)
  ) {
    return ''
  }

  return path.slice(startDot, end)
}

function join() {
  var index = -1
  var joined

  while (++index < arguments.length) {
    assertPath(arguments[index])

    if (arguments[index]) {
      joined =
        joined === undefined
          ? arguments[index]
          : joined + '/' + arguments[index]
    }
  }

  return joined === undefined ? '.' : normalize(joined)
}

// Note: `normalize` is not exposed as `path.normalize`, so some code is
// manually removed from it.
function normalize(path) {
  var absolute
  var value

  assertPath(path)

  absolute = path.charCodeAt(0) === 47 /* `/` */

  // Normalize the path according to POSIX rules.
  value = normalizeString(path, !absolute)

  if (!value.length && !absolute) {
    value = '.'
  }

  if (value.length && path.charCodeAt(path.length - 1) === 47 /* / */) {
    value += '/'
  }

  return absolute ? '/' + value : value
}

// Resolve `.` and `..` elements in a path with directory names.
function normalizeString(path, allowAboveRoot) {
  var result = ''
  var lastSegmentLength = 0
  var lastSlash = -1
  var dots = 0
  var index = -1
  var code
  var lastSlashIndex

  while (++index <= path.length) {
    if (index < path.length) {
      code = path.charCodeAt(index)
    } else if (code === 47 /* `/` */) {
      break
    } else {
      code = 47 /* `/` */
    }

    if (code === 47 /* `/` */) {
      if (lastSlash === index - 1 || dots === 1) {
        // Empty.
      } else if (lastSlash !== index - 1 && dots === 2) {
        if (
          result.length < 2 ||
          lastSegmentLength !== 2 ||
          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||
          result.charCodeAt(result.length - 2) !== 46 /* `.` */
        ) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf('/')

            /* istanbul ignore else - No clue how to cover it. */
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = ''
                lastSegmentLength = 0
              } else {
                result = result.slice(0, lastSlashIndex)
                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')
              }

              lastSlash = index
              dots = 0
              continue
            }
          } else if (result.length) {
            result = ''
            lastSegmentLength = 0
            lastSlash = index
            dots = 0
            continue
          }
        }

        if (allowAboveRoot) {
          result = result.length ? result + '/..' : '..'
          lastSegmentLength = 2
        }
      } else {
        if (result.length) {
          result += '/' + path.slice(lastSlash + 1, index)
        } else {
          result = path.slice(lastSlash + 1, index)
        }

        lastSegmentLength = index - lastSlash - 1
      }

      lastSlash = index
      dots = 0
    } else if (code === 46 /* `.` */ && dots > -1) {
      dots++
    } else {
      dots = -1
    }
  }

  return result
}

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError(
      'Path must be a string. Received ' + JSON.stringify(path)
    )
  }
}


/***/ }),

/***/ "../../node_modules/vfile/lib/minproc.browser.js":
/*!*******************************************************!*\
  !*** ../../node_modules/vfile/lib/minproc.browser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Somewhat based on:
// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.
// But I don’t think one tiny line of code can be copyrighted. 😅
exports.cwd = cwd

function cwd() {
  return '/'
}


/***/ }),

/***/ "../../node_modules/vfile/node_modules/is-buffer/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/vfile/node_modules/is-buffer/index.js ***!
  \****************************************************************/
/***/ ((module) => {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}


/***/ }),

/***/ "../../node_modules/xtend/immutable.js":
/*!*********************************************!*\
  !*** ../../node_modules/xtend/immutable.js ***!
  \*********************************************/
/***/ ((module) => {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),

/***/ "./node_modules/bsdiff-node/index.js":
/*!*******************************************!*\
  !*** ./node_modules/bsdiff-node/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(/*! fs */ "fs");
const { promisify } = __webpack_require__(/*! util */ "util");
const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);

function nodeify(promise, cb) {
  if (typeof cb === "function") {
    promise.then(() => cb()).catch(cb);
    return;
  }
  return promise;
}

function diff(_srcFile, dstFile, patchFile, cb) {
  const work = (async () => {
    const data = await readFile(dstFile);
    await writeFile(patchFile, data);
  })();
  return nodeify(work, cb);
}

function patch(_srcFile, patchFile, dstFile, cb) {
  const work = (async () => {
    const data = await readFile(patchFile);
    await writeFile(dstFile, data);
  })();
  return nodeify(work, cb);
}

module.exports = { diff, patch };


/***/ }),

/***/ "./node_modules/crc-32/crc32.js":
/*!**************************************!*\
  !*** ./node_modules/crc-32/crc32.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
/* vim: set ts=2: */
/*exported CRC32 */
var CRC32;
(function (factory) {
	/*jshint ignore:start */
	/*eslint-disable */
	if(typeof DO_NOT_EXPORT_CRC === 'undefined') {
		if(true) {
			factory(exports);
		} else // removed by dead control flow
{}
	} else {
		factory(CRC32 = {});
	}
	/*eslint-enable */
	/*jshint ignore:end */
}(function(CRC32) {
CRC32.version = '1.2.2';
/*global Int32Array */
function signed_crc_table() {
	var c = 0, table = new Array(256);

	for(var n =0; n != 256; ++n){
		c = n;
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		table[n] = c;
	}

	return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
}

var T0 = signed_crc_table();
function slice_by_16_tables(T) {
	var c = 0, v = 0, n = 0, table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096) ;

	for(n = 0; n != 256; ++n) table[n] = T[n];
	for(n = 0; n != 256; ++n) {
		v = T[n];
		for(c = 256 + n; c < 4096; c += 256) v = table[c] = (v >>> 8) ^ T[v & 0xFF];
	}
	var out = [];
	for(n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
	return out;
}
var TT = slice_by_16_tables(T0);
var T1 = TT[0],  T2 = TT[1],  T3 = TT[2],  T4 = TT[3],  T5 = TT[4];
var T6 = TT[5],  T7 = TT[6],  T8 = TT[7],  T9 = TT[8],  Ta = TT[9];
var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
function crc32_bstr(bstr, seed) {
	var C = seed ^ -1;
	for(var i = 0, L = bstr.length; i < L;) C = (C>>>8) ^ T0[(C^bstr.charCodeAt(i++))&0xFF];
	return ~C;
}

function crc32_buf(B, seed) {
	var C = seed ^ -1, L = B.length - 15, i = 0;
	for(; i < L;) C =
		Tf[B[i++] ^ (C & 255)] ^
		Te[B[i++] ^ ((C >> 8) & 255)] ^
		Td[B[i++] ^ ((C >> 16) & 255)] ^
		Tc[B[i++] ^ (C >>> 24)] ^
		Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^
		T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^
		T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
	L += 15;
	while(i < L) C = (C>>>8) ^ T0[(C^B[i++])&0xFF];
	return ~C;
}

function crc32_str(str, seed) {
	var C = seed ^ -1;
	for(var i = 0, L = str.length, c = 0, d = 0; i < L;) {
		c = str.charCodeAt(i++);
		if(c < 0x80) {
			C = (C>>>8) ^ T0[(C^c)&0xFF];
		} else if(c < 0x800) {
			C = (C>>>8) ^ T0[(C ^ (192|((c>>6)&31)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];
		} else if(c >= 0xD800 && c < 0xE000) {
			c = (c&1023)+64; d = str.charCodeAt(i++)&1023;
			C = (C>>>8) ^ T0[(C ^ (240|((c>>8)&7)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|((c>>2)&63)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|((d>>6)&15)|((c&3)<<4)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|(d&63)))&0xFF];
		} else {
			C = (C>>>8) ^ T0[(C ^ (224|((c>>12)&15)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|((c>>6)&63)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];
		}
	}
	return ~C;
}
CRC32.table = T0;
// $FlowIgnore
CRC32.bstr = crc32_bstr;
// $FlowIgnore
CRC32.buf = crc32_buf;
// $FlowIgnore
CRC32.str = crc32_str;
}));


/***/ }),

/***/ "./node_modules/memoize-one/dist/memoize-one.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/memoize-one/dist/memoize-one.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ memoizeOne)
/* harmony export */ });
var safeIsNaN = Number.isNaN ||
    function ponyfill(value) {
        return typeof value === 'number' && value !== value;
    };
function isEqual(first, second) {
    if (first === second) {
        return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
        return true;
    }
    return false;
}
function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (!isEqual(newInputs[i], lastInputs[i])) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var cache = null;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {
            return cache.lastResult;
        }
        var lastResult = resultFn.apply(this, newArgs);
        cache = {
            lastResult: lastResult,
            lastArgs: newArgs,
            lastThis: this,
        };
        return lastResult;
    }
    memoized.clear = function clear() {
        cache = null;
    };
    return memoized;
}




/***/ }),

/***/ "./node_modules/nanoid/index.browser.js":
/*!**********************************************!*\
  !*** ./node_modules/nanoid/index.browser.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),
/* harmony export */   customRandom: () => (/* binding */ customRandom),
/* harmony export */   nanoid: () => (/* binding */ nanoid),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   urlAlphabet: () => (/* reexport safe */ _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__.urlAlphabet)
/* harmony export */ });
/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-alphabet/index.js */ "./node_modules/nanoid/url-alphabet/index.js");

let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * defaultSize) / alphabet.length)
  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let j = step | 0
      while (j--) {
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)
let nanoid = (size = 21) =>
  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte > 62) {
      id += '-'
    } else {
      id += '_'
    }
    return id
  }, '')



/***/ }),

/***/ "./node_modules/nanoid/url-alphabet/index.js":
/*!***************************************************!*\
  !*** ./node_modules/nanoid/url-alphabet/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   urlAlphabet: () => (/* binding */ urlAlphabet)
/* harmony export */ });
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'



/***/ }),

/***/ "./node_modules/shortid/index.js":
/*!***************************************!*\
  !*** ./node_modules/shortid/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(/*! ./lib/index */ "./node_modules/shortid/lib/index.js");


/***/ }),

/***/ "./node_modules/shortid/lib/alphabet.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/alphabet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var randomFromSeed = __webpack_require__(/*! ./random/random-from-seed */ "./node_modules/shortid/lib/random/random-from-seed.js");

var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
var alphabet;
var previousSeed;

var shuffled;

function reset() {
    shuffled = false;
}

function setCharacters(_alphabet_) {
    if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
        }
        return;
    }

    if (_alphabet_ === alphabet) {
        return;
    }

    if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
    }

    var unique = _alphabet_.split('').filter(function(item, ind, arr){
       return ind !== arr.lastIndexOf(item);
    });

    if (unique.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
    }

    alphabet = _alphabet_;
    reset();
}

function characters(_alphabet_) {
    setCharacters(_alphabet_);
    return alphabet;
}

function setSeed(seed) {
    randomFromSeed.seed(seed);
    if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
    }
}

function shuffle() {
    if (!alphabet) {
        setCharacters(ORIGINAL);
    }

    var sourceArray = alphabet.split('');
    var targetArray = [];
    var r = randomFromSeed.nextValue();
    var characterIndex;

    while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join('');
}

function getShuffled() {
    if (shuffled) {
        return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
}

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
function lookup(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
}

function get () {
  return alphabet || ORIGINAL;
}

module.exports = {
    get: get,
    characters: characters,
    seed: setSeed,
    lookup: lookup,
    shuffled: getShuffled
};


/***/ }),

/***/ "./node_modules/shortid/lib/build.js":
/*!*******************************************!*\
  !*** ./node_modules/shortid/lib/build.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var generate = __webpack_require__(/*! ./generate */ "./node_modules/shortid/lib/generate.js");
var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
var REDUCE_TIME = 1567752802062;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
var version = 7;

// Counter is used when shortid is called multiple times in one second.
var counter;

// Remember the last time shortid was called in case counter is needed.
var previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
function build(clusterWorkerId) {
    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

    if (seconds === previousSeconds) {
        counter++;
    } else {
        counter = 0;
        previousSeconds = seconds;
    }

    str = str + generate(version);
    str = str + generate(clusterWorkerId);
    if (counter > 0) {
        str = str + generate(counter);
    }
    str = str + generate(seconds);
    return str;
}

module.exports = build;


/***/ }),

/***/ "./node_modules/shortid/lib/generate.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/generate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");
var random = __webpack_require__(/*! ./random/random-byte */ "./node_modules/shortid/lib/random/random-byte-browser.js");
var customRandom = (__webpack_require__(/*! nanoid */ "./node_modules/nanoid/index.browser.js").customRandom);

function generate(number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + customRandom(alphabet.get(), 1, random)();
        done = number < (Math.pow(16, loopCounter + 1 ) );
        loopCounter++;
    }
    return str;
}

module.exports = generate;


/***/ }),

/***/ "./node_modules/shortid/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/shortid/lib/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");
var build = __webpack_require__(/*! ./build */ "./node_modules/shortid/lib/build.js");
var isValid = __webpack_require__(/*! ./is-valid */ "./node_modules/shortid/lib/is-valid.js");

// if you are using cluster or multiple servers use this to make each instance
// has a unique value for worker
// Note: I don't know if this is automatically set when using third
// party cluster solutions such as pm2.
var clusterWorkerId = __webpack_require__(/*! ./util/cluster-worker-id */ "./node_modules/shortid/lib/util/cluster-worker-id-browser.js") || 0;

/**
 * Set the seed.
 * Highly recommended if you don't want people to try to figure out your id schema.
 * exposed as shortid.seed(int)
 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
 */
function seed(seedValue) {
    alphabet.seed(seedValue);
    return module.exports;
}

/**
 * Set the cluster worker or machine id
 * exposed as shortid.worker(int)
 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
 * returns shortid module so it can be chained.
 */
function worker(workerId) {
    clusterWorkerId = workerId;
    return module.exports;
}

/**
 *
 * sets new characters to use in the alphabet
 * returns the shuffled alphabet
 */
function characters(newCharacters) {
    if (newCharacters !== undefined) {
        alphabet.characters(newCharacters);
    }

    return alphabet.shuffled();
}

/**
 * Generate unique id
 * Returns string id
 */
function generate() {
  return build(clusterWorkerId);
}

// Export all other functions as properties of the generate function
module.exports = generate;
module.exports.generate = generate;
module.exports.seed = seed;
module.exports.worker = worker;
module.exports.characters = characters;
module.exports.isValid = isValid;


/***/ }),

/***/ "./node_modules/shortid/lib/is-valid.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/is-valid.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");

function isShortId(id) {
    if (!id || typeof id !== 'string' || id.length < 6 ) {
        return false;
    }

    var nonAlphabetic = new RegExp('[^' +
      alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&') +
    ']');
    return !nonAlphabetic.test(id);
}

module.exports = isShortId;


/***/ }),

/***/ "./node_modules/shortid/lib/random/random-byte-browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/shortid/lib/random/random-byte-browser.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";


var crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

var randomByte;

if (!crypto || !crypto.getRandomValues) {
    randomByte = function(size) {
        var bytes = [];
        for (var i = 0; i < size; i++) {
            bytes.push(Math.floor(Math.random() * 256));
        }
        return bytes;
    };
} else {
    randomByte = function(size) {
        return crypto.getRandomValues(new Uint8Array(size));
    };
}

module.exports = randomByte;


/***/ }),

/***/ "./node_modules/shortid/lib/random/random-from-seed.js":
/*!*************************************************************!*\
  !*** ./node_modules/shortid/lib/random/random-from-seed.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

var seed = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
function getNextValue() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed/(233280.0);
}

function setSeed(_seed_) {
    seed = _seed_;
}

module.exports = {
    nextValue: getNextValue,
    seed: setSeed
};


/***/ }),

/***/ "./node_modules/shortid/lib/util/cluster-worker-id-browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/shortid/lib/util/cluster-worker-id-browser.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


module.exports = 0;


/***/ }),

/***/ "./node_modules/tmp/lib/tmp.js":
/*!*************************************!*\
  !*** ./node_modules/tmp/lib/tmp.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */

/*
 * Module dependencies.
 */
const fs = __webpack_require__(/*! fs */ "fs");
const os = __webpack_require__(/*! os */ "os");
const path = __webpack_require__(/*! path */ "path");
const crypto = __webpack_require__(/*! crypto */ "crypto");
const _c = { fs: fs.constants, os: os.constants };

/*
 * The working inner variables.
 */
const // the random characters to choose from
  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
  TEMPLATE_PATTERN = /XXXXXX/,
  DEFAULT_TRIES = 3,
  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),
  // constants are off on the windows platform and will not match the actual errno codes
  IS_WIN32 = os.platform() === 'win32',
  EBADF = _c.EBADF || _c.os.errno.EBADF,
  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,
  DIR_MODE = 0o700 /* 448 */,
  FILE_MODE = 0o600 /* 384 */,
  EXIT = 'exit',
  // this will hold the objects need to be removed on exit
  _removeObjects = [],
  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback
  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);

let _gracefulCleanup = false;

/**
 * Recursively remove a directory and its contents.
 *
 * @param {string} dirPath path of directory to remove
 * @param {Function} callback
 * @private
 */
function rimraf(dirPath, callback) {
  return fs.rm(dirPath, { recursive: true }, callback);
}

/**
 * Recursively remove a directory and its contents, synchronously.
 *
 * @param {string} dirPath path of directory to remove
 * @private
 */
function FN_RIMRAF_SYNC(dirPath) {
  return fs.rmSync(dirPath, { recursive: true });
}

/**
 * Gets a temporary file name.
 *
 * @param {(Options|tmpNameCallback)} options options or callback
 * @param {?tmpNameCallback} callback the callback function
 */
function tmpName(options, callback) {
  const args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  _assertAndSanitizeOptions(opts, function (err, sanitizedOptions) {
    if (err) return cb(err);

    let tries = sanitizedOptions.tries;
    (function _getUniqueName() {
      try {
        const name = _generateTmpName(sanitizedOptions);

        // check whether the path exists then retry if needed
        fs.stat(name, function (err) {
          /* istanbul ignore else */
          if (!err) {
            /* istanbul ignore else */
            if (tries-- > 0) return _getUniqueName();

            return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));
          }

          cb(null, name);
        });
      } catch (err) {
        cb(err);
      }
    })();
  });
}

/**
 * Synchronous version of tmpName.
 *
 * @param {Object} options
 * @returns {string} the generated random name
 * @throws {Error} if the options are invalid or could not generate a filename
 */
function tmpNameSync(options) {
  const args = _parseArguments(options),
    opts = args[0];

  const sanitizedOptions = _assertAndSanitizeOptionsSync(opts);

  let tries = sanitizedOptions.tries;
  do {
    const name = _generateTmpName(sanitizedOptions);
    try {
      fs.statSync(name);
    } catch (e) {
      return name;
    }
  } while (tries-- > 0);

  throw new Error('Could not get a unique tmp filename, max tries reached');
}

/**
 * Creates and opens a temporary file.
 *
 * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined
 * @param {?fileCallback} callback
 */
function file(options, callback) {
  const args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
    if (err) return cb(err);

    // create and open the file
    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
      /* istanbu ignore else */
      if (err) return cb(err);

      if (opts.discardDescriptor) {
        return fs.close(fd, function _discardCallback(possibleErr) {
          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only
          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));
        });
      } else {
        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care
        // about the descriptor
        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
      }
    });
  });
}

/**
 * Synchronous version of file.
 *
 * @param {Options} options
 * @returns {FileSyncObject} object consists of name, fd and removeCallback
 * @throws {Error} if cannot create a file
 */
function fileSync(options) {
  const args = _parseArguments(options),
    opts = args[0];

  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
  const name = tmpNameSync(opts);
  let fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
  /* istanbul ignore else */
  if (opts.discardDescriptor) {
    fs.closeSync(fd);
    fd = undefined;
  }

  return {
    name: name,
    fd: fd,
    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
  };
}

/**
 * Creates a temporary directory.
 *
 * @param {(Options|dirCallback)} options the options or the callback function
 * @param {?dirCallback} callback
 */
function dir(options, callback) {
  const args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
    if (err) return cb(err);

    // create the directory
    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
      /* istanbul ignore else */
      if (err) return cb(err);

      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
    });
  });
}

/**
 * Synchronous version of dir.
 *
 * @param {Options} options
 * @returns {DirSyncObject} object consists of name and removeCallback
 * @throws {Error} if it cannot create a directory
 */
function dirSync(options) {
  const args = _parseArguments(options),
    opts = args[0];

  const name = tmpNameSync(opts);
  fs.mkdirSync(name, opts.mode || DIR_MODE);

  return {
    name: name,
    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
  };
}

/**
 * Removes files asynchronously.
 *
 * @param {Object} fdPath
 * @param {Function} next
 * @private
 */
function _removeFileAsync(fdPath, next) {
  const _handler = function (err) {
    if (err && !_isENOENT(err)) {
      // reraise any unanticipated error
      return next(err);
    }
    next();
  };

  if (0 <= fdPath[0])
    fs.close(fdPath[0], function () {
      fs.unlink(fdPath[1], _handler);
    });
  else fs.unlink(fdPath[1], _handler);
}

/**
 * Removes files synchronously.
 *
 * @param {Object} fdPath
 * @private
 */
function _removeFileSync(fdPath) {
  let rethrownException = null;
  try {
    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);
  } catch (e) {
    // reraise any unanticipated error
    if (!_isEBADF(e) && !_isENOENT(e)) throw e;
  } finally {
    try {
      fs.unlinkSync(fdPath[1]);
    } catch (e) {
      // reraise any unanticipated error
      if (!_isENOENT(e)) rethrownException = e;
    }
  }
  if (rethrownException !== null) {
    throw rethrownException;
  }
}

/**
 * Prepares the callback for removal of the temporary file.
 *
 * Returns either a sync callback or a async callback depending on whether
 * fileSync or file was called, which is expressed by the sync parameter.
 *
 * @param {string} name the path of the file
 * @param {number} fd file descriptor
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {fileCallback | fileCallbackSync}
 * @private
 */
function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {
  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);
  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);

  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return sync ? removeCallbackSync : removeCallback;
}

/**
 * Prepares the callback for removal of the temporary directory.
 *
 * Returns either a sync callback or a async callback depending on whether
 * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.
 *
 * @param {string} name
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {Function} the callback
 * @private
 */
function _prepareTmpDirRemoveCallback(name, opts, sync) {
  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);
  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);
  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);
  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return sync ? removeCallbackSync : removeCallback;
}

/**
 * Creates a guarded function wrapping the removeFunction call.
 *
 * The cleanup callback is save to be called multiple times.
 * Subsequent invocations will be ignored.
 *
 * @param {Function} removeFunction
 * @param {string} fileOrDirName
 * @param {boolean} sync
 * @param {cleanupCallbackSync?} cleanupCallbackSync
 * @returns {cleanupCallback | cleanupCallbackSync}
 * @private
 */
function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {
  let called = false;

  // if sync is true, the next parameter will be ignored
  return function _cleanupCallback(next) {
    /* istanbul ignore else */
    if (!called) {
      // remove cleanupCallback from cache
      const toRemove = cleanupCallbackSync || _cleanupCallback;
      const index = _removeObjects.indexOf(toRemove);
      /* istanbul ignore else */
      if (index >= 0) _removeObjects.splice(index, 1);

      called = true;
      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
        return removeFunction(fileOrDirName);
      } else {
        return removeFunction(fileOrDirName, next || function () {});
      }
    }
  };
}

/**
 * The garbage collector.
 *
 * @private
 */
function _garbageCollector() {
  /* istanbul ignore else */
  if (!_gracefulCleanup) return;

  // the function being called removes itself from _removeObjects,
  // loop until _removeObjects is empty
  while (_removeObjects.length) {
    try {
      _removeObjects[0]();
    } catch (e) {
      // already removed?
    }
  }
}

/**
 * Random name generator based on crypto.
 * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
 *
 * @param {number} howMany
 * @returns {string} the generated random name
 * @private
 */
function _randomChars(howMany) {
  let value = [],
    rnd = null;

  // make sure that we do not fail because we ran out of entropy
  try {
    rnd = crypto.randomBytes(howMany);
  } catch (e) {
    rnd = crypto.pseudoRandomBytes(howMany);
  }

  for (let i = 0; i < howMany; i++) {
    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
  }

  return value.join('');
}

/**
 * Checks whether the `obj` parameter is defined or not.
 *
 * @param {Object} obj
 * @returns {boolean} true if the object is undefined
 * @private
 */
function _isUndefined(obj) {
  return typeof obj === 'undefined';
}

/**
 * Parses the function arguments.
 *
 * This function helps to have optional arguments.
 *
 * @param {(Options|null|undefined|Function)} options
 * @param {?Function} callback
 * @returns {Array} parsed arguments
 * @private
 */
function _parseArguments(options, callback) {
  /* istanbul ignore else */
  if (typeof options === 'function') {
    return [{}, options];
  }

  /* istanbul ignore else */
  if (_isUndefined(options)) {
    return [{}, callback];
  }

  // copy options so we do not leak the changes we make internally
  const actualOptions = {};
  for (const key of Object.getOwnPropertyNames(options)) {
    actualOptions[key] = options[key];
  }

  return [actualOptions, callback];
}

/**
 * Resolve the specified path name in respect to tmpDir.
 *
 * The specified name might include relative path components, e.g. ../
 * so we need to resolve in order to be sure that is is located inside tmpDir
 *
 * @private
 */
function _resolvePath(name, tmpDir, cb) {
  const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);

  fs.stat(pathToResolve, function (err) {
    if (err) {
      fs.realpath(path.dirname(pathToResolve), function (err, parentDir) {
        if (err) return cb(err);

        cb(null, path.join(parentDir, path.basename(pathToResolve)));
      });
    } else {
      fs.realpath(pathToResolve, cb);
    }
  });
}

/**
 * Resolve the specified path name in respect to tmpDir.
 *
 * The specified name might include relative path components, e.g. ../
 * so we need to resolve in order to be sure that is is located inside tmpDir
 *
 * @private
 */
function _resolvePathSync(name, tmpDir) {
  const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);

  try {
    fs.statSync(pathToResolve);
    return fs.realpathSync(pathToResolve);
  } catch (_err) {
    const parentDir = fs.realpathSync(path.dirname(pathToResolve));

    return path.join(parentDir, path.basename(pathToResolve));
  }
}

/**
 * Generates a new temporary name.
 *
 * @param {Object} opts
 * @returns {string} the new random name according to opts
 * @private
 */
function _generateTmpName(opts) {
  const tmpDir = opts.tmpdir;

  /* istanbul ignore else */
  if (!_isUndefined(opts.name)) {
    return path.join(tmpDir, opts.dir, opts.name);
  }

  /* istanbul ignore else */
  if (!_isUndefined(opts.template)) {
    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));
  }

  // prefix and postfix
  const name = [
    opts.prefix ? opts.prefix : 'tmp',
    '-',
    process.pid,
    '-',
    _randomChars(12),
    opts.postfix ? '-' + opts.postfix : ''
  ].join('');

  return path.join(tmpDir, opts.dir, name);
}

/**
 * Asserts and sanitizes the basic options.
 *
 * @private
 */
function _assertOptionsBase(options) {
  if (!_isUndefined(options.name)) {
    const name = options.name;

    // assert that name is not absolute and does not contain a path
    if (path.isAbsolute(name)) throw new Error(`name option must not contain an absolute path, found "${name}".`);

    // must not fail on valid .<name> or ..<name> or similar such constructs
    const basename = path.basename(name);
    if (basename === '..' || basename === '.' || basename !== name)
      throw new Error(`name option must not contain a path, found "${name}".`);
  }

  /* istanbul ignore else */
  if (!_isUndefined(options.template) && !options.template.match(TEMPLATE_PATTERN)) {
    throw new Error(`Invalid template, found "${options.template}".`);
  }

  /* istanbul ignore else */
  if ((!_isUndefined(options.tries) && isNaN(options.tries)) || options.tries < 0) {
    throw new Error(`Invalid tries, found "${options.tries}".`);
  }

  // if a name was specified we will try once
  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
  options.keep = !!options.keep;
  options.detachDescriptor = !!options.detachDescriptor;
  options.discardDescriptor = !!options.discardDescriptor;
  options.unsafeCleanup = !!options.unsafeCleanup;

  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to
  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;
  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;
}

/**
 * Gets the relative directory to tmpDir.
 *
 * @private
 */
function _getRelativePath(option, name, tmpDir, cb) {
  if (_isUndefined(name)) return cb(null);

  _resolvePath(name, tmpDir, function (err, resolvedPath) {
    if (err) return cb(err);

    const relativePath = path.relative(tmpDir, resolvedPath);

    if (!resolvedPath.startsWith(tmpDir)) {
      return cb(new Error(`${option} option must be relative to "${tmpDir}", found "${relativePath}".`));
    }

    cb(null, relativePath);
  });
}

/**
 * Gets the relative path to tmpDir.
 *
 * @private
 */
function _getRelativePathSync(option, name, tmpDir) {
  if (_isUndefined(name)) return;

  const resolvedPath = _resolvePathSync(name, tmpDir);
  const relativePath = path.relative(tmpDir, resolvedPath);

  if (!resolvedPath.startsWith(tmpDir)) {
    throw new Error(`${option} option must be relative to "${tmpDir}", found "${relativePath}".`);
  }

  return relativePath;
}

/**
 * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
 * options.
 *
 * @private
 */
function _assertAndSanitizeOptions(options, cb) {
  _getTmpDir(options, function (err, tmpDir) {
    if (err) return cb(err);

    options.tmpdir = tmpDir;

    try {
      _assertOptionsBase(options, tmpDir);
    } catch (err) {
      return cb(err);
    }

    // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to
    _getRelativePath('dir', options.dir, tmpDir, function (err, dir) {
      if (err) return cb(err);

      options.dir = _isUndefined(dir) ? '' : dir;

      // sanitize further if template is relative to options.dir
      _getRelativePath('template', options.template, tmpDir, function (err, template) {
        if (err) return cb(err);

        options.template = template;

        cb(null, options);
      });
    });
  });
}

/**
 * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
 * options.
 *
 * @private
 */
function _assertAndSanitizeOptionsSync(options) {
  const tmpDir = (options.tmpdir = _getTmpDirSync(options));

  _assertOptionsBase(options, tmpDir);

  const dir = _getRelativePathSync('dir', options.dir, tmpDir);
  options.dir = _isUndefined(dir) ? '' : dir;

  options.template = _getRelativePathSync('template', options.template, tmpDir);

  return options;
}

/**
 * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
function _isEBADF(error) {
  return _isExpectedError(error, -EBADF, 'EBADF');
}

/**
 * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
function _isENOENT(error) {
  return _isExpectedError(error, -ENOENT, 'ENOENT');
}

/**
 * Helper to determine whether the expected error code matches the actual code and errno,
 * which will differ between the supported node versions.
 *
 * - Node >= 7.0:
 *   error.code {string}
 *   error.errno {number} any numerical value will be negated
 *
 * CAVEAT
 *
 * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT
 * is no different here.
 *
 * @param {SystemError} error
 * @param {number} errno
 * @param {string} code
 * @private
 */
function _isExpectedError(error, errno, code) {
  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;
}

/**
 * Sets the graceful cleanup.
 *
 * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the
 * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary
 * object removals.
 */
function setGracefulCleanup() {
  _gracefulCleanup = true;
}

/**
 * Returns the currently configured tmp dir from os.tmpdir().
 *
 * @private
 */
function _getTmpDir(options, cb) {
  return fs.realpath((options && options.tmpdir) || os.tmpdir(), cb);
}

/**
 * Returns the currently configured tmp dir from os.tmpdir().
 *
 * @private
 */
function _getTmpDirSync(options) {
  return fs.realpathSync((options && options.tmpdir) || os.tmpdir());
}

// Install process exit listener
process.addListener(EXIT, _garbageCollector);

/**
 * Configuration options.
 *
 * @typedef {Object} Options
 * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected
 * @property {?number} tries the number of tries before give up the name generation
 * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files
 * @property {?string} template the "mkstemp" like filename template
 * @property {?string} name fixed name relative to tmpdir or the specified dir option
 * @property {?string} dir tmp directory relative to the root tmp directory in use
 * @property {?string} prefix prefix for the generated name
 * @property {?string} postfix postfix for the generated name
 * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir
 * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty
 * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection
 * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection
 */

/**
 * @typedef {Object} FileSyncObject
 * @property {string} name the name of the file
 * @property {string} fd the file descriptor or -1 if the fd has been discarded
 * @property {fileCallback} removeCallback the callback function to remove the file
 */

/**
 * @typedef {Object} DirSyncObject
 * @property {string} name the name of the directory
 * @property {fileCallback} removeCallback the callback function to remove the directory
 */

/**
 * @callback tmpNameCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 */

/**
 * @callback fileCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback fileCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * @callback dirCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback dirCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallback
 * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallbackSync
 */

/**
 * Callback function for function composition.
 * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
 *
 * @callback simpleCallback
 */

// exporting all the needed methods

// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will
// allow users to reconfigure the temporary directory
Object.defineProperty(module.exports, "tmpdir", ({
  enumerable: true,
  configurable: false,
  get: function () {
    return _getTmpDirSync();
  }
}));

module.exports.dir = dir;
module.exports.dirSync = dirSync;

module.exports.file = file;
module.exports.fileSync = fileSync;

module.exports.tmpName = tmpName;
module.exports.tmpNameSync = tmpNameSync;

module.exports.setGracefulCleanup = setGracefulCleanup;


/***/ }),

/***/ "./src/actions/persistent.ts":
/*!***********************************!*\
  !*** ./src/actions/persistent.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clearPendingVote = exports.setPendingVote = exports.updateSuccessRate = exports.updateRevisionInfo = exports.updateCollectionInfo = void 0;
const redux_act_1 = __webpack_require__(/*! redux-act */ "redux-act");
exports.updateCollectionInfo = (0, redux_act_1.createAction)('UPDATE_COLLECTION_INFO', (collectionId, collectionInfo, timestamp) => ({ collectionId, collectionInfo, timestamp }));
exports.updateRevisionInfo = (0, redux_act_1.createAction)('UPDATE_REVISION_INFO', (revisionId, revisionInfo, timestamp) => ({ revisionId, revisionInfo, timestamp }));
exports.updateSuccessRate = (0, redux_act_1.createAction)('UPDATE_COLLECTION_HEALTH_RATE', (revisionId, vote, average, total) => ({ revisionId, vote, average, total }));
exports.setPendingVote = (0, redux_act_1.createAction)('SET_REVISION_PENDING_VOTE', (revisionId, collectionSlug, revisionNumber, time) => ({ revisionId, collectionSlug, revisionNumber, time }));
exports.clearPendingVote = (0, redux_act_1.createAction)('CLEAR_REVISION_PENDING_VOTE', (revisionId) => ({ revisionId }));


/***/ }),

/***/ "./src/actions/session.ts":
/*!********************************!*\
  !*** ./src/actions/session.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.healthDownvoteDialog = exports.startAddModsToCollection = exports.startEditCollection = void 0;
const redux_act_1 = __webpack_require__(/*! redux-act */ "redux-act");
exports.startEditCollection = (0, redux_act_1.createAction)('START_EDIT_COLLECTION', (modId) => ({ modId }));
exports.startAddModsToCollection = (0, redux_act_1.createAction)('START_ADD_MODS_TO_COLLECTION', (collectionId) => ({ collectionId }));
exports.healthDownvoteDialog = (0, redux_act_1.createAction)('HEALTH_DOWNVOTE_DIALOG', (collectionModId) => ({ collectionModId }));


/***/ }),

/***/ "./src/actions/settings.ts":
/*!*********************************!*\
  !*** ./src/actions/settings.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setSortWorkshop = exports.setSortAdded = void 0;
const redux_act_1 = __webpack_require__(/*! redux-act */ "redux-act");
exports.setSortAdded = (0, redux_act_1.createAction)('SORT_COLLECTION_ADDED', (sorting) => ({ sorting }));
exports.setSortWorkshop = (0, redux_act_1.createAction)('SORT_COLLECTION_WORKSHOP', (sorting) => ({ sorting }));


/***/ }),

/***/ "./src/collectionCreate.ts":
/*!*********************************!*\
  !*** ./src/collectionCreate.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeCollectionAction = exports.addCollectionAction = exports.alreadyIncluded = exports.removeCollectionCondition = exports.addCollectionCondition = exports.initFromProfile = void 0;
const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
const transformCollection_1 = __webpack_require__(/*! ./util/transformCollection */ "./src/util/transformCollection.ts");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const util_1 = __webpack_require__(/*! ./util/util */ "./src/util/util.ts");
async function initFromProfile(api, profileId) {
    var _a, _b;
    try {
        let forcedName;
        const isQuickCollection = profileId === undefined;
        if (isQuickCollection && vortex_api_1.selectors.activeProfile(api.getState()) === undefined) {
            throw new vortex_api_1.util.ProcessCanceled('No active profile');
        }
        else if (isQuickCollection) {
            profileId = vortex_api_1.selectors.activeProfile(api.getState()).id;
            await (0, transformCollection_1.showQuickCollectionRestrictionsDialog)(api);
            forcedName = `My mods: ${new Date().toLocaleDateString('en-GB', {
                day: '2-digit',
                month: 'short',
                year: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
            })}`;
        }
        const { id, name, updated, wantsToUpload } = await (0, transformCollection_1.createCollectionFromProfile)(api, profileId, forcedName);
        if (isQuickCollection) {
            const state = api.getState();
            const activeGameId = vortex_api_1.selectors.activeGameId(state);
            const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', activeGameId], {});
            const hasRules = ((_b = (_a = mods[id]) === null || _a === void 0 ? void 0 : _a.rules) !== null && _b !== void 0 ? _b : []).length > 0;
            if (!hasRules) {
                await api.showDialog('error', 'Collection is empty', {
                    text: 'The generated quick collection is empty. Please ensure the Nexus Mods sourced mods you want to include are '
                        + 'enabled and deployed.',
                }, [
                    { label: 'Close' },
                ]);
                return;
            }
        }
        api.store.dispatch(vortex_api_1.actions.setModEnabled(profileId, id, true));
        if (wantsToUpload) {
            await (0, util_1.uploadCollection)(api, profileId, id);
        }
        api.sendNotification({
            type: 'success',
            id: 'collection-created',
            title: updated ? 'Collection updated' : 'Collection created',
            message: name,
            displayMS: vortex_api_1.util.calcDuration(name.length + 20),
            actions: [
                {
                    title: 'Edit',
                    action: dismiss => {
                        api.events.emit('edit-collection', id);
                        dismiss();
                    },
                },
            ],
        });
    }
    catch (err) {
        if (!(err instanceof vortex_api_1.util.UserCanceled)) {
            throw err;
        }
    }
}
exports.initFromProfile = initFromProfile;
const collections = (mods) => {
    const isWorkshopCollection = mod => {
        var _a;
        return (mod.type === constants_1.MOD_TYPE)
            && (((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.editable) === true);
    };
    return Object.values(mods)
        .filter(isWorkshopCollection)
        .map(coll => { var _a; return new Set(((_a = coll.rules) !== null && _a !== void 0 ? _a : []).map(rule => rule.reference.id)); });
};
function addCollectionCondition(api, instanceIds) {
    const state = api.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const mods = state.persistent.mods[gameId];
    return collections(mods).find(ruleSet => {
        return instanceIds.find(modId => (mods[modId].type !== constants_1.MOD_TYPE) && !ruleSet.has(modId)) !== undefined;
    }) !== undefined;
}
exports.addCollectionCondition = addCollectionCondition;
function removeCollectionCondition(api, instanceIds) {
    const state = api.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const mods = state.persistent.mods[gameId];
    return collections(mods).find(ruleSet => {
        return instanceIds.find(modId => ruleSet.has(modId)) !== undefined;
    }) !== undefined;
}
exports.removeCollectionCondition = removeCollectionCondition;
function alreadyIncluded(rules, modId) {
    var _a;
    return ((_a = rules === null || rules === void 0 ? void 0 : rules.find) === null || _a === void 0 ? void 0 : _a.call(rules, rule => rule.reference.id === modId)) !== undefined;
}
exports.alreadyIncluded = alreadyIncluded;
function addCollectionAction(api, instanceIdsIn) {
    const state = api.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const mods = state.persistent.mods[gameId];
    const instanceIds = instanceIdsIn.filter(modId => mods[modId] !== undefined);
    const filtered = instanceIds.filter(modId => (mods[modId].type !== constants_1.MOD_TYPE));
    const collections = Object.keys(mods)
        .filter(collectionId => {
        var _a, _b;
        if ((mods[collectionId].type !== constants_1.MOD_TYPE)
            || (((_a = mods[collectionId].attributes) === null || _a === void 0 ? void 0 : _a.editable) !== true)) {
            return false;
        }
        const rules = (_b = mods[collectionId].rules) !== null && _b !== void 0 ? _b : [];
        return filtered.find(modId => !alreadyIncluded(rules, modId)) !== undefined;
    });
    const sortAlphabetically = (modIds) => {
        const temp = [...modIds];
        temp.sort((a, b) => {
            const modA = vortex_api_1.util.renderModName(mods[a]).toLowerCase();
            const modB = vortex_api_1.util.renderModName(mods[b]).toLowerCase();
            return modA.localeCompare(modB);
        });
        return temp;
    };
    return api.showDialog('question', 'Add Mods to Collection', {
        text: 'Choose which collection you want the selected mods to be added',
        message: sortAlphabetically(filtered).map(modId => vortex_api_1.util.renderModName(mods[modId], { version: true, variant: true })).join('\n'),
        choices: sortAlphabetically(collections).map((modId, idx) => ({
            id: modId,
            text: vortex_api_1.util.renderModName(mods[modId]),
            value: idx === 0,
        })),
    }, [
        { label: 'Cancel' },
        { label: 'Add' },
    ])
        .then((result) => {
        var _a;
        if (result.action === 'Add') {
            const collectionId = Object.keys(result.input).find(target => result.input[target]);
            if (mods[collectionId] === undefined) {
                return;
            }
            const rules = (_a = mods[collectionId].rules) !== null && _a !== void 0 ? _a : [];
            vortex_api_1.util.batchDispatch(api.store, filtered.reduce((prev, modId) => {
                if (!alreadyIncluded(rules, modId) && (mods[modId].type !== constants_1.MOD_TYPE)) {
                    prev.push(vortex_api_1.actions.addModRule(gameId, collectionId, {
                        type: 'requires',
                        reference: {
                            id: modId,
                        },
                    }));
                }
                return prev;
            }, []));
        }
    });
}
exports.addCollectionAction = addCollectionAction;
function removeCollectionAction(api, instanceIds) {
    const state = api.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const mods = state.persistent.mods[gameId];
    const collections = Object.keys(mods)
        .filter(collectionId => {
        var _a, _b;
        if ((mods[collectionId].type !== constants_1.MOD_TYPE)
            || (((_a = mods[collectionId].attributes) === null || _a === void 0 ? void 0 : _a.editable) !== true)) {
            return false;
        }
        const rules = (_b = mods[collectionId].rules) !== null && _b !== void 0 ? _b : [];
        return instanceIds.find(modId => alreadyIncluded(rules, modId)) !== undefined;
    });
    return api.showDialog('question', 'Remove Mods from Collection', {
        text: 'Please select the (modifiable) collection to remove the mods from',
        message: instanceIds.map(modId => vortex_api_1.util.renderModName(mods[modId])).join('\n'),
        choices: collections.map((modId, idx) => ({
            id: modId,
            text: vortex_api_1.util.renderModName(mods[modId]),
            value: idx === 0,
        })),
    }, [
        { label: 'Cancel' },
        { label: 'Remove' },
    ])
        .then((result) => {
        var _a;
        if (result.action === 'Remove') {
            const collectionId = Object.keys(result.input).find(target => result.input[target]);
            const rules = (_a = mods[collectionId].rules) !== null && _a !== void 0 ? _a : [];
            vortex_api_1.util.batchDispatch(api.store, instanceIds.reduce((prev, modId) => {
                const ruleToRemove = rules.find(rule => rule.reference.id === modId);
                if (ruleToRemove !== undefined) {
                    prev.push(vortex_api_1.actions.removeModRule(gameId, collectionId, ruleToRemove));
                }
                return prev;
            }, []));
        }
    });
}
exports.removeCollectionAction = removeCollectionAction;


/***/ }),

/***/ "./src/collectionExport.ts":
/*!*********************************!*\
  !*** ./src/collectionExport.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.doExportToFile = exports.doExportToAPI = void 0;
const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
const transformCollection_1 = __webpack_require__(/*! ./util/transformCollection */ "./src/util/transformCollection.ts");
const util_1 = __webpack_require__(/*! ./util/util */ "./src/util/util.ts");
const PromiseBB = __webpack_require__(/*! bluebird */ "bluebird");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Zip = __webpack_require__(/*! node-7z */ "node-7z");
const path = __webpack_require__(/*! path */ "path");
const tmp_1 = __webpack_require__(/*! tmp */ "./node_modules/tmp/lib/tmp.js");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
async function withTmpDir(cb) {
    return new Promise((resolve, reject) => {
        (0, tmp_1.dir)((err, tmpPath, cleanup) => {
            if (err !== null) {
                return reject(err);
            }
            else {
                cb(tmpPath)
                    .then(() => {
                    resolve();
                })
                    .catch(tmpErr => {
                    reject(tmpErr);
                })
                    .finally(() => {
                    try {
                        cleanup();
                    }
                    catch (err) {
                        (0, vortex_api_1.log)('warn', 'Failed to clean up temp file', { path, err });
                    }
                });
            }
        });
    });
}
async function zip(zipPath, sourcePath) {
    const zipper = new Zip();
    const files = await vortex_api_1.fs.readdirAsync(sourcePath);
    await zipper.add(zipPath, files.map(fileName => path.join(sourcePath, fileName)));
}
async function generateCollectionInfo(api, gameId, collection, progress, error) {
    const state = api.getState();
    const mods = state.persistent.mods[gameId];
    const stagingPath = vortex_api_1.selectors.installPath(state);
    return (0, transformCollection_1.modToCollection)(api, gameId, stagingPath, collection, mods, progress, error);
}
async function writeCollectionToFile(state, info, mod, outputPath) {
    var _a, _b, _c;
    await vortex_api_1.fs.ensureDirWritableAsync(outputPath, () => PromiseBB.resolve());
    await vortex_api_1.fs.writeFileAsync(path.join(outputPath, 'collection.json'), JSON.stringify(info, undefined, 2));
    const stagingPath = vortex_api_1.selectors.installPath(state);
    const modPath = path.join(stagingPath, mod.installationPath);
    try {
        const tweaks = (_a = mod.enabledINITweaks) !== null && _a !== void 0 ? _a : [];
        for (const tweak of tweaks) {
            await vortex_api_1.fs.copyAsync(path.join(modPath, 'INI Tweaks', tweak), path.join(outputPath, 'INI Tweaks', tweak));
        }
    }
    catch (err) {
        if (err.code !== 'ENOENT') {
            throw err;
        }
    }
    await vortex_api_1.fs.copyAsync(path.join(modPath, constants_1.BUNDLED_PATH), path.join(outputPath, constants_1.BUNDLED_PATH));
    await vortex_api_1.fs.copyAsync(path.join(modPath, constants_1.PATCHES_PATH), path.join(outputPath, constants_1.PATCHES_PATH));
    const zipPath = path.join(modPath, 'export', `collection_${(_c = (_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.version) !== null && _c !== void 0 ? _c : '0'}.7z`);
    try {
        await vortex_api_1.fs.removeAsync(zipPath);
    }
    catch (err) {
        if (err.code !== 'ENOENT') {
            throw err;
        }
    }
    await zip(zipPath, outputPath);
    await vortex_api_1.fs.removeAsync(outputPath);
    return zipPath;
}
function filterInfoModSource(source) {
    return _.omit(source, ['instructions', 'fileSize', 'tag']);
}
function filterInfoMod(mod) {
    const res = _.omit(mod, ['hashes', 'choices', 'patches', 'details', 'instructions', 'phase', 'fileOverrides']);
    res.source = filterInfoModSource(res.source);
    return res;
}
function filterInfo(input) {
    const info = _.omit(input.info, ['installInstructions']);
    return {
        info,
        mods: input.mods.map(mod => filterInfoMod(mod)),
    };
}
async function queryErrorsContinue(api, errors) {
    const res = await api.showDialog('error', 'Errors creating collection', {
        text: 'There were errors creating the collection, do you want to proceed anyway?',
        message: errors.map(err => api.translate(err.message, { replace: err.replace })).join('\n'),
    }, [
        { label: 'Cancel' },
        { label: 'Continue' },
    ]);
    if (res.action === 'Cancel') {
        throw new vortex_api_1.util.UserCanceled();
    }
}
function renderGraphLocateError(api, gameId, modId, det) {
    var _a, _b, _c;
    const t = api.translate;
    const state = api.getState();
    const mods = state.persistent.mods[gameId];
    switch (det.attribute) {
        case 'modId': {
            const missingMod = Object.values(mods).find(iter => { var _a, _b, _c; return ((_c = (_b = (_a = iter.attributes) === null || _a === void 0 ? void 0 : _a.modId) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) === det.value.toString(); });
            if (missingMod !== undefined) {
                return t('Mod not found on nexusmods.com: {{modName}} (modId: {{modId}}), '
                    + 'it may have been removed.', { replace: {
                        modName: vortex_api_1.util.renderModName(missingMod),
                        modId: det.value,
                    } });
            }
            else {
                return t('Mod with id {{modId}} not found', { replace: { modId: det.value } });
            }
        }
        case 'fileId': {
            const missingMod = Object.values(mods).find(iter => { var _a, _b, _c; return ((_c = (_b = (_a = iter.attributes) === null || _a === void 0 ? void 0 : _a.fileId) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) === det.value.toString(); });
            if (missingMod !== undefined) {
                return t('Mod not found on nexusmods.com: {{modName}} '
                    + '(modId: {{modId}}, fileId: {{fileId}}), '
                    + 'it may have been removed.', { replace: {
                        modName: vortex_api_1.util.renderModName(missingMod, { version: true }),
                        modId: (_b = (_a = missingMod.attributes) === null || _a === void 0 ? void 0 : _a.modId) !== null && _b !== void 0 ? _b : 'Unknown',
                        fileId: (_c = missingMod.attributes) === null || _c === void 0 ? void 0 : _c.fileId,
                    } });
            }
            else {
                return t('Mod with file id {{fileId}} not found', { replace: { fileId: det.value } });
            }
        }
        default: {
            return det.message;
        }
    }
}
function renderGraphErrorFallback(message, det) {
    return det.message || message;
}
function renderGraphErrorDetail(api, gameId, modId, message, det) {
    if ((det.type === 'LOCATE_ERROR') && !!det.value) {
        return renderGraphLocateError(api, gameId, modId, det);
    }
    else {
        return renderGraphErrorFallback(message, det);
    }
}
async function doExportToAPI(api, gameId, modId, uploaderName) {
    var _a;
    const state = api.store.getState();
    const mod = state.persistent.mods[gameId][modId];
    const { progress, progressEnd } = (0, util_1.makeProgressFunction)(api);
    const errors = [];
    let mayIgnore = true;
    const onError = (message, replace, allowIgnore) => {
        errors.push({ message, replace });
        mayIgnore && (mayIgnore = allowIgnore);
    };
    let info;
    let collectionId;
    let collectionSlug;
    let revisionNumber;
    try {
        info = await generateCollectionInfo(api, gameId, mod, progress, onError);
        if (errors.length > 0) {
            if (mayIgnore) {
                await queryErrorsContinue(api, errors);
            }
            else {
                throw new vortex_api_1.util.UserCanceled();
            }
        }
        await withTmpDir(async (tmpPath) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const filePath = await writeCollectionToFile(state, info, mod, tmpPath);
            collectionId = (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.collectionId) !== null && _b !== void 0 ? _b : undefined;
            const modUploader = (_d = (_c = mod.attributes) === null || _c === void 0 ? void 0 : _c.uploader) !== null && _d !== void 0 ? _d : (_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.author;
            if ((collectionId !== undefined) && (modUploader !== uploaderName)) {
                (0, vortex_api_1.log)('info', 'user doesn\'t match original author, creating new collection');
                collectionId = undefined;
            }
            const result = await vortex_api_1.util.toPromise(cb => api.events.emit('submit-collection', filterInfo(info), filePath, collectionId, cb));
            collectionId = result.collection.id;
            collectionSlug = result.collection.slug;
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'collectionId', collectionId));
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'collectionSlug', result.collection.slug));
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'source', 'nexus'));
            const revisionId = (_g = (_f = result.revision) === null || _f === void 0 ? void 0 : _f.id) !== null && _g !== void 0 ? _g : result['revisionId'];
            revisionNumber = (_j = (_h = result.revision) === null || _h === void 0 ? void 0 : _h.revisionNumber) !== null && _j !== void 0 ? _j : result['revisionNumber'];
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'revisionId', revisionId));
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'revisionNumber', revisionNumber));
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'version', ((revisionNumber !== null && revisionNumber !== void 0 ? revisionNumber : 0) + 1).toString()));
        });
        progressEnd();
    }
    catch (err) {
        progressEnd();
        if (err.name === 'ModFileNotFound') {
            const file = info.mods.find(iter => iter.source.fileId === err.fileId);
            api.sendNotification({
                type: 'error',
                title: 'The server can\'t find one of the files in the collection, '
                    + 'are mod id and file id for it set correctly?',
                message: file !== undefined ? file.name : `id: ${err.fileId}`,
            });
            throw new vortex_api_1.util.ProcessCanceled('Mod file not found');
        }
        else if (err.constructor.name === 'ParameterInvalid') {
            api.sendNotification({
                type: 'error',
                title: 'The server rejected this collection',
                message: err.message || '<No reason given>',
            });
            throw new vortex_api_1.util.ProcessCanceled('collection rejected');
        }
        else if (err.constructor.name === 'GraphError') {
            const message = err.message;
            const details = (_a = err['details']) !== null && _a !== void 0 ? _a : [];
            api.sendNotification({
                type: 'error',
                message: 'The server rejected this collection',
                actions: [
                    { title: 'More', action: () => {
                            api.showDialog('error', 'The server rejected this collection', {
                                text: details.length === 0 ? message : details.map(detail => renderGraphErrorDetail(api, gameId, modId, message, detail)).join('\n'),
                            }, [
                                { label: 'Close' },
                            ]);
                        } },
                ],
            });
            throw new vortex_api_1.util.ProcessCanceled('collection rejected');
        }
        else if (err instanceof vortex_api_1.util.ProcessCanceled) {
            api.showErrorNotification('Failed to upload collection', err, { allowReport: false });
        }
        else {
            throw err;
        }
    }
    return { slug: collectionSlug, revisionNumber };
}
exports.doExportToAPI = doExportToAPI;
async function doExportToFile(api, gameId, modId) {
    const state = api.store.getState();
    const mod = state.persistent.mods[gameId][modId];
    const { progress, progressEnd } = (0, util_1.makeProgressFunction)(api);
    const errors = [];
    const onError = (message, replace) => {
        errors.push({ message, replace });
    };
    try {
        const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
        const modPath = path.join(stagingPath, mod.installationPath);
        const outputPath = path.join(modPath, 'build');
        const info = await generateCollectionInfo(api, gameId, mod, progress, onError);
        const zipPath = await writeCollectionToFile(state, info, mod, outputPath);
        const dialogActions = [
            {
                title: 'Open', action: () => {
                    vortex_api_1.util.opn(path.join(stagingPath, mod.installationPath, 'export')).catch(() => null);
                },
            },
        ];
        if (errors.length > 0) {
            const li = (input) => `[*]${input}`;
            dialogActions.unshift({
                title: 'Errors',
                action: () => {
                    api.showDialog('error', 'Collection Export Errors', {
                        bbcode: '[list]'
                            + errors.map(err => li(api.translate(err.message, { replace: err.replace })))
                            + '[/list]',
                    }, [
                        { label: 'Close' },
                    ]);
                },
            });
        }
        api.sendNotification({
            id: 'collection-exported',
            title: errors.length > 0 ? 'Collection exported, there were errors' : 'Collection exported',
            message: zipPath,
            type: errors.length > 0 ? 'warning' : 'success',
            actions: dialogActions,
        });
    }
    catch (err) {
        api.showErrorNotification('Failed to export collection', err);
    }
    progressEnd();
}
exports.doExportToFile = doExportToFile;


/***/ }),

/***/ "./src/collectionInstall.ts":
/*!**********************************!*\
  !*** ./src/collectionInstall.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.postprocessCollection = exports.makeInstall = exports.testSupported = void 0;
const extension_1 = __webpack_require__(/*! ./util/extension */ "./src/util/extension.ts");
const gameSupport_1 = __webpack_require__(/*! ./util/gameSupport */ "./src/util/gameSupport/index.ts");
const transformCollection_1 = __webpack_require__(/*! ./util/transformCollection */ "./src/util/transformCollection.ts");
const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
const _ = __webpack_require__(/*! lodash */ "lodash");
const path = __webpack_require__(/*! path */ "path");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const importCollection_1 = __webpack_require__(/*! ./util/importCollection */ "./src/util/importCollection.ts");
const collectionConfig_1 = __webpack_require__(/*! ./util/collectionConfig */ "./src/util/collectionConfig/index.ts");
async function testSupported(files, gameId) {
    return {
        supported: files.indexOf('collection.json') !== -1,
        requiredFiles: ['collection.json'],
    };
}
exports.testSupported = testSupported;
function makeInstall(api) {
    return async (files, destinationPath, gameId, progressDelegate) => {
        var _a;
        const collection = await (0, importCollection_1.readCollection)(api, path.join(destinationPath, 'collection.json'));
        const config = await (0, collectionConfig_1.parseConfig)({ collection, gameId });
        const configInstructions = Object.entries(config).reduce((accum, [key, value]) => {
            const instr = { type: 'attribute', key, value, };
            accum.push(instr);
            return accum;
        }, []);
        const filesToCopy = files
            .filter(filePath => !filePath.endsWith(path.sep)
            && (filePath.split(path.sep)[0] !== constants_1.BUNDLED_PATH));
        const bundled = files
            .filter(filePath => !filePath.endsWith(path.sep)
            && (filePath.split(path.sep)[0] === constants_1.BUNDLED_PATH));
        const knownGames = vortex_api_1.selectors.knownGames(api.getState());
        const state = api.getState();
        const downloads = Object.values(state.persistent.downloads.files).reverse();
        const collectionDownload = downloads.find(down => (down.localPath !== undefined)
            && (path.basename(destinationPath, '.installing')
                === path.basename(down.localPath, path.extname(down.localPath))));
        return Promise.resolve({
            instructions: [
                {
                    type: 'attribute',
                    key: 'customFileName',
                    value: (((_a = collectionDownload === null || collectionDownload === void 0 ? void 0 : collectionDownload.modInfo) === null || _a === void 0 ? void 0 : _a.name) !== undefined)
                        ? collectionDownload.modInfo.name
                        : collection.info.name,
                },
                {
                    type: 'attribute',
                    key: 'installInstructions',
                    value: collection.info.installInstructions,
                },
                ...configInstructions,
                {
                    type: 'setmodtype',
                    value: constants_1.MOD_TYPE,
                },
                ...filesToCopy.map(filePath => ({
                    type: 'copy',
                    source: filePath,
                    destination: filePath,
                })),
                ...bundled.map(filePath => ({
                    type: 'copy',
                    source: filePath,
                    destination: filePath,
                })),
                ...collection.mods.map(mod => ({
                    type: 'rule',
                    rule: (0, transformCollection_1.collectionModToRule)(knownGames, mod),
                })),
            ],
        });
    };
}
exports.makeInstall = makeInstall;
function applyCollectionRules(api, gameId, collection, mods) {
    var _a;
    const batch = ((_a = collection.modRules) !== null && _a !== void 0 ? _a : []).reduce((prev, rule) => {
        var _a, _b;
        const sourceMod = vortex_api_1.util.findModByRef(rule.source, mods);
        if (sourceMod !== undefined) {
            const destMod = vortex_api_1.util.findModByRef(rule.reference, mods);
            let exists = false;
            if (destMod !== undefined) {
                const exSourceRules = ((_a = sourceMod.rules) !== null && _a !== void 0 ? _a : []).filter(iter => ['before', 'after'].includes(iter.type)
                    && vortex_api_1.util.testModReference(destMod, iter.reference));
                exSourceRules.forEach(exSourceRule => {
                    const copy = JSON.parse(JSON.stringify(exSourceRule));
                    delete copy.reference.idHint;
                    if (!exists && _.isEqual(copy, rule)) {
                        exists = true;
                    }
                    else {
                        prev.push(vortex_api_1.actions.removeModRule(gameId, sourceMod.id, exSourceRule));
                    }
                });
                const exDestRules = ((_b = destMod.rules) !== null && _b !== void 0 ? _b : []).filter(iter => ['before', 'after'].includes(iter.type)
                    && vortex_api_1.util.testModReference(sourceMod, iter.reference));
                exDestRules.forEach(exDestRule => {
                    prev.push(vortex_api_1.actions.removeModRule(gameId, destMod.id, exDestRule));
                });
                rule.reference = {
                    id: destMod.id,
                    idHint: destMod.id,
                    archiveId: destMod.archiveId,
                };
            }
            if (!exists) {
                (0, vortex_api_1.log)('info', 'add collection rule', { gameId, sourceMod: sourceMod.id, rule: JSON.stringify(rule) });
                prev.push(vortex_api_1.actions.addModRule(gameId, sourceMod.id, rule));
            }
        }
        return prev;
    }, []);
    vortex_api_1.util.batchDispatch(api.store, batch);
}
async function postprocessCollection(api, gameId, collectionMod, collection, mods) {
    (0, vortex_api_1.log)('info', 'postprocess collection');
    applyCollectionRules(api, gameId, collection, mods);
    try {
        await vortex_api_1.util.toPromise(cb => api.events.emit('deploy-mods', cb));
    }
    catch (err) {
        (0, vortex_api_1.log)('warn', 'Failed to deploy during collection post processing');
    }
    const exts = (0, extension_1.findExtensions)(api.getState(), gameId);
    for (const ext of exts) {
        await ext.parse(gameId, collection, collectionMod);
    }
    await (0, gameSupport_1.parseGameSpecifics)(api, gameId, collection, collectionMod);
}
exports.postprocessCollection = postprocessCollection;


/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.INSTRUCTIONS_PLACEHOLDER = exports.DEFAULT_INSTRUCTIONS = exports.CACHE_LRU_COUNT = exports.CACHE_EXPIRE_MS = exports.PATCH_OVERHEAD = exports.MAX_PATCH_SIZE = exports.DELAY_FIRST_VOTE_REQUEST = exports.TIME_BEFORE_VOTE = exports.OPTIONAL_TWEAK_PREFIX = exports.INI_TWEAKS_PATH = exports.MAX_COLLECTION_NAME_LENGTH = exports.MIN_COLLECTION_NAME_LENGTH = exports.INSTALLING_NOTIFICATION_ID = exports.PATCHES_PATH = exports.BUNDLED_PATH = exports.ADULT_CONTENT_URL = exports.TOS_URL = exports.PREMIUM_PATH = exports.NEXUS_PROTOCOL = exports.NEXUS_BASE_GAMES_URL = exports.NEXUS_NEXT_URL = exports.NEXUS_BASE_URL = exports.NEXUS_NEXT_SUBDOMAIN = exports.NEXUS_FLAMEWORK_SUBDOMAIN = exports.NEXUS_DOMAIN = exports.AVATAR_FALLBACK = exports.AUTHOR_UNKNOWN = exports.NAMESPACE = exports.MOD_TYPE = void 0;
exports.MOD_TYPE = 'collection';
exports.NAMESPACE = 'collection';
exports.AUTHOR_UNKNOWN = '<Unknown User>';
exports.AVATAR_FALLBACK = 'assets/images/noavatar.png';
exports.NEXUS_DOMAIN = process.env['NEXUS_DOMAIN'] || 'nexusmods.com';
exports.NEXUS_FLAMEWORK_SUBDOMAIN = process.env['FLAMEWORK_SUBDOMAIN'] || 'www';
exports.NEXUS_NEXT_SUBDOMAIN = process.env['NEXT_SUBDOMAIN'] || 'next';
exports.NEXUS_BASE_URL = process.env['NEXUS_BASE_URL'] || `https://${exports.NEXUS_FLAMEWORK_SUBDOMAIN}.${exports.NEXUS_DOMAIN}`;
exports.NEXUS_NEXT_URL = process.env['NEXUS_NEXT_URL'] || `https://${exports.NEXUS_DOMAIN}/games`;
exports.NEXUS_BASE_GAMES_URL = process.env['NEXUS_BASE_GAMES_URL'] || `https://${exports.NEXUS_FLAMEWORK_SUBDOMAIN}.${exports.NEXUS_DOMAIN}/games`;
exports.NEXUS_PROTOCOL = 'https:';
exports.PREMIUM_PATH = ['account', 'billing', 'premium'];
exports.TOS_URL = 'https://help.nexusmods.com/article/115-guidelines-for-collections';
exports.ADULT_CONTENT_URL = 'https://help.nexusmods.com/article/19-adult-content-guidelines';
exports.BUNDLED_PATH = 'bundled';
exports.PATCHES_PATH = 'patches';
exports.INSTALLING_NOTIFICATION_ID = 'installing-collection-';
exports.MIN_COLLECTION_NAME_LENGTH = 3;
exports.MAX_COLLECTION_NAME_LENGTH = 36;
exports.INI_TWEAKS_PATH = 'Ini Tweaks';
exports.OPTIONAL_TWEAK_PREFIX = '(optional).';
exports.TIME_BEFORE_VOTE = 48 * 60 * 60 * 1000;
exports.DELAY_FIRST_VOTE_REQUEST = 1 * 60 * 1000;
exports.MAX_PATCH_SIZE = 0.2;
exports.PATCH_OVERHEAD = 130;
exports.CACHE_EXPIRE_MS = 1 * 60 * 60 * 1000;
exports.CACHE_LRU_COUNT = 50;
exports.DEFAULT_INSTRUCTIONS = 'No additional instructions.';
exports.INSTRUCTIONS_PLACEHOLDER = 'Enter instructions here (Markdown supported - Links, Bold, Italics)';


/***/ }),

/***/ "./src/eventHandlers.ts":
/*!******************************!*\
  !*** ./src/eventHandlers.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.onCollectionUpdate = void 0;
const Bluebird = __webpack_require__(/*! bluebird */ "bluebird");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const InstallChangelogDialog_1 = __webpack_require__(/*! ./views/InstallDialog/InstallChangelogDialog */ "./src/views/InstallDialog/InstallChangelogDialog.tsx");
async function collectionUpdate(api, downloadGameId, collectionSlug, revisionNumber, oldModId) {
    var _a, _b, _c;
    try {
        const latest = (await api.emitAndAwait('get-nexus-collection-revision', collectionSlug, parseInt(revisionNumber, 10)))[0];
        if (latest === undefined) {
            throw new vortex_api_1.util.ProcessCanceled(`Server returned no info on collection ${collectionSlug}, revision ${revisionNumber}`);
        }
        const collection = latest.collection;
        if (collectionSlug !== collection.slug) {
            throw new Error(`Invalid collection "${collectionSlug}"`);
        }
        const state = api.getState();
        const gameMode = vortex_api_1.selectors.activeGameId(state);
        const oldMod = state.persistent.mods[gameMode][oldModId];
        if (!!((_a = latest.collectionChangelog) === null || _a === void 0 ? void 0 : _a.description) && (oldMod !== undefined)) {
            await (0, InstallChangelogDialog_1.default)(oldMod, gameMode, latest);
        }
        const modInfo = {
            game: downloadGameId,
            source: 'nexus',
            name: collection === null || collection === void 0 ? void 0 : collection.name,
            nexus: {
                ids: {
                    gameId: downloadGameId,
                    collectionId: collection.id,
                    collectionSlug,
                    revisionId: latest.id,
                    revisionNumber: latest.revisionNumber,
                },
                revisionInfo: latest,
            },
        };
        const downloadURLs = (await api.emitAndAwait('resolve-collection-url', latest.downloadLink))[0];
        let dlId;
        try {
            const fileName = vortex_api_1.util.sanitizeFilename(collection.name);
            dlId = await vortex_api_1.util.toPromise(cb => api.events.emit('start-download', downloadURLs.map(iter => iter.URI), modInfo, fileName + `-rev${latest.revisionNumber}.7z`, cb, 'never', { allowInstall: false }));
        }
        catch (err) {
            if (err.name === 'AlreadyDownloaded') {
                const { files } = api.getState().persistent.downloads;
                dlId = Object.keys(files).find(iter => files[iter].localPath === err.fileName);
            }
            if (dlId === undefined) {
                throw err;
            }
        }
        api.events.emit('analytics-track-click-event', 'Collections', 'Update Collection');
        const oldRules = (_b = oldMod === null || oldMod === void 0 ? void 0 : oldMod.rules) !== null && _b !== void 0 ? _b : [];
        const newModId = await vortex_api_1.util.toPromise(cb => api.events.emit('start-install-download', dlId, undefined, cb));
        const mods = api.getState().persistent.mods[gameMode];
        if (mods[newModId] === undefined) {
            throw new vortex_api_1.util.ProcessCanceled('Download failed, update archive not found');
        }
        const candidates = oldRules
            .filter(rule => ['requires', 'recommends'].includes(rule.type))
            .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
            .filter(mod => {
            var _a;
            return (mod !== undefined)
                && (((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a['installedAsDependency']) === true);
        });
        const notCandidates = Object.values(mods)
            .filter(mod => !candidates.includes(mod) && ![oldModId, newModId].includes(mod.id));
        const references = (rules, mod) => (rules !== null && rules !== void 0 ? rules : []).find(rule => ['requires', 'recommends'].includes(rule.type)
            && vortex_api_1.util.testModReference(mod, rule.reference)) !== undefined;
        const obsolete = candidates
            .filter(mod => !references(mods[newModId].rules, mod))
            .filter(mod => notCandidates
            .find(other => references(other.rules, mod)) === undefined);
        let ops = { remove: [], keep: [] };
        if (obsolete.length > 0) {
            const collectionName = (_c = collection === null || collection === void 0 ? void 0 : collection.name) !== null && _c !== void 0 ? _c : vortex_api_1.util.renderModName(oldMod);
            const result = await api.showDialog('question', 'Remove mods from old revision?', {
                text: 'There are {{count}} mods installed that are not present in the latest '
                    + 'revision of "{{collectionName}}". It is recommended that you remove the '
                    + 'unused mods to avoid compatibility issues going forward. '
                    + 'If you choose to keep the mods installed they will no longer be associated '
                    + 'with this Collection and will be managed as if they have been installed '
                    + 'individually. Would you like to remove the old mods now?',
                parameters: {
                    count: obsolete.length,
                    collectionName,
                },
            }, [
                { label: 'Keep All' },
                { label: 'Review Mods' },
                { label: 'Remove All' },
            ]);
            if (result.action === 'Keep All') {
                ops.keep = obsolete.map(mod => mod.id);
            }
            else if (result.action === 'Remove All') {
                ops.remove = obsolete.map(mod => mod.id);
            }
            else {
                const reviewResult = await api.showDialog('question', 'Remove mods from old revision?', {
                    text: 'The following mods are not present in the latest revision of '
                        + '"{{collectionName}}". Please select the ones to remove.',
                    parameters: {
                        collectionName,
                    },
                    checkboxes: obsolete.map(mod => ({ id: mod.id, text: vortex_api_1.util.renderModName(mod), value: true })),
                }, [
                    { label: 'Keep All' },
                    { label: 'Remove selected' },
                ]);
                if (reviewResult.action === 'Keep All') {
                    ops.keep = obsolete.map(mod => mod.id);
                }
                else {
                    ops = Object.keys(reviewResult.input).reduce((prev, value) => {
                        if (reviewResult.input[value]) {
                            prev.remove.push(value);
                        }
                        else {
                            prev.keep.push(value);
                        }
                        return prev;
                    }, { remove: [], keep: [] });
                }
            }
        }
        vortex_api_1.util.batchDispatch(api.store, ops.keep.map(modId => vortex_api_1.actions.setModAttribute(gameMode, modId, 'installedAsDependency', false)));
        await vortex_api_1.util.toPromise(cb => api.events.emit('remove-mods', gameMode, [oldModId, ...ops.remove], cb, { incomplete: true, ignoreInstalling: true }));
    }
    catch (err) {
        if (!(err instanceof vortex_api_1.util.UserCanceled)) {
            api.showErrorNotification('Failed to download collection', err, {
                allowReport: !(err instanceof vortex_api_1.util.ProcessCanceled),
                warning: err instanceof vortex_api_1.util.ProcessCanceled,
            });
        }
    }
}
function onCollectionUpdate(api, driver) {
    return (gameId, collectionSlug, revisionNumber, source, oldModId, cb) => {
        if ((source !== 'nexus') || (collectionSlug === undefined) || (revisionNumber === undefined)) {
            return;
        }
        driver.prepare(() => Bluebird.resolve(collectionUpdate(api, gameId, collectionSlug, revisionNumber.toString(), oldModId))
            .then(() => {
            cb === null || cb === void 0 ? void 0 : cb(null);
        })
            .catch(err => {
            if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                api.showErrorNotification('Failed to update collection', err);
            }
            cb === null || cb === void 0 ? void 0 : cb(err);
        }));
    };
}
exports.onCollectionUpdate = onCollectionUpdate;


/***/ }),

/***/ "./src/initweaks.ts":
/*!**************************!*\
  !*** ./src/initweaks.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.importTweaks = exports.getEnabledTweaks = void 0;
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const IniTweaks_1 = __webpack_require__(/*! ./views/IniTweaks */ "./src/views/IniTweaks.tsx");
const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
const gameSupport = {
    skyrim: {
        gameSettingsFiles: ['Skyrim.ini', 'SkyrimPrefs.ini'],
    },
    skyrimse: {
        gameSettingsFiles: ['Skyrim.ini', 'SkyrimPrefs.ini', 'SkyrimCustom.ini'],
    },
    skyrimvr: {
        gameSettingsFiles: ['Skyrim.ini', 'SkyrimPrefs.ini'],
    },
    fallout3: {
        gameSettingsFiles: ['Fallout.ini', 'FalloutPrefs.ini', 'FalloutCustom.ini'],
    },
    fallout4: {
        gameSettingsFiles: ['Fallout4.ini', 'Fallout4Prefs.ini', 'Fallout4Custom.ini'],
    },
    fallout4vr: {
        gameSettingsFiles: ['Fallout4Custom.ini', 'Fallout4Prefs.ini'],
    },
    falloutnv: {
        gameSettingsFiles: ['Fallout.ini', 'FalloutPrefs.ini'],
    },
    starfield: {
        gameSettingsFiles: ['StarfieldCustom.ini', 'StarfieldPrefs.ini'],
    },
    oblivion: {
        gameSettingsFiles: ['Oblivion.ini'],
    },
    enderal: {
        gameSettingsFiles: ['Enderal.ini', 'EnderalPrefs.ini'],
    },
    enderalspecialedition: {
        gameSettingsFiles: ['Enderal.ini', 'EnderalPrefs.ini'],
    },
};
function isSupported(gameId) {
    return gameSupport[gameId] !== undefined;
}
function validateFilenameInput(content) {
    const input = content.input[0].value || '';
    if ((input.length < 2) || !vortex_api_1.util.isFilenameValid(input)) {
        return [{
                actions: ['Confirm'],
                errorText: 'Has to be a valid file name',
                id: content.input[0].id,
            }];
    }
    else {
        return [];
    }
}
function TweakListWrap(api, prop) {
    return React.createElement(IniTweaks_1.default, {
        ...prop,
        settingsFiles: gameSupport[prop.gameId].gameSettingsFiles,
        onRefreshTweaks: genRefreshTweaks,
        onAddIniTweak: (modPath, settingsFiles) => genAddIniTweak(api, modPath, settingsFiles),
        onRemoveIniTweak: (modPath, tweak) => genRemoveIniTweak(api, prop, modPath, tweak),
    });
}
async function getTweaks(dirPath) {
    try {
        const tweaks = await vortex_api_1.fs.readdirAsync(dirPath);
        return tweaks;
    }
    catch (err) {
        (0, vortex_api_1.log)('debug', 'failed to find tweaks', err);
        return [];
    }
}
function getEnabledTweaks(api, gameId, modId) {
    const state = api.getState();
    const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', gameId], {});
    const tweaks = vortex_api_1.util.getSafe(mods[modId], ['enabledINITweaks'], []);
    return tweaks;
}
exports.getEnabledTweaks = getEnabledTweaks;
async function importTweaks(api, profile, mods, destCollection, force) {
    var _a;
    const tweaks = await getAllTweaks(api, profile, mods);
    const state = api.getState();
    const stagingFolder = vortex_api_1.selectors.installPathForGame(state, profile.gameId);
    const destTweakDirPath = path.join(stagingFolder, destCollection.id, constants_1.INI_TWEAKS_PATH);
    const batchedActions = [];
    const existingTweaks = (_a = destCollection.enabledINITweaks) !== null && _a !== void 0 ? _a : [];
    await vortex_api_1.fs.ensureDirWritableAsync(destTweakDirPath);
    for (const tweak of tweaks) {
        if (force !== true && existingTweaks.includes(tweak.fileName)) {
            continue;
        }
        try {
            const dest = path.join(destTweakDirPath, path.basename(tweak.sourcePath));
            await vortex_api_1.fs.copyAsync(tweak.sourcePath, dest, { overwrite: true });
            batchedActions.push(vortex_api_1.actions.setINITweakEnabled(profile.gameId, destCollection.id, tweak.fileName, true));
        }
        catch (err) {
            (0, vortex_api_1.log)('error', 'Unable to import tweak', err);
            continue;
        }
    }
    if (batchedActions.length > 0) {
        vortex_api_1.util.batchDispatch(api.store, batchedActions);
    }
    return Promise.resolve(tweaks);
}
exports.importTweaks = importTweaks;
async function getAllTweaks(api, profile, mods) {
    const state = api.getState();
    if ((profile === null || profile === void 0 ? void 0 : profile.gameId) === undefined) {
        return Promise.resolve([]);
    }
    const installationPath = vortex_api_1.selectors.installPathForGame(state, profile.gameId);
    const enabledMods = Object.keys(mods)
        .filter(id => vortex_api_1.util.getSafe(profile.modState, [id, 'enabled'], false)
        && (mods[id].installationPath !== undefined));
    const validTweaks = [];
    for (const modId of enabledMods) {
        const modPath = path.join(installationPath, mods[modId].installationPath);
        const tweaks = getEnabledTweaks(api, profile.gameId, modId);
        if (tweaks.length === 0) {
            continue;
        }
        for (const tweak of tweaks) {
            try {
                const tweakPath = path.join(modPath, constants_1.INI_TWEAKS_PATH, tweak);
                await vortex_api_1.fs.statAsync(tweakPath);
                validTweaks.push({
                    enabled: true,
                    sourcePath: tweakPath,
                    fileName: tweak,
                });
            }
            catch (err) {
                continue;
            }
        }
    }
    return Promise.resolve(validTweaks);
}
async function removeOptionalPrefix(filePath) {
    try {
        if (filePath.indexOf(constants_1.OPTIONAL_TWEAK_PREFIX) !== -1) {
            const trimmedFilePath = filePath.replace(constants_1.OPTIONAL_TWEAK_PREFIX, '');
            await vortex_api_1.fs.removeAsync(trimmedFilePath).catch(err => null);
            await vortex_api_1.fs.linkAsync(filePath, trimmedFilePath);
            await vortex_api_1.fs.removeAsync(filePath);
            return Promise.resolve(trimmedFilePath);
        }
        else {
            return Promise.resolve(filePath);
        }
    }
    catch (err) {
        (0, vortex_api_1.log)('error', 'failed to remove optional prefix from ini file', { error: err, filePath });
        return Promise.resolve(filePath);
    }
}
async function genRefreshTweaks(modPath) {
    const tweakPath = path.join(modPath, constants_1.INI_TWEAKS_PATH);
    const tweaks = await getTweaks(tweakPath);
    return tweaks.reduce(async (accumP, twk) => {
        const accum = await accumP;
        const filePath = await removeOptionalPrefix(path.join(tweakPath, twk));
        accum.push({ fileName: path.basename(filePath) });
        return accum;
    }, Promise.resolve([]));
}
async function genRemoveIniTweak(api, props, modPath, tweak) {
    return api.showDialog('question', 'Remove INI Tweak', {
        text: 'You are about to remove an INI tweak "{{fileName}}" from the collection. Are you sure you wish to proceed ?',
        parameters: { fileName: tweak.fileName },
    }, [
        { label: 'Cancel' },
        { label: 'Remove' },
    ]).then(async (res) => {
        if (res.action === 'Remove') {
            try {
                const tweaks = await genRefreshTweaks(modPath);
                const targetTweak = tweaks.find(twk => twk.fileName === tweak.fileName);
                const tweakPath = path.join(modPath, constants_1.INI_TWEAKS_PATH, targetTweak.fileName);
                await vortex_api_1.fs.removeAsync(tweakPath);
                const { gameId, collection } = props;
                api.store.dispatch(vortex_api_1.actions.setINITweakEnabled(gameId, collection.id, targetTweak.fileName, false));
            }
            catch (err) {
                if (err.code === 'ENOENT') {
                    const { gameId, collection } = props;
                    api.store.dispatch(vortex_api_1.actions.setINITweakEnabled(gameId, collection.id, tweak.fileName, false));
                    return;
                }
                api.showErrorNotification('Failed to remove INI tweak', err, { allowReport: ['EPERM'].includes(err.code) });
            }
        }
    });
}
async function genAddIniTweak(api, modPath, settingsFiles) {
    return api.showDialog('question', 'Name', {
        text: 'Please enter a name for the ini tweak',
        input: [
            { id: 'name', type: 'text' },
        ],
        choices: settingsFiles.map((fileName, idx) => ({
            text: fileName,
            value: idx === 0,
            id: fileName,
        })),
        condition: validateFilenameInput,
    }, [
        { label: 'Cancel' },
        { label: 'Confirm' },
    ]).then(res => {
        if (res.action === 'Confirm') {
            const tweaksPath = path.join(modPath, constants_1.INI_TWEAKS_PATH);
            let selectedIni = Object.keys(res.input)
                .find(key => (path.extname(key) === '.ini') && res.input[key] === true);
            if (selectedIni === undefined) {
                return Promise.reject(new Error('No ini file selected'));
            }
            selectedIni = path.basename(selectedIni, path.extname(selectedIni));
            const fileName = `${res.input['name']} [${selectedIni}].ini`;
            return vortex_api_1.fs.ensureDirWritableAsync(tweaksPath, () => Promise.resolve())
                .then(() => vortex_api_1.fs.writeFileAsync(path.join(tweaksPath, fileName), ''));
        }
        else {
            return Promise.resolve();
        }
    });
}
async function genEnableIniTweaks(api, gameId, mod) {
    const stagingPath = vortex_api_1.selectors.installPathForGame(api.getState(), gameId);
    const modPath = path.join(stagingPath, mod.installationPath);
    try {
        const tweaks = await genRefreshTweaks(modPath);
        const batched = tweaks.map(req => vortex_api_1.actions.setINITweakEnabled(gameId, mod.id, req.fileName, true));
        if (batched.length > 0) {
            vortex_api_1.util.batchDispatch(api.store, batched);
        }
    }
    catch (err) {
        if (err.code !== 'ENOENT') {
            api.showErrorNotification('Failed to enable collection ini tweaks', err);
        }
    }
}
function init(context) {
    context.optional.registerCollectionFeature('ini-tweaks', () => Promise.resolve({}), (gameId, collection, mod) => genEnableIniTweaks(context.api, gameId, mod), () => Promise.resolve(), () => 'INI Tweaks', (state, gameId) => isSupported(gameId), (prop) => TweakListWrap(context.api, prop));
}
exports["default"] = init;


/***/ }),

/***/ "./src/reducers/persistent.ts":
/*!************************************!*\
  !*** ./src/reducers/persistent.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const actions = __webpack_require__(/*! ../actions/persistent */ "./src/actions/persistent.ts");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const persistentReducer = {
    reducers: {
        [actions.updateCollectionInfo]: (state, payload) => {
            const { collectionId, collectionInfo, timestamp } = payload;
            if (collectionInfo === undefined) {
                return vortex_api_1.util.deleteOrNop(state, ['collections', collectionId]);
            }
            else {
                return vortex_api_1.util.setSafe(state, ['collections', collectionId], { timestamp, info: collectionInfo });
            }
        },
        [actions.updateRevisionInfo]: (state, payload) => {
            const { revisionId, revisionInfo, timestamp } = payload;
            if (revisionInfo === undefined) {
                return vortex_api_1.util.deleteOrNop(state, ['revisions', 'revisionId']);
            }
            else {
                return vortex_api_1.util.setSafe(state, ['revisions', revisionId], { timestamp, info: revisionInfo });
            }
        },
        [actions.updateSuccessRate]: (state, payload) => {
            const { revisionId, vote, average, total } = payload;
            const revPath = ['revisions', revisionId, 'info'];
            state = vortex_api_1.util.setSafe(state, [...revPath, 'metadata', 'ratingValue'], vote);
            return vortex_api_1.util.setSafe(state, [...revPath, 'rating'], {
                average,
                total,
            });
        },
        [actions.setPendingVote]: (state, payload) => {
            const { revisionId, collectionSlug, revisionNumber, time } = payload;
            return vortex_api_1.util.setSafe(state, ['pendingVotes', revisionId], {
                collectionSlug, revisionNumber, time
            });
        },
        [actions.clearPendingVote]: (state, payload) => {
            const { revisionId } = payload;
            return vortex_api_1.util.deleteOrNop(state, ['pendingVotes', revisionId]);
        },
    },
    defaults: {
        collections: {},
        revisions: {},
        pendingVotes: {},
    },
};
exports["default"] = persistentReducer;


/***/ }),

/***/ "./src/reducers/session.ts":
/*!*********************************!*\
  !*** ./src/reducers/session.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const actions = __webpack_require__(/*! ../actions/session */ "./src/actions/session.ts");
const sessionReducer = {
    reducers: {
        [actions.startEditCollection]: (state, payload) => {
            const { modId } = payload;
            return vortex_api_1.util.setSafe(state, ['editCollectionId'], modId);
        },
        [actions.startAddModsToCollection]: (state, payload) => {
            const { collectionId } = payload;
            return vortex_api_1.util.setSafe(state, ['addModsId'], collectionId);
        },
        [actions.healthDownvoteDialog]: (state, payload) => {
            const { collectionModId } = payload;
            return vortex_api_1.util.setSafe(state, ['healthDownvoteDialog'], collectionModId);
        }
    },
    defaults: {
        editCollectionId: undefined,
        addModsId: undefined,
        healthDownvoteDialog: undefined,
    },
};
exports["default"] = sessionReducer;


/***/ }),

/***/ "./src/reducers/settings.ts":
/*!**********************************!*\
  !*** ./src/reducers/settings.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const actions = __webpack_require__(/*! ../actions/settings */ "./src/actions/settings.ts");
const settingsReducer = {
    reducers: {
        [actions.setSortAdded]: (state, payload) => {
            const { sorting } = payload;
            return vortex_api_1.util.setSafe(state, ['sortAdded'], sorting);
        },
        [actions.setSortWorkshop]: (state, payload) => {
            const { sorting } = payload;
            return vortex_api_1.util.setSafe(state, ['sortWorkshop'], sorting);
        },
    },
    defaults: {
        sortAdded: 'datedownloaded',
        sortWorkshop: 'recentlyupdated',
    },
};
exports["default"] = settingsReducer;


/***/ }),

/***/ "./src/tools.ts":
/*!**********************!*\
  !*** ./src/tools.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Tools_1 = __webpack_require__(/*! ./views/Tools */ "./src/views/Tools.tsx");
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const shortid_1 = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function ToolsListWrap(prop) {
    return React.createElement(Tools_1.default, {
        ...prop,
    });
}
function convertTools(state, gameId, includedTools) {
    const { tools } = state.settings.gameMode.discovered[gameId];
    const discovery = vortex_api_1.selectors.discoveryByGame(state, gameId);
    return vortex_api_1.util.makeUniqueByKey(includedTools !== null && includedTools !== void 0 ? includedTools : [], item => item)
        .filter(toolId => { var _a, _b; return ((_a = tools[toolId]) === null || _a === void 0 ? void 0 : _a.custom) && !((_b = tools[toolId]) === null || _b === void 0 ? void 0 : _b.hidden); })
        .map(toolId => {
        const tool = tools[toolId];
        const exe = vortex_api_1.util.isChildPath(tool.path, discovery.path)
            ? path.relative(discovery.path, tool.path)
            : tool.path;
        return {
            name: tool.name,
            exe,
            args: tool.parameters,
            env: tool.environment,
            cwd: tool.workingDirectory,
            detach: tool.detach,
            shell: tool.shell,
            onStart: tool.onStart,
        };
    });
}
function generateTools(api, gameId, mod) {
    var _a, _b;
    return {
        tools: convertTools(api.getState(), gameId, (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.includedTools),
    };
}
function normalizePath(input) {
    return path.normalize(input.toUpperCase());
}
function isSameTool(discovery, lhs, rhs) {
    if ((lhs === null || lhs === void 0 ? void 0 : lhs.path) === undefined) {
        return false;
    }
    return (normalizePath(lhs.path) === normalizePath(path.resolve(discovery.path, rhs.exe)))
        || (lhs.name === rhs.name);
}
function updatePaths(tool, gamePath) {
    return {
        ...tool,
        exe: path.isAbsolute(tool.exe)
            ? tool.exe
            : path.join(gamePath, tool.exe),
    };
}
async function cloneTools(api, gameId, tools, from, to) {
    const discovery = vortex_api_1.selectors.discoveryByGame(api.getState(), gameId);
    const knownTools = api.getState().settings.gameMode.discovered[gameId].tools;
    const includedTools = (tools !== null && tools !== void 0 ? tools : []).map(tool => {
        const exePath = path.isAbsolute(tool.exe)
            ? tool.exe
            : path.join(discovery.path, tool.exe);
        return Object.keys(knownTools !== null && knownTools !== void 0 ? knownTools : {})
            .find(iter => (knownTools[iter].custom && !knownTools[iter].hidden)
            && (normalizePath(knownTools[iter].path) === normalizePath(exePath)
                || knownTools[iter].name === tool.name));
    })
        .filter(iter => iter !== undefined);
    const attributes = vortex_api_1.util.setSafe(to.attributes.collection, ['includedTools'], includedTools);
    api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, to.id, 'collection', attributes));
}
async function setUpTools(api, gameId, tools) {
    const knownTools = api.getState().settings.gameMode.discovered[gameId].tools;
    const discovery = vortex_api_1.selectors.discoveryByGame(api.getState(), gameId);
    const addTools = (tools !== null && tools !== void 0 ? tools : [])
        .map(tool => updatePaths(tool, discovery.path))
        .filter(tool => Object.values(knownTools !== null && knownTools !== void 0 ? knownTools : {})
        .find(iter => isSameTool(discovery, iter, tool)) === undefined);
    const addActions = addTools.map(tool => {
        tool.id = (0, shortid_1.generate)();
        return vortex_api_1.actions.addDiscoveredTool(gameId, tool.id, {
            id: tool.id,
            path: tool.exe,
            name: tool.name,
            requiredFiles: [],
            executable: null,
            parameters: tool.args,
            environment: tool.env,
            workingDirectory: tool.cwd,
            shell: tool.shell,
            detach: tool.detach,
            onStart: tool.onStart,
            custom: true,
            hidden: true,
        }, true);
    });
    vortex_api_1.util.batchDispatch(api.store, addActions);
    const notFoundTools = [];
    await Promise.all(addTools.map(async (tool) => {
        try {
            await vortex_api_1.fs.statAsync(tool.exe);
        }
        catch (err) {
            notFoundTools.push(tool.name);
        }
        if (path.extname(tool.exe) === '.exe') {
            const iconPath = vortex_api_1.util.StarterInfo.toolIconRW(gameId, tool.id);
            await vortex_api_1.fs.ensureDirWritableAsync(path.dirname(iconPath), () => Promise.resolve());
            try {
                await vortex_api_1.util['extractExeIcon'](tool.exe, iconPath);
            }
            catch (err) {
                (0, vortex_api_1.log)('warn', 'failed to extract exe icon', { executable: tool.exe, error: err.message });
            }
        }
    }));
    if (notFoundTools.length > 0) {
        await api.showDialog('info', 'Tool not found', {
            text: 'The collection you just installed set up tools to be run from the dashboard, '
                + 'however not all were found locally. '
                + 'It\'s possible that these tools will be available after the next deployment '
                + 'completes, otherwise you may have to edit the configuration for the tool to '
                + 'adjust them to your own setup.',
            message: notFoundTools.join('\n'),
        }, [
            { label: 'Continue' },
        ]);
    }
    vortex_api_1.util.batchDispatch(api.store, addTools.map(tool => vortex_api_1.actions.setToolVisible(gameId, tool.id, true)));
}
function init(context) {
    context.optional.registerCollectionFeature('tools', (gameId, includedMods, mod) => generateTools(context.api, gameId, mod), (gameId, collection, mod) => setUpTools(context.api, gameId, collection['tools']), (gameId, collection, from, to) => cloneTools(context.api, gameId, collection['tools'], from, to), () => 'Tools', (state, gameId) => true, ToolsListWrap);
}
exports["default"] = init;


/***/ }),

/***/ "./src/util/InfoCache.ts":
/*!*******************************!*\
  !*** ./src/util/InfoCache.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const persistent_1 = __webpack_require__(/*! ../actions/persistent */ "./src/actions/persistent.ts");
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
const importCollection_1 = __webpack_require__(/*! ./importCollection */ "./src/util/importCollection.ts");
const path = __webpack_require__(/*! path */ "path");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
class InfoCache {
    constructor(api) {
        this.mCacheRevRequests = {};
        this.mCacheColRequests = {};
        this.mCacheColRules = {};
        this.mApi = api;
    }
    async getCollectionModRules(revisionId, collection, gameId) {
        const cacheId = revisionId !== null && revisionId !== void 0 ? revisionId : collection.id;
        if (this.mCacheColRules[cacheId] === undefined) {
            this.mCacheColRules[cacheId] = this.cacheCollectionModRules(revisionId, collection, gameId);
        }
        return this.mCacheColRules[cacheId];
    }
    async getCollectionInfo(slug, forceFetch) {
        var _a, _b;
        const { store } = this.mApi;
        if (slug === undefined) {
            return;
        }
        const collections = (_a = store.getState().persistent.collections.collections) !== null && _a !== void 0 ? _a : {};
        if (forceFetch
            || (((_b = collections[slug]) === null || _b === void 0 ? void 0 : _b.timestamp) === undefined)
            || ((Date.now() - collections[slug].timestamp) > constants_1.CACHE_EXPIRE_MS)) {
            if (this.mCacheColRequests[slug] === undefined) {
                this.mCacheColRequests[slug] = this.cacheCollectionInfo(slug);
            }
            return this.mCacheColRequests[slug];
        }
        return collections[slug].info;
    }
    async clearCache() {
        const { store } = this.mApi;
        const state = this.mApi.getState();
        const cutOffTime = Date.now() - constants_1.CACHE_EXPIRE_MS;
        {
            const { collections } = state.persistent.collections;
            const collectionsToDrop = Object.keys(collections)
                .sort((lhs, rhs) => collections[rhs].timestamp - collections[lhs].timestamp)
                .reduce((prev, iter, idx) => {
                if ((idx >= constants_1.CACHE_LRU_COUNT) || (collections[iter].timestamp < cutOffTime)) {
                    prev.push(iter);
                }
                return prev;
            }, []);
            if (collectionsToDrop.length > 0) {
                (0, vortex_api_1.log)('debug', 'dropping outdated collections cache', { ids: collectionsToDrop });
                vortex_api_1.util.batchDispatch(store, collectionsToDrop
                    .map(coll => (0, persistent_1.updateCollectionInfo)(coll, undefined, undefined)));
            }
        }
        {
            const { revisions } = state.persistent.collections;
            const revisionsToDrop = Object.keys(revisions)
                .sort((lhs, rhs) => revisions[rhs].timestamp - revisions[lhs].timestamp)
                .reduce((prev, iter, idx) => {
                if ((idx >= constants_1.CACHE_LRU_COUNT) || (revisions[iter].timestamp < cutOffTime)) {
                    prev.push(iter);
                }
                return prev;
            }, []);
            if (revisionsToDrop.length > 0) {
                (0, vortex_api_1.log)('debug', 'dropping outdated revision cache', { ids: revisionsToDrop });
                vortex_api_1.util.batchDispatch(store, revisionsToDrop
                    .map(rev => (0, persistent_1.updateRevisionInfo)(rev, undefined, undefined)));
            }
        }
    }
    async getRevisionInfo(revisionId, collectionSlug, revisionNumber, fetchBehavior = 'allow') {
        var _a, _b, _c, _d;
        const { store } = this.mApi;
        const revisions = (_a = store.getState().persistent.collections.revisions) !== null && _a !== void 0 ? _a : {};
        if ((fetchBehavior === 'force')
            || (((_b = revisions[revisionId]) === null || _b === void 0 ? void 0 : _b.timestamp) === undefined)
            || (((Date.now() - revisions[revisionId].timestamp) > constants_1.CACHE_EXPIRE_MS)
                && (fetchBehavior === 'allow'))) {
            this.fetchRevisionInfo(revisions, revisionId, collectionSlug, revisionNumber);
            return this.mCacheRevRequests[revisionId];
        }
        if (!((_d = (_c = revisions[revisionId]) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.collection)) {
            return Promise.resolve(undefined);
        }
        const collectionInfo = await this.getCollectionInfo(revisions[revisionId].info.collection.slug);
        return {
            ...revisions[revisionId].info,
            collection: {
                ...collectionInfo,
            },
        };
    }
    fetchRevisionInfo(revisions, revisionId, collectionSlug, revisionNumber) {
        var _a;
        (0, vortex_api_1.log)('info', 'revision info cache outdated', {
            timestamp: (_a = revisions[revisionId]) === null || _a === void 0 ? void 0 : _a.timestamp,
            now: Date.now(),
        });
        if (this.mCacheRevRequests[revisionId] === undefined) {
            this.mCacheRevRequests[revisionId] =
                this.cacheRevisionInfo(revisionId, collectionSlug, revisionNumber);
        }
    }
    async cacheCollectionModRules(revisionId, collection, gameId) {
        const store = this.mApi.store;
        const state = store.getState();
        const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', gameId], {});
        const colMod = collection !== null && collection !== void 0 ? collection : (Object.values(mods).find(iter => { var _a; return (iter.type === constants_1.MOD_TYPE) && (((_a = iter.attributes) === null || _a === void 0 ? void 0 : _a.revisionId) === revisionId); }));
        if ((colMod === null || colMod === void 0 ? void 0 : colMod.installationPath) === undefined) {
            return [];
        }
        const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
        try {
            const collectionInfo = await (0, importCollection_1.readCollection)(this.mApi, path.join(stagingPath, colMod.installationPath, 'collection.json'));
            return collectionInfo.modRules;
        }
        catch (err) {
            if (err.code !== 'ENOENT') {
                this.mApi.showErrorNotification('Failed to cache collection mod rules', err, {
                    allowReport: false,
                });
            }
            return [];
        }
    }
    async cacheCollectionInfo(collectionSlug) {
        const { store } = this.mApi;
        const collectionInfo = (await this.mApi.emitAndAwait('get-nexus-collection', collectionSlug))[0];
        if (!!(collectionInfo === null || collectionInfo === void 0 ? void 0 : collectionInfo.id)) {
            store.dispatch((0, persistent_1.updateCollectionInfo)(collectionInfo.id.toString(), collectionInfo, Date.now()));
            delete this.mCacheColRequests[collectionInfo.id.toString()];
        }
        return collectionInfo;
    }
    updateRevisionCacheState(store, revisionId, revisionInfo, now) {
        store.dispatch((0, persistent_1.updateCollectionInfo)(revisionInfo.collection.id.toString(), revisionInfo.collection, now));
        store.dispatch((0, persistent_1.updateRevisionInfo)(revisionId, {
            ...revisionInfo,
            collection: {
                id: revisionInfo.collection.id,
                slug: revisionInfo.collection.slug,
            },
        }, now));
    }
    async cacheRevisionInfo(revisionId, collectionSlug, revisionNumber) {
        const { store } = this.mApi;
        if ((collectionSlug === undefined) || (revisionNumber === undefined)) {
            const err = new Error('missing collection/revision id');
            err['allowReport'] = false;
            return Promise.reject(err);
        }
        const revisionInfo = (await this.mApi.emitAndAwait('get-nexus-collection-revision', collectionSlug, revisionNumber))[0];
        const now = Date.now();
        if (!!revisionInfo) {
            this.updateRevisionCacheState(store, revisionId, revisionInfo, now);
        }
        else {
            store.dispatch((0, persistent_1.updateRevisionInfo)(revisionId, null, now));
        }
        const result = await revisionInfo;
        delete this.mCacheRevRequests[revisionId];
        return result !== null && result !== void 0 ? result : null;
    }
}
exports["default"] = InfoCache;


/***/ }),

/***/ "./src/util/InstallDriver.ts":
/*!***********************************!*\
  !*** ./src/util/InstallDriver.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Promise = __webpack_require__(/*! bluebird */ "bluebird");
const path = __webpack_require__(/*! path */ "path");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const persistent_1 = __webpack_require__(/*! ../actions/persistent */ "./src/actions/persistent.ts");
const collectionInstall_1 = __webpack_require__(/*! ../collectionInstall */ "./src/collectionInstall.ts");
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
const binaryPatching_1 = __webpack_require__(/*! ./binaryPatching */ "./src/util/binaryPatching.ts");
const importCollection_1 = __webpack_require__(/*! ./importCollection */ "./src/util/importCollection.ts");
const InfoCache_1 = __webpack_require__(/*! ./InfoCache */ "./src/util/InfoCache.ts");
const util_1 = __webpack_require__(/*! ./util */ "./src/util/util.ts");
class InstallDriver {
    get requiredMods() {
        return this.mDependentMods.filter(_ => _.type === 'requires');
    }
    get recommendedMods() {
        return this.mDependentMods.filter(_ => _.type === 'recommends');
    }
    constructor(api) {
        this.mStep = 'prepare';
        this.mUpdateHandlers = [];
        this.mInstalledMods = [];
        this.mDependentMods = [];
        this.mInstallDone = false;
        this.mPrepare = Promise.resolve();
        this.mDebounce = new vortex_api_1.util.Debouncer((collectionSlug, revisionNumber) => {
            this.mApi.events.emit('analytics-track-event-with-payload', 'Collection Installation Failed', {
                collection_slug: collectionSlug,
                collection_revision_number: revisionNumber
            });
            return null;
        }, 1000);
        this.startInstall = async () => {
            var _a, _b;
            (_b = (_a = this.mApi.ext).withSuppressedTests) === null || _b === void 0 ? void 0 : _b.call(_a, ['plugins-changed', 'settings-changed', 'mod-activated', 'mod-installed'], () => new Promise(resolve => {
                this.mOnStop = () => {
                    resolve(undefined);
                    this.mOnStop = undefined;
                };
            }));
            return this.startImpl();
        };
        this.startImpl = async () => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            this.mApi.events.emit('analytics-track-event-with-payload', 'Collection Installation Started', {
                collection_slug: this.collectionSlug,
                collection_revision_number: this.revisionNumber
            });
            if ((((_a = this.mCollection) === null || _a === void 0 ? void 0 : _a.archiveId) === undefined) || (this.mProfile === undefined)) {
                return false;
            }
            this.mInstalledMods = [];
            this.mInstallingMod = undefined;
            this.mInstallDone = false;
            this.mStep = 'start';
            const collection = this.mCollection;
            const profile = this.mProfile;
            const gameId = this.mGameId;
            const state = this.mApi.store.getState();
            const mods = (_b = state.persistent.mods[gameId]) !== null && _b !== void 0 ? _b : {};
            const modInfo = (_c = state.persistent.downloads.files[collection.archiveId]) === null || _c === void 0 ? void 0 : _c.modInfo;
            const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
            const slug = this.collectionSlug;
            const revisionId = this.revisionId;
            if (revisionId !== undefined) {
                try {
                    this.mRevisionInfo = (_d = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.revisionInfo) !== null && _d !== void 0 ? _d : await this.mInfoCache.getRevisionInfo(revisionId, slug, this.revisionNumber);
                }
                catch (err) {
                    (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                        revisionId, slug, revisionNumber: this.revisionNumber, error: err.message
                    });
                }
            }
            const { userInfo } = (_e = state.persistent['nexus']) !== null && _e !== void 0 ? _e : {};
            if (((_h = (_g = (_f = this.mRevisionInfo) === null || _f === void 0 ? void 0 : _f.collection) === null || _g === void 0 ? void 0 : _g.user) === null || _h === void 0 ? void 0 : _h.memberId) !== (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId)) {
                this.mApi.store.dispatch((0, persistent_1.setPendingVote)(revisionId, slug, this.revisionNumber, Date.now()));
            }
            const gameMode = gameId;
            const currentgame = vortex_api_1.util.getGame(gameMode);
            const discovery = vortex_api_1.selectors.discoveryByGame(state, gameMode);
            const gameVersion = await currentgame.getInstalledVersion(discovery);
            const gvMatch = gv => gv.reference === gameVersion;
            const revGameVersions = (_k = (_j = this.mRevisionInfo) === null || _j === void 0 ? void 0 : _j.gameVersions) !== null && _k !== void 0 ? _k : [];
            if (((_l = revGameVersions.length) !== null && _l !== void 0 ? _l : 0 !== 0)
                && (revGameVersions.find(gvMatch) === undefined)) {
                const choice = await this.mApi.showDialog('question', 'Game version mismatch', {
                    bbcode: 'The version of the game you have installed is different to the one the curator used when creating this collection.'
                        + '[br][/br][br][/br]'
                        + 'Your game version: [style=dialog-success-text]{{actual}}[/style][br][/br]'
                        + 'Recommended game version: [style=dialog-danger-text]{{intended}}[/style]'
                        + '[br][/br][br][/br]'
                        + 'If you choose to continue, some or all of the mods included in the collection may not work properly for you. This will '
                        + 'require manual troubleshooting to correct. For users who are not familiar with modding, we do not recommend continuing with installation.'
                        + '[br][/br][br][/br]'
                        + 'You can also check the description, comments and bug reports on the Collection page to see if others have been successful'
                        + 'while playing with the game version you have installed or to request advice from the curator.',
                    parameters: {
                        actual: gameVersion,
                        intended: revGameVersions.map(gv => gv.reference).join(' or '),
                    },
                }, [
                    { label: 'Cancel' },
                    { label: 'Continue' },
                ]);
                if (choice.action === 'Cancel') {
                    this.mInstallDone = true;
                    return false;
                }
            }
            this.mApi.events.emit('will-install-collection', gameId, collection.id);
            this.mApi.events.emit('view-collection', collection.id);
            this.updateProgress(profile, gameId, collection);
            this.augmentRules(gameId, collection);
            this.mApi.dismissNotification((0, util_1.getUnfulfilledNotificationId)(collection.id));
            this.mApi.store.dispatch(vortex_api_1.actions.setModEnabled(profile.id, collection.id, true));
            const required = ((_m = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _m !== void 0 ? _m : [])
                .filter(rule => ['requires', 'recommends'].includes(rule.type));
            const dependencies = required
                .reduce((accum, rule) => {
                var _a;
                const modRef = {
                    ...rule.reference,
                    patches: ((_a = rule === null || rule === void 0 ? void 0 : rule.extra) === null || _a === void 0 ? void 0 : _a.patches) ? { ...rule.extra.patches } : undefined,
                    fileList: rule === null || rule === void 0 ? void 0 : rule.fileList,
                };
                const mod = vortex_api_1.util.findModByRef(modRef, mods);
                if (mod === undefined) {
                    accum.push(rule);
                }
                return accum;
            }, []);
            this.mDependentMods = dependencies;
            if (this.requiredMods.length === 0) {
                this.mInstallDone = false;
            }
            (0, vortex_api_1.log)('info', 'starting install of collection', {
                totalMods: required.length,
                missing: this.requiredMods.length,
            });
        };
        this.begin = () => {
            var _a;
            if ((this.mCollection === undefined) || (((_a = this.mProfile) === null || _a === void 0 ? void 0 : _a.id) === undefined)) {
                return;
            }
            this.mApi.events.emit('install-dependencies', this.mProfile.id, this.mGameId, [this.mCollection.id], true);
            this.mStep = 'installing';
        };
        this.closeDisclaimers = () => {
            this.mStep = 'installing';
        };
        this.finishInstalling = () => {
            this.mStep = 'review';
        };
        this.close = () => {
            if ((this.mGameId !== undefined) && (this.mCollection !== undefined)) {
                this.mApi.events.emit('did-install-collection', this.mGameId, this.mCollection.id);
            }
            this.mCollection = undefined;
            this.mInstallDone = true;
            this.triggerUpdate();
        };
        this.mApi = api;
        this.mInfoCache = new InfoCache_1.default(api);
        api.onAsync('will-install-mod', (gameId, archiveId, modId) => {
            const state = api.store.getState();
            const download = state.persistent.downloads.files[archiveId];
            if (download !== undefined) {
                this.mInstallingMod = download.localPath;
            }
            return Promise.resolve();
        });
        api.events.on('did-install-mod', (gameId, archiveId, modId) => {
            var _a, _b, _c, _d;
            const state = api.store.getState();
            const mod = vortex_api_1.util.getSafe(state.persistent.mods, [gameId, modId], undefined);
            const dependent = this.mDependentMods.find(iter => vortex_api_1.util.testModReference(mod, iter.reference));
            if ((mod !== undefined) && (dependent !== undefined)) {
                if (dependent.type === 'requires') {
                    this.mInstalledMods.push(mod);
                }
                if ((((_a = this.mCollection) === null || _a === void 0 ? void 0 : _a.installationPath) !== undefined)
                    && (dependent.reference.description !== undefined)) {
                    if (dependent.type === 'requires') {
                        this.updateProgress(this.mProfile, this.mGameId, this.mCollection);
                    }
                    (0, binaryPatching_1.applyPatches)(api, this.mCollection, gameId, dependent.reference.description, modId, (_b = dependent.extra) === null || _b === void 0 ? void 0 : _b.patches);
                    vortex_api_1.util.batchDispatch(api.store, [
                        vortex_api_1.actions.setFileOverride(gameId, modId, (_c = dependent.extra) === null || _c === void 0 ? void 0 : _c.fileOverrides),
                        vortex_api_1.actions.setModAttribute(gameId, modId, 'patches', (_d = dependent.extra) === null || _d === void 0 ? void 0 : _d.patches),
                        vortex_api_1.actions.setModAttribute(gameId, modId, 'fileList', dependent.fileList),
                    ]);
                }
            }
            this.triggerUpdate();
        });
        api.events.on('did-finish-download', () => {
            this.updateProgress(this.mProfile, this.mGameId, this.mCollection);
        });
        api.events.on('will-install-dependencies', (profileId, modId, recommendations, onCancel) => {
            var _a, _b;
            const state = api.getState();
            const profile = this.profile || vortex_api_1.selectors.profileById(state, profileId);
            const gameId = this.mGameId || (profile === null || profile === void 0 ? void 0 : profile.gameId);
            if (gameId === undefined) {
                return;
            }
            const mods = state.persistent.mods[gameId];
            if ((this.mCollection === undefined)
                && (((_a = mods[modId]) === null || _a === void 0 ? void 0 : _a.type) === constants_1.MOD_TYPE)
                && recommendations) {
                this.mLastCollection = this.mCollection = mods[modId];
                this.mStep = 'installing';
            }
            const isCollectionMod = rule => { var _a; return ((_a = vortex_api_1.util.findModByRef(rule.reference, mods)) === null || _a === void 0 ? void 0 : _a.id) === modId; };
            if ((this.mCollection !== undefined)
                && recommendations
                && ((_b = this.mCollection.rules) !== null && _b !== void 0 ? _b : []).find(isCollectionMod)) {
                onCancel();
            }
        });
        api.events.on('did-install-dependencies', (gameId, modId, recommendations) => {
            this.onDidInstallDependencies(gameId, modId, recommendations);
        });
    }
    async prepare(func) {
        this.mPrepare = this.mPrepare.then(func);
    }
    async query(profile, collection) {
        var _a;
        await this.mPrepare;
        this.mPrepare = Promise.resolve();
        if ((collection === null || collection === void 0 ? void 0 : collection.archiveId) === undefined) {
            return;
        }
        if (!this.mInstallDone && (this.mCollection !== undefined)) {
            this.mApi.sendNotification({
                type: 'warning',
                message: 'Already installing a collection',
            });
            return;
        }
        this.mProfile = profile;
        this.mLastCollection = this.mCollection = collection;
        this.mGameId = (_a = profile === null || profile === void 0 ? void 0 : profile.gameId) !== null && _a !== void 0 ? _a : vortex_api_1.selectors.activeGameId(this.mApi.getState());
        this.mStep = 'query';
        await this.initCollectionInfo();
        this.triggerUpdate();
    }
    async start(profile, collection) {
        var _a;
        await this.mPrepare;
        this.mPrepare = Promise.resolve();
        if ((collection === null || collection === void 0 ? void 0 : collection.archiveId) === undefined) {
            return;
        }
        if (!this.mInstallDone && (this.mCollection !== undefined)) {
            this.mApi.sendNotification({
                type: 'warning',
                message: 'Already installing a collection',
                displayMS: 5000,
            });
            (0, vortex_api_1.log)('warn', 'already installing a collection');
            return;
        }
        this.mProfile = profile;
        this.mLastCollection = this.mCollection = collection;
        this.mGameId = (_a = profile === null || profile === void 0 ? void 0 : profile.gameId) !== null && _a !== void 0 ? _a : vortex_api_1.selectors.activeGameId(this.mApi.getState());
        this.mTotalSize = (0, util_1.calculateCollectionSize)(this.getModsEx(profile, this.mGameId, collection));
        await this.startInstall();
        await this.initCollectionInfo();
        this.triggerUpdate();
    }
    onUpdate(cb) {
        this.mUpdateHandlers.push(cb);
    }
    get profile() {
        return this.mProfile;
    }
    set profile(val) {
        this.mProfile = val;
        if (val !== undefined) {
            this.mGameId = val === null || val === void 0 ? void 0 : val.gameId;
        }
    }
    get infoCache() {
        return this.mInfoCache;
    }
    get step() {
        return this.mStep;
    }
    get installedMods() {
        return this.mInstalledMods;
    }
    get numRequired() {
        return this.requiredMods.length;
    }
    get installingMod() {
        return this.mInstallingMod;
    }
    get collection() {
        return this.mCollection;
    }
    get lastCollection() {
        return this.mLastCollection;
    }
    get collectionId() {
        var _a, _b, _c;
        const state = this.mApi.store.getState();
        const modInfo = (this.mCollection !== undefined)
            ? (_a = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _a === void 0 ? void 0 : _a.modInfo
            : undefined;
        const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
        return ((_b = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.ids) === null || _b === void 0 ? void 0 : _b.collectionId) || ((_c = modInfo === null || modInfo === void 0 ? void 0 : modInfo.ids) === null || _c === void 0 ? void 0 : _c.collectionId);
    }
    get collectionSlug() {
        var _a, _b, _c;
        const state = this.mApi.store.getState();
        const modInfo = (this.mCollection !== undefined)
            ? (_a = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _a === void 0 ? void 0 : _a.modInfo
            : undefined;
        const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
        return ((_b = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.ids) === null || _b === void 0 ? void 0 : _b.collectionSlug) || ((_c = modInfo === null || modInfo === void 0 ? void 0 : modInfo.ids) === null || _c === void 0 ? void 0 : _c.collectionSlug);
    }
    get revisionNumber() {
        var _a, _b, _c;
        const state = this.mApi.store.getState();
        const modInfo = (this.mCollection !== undefined)
            ? (_a = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _a === void 0 ? void 0 : _a.modInfo
            : undefined;
        const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
        return ((_b = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.ids) === null || _b === void 0 ? void 0 : _b.revisionNumber) || ((_c = modInfo === null || modInfo === void 0 ? void 0 : modInfo.ids) === null || _c === void 0 ? void 0 : _c.revisionNumber);
    }
    get revisionId() {
        var _a, _b, _c;
        const state = this.mApi.store.getState();
        const modInfo = (this.mCollection !== undefined)
            ? (_a = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _a === void 0 ? void 0 : _a.modInfo
            : undefined;
        const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
        return ((_b = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.ids) === null || _b === void 0 ? void 0 : _b.revisionId) || ((_c = modInfo === null || modInfo === void 0 ? void 0 : modInfo.ids) === null || _c === void 0 ? void 0 : _c.revisionId);
    }
    get collectionInfo() {
        return this.mCollectionInfo;
    }
    get revisionInfo() {
        return this.mRevisionInfo;
    }
    get installDone() {
        return this.mInstallDone;
    }
    cancel() {
        this.onStop();
        this.triggerUpdate();
    }
    installRecommended() {
        this.mApi.emitAndAwait('install-from-dependencies', this.mCollection.id, this.mCollection.rules, true);
        this.mStep = 'recommendations';
        this.triggerUpdate();
    }
    async continue() {
        var _a, _b;
        if (this.canContinue() && (((_a = this.mCollection) === null || _a === void 0 ? void 0 : _a.archiveId) !== undefined)) {
            await this.initCollectionInfo();
            const steps = {
                query: this.startInstall,
                start: this.begin,
                disclaimer: this.closeDisclaimers,
                installing: this.finishInstalling,
                recommendations: this.finishInstalling,
                review: this.close,
            };
            const res = await ((_b = steps[this.mStep]) === null || _b === void 0 ? void 0 : _b.call(steps));
            if (res !== false) {
                this.triggerUpdate();
            }
        }
    }
    canContinue() {
        if (this.mCollection === undefined) {
            return false;
        }
        if (this.mStep === 'installing') {
            return this.mInstallDone;
        }
        else if (this.mStep === 'disclaimer') {
            return (this.mInstalledMods.length > 0) || this.mInstallDone;
        }
        else {
            return true;
        }
    }
    canClose() {
        return ['start'].indexOf(this.mStep) !== -1;
    }
    canHide() {
        return ['disclaimer', 'installing'].indexOf(this.mStep) !== -1;
    }
    async initCollectionInfo() {
        var _a, _b, _c, _d, _e;
        if (((_a = this.mCollection) === null || _a === void 0 ? void 0 : _a.archiveId) === undefined) {
            return;
        }
        const slug = this.collectionSlug;
        const state = this.mApi.store.getState();
        const modInfo = (_b = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _b === void 0 ? void 0 : _b.modInfo;
        const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
        this.mCollectionInfo = (_d = (_c = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.collectionInfo) !== null && _c !== void 0 ? _c : await this.mInfoCache.getCollectionInfo(slug)) !== null && _d !== void 0 ? _d : (_e = this.mRevisionInfo) === null || _e === void 0 ? void 0 : _e.collection;
    }
    async onDidInstallDependencies(gameId, modId, recommendations) {
        var _a, _b, _c;
        const mods = this.mApi.getState().persistent.mods[gameId];
        if (((_a = mods[modId]) === null || _a === void 0 ? void 0 : _a.type) === constants_1.MOD_TYPE) {
            (0, vortex_api_1.log)('info', 'did install dependencies', { gameId, modId });
        }
        if ((this.mCollection !== undefined) && (modId === this.mCollection.id)) {
            this.mLastCollection = this.mCollection = mods[modId];
            if (this.mCollection !== undefined) {
                if (!recommendations) {
                    const filter = rule => (rule.type === 'requires')
                        && (rule['ignored'] !== true)
                        && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined);
                    const incomplete = ((_b = this.mCollection.rules) !== null && _b !== void 0 ? _b : []).find(filter);
                    if (incomplete === undefined) {
                        await this.initCollectionInfo();
                        this.mStep = 'review';
                    }
                    else {
                        this.mInstallDone = true;
                        this.mInstallingMod = undefined;
                    }
                    this.mApi.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + modId);
                    this.triggerUpdate();
                }
                else {
                    const filter = rule => (['requires', 'recommends'].includes(rule.type))
                        && (rule['ignored'] !== true)
                        && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined);
                    const incomplete = ((_c = this.mCollection.rules) !== null && _c !== void 0 ? _c : []).find(filter);
                    this.mApi.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + modId);
                    if (incomplete === undefined) {
                        await this.initCollectionInfo();
                        this.mStep = 'review';
                    }
                    else {
                        this.onStop();
                    }
                }
            }
        }
        const stagingPath = vortex_api_1.selectors.installPathForGame(this.mApi.getState(), gameId);
        const mod = mods[modId];
        if ((mod !== undefined) && (mod.type === constants_1.MOD_TYPE)) {
            try {
                const collectionInfo = await (0, importCollection_1.readCollection)(this.mApi, path.join(stagingPath, mod.installationPath, 'collection.json'));
                await (0, collectionInstall_1.postprocessCollection)(this.mApi, gameId, mod, collectionInfo, mods);
                this.mApi.events.emit('analytics-track-event-with-payload', 'Collection Installation Completed', {
                    collection_slug: this.collectionSlug,
                    collection_revision_number: this.revisionNumber
                });
            }
            catch (err) {
                (0, vortex_api_1.log)('info', 'Failed to apply mod rules from collection. This is normal if this is the '
                    + 'platform where the collection has been created.');
                this.mDebounce.schedule(undefined, this.collectionSlug, this.revisionNumber);
            }
        }
    }
    onStop() {
        var _a;
        if (this.mCollection !== undefined) {
            this.mApi.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + this.mCollection.id);
        }
        this.mCollection = undefined;
        this.mProfile = undefined;
        this.mGameId = undefined;
        this.mInstalledMods = [];
        this.mStep = 'prepare';
        (_a = this.mOnStop) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    getModsEx(profile, gameId, collection) {
        var _a;
        if (profile === undefined) {
            profile = this.mProfile;
        }
        if (profile === undefined) {
            return {};
        }
        const mods = this.mApi.getState().persistent.mods[gameId];
        if (mods === undefined) {
            (0, vortex_api_1.log)('error', 'no mods for game', { gameId });
            return {};
        }
        return ((_a = collection.rules) !== null && _a !== void 0 ? _a : []).reduce((prev, rule) => {
            if (!['requires', 'recommends'].includes(rule.type)) {
                return prev;
            }
            const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
            prev[(0, util_1.modRuleId)(rule)] = { ...mod, collectionRule: rule };
            return prev;
        }, {});
    }
    matchRepo(rule, ref) {
        var _a, _b;
        if (ref === null) {
            return false;
        }
        const modId = (_a = rule.reference.repo) === null || _a === void 0 ? void 0 : _a.modId;
        const fileId = (_b = rule.reference.repo) === null || _b === void 0 ? void 0 : _b.fileId;
        if ((modId === undefined) || (fileId === undefined)
            || !ref.modId || !ref.fileId) {
            return false;
        }
        return modId.toString() === ref.modId.toString()
            && fileId.toString() === ref.fileId.toString();
    }
    augmentRules(gameId, collection) {
        var _a;
        vortex_api_1.util.batchDispatch(this.mApi.store, ((_a = collection.rules) !== null && _a !== void 0 ? _a : []).map(rule => {
            var _a, _b;
            if (rule.reference.repo === undefined) {
                return undefined;
            }
            const revMod = ((_b = (_a = this.mRevisionInfo) === null || _a === void 0 ? void 0 : _a.modFiles) !== null && _b !== void 0 ? _b : []).find(iter => this.matchRepo(rule, iter.file));
            if ((revMod === null || revMod === void 0 ? void 0 : revMod.file) !== undefined) {
                const newRule = vortex_api_1.util.setSafe(rule, ['extra', 'fileName'], revMod.file.uri);
                return vortex_api_1.actions.addModRule(gameId, collection.id, newRule);
            }
        })
            .filter(rule => rule !== undefined));
    }
    triggerUpdate() {
        this.mUpdateHandlers.forEach(cb => {
            cb();
        });
    }
    installProgress(profile, gameId, collection) {
        const mods = this.getModsEx(profile, gameId, collection);
        const downloads = this.mApi.getState().persistent.downloads.files;
        const downloadProgress = Object.values(mods).reduce((prev, mod) => {
            var _a;
            let size = 0;
            if ((mod.state === 'downloading') || (mod.state === null)) {
                const download = downloads[mod.archiveId];
                size += (download === null || download === void 0 ? void 0 : download.received) || 0;
            }
            else {
                size += ((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.fileSize) || 0;
            }
            return prev + size;
        }, 0);
        const installedMods = Object.values(mods).filter(mod => mod.state === 'installed');
        const totalMods = Object.values(mods).filter(util_1.isRelevant);
        const dlPerc = downloadProgress / this.mTotalSize;
        const instPerc = installedMods.length / totalMods.length;
        return (dlPerc + instPerc) * 50.0;
    }
    updateProgress(profile, gameId, collection) {
        if (collection === undefined) {
            return;
        }
        if (this.mTotalSize === undefined) {
            this.mTotalSize = (0, util_1.calculateCollectionSize)(this.getModsEx(profile, gameId, collection));
        }
        this.mApi.sendNotification({
            id: constants_1.INSTALLING_NOTIFICATION_ID + collection.id,
            type: 'activity',
            title: 'Installing Collection',
            message: vortex_api_1.util.renderModName(collection),
            progress: this.installProgress(profile, gameId, collection),
            actions: [
                {
                    title: 'Show',
                    action: () => {
                        this.mApi.events.emit('view-collection', collection.id);
                    },
                },
            ],
        });
    }
}
exports["default"] = InstallDriver;


/***/ }),

/***/ "./src/util/binaryPatching.ts":
/*!************************************!*\
  !*** ./src/util/binaryPatching.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.applyPatches = exports.scanForDiffs = void 0;
const crc32 = __webpack_require__(/*! crc-32 */ "./node_modules/crc-32/crc32.js");
const path = __webpack_require__(/*! path */ "path");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
const bsdiff = vortex_api_1.util.lazyRequire(() => __webpack_require__(/*! bsdiff-node */ "./node_modules/bsdiff-node/index.js"));
function crcFromBuf(data) {
    return (crc32.buf(data) >>> 0).toString(16).toUpperCase().padStart(8, '0');
}
async function validatePatch(srcFilePath, patchFilePath) {
    const srcStats = await vortex_api_1.fs.statAsync(srcFilePath);
    const patchStats = await vortex_api_1.fs.statAsync(patchFilePath);
    if ((patchStats.size - constants_1.PATCH_OVERHEAD) > (srcStats.size * constants_1.MAX_PATCH_SIZE)) {
        throw new vortex_api_1.util.DataInvalid('patch too large');
    }
}
const queue = vortex_api_1.util.makeQueue();
async function scanForDiffs(api, gameId, modId, destPath, onProgress) {
    var _a;
    const state = api.getState();
    const mod = state.persistent.mods[gameId][modId];
    const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
    const localPath = path.join(stagingPath, mod.installationPath);
    const archive = state.persistent.downloads.files[mod.archiveId];
    if (archive === undefined) {
        throw new vortex_api_1.util.ProcessCanceled('Archive not found');
    }
    const choices = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.installerChoices;
    return queue(() => new Promise((resolve, reject) => {
        api.events.emit('simulate-installer', gameId, mod.archiveId, { choices }, async (instRes, tempPath) => {
            try {
                const dlPath = vortex_api_1.selectors.downloadPathForGame(state, archive.game[0]);
                const archivePath = path.join(dlPath, archive.localPath);
                const sourceChecksums = {};
                const szip = new vortex_api_1.util.SevenZip();
                await szip.list(archivePath, undefined, async (entries) => {
                    for (const entry of entries) {
                        if (entry.attr !== 'D') {
                            try {
                                sourceChecksums[entry.name] = entry['crc'].toUpperCase();
                            }
                            catch (err) {
                                api.showErrorNotification('Failed to determine checksum for file', err, {
                                    message: entry.name,
                                });
                            }
                        }
                    }
                });
                const result = {};
                for (const file of instRes.instructions.filter(instr => instr.type === 'copy')) {
                    const srcCRC = sourceChecksums[file.source];
                    const dstFilePath = path.join(localPath, file.destination);
                    const dat = await vortex_api_1.fs.readFileAsync(dstFilePath);
                    const dstCRC = crcFromBuf(dat);
                    if (srcCRC !== dstCRC) {
                        onProgress(undefined, api.translate('Creating patch for {{fileName}}', { replace: {
                                fileName: path.basename(file.source),
                            } }));
                        (0, vortex_api_1.log)('debug', 'found modified file', { filePath: file.source, srcCRC, dstCRC });
                        const srcFilePath = path.join(tempPath, file.source);
                        const patchPath = path.join(destPath, file.destination + '.diff');
                        await vortex_api_1.fs.ensureDirWritableAsync(path.dirname(patchPath));
                        await bsdiff.diff(srcFilePath, dstFilePath, patchPath, progress => {
                        });
                        try {
                            await validatePatch(srcFilePath, patchPath);
                            result[file.destination] = srcCRC;
                        }
                        catch (err) {
                            await vortex_api_1.fs.removeAsync(patchPath);
                            const res = await api.showDialog('error', 'Can\'t save local edits', {
                                text: 'The local modifications to file "{{fileName}}" can not be included in '
                                    + 'the collection.\n'
                                    + 'We don\'t allow edits that exceed a certain percentage '
                                    + 'of the original file size.\n'
                                    + 'If you continue anyway this file will be installed unmodified for users.',
                                parameters: {
                                    fileName: file.source,
                                },
                            }, [
                                { label: 'Cancel' },
                                { label: 'Continue' },
                            ]);
                            if (res.action === 'Cancel') {
                                err['mayIgnore'] = false;
                                throw err;
                            }
                        }
                        (0, vortex_api_1.log)('debug', 'patch created at', patchPath);
                    }
                }
                resolve(result);
            }
            catch (err) {
                reject(err);
            }
        });
    }), false);
}
exports.scanForDiffs = scanForDiffs;
async function applyPatches(api, collection, gameId, modName, modId, patches) {
    const state = api.getState();
    const installPath = vortex_api_1.selectors.installPathForGame(state, gameId);
    const mod = state.persistent.mods[gameId][modId];
    const modPath = path.join(installPath, mod.installationPath);
    const patchesPath = path.join(installPath, collection.installationPath, constants_1.PATCHES_PATH, modName);
    for (const filePath of Object.keys(patches !== null && patches !== void 0 ? patches : {})) {
        try {
            const srcPath = path.join(modPath, filePath);
            const diffPath = path.join(patchesPath, filePath) + '.diff';
            await vortex_api_1.fs.statAsync(diffPath);
            const srcDat = await vortex_api_1.fs.readFileAsync(srcPath);
            const srcCRC = crcFromBuf(srcDat);
            if (srcCRC === patches[filePath]) {
                await bsdiff.patch(srcPath, srcPath + '.patched', diffPath);
                await vortex_api_1.fs.removeAsync(srcPath);
                await vortex_api_1.fs.renameAsync(srcPath + '.patched', srcPath);
                (0, vortex_api_1.log)('info', 'patched', srcPath);
            }
            else {
                (0, vortex_api_1.log)('warn', 'patch not applied because reference CRC differs', { filePath, srcCRC });
            }
        }
        catch (err) {
            err['Collection'] = vortex_api_1.util.renderModName(collection);
            api.showErrorNotification('failed to patch', err, {
                message: filePath,
            });
        }
    }
}
exports.applyPatches = applyPatches;


/***/ }),

/***/ "./src/util/checksumMatcher.ts":
/*!*************************************!*\
  !*** ./src/util/checksumMatcher.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.matchChecksums = void 0;
const crc32 = __webpack_require__(/*! crc-32 */ "./node_modules/crc-32/crc32.js");
const path = __webpack_require__(/*! path */ "path");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const errors_1 = __webpack_require__(/*! ../util/errors */ "./src/util/errors.ts");
async function matchChecksums(api, gameId, modId) {
    const state = api.getState();
    const mod = state.persistent.mods[gameId][modId];
    if (!(mod === null || mod === void 0 ? void 0 : mod.archiveId)) {
        throw new vortex_api_1.util.ProcessCanceled('Mod not found');
    }
    const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
    const localPath = path.join(stagingPath, mod.installationPath);
    const archive = state.persistent.downloads.files[mod.archiveId];
    if (archive === undefined) {
        throw new vortex_api_1.util.ProcessCanceled('Archive not found');
    }
    const dlPath = vortex_api_1.selectors.downloadPathForGame(state, archive.game[0]);
    const archivePath = path.join(dlPath, archive.localPath);
    const sourceChecksums = new Set();
    const szip = new vortex_api_1.util.SevenZip();
    await szip.list(archivePath, undefined, async (entries) => {
        for (const entry of entries) {
            if (entry.attr !== 'D') {
                try {
                    if (!!entry['crc']) {
                        sourceChecksums.add(entry['crc'].toUpperCase());
                    }
                }
                catch (err) {
                    api.showErrorNotification('Failed to determine checksum for file', err, {
                        message: entry.name,
                    });
                }
            }
        }
    });
    let entries = [];
    await vortex_api_1.util.walk(localPath, async (input) => {
        entries = [].concat(entries, input);
    }, {});
    const localChecksums = new Set();
    const computeCRC32Stream = (filePath) => {
        return new Promise((resolve, reject) => {
            const stream = vortex_api_1.fs.createReadStream(filePath);
            let crc = 0;
            stream.on('data', (chunk) => {
                crc = crc32.buf(chunk, crc);
            });
            stream.on('end', () => {
                resolve((crc >>> 0).toString(16).toUpperCase().padStart(8, '0'));
            });
            stream.on('error', (err) => {
                reject(err);
            });
        });
    };
    for (const entry of entries) {
        const isDirectory = (await vortex_api_1.fs.statAsync(entry)).isDirectory();
        if (isDirectory) {
            continue;
        }
        const crc = await computeCRC32Stream(entry);
        localChecksums.add(crc);
    }
    const missingChecksums = [];
    for (const crc of localChecksums) {
        if (!sourceChecksums.has(crc)) {
            missingChecksums.push(crc);
        }
    }
    if (missingChecksums.length > 0) {
        throw new errors_1.ReplicateHashMismatchError();
    }
}
exports.matchChecksums = matchChecksums;


/***/ }),

/***/ "./src/util/collectionConfig/index.ts":
/*!********************************************!*\
  !*** ./src/util/collectionConfig/index.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseConfig = exports.generateConfig = void 0;
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const configDefaults = {
    recommendNewProfile: false,
};
async function generateConfig(props) {
    const { collectionMod } = props;
    const config = vortex_api_1.util.getSafe(collectionMod, ['attributes', 'collection', 'collectionConfig'], configDefaults);
    return {
        ...config,
    };
}
exports.generateConfig = generateConfig;
async function parseConfig(props) {
    const { collection } = props;
    const config = vortex_api_1.util.getSafe(collection, ['collectionConfig'], configDefaults);
    return config;
}
exports.parseConfig = parseConfig;


/***/ }),

/***/ "./src/util/defaults.ts":
/*!******************************!*\
  !*** ./src/util/defaults.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.genDefaultsAction = void 0;
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function applyDefaultInstallMode(prev, mod) {
    var _a, _b, _c;
    if (((_a = prev === null || prev === void 0 ? void 0 : prev.installMode) === null || _a === void 0 ? void 0 : _a[mod.id]) === undefined) {
        const { installerChoices } = (_b = mod === null || mod === void 0 ? void 0 : mod.attributes) !== null && _b !== void 0 ? _b : {};
        if (((installerChoices === null || installerChoices === void 0 ? void 0 : installerChoices.type) === 'fomod') && (((_c = installerChoices === null || installerChoices === void 0 ? void 0 : installerChoices.options) === null || _c === void 0 ? void 0 : _c.length) > 0)) {
            prev = vortex_api_1.util.setSafe(prev, ['installMode', mod.id], 'choices');
        }
    }
    return prev;
}
function applyDefaultSource(prev, mod) {
    var _a, _b, _c;
    if (((_a = prev === null || prev === void 0 ? void 0 : prev.source) === null || _a === void 0 ? void 0 : _a[mod.id]) === undefined) {
        if (((_b = mod === null || mod === void 0 ? void 0 : mod.attributes) === null || _b === void 0 ? void 0 : _b.source) === 'website') {
            prev = vortex_api_1.util.setSafe(prev, ['source', mod.id], {
                type: 'browse',
                url: (_c = mod === null || mod === void 0 ? void 0 : mod.attributes) === null || _c === void 0 ? void 0 : _c.url,
            });
        }
    }
    return prev;
}
function genDefaultsAction(api, collectionId, mods, gameId) {
    if (mods.length === 0) {
        return undefined;
    }
    const state = api.getState();
    const collection = vortex_api_1.util.getSafe(state, ['persistent', 'mods', gameId, collectionId], undefined);
    if (collection === undefined) {
        const error = new vortex_api_1.util.ProcessCanceled('Unable to find collection mod', { collectionId: collection.id });
        api.showErrorNotification('Failed to ascertain default install mode', error);
        return undefined;
    }
    const attr = vortex_api_1.util.getSafe(collection.attributes, ['collection'], {});
    const resAttr = mods.reduce((prev, mod) => {
        prev = applyDefaultInstallMode(prev, mod);
        prev = applyDefaultSource(prev, mod);
        return prev;
    }, attr);
    return vortex_api_1.actions.setModAttribute(gameId, collection.id, 'collection', resAttr);
}
exports.genDefaultsAction = genDefaultsAction;


/***/ }),

/***/ "./src/util/errors.ts":
/*!****************************!*\
  !*** ./src/util/errors.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReplicateHashMismatchError = void 0;
class ReplicateHashMismatchError extends Error {
    constructor() {
        super('Replicate install mode can only work if the checksums of the installed files match those in the archive. Please try to reinstall the mod or use binary patching instead.');
        this.mayIgnore = false;
        this.name = 'ReplicateHashMismatchError';
        this.mayIgnore = false;
    }
}
exports.ReplicateHashMismatchError = ReplicateHashMismatchError;


/***/ }),

/***/ "./src/util/extension.ts":
/*!*******************************!*\
  !*** ./src/util/extension.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findExtensions = exports.addExtension = void 0;
const features = [];
function addExtension(feature) {
    features.push(feature);
}
exports.addExtension = addExtension;
function findExtensions(state, gameId) {
    return features.filter(iter => (iter.condition === undefined) || iter.condition(state, gameId));
}
exports.findExtensions = findExtensions;


/***/ }),

/***/ "./src/util/findModByRef.ts":
/*!**********************************!*\
  !*** ./src/util/findModByRef.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.testDownloadReference = void 0;
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function testDownloadReference(download, reference) {
    if (download === undefined) {
        return false;
    }
    return vortex_api_1.util.testModReference(vortex_api_1.util.lookupFromDownload(download), reference);
}
exports.testDownloadReference = testDownloadReference;


/***/ }),

/***/ "./src/util/gameSupport/gamebryo.tsx":
/*!*******************************************!*\
  !*** ./src/util/gameSupport/gamebryo.tsx ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Interface = exports.PluginRule = exports.parser = exports.generate = void 0;
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function getEnabledPlugins(state, plugins) {
    const gamebryoLO = state['loadOrder'];
    return plugins.map(pluginName => ({
        ...gamebryoLO[pluginName.toLowerCase()],
        name: pluginName,
    }))
        .filter(lo => (lo !== undefined) && (lo.name !== undefined) && (lo.enabled === true))
        .sort((lhs, rhs) => lhs.loadOrder - rhs.loadOrder)
        .map(lo => ({ name: lo.name, enabled: lo.enabled }));
}
function extractPluginRules(state, plugins) {
    const installedPlugins = new Set(plugins.map(name => name.toLowerCase()));
    const customisedPlugins = state['userlist'].plugins.filter((plug) => installedPlugins.has(plug.name.toLowerCase())
        && ((plug.after !== undefined) || (plug.group !== undefined)));
    return {
        plugins: customisedPlugins,
        groups: state['userlist'].groups,
    };
}
async function getIncludedPlugins(gameId, stagingPath, mods, modIds) {
    const extensions = ['fallout4', 'skyrimse'].includes(gameId)
        ? new Set(['.esp', '.esm', '.esl'])
        : new Set(['.esp', '.esm']);
    const includedPlugins = [];
    await Promise.all(modIds.map(async (modId) => {
        if (mods[modId] !== undefined) {
            try {
                const files = await vortex_api_1.fs.readdirAsync(path.join(stagingPath, mods[modId].installationPath));
                const plugins = files.filter(fileName => extensions.has(path.extname(fileName).toLowerCase()));
                includedPlugins.push(...plugins);
            }
            catch (err) {
                (0, vortex_api_1.log)('warn', 'failed to read plugins included in mod', err.message);
            }
        }
    }));
    return includedPlugins;
}
async function generate(state, gameId, stagingPath, modIds, mods) {
    const includedPlugins = await getIncludedPlugins(gameId, stagingPath, mods, modIds);
    return {
        plugins: getEnabledPlugins(state, includedPlugins),
        pluginRules: extractPluginRules(state, includedPlugins),
    };
}
exports.generate = generate;
function toLootType(type) {
    switch (type) {
        case 'requires': return 'req';
        case 'incompatible': return 'inc';
        default: return 'after';
    }
}
function refName(iter) {
    if (typeof (iter) === 'string') {
        return iter;
    }
    else {
        return iter.name;
    }
}
async function parser(api, gameId, collection, collectionMod) {
    var _a, _b, _c;
    const state = api.getState();
    if (state.userlist === undefined) {
        return;
    }
    const mods = state.persistent.mods[gameId];
    vortex_api_1.util.batchDispatch(api.store, ((_a = collection.pluginRules.groups) !== null && _a !== void 0 ? _a : []).reduce((prev, group) => {
        if (state.userlist.groups[group.name] === undefined) {
            prev.push({
                type: 'ADD_PLUGIN_GROUP', payload: {
                    group: group.name,
                },
            });
        }
        group.after.forEach(after => {
            prev.push({
                type: 'ADD_GROUP_RULE', payload: {
                    groupId: group.name,
                    reference: after,
                },
            });
        });
        return prev;
    }, []));
    const collectionModIds = collectionMod.rules
        .filter(rule => ['requires', 'recommends'].includes(rule.type))
        .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
        .filter(mod => !!mod)
        .map(mod => mod.id);
    const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
    const includedPlugins = await getIncludedPlugins(gameId, stagingPath, mods, collectionModIds);
    const isEnabled = (pluginName) => collection.plugins.find(plugin => ((plugin.name === pluginName) && (plugin.enabled))) !== undefined;
    vortex_api_1.util.batchDispatch(api.store, includedPlugins.map(plugin => {
        return {
            type: 'SET_PLUGIN_ENABLED', payload: {
                pluginName: plugin,
                enabled: isEnabled(plugin),
            }
        };
    }));
    state.session.notifications.notifications
        .filter(noti => noti.id.startsWith('multiple-plugins-'))
        .forEach(noti => api.dismissNotification(noti.id));
    vortex_api_1.util.batchDispatch(api.store, ((_c = (_b = collection.pluginRules) === null || _b === void 0 ? void 0 : _b.plugins) !== null && _c !== void 0 ? _c : []).reduce((prev, plugin) => {
        const existing = state.userlist.plugins.find(plug => plug.name.toUpperCase() === plugin.name.toUpperCase());
        if ((plugin.group !== undefined) && ((existing === null || existing === void 0 ? void 0 : existing.group) === undefined)) {
            prev.push({
                type: 'SET_PLUGIN_GROUP',
                payload: {
                    pluginId: plugin.name.toLowerCase(),
                    group: plugin.group,
                },
            });
        }
        ['requires', 'incompatible', 'after'].forEach(type => {
            const lootType = toLootType(type);
            (plugin[type] || []).forEach(ref => {
                const match = iter => refName(iter).toUpperCase() === ref.toUpperCase();
                if (vortex_api_1.util.getSafe(existing, [lootType], []).find(match) === undefined) {
                    prev.push({
                        type: 'ADD_USERLIST_RULE',
                        payload: {
                            pluginId: plugin.name.toLowerCase(),
                            reference: ref,
                            type,
                        },
                    });
                }
            });
        });
        return prev;
    }, []));
}
exports.parser = parser;
function ruleName(rule) {
    var _a;
    if (typeof (rule) === 'string') {
        return rule;
    }
    else {
        return (_a = rule.display) !== null && _a !== void 0 ? _a : rule.name;
    }
}
function ruleId(rule) {
    if (typeof (rule) === 'string') {
        return rule.toLowerCase();
    }
    else {
        return rule.name.toLowerCase();
    }
}
function ruleType(t, type) {
    switch (type) {
        case 'after': return t('after');
        case 'requires': return t('requires');
        case 'incompatible': return t('incompatible with');
        default: return '???';
    }
}
function renderRefName(rule) {
    return typeof (rule.ref) === 'string'
        ? rule.ref
        : rule.ref.display;
}
function renderType(t, type) {
    if (type === 'assigned') {
        return t('assigned to group');
    }
    else {
        return t(type);
    }
}
function PluginRule(props) {
    const { t, onRemove, rule } = props;
    const remove = React.useCallback((evt) => {
        onRemove(rule);
    }, [rule]);
    return (React.createElement(react_bootstrap_1.ListGroupItem, null,
        React.createElement("div", { className: 'rule-name' },
            rule.isGroup ? t('Group') + ' ' : '',
            rule.name),
        React.createElement("div", { className: 'rule-type' }, renderType(t, rule.type)),
        React.createElement("div", { className: 'rule-name' }, renderRefName(rule)),
        React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed remove-btn', icon: 'remove', tooltip: t('Remove plugin rule'), onClick: remove })));
}
exports.PluginRule = PluginRule;
function Interface(props) {
    var _a;
    const { t, collection } = props;
    const [pluginRules, setPluginRules] = React.useState(null);
    const [groupAssignments, setGroupAssignments] = React.useState(null);
    const store = (0, react_redux_1.useStore)();
    const gameId = (0, react_redux_1.useSelector)(vortex_api_1.selectors.activeGameId);
    const mods = (0, react_redux_1.useSelector)((selState) => selState.persistent.mods[gameId]);
    const userlist = (0, react_redux_1.useSelector)((selState) => selState.userlist);
    const state = store.getState();
    React.useEffect(() => {
        const modIds = collection.rules
            .map(rule => rule.reference.id)
            .filter(modId => modId !== undefined);
        const stagingPath = vortex_api_1.selectors.installPath(state);
        getIncludedPlugins(gameId, stagingPath, mods, modIds)
            .then(plugins => {
            var _a, _b, _c, _d;
            const pluginsL = plugins.map(plug => plug.toLowerCase());
            const rules = [];
            const assignments = {};
            for (const plugin of plugins) {
                const plug = ((_a = userlist === null || userlist === void 0 ? void 0 : userlist.plugins) !== null && _a !== void 0 ? _a : [])
                    .find(iter => iter.name.toLowerCase() === plugin.toLowerCase());
                const byRef = (name) => pluginsL.includes(ruleId(name));
                const toRule = (ref, type) => ({
                    name: plugin,
                    ref,
                    type,
                });
                if (plug !== undefined) {
                    rules.push(...((_b = plug.after) !== null && _b !== void 0 ? _b : []).filter(byRef).map(aft => toRule(aft, 'after')));
                    rules.push(...((_c = plug.req) !== null && _c !== void 0 ? _c : []).filter(byRef).map(req => toRule(req, 'requires')));
                    rules.push(...((_d = plug.inc) !== null && _d !== void 0 ? _d : []).filter(byRef).map(inc => toRule(inc, 'incompatible')));
                    if (plug.group !== undefined) {
                        assignments[plug.name] = plug.group;
                    }
                }
            }
            setPluginRules(rules);
            setGroupAssignments(assignments);
        });
    }, [collection, mods, userlist, setPluginRules]);
    const removeRule = React.useCallback((rule) => {
        store.dispatch({ type: 'REMOVE_USERLIST_RULE', payload: {
                pluginId: rule.name.toLowerCase(), reference: rule.ref, type: rule.type,
            } });
    }, [store]);
    const removeGroupRule = React.useCallback((rule) => {
        store.dispatch({ type: 'REMOVE_GROUP_RULE', payload: {
                groupId: rule.name.toLowerCase(), reference: rule.ref,
            } });
    }, [store]);
    const unassignGroup = React.useCallback((rule) => {
        store.dispatch({ type: 'SET_PLUGIN_GROUP', payload: {
                pluginId: rule.name.toLowerCase(), group: undefined,
            } });
    }, [store]);
    if (userlist === undefined) {
        return (React.createElement(react_bootstrap_1.Panel, null, t('No userlist loaded, is the gamebryo-plugin-management extension disabled?')));
    }
    const grpsFlattened = ((_a = userlist === null || userlist === void 0 ? void 0 : userlist.groups) !== null && _a !== void 0 ? _a : []).reduce((prev, grp) => {
        var _a;
        ((_a = grp.after) !== null && _a !== void 0 ? _a : []).forEach(aft => {
            prev.push({ name: grp.name, ref: aft, type: 'after' });
        });
        return prev;
    }, []);
    return (React.createElement("div", { className: 'collection-rules-edit collection-scrollable' },
        React.createElement(react_bootstrap_1.ControlLabel, null,
            React.createElement("p", null,
                t('The collection will include your custom load order rules so that '
                    + 'users of your collection will get the same load order.'),
                React.createElement("br", null),
                t('Rules you remove here are also removed from your actual setup.'))),
        (pluginRules !== null) ? (React.createElement(react_bootstrap_1.ListGroup, null, pluginRules.map(rule => (React.createElement(PluginRule, { t: t, key: `${rule.name}_after_${rule.ref}`, rule: rule, onRemove: removeRule }))))) : React.createElement(vortex_api_1.Spinner, null),
        (groupAssignments !== null) ? (React.createElement(react_bootstrap_1.ListGroup, null, Object.keys(groupAssignments).map(pluginName => (React.createElement(PluginRule, { t: t, key: `${pluginName}_assigned_${groupAssignments[pluginName]}`, rule: { name: pluginName, type: 'assigned', ref: groupAssignments[pluginName] }, onRemove: unassignGroup }))))) : React.createElement(vortex_api_1.Spinner, null),
        React.createElement(react_bootstrap_1.ListGroup, null, (grpsFlattened.map(grp => (React.createElement(PluginRule, { t: t, key: `${grp.name}_after_${grp.ref}`, rule: grp, onRemove: removeGroupRule })))))));
}
exports.Interface = Interface;


/***/ }),

/***/ "./src/util/gameSupport/index.ts":
/*!***************************************!*\
  !*** ./src/util/gameSupport/index.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getInterface = exports.parseGameSpecifics = exports.generateGameSpecifics = void 0;
const gamebryo = __webpack_require__(/*! ./gamebryo */ "./src/util/gameSupport/gamebryo.tsx");
const gameSupport = {
    skyrim: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    skyrimse: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    skyrimvr: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    fallout3: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    fallout4: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    fallout4vr: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    falloutnv: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    starfield: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    oblivion: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    enderal: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    enderalspecialedition: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
};
function generateGameSpecifics(state, gameId, stagingPath, modIds, mods) {
    if ((gameSupport[gameId] !== undefined) && (gameSupport[gameId].generator !== undefined)) {
        return gameSupport[gameId].generator(state, gameId, stagingPath, modIds, mods);
    }
    else {
        return Promise.resolve({});
    }
}
exports.generateGameSpecifics = generateGameSpecifics;
function parseGameSpecifics(api, gameId, collection, collectionMod) {
    if ((gameSupport[gameId] !== undefined) && (gameSupport[gameId].parser !== undefined)) {
        return gameSupport[gameId].parser(api, gameId, collection, collectionMod);
    }
    else {
        return Promise.resolve();
    }
}
exports.parseGameSpecifics = parseGameSpecifics;
function getInterface(gameId) {
    if (gameSupport[gameId] === undefined) {
        return null;
    }
    else {
        return gameSupport[gameId].interface;
    }
}
exports.getInterface = getInterface;


/***/ }),

/***/ "./src/util/importCollection.ts":
/*!**************************************!*\
  !*** ./src/util/importCollection.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readCollection = void 0;
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const validation_1 = __webpack_require__(/*! ../validationCode/validation */ "./src/validationCode/validation.ts");
function isFuzzyVersion(input) {
    if (!input) {
        return false;
    }
    return input.endsWith('+prefer') || (input === '*');
}
function postProcessRule(rule) {
    const result = JSON.parse(JSON.stringify(rule));
    if (isFuzzyVersion(result.reference.versionMatch)
        && !!result.reference.logicalFileName) {
        delete result.reference.fileExpression;
    }
    if (isFuzzyVersion(result.source.versionMatch)
        && !!result.source.logicalFileName) {
        delete result.source.fileExpression;
    }
    return result;
}
function validationMessage(msg) {
    return `${(msg.instancePath || '/')} ${msg.message}`;
}
async function readCollection(api, manifest) {
    var _a;
    const collectionData = await vortex_api_1.fs.readFileAsync(manifest, { encoding: 'utf-8' });
    const collection = JSON.parse(collectionData);
    const readErrors = (0, validation_1.validateICollection)(collection);
    if (readErrors.length > 0) {
        api.showErrorNotification('Collection validation mismatch', 'There was a validation issue with this collection. '
            + 'During the testing phase, this is likely caused by the checks being too strict and '
            + 'the collection itself should still work correctly.\n'
            + 'To help us improve the validation, please report this error once on each '
            + 'collection it appears for.\n\n'
            + readErrors.map(validationMessage).join('\n'));
    }
    collection.modRules = ((_a = collection.modRules) !== null && _a !== void 0 ? _a : []).map(rule => postProcessRule(rule));
    return collection;
}
exports.readCollection = readCollection;


/***/ }),

/***/ "./src/util/transformCollection.ts":
/*!*****************************************!*\
  !*** ./src/util/transformCollection.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createCollectionFromProfile = exports.showQuickCollectionRestrictionsDialog = exports.validateName = exports.createCollection = exports.cloneCollection = exports.makeCollectionId = exports.modToCollection = exports.collectionModToRule = exports.makeBiDirRule = exports.generateCollection = void 0;
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
const binaryPatching_1 = __webpack_require__(/*! ./binaryPatching */ "./src/util/binaryPatching.ts");
const extension_1 = __webpack_require__(/*! ./extension */ "./src/util/extension.ts");
const gameSupport_1 = __webpack_require__(/*! ./gameSupport */ "./src/util/gameSupport/index.ts");
const collectionConfig_1 = __webpack_require__(/*! ./collectionConfig */ "./src/util/collectionConfig/index.ts");
const util_1 = __webpack_require__(/*! ./util */ "./src/util/util.ts");
const _ = __webpack_require__(/*! lodash */ "lodash");
const path = __webpack_require__(/*! path */ "path");
const shortid_1 = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
const turbowalk_1 = __webpack_require__(/*! turbowalk */ "turbowalk");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const util_2 = __webpack_require__(/*! ./util */ "./src/util/util.ts");
const checksumMatcher_1 = __webpack_require__(/*! ./checksumMatcher */ "./src/util/checksumMatcher.ts");
const initweaks_1 = __webpack_require__(/*! ../initweaks */ "./src/initweaks.ts");
const errors_1 = __webpack_require__(/*! ./errors */ "./src/util/errors.ts");
function sanitizeExpression(fileName) {
    return path.basename(fileName, path.extname(fileName))
        .replace(/\.\d+$/, '')
        .replace(/ \(\d+\)$/, '');
}
function toInt(input) {
    if (!input) {
        return 0;
    }
    if (typeof (input) === 'string') {
        return parseInt(input, 10);
    }
    return input;
}
function deduceSource(mod, sourceInfo, versionMatcher, metaInfo, tag) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const res = (sourceInfo !== undefined)
        ? { ...sourceInfo }
        : { type: 'nexus' };
    const assign = (obj, key, value) => {
        if (obj[key] === undefined) {
            obj[key] = value;
        }
    };
    if (res.type === 'nexus') {
        if (((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.source) !== 'nexus') {
            throw new Error(`"${vortex_api_1.util.renderModName(mod)}" doesn't have Nexus as its source`);
        }
        const modId = (mod.type === constants_1.MOD_TYPE) ? (_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.collectionId : (_c = mod.attributes) === null || _c === void 0 ? void 0 : _c.modId;
        const fileId = (mod.type === constants_1.MOD_TYPE) ? (_d = mod.attributes) === null || _d === void 0 ? void 0 : _d.revisionId : (_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.fileId;
        if (!modId || !fileId || isNaN(modId) || isNaN(fileId)) {
            throw new Error(`"${mod.id}" is missing mod id or file id`);
        }
        res.modId = toInt(modId);
        res.fileId = toInt(fileId);
    }
    else {
        assign(res, 'adultContent', sourceInfo === null || sourceInfo === void 0 ? void 0 : sourceInfo.adultContent);
    }
    if (['browse', 'direct'].includes(res.type) && !res.url) {
        throw new Error(`"${mod.id}" has no URL set`);
    }
    if ((sourceInfo === null || sourceInfo === void 0 ? void 0 : sourceInfo.type) !== 'bundle') {
        assign(res, 'md5', (_f = mod.attributes) === null || _f === void 0 ? void 0 : _f.fileMD5);
    }
    assign(res, 'fileSize', (_g = mod.attributes) === null || _g === void 0 ? void 0 : _g.fileSize);
    assign(res, 'logicalFilename', (_k = (_j = (_h = metaInfo === null || metaInfo === void 0 ? void 0 : metaInfo[0]) === null || _h === void 0 ? void 0 : _h.value) === null || _j === void 0 ? void 0 : _j.logicalFileName) !== null && _k !== void 0 ? _k : (_l = mod.attributes) === null || _l === void 0 ? void 0 : _l.logicalFileName);
    if ((sourceInfo === null || sourceInfo === void 0 ? void 0 : sourceInfo.updatePolicy) !== undefined) {
        assign(res, 'updatePolicy', sourceInfo.updatePolicy);
    }
    else if ((sourceInfo === null || sourceInfo === void 0 ? void 0 : sourceInfo.type) === 'bundle') {
        assign(res, 'updatePolicy', 'exact');
    }
    else {
        if (versionMatcher === '*') {
            assign(res, 'updatePolicy', 'latest');
        }
        else if ((versionMatcher === undefined)
            || versionMatcher.endsWith('+prefer')) {
            assign(res, 'updatePolicy', 'prefer');
        }
        else {
            assign(res, 'updatePolicy', 'exact');
        }
    }
    if ((res.md5 === undefined)
        && (res.logicalFilename === undefined)
        && (res.fileExpression === undefined)
        && (((_m = mod.attributes) === null || _m === void 0 ? void 0 : _m.fileName) !== undefined)) {
        assign(res, 'fileExpression', sanitizeExpression(mod.attributes.fileName));
    }
    assign(res, 'tag', tag);
    return res;
}
function generateCollection(info, mods, modRules) {
    return {
        info,
        mods,
        modRules,
    };
}
exports.generateCollection = generateCollection;
async function rulesToCollectionMods(api, collection, resolvedRules, mods, stagingPath, game, collectionInfo, bundleTags, onProgress, onError) {
    var _a;
    let total = resolvedRules.length;
    let finished = 0;
    const collectionPath = path.join(stagingPath, collection.installationPath);
    await vortex_api_1.fs.removeAsync(path.join(collectionPath, constants_1.BUNDLED_PATH));
    await vortex_api_1.fs.removeAsync(path.join(collectionPath, constants_1.PATCHES_PATH));
    await vortex_api_1.fs.ensureDirAsync(path.join(collectionPath, constants_1.BUNDLED_PATH));
    await vortex_api_1.fs.ensureDirAsync(path.join(collectionPath, constants_1.PATCHES_PATH));
    const state = api.getState();
    const downloads = state.persistent.downloads.files;
    const downloadPath = vortex_api_1.selectors.downloadPathForGame(state, game.id);
    const fileOverridesIds = new Set(Object.keys((_a = collectionInfo.fileOverrides) !== null && _a !== void 0 ? _a : {})
        .filter(modId => collectionInfo.fileOverrides[modId]));
    const result = await Promise.all(resolvedRules.map(async (resolvedRule) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
        const { mod, rule } = resolvedRule;
        const fileName = (_a = downloads[mod.archiveId]) === null || _a === void 0 ? void 0 : _a.localPath;
        const refMD5 = (((_c = (_b = collectionInfo.source) === null || _b === void 0 ? void 0 : _b[mod.id]) === null || _c === void 0 ? void 0 : _c.type) === 'bundle')
            ? undefined
            : (_d = mod.attributes) === null || _d === void 0 ? void 0 : _d.fileMD5;
        const meta = await api.lookupModMeta({
            fileName,
            filePath: fileName !== undefined ? path.join(downloadPath, fileName) : undefined,
            fileMD5: refMD5,
            fileSize: (_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.fileSize,
            gameId: game.id,
        });
        const modName = vortex_api_1.util.renderModName(mod, { version: false });
        try {
            const source = deduceSource(mod, (_f = collectionInfo.source) === null || _f === void 0 ? void 0 : _f[mod.id], rule.reference.versionMatch, meta, bundleTags[mod.id]);
            let hashes;
            let choices;
            let entries = [];
            const installMode = (_h = (_g = collectionInfo.installMode) === null || _g === void 0 ? void 0 : _g[mod.id]) !== null && _h !== void 0 ? _h : 'fresh';
            const modPath = path.join(stagingPath, mod.installationPath);
            if (installMode === 'clone') {
                await (0, checksumMatcher_1.matchChecksums)(api, game.id, mod.id);
                await (0, turbowalk_1.default)(modPath, async (input) => {
                    entries = [].concat(entries, input);
                }, {});
                hashes = await Promise.all(entries
                    .filter(iter => !iter.isDirectory)
                    .map(async (iter) => ({
                    path: path.relative(modPath, iter.filePath),
                    md5: await (0, util_2.fileMD5Async)(iter.filePath),
                })));
                onProgress(undefined, modName);
                ++finished;
            }
            else if (installMode === 'choices') {
                choices = (_j = mod === null || mod === void 0 ? void 0 : mod.attributes) === null || _j === void 0 ? void 0 : _j.installerChoices;
                --total;
            }
            else {
                --total;
            }
            let patches;
            if (((_k = collectionInfo.saveEdits) === null || _k === void 0 ? void 0 : _k[mod.id]) === true) {
                const destPath = path.join(collectionPath, constants_1.PATCHES_PATH, modName);
                await vortex_api_1.fs.ensureDirWritableAsync(destPath);
                patches = await (0, binaryPatching_1.scanForDiffs)(api, game.id, mod.id, destPath, onProgress);
            }
            if (((_m = (_l = collectionInfo.source) === null || _l === void 0 ? void 0 : _l[mod.id]) === null || _m === void 0 ? void 0 : _m.type) === 'bundle') {
                const tlFiles = await vortex_api_1.fs.readdirAsync(modPath);
                const generatedName = `Bundled - ${vortex_api_1.util.sanitizeFilename(vortex_api_1.util.renderModName(mod, { version: true }))}`;
                const destPath = path.join(collectionPath, constants_1.BUNDLED_PATH, generatedName);
                try {
                    await vortex_api_1.fs.removeAsync(destPath);
                }
                catch (err) {
                    if (err.code !== 'ENOENT') {
                        throw err;
                    }
                }
                await Promise.all(tlFiles.map(async (name) => {
                    await vortex_api_1.fs.copyAsync(path.join(modPath, name), path.join(destPath, name));
                }));
                source.fileExpression = generatedName;
                let totalSize = 0;
                await (0, turbowalk_1.default)(destPath, items => totalSize += items.reduce((sub, entry) => sub + entry.size, 0));
                source.fileSize = totalSize;
            }
            onProgress(Math.floor((finished / total) * 100), modName);
            const dlGame = (((_o = mod.attributes) === null || _o === void 0 ? void 0 : _o.downloadGame) !== undefined)
                ? vortex_api_1.util.getGame(mod.attributes.downloadGame)
                : game;
            const domainName = (dlGame !== undefined)
                ? vortex_api_1.util.nexusGameId(dlGame) : (_p = mod.attributes) === null || _p === void 0 ? void 0 : _p.downloadGame;
            const res = {
                name: modName,
                version: (_r = (_q = mod.attributes) === null || _q === void 0 ? void 0 : _q.version) !== null && _r !== void 0 ? _r : '1.0.0',
                optional: rule.type === 'recommends',
                domainName,
                source,
                hashes,
                choices,
                patches,
                instructions: !!((_s = collectionInfo.instructions) === null || _s === void 0 ? void 0 : _s[mod.id])
                    ? (_t = collectionInfo.instructions) === null || _t === void 0 ? void 0 : _t[mod.id]
                    : undefined,
                author: (_u = mod.attributes) === null || _u === void 0 ? void 0 : _u.author,
                details: {
                    category: vortex_api_1.util.resolveCategoryName((_v = mod.attributes) === null || _v === void 0 ? void 0 : _v.category, state),
                    type: mod.type,
                },
                phase: (_x = (_w = rule.extra) === null || _w === void 0 ? void 0 : _w['phase']) !== null && _x !== void 0 ? _x : 0,
                fileOverrides: fileOverridesIds.has(mod.id) ? mod.fileOverrides : undefined,
            };
            return res;
        }
        catch (err) {
            --total;
            onError('failed to pack "{{modName}}": {{error}}', {
                modName, error: err.message, stack: err.stack,
            }, (_y = err['mayIgnore']) !== null && _y !== void 0 ? _y : true);
            if (err instanceof errors_1.ReplicateHashMismatchError) {
                api.showDialog('error', 'Collection export failed', {
                    bbcode: '"{{modName}}" cannot be exported using the replicate install mode.[br][/br][br][/br]The hashes of '
                        + 'the below files in your staging folder do not match the hashes of the files in the mod\'s '
                        + 'archive, which is guaranteed to cause issues for the end user.[br][/br][br][/br] Please consider using '
                        + 'binary patching or bundle your changes instead.',
                    parameters: {
                        modName: vortex_api_1.util.renderModName(mod),
                    },
                    message: err.affectedFiles.map(file => vortex_api_1.util.sanitizeFilename(file)).join('\n'),
                    options: {
                        order: ['bbcode', 'message'],
                    }
                }, [
                    {
                        label: 'Close',
                    },
                ], 'replicate-hash-mismatch-error-dialog');
            }
            return undefined;
        }
    }));
    return result.filter(mod => (mod !== undefined) && (Object.keys(mod.source).length > 0));
}
function makeBiDirRule(source, rule) {
    if (rule === undefined) {
        return undefined;
    }
    return {
        type: rule.type,
        reference: rule.reference,
        source,
    };
}
exports.makeBiDirRule = makeBiDirRule;
function makeTransferrable(mods, collection, rule) {
    let newRef = { ...rule.reference };
    const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
    if ((rule.reference.fileMD5 === undefined)
        && (rule.reference.logicalFileName === undefined)
        && (rule.reference.fileExpression === undefined)) {
        if (rule.reference.id === undefined) {
            (0, vortex_api_1.log)('warn', 'invalid rule couldn\'t be included in the collection', JSON.stringify(rule));
            return undefined;
        }
        if (mod === undefined) {
            (0, vortex_api_1.log)('warn', 'mod enabled in collection isn\'t installed', JSON.stringify(rule));
            return undefined;
        }
        newRef = vortex_api_1.util.makeModReference(mod);
    }
    if (mod !== undefined) {
        const mpRule = collection.rules.find(iter => vortex_api_1.util.testModReference(mod, iter.reference));
        if ((mpRule !== undefined) && ((mpRule.reference.versionMatch === undefined)
            || (mpRule.reference.versionMatch === '*')
            || (mpRule.reference.versionMatch.startsWith('>=')))) {
            newRef.versionMatch = '*';
        }
    }
    return {
        type: rule.type,
        fileList: rule.fileList,
        comment: rule.comment,
        reference: newRef,
    };
}
function ruleEnabled(rule, mods, collection) {
    var _a, _b, _c, _d;
    if (rule === undefined) {
        return false;
    }
    const ruleEx = {
        ...rule,
        sourceName: (0, util_1.renderReference)(rule.source, mods),
        referenceName: (0, util_1.renderReference)(rule.reference, mods),
    };
    const id = (0, util_1.ruleId)(ruleEx);
    return (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.rule) === null || _c === void 0 ? void 0 : _c[id]) !== null && _d !== void 0 ? _d : true;
}
function extractModRules(collectionRules, collection, mods, collectionAttributes, bundleTags) {
    return collectionRules.reduce((prev, resolvedRule) => {
        var _a, _b;
        const { mod } = resolvedRule;
        const source = vortex_api_1.util.makeModReference(mod);
        const sourceOrig = JSON.parse(JSON.stringify(source));
        const mpRule = collection.rules.find(iter => vortex_api_1.util.testModReference(mod, iter.reference));
        if ((mpRule !== undefined) && ((mpRule.reference.versionMatch === undefined)
            || (mpRule.reference.versionMatch === '*')
            || (mpRule.reference.versionMatch.startsWith('>=')))) {
            source.versionMatch = '*';
        }
        if (((_b = (_a = collectionAttributes.source) === null || _a === void 0 ? void 0 : _a[mod.id]) === null || _b === void 0 ? void 0 : _b.type) === 'bundle') {
            source.fileMD5 = undefined;
            source.tag = bundleTags[mod.id];
        }
        const includedRules = (mod.rules || [])
            .filter(rule => !['requires', 'recommends'].includes(rule.type));
        return [].concat(prev, includedRules.map((input) => {
            var _a, _b, _c, _d;
            if (((_a = input.extra) === null || _a === void 0 ? void 0 : _a['automatic']) === true) {
                return undefined;
            }
            const target = JSON.parse(JSON.stringify(input));
            const targetRef = vortex_api_1.util.findModByRef(target.reference, mods);
            const targetId = (_b = targetRef === null || targetRef === void 0 ? void 0 : targetRef.id) !== null && _b !== void 0 ? _b : target.reference.idHint;
            const targetRule = makeTransferrable(mods, collection, target);
            if (((_d = (_c = collectionAttributes.source) === null || _c === void 0 ? void 0 : _c[targetId]) === null || _d === void 0 ? void 0 : _d.type) === 'bundle') {
                target.reference.fileMD5 = undefined;
                if (targetRule !== undefined) {
                    targetRule.reference.tag = bundleTags[targetId];
                }
            }
            if ((targetRule === undefined)
                || !ruleEnabled(makeBiDirRule(sourceOrig, targetRule), mods, collection)) {
                return undefined;
            }
            return makeBiDirRule(source, targetRule);
        }));
    }, [])
        .filter(rule => rule !== undefined);
}
function collectionModToRule(knownGames, mod) {
    var _a, _b, _c, _d;
    const downloadHint = ['manual', 'browse', 'direct'].includes(mod.source.type)
        ? {
            url: mod.source.url,
            instructions: mod.source.instructions,
            mode: mod.source.type,
        }
        : undefined;
    const coerced = vortex_api_1.util.coerceToSemver(mod.version);
    let versionMatch = !!coerced
        ? `>=${coerced !== null && coerced !== void 0 ? coerced : '0.0.0'}+prefer`
        : vortex_api_1.util.coerceToSemver(mod.version);
    const { updatePolicy } = mod.source;
    if ((updatePolicy === 'exact')
        || (mod.source.type === 'bundle')
        || (mod.hashes !== undefined)) {
        versionMatch = !!coerced ? coerced : vortex_api_1.util.coerceToSemver(mod.version);
    }
    else if (updatePolicy === 'latest') {
        versionMatch = '*';
    }
    const refMD5 = (mod.source.type === 'bundle')
        ? undefined
        : mod.source.md5;
    const fileExpression = (updatePolicy === 'exact') || (mod.source.logicalFilename === undefined)
        ? mod.source.fileExpression
        : undefined;
    const reference = {
        description: mod.name,
        fileMD5: refMD5,
        gameId: vortex_api_1.util.convertGameIdReverse(knownGames, mod.domainName),
        fileSize: mod.source.fileSize,
        versionMatch,
        logicalFileName: mod.source.logicalFilename,
        fileExpression,
        tag: (_a = mod.source.tag) !== null && _a !== void 0 ? _a : (0, shortid_1.generate)(),
    };
    if (['latest', 'prefer'].includes(updatePolicy)) {
        reference['md5Hint'] = mod.source.md5;
    }
    if (mod.source.type === 'nexus') {
        if (!mod.source.modId || !mod.source.fileId) {
            const err = new Error('Invalid nexus repo specification');
            err['mod'] = mod;
            throw err;
        }
        reference['repo'] = {
            repository: 'nexus',
            gameId: mod.domainName,
            modId: mod.source.modId.toString(),
            fileId: mod.source.fileId.toString(),
            campaign: 'collection',
        };
    }
    const res = {
        type: mod.optional ? 'recommends' : 'requires',
        reference,
        fileList: mod.hashes,
        installerChoices: mod.choices,
        downloadHint,
        extra: {
            author: mod.author,
            type: (_b = mod.details) === null || _b === void 0 ? void 0 : _b.type,
            category: (_c = mod.details) === null || _c === void 0 ? void 0 : _c.category,
            version: mod.version,
            url: mod.source.url,
            name: mod.name,
            instructions: !!mod.instructions
                ? mod.instructions
                : undefined,
            phase: (_d = mod.phase) !== null && _d !== void 0 ? _d : 0,
            patches: mod.patches,
            fileOverrides: mod.fileOverrides,
        },
    };
    if (mod.source.type === 'bundle') {
        res.extra.localPath = path.join('bundled', mod.source.fileExpression);
    }
    return res;
}
exports.collectionModToRule = collectionModToRule;
async function modToCollection(api, gameId, stagingPath, collection, mods, onProgress, onError) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const state = api.getState();
    if (vortex_api_1.selectors.activeGameId(state) !== gameId) {
        return Promise.reject(new Error('Can only export collection for the active profile'));
    }
    const includedMods = collection.rules
        .map(rule => {
        let id = rule.reference.id;
        if (id === undefined) {
            const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
            if (mod !== undefined) {
                id = mod.id;
            }
        }
        return id;
    })
        .filter(id => id !== undefined);
    const missing = includedMods.find(modId => mods[modId] === undefined);
    if (missing !== undefined) {
        return Promise.reject(new Error('Can only export collections that are fully installed'));
    }
    const exts = (0, extension_1.findExtensions)(state, gameId);
    const extData = {};
    for (const ext of exts) {
        Object.assign(extData, await ext.generate(gameId, includedMods, collection));
    }
    const gameSpecific = await (0, gameSupport_1.generateGameSpecifics)(state, gameId, stagingPath, includedMods, mods);
    const game = vortex_api_1.util.getGame(gameId);
    const discovery = vortex_api_1.selectors.discoveryByGame(state, gameId);
    const gameVersions = (game !== undefined)
        ? [await game.getInstalledVersion(discovery)]
        : [];
    const collectionAttributes = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) !== null && _b !== void 0 ? _b : {};
    const collectionConfig = await (0, collectionConfig_1.generateConfig)({ gameId, collectionMod: collection });
    const collectionInfo = {
        author: (_d = (_c = collection.attributes) === null || _c === void 0 ? void 0 : _c.uploader) !== null && _d !== void 0 ? _d : 'Anonymous',
        authorUrl: (_f = (_e = collection.attributes) === null || _e === void 0 ? void 0 : _e.authorURL) !== null && _f !== void 0 ? _f : '',
        name: vortex_api_1.util.renderModName(collection),
        description: (_h = (_g = collection.attributes) === null || _g === void 0 ? void 0 : _g.shortDescription) !== null && _h !== void 0 ? _h : '',
        installInstructions: (_j = collectionAttributes.installInstructions) !== null && _j !== void 0 ? _j : '',
        domainName: vortex_api_1.util.nexusGameId(game),
        gameVersions,
    };
    const bundleTags = includedMods.reduce((prev, modId) => {
        prev[modId] = (0, shortid_1.generate)();
        return prev;
    }, {});
    const resolvedRules = collection.rules.reduce((prev, rule) => {
        const mod = (rule.reference.id !== undefined)
            ? mods[rule.reference.id]
            : vortex_api_1.util.findModByRef(rule.reference, mods);
        if (mod === undefined) {
            onError('Not packaging mod that isn\'t installed: "{{id}}"', { id: rule.reference.id }, true);
        }
        else if (mod.type === constants_1.MOD_TYPE) {
        }
        else {
            prev.push({ mod, rule });
        }
        return prev;
    }, []);
    const modRules = extractModRules(resolvedRules, collection, mods, collectionAttributes, bundleTags);
    const res = {
        info: collectionInfo,
        mods: await rulesToCollectionMods(api, collection, resolvedRules, mods, stagingPath, game, collectionAttributes, bundleTags, onProgress, onError),
        modRules,
        ...extData,
        ...gameSpecific,
        collectionConfig: { ...collectionConfig },
    };
    return res;
}
exports.modToCollection = modToCollection;
async function createTweaksFromProfile(api, profile, mods, existingId) {
    var _a;
    return (0, initweaks_1.importTweaks)(api, profile, api.getState().persistent.mods[profile.gameId], (_a = api.getState().persistent.mods[profile.gameId]) === null || _a === void 0 ? void 0 : _a[existingId]);
}
function createRulesFromProfile(profile, mods, existingRules, existingId, filterFunc, isQuickCollection) {
    var _a;
    return Object.keys((_a = profile.modState) !== null && _a !== void 0 ? _a : {})
        .filter(modId => {
        var _a, _b;
        return ((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[modId]) === null || _b === void 0 ? void 0 : _b.enabled)
            && (mods[modId] !== undefined)
            && (modId !== existingId)
            && (mods[modId].type !== constants_1.MOD_TYPE)
            && filterFunc(mods[modId]);
    })
        .map(modId => {
        let versionMatch;
        const oldRule = existingRules
            .find(iter => vortex_api_1.util.testModReference(mods[modId], iter.reference));
        if ((oldRule !== undefined) && (oldRule.reference.versionMatch !== undefined)) {
            versionMatch = (oldRule.reference.versionMatch === '*')
                ? '*'
                : mods[modId].attributes.version;
        }
        if (isQuickCollection) {
            versionMatch = mods[modId].attributes.version;
        }
        return {
            type: 'requires',
            reference: {
                id: modId,
                archiveId: mods[modId].archiveId,
                versionMatch,
            },
        };
    });
}
function makeCollectionId(baseId) {
    return `vortex_collection_${baseId}`;
}
exports.makeCollectionId = makeCollectionId;
function deduceCollectionAttributes(collectionMod, collection, mods) {
    var _a;
    const res = {
        installMode: {},
        instructions: {},
        source: {},
        saveEdits: {},
    };
    ((_a = collectionMod.rules) !== null && _a !== void 0 ? _a : []).forEach(rule => {
        var _a, _b, _c, _d, _e, _f, _g;
        const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
        if (mod === undefined) {
            return;
        }
        res.installMode[mod.id] = (rule.installerChoices !== undefined)
            ? 'choices'
            : (rule.fileList !== undefined)
                ? 'clone'
                : 'fresh';
        res.instructions[mod.id] = (_a = rule.extra) === null || _a === void 0 ? void 0 : _a.instructions;
        res.source[mod.id] = {
            type: (_c = (_b = rule.downloadHint) === null || _b === void 0 ? void 0 : _b.mode) !== null && _c !== void 0 ? _c : ((((_d = rule.reference.repo) === null || _d === void 0 ? void 0 : _d.repository) === 'nexus') ? 'nexus' : 'bundle'),
            url: (_e = rule.downloadHint) === null || _e === void 0 ? void 0 : _e.url,
            instructions: (_f = rule.downloadHint) === null || _f === void 0 ? void 0 : _f.instructions,
        };
        res.saveEdits[mod.id] = ((_g = rule.extra) === null || _g === void 0 ? void 0 : _g.patches) !== undefined;
    });
    return res;
}
async function cloneCollection(api, gameId, id, sourceId) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const state = api.getState();
    const t = api.translate;
    const { userInfo } = (_a = state.persistent['nexus']) !== null && _a !== void 0 ? _a : {};
    const mods = ((_b = state.persistent.mods[gameId]) !== null && _b !== void 0 ? _b : {});
    const existingCollection = mods[sourceId];
    const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
    let collection;
    try {
        const collectionData = await vortex_api_1.fs.readFileAsync(path.join(stagingPath, existingCollection.installationPath, 'collection.json'), { encoding: 'utf-8' });
        collection = JSON.parse(collectionData);
    }
    catch (err) {
        api.showErrorNotification('Failed to clone collection', err);
        return undefined;
    }
    const ruleFilter = (rule) => {
        if (rule.ignored) {
            return false;
        }
        if (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined) {
            return false;
        }
        return true;
    };
    const ruleSimplify = (rule) => {
        const referencedMod = vortex_api_1.util.findModByRef(rule.reference, mods);
        return ({
            ...rule,
            reference: {
                archiveId: referencedMod.archiveId,
                id: referencedMod.id,
                idHint: referencedMod.id,
                versionMatch: rule.reference.versionMatch,
            },
        });
    };
    const ownCollection = ((_c = existingCollection.attributes) === null || _c === void 0 ? void 0 : _c.uploaderId) === (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId);
    let name = 'Copy of ' + ((_d = existingCollection.attributes) === null || _d === void 0 ? void 0 : _d.name);
    if (name.length > constants_1.MAX_COLLECTION_NAME_LENGTH) {
        name = name.slice(0, constants_1.MAX_COLLECTION_NAME_LENGTH) + '...';
    }
    const customFileName = ownCollection
        ? (_e = existingCollection.attributes) === null || _e === void 0 ? void 0 : _e.customFileName
        : t('Copy of {{name}}', { replace: { name: (_f = existingCollection.attributes) === null || _f === void 0 ? void 0 : _f.customFileName } });
    const ownCollectionAttributes = ownCollection ? ({
        pictureUrl: existingCollection.attributes.pictureUrl,
        uploader: userInfo.name,
        uploaderAvatar: existingCollection.attributes.uploaderAvatar,
    }) : {};
    const mod = {
        id,
        type: constants_1.MOD_TYPE,
        state: 'installed',
        attributes: {
            name,
            customFileName,
            version: ownCollection ? (_g = existingCollection.attributes) === null || _g === void 0 ? void 0 : _g.version : '0',
            installTime: new Date(),
            author: (_h = userInfo === null || userInfo === void 0 ? void 0 : userInfo.name) !== null && _h !== void 0 ? _h : 'Anonymous',
            uploader: (_j = userInfo === null || userInfo === void 0 ? void 0 : userInfo.name) !== null && _j !== void 0 ? _j : 'Anonymous',
            uploaderId: userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId,
            editable: true,
            collectionId: ownCollection ? (_k = existingCollection.attributes) === null || _k === void 0 ? void 0 : _k.collectionId : undefined,
            revisionId: ownCollection ? (_l = existingCollection.attributes) === null || _l === void 0 ? void 0 : _l.revisionId : undefined,
            collectionSlug: ownCollection ? (_m = existingCollection.attributes) === null || _m === void 0 ? void 0 : _m.collectionSlug : undefined,
            revisionNumber: ownCollection
                ? (((_o = existingCollection.attributes) === null || _o === void 0 ? void 0 : _o.revisionNumber) + 1) : undefined,
            collection: deduceCollectionAttributes(existingCollection, collection, mods),
            ...ownCollectionAttributes,
        },
        installationPath: id,
        rules: existingCollection.rules
            .filter(ruleFilter)
            .map(ruleSimplify),
    };
    try {
        await new Promise((resolve, reject) => {
            api.events.emit('create-mod', gameId, mod, (error) => {
                if (error !== null) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
        const deployPath = vortex_api_1.selectors.installPathForGame(state, gameId);
        const sourcePath = path.join(deployPath, sourceId);
        const clonePath = path.join(deployPath, id);
        const files = await vortex_api_1.fs.readdirAsync(sourcePath);
        for (const file of files) {
            await vortex_api_1.fs.copyAsync(path.join(sourcePath, file), path.join(clonePath, file));
        }
        const exts = (0, extension_1.findExtensions)(api.getState(), gameId);
        for (const ext of exts) {
            if (ext.clone !== undefined) {
                await ext.clone(gameId, collection, existingCollection, mod);
            }
        }
        return id;
    }
    catch (err) {
        api.showErrorNotification('Failed to clone collection', err);
        return undefined;
    }
}
exports.cloneCollection = cloneCollection;
async function createCollection(api, gameId, id, name, rules) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const state = api.store.getState();
    const mod = {
        id,
        type: constants_1.MOD_TYPE,
        state: 'installed',
        attributes: {
            name,
            version: '0',
            installTime: new Date(),
            author: (_c = (_b = (_a = state.persistent['nexus']) === null || _a === void 0 ? void 0 : _a.userInfo) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : 'Anonymous',
            uploader: (_f = (_e = (_d = state.persistent['nexus']) === null || _d === void 0 ? void 0 : _d.userInfo) === null || _e === void 0 ? void 0 : _e.name) !== null && _f !== void 0 ? _f : 'Anonymous',
            uploaderId: (_h = (_g = state.persistent['nexus']) === null || _g === void 0 ? void 0 : _g.userInfo) === null || _h === void 0 ? void 0 : _h.user_id,
            editable: true,
            source: 'user-generated',
            recommendNewProfile: false,
        },
        installationPath: id,
        rules,
    };
    try {
        await new Promise((resolve, reject) => {
            api.events.emit('create-mod', gameId, mod, (error) => {
                if (error !== null) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    catch (err) {
        api.showErrorNotification('Failed to create collection', err);
    }
}
exports.createCollection = createCollection;
function updateCollection(api, gameId, mod, newRules) {
    var _a;
    api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, mod.id, 'editable', true));
    const removedRules = [];
    vortex_api_1.util.batchDispatch(api.store, ((_a = mod.rules) !== null && _a !== void 0 ? _a : []).reduce((prev, rule) => {
        if (newRules.find(iter => _.isEqual(rule, iter)) === undefined) {
            removedRules.push(rule);
            prev.push(vortex_api_1.actions.removeModRule(gameId, mod.id, rule));
        }
        return prev;
    }, []));
    vortex_api_1.util.batchDispatch(api.store, newRules.reduce((prev, rule) => {
        var _a;
        if (((_a = mod.rules) !== null && _a !== void 0 ? _a : []).find(iter => _.isEqual(rule, iter)) === undefined) {
            prev.push(vortex_api_1.actions.addModRule(gameId, mod.id, rule));
        }
        return prev;
    }, []));
}
function validateName(t, content) {
    const input = content.input[0].value || '';
    if ((input.length >= constants_1.MIN_COLLECTION_NAME_LENGTH)
        && (input.length <= constants_1.MAX_COLLECTION_NAME_LENGTH)) {
        return [];
    }
    else {
        return [{
                id: 'name',
                errorText: t('Name must be between {{min}}-{{max}} characters long', {
                    replace: {
                        min: constants_1.MIN_COLLECTION_NAME_LENGTH,
                        max: constants_1.MAX_COLLECTION_NAME_LENGTH,
                    },
                }),
                actions: ['Create'],
            }];
    }
}
exports.validateName = validateName;
async function showQuickCollectionRestrictionsDialog(api) {
    var _a;
    const t = api.translate;
    const state = api.store.getState();
    const profileId = (_a = vortex_api_1.selectors.activeProfile(state)) === null || _a === void 0 ? void 0 : _a.id;
    if (!profileId) {
        return;
    }
    const restrictionsDialog = await api.showDialog('info', 'Quick Collection', {
        bbcode: t('Quick Collections create a backup of your mod list for easy import by another PC or mod manager. '
            + 'They can be created in a few clicks but do not include all the features of a "full" collection.[br][/br][br][/br]'
            + 'Your Quick Collection will include:[br][/br]'
            + '[list]'
            + '[*] All mods downloaded from Nexus Mods that are currently enabled and deployed.'
            + '[*] Installer choices for mods that support installers (such as FOMODs).'
            + '[*] File conflict rules.'
            + '[*] Load order rules.'
            + '[/list][br][/br]'
            + 'Quick Collections do NOT include:[br][/br]'
            + '[list]'
            + '[*] Mods from sources other than Nexus Mods.'
            + '[*] Alterations you have made mods after installing them.'
            + '[*] Outputs of automated tools generated on your PC (FNIS, Script Merger, etc).'
            + '[*] Mods that you have created on your PC and added to Vortex.'
            + '[/list][br][/br]'
            + 'If you are using this feature migrate your mod list to the Nexus Mods app, see the '
            + `[url=https://nexus-mods.github.io/NexusMods.App/users/gettingstarted/MovingToTheApp/]full guide here.[/url]`),
    }, [
        { label: 'Cancel' },
        { label: 'Proceed' },
    ]);
    return (restrictionsDialog.action === 'Cancel')
        ? Promise.reject(new vortex_api_1.util.UserCanceled())
        : Promise.resolve();
}
exports.showQuickCollectionRestrictionsDialog = showQuickCollectionRestrictionsDialog;
async function createCollectionFromProfile(api, profileId, forceName) {
    var _a, _b, _c, _d, _e;
    const state = api.store.getState();
    const profile = state.persistent.profiles[profileId];
    const isQuickCollection = forceName !== undefined;
    const id = (isQuickCollection)
        ? makeCollectionId(`${profileId}_${(0, shortid_1.generate)()}`)
        : makeCollectionId(profileId);
    const mod = (_a = state.persistent.mods[profile.gameId]) === null || _a === void 0 ? void 0 : _a[id];
    const isNexusSourced = (m) => { var _a; return (((_a = m === null || m === void 0 ? void 0 : m.attributes) === null || _a === void 0 ? void 0 : _a.source) === 'nexus'); };
    const isGeneratedMod = (m) => { var _a; return (((_a = m === null || m === void 0 ? void 0 : m.attributes) === null || _a === void 0 ? void 0 : _a.generated) === true); };
    const filterFunc = (m) => forceName ? (isNexusSourced(m) && !isGeneratedMod(m)) : true;
    const rules = createRulesFromProfile(profile, (_b = state.persistent.mods[profile.gameId]) !== null && _b !== void 0 ? _b : {}, (_c = mod === null || mod === void 0 ? void 0 : mod.rules) !== null && _c !== void 0 ? _c : [], mod === null || mod === void 0 ? void 0 : mod.id, filterFunc, isQuickCollection);
    let name = forceName !== null && forceName !== void 0 ? forceName : profile.name;
    const uploadLabel = 'Create and Upload';
    let wantsToUpload = false;
    if (mod === undefined) {
        const t = api.translate;
        const result = await api.showDialog('question', 'New collection from profile', {
            text: 'Create a collection containing the mods enabled in your current profile.',
            input: [{
                    id: 'name',
                    label: 'Please enter a name for your new collection',
                    type: 'text',
                    value: name,
                }],
            condition: content => validateName(t, content),
        }, [
            { label: 'Cancel' },
            { label: forceName ? uploadLabel : 'Create', default: true },
        ]);
        const cancelled = result.action === 'Cancel';
        if (cancelled) {
            throw new vortex_api_1.util.UserCanceled();
        }
        wantsToUpload = result.action === uploadLabel;
        name = result.input['name'];
        await createCollection(api, profile.gameId, id, name, rules);
        await createTweaksFromProfile(api, profile, (_d = state.persistent.mods[profile.gameId]) !== null && _d !== void 0 ? _d : {}, id);
    }
    else {
        name = (_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.name;
        updateCollection(api, profile.gameId, mod, rules);
    }
    return { id, name, updated: mod !== undefined, wantsToUpload };
}
exports.createCollectionFromProfile = createCollectionFromProfile;


/***/ }),

/***/ "./src/util/util.ts":
/*!**************************!*\
  !*** ./src/util/util.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uploadCollection = exports.isEmpty = exports.walkPath = exports.fileMD5Async = exports.calculateCollectionSize = exports.isRelevant = exports.modRuleId = exports.ruleId = exports.renderReference = exports.md5sum = exports.getUnfulfilledNotificationId = exports.bbProm = exports.makeProgressFunction = void 0;
const PromiseBB = __webpack_require__(/*! bluebird */ "bluebird");
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const collectionExport_1 = __webpack_require__(/*! ../collectionExport */ "./src/collectionExport.ts");
const vortexmt_1 = __webpack_require__(/*! vortexmt */ "vortexmt");
const turbowalk_1 = __webpack_require__(/*! turbowalk */ "turbowalk");
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
function makeProgressFunction(api) {
    const notificationId = api.sendNotification({
        type: 'activity',
        title: 'Building Collection',
        message: '',
        progress: 0,
    });
    let notiPerc = 0;
    let notiText = '';
    const items = new Set();
    const progress = (percent, text) => {
        let change = false;
        if ((percent !== undefined)) {
            if (percent > notiPerc) {
                change = true;
                notiPerc = percent;
            }
            if (text !== undefined) {
                items.delete(text);
                if (items.size > 0) {
                    const itemList = Array.from(items);
                    const newText = itemList[itemList.length - 1];
                    if (newText !== notiText) {
                        change = true;
                        notiText = newText;
                    }
                }
            }
        }
        if ((percent === undefined) && (text !== undefined) && (text !== notiText)) {
            change = true;
            notiText = text;
            if (percent === undefined) {
                items.add(text);
            }
        }
        if (change) {
            api.sendNotification({
                id: notificationId,
                type: 'activity',
                title: 'Building Collection',
                progress: notiPerc,
                message: notiText,
            });
        }
    };
    const progressEnd = () => {
        api.dismissNotification(notificationId);
    };
    return { progress, progressEnd };
}
exports.makeProgressFunction = makeProgressFunction;
function bbProm(func) {
    return (...args) => PromiseBB.resolve(func(...args));
}
exports.bbProm = bbProm;
function getUnfulfilledNotificationId(collectionId) {
    return `collection-incomplete-${collectionId}`;
}
exports.getUnfulfilledNotificationId = getUnfulfilledNotificationId;
function md5sum(input) {
    const hash = (0, crypto_1.createHash)('md5');
    hash.update(input);
    return hash.digest('hex');
}
exports.md5sum = md5sum;
function renderReference(ref, mods) {
    const mod = vortex_api_1.util.findModByRef(ref, mods);
    return vortex_api_1.util.renderModReference(ref, mod);
}
exports.renderReference = renderReference;
function ruleId(rule) {
    return md5sum(`${rule.sourceName}-${rule.type}-${rule.referenceName}`);
}
exports.ruleId = ruleId;
function modRuleId(input) {
    return input.type + '_' + (input.reference.fileMD5
        || input.reference.id
        || input.reference.logicalFileName
        || input.reference.fileExpression
        || input.reference.description);
}
exports.modRuleId = modRuleId;
function isRelevant(mod) {
    if (!!mod.state) {
        return true;
    }
    if (mod.collectionRule['ignored']) {
        return false;
    }
    if (mod.collectionRule.type !== 'requires') {
        return false;
    }
    return true;
}
exports.isRelevant = isRelevant;
function calculateCollectionSize(mods) {
    return Object.values(mods).reduce((prev, mod) => {
        var _a, _b, _c;
        if (!isRelevant(mod)) {
            return prev;
        }
        const size = (_c = (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.fileSize) !== null && _b !== void 0 ? _b : mod.collectionRule.reference.fileSize) !== null && _c !== void 0 ? _c : 0;
        return prev + size;
    }, 0);
}
exports.calculateCollectionSize = calculateCollectionSize;
async function fileMD5Async(fileName) {
    return new Promise((resolve, reject) => {
        (0, vortexmt_1.fileMD5)(fileName, (err, result) => (err !== null) ? reject(err) : resolve(result), () => null);
    });
}
exports.fileMD5Async = fileMD5Async;
async function walkPath(dirPath, walkOptions) {
    walkOptions = walkOptions || { skipLinks: true, skipHidden: true, skipInaccessible: true };
    const walkResults = [];
    return new Promise(async (resolve, reject) => {
        await (0, turbowalk_1.default)(dirPath, async (entries) => {
            for (const entry of entries) {
                const md5 = await fileMD5Async(entry.filePath);
                const extendedEntry = { ...entry, fileMD5: md5 };
                walkResults.push(extendedEntry);
            }
            return Promise.resolve();
        }, walkOptions).catch(err => err.code === 'ENOENT' ? Promise.resolve() : Promise.reject(err));
        return resolve(walkResults);
    });
}
exports.walkPath = walkPath;
function isEmpty(value) {
    return (!value)
        || (value.hasOwnProperty('length') && value.length === 0)
        || (value.constructor === Object && Object.keys(value).length === 0);
}
exports.isEmpty = isEmpty;
async function uploadCollection(api, profileId, collectionId) {
    var _a, _b;
    if (!profileId || !collectionId) {
        return;
    }
    const state = api.getState();
    const profile = vortex_api_1.selectors.profileById(state, profileId);
    const userInfo = vortex_api_1.util.getSafe(state, ['persistent', 'nexus', 'userInfo'], undefined);
    if (userInfo === undefined) {
        api.showErrorNotification('Not logged in', 'You have to be logged into nexusmods.com to upload collections.');
        return;
    }
    const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', profile.gameId], {});
    if (mods[collectionId] === undefined) {
        return;
    }
    api.events.emit('analytics-track-click-event', 'Collections', 'Upload collection');
    const missing = ((_b = (_a = mods[collectionId]) === null || _a === void 0 ? void 0 : _a.rules) !== null && _b !== void 0 ? _b : []).filter(rule => ['requires', 'recommends'].includes(rule.type)
        && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined));
    if (missing.length > 0) {
        await api.showDialog('error', 'Collection isn\'t fully installed', {
            text: 'You can only upload collections that are fully installed on this system.\n'
                + 'If you have removed mods that were part of this collection you may want to remove '
                + 'them from the collection as well. If this collection is connected to a '
                + 'profile you can simply update from that.',
            message: missing.map(rule => vortex_api_1.util.renderModReference(rule.reference)).join('\n'),
        }, [
            { label: 'Close' },
        ]);
        return;
    }
    const choice = await api.showDialog('question', 'Share on Nexus Mods', {
        bbcode: 'You are about to upload "{{collectionName}}" to Nexus Mods in a draft state. '
            + 'You will be able to add additional metadata and media before sharing it with '
            + 'the community.'
            + '\n\n'
            + 'Please ensure that your collection complies with our '
            + `[url=${constants_1.TOS_URL}]Collections Guidelines[/url] before publishing.`,
        parameters: {
            collectionName: vortex_api_1.util.renderModName(mods[collectionId]),
        },
    }, [
        { label: 'Cancel' },
        { label: 'Upload' },
    ]);
    if (choice.action === 'Upload') {
        try {
            const { slug, revisionNumber } = await (0, collectionExport_1.doExportToAPI)(api, profile.gameId, collectionId, userInfo.name);
            if ((slug !== undefined) && (revisionNumber !== undefined)) {
                api.sendNotification({
                    type: 'success',
                    message: 'Collection submitted',
                    actions: [
                        {
                            title: 'Open in Browser', action: () => {
                                const game = vortex_api_1.selectors.gameById(api.getState(), profile.gameId);
                                const domainName = vortex_api_1.util.nexusGameId(game);
                                const url = vortex_api_1.util.nexusModsURL([domainName, 'collections', slug, 'revisions', revisionNumber.toString()], {
                                    campaign: vortex_api_1.util.Campaign.ViewCollection,
                                    section: vortex_api_1.util.Section.Collections,
                                });
                                vortex_api_1.util.opn(url).catch(() => null);
                            },
                        },
                    ],
                });
            }
        }
        catch (err) {
            if (!(err instanceof vortex_api_1.util.UserCanceled)
                && !(err instanceof vortex_api_1.util.ProcessCanceled)) {
                api.showErrorNotification('Failed to upload to API', err, {
                    allowReport: false,
                });
            }
        }
    }
}
exports.uploadCollection = uploadCollection;


/***/ }),

/***/ "./src/validationCode/ICollection.validate.js":
/*!****************************************************!*\
  !*** ./src/validationCode/ICollection.validate.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = validate10;module.exports["default"] = validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","anyOf":[{"$ref":"#/definitions/ICollection"}],"definitions":{"ICollection":{"type":"object","properties":{"plugins":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"enabled":{"type":"boolean"}},"required":["name"]}},"pluginRules":{"type":"object","properties":{"plugins":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"group":{"type":"string"},"after":{"type":"array","items":{"type":"string"}}},"required":["name"]}},"groups":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"group":{"type":"string"},"after":{"type":"array","items":{"type":"string"}}},"required":["name"]}}},"required":["plugins"]},"info":{"$ref":"#/definitions/ICollectionInfo"},"mods":{"type":"array","items":{"$ref":"#/definitions/ICollectionMod"}},"modRules":{"type":"array","items":{"$ref":"#/definitions/ICollectionModRule"}}},"required":["info","mods","modRules"]},"ICollectionInfo":{"type":"object","properties":{"author":{"type":"string"},"authorUrl":{"type":"string"},"name":{"type":"string"},"description":{"type":"string"},"domainName":{"type":"string"},"gameVersions":{"type":"array","items":{"type":"string"}}},"required":["author","authorUrl","name","description","domainName"]},"ICollectionMod":{"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"},"optional":{"type":"boolean"},"domainName":{"type":"string"},"source":{"$ref":"#/definitions/ICollectionSourceInfo"},"hashes":{},"choices":{},"patches":{"type":"object","additionalProperties":{"type":"string"}},"instructions":{"type":"string"},"author":{"type":"string"},"details":{"$ref":"#/definitions/ICollectionModDetails"},"phase":{"type":"number"},"fileOverrides":{"type":"array","items":{"type":"string"}}},"required":["name","version","optional","domainName","source"]},"ICollectionSourceInfo":{"type":"object","properties":{"type":{"$ref":"#/definitions/SourceType"},"url":{"type":"string"},"instructions":{"type":"string"},"modId":{"type":"number"},"fileId":{"type":"number"},"updatePolicy":{"$ref":"#/definitions/UpdatePolicy"},"adultContent":{"type":"boolean"},"md5":{"type":"string"},"fileSize":{"type":"number"},"logicalFilename":{"type":"string"},"fileExpression":{"type":"string"},"tag":{"type":"string"}},"required":["type"]},"SourceType":{"type":"string","enum":["browse","manual","direct","nexus","bundle"]},"UpdatePolicy":{"type":"string","enum":["exact","latest","prefer"]},"ICollectionModDetails":{"type":"object","properties":{"type":{"type":"string"},"category":{"type":"string"}}},"ICollectionModRule":{"type":"object","properties":{"source":{"$ref":"#/definitions/IModReference"},"type":{"$ref":"#/definitions/RuleType"},"reference":{"$ref":"#/definitions/IModReference"}},"required":["source","type","reference"]},"IModReference":{"type":"object","properties":{"fileMD5":{"type":"string"},"fileSize":{"type":"number"},"gameId":{"type":"string"},"versionMatch":{"type":"string"},"logicalFileName":{"type":"string"},"fileExpression":{"type":"string"},"id":{"type":"string"},"idHint":{"type":"string"},"md5Hint":{"type":"string"},"tag":{"type":"string"},"archiveId":{"type":"string"},"repo":{"type":"object","properties":{"gameId":{"type":"string"},"modId":{"type":"string"},"fileId":{"type":"string"},"repository":{"type":"string"},"campaign":{"type":"string"}},"required":["fileId","repository"]},"description":{"type":"string"},"instructions":{"type":"string"}}},"RuleType":{"type":"string","enum":["before","after","requires","conflicts","recommends","provides"]}},"exported":["ICollection"]};const schema12 = {"type":"object","properties":{"plugins":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"enabled":{"type":"boolean"}},"required":["name"]}},"pluginRules":{"type":"object","properties":{"plugins":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"group":{"type":"string"},"after":{"type":"array","items":{"type":"string"}}},"required":["name"]}},"groups":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"group":{"type":"string"},"after":{"type":"array","items":{"type":"string"}}},"required":["name"]}}},"required":["plugins"]},"info":{"$ref":"#/definitions/ICollectionInfo"},"mods":{"type":"array","items":{"$ref":"#/definitions/ICollectionMod"}},"modRules":{"type":"array","items":{"$ref":"#/definitions/ICollectionModRule"}}},"required":["info","mods","modRules"]};const schema13 = {"type":"object","properties":{"author":{"type":"string"},"authorUrl":{"type":"string"},"name":{"type":"string"},"description":{"type":"string"},"domainName":{"type":"string"},"gameVersions":{"type":"array","items":{"type":"string"}}},"required":["author","authorUrl","name","description","domainName"]};const schema14 = {"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"},"optional":{"type":"boolean"},"domainName":{"type":"string"},"source":{"$ref":"#/definitions/ICollectionSourceInfo"},"hashes":{},"choices":{},"patches":{"type":"object","additionalProperties":{"type":"string"}},"instructions":{"type":"string"},"author":{"type":"string"},"details":{"$ref":"#/definitions/ICollectionModDetails"},"phase":{"type":"number"},"fileOverrides":{"type":"array","items":{"type":"string"}}},"required":["name","version","optional","domainName","source"]};const schema18 = {"type":"object","properties":{"type":{"type":"string"},"category":{"type":"string"}}};const schema15 = {"type":"object","properties":{"type":{"$ref":"#/definitions/SourceType"},"url":{"type":"string"},"instructions":{"type":"string"},"modId":{"type":"number"},"fileId":{"type":"number"},"updatePolicy":{"$ref":"#/definitions/UpdatePolicy"},"adultContent":{"type":"boolean"},"md5":{"type":"string"},"fileSize":{"type":"number"},"logicalFilename":{"type":"string"},"fileExpression":{"type":"string"},"tag":{"type":"string"}},"required":["type"]};const schema16 = {"type":"string","enum":["browse","manual","direct","nexus","bundle"]};const schema17 = {"type":"string","enum":["exact","latest","prefer"]};const func0 = (__webpack_require__(/*! ./dummy */ "./src/validationCode/dummy.js")["default"]);function validate13(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(data && typeof data == "object" && !Array.isArray(data)){if(data.type === undefined){const err0 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "type"},message:"must have required property '"+"type"+"'",schema:schema15.required,parentSchema:schema15,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}if(data.type !== undefined){let data0 = data.type;if(typeof data0 !== "string"){const err1 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/SourceType/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema16.type,parentSchema:schema16,data:data0};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}if(!(((((data0 === "browse") || (data0 === "manual")) || (data0 === "direct")) || (data0 === "nexus")) || (data0 === "bundle"))){const err2 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/SourceType/enum",keyword:"enum",params:{allowedValues: schema16.enum},message:"must be equal to one of the allowed values",schema:schema16.enum,parentSchema:schema16,data:data0};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}}if(data.url !== undefined){let data1 = data.url;if(typeof data1 !== "string"){const err3 = {instancePath:instancePath+"/url",schemaPath:"#/properties/url/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.url.type,parentSchema:schema15.properties.url,data:data1};if(vErrors === null){vErrors = [err3];}else {vErrors.push(err3);}errors++;}}if(data.instructions !== undefined){let data2 = data.instructions;if(typeof data2 !== "string"){const err4 = {instancePath:instancePath+"/instructions",schemaPath:"#/properties/instructions/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.instructions.type,parentSchema:schema15.properties.instructions,data:data2};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}}if(data.modId !== undefined){let data3 = data.modId;if(!((typeof data3 == "number") && (isFinite(data3)))){const err5 = {instancePath:instancePath+"/modId",schemaPath:"#/properties/modId/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema15.properties.modId.type,parentSchema:schema15.properties.modId,data:data3};if(vErrors === null){vErrors = [err5];}else {vErrors.push(err5);}errors++;}}if(data.fileId !== undefined){let data4 = data.fileId;if(!((typeof data4 == "number") && (isFinite(data4)))){const err6 = {instancePath:instancePath+"/fileId",schemaPath:"#/properties/fileId/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema15.properties.fileId.type,parentSchema:schema15.properties.fileId,data:data4};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}}if(data.updatePolicy !== undefined){let data5 = data.updatePolicy;if(typeof data5 !== "string"){const err7 = {instancePath:instancePath+"/updatePolicy",schemaPath:"#/definitions/UpdatePolicy/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema17.type,parentSchema:schema17,data:data5};if(vErrors === null){vErrors = [err7];}else {vErrors.push(err7);}errors++;}if(!(((data5 === "exact") || (data5 === "latest")) || (data5 === "prefer"))){const err8 = {instancePath:instancePath+"/updatePolicy",schemaPath:"#/definitions/UpdatePolicy/enum",keyword:"enum",params:{allowedValues: schema17.enum},message:"must be equal to one of the allowed values",schema:schema17.enum,parentSchema:schema17,data:data5};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}}if(data.adultContent !== undefined){let data6 = data.adultContent;if(typeof data6 !== "boolean"){const err9 = {instancePath:instancePath+"/adultContent",schemaPath:"#/properties/adultContent/type",keyword:"type",params:{type: "boolean"},message:"must be boolean",schema:schema15.properties.adultContent.type,parentSchema:schema15.properties.adultContent,data:data6};if(vErrors === null){vErrors = [err9];}else {vErrors.push(err9);}errors++;}}if(data.md5 !== undefined){let data7 = data.md5;if(typeof data7 !== "string"){const err10 = {instancePath:instancePath+"/md5",schemaPath:"#/properties/md5/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.md5.type,parentSchema:schema15.properties.md5,data:data7};if(vErrors === null){vErrors = [err10];}else {vErrors.push(err10);}errors++;}}if(data.fileSize !== undefined){let data8 = data.fileSize;if(!((typeof data8 == "number") && (isFinite(data8)))){const err11 = {instancePath:instancePath+"/fileSize",schemaPath:"#/properties/fileSize/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema15.properties.fileSize.type,parentSchema:schema15.properties.fileSize,data:data8};if(vErrors === null){vErrors = [err11];}else {vErrors.push(err11);}errors++;}}if(data.logicalFilename !== undefined){let data9 = data.logicalFilename;if(typeof data9 !== "string"){const err12 = {instancePath:instancePath+"/logicalFilename",schemaPath:"#/properties/logicalFilename/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.logicalFilename.type,parentSchema:schema15.properties.logicalFilename,data:data9};if(vErrors === null){vErrors = [err12];}else {vErrors.push(err12);}errors++;}}if(data.fileExpression !== undefined){let data10 = data.fileExpression;if(typeof data10 !== "string"){const err13 = {instancePath:instancePath+"/fileExpression",schemaPath:"#/properties/fileExpression/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.fileExpression.type,parentSchema:schema15.properties.fileExpression,data:data10};if(vErrors === null){vErrors = [err13];}else {vErrors.push(err13);}errors++;}}if(data.tag !== undefined){let data11 = data.tag;if(typeof data11 !== "string"){const err14 = {instancePath:instancePath+"/tag",schemaPath:"#/properties/tag/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.tag.type,parentSchema:schema15.properties.tag,data:data11};if(vErrors === null){vErrors = [err14];}else {vErrors.push(err14);}errors++;}}}else {const err15 = {instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema15.type,parentSchema:schema15,data};if(vErrors === null){vErrors = [err15];}else {vErrors.push(err15);}errors++;}validate13.errors = vErrors;return errors === 0;}function validate12(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(data && typeof data == "object" && !Array.isArray(data)){if(data.name === undefined){const err0 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}if(data.version === undefined){const err1 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "version"},message:"must have required property '"+"version"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}if(data.optional === undefined){const err2 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "optional"},message:"must have required property '"+"optional"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}if(data.domainName === undefined){const err3 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "domainName"},message:"must have required property '"+"domainName"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err3];}else {vErrors.push(err3);}errors++;}if(data.source === undefined){const err4 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "source"},message:"must have required property '"+"source"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}if(data.name !== undefined){let data0 = data.name;if(typeof data0 !== "string"){const err5 = {instancePath:instancePath+"/name",schemaPath:"#/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.name.type,parentSchema:schema14.properties.name,data:data0};if(vErrors === null){vErrors = [err5];}else {vErrors.push(err5);}errors++;}}if(data.version !== undefined){let data1 = data.version;if(typeof data1 !== "string"){const err6 = {instancePath:instancePath+"/version",schemaPath:"#/properties/version/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.version.type,parentSchema:schema14.properties.version,data:data1};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}}if(data.optional !== undefined){let data2 = data.optional;if(typeof data2 !== "boolean"){const err7 = {instancePath:instancePath+"/optional",schemaPath:"#/properties/optional/type",keyword:"type",params:{type: "boolean"},message:"must be boolean",schema:schema14.properties.optional.type,parentSchema:schema14.properties.optional,data:data2};if(vErrors === null){vErrors = [err7];}else {vErrors.push(err7);}errors++;}}if(data.domainName !== undefined){let data3 = data.domainName;if(typeof data3 !== "string"){const err8 = {instancePath:instancePath+"/domainName",schemaPath:"#/properties/domainName/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.domainName.type,parentSchema:schema14.properties.domainName,data:data3};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}}if(data.source !== undefined){if(!(validate13(data.source, {instancePath:instancePath+"/source",parentData:data,parentDataProperty:"source",rootData}))){vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);errors = vErrors.length;}}if(data.patches !== undefined){let data5 = data.patches;if(data5 && typeof data5 == "object" && !Array.isArray(data5)){for(const key0 in data5){let data6 = data5[key0];if(typeof data6 !== "string"){const err9 = {instancePath:instancePath+"/patches/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"),schemaPath:"#/properties/patches/additionalProperties/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.patches.additionalProperties.type,parentSchema:schema14.properties.patches.additionalProperties,data:data6};if(vErrors === null){vErrors = [err9];}else {vErrors.push(err9);}errors++;}}}else {const err10 = {instancePath:instancePath+"/patches",schemaPath:"#/properties/patches/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema14.properties.patches.type,parentSchema:schema14.properties.patches,data:data5};if(vErrors === null){vErrors = [err10];}else {vErrors.push(err10);}errors++;}}if(data.instructions !== undefined){let data7 = data.instructions;if(typeof data7 !== "string"){const err11 = {instancePath:instancePath+"/instructions",schemaPath:"#/properties/instructions/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.instructions.type,parentSchema:schema14.properties.instructions,data:data7};if(vErrors === null){vErrors = [err11];}else {vErrors.push(err11);}errors++;}}if(data.author !== undefined){let data8 = data.author;if(typeof data8 !== "string"){const err12 = {instancePath:instancePath+"/author",schemaPath:"#/properties/author/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.author.type,parentSchema:schema14.properties.author,data:data8};if(vErrors === null){vErrors = [err12];}else {vErrors.push(err12);}errors++;}}if(data.details !== undefined){let data9 = data.details;if(data9 && typeof data9 == "object" && !Array.isArray(data9)){if(data9.type !== undefined){let data10 = data9.type;if(typeof data10 !== "string"){const err13 = {instancePath:instancePath+"/details/type",schemaPath:"#/definitions/ICollectionModDetails/properties/type/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema18.properties.type.type,parentSchema:schema18.properties.type,data:data10};if(vErrors === null){vErrors = [err13];}else {vErrors.push(err13);}errors++;}}if(data9.category !== undefined){let data11 = data9.category;if(typeof data11 !== "string"){const err14 = {instancePath:instancePath+"/details/category",schemaPath:"#/definitions/ICollectionModDetails/properties/category/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema18.properties.category.type,parentSchema:schema18.properties.category,data:data11};if(vErrors === null){vErrors = [err14];}else {vErrors.push(err14);}errors++;}}}else {const err15 = {instancePath:instancePath+"/details",schemaPath:"#/definitions/ICollectionModDetails/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema18.type,parentSchema:schema18,data:data9};if(vErrors === null){vErrors = [err15];}else {vErrors.push(err15);}errors++;}}if(data.phase !== undefined){let data12 = data.phase;if(!((typeof data12 == "number") && (isFinite(data12)))){const err16 = {instancePath:instancePath+"/phase",schemaPath:"#/properties/phase/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema14.properties.phase.type,parentSchema:schema14.properties.phase,data:data12};if(vErrors === null){vErrors = [err16];}else {vErrors.push(err16);}errors++;}}if(data.fileOverrides !== undefined){let data13 = data.fileOverrides;if(Array.isArray(data13)){const len0 = data13.length;for(let i0=0; i0<len0; i0++){let data14 = data13[i0];if(typeof data14 !== "string"){const err17 = {instancePath:instancePath+"/fileOverrides/" + i0,schemaPath:"#/properties/fileOverrides/items/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.fileOverrides.items.type,parentSchema:schema14.properties.fileOverrides.items,data:data14};if(vErrors === null){vErrors = [err17];}else {vErrors.push(err17);}errors++;}}}else {const err18 = {instancePath:instancePath+"/fileOverrides",schemaPath:"#/properties/fileOverrides/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema14.properties.fileOverrides.type,parentSchema:schema14.properties.fileOverrides,data:data13};if(vErrors === null){vErrors = [err18];}else {vErrors.push(err18);}errors++;}}}else {const err19 = {instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema14.type,parentSchema:schema14,data};if(vErrors === null){vErrors = [err19];}else {vErrors.push(err19);}errors++;}validate12.errors = vErrors;return errors === 0;}const schema19 = {"type":"object","properties":{"source":{"$ref":"#/definitions/IModReference"},"type":{"$ref":"#/definitions/RuleType"},"reference":{"$ref":"#/definitions/IModReference"}},"required":["source","type","reference"]};const schema20 = {"type":"object","properties":{"fileMD5":{"type":"string"},"fileSize":{"type":"number"},"gameId":{"type":"string"},"versionMatch":{"type":"string"},"logicalFileName":{"type":"string"},"fileExpression":{"type":"string"},"id":{"type":"string"},"idHint":{"type":"string"},"md5Hint":{"type":"string"},"tag":{"type":"string"},"archiveId":{"type":"string"},"repo":{"type":"object","properties":{"gameId":{"type":"string"},"modId":{"type":"string"},"fileId":{"type":"string"},"repository":{"type":"string"},"campaign":{"type":"string"}},"required":["fileId","repository"]},"description":{"type":"string"},"instructions":{"type":"string"}}};const schema21 = {"type":"string","enum":["before","after","requires","conflicts","recommends","provides"]};function validate16(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(data && typeof data == "object" && !Array.isArray(data)){if(data.source === undefined){const err0 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "source"},message:"must have required property '"+"source"+"'",schema:schema19.required,parentSchema:schema19,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}if(data.type === undefined){const err1 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "type"},message:"must have required property '"+"type"+"'",schema:schema19.required,parentSchema:schema19,data};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}if(data.reference === undefined){const err2 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "reference"},message:"must have required property '"+"reference"+"'",schema:schema19.required,parentSchema:schema19,data};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}if(data.source !== undefined){let data0 = data.source;if(data0 && typeof data0 == "object" && !Array.isArray(data0)){if(data0.fileMD5 !== undefined){let data1 = data0.fileMD5;if(typeof data1 !== "string"){const err3 = {instancePath:instancePath+"/source/fileMD5",schemaPath:"#/definitions/IModReference/properties/fileMD5/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.fileMD5.type,parentSchema:schema20.properties.fileMD5,data:data1};if(vErrors === null){vErrors = [err3];}else {vErrors.push(err3);}errors++;}}if(data0.fileSize !== undefined){let data2 = data0.fileSize;if(!((typeof data2 == "number") && (isFinite(data2)))){const err4 = {instancePath:instancePath+"/source/fileSize",schemaPath:"#/definitions/IModReference/properties/fileSize/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema20.properties.fileSize.type,parentSchema:schema20.properties.fileSize,data:data2};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}}if(data0.gameId !== undefined){let data3 = data0.gameId;if(typeof data3 !== "string"){const err5 = {instancePath:instancePath+"/source/gameId",schemaPath:"#/definitions/IModReference/properties/gameId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.gameId.type,parentSchema:schema20.properties.gameId,data:data3};if(vErrors === null){vErrors = [err5];}else {vErrors.push(err5);}errors++;}}if(data0.versionMatch !== undefined){let data4 = data0.versionMatch;if(typeof data4 !== "string"){const err6 = {instancePath:instancePath+"/source/versionMatch",schemaPath:"#/definitions/IModReference/properties/versionMatch/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.versionMatch.type,parentSchema:schema20.properties.versionMatch,data:data4};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}}if(data0.logicalFileName !== undefined){let data5 = data0.logicalFileName;if(typeof data5 !== "string"){const err7 = {instancePath:instancePath+"/source/logicalFileName",schemaPath:"#/definitions/IModReference/properties/logicalFileName/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.logicalFileName.type,parentSchema:schema20.properties.logicalFileName,data:data5};if(vErrors === null){vErrors = [err7];}else {vErrors.push(err7);}errors++;}}if(data0.fileExpression !== undefined){let data6 = data0.fileExpression;if(typeof data6 !== "string"){const err8 = {instancePath:instancePath+"/source/fileExpression",schemaPath:"#/definitions/IModReference/properties/fileExpression/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.fileExpression.type,parentSchema:schema20.properties.fileExpression,data:data6};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}}if(data0.id !== undefined){let data7 = data0.id;if(typeof data7 !== "string"){const err9 = {instancePath:instancePath+"/source/id",schemaPath:"#/definitions/IModReference/properties/id/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.id.type,parentSchema:schema20.properties.id,data:data7};if(vErrors === null){vErrors = [err9];}else {vErrors.push(err9);}errors++;}}if(data0.idHint !== undefined){let data8 = data0.idHint;if(typeof data8 !== "string"){const err10 = {instancePath:instancePath+"/source/idHint",schemaPath:"#/definitions/IModReference/properties/idHint/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.idHint.type,parentSchema:schema20.properties.idHint,data:data8};if(vErrors === null){vErrors = [err10];}else {vErrors.push(err10);}errors++;}}if(data0.md5Hint !== undefined){let data9 = data0.md5Hint;if(typeof data9 !== "string"){const err11 = {instancePath:instancePath+"/source/md5Hint",schemaPath:"#/definitions/IModReference/properties/md5Hint/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.md5Hint.type,parentSchema:schema20.properties.md5Hint,data:data9};if(vErrors === null){vErrors = [err11];}else {vErrors.push(err11);}errors++;}}if(data0.tag !== undefined){let data10 = data0.tag;if(typeof data10 !== "string"){const err12 = {instancePath:instancePath+"/source/tag",schemaPath:"#/definitions/IModReference/properties/tag/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.tag.type,parentSchema:schema20.properties.tag,data:data10};if(vErrors === null){vErrors = [err12];}else {vErrors.push(err12);}errors++;}}if(data0.archiveId !== undefined){let data11 = data0.archiveId;if(typeof data11 !== "string"){const err13 = {instancePath:instancePath+"/source/archiveId",schemaPath:"#/definitions/IModReference/properties/archiveId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.archiveId.type,parentSchema:schema20.properties.archiveId,data:data11};if(vErrors === null){vErrors = [err13];}else {vErrors.push(err13);}errors++;}}if(data0.repo !== undefined){let data12 = data0.repo;if(data12 && typeof data12 == "object" && !Array.isArray(data12)){if(data12.fileId === undefined){const err14 = {instancePath:instancePath+"/source/repo",schemaPath:"#/definitions/IModReference/properties/repo/required",keyword:"required",params:{missingProperty: "fileId"},message:"must have required property '"+"fileId"+"'",schema:schema20.properties.repo.required,parentSchema:schema20.properties.repo,data:data12};if(vErrors === null){vErrors = [err14];}else {vErrors.push(err14);}errors++;}if(data12.repository === undefined){const err15 = {instancePath:instancePath+"/source/repo",schemaPath:"#/definitions/IModReference/properties/repo/required",keyword:"required",params:{missingProperty: "repository"},message:"must have required property '"+"repository"+"'",schema:schema20.properties.repo.required,parentSchema:schema20.properties.repo,data:data12};if(vErrors === null){vErrors = [err15];}else {vErrors.push(err15);}errors++;}if(data12.gameId !== undefined){let data13 = data12.gameId;if(typeof data13 !== "string"){const err16 = {instancePath:instancePath+"/source/repo/gameId",schemaPath:"#/definitions/IModReference/properties/repo/properties/gameId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.gameId.type,parentSchema:schema20.properties.repo.properties.gameId,data:data13};if(vErrors === null){vErrors = [err16];}else {vErrors.push(err16);}errors++;}}if(data12.modId !== undefined){let data14 = data12.modId;if(typeof data14 !== "string"){const err17 = {instancePath:instancePath+"/source/repo/modId",schemaPath:"#/definitions/IModReference/properties/repo/properties/modId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.modId.type,parentSchema:schema20.properties.repo.properties.modId,data:data14};if(vErrors === null){vErrors = [err17];}else {vErrors.push(err17);}errors++;}}if(data12.fileId !== undefined){let data15 = data12.fileId;if(typeof data15 !== "string"){const err18 = {instancePath:instancePath+"/source/repo/fileId",schemaPath:"#/definitions/IModReference/properties/repo/properties/fileId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.fileId.type,parentSchema:schema20.properties.repo.properties.fileId,data:data15};if(vErrors === null){vErrors = [err18];}else {vErrors.push(err18);}errors++;}}if(data12.repository !== undefined){let data16 = data12.repository;if(typeof data16 !== "string"){const err19 = {instancePath:instancePath+"/source/repo/repository",schemaPath:"#/definitions/IModReference/properties/repo/properties/repository/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.repository.type,parentSchema:schema20.properties.repo.properties.repository,data:data16};if(vErrors === null){vErrors = [err19];}else {vErrors.push(err19);}errors++;}}if(data12.campaign !== undefined){let data17 = data12.campaign;if(typeof data17 !== "string"){const err20 = {instancePath:instancePath+"/source/repo/campaign",schemaPath:"#/definitions/IModReference/properties/repo/properties/campaign/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.campaign.type,parentSchema:schema20.properties.repo.properties.campaign,data:data17};if(vErrors === null){vErrors = [err20];}else {vErrors.push(err20);}errors++;}}}else {const err21 = {instancePath:instancePath+"/source/repo",schemaPath:"#/definitions/IModReference/properties/repo/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema20.properties.repo.type,parentSchema:schema20.properties.repo,data:data12};if(vErrors === null){vErrors = [err21];}else {vErrors.push(err21);}errors++;}}if(data0.description !== undefined){let data18 = data0.description;if(typeof data18 !== "string"){const err22 = {instancePath:instancePath+"/source/description",schemaPath:"#/definitions/IModReference/properties/description/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.description.type,parentSchema:schema20.properties.description,data:data18};if(vErrors === null){vErrors = [err22];}else {vErrors.push(err22);}errors++;}}if(data0.instructions !== undefined){let data19 = data0.instructions;if(typeof data19 !== "string"){const err23 = {instancePath:instancePath+"/source/instructions",schemaPath:"#/definitions/IModReference/properties/instructions/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.instructions.type,parentSchema:schema20.properties.instructions,data:data19};if(vErrors === null){vErrors = [err23];}else {vErrors.push(err23);}errors++;}}}else {const err24 = {instancePath:instancePath+"/source",schemaPath:"#/definitions/IModReference/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema20.type,parentSchema:schema20,data:data0};if(vErrors === null){vErrors = [err24];}else {vErrors.push(err24);}errors++;}}if(data.type !== undefined){let data20 = data.type;if(typeof data20 !== "string"){const err25 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/RuleType/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema21.type,parentSchema:schema21,data:data20};if(vErrors === null){vErrors = [err25];}else {vErrors.push(err25);}errors++;}if(!((((((data20 === "before") || (data20 === "after")) || (data20 === "requires")) || (data20 === "conflicts")) || (data20 === "recommends")) || (data20 === "provides"))){const err26 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/RuleType/enum",keyword:"enum",params:{allowedValues: schema21.enum},message:"must be equal to one of the allowed values",schema:schema21.enum,parentSchema:schema21,data:data20};if(vErrors === null){vErrors = [err26];}else {vErrors.push(err26);}errors++;}}if(data.reference !== undefined){let data21 = data.reference;if(data21 && typeof data21 == "object" && !Array.isArray(data21)){if(data21.fileMD5 !== undefined){let data22 = data21.fileMD5;if(typeof data22 !== "string"){const err27 = {instancePath:instancePath+"/reference/fileMD5",schemaPath:"#/definitions/IModReference/properties/fileMD5/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.fileMD5.type,parentSchema:schema20.properties.fileMD5,data:data22};if(vErrors === null){vErrors = [err27];}else {vErrors.push(err27);}errors++;}}if(data21.fileSize !== undefined){let data23 = data21.fileSize;if(!((typeof data23 == "number") && (isFinite(data23)))){const err28 = {instancePath:instancePath+"/reference/fileSize",schemaPath:"#/definitions/IModReference/properties/fileSize/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema20.properties.fileSize.type,parentSchema:schema20.properties.fileSize,data:data23};if(vErrors === null){vErrors = [err28];}else {vErrors.push(err28);}errors++;}}if(data21.gameId !== undefined){let data24 = data21.gameId;if(typeof data24 !== "string"){const err29 = {instancePath:instancePath+"/reference/gameId",schemaPath:"#/definitions/IModReference/properties/gameId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.gameId.type,parentSchema:schema20.properties.gameId,data:data24};if(vErrors === null){vErrors = [err29];}else {vErrors.push(err29);}errors++;}}if(data21.versionMatch !== undefined){let data25 = data21.versionMatch;if(typeof data25 !== "string"){const err30 = {instancePath:instancePath+"/reference/versionMatch",schemaPath:"#/definitions/IModReference/properties/versionMatch/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.versionMatch.type,parentSchema:schema20.properties.versionMatch,data:data25};if(vErrors === null){vErrors = [err30];}else {vErrors.push(err30);}errors++;}}if(data21.logicalFileName !== undefined){let data26 = data21.logicalFileName;if(typeof data26 !== "string"){const err31 = {instancePath:instancePath+"/reference/logicalFileName",schemaPath:"#/definitions/IModReference/properties/logicalFileName/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.logicalFileName.type,parentSchema:schema20.properties.logicalFileName,data:data26};if(vErrors === null){vErrors = [err31];}else {vErrors.push(err31);}errors++;}}if(data21.fileExpression !== undefined){let data27 = data21.fileExpression;if(typeof data27 !== "string"){const err32 = {instancePath:instancePath+"/reference/fileExpression",schemaPath:"#/definitions/IModReference/properties/fileExpression/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.fileExpression.type,parentSchema:schema20.properties.fileExpression,data:data27};if(vErrors === null){vErrors = [err32];}else {vErrors.push(err32);}errors++;}}if(data21.id !== undefined){let data28 = data21.id;if(typeof data28 !== "string"){const err33 = {instancePath:instancePath+"/reference/id",schemaPath:"#/definitions/IModReference/properties/id/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.id.type,parentSchema:schema20.properties.id,data:data28};if(vErrors === null){vErrors = [err33];}else {vErrors.push(err33);}errors++;}}if(data21.idHint !== undefined){let data29 = data21.idHint;if(typeof data29 !== "string"){const err34 = {instancePath:instancePath+"/reference/idHint",schemaPath:"#/definitions/IModReference/properties/idHint/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.idHint.type,parentSchema:schema20.properties.idHint,data:data29};if(vErrors === null){vErrors = [err34];}else {vErrors.push(err34);}errors++;}}if(data21.md5Hint !== undefined){let data30 = data21.md5Hint;if(typeof data30 !== "string"){const err35 = {instancePath:instancePath+"/reference/md5Hint",schemaPath:"#/definitions/IModReference/properties/md5Hint/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.md5Hint.type,parentSchema:schema20.properties.md5Hint,data:data30};if(vErrors === null){vErrors = [err35];}else {vErrors.push(err35);}errors++;}}if(data21.tag !== undefined){let data31 = data21.tag;if(typeof data31 !== "string"){const err36 = {instancePath:instancePath+"/reference/tag",schemaPath:"#/definitions/IModReference/properties/tag/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.tag.type,parentSchema:schema20.properties.tag,data:data31};if(vErrors === null){vErrors = [err36];}else {vErrors.push(err36);}errors++;}}if(data21.archiveId !== undefined){let data32 = data21.archiveId;if(typeof data32 !== "string"){const err37 = {instancePath:instancePath+"/reference/archiveId",schemaPath:"#/definitions/IModReference/properties/archiveId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.archiveId.type,parentSchema:schema20.properties.archiveId,data:data32};if(vErrors === null){vErrors = [err37];}else {vErrors.push(err37);}errors++;}}if(data21.repo !== undefined){let data33 = data21.repo;if(data33 && typeof data33 == "object" && !Array.isArray(data33)){if(data33.fileId === undefined){const err38 = {instancePath:instancePath+"/reference/repo",schemaPath:"#/definitions/IModReference/properties/repo/required",keyword:"required",params:{missingProperty: "fileId"},message:"must have required property '"+"fileId"+"'",schema:schema20.properties.repo.required,parentSchema:schema20.properties.repo,data:data33};if(vErrors === null){vErrors = [err38];}else {vErrors.push(err38);}errors++;}if(data33.repository === undefined){const err39 = {instancePath:instancePath+"/reference/repo",schemaPath:"#/definitions/IModReference/properties/repo/required",keyword:"required",params:{missingProperty: "repository"},message:"must have required property '"+"repository"+"'",schema:schema20.properties.repo.required,parentSchema:schema20.properties.repo,data:data33};if(vErrors === null){vErrors = [err39];}else {vErrors.push(err39);}errors++;}if(data33.gameId !== undefined){let data34 = data33.gameId;if(typeof data34 !== "string"){const err40 = {instancePath:instancePath+"/reference/repo/gameId",schemaPath:"#/definitions/IModReference/properties/repo/properties/gameId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.gameId.type,parentSchema:schema20.properties.repo.properties.gameId,data:data34};if(vErrors === null){vErrors = [err40];}else {vErrors.push(err40);}errors++;}}if(data33.modId !== undefined){let data35 = data33.modId;if(typeof data35 !== "string"){const err41 = {instancePath:instancePath+"/reference/repo/modId",schemaPath:"#/definitions/IModReference/properties/repo/properties/modId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.modId.type,parentSchema:schema20.properties.repo.properties.modId,data:data35};if(vErrors === null){vErrors = [err41];}else {vErrors.push(err41);}errors++;}}if(data33.fileId !== undefined){let data36 = data33.fileId;if(typeof data36 !== "string"){const err42 = {instancePath:instancePath+"/reference/repo/fileId",schemaPath:"#/definitions/IModReference/properties/repo/properties/fileId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.fileId.type,parentSchema:schema20.properties.repo.properties.fileId,data:data36};if(vErrors === null){vErrors = [err42];}else {vErrors.push(err42);}errors++;}}if(data33.repository !== undefined){let data37 = data33.repository;if(typeof data37 !== "string"){const err43 = {instancePath:instancePath+"/reference/repo/repository",schemaPath:"#/definitions/IModReference/properties/repo/properties/repository/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.repository.type,parentSchema:schema20.properties.repo.properties.repository,data:data37};if(vErrors === null){vErrors = [err43];}else {vErrors.push(err43);}errors++;}}if(data33.campaign !== undefined){let data38 = data33.campaign;if(typeof data38 !== "string"){const err44 = {instancePath:instancePath+"/reference/repo/campaign",schemaPath:"#/definitions/IModReference/properties/repo/properties/campaign/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.campaign.type,parentSchema:schema20.properties.repo.properties.campaign,data:data38};if(vErrors === null){vErrors = [err44];}else {vErrors.push(err44);}errors++;}}}else {const err45 = {instancePath:instancePath+"/reference/repo",schemaPath:"#/definitions/IModReference/properties/repo/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema20.properties.repo.type,parentSchema:schema20.properties.repo,data:data33};if(vErrors === null){vErrors = [err45];}else {vErrors.push(err45);}errors++;}}if(data21.description !== undefined){let data39 = data21.description;if(typeof data39 !== "string"){const err46 = {instancePath:instancePath+"/reference/description",schemaPath:"#/definitions/IModReference/properties/description/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.description.type,parentSchema:schema20.properties.description,data:data39};if(vErrors === null){vErrors = [err46];}else {vErrors.push(err46);}errors++;}}if(data21.instructions !== undefined){let data40 = data21.instructions;if(typeof data40 !== "string"){const err47 = {instancePath:instancePath+"/reference/instructions",schemaPath:"#/definitions/IModReference/properties/instructions/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.instructions.type,parentSchema:schema20.properties.instructions,data:data40};if(vErrors === null){vErrors = [err47];}else {vErrors.push(err47);}errors++;}}}else {const err48 = {instancePath:instancePath+"/reference",schemaPath:"#/definitions/IModReference/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema20.type,parentSchema:schema20,data:data21};if(vErrors === null){vErrors = [err48];}else {vErrors.push(err48);}errors++;}}}else {const err49 = {instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema19.type,parentSchema:schema19,data};if(vErrors === null){vErrors = [err49];}else {vErrors.push(err49);}errors++;}validate16.errors = vErrors;return errors === 0;}function validate11(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(data && typeof data == "object" && !Array.isArray(data)){if(data.info === undefined){const err0 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "info"},message:"must have required property '"+"info"+"'",schema:schema12.required,parentSchema:schema12,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}if(data.mods === undefined){const err1 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "mods"},message:"must have required property '"+"mods"+"'",schema:schema12.required,parentSchema:schema12,data};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}if(data.modRules === undefined){const err2 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "modRules"},message:"must have required property '"+"modRules"+"'",schema:schema12.required,parentSchema:schema12,data};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}if(data.plugins !== undefined){let data0 = data.plugins;if(Array.isArray(data0)){const len0 = data0.length;for(let i0=0; i0<len0; i0++){let data1 = data0[i0];if(data1 && typeof data1 == "object" && !Array.isArray(data1)){if(data1.name === undefined){const err3 = {instancePath:instancePath+"/plugins/" + i0,schemaPath:"#/properties/plugins/items/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema12.properties.plugins.items.required,parentSchema:schema12.properties.plugins.items,data:data1};if(vErrors === null){vErrors = [err3];}else {vErrors.push(err3);}errors++;}if(data1.name !== undefined){let data2 = data1.name;if(typeof data2 !== "string"){const err4 = {instancePath:instancePath+"/plugins/" + i0+"/name",schemaPath:"#/properties/plugins/items/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.plugins.items.properties.name.type,parentSchema:schema12.properties.plugins.items.properties.name,data:data2};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}}if(data1.enabled !== undefined){let data3 = data1.enabled;if(typeof data3 !== "boolean"){const err5 = {instancePath:instancePath+"/plugins/" + i0+"/enabled",schemaPath:"#/properties/plugins/items/properties/enabled/type",keyword:"type",params:{type: "boolean"},message:"must be boolean",schema:schema12.properties.plugins.items.properties.enabled.type,parentSchema:schema12.properties.plugins.items.properties.enabled,data:data3};if(vErrors === null){vErrors = [err5];}else {vErrors.push(err5);}errors++;}}}else {const err6 = {instancePath:instancePath+"/plugins/" + i0,schemaPath:"#/properties/plugins/items/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.properties.plugins.items.type,parentSchema:schema12.properties.plugins.items,data:data1};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}}}else {const err7 = {instancePath:instancePath+"/plugins",schemaPath:"#/properties/plugins/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.plugins.type,parentSchema:schema12.properties.plugins,data:data0};if(vErrors === null){vErrors = [err7];}else {vErrors.push(err7);}errors++;}}if(data.pluginRules !== undefined){let data4 = data.pluginRules;if(data4 && typeof data4 == "object" && !Array.isArray(data4)){if(data4.plugins === undefined){const err8 = {instancePath:instancePath+"/pluginRules",schemaPath:"#/properties/pluginRules/required",keyword:"required",params:{missingProperty: "plugins"},message:"must have required property '"+"plugins"+"'",schema:schema12.properties.pluginRules.required,parentSchema:schema12.properties.pluginRules,data:data4};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}if(data4.plugins !== undefined){let data5 = data4.plugins;if(Array.isArray(data5)){const len1 = data5.length;for(let i1=0; i1<len1; i1++){let data6 = data5[i1];if(data6 && typeof data6 == "object" && !Array.isArray(data6)){if(data6.name === undefined){const err9 = {instancePath:instancePath+"/pluginRules/plugins/" + i1,schemaPath:"#/properties/pluginRules/properties/plugins/items/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema12.properties.pluginRules.properties.plugins.items.required,parentSchema:schema12.properties.pluginRules.properties.plugins.items,data:data6};if(vErrors === null){vErrors = [err9];}else {vErrors.push(err9);}errors++;}if(data6.name !== undefined){let data7 = data6.name;if(typeof data7 !== "string"){const err10 = {instancePath:instancePath+"/pluginRules/plugins/" + i1+"/name",schemaPath:"#/properties/pluginRules/properties/plugins/items/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.plugins.items.properties.name.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items.properties.name,data:data7};if(vErrors === null){vErrors = [err10];}else {vErrors.push(err10);}errors++;}}if(data6.group !== undefined){let data8 = data6.group;if(typeof data8 !== "string"){const err11 = {instancePath:instancePath+"/pluginRules/plugins/" + i1+"/group",schemaPath:"#/properties/pluginRules/properties/plugins/items/properties/group/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.plugins.items.properties.group.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items.properties.group,data:data8};if(vErrors === null){vErrors = [err11];}else {vErrors.push(err11);}errors++;}}if(data6.after !== undefined){let data9 = data6.after;if(Array.isArray(data9)){const len2 = data9.length;for(let i2=0; i2<len2; i2++){let data10 = data9[i2];if(typeof data10 !== "string"){const err12 = {instancePath:instancePath+"/pluginRules/plugins/" + i1+"/after/" + i2,schemaPath:"#/properties/pluginRules/properties/plugins/items/properties/after/items/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.plugins.items.properties.after.items.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items.properties.after.items,data:data10};if(vErrors === null){vErrors = [err12];}else {vErrors.push(err12);}errors++;}}}else {const err13 = {instancePath:instancePath+"/pluginRules/plugins/" + i1+"/after",schemaPath:"#/properties/pluginRules/properties/plugins/items/properties/after/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.pluginRules.properties.plugins.items.properties.after.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items.properties.after,data:data9};if(vErrors === null){vErrors = [err13];}else {vErrors.push(err13);}errors++;}}}else {const err14 = {instancePath:instancePath+"/pluginRules/plugins/" + i1,schemaPath:"#/properties/pluginRules/properties/plugins/items/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.properties.pluginRules.properties.plugins.items.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items,data:data6};if(vErrors === null){vErrors = [err14];}else {vErrors.push(err14);}errors++;}}}else {const err15 = {instancePath:instancePath+"/pluginRules/plugins",schemaPath:"#/properties/pluginRules/properties/plugins/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.pluginRules.properties.plugins.type,parentSchema:schema12.properties.pluginRules.properties.plugins,data:data5};if(vErrors === null){vErrors = [err15];}else {vErrors.push(err15);}errors++;}}if(data4.groups !== undefined){let data11 = data4.groups;if(Array.isArray(data11)){const len3 = data11.length;for(let i3=0; i3<len3; i3++){let data12 = data11[i3];if(data12 && typeof data12 == "object" && !Array.isArray(data12)){if(data12.name === undefined){const err16 = {instancePath:instancePath+"/pluginRules/groups/" + i3,schemaPath:"#/properties/pluginRules/properties/groups/items/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema12.properties.pluginRules.properties.groups.items.required,parentSchema:schema12.properties.pluginRules.properties.groups.items,data:data12};if(vErrors === null){vErrors = [err16];}else {vErrors.push(err16);}errors++;}if(data12.name !== undefined){let data13 = data12.name;if(typeof data13 !== "string"){const err17 = {instancePath:instancePath+"/pluginRules/groups/" + i3+"/name",schemaPath:"#/properties/pluginRules/properties/groups/items/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.groups.items.properties.name.type,parentSchema:schema12.properties.pluginRules.properties.groups.items.properties.name,data:data13};if(vErrors === null){vErrors = [err17];}else {vErrors.push(err17);}errors++;}}if(data12.group !== undefined){let data14 = data12.group;if(typeof data14 !== "string"){const err18 = {instancePath:instancePath+"/pluginRules/groups/" + i3+"/group",schemaPath:"#/properties/pluginRules/properties/groups/items/properties/group/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.groups.items.properties.group.type,parentSchema:schema12.properties.pluginRules.properties.groups.items.properties.group,data:data14};if(vErrors === null){vErrors = [err18];}else {vErrors.push(err18);}errors++;}}if(data12.after !== undefined){let data15 = data12.after;if(Array.isArray(data15)){const len4 = data15.length;for(let i4=0; i4<len4; i4++){let data16 = data15[i4];if(typeof data16 !== "string"){const err19 = {instancePath:instancePath+"/pluginRules/groups/" + i3+"/after/" + i4,schemaPath:"#/properties/pluginRules/properties/groups/items/properties/after/items/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.groups.items.properties.after.items.type,parentSchema:schema12.properties.pluginRules.properties.groups.items.properties.after.items,data:data16};if(vErrors === null){vErrors = [err19];}else {vErrors.push(err19);}errors++;}}}else {const err20 = {instancePath:instancePath+"/pluginRules/groups/" + i3+"/after",schemaPath:"#/properties/pluginRules/properties/groups/items/properties/after/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.pluginRules.properties.groups.items.properties.after.type,parentSchema:schema12.properties.pluginRules.properties.groups.items.properties.after,data:data15};if(vErrors === null){vErrors = [err20];}else {vErrors.push(err20);}errors++;}}}else {const err21 = {instancePath:instancePath+"/pluginRules/groups/" + i3,schemaPath:"#/properties/pluginRules/properties/groups/items/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.properties.pluginRules.properties.groups.items.type,parentSchema:schema12.properties.pluginRules.properties.groups.items,data:data12};if(vErrors === null){vErrors = [err21];}else {vErrors.push(err21);}errors++;}}}else {const err22 = {instancePath:instancePath+"/pluginRules/groups",schemaPath:"#/properties/pluginRules/properties/groups/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.pluginRules.properties.groups.type,parentSchema:schema12.properties.pluginRules.properties.groups,data:data11};if(vErrors === null){vErrors = [err22];}else {vErrors.push(err22);}errors++;}}}else {const err23 = {instancePath:instancePath+"/pluginRules",schemaPath:"#/properties/pluginRules/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.properties.pluginRules.type,parentSchema:schema12.properties.pluginRules,data:data4};if(vErrors === null){vErrors = [err23];}else {vErrors.push(err23);}errors++;}}if(data.info !== undefined){let data17 = data.info;if(data17 && typeof data17 == "object" && !Array.isArray(data17)){if(data17.author === undefined){const err24 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "author"},message:"must have required property '"+"author"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err24];}else {vErrors.push(err24);}errors++;}if(data17.authorUrl === undefined){const err25 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "authorUrl"},message:"must have required property '"+"authorUrl"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err25];}else {vErrors.push(err25);}errors++;}if(data17.name === undefined){const err26 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err26];}else {vErrors.push(err26);}errors++;}if(data17.description === undefined){const err27 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "description"},message:"must have required property '"+"description"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err27];}else {vErrors.push(err27);}errors++;}if(data17.domainName === undefined){const err28 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "domainName"},message:"must have required property '"+"domainName"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err28];}else {vErrors.push(err28);}errors++;}if(data17.author !== undefined){let data18 = data17.author;if(typeof data18 !== "string"){const err29 = {instancePath:instancePath+"/info/author",schemaPath:"#/definitions/ICollectionInfo/properties/author/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.author.type,parentSchema:schema13.properties.author,data:data18};if(vErrors === null){vErrors = [err29];}else {vErrors.push(err29);}errors++;}}if(data17.authorUrl !== undefined){let data19 = data17.authorUrl;if(typeof data19 !== "string"){const err30 = {instancePath:instancePath+"/info/authorUrl",schemaPath:"#/definitions/ICollectionInfo/properties/authorUrl/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.authorUrl.type,parentSchema:schema13.properties.authorUrl,data:data19};if(vErrors === null){vErrors = [err30];}else {vErrors.push(err30);}errors++;}}if(data17.name !== undefined){let data20 = data17.name;if(typeof data20 !== "string"){const err31 = {instancePath:instancePath+"/info/name",schemaPath:"#/definitions/ICollectionInfo/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.name.type,parentSchema:schema13.properties.name,data:data20};if(vErrors === null){vErrors = [err31];}else {vErrors.push(err31);}errors++;}}if(data17.description !== undefined){let data21 = data17.description;if(typeof data21 !== "string"){const err32 = {instancePath:instancePath+"/info/description",schemaPath:"#/definitions/ICollectionInfo/properties/description/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.description.type,parentSchema:schema13.properties.description,data:data21};if(vErrors === null){vErrors = [err32];}else {vErrors.push(err32);}errors++;}}if(data17.domainName !== undefined){let data22 = data17.domainName;if(typeof data22 !== "string"){const err33 = {instancePath:instancePath+"/info/domainName",schemaPath:"#/definitions/ICollectionInfo/properties/domainName/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.domainName.type,parentSchema:schema13.properties.domainName,data:data22};if(vErrors === null){vErrors = [err33];}else {vErrors.push(err33);}errors++;}}if(data17.gameVersions !== undefined){let data23 = data17.gameVersions;if(Array.isArray(data23)){const len5 = data23.length;for(let i5=0; i5<len5; i5++){let data24 = data23[i5];if(typeof data24 !== "string"){const err34 = {instancePath:instancePath+"/info/gameVersions/" + i5,schemaPath:"#/definitions/ICollectionInfo/properties/gameVersions/items/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.gameVersions.items.type,parentSchema:schema13.properties.gameVersions.items,data:data24};if(vErrors === null){vErrors = [err34];}else {vErrors.push(err34);}errors++;}}}else {const err35 = {instancePath:instancePath+"/info/gameVersions",schemaPath:"#/definitions/ICollectionInfo/properties/gameVersions/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema13.properties.gameVersions.type,parentSchema:schema13.properties.gameVersions,data:data23};if(vErrors === null){vErrors = [err35];}else {vErrors.push(err35);}errors++;}}}else {const err36 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema13.type,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err36];}else {vErrors.push(err36);}errors++;}}if(data.mods !== undefined){let data25 = data.mods;if(Array.isArray(data25)){const len6 = data25.length;for(let i6=0; i6<len6; i6++){if(!(validate12(data25[i6], {instancePath:instancePath+"/mods/" + i6,parentData:data25,parentDataProperty:i6,rootData}))){vErrors = vErrors === null ? validate12.errors : vErrors.concat(validate12.errors);errors = vErrors.length;}}}else {const err37 = {instancePath:instancePath+"/mods",schemaPath:"#/properties/mods/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.mods.type,parentSchema:schema12.properties.mods,data:data25};if(vErrors === null){vErrors = [err37];}else {vErrors.push(err37);}errors++;}}if(data.modRules !== undefined){let data27 = data.modRules;if(Array.isArray(data27)){const len7 = data27.length;for(let i7=0; i7<len7; i7++){if(!(validate16(data27[i7], {instancePath:instancePath+"/modRules/" + i7,parentData:data27,parentDataProperty:i7,rootData}))){vErrors = vErrors === null ? validate16.errors : vErrors.concat(validate16.errors);errors = vErrors.length;}}}else {const err38 = {instancePath:instancePath+"/modRules",schemaPath:"#/properties/modRules/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.modRules.type,parentSchema:schema12.properties.modRules,data:data27};if(vErrors === null){vErrors = [err38];}else {vErrors.push(err38);}errors++;}}}else {const err39 = {instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.type,parentSchema:schema12,data};if(vErrors === null){vErrors = [err39];}else {vErrors.push(err39);}errors++;}validate11.errors = vErrors;return errors === 0;}function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;const _errs0 = errors;let valid0 = false;const _errs1 = errors;if(!(validate11(data, {instancePath,parentData,parentDataProperty,rootData}))){vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);errors = vErrors.length;}var _valid0 = _errs1 === errors;valid0 = valid0 || _valid0;if(!valid0){const err0 = {instancePath,schemaPath:"#/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf",schema:schema11.anyOf,parentSchema:schema11,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}else {errors = _errs0;if(vErrors !== null){if(_errs0){vErrors.length = _errs0;}else {vErrors = null;}}}validate10.errors = vErrors;return errors === 0;}


/***/ }),

/***/ "./src/validationCode/dummy.js":
/*!*************************************!*\
  !*** ./src/validationCode/dummy.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

function dummyFunc() {
    console.error('Standalone validation code relies on AJV module; validation may fail');
    return;
}
exports["default"] = dummyFunc;

/***/ }),

/***/ "./src/validationCode/validation.ts":
/*!******************************************!*\
  !*** ./src/validationCode/validation.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateICollection = void 0;
const ICollection_validate_1 = __webpack_require__(/*! ./ICollection.validate */ "./src/validationCode/ICollection.validate.js");
function validateICollection(data) {
    var res = (0, ICollection_validate_1.default)(data);
    return (res === false) ? ICollection_validate_1.default.prototype.constructor.errors : [];
}
exports.validateICollection = validateICollection;


/***/ }),

/***/ "./src/views/AddModsDialog.tsx":
/*!*************************************!*\
  !*** ./src/views/AddModsDialog.tsx ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const react_1 = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const session_1 = __webpack_require__(/*! ../actions/session */ "./src/actions/session.ts");
const collectionCreate_1 = __webpack_require__(/*! ../collectionCreate */ "./src/collectionCreate.ts");
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
function makeColumns(onSelect) {
    let collator;
    return [
        {
            id: 'name',
            name: 'Mod Name',
            description: 'Mod Name',
            calc: (mod) => vortex_api_1.util.renderModName(mod.mod),
            placement: 'table',
            edit: {},
            isDefaultSort: true,
            isSortable: true,
            filter: new vortex_api_1.TableTextFilter(true),
            sortFunc: (lhs, rhs, locale) => {
                if (collator === undefined) {
                    collator = new Intl.Collator(locale, { sensitivity: 'base' });
                }
                return collator.compare(lhs, rhs);
            },
        }, {
            id: 'variant',
            name: 'Variant',
            description: 'The variant',
            calc: (mod) => { var _a, _b; return (_b = (_a = mod.mod.attributes) === null || _a === void 0 ? void 0 : _a.variant) !== null && _b !== void 0 ? _b : ''; },
            placement: 'table',
            edit: {},
        }, {
            id: 'version',
            name: 'Version',
            description: 'The version',
            calc: (mod) => { var _a, _b; return (_b = (_a = mod.mod.attributes) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : ''; },
            placement: 'table',
            edit: {},
        },
    ];
}
function AddModsDialog(props) {
    var _a;
    const { onAddSelection } = props;
    const { t } = (0, react_i18next_1.useTranslation)(constants_1.NAMESPACE);
    const store = (0, react_redux_1.useStore)();
    const dispatch = (0, react_redux_1.useDispatch)();
    const hide = React.useCallback(() => {
        dispatch((0, session_1.startAddModsToCollection)(undefined));
    }, []);
    const [selection, setSelection] = (0, react_1.useState)(new Set());
    const state = store.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const collectionId = (0, react_redux_1.useSelector)(stateSel => stateSel.session.collections.addModsId);
    const collection = collectionId !== undefined
        ? (_a = state.persistent.mods[gameId]) === null || _a === void 0 ? void 0 : _a[collectionId]
        : undefined;
    const mods = state.persistent.mods[gameId];
    const modsWithState = React.useMemo(() => Object.keys(mods !== null && mods !== void 0 ? mods : {})
        .reduce((prev, modId) => {
        if (!(0, collectionCreate_1.alreadyIncluded)(collection === null || collection === void 0 ? void 0 : collection.rules, modId)
            && (mods[modId].type !== constants_1.MOD_TYPE)) {
            prev[modId] = {
                selected: selection.has(modId),
                mod: mods[modId],
            };
        }
        return prev;
    }, {}), [selection, collectionId]);
    const changeSelection = React.useCallback((modIds, selected) => {
        if (selected) {
            setSelection(new Set([].concat(Array.from(selection), modIds)));
        }
        else {
            setSelection(new Set(Array.from(selection).filter(modId => !modIds.includes(modId))));
        }
    }, [selection, setSelection, collectionId]);
    const columns = React.useMemo(() => makeColumns(changeSelection), [selection, setSelection, collectionId]);
    const addSelection = React.useCallback(() => {
        onAddSelection(collectionId, Array.from(selection));
        hide();
    }, [onAddSelection, hide, selection, collectionId]);
    const updateSelection = React.useCallback((modIds) => {
        setSelection(new Set(modIds));
    }, [setSelection]);
    const TableX = vortex_api_1.Table;
    return (React.createElement(vortex_api_1.Modal, { id: 'add-mods-to-collection-dialog', className: 'collection-add-mods-dialog', show: collection !== undefined, onHide: hide },
        React.createElement(vortex_api_1.Modal.Header, null,
            React.createElement(vortex_api_1.Modal.Title, null, vortex_api_1.util.renderModName(collection))),
        React.createElement(vortex_api_1.Modal.Body, null, (Object.keys(modsWithState).length > 0)
            ? (React.createElement(React.Fragment, null,
                t('Select (click, shift-click, ...) installed mods you want to add to your collection below:'),
                React.createElement(TableX, { tableId: 'collection-add-mods', data: modsWithState, staticElements: columns, actions: [], showDetails: false, hasActions: false, onChangeSelection: updateSelection }))) : (React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'folder-download', fill: true, text: t('You don\'t have any installed mods') }))),
        React.createElement(vortex_api_1.Usage, { persistent: true, infoId: 'add-mods-from-mods-page' },
            React.createElement("p", null, t('You can also add mods to a collection from the mods screen: '
                + 'Right-click > Add to Collection')),
            React.createElement("p", null, t('Mods need to be in an installed state in order to add them to a collection. '
                + 'If the mod you want to add is not in this list, make sure it\'s installed.'))),
        React.createElement(vortex_api_1.Modal.Footer, null,
            React.createElement(react_bootstrap_1.Button, { onClick: hide }, t('Close')),
            React.createElement(react_bootstrap_1.Button, { onClick: addSelection }, t('Add Selection')))));
}
exports["default"] = React.memo(AddModsDialog);


/***/ }),

/***/ "./src/views/CollectionList/StartPage.tsx":
/*!************************************************!*\
  !*** ./src/views/CollectionList/StartPage.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const settings_1 = __webpack_require__(/*! ../../actions/settings */ "./src/actions/settings.ts");
const collectionCreate_1 = __webpack_require__(/*! ../../collectionCreate */ "./src/collectionCreate.ts");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const transformCollection_1 = __webpack_require__(/*! ../../util/transformCollection */ "./src/util/transformCollection.ts");
const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
const RemoteTile_1 = __webpack_require__(/*! ../CollectionTile/RemoteTile */ "./src/views/CollectionTile/RemoteTile.tsx");
const _ = __webpack_require__(/*! lodash */ "lodash");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const react_select_1 = __webpack_require__(/*! react-select */ "react-select");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const FEEDBACK_URL = 'https://docs.google.com/forms/d/e/1FAIpQLSc3csy4ycVBECvHQDgri37Gqq1gOuTQ7LcpiIaOkGHpDsW4kA/viewform?usp=sf_link';
const BUG_REPORT_URL = 'https://docs.google.com/forms/d/e/1FAIpQLSdmDBdGjTQVRa7wRouN4yP6zMvqsxTT86R-DwmQXZq7SWGCSg/viewform?usp=sf_link';
function dateCompare(lhs, rhs) {
    return (new Date(lhs !== null && lhs !== void 0 ? lhs : 0)).getTime() - (new Date(rhs !== null && rhs !== void 0 ? rhs : 0)).getTime();
}
const nop = () => null;
const validRE = /^[\p{L}\p{N} -]*$/u;
function validateCollectionName(t, input) {
    if ((input.length < constants_1.MIN_COLLECTION_NAME_LENGTH) || (input.length > constants_1.MAX_COLLECTION_NAME_LENGTH)) {
        return t('The name bust be between {{min}}-{{max}} characters long', {
            replace: {
                min: constants_1.MIN_COLLECTION_NAME_LENGTH,
                max: constants_1.MAX_COLLECTION_NAME_LENGTH,
            },
        });
    }
    if (input.match(validRE) === null) {
        return t('Invalid characters, only letters, numbers, space and - are allowed.');
    }
    return undefined;
}
function AddCard(props) {
    const { t, onClick } = props;
    const classes = ['collection-add-btn'];
    return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' '), bsStyle: 'default', onClick: onClick },
        React.createElement(react_bootstrap_1.Panel.Body, { className: 'collection-thumbnail-body' },
            React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'folder-add', text: t('Discover more collections') }))));
}
function CreateCard(props) {
    const { t, onTrackClick } = props;
    const classes = ['collection-add-btn'];
    const actions = React.useRef([]);
    React.useEffect(() => {
        actions.current = [
            {
                title: 'From Profile',
                icon: 'profile',
                action: () => {
                    onTrackClick('Collections', 'From profile');
                    props.onCreateFromProfile();
                },
            }, {
                title: 'Empty',
                icon: 'show',
                action: () => {
                    onTrackClick('Collections', 'Empty');
                    props.onCreateEmpty();
                },
            }, {
                title: 'Quick Collection',
                icon: 'highlight-lab',
                action: () => {
                    onTrackClick('Collections', 'Quick Collection');
                    props.onCreateQuickCollection();
                },
            },
        ];
    }, [props.onCreateFromProfile, props.onCreateEmpty, props.onCreateQuickCollection]);
    return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' '), bsStyle: 'default' },
        React.createElement(react_bootstrap_1.Panel.Body, { className: 'collection-thumbnail-body' },
            React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'add', text: t('Create a collection'), fill: true }),
            React.createElement("div", { className: 'hover-menu' },
                React.createElement("div", { key: 'primary-buttons', className: 'hover-content' },
                    React.createElement(vortex_api_1.IconBar, { className: 'buttons', group: 'collection-actions', staticElements: actions.current, collapse: false, buttonType: 'text', orientation: 'vertical', clickAnywhere: true, t: t }))))));
}
class StartPage extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.setSortAdded = (value) => {
            if (!!value) {
                this.props.onSetSortAdded(value.value);
            }
        };
        this.setSortWorkshop = (value) => {
            if (!!value) {
                this.props.onSetSortWorkshop(value.value);
            }
        };
        this.setActiveTab = (tabId) => {
            this.props.onSetActiveTab(tabId);
            this.context.api.events.emit('analytics-track-navigation', `collections/${tabId}`);
        };
        this.openCollections = () => {
            const { game } = this.props;
            this.context.api.events.emit('analytics-track-click-event', 'Collections', 'Discover more');
            vortex_api_1.util.opn(`${constants_1.NEXUS_BASE_GAMES_URL}/${vortex_api_1.util.nexusGameId(game)}/collections`).catch(() => null);
        };
        this.openMyCollectionsPage = () => {
            this.context.api.events.emit('analytics-track-click-event', 'Collections', 'Open My Collections');
            vortex_api_1.util.opn(`${constants_1.NEXUS_BASE_URL}/my-collections`).catch(() => null);
        };
        this.trackEvent = (namespace, eventName) => {
            this.context.api.events.emit('analytics-track-click-event', namespace, eventName);
        };
        this.openFeedback = () => {
            vortex_api_1.util.opn(FEEDBACK_URL).catch(() => null);
        };
        this.openBugReport = () => {
            vortex_api_1.util.opn(BUG_REPORT_URL).catch(() => null);
        };
        this.quickCollection = async () => {
            try {
                await (0, collectionCreate_1.initFromProfile)(this.context.api);
                this.refreshImages();
            }
            catch (err) {
                if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                    this.context.api.showErrorNotification('Failed to create quick collection', err);
                }
            }
        };
        this.fromProfile = async () => {
            const { profile } = this.props;
            try {
                await (0, collectionCreate_1.initFromProfile)(this.context.api, profile.id);
                this.refreshImages();
            }
            catch (err) {
                if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                    this.context.api.showErrorNotification('Failed to init collection', err);
                }
            }
        };
        this.fromEmpty = async () => {
            const { t, onCreateCollection } = this.props;
            try {
                const result = await this.context.api.showDialog('question', 'New empty Collection', {
                    text: 'Create an empty collection which you can manually add mods to.',
                    input: [{ id: 'name', label: 'Collection Name', type: 'text' }],
                    condition: content => (0, transformCollection_1.validateName)(t, content),
                }, [
                    { label: 'Cancel' },
                    { label: 'Create', default: true },
                ]);
                if (result.action === 'Create') {
                    await onCreateCollection(result.input['name']);
                    this.refreshImages();
                }
            }
            catch (err) {
                this.context.api.showErrorNotification('Failed to init collection', err);
            }
        };
        this.initState({
            createOpen: false,
            imageTime: Date.now(),
            mousePosition: { x: 0, y: 0 },
            collectionsEx: { added: [], workshop: [] },
        });
    }
    componentDidMount() {
        const collectionsNow = Object.values(this.props.mods).filter(mod => mod.type === constants_1.MOD_TYPE);
        this.updateSorted(collectionsNow, this.props.sortAdded, this.props.sortWorkshop, false)
            .then(() => this.updateSorted(collectionsNow, this.props.sortAdded, this.props.sortWorkshop, false))
            .catch(err => {
            (0, vortex_api_1.log)('error', 'failed to update list of collections', {
                error: err.message,
            });
        });
    }
    componentDidUpdate(prevProps, prevState) {
        const collectionsPrev = Object.values(prevProps.mods).filter(mod => mod.type === constants_1.MOD_TYPE);
        const collectionsNow = Object.values(this.props.mods).filter(mod => mod.type === constants_1.MOD_TYPE);
        if (!_.isEqual(collectionsPrev, collectionsNow)
            || (prevProps.sortAdded !== this.props.sortAdded)
            || (prevProps.sortWorkshop !== this.props.sortWorkshop)
            || (prevProps.localState.ownCollections !== this.props.localState.ownCollections)) {
            this.updateSorted(collectionsNow, this.props.sortAdded, this.props.sortWorkshop, true);
        }
    }
    render() {
        const { t, activeTab, installing, profile, matchedReferences, mods, onClone, onEdit, onPause, onInstallCollection, onRemove, onResume, onUpdate, onUpload, onView, sortAdded, sortWorkshop } = this.props;
        const { imageTime, collectionsEx } = this.state;
        const { added, workshop } = collectionsEx;
        return (React.createElement(react_bootstrap_1.Tabs, { id: 'collection-start-page', activeKey: activeTab, onSelect: this.setActiveTab },
            React.createElement(react_bootstrap_1.Tab, { tabClassName: 'collection-tab', eventKey: 'active-collections', title: React.createElement(React.Fragment, null,
                    React.createElement(vortex_api_1.Icon, { name: 'add' }),
                    t('Added Collections')) },
                React.createElement(react_bootstrap_1.Panel, null,
                    React.createElement(react_bootstrap_1.Panel.Heading, null,
                        React.createElement(react_bootstrap_1.Panel.Title, null, t('View and manage collections created by other users.')),
                        React.createElement("div", { className: 'flex-fill' }),
                        React.createElement("div", { className: 'collection-sort-container' },
                            t('Sort by:'),
                            React.createElement(react_select_1.default, { className: 'select-compact', options: [
                                    { value: 'alphabetical', label: t('Name A-Z') },
                                    { value: 'datedownloaded', label: t('Date downloaded') },
                                    { value: 'recentlyupdated', label: t('Recently updated') },
                                ], value: sortAdded, onChange: this.setSortAdded, clearable: false, autosize: false, searchable: false }))),
                    React.createElement(react_bootstrap_1.Panel.Body, null,
                        React.createElement("div", { className: 'collection-list' },
                            React.createElement(AddCard, { t: t, onClick: this.openCollections }),
                            added.map(mod => {
                                var _a, _b;
                                return React.createElement(CollectionTile_1.default, { key: mod.mod.id, t: t, gameId: profile.gameId, imageTime: imageTime, installing: installing, mods: mods, incomplete: (_b = (_a = matchedReferences[mod.mod.id]) === null || _a === void 0 ? void 0 : _a.includes) === null || _b === void 0 ? void 0 : _b.call(_a, null), collection: mod.mod, infoCache: this.props.infoCache, onView: onView, onRemove: onRemove, onResume: onResume, onPause: onPause, onUpdate: onUpdate, details: true });
                            }))))),
            React.createElement(react_bootstrap_1.Tab, { tabClassName: 'collection-tab', eventKey: 'collection-workshop', title: React.createElement(React.Fragment, null,
                    React.createElement(vortex_api_1.Icon, { name: 'highlight-tool' }),
                    t('Workshop')) },
                React.createElement(react_bootstrap_1.Panel, null,
                    React.createElement(react_bootstrap_1.Panel.Heading, null,
                        React.createElement(react_bootstrap_1.Panel.Title, null,
                            React.createElement(react_i18next_1.Trans, { ns: constants_1.NAMESPACE, i18nKey: 'collection-own-page' },
                                "Build your own collections and share them with the Nexus Mods community. You can view all your uploaded collections\u00A0",
                                React.createElement("a", { onClick: this.openMyCollectionsPage, className: 'my-collections-page-link', title: t('Open My Collections Page') }, "here."))),
                        React.createElement("div", { className: 'flex-fill' }),
                        React.createElement("div", { className: 'collection-sort-container' },
                            t('Sort by:'),
                            React.createElement(react_select_1.default, { className: 'select-compact', options: [
                                    { value: 'alphabetical', label: t('Name A-Z') },
                                    { value: 'datecreated', label: t('Date created') },
                                    { value: 'recentlyupdated', label: t('Recently updated') },
                                ], value: sortWorkshop, onChange: this.setSortWorkshop, clearable: false, autosize: false, searchable: false }))),
                    React.createElement(react_bootstrap_1.Panel.Body, null,
                        React.createElement("div", { className: 'collection-list' },
                            React.createElement(CreateCard, { t: t, onCreateFromProfile: this.fromProfile, onCreateQuickCollection: this.quickCollection, onCreateEmpty: this.fromEmpty, onTrackClick: this.trackEvent }),
                            workshop.map(mod => {
                                var _a, _b, _c, _d;
                                return (mod.mod !== undefined)
                                    ? (React.createElement(CollectionTile_1.default, { t: t, key: mod.mod.id, gameId: profile.gameId, collection: mod.mod, infoCache: this.props.infoCache, imageTime: imageTime, mods: mods, incomplete: (mod.mod === undefined)
                                            || ((_b = (_a = matchedReferences[mod.mod.id]) === null || _a === void 0 ? void 0 : _a.includes) === null || _b === void 0 ? void 0 : _b.call(_a, null)), onEdit: onEdit, onRemove: onRemove, onUpload: onUpload, details: true })) : (React.createElement(RemoteTile_1.default, { t: t, key: mod.revision.id, revision: mod.revision, added: mod.added, incomplete: (mod.added === undefined)
                                        || ((_d = (_c = matchedReferences[mod.added.id]) === null || _c === void 0 ? void 0 : _c.includes) === null || _d === void 0 ? void 0 : _d.call(_c, null)), onInstallCollection: onInstallCollection, onCloneCollection: onClone, onResumeCollection: onResume }));
                            })))))));
    }
    name(input) {
        var _a, _b, _c;
        return (input.mod !== undefined)
            ? vortex_api_1.util.renderModName(input.mod)
            : ((_c = (_b = (_a = input.revision) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : '');
    }
    sorter(sorting) {
        var _a;
        const alphabetical = (lhs, rhs) => this.name(lhs).localeCompare(this.name(rhs));
        return (_a = {
            alphabetical,
            datedownloaded: (lhs, rhs) => { var _a, _b, _c, _d; return dateCompare((_b = (_a = rhs.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.installTime, (_d = (_c = lhs.mod) === null || _c === void 0 ? void 0 : _c.attributes) === null || _d === void 0 ? void 0 : _d.installTime); },
            datecreated: (lhs, rhs) => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                return dateCompare((_c = (_b = (_a = rhs.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.installTime) !== null && _c !== void 0 ? _c : (_d = rhs.revision) === null || _d === void 0 ? void 0 : _d.createdAt, (_g = (_f = (_e = lhs.mod) === null || _e === void 0 ? void 0 : _e.attributes) === null || _f === void 0 ? void 0 : _f.installTime) !== null && _g !== void 0 ? _g : (_h = lhs.revision) === null || _h === void 0 ? void 0 : _h.createdAt);
            },
            recentlyupdated: (lhs, rhs) => {
                var _a, _b, _c, _d, _e, _f;
                return dateCompare((_b = (_a = rhs.revision) === null || _a === void 0 ? void 0 : _a.updatedAt) !== null && _b !== void 0 ? _b : (_c = rhs.mod.attributes) === null || _c === void 0 ? void 0 : _c.installTime, (_e = (_d = lhs.revision) === null || _d === void 0 ? void 0 : _d.updatedAt) !== null && _e !== void 0 ? _e : (_f = lhs.mod.attributes) === null || _f === void 0 ? void 0 : _f.installTime);
            },
        }[sorting]) !== null && _a !== void 0 ? _a : alphabetical;
    }
    updateSorted(collections, sortAdded, sortWorkshop, allowMetaUpdate) {
        return Promise.all(collections.map(async (mod) => {
            var _a;
            const { revisionId, collectionSlug, revisionNumber } = (_a = mod.attributes) !== null && _a !== void 0 ? _a : {};
            const revision = revisionNumber !== undefined
                ? await this.props.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber, allowMetaUpdate ? 'allow' : 'avoid')
                : undefined;
            return { mod, revision };
        }))
            .then((result) => {
            let { foreign, own } = result.reduce((prev, mod) => {
                if (vortex_api_1.util.getSafe(mod.mod.attributes, ['editable'], false)) {
                    prev.own.push(mod);
                }
                else {
                    prev.foreign.push(mod);
                }
                return prev;
            }, { foreign: [], own: [] });
            const installed = new Set(own.map(res => { var _a; return (_a = res.mod.attributes) === null || _a === void 0 ? void 0 : _a['collectionSlug']; }));
            own.push(...this.props.localState.ownCollections
                .filter(coll => { var _a; return !installed.has((_a = coll.collection) === null || _a === void 0 ? void 0 : _a.slug); })
                .map(coll => {
                var _a;
                return ({
                    mod: undefined,
                    added: (_a = foreign.find(iter => { var _a, _b, _c; return ((_b = (_a = iter.revision) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.slug) === ((_c = coll.collection) === null || _c === void 0 ? void 0 : _c.slug); })) === null || _a === void 0 ? void 0 : _a.mod,
                    revision: coll,
                });
            }));
            foreign = foreign.sort(this.sorter(sortAdded));
            own = own.sort(this.sorter(sortWorkshop));
            this.nextState.collectionsEx = { added: foreign, workshop: own };
        });
    }
    refreshImages() {
        this.nextState.imageTime = Date.now();
    }
}
function mapStateToProps(state) {
    var _a, _b, _c;
    return {
        userInfo: (_a = state.persistent['nexus']) === null || _a === void 0 ? void 0 : _a.userInfo,
        sortAdded: (_b = state.settings.collections.sortAdded) !== null && _b !== void 0 ? _b : 'datedownloaded',
        sortWorkshop: (_c = state.settings.collections.sortWorkshop) !== null && _c !== void 0 ? _c : 'recentlyupdated',
    };
}
function mapDispatchToProps(dispatch) {
    return {
        onSetSortAdded: (sorting) => dispatch((0, settings_1.setSortAdded)(sorting)),
        onSetSortWorkshop: (sorting) => dispatch((0, settings_1.setSortWorkshop)(sorting)),
    };
}
exports["default"] = (0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(StartPage);


/***/ }),

/***/ "./src/views/CollectionList/index.tsx":
/*!********************************************!*\
  !*** ./src/views/CollectionList/index.tsx ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const persistent_1 = __webpack_require__(/*! ../../actions/persistent */ "./src/actions/persistent.ts");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const extension_1 = __webpack_require__(/*! ../../util/extension */ "./src/util/extension.ts");
const CollectionPageEdit_1 = __webpack_require__(/*! ../CollectionPageEdit */ "./src/views/CollectionPageEdit/index.tsx");
const CollectionPageView_1 = __webpack_require__(/*! ../CollectionPageView */ "./src/views/CollectionPageView/index.tsx");
const StartPage_1 = __webpack_require__(/*! ./StartPage */ "./src/views/CollectionList/StartPage.tsx");
const React = __webpack_require__(/*! react */ "react");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
const emptyObj = {};
const emptyArr = [];
class CollectionsMainPage extends vortex_api_1.ComponentEx {
    constructor(props) {
        var _a;
        super(props);
        this.onUpdateMeta = () => {
            this.props.onUpdateMeta();
            this.context.api.events.emit('analytics-track-click-event', 'Collections', 'Refresh');
        };
        this.setActiveTab = (tabId) => {
            this.nextState.activeTab = tabId;
        };
        this.createCollection = (name) => {
            const { profile, onCreateCollection } = this.props;
            onCreateCollection(profile, name);
        };
        this.deselectCollection = () => {
            this.nextState.selectedCollection = undefined;
        };
        this.resetMainPage = () => {
            this.deselectCollection();
        };
        this.view = (modId) => {
            this.showPage('view', modId);
        };
        this.edit = async (modId) => {
            var _a, _b;
            const { mods, userInfo } = this.props;
            const { api } = this.context;
            if (mods[modId] === undefined) {
                return;
            }
            const author = (_a = mods[modId].attributes) === null || _a === void 0 ? void 0 : _a['uploaderId'];
            if ((author !== undefined) && (author !== (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId))) {
                const result = await api.showDialog('question', 'Edit Collection', {
                    text: 'This collection has been uploaded with a different account ({{uploadAuthor}}) '
                        + 'than you\'re using now ({{currentUser}}). '
                        + 'If you edit and upload this collection now it will be uploaded as a new '
                        + 'collection by your current user.',
                    parameters: {
                        uploadAuthor: mods[modId].attributes['uploader'],
                        currentUser: (_b = userInfo === null || userInfo === void 0 ? void 0 : userInfo.name) !== null && _b !== void 0 ? _b : '<Logged out>',
                    },
                }, [
                    { label: 'Cancel' },
                    { label: 'Continue' },
                ]);
                if (result.action === 'Cancel') {
                    return;
                }
            }
            this.showPage('edit', modId);
        };
        this.pause = async (modId, silent) => {
            var _a;
            const { downloads, mods } = this.props;
            const collection = mods[modId];
            if (collection === undefined) {
                return;
            }
            ((_a = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _a !== void 0 ? _a : []).forEach(rule => {
                const dlId = vortex_api_1.util.findDownloadByRef(rule.reference, downloads);
                if (dlId !== undefined) {
                    this.context.api.events.emit('pause-download', dlId);
                }
            });
            const { api } = this.context;
            await api.emitAndAwait('cancel-dependency-install', modId);
            this.props.driver.cancel();
            api.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + modId);
            if (silent !== true) {
                api.sendNotification({
                    id: 'collection-pausing',
                    type: 'success',
                    title: 'Collection pausing',
                    message: 'Already queued mod installations will still finish',
                });
            }
        };
        this.clone = async (collectionId) => {
            const id = await this.props.onCloneCollection(collectionId);
            if (id !== undefined) {
                this.showPage('edit', id);
            }
        };
        this.cancel = async (modId, cancel) => {
            const { profile } = this.props;
            return this.props.onRemoveCollection(profile.gameId, modId, cancel !== null && cancel !== void 0 ? cancel : true);
        };
        this.voteSuccess = async (modId, success) => {
            const { mods } = this.props;
            const { api } = this.context;
            const collection = mods[modId];
            if (collection === undefined) {
                return;
            }
            const { revisionId } = collection.attributes;
            if (revisionId === undefined) {
                return;
            }
            const vote = success ? 'positive' : 'negative';
            const voted = (await api.emitAndAwait('rate-nexus-collection-revision', parseInt(revisionId, 10), vote))[0];
            if (voted.success) {
                api.store.dispatch((0, persistent_1.updateSuccessRate)(revisionId, vote, voted.averageRating.average, voted.averageRating.total));
            }
        };
        this.remove = (modId) => {
            var _a, _b;
            const { mods } = this.props;
            const { api } = this.context;
            if (mods[modId] === undefined) {
                return;
            }
            try {
                if ((_b = (_a = mods[modId]) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.editable) {
                    api.events.emit('analytics-track-click-event', 'Collections', 'Remove Workshop Collection');
                    return this.removeWorkshop(modId)
                        .catch(err => {
                        const allowReport = !['EPERM'].includes(err.code)
                            && !(err instanceof vortex_api_1.util.ProcessCanceled)
                            && !(err instanceof vortex_api_1.util.UserCanceled);
                        api.showErrorNotification('Failed to remove collection', err, { allowReport });
                    });
                }
                else {
                    api.events.emit('analytics-track-click-event', 'Collections', 'Remove Added Collection');
                    return this.cancel(modId, false)
                        .catch(err => {
                        api.showErrorNotification('Failed to remove collection', err, {
                            allowReport: !['EPERM'].includes(err.code),
                        });
                    });
                }
            }
            catch (err) {
                if (err instanceof vortex_api_1.util.UserCanceled) {
                    (0, vortex_api_1.log)('info', 'collection removal canceled by user');
                }
                else if (err instanceof vortex_api_1.util.ProcessCanceled) {
                    api.sendNotification({
                        type: 'warning',
                        title: 'Removal failed',
                        message: err.message,
                    });
                }
                else {
                    api.showErrorNotification('Failed to remove collection', err);
                }
            }
        };
        this.update = async (collectionId) => {
            const { mods } = this.props;
            const { api } = this.context;
            const state = api.getState();
            const gameMode = vortex_api_1.selectors.activeGameId(state);
            const mod = mods[collectionId];
            if (mod === undefined) {
                return;
            }
            const downloadGame = vortex_api_1.util.getSafe(mod.attributes, ['downloadGame'], gameMode);
            const newestFileId = vortex_api_1.util.getSafe(mod.attributes, ['newestVersion'], undefined);
            await vortex_api_1.util.toPromise(cb => {
                var _a, _b;
                return this.context.api.events.emit('collection-update', downloadGame, (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.collectionSlug, newestFileId, (_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.source, collectionId, cb);
            });
        };
        this.upload = async (collectionId) => {
            var _a;
            (0, util_1.uploadCollection)(this.context.api, (_a = this.props.profile) === null || _a === void 0 ? void 0 : _a.id, collectionId);
        };
        this.installManually = (collectionId, rules) => {
            const { api } = this.context;
            const ruleGroups = rules.reduce((prev, rule) => {
                if (prev[rule.type] !== undefined) {
                    prev[rule.type].push(rule);
                }
                else {
                    (0, vortex_api_1.log)('error', 'unexpected rule encountered', { collectionId, ruleType: rule.type });
                }
                return prev;
            }, { requires: [], recommends: [] });
            const eaa = (ruleList, recommended) => {
                if (ruleList.length === 0) {
                    return Promise.resolve();
                }
                else {
                    return api.emitAndAwait('install-from-dependencies', collectionId, ruleList, recommended);
                }
            };
            eaa(ruleGroups.requires, false)
                .then(() => eaa(ruleGroups.recommends, true))
                .catch(err => {
                if (err instanceof vortex_api_1.util.UserCanceled) {
                    return;
                }
                api.showErrorNotification('Failed to install dependencies', err, {
                    allowReport: !(err instanceof vortex_api_1.util.ProcessCanceled),
                });
            });
        };
        this.resume = async (modId) => {
            const { driver, mods, profile, userInfo } = this.props;
            if (mods[modId] === undefined) {
                return;
            }
            if ((userInfo === null) || (userInfo === undefined)) {
                const { api } = this.context;
                api.showDialog('info', 'Not logged in', {
                    text: 'You have to be logged in with Nexus Mods to install collections.',
                }, [{ label: 'Continue' }]);
            }
            else if (mods[modId] !== undefined) {
                driver.start(profile, mods[modId]);
            }
        };
        this.initState({
            selectedCollection: undefined,
            matchedReferences: this.updateMatchedReferences(this.props),
            viewMode: 'view',
            activeTab: 'active-collections',
        });
        if (props.onAddCallback !== undefined) {
            props.onAddCallback('viewCollection', (collectionId) => {
                this.showPage('view', collectionId);
            });
            props.onAddCallback('editCollection', () => (collectionId) => {
                this.showPage('edit', collectionId);
            });
        }
        (_a = props.resetCB) === null || _a === void 0 ? void 0 : _a.call(props, this.resetMainPage);
        this.mMatchRefDebouncer = new vortex_api_1.util.Debouncer(() => {
            this.nextState.matchedReferences = this.updateMatchedReferences(this.props);
            return Promise.resolve();
        }, 2000);
    }
    UNSAFE_componentWillReceiveProps(newProps) {
        if (this.props.mods !== newProps.mods) {
            this.mMatchRefDebouncer.schedule();
        }
    }
    componentWillUnmount() {
        this.mMatchRefDebouncer.clear();
    }
    render() {
        const { t, downloads, driver, game, localState, mods, notifications, profile, pathTool } = this.props;
        const { activeTab, matchedReferences, selectedCollection, viewMode } = this.state;
        if (profile === undefined) {
            return null;
        }
        const collection = (selectedCollection !== undefined)
            ? mods[selectedCollection]
            : undefined;
        let content = null;
        if (collection === undefined) {
            content = (React.createElement(React.Fragment, null,
                React.createElement(vortex_api_1.tooltip.IconButton, { className: 'collections-refresh-meta', icon: 'refresh', tooltip: t('Download the latest meta information about your installed and owned collections. '
                        + 'This will reset local changes to names of collections in your workshop.'), onClick: this.onUpdateMeta }, t('Refresh')),
                React.createElement(StartPage_1.default, { t: t, game: game, localState: localState, installing: driver.installDone ? undefined : driver.collection, infoCache: driver.infoCache, profile: profile, mods: mods, matchedReferences: matchedReferences !== null && matchedReferences !== void 0 ? matchedReferences : emptyObj, activeTab: activeTab, onView: this.view, onEdit: this.edit, onRemove: this.remove, onUpdate: this.update, onUpload: this.upload, onClone: this.clone, onCreateCollection: this.createCollection, onResume: this.resume, onPause: this.pause, onSetActiveTab: this.setActiveTab, onInstallCollection: this.props.onInstallCollection })));
        }
        else {
            content = (React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                    React.createElement(vortex_api_1.tooltip.IconButton, { className: 'collection-back-btn', tooltip: 'Return to overview', icon: 'nav-back', onClick: this.deselectCollection }, t('View All Collections'))),
                React.createElement(vortex_api_1.FlexLayout.Flex, null, (viewMode === 'view') ? (React.createElement(CollectionPageView_1.default, { t: t, className: 'collection-details', driver: this.props.driver, profile: profile, collection: collection, mods: mods, downloads: downloads, notifications: notifications, onAddCallback: this.props.onAddCallback, onView: this.view, onPause: this.pause, onCancel: this.cancel, onClone: this.clone, onResume: this.resume, onInstallManually: this.installManually, onVoteSuccess: this.voteSuccess }))
                    : (React.createElement(CollectionPageEdit_1.default, { profile: profile, collection: collection, mods: mods, driver: this.props.driver, onRemove: this.remove, onUpload: this.upload, exts: this.props.exts, pathTool: pathTool })))));
        }
        return (React.createElement(vortex_api_1.MainPage, { id: 'collection-page' },
            React.createElement(vortex_api_1.MainPage.Body, null, content)));
    }
    showPage(page, modId) {
        this.nextState.selectedCollection = modId;
        this.nextState.viewMode = page;
    }
    async removeWorkshop(modId) {
        const { mods, profile } = this.props;
        const { api } = this.context;
        const result = await api.showDialog('question', 'Remove Collection (Workshop)', {
            text: 'Deleting a collection will not remove the mods that have been added to it.\n\n'
                + 'Any changes made to this collection since the last upload to Nexus Mods will '
                + 'be lost.\n\n'
                + 'Are you sure you want to remove "{{collectionName}}" from your Workshop?',
            parameters: {
                collectionName: vortex_api_1.util.renderModName(mods[modId]),
            },
        }, [
            { label: 'Cancel' },
            { label: 'Remove' },
        ]);
        if (result.action === 'Remove') {
            await vortex_api_1.util.toPromise(cb => api.events.emit('remove-mod', profile.gameId, modId, cb, {
                incomplete: true,
            }));
        }
    }
    updateMatchedReferences(props) {
        const { mods, profile } = props;
        const collections = Object.values(mods).filter(mod => mod.type === constants_1.MOD_TYPE);
        return collections.reduce((prev, collection) => {
            prev[collection.id] =
                (collection.rules || [])
                    .filter(rule => (rule.type === 'requires') && !rule['ignored'])
                    .map(rule => {
                    var _a, _b;
                    const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
                    if ((mod !== undefined) && !((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[mod.id]) === null || _b === void 0 ? void 0 : _b.enabled)) {
                        return null;
                    }
                    return mod !== null && mod !== void 0 ? mod : null;
                });
            return prev;
        }, {});
    }
}
function mapStateToProps(state) {
    var _a, _b;
    const profile = vortex_api_1.selectors.activeProfile(state);
    const game = profile !== undefined ? vortex_api_1.selectors.gameById(state, profile.gameId) : undefined;
    return {
        game,
        profile,
        mods: profile !== undefined ? ((_a = state.persistent.mods[profile.gameId]) !== null && _a !== void 0 ? _a : emptyObj) : emptyObj,
        notifications: state.session.notifications.notifications,
        downloads: state.persistent.downloads.files,
        userInfo: (_b = state.persistent['nexus']) === null || _b === void 0 ? void 0 : _b.userInfo,
        exts: profile !== undefined ? (0, extension_1.findExtensions)(state, profile.gameId) : emptyArr,
    };
}
function mapDispatchToProps(dispatch) {
    return {
        removeMod: (gameId, modId) => dispatch(vortex_api_1.actions.removeMod(gameId, modId)),
    };
}
exports["default"] = (0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)((0, react_i18next_1.withTranslation)([constants_1.NAMESPACE, 'common'])(CollectionsMainPage));


/***/ }),

/***/ "./src/views/CollectionModsPageAttributeRenderer.tsx":
/*!***********************************************************!*\
  !*** ./src/views/CollectionModsPageAttributeRenderer.tsx ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function TooltipItem(props) {
    const { name } = props;
    return (React.createElement("li", null, name));
}
function Tooltip(props) {
    const { collectionNames } = props;
    return (React.createElement("ul", { className: 'collection-mods-page-attrib-tooltip' }, collectionNames.map((name, idx) => React.createElement(TooltipItem, { key: `${name}${idx}`, name: name }))));
}
function nop() {
}
function CollectionCount(props) {
    const { collectionNames, modId } = props;
    const filtered = collectionNames.slice(1);
    const tip = React.createElement(Tooltip, { collectionNames: filtered });
    return (React.createElement(vortex_api_1.tooltip.Button, { id: `${modId}-collection-count`, className: 'collection-mods-page-attr-addendum', tooltip: tip, onClick: nop }, `+${filtered.length}`));
}
function CollectionModsPageAttributeRenderer(props) {
    const { collections, detailCell, modId } = props;
    const collectionNames = collections.map(collection => vortex_api_1.util.renderModName(collection));
    const count = collectionNames.length;
    return (count > 0)
        ? (React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-mods-page-attribute-renderer' },
            React.createElement(vortex_api_1.FlexLayout.Fixed, null, detailCell ? (React.createElement("ul", null, collectionNames.map(name => (React.createElement("li", { key: name }, name))))) : (React.createElement("div", null, collectionNames[0]))),
            ((count > 1) && !detailCell) ? (React.createElement(CollectionCount, { collectionNames: collectionNames, modId: modId })) : null)) : null;
}
exports["default"] = CollectionModsPageAttributeRenderer;


/***/ }),

/***/ "./src/views/CollectionPageEdit/FileOverrides.tsx":
/*!********************************************************!*\
  !*** ./src/views/CollectionPageEdit/FileOverrides.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function FileOverrides(props) {
    var _a;
    const { t, collection, mods, onSetCollectionAttribute, pathTool } = props;
    const { discovery } = (0, react_redux_1.useSelector)(mapStateToProps);
    const [showOverlay, setShowOverlay] = React.useState(undefined);
    const target = React.useRef();
    const container = React.useRef();
    const modsWithOverrides = React.useMemo(() => {
        var _a;
        return ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type))
            .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
            .filter(mod => { var _a; return ((_a = mod === null || mod === void 0 ? void 0 : mod.fileOverrides) !== null && _a !== void 0 ? _a : []).length > 0; });
    }, [collection, mods]);
    const toggleOverride = React.useCallback((value, dataId) => {
        onSetCollectionAttribute(['fileOverrides', dataId], value);
    }, []);
    const togglePopover = React.useCallback((evt) => {
        const modId = evt.currentTarget.getAttribute('data-modid');
        if (showOverlay === modId) {
            setShowOverlay(undefined);
        }
        else {
            target.current = evt.currentTarget;
            setShowOverlay(modId);
        }
    }, [setShowOverlay, showOverlay]);
    const hide = React.useCallback((evt) => {
        evt.preventDefault();
        setShowOverlay(undefined);
    }, []);
    const getBounds = React.useCallback(() => {
        return container.current !== undefined ? container.current.getBoundingClientRect() : {
            left: 0,
            top: 0,
            width: window.innerWidth,
            height: window.innerHeight,
            right: window.innerWidth,
            bottom: window.innerHeight,
        };
    }, [container.current]);
    const mod = mods[showOverlay];
    const toRelPath = (filePath) => pathTool.relative(discovery.path, filePath);
    const popover = showOverlay === undefined ? React.createElement(react_bootstrap_1.Popover, null) : (React.createElement(react_bootstrap_1.Popover, { id: 'file-overrides-popover' },
        React.createElement(react_bootstrap_1.ListGroup, null, ((_a = mod.fileOverrides) !== null && _a !== void 0 ? _a : []).map(override => (React.createElement("div", { key: override }, toRelPath(override)))))));
    const isEnabled = (id) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.fileOverrides) === null || _c === void 0 ? void 0 : _c[id]) !== null && _d !== void 0 ? _d : false; };
    return (React.createElement("div", { ref: container, id: 'collection-file-overrides', className: 'collection-file-overrides' },
        React.createElement(react_bootstrap_1.ControlLabel, null,
            React.createElement("p", null, t('File overrides can be considered as a type of ignore list. This page will allow you to export file overrides that '
                + 'are defined for your selected mod list. As of Vortex 1.10.x, the file overrides are generated automatically based on '
                + 'mod rules you export as part of your collection.')),
            React.createElement("p", null, t('Please note that these pre-generated file overrides are toggled off by default as Vortex will '
                + 'generate them on the users machine as part of the collection installation automatically. Therefore there\'s no '
                + 'explicit need to export these overrides unless you have manually set certain overrides which are not generated by the mod dependency system.')),
            React.createElement("p", null, t('Any mods enabled below will NOT be deployed on the user\'s machine. '
                + 'Please use this feature sparingly as most users are not aware that Vortex offers this functionality and may '
                + 'encounter trouble when trying to tweak/remove them.'))),
        React.createElement(react_bootstrap_1.Table, null,
            React.createElement("tbody", null, modsWithOverrides.map(mod => {
                var _a;
                return (React.createElement("tr", { key: mod.id },
                    React.createElement("td", null,
                        React.createElement(vortex_api_1.Toggle, { checked: isEnabled(mod.id), dataId: mod.id, onToggle: toggleOverride },
                            vortex_api_1.util.renderModName(mod),
                            "\u00A0",
                            React.createElement(vortex_api_1.Overlay, { rootClose: true, show: showOverlay !== undefined, onHide: hide, orientation: 'horizontal', getBounds: getBounds, target: target.current }, popover))),
                    React.createElement("td", null,
                        React.createElement("a", { "data-modid": mod.id, onClick: togglePopover }, t('contains {{count}} file override', {
                            count: ((_a = mod.fileOverrides) !== null && _a !== void 0 ? _a : []).length,
                        })))));
            })))));
}
function mapStateToProps(state) {
    const gameId = vortex_api_1.selectors.activeGameId(state);
    return {
        gameId,
        discovery: vortex_api_1.selectors.discoveryByGame(state, gameId),
    };
}
exports["default"] = FileOverrides;


/***/ }),

/***/ "./src/views/CollectionPageEdit/InstallModeRenderer.tsx":
/*!**************************************************************!*\
  !*** ./src/views/CollectionPageEdit/InstallModeRenderer.tsx ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
class InstallModeRenderer extends vortex_api_1.ComponentEx {
    constructor() {
        super(...arguments);
        this.renderIconTooltip = () => {
            const { t, hasInstallerOptions } = this.props;
            return hasInstallerOptions ? (React.createElement(vortex_api_1.FlexLayout.Fixed, { style: { marginLeft: '5px', marginTop: '3px' } },
                React.createElement(vortex_api_1.tooltip.Icon, { name: 'options', tooltip: t('This mod has installer options') }))) : null;
        };
        this.renderOption = (option) => {
            const { t, options, modId } = this.props;
            const text = t(options[option]);
            return React.createElement("option", { key: option, value: option, "data-id": modId }, text);
        };
        this.selectInstallMode = (evt) => {
            var _a;
            const { onSetInstallMode } = this.props;
            const modId = (_a = evt.target.selectedOptions[0]) === null || _a === void 0 ? void 0 : _a.getAttribute('data-id');
            const newVal = evt.target.value;
            onSetInstallMode(modId, newVal);
        };
    }
    render() {
        const { options, currentInstallMode } = this.props;
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
            React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                React.createElement(react_bootstrap_1.FormControl, { componentClass: 'select', onChange: this.selectInstallMode, value: currentInstallMode }, Object.keys(options).map(this.renderOption))),
            this.renderIconTooltip()));
    }
}
function mapStateToProps(state) {
    const activeGameId = vortex_api_1.selectors.activeGameId(state);
    return {
        mods: vortex_api_1.util.getSafe(state, ['persistent', 'mods', activeGameId], {}),
    };
}
exports["default"] = (0, react_i18next_1.withTranslation)([constants_1.NAMESPACE, 'common'])((0, react_redux_1.connect)(mapStateToProps)(InstallModeRenderer));


/***/ }),

/***/ "./src/views/CollectionPageEdit/Instructions.tsx":
/*!*******************************************************!*\
  !*** ./src/views/CollectionPageEdit/Instructions.tsx ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
function CollectionGeneralInfo(props) {
    return (React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
        instructions(props),
        settings(props)));
}
const settings = (props) => {
    var _a, _b, _c;
    const [t] = (0, react_i18next_1.useTranslation)([constants_1.NAMESPACE, 'common']);
    const { onSetCollectionAttribute, collection } = props;
    const [recommendNewProfile, setRecommendNewProfile] = React.useState((_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.collectionConfig) === null || _c === void 0 ? void 0 : _c.recommendNewProfile);
    const toggleRecommendNewProfile = React.useCallback(() => {
        const newValue = !recommendNewProfile;
        setRecommendNewProfile(newValue);
        onSetCollectionAttribute(['collectionConfig', 'recommendNewProfile'], newValue);
    }, [onSetCollectionAttribute, recommendNewProfile, setRecommendNewProfile]);
    return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', id: 'collection-settings-edit', className: 'collection-settings-edit' },
        React.createElement("h4", null, t('Options')),
        React.createElement("p", null, t('The below settings can optionally be changed to customize this collection')),
        React.createElement(vortex_api_1.Toggle, { id: 'settings-recommend-new-profile', onToggle: toggleRecommendNewProfile, checked: recommendNewProfile },
            t('Recommend new profile'),
            React.createElement(vortex_api_1.More, { id: 'collection-settings-recommendnewprofile', name: t('Recommend new profile') }, t('If enabled, Vortex will recommend creating a new profile when installing this collection. If disabled, the collection will be installed into the currently active profile.')))));
};
const instructions = (props) => {
    var _a, _b;
    const [t] = (0, react_i18next_1.useTranslation)([constants_1.NAMESPACE, 'common']);
    const { collection, onSetCollectionAttribute } = props;
    const [input, setInput] = React.useState((_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a['collection']) === null || _b === void 0 ? void 0 : _b['installInstructions']);
    const [placeholder, setPlaceholder] = React.useState(t(constants_1.INSTRUCTIONS_PLACEHOLDER));
    const [hasChanged, setHasChanged] = React.useState(false);
    React.useEffect(() => {
        var _a, _b;
        setInput((_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a['collection']) === null || _b === void 0 ? void 0 : _b['installInstructions']);
    }, [collection]);
    const assignInstructions = React.useCallback((evt) => {
        setInput(evt.currentTarget.value);
        setHasChanged(true);
    }, [setInput]);
    const saveInstructions = React.useCallback(() => {
        onSetCollectionAttribute(['installInstructions'], input);
        setHasChanged(false);
    }, [input]);
    return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', id: 'collection-instructions-edit', className: 'collection-instructions-edit' },
        React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-instructions-container' },
            React.createElement("h4", null, t('Instructions')),
            React.createElement("p", null, t('Instructions will be shown to the user before installation starts and can be reviewed in the Instructions tab. You can also add individual mod instructions in the Mods tab.')),
            React.createElement(react_bootstrap_1.FormControl, { id: 'collection-instructions-area', componentClass: 'textarea', value: input, onChange: assignInstructions, placeholder: placeholder, onFocus: (e) => setPlaceholder(''), onBlur: (e) => setPlaceholder(t(constants_1.INSTRUCTIONS_PLACEHOLDER)), rows: 8 })),
        React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-instructions-buttons' },
            React.createElement(vortex_api_1.tooltip.Button, { disabled: !hasChanged, tooltip: t('Save Instructions'), onClick: saveInstructions }, t('Save')))));
};
exports["default"] = CollectionGeneralInfo;


/***/ }),

/***/ "./src/views/CollectionPageEdit/ModRules.tsx":
/*!***************************************************!*\
  !*** ./src/views/CollectionPageEdit/ModRules.tsx ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
class ModRulesPage extends vortex_api_1.ComponentEx {
    constructor() {
        super(...arguments);
        this.mAugmentedRules = (0, memoize_one_1.default)((rules) => rules.map(rule => this.augmentRule(rule)));
        this.mFilteredRules = (0, memoize_one_1.default)((collection, rules) => rules.filter(rule => !vortex_api_1.util.testModReference(collection, rule.source)));
        this.enableAllRules = () => {
            this.setRulesEnabled(true);
        };
        this.disableAllRules = () => {
            this.setRulesEnabled(false);
        };
        this.ruleSort = (lhs, rhs) => {
            return lhs.sourceName.localeCompare(rhs.sourceName);
        };
        this.toggleRule = (newValue, dataId) => {
            const { onSetCollectionAttribute } = this.props;
            onSetCollectionAttribute(['rule', dataId], newValue);
        };
    }
    shouldComponentUpdate(nextProps) {
        return (this.props.t !== nextProps.t)
            || (this.props.collection !== nextProps.collection)
            || (this.props.mods !== nextProps.mods)
            || (this.props.rules !== nextProps.rules)
            || (this.props.onSetCollectionAttribute !== nextProps.onSetCollectionAttribute);
    }
    render() {
        const { t, collection } = this.props;
        const rules = this.mAugmentedRules(this.props.rules);
        const filtered = this.mFilteredRules(collection, rules);
        let lastSourceName;
        return (React.createElement("div", { id: 'collection-mod-rules', className: 'collection-rules-edit' },
            React.createElement(react_bootstrap_1.ControlLabel, null,
                React.createElement("p", null,
                    t('By default the collection will replicate all your custom rules that dictate '
                        + 'the deployment order of mods.'),
                    "\u00A0",
                    t('If you disable rules here your collection may produce unresolved file conflicts '
                        + 'that the user has to resolve.'))),
            React.createElement("div", null,
                React.createElement("a", { onClick: this.enableAllRules }, t('Enable all')),
                React.createElement("span", { className: 'link-action-seperator' }, "\u00A0 | \u00A0"),
                React.createElement("a", { onClick: this.disableAllRules }, t('Disable all'))),
            React.createElement(react_bootstrap_1.ListGroup, null, filtered
                .sort(this.ruleSort)
                .map((rule, idx) => {
                const separator = rule.sourceName !== lastSourceName;
                lastSourceName = rule.sourceName;
                return this.renderRule(rule, idx, separator);
            }))));
    }
    augmentRule(rule) {
        return {
            ...rule,
            sourceName: (0, util_1.renderReference)(rule.source, this.props.mods),
            referenceName: (0, util_1.renderReference)(rule.reference, this.props.mods),
        };
    }
    setRulesEnabled(enable) {
        const { collection, onSetCollectionAttribute } = this.props;
        const rules = this.mAugmentedRules(this.props.rules);
        const filtered = this.mFilteredRules(collection, rules);
        filtered.forEach(rule => {
            onSetCollectionAttribute(['rule', (0, util_1.ruleId)(rule)], enable);
        });
    }
    renderRule(rule, idx, separator) {
        var _a, _b, _c, _d;
        const { collection } = this.props;
        const id = (0, util_1.ruleId)(rule);
        const checked = (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.rule) === null || _c === void 0 ? void 0 : _c[id]) !== null && _d !== void 0 ? _d : true;
        return (React.createElement(react_bootstrap_1.ListGroupItem, { className: separator ? 'collection-rule-separator' : undefined, key: idx.toString() },
            React.createElement(vortex_api_1.Toggle, { checked: checked, dataId: id, onToggle: this.toggleRule },
                React.createElement("div", { className: 'rule-name' }, rule.sourceName),
                React.createElement("div", { className: 'rule-type' }, rule.type),
                React.createElement("div", { className: 'rule-name' }, rule.referenceName))));
    }
}
exports["default"] = ModRulesPage;


/***/ }),

/***/ "./src/views/CollectionPageEdit/ModsEditPage.tsx":
/*!*******************************************************!*\
  !*** ./src/views/CollectionPageEdit/ModsEditPage.tsx ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const _ = __webpack_require__(/*! lodash */ "lodash");
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const InstallModeRenderer_1 = __webpack_require__(/*! ./InstallModeRenderer */ "./src/views/CollectionPageEdit/InstallModeRenderer.tsx");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
;
const SOURCES = {
    nexus: 'Nexus Mods',
    direct: 'Direct download',
    browse: 'Browse a website',
    bundle: 'Bundle with collection',
};
const INSTALL_MODES = {
    fresh: 'Fresh Install',
    choices: 'Same Installer Options',
    clone: 'Replicate',
};
const getCollator = (() => {
    let lang;
    let collator;
    return (locale) => {
        if ((collator === undefined) || (locale !== lang)) {
            lang = locale;
            collator = new Intl.Collator(locale, { sensitivity: 'base' });
        }
        return collator;
    };
})();
function undefSort(lhs, rhs) {
    return (lhs !== undefined)
        ? 1 : (rhs !== undefined)
        ? -1 : 0;
}
function modNameSort(lhs, rhs, collator, sortDir) {
    const lhsName = vortex_api_1.util.renderModName(lhs);
    const rhsName = vortex_api_1.util.renderModName(rhs);
    return ((lhsName === undefined) || (rhsName === undefined))
        ? undefSort(lhsName, rhsName)
        : collator.compare(lhsName, rhsName) * (sortDir !== 'desc' ? 1 : -1);
}
function sortCategories(lhs, rhs, collator, state, sortDir) {
    var _a, _b;
    const lhsCat = vortex_api_1.util.resolveCategoryName((_a = lhs === null || lhs === void 0 ? void 0 : lhs.attributes) === null || _a === void 0 ? void 0 : _a.category, state);
    const rhsCat = vortex_api_1.util.resolveCategoryName((_b = rhs === null || rhs === void 0 ? void 0 : rhs.attributes) === null || _b === void 0 ? void 0 : _b.category, state);
    return (lhsCat === rhsCat)
        ? modNameSort(lhs, rhs, collator, sortDir)
        : collator.compare(lhsCat, rhsCat);
}
const coerceableRE = /^v?[0-9.]+$/;
function safeCoerce(input) {
    var _a;
    return coerceableRE.test(input)
        ? (_a = vortex_api_1.util.coerceToSemver(input)) !== null && _a !== void 0 ? _a : input
        : input;
}
class ModsEditPage extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.mActions = [
            {
                title: 'Requires',
                icon: 'requires',
                singleRowAction: false,
                multiRowAction: true,
                condition: (instanceIds) => instanceIds.find(id => { var _a, _b; return ((_b = (_a = this.state.entries[id]) === null || _a === void 0 ? void 0 : _a.rule) === null || _b === void 0 ? void 0 : _b.type) === 'recommends'; }) !== undefined,
                action: (instanceIds) => {
                    const { onAddRule, onRemoveRule } = this.props;
                    const { entries } = this.state;
                    instanceIds.forEach(id => {
                        var _a, _b;
                        if (((_b = (_a = entries[id]) === null || _a === void 0 ? void 0 : _a.rule) === null || _b === void 0 ? void 0 : _b.type) === 'recommends') {
                            const newRule = _.cloneDeep(entries[id].rule);
                            onRemoveRule(entries[id].rule);
                            newRule.type = 'requires';
                            onAddRule(newRule);
                        }
                    });
                },
            },
            {
                title: 'Recommends',
                icon: 'recommends',
                singleRowAction: false,
                multiRowAction: true,
                condition: (instanceIds) => instanceIds.find(id => { var _a, _b; return ((_b = (_a = this.state.entries[id]) === null || _a === void 0 ? void 0 : _a.rule) === null || _b === void 0 ? void 0 : _b.type) === 'requires'; }) !== undefined,
                action: (instanceIds) => {
                    const { onAddRule, onRemoveRule } = this.props;
                    const { entries } = this.state;
                    instanceIds.forEach(id => {
                        var _a;
                        if (((_a = entries[id].rule) === null || _a === void 0 ? void 0 : _a.type) === 'requires') {
                            const newRule = _.cloneDeep(entries[id].rule);
                            onRemoveRule(entries[id].rule);
                            newRule.type = 'recommends';
                            onAddRule(newRule);
                        }
                    });
                },
            },
            {
                title: 'Set Install Type',
                icon: 'edit',
                singleRowAction: false,
                multiRowAction: true,
                action: (instanceIds) => {
                    var _a, _b, _c, _d;
                    const { onSetCollectionAttribute, collection } = this.props;
                    const refMode = (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.installMode) === null || _c === void 0 ? void 0 : _c[instanceIds[0]]) !== null && _d !== void 0 ? _d : 'fresh';
                    this.context.api.showDialog('question', 'Install Type', {
                        text: 'Please select the install mode to apply to all selected mods',
                        choices: [
                            { id: 'fresh', text: 'Fresh Install', value: refMode === 'fresh' },
                            { id: 'choices', text: 'Same Installer Options', value: refMode === 'choices' },
                            { id: 'clone', text: 'Replicate', value: refMode === 'clone' },
                        ],
                    }, [
                        { label: 'Cancel' },
                        { label: 'Apply' },
                    ]).then(result => {
                        if (result.action === 'Apply') {
                            const selected = Object.keys(result.input).find(iter => result.input[iter]);
                            instanceIds.forEach(modId => {
                                onSetCollectionAttribute(['installMode', modId], selected);
                            });
                        }
                    });
                },
            },
            {
                title: 'Set Version',
                icon: 'auto-update',
                singleRowAction: false,
                multiRowAction: true,
                action: (instanceIds) => {
                    this.context.api.showDialog('question', 'Version Match', {
                        text: 'Please choose how Vortex should choose the version of the mod to be installed. '
                            + '"Exact" means that the user should install the same version as you have '
                            + 'installed right now. "Latest" means it should get the newest version at '
                            + 'the time of installation.',
                        choices: [
                            { id: 'prefer', text: 'Prefer exact', value: true },
                            { id: 'latest', text: 'Latest', value: false },
                            { id: 'exact', text: 'Exact only', value: false },
                        ],
                    }, [
                        { label: 'Cancel' },
                        { label: 'Apply' },
                    ]).then(result => {
                        if (result.action === 'Apply') {
                            const { onAddRule, onRemoveRule } = this.props;
                            const { entries } = this.state;
                            const selected = Object.keys(result.input).find(iter => result.input[iter]);
                            instanceIds.forEach(modId => {
                                const entry = entries[modId];
                                if (entry.mod !== undefined) {
                                    const newRule = _.cloneDeep(entry.rule);
                                    newRule.reference.versionMatch = (selected === 'exact')
                                        ? entry.mod.attributes['version']
                                        : (selected === 'prefer')
                                            ? '>=' + entry.mod.attributes['version'] + '+prefer'
                                            : '*';
                                    onRemoveRule(entry.rule);
                                    onAddRule(newRule);
                                }
                            });
                        }
                    });
                },
            },
            {
                title: 'Remove',
                icon: 'delete',
                singleRowAction: true,
                multiRowAction: true,
                action: (instanceIds) => {
                    const { entries } = this.state;
                    const filteredIds = instanceIds.filter(id => entries[id] !== undefined);
                    this.context.api.showDialog('question', 'Confirm removal', {
                        text: 'Are you sure you want to remove these mods from this collection? Removing the mods from the collection will not remove them from Vortex.',
                        message: filteredIds.map(id => entries[id].mod !== undefined
                            ? vortex_api_1.util.renderModName(entries[id].mod)
                            : vortex_api_1.util.renderModReference(entries[id].rule.reference)).join('\n'),
                    }, [
                        { label: 'Cancel' },
                        { label: 'Remove', action: () => {
                                filteredIds.forEach(id => {
                                    if (entries[id] !== undefined) {
                                        this.props.onRemoveRule(entries[id].rule);
                                        delete this.nextState.entries[id];
                                    }
                                });
                            } },
                    ]);
                },
            },
            {
                icon: 'sort-none',
                title: 'Assign order',
                subMenus: (instanceIds) => {
                    const { t } = this.props;
                    const ids = Array.isArray(instanceIds)
                        ? instanceIds
                        : [instanceIds];
                    const maxPhase = Object.values(this.state.entries).reduce((prev, entry) => { var _a, _b; return Math.max(prev, (_b = (_a = entry.rule.extra) === null || _a === void 0 ? void 0 : _a['phase']) !== null && _b !== void 0 ? _b : 0); }, 0);
                    return (new Array(maxPhase + 1)).fill(0).map((ignore, idx) => {
                        const item = {
                            title: t('Phase {{num}}', { replace: { num: idx } }),
                            action: () => {
                                ids.forEach(id => { this.setPhase(this.state.entries[id], idx); });
                            },
                        };
                        return item;
                    })
                        .concat({
                        title: t('Create & Add to Phase {{num}}', { replace: { num: maxPhase + 1 } }),
                        action: () => {
                            ids.forEach(id => { this.setPhase(this.state.entries[id], maxPhase + 1); });
                        },
                    });
                },
                singleRowAction: true,
            },
        ];
        this.addMods = () => {
            const { collection, onAddModsDialog } = this.props;
            onAddModsDialog(collection.id);
        };
        this.setPhase = (mod, phase) => {
            const { onAddRule, onDismissPhaseUsage, onShowPhaseColumn, showPhaseUsage } = this.props;
            const impl = async () => {
                const newRule = _.cloneDeep(mod.rule);
                vortex_api_1.util.setdefault(newRule, 'extra', {})['phase'] = phase;
                onAddRule(newRule);
                if (phase !== 0) {
                    onShowPhaseColumn();
                }
                if (showPhaseUsage) {
                    const result = await this.context.api.showDialog('info', 'Installation Phase', {
                        text: 'When installing your collection Vortex will process installation phases '
                            + 'one by one and ensure all mods from a given phase are both '
                            + 'installed and deployed before continuing to the next phase. '
                            + 'That way, mods that require other mods being present can be set to '
                            + 'install after their requirements by being put in different phases.\n'
                            + 'Please note that Vortex will need to deploy after each phase which will '
                            + 'slow down the installation process. '
                            + 'It is advised to only utilise this feature when necessary.',
                        checkboxes: [
                            { id: 'dismiss', text: 'Don\'t show this in the future', value: false },
                        ],
                    }, [
                        { label: 'Understood' },
                    ]);
                    if (result.input['dismiss']) {
                        onDismissPhaseUsage();
                    }
                }
            };
            impl();
        };
        this.showProblems = (evt) => {
            const { t, mods } = this.props;
            const modId = evt.currentTarget.getAttribute('data-modid');
            const mod = mods[modId];
            const problems = this.state.problems[modId];
            const { api } = this.context;
            const solutions = new Map([
                ['invalid-ids', () => this.fixInvalidIds(api, mod)],
                ['no-version-set', () => this.fixMissingVersion(api, mod)],
                ['replicate-fuzzy-version', () => this.setCurrentVersion(this.state.entries[modId])],
                ['choices-fuzzy-version', () => this.setPreferVersion(this.state.entries[modId])],
            ]);
            const modName = vortex_api_1.util.renderModName(mod);
            api.showDialog('info', modName, {
                bbcode: '[list]' + problems.map((prob, idx) => {
                    if (solutions.has(prob.type)) {
                        return `[*]${prob.message} [url="cb://selectproblem/${idx}"]${t('Fix it')}[/url][/*]`;
                    }
                    else {
                        return `[*]${prob.message}[/*]`;
                    }
                }).join('') + '[/list]',
                options: {
                    translated: true,
                    bbcodeContext: {
                        callbacks: {
                            selectproblem: (idx) => {
                                solutions.get(problems[idx].type)();
                                api.closeDialog('collection-problem');
                            },
                        },
                    },
                },
            }, [
                { label: 'Close' },
            ], 'collection-problem');
        };
        this.changeInstallMode = (id, value) => {
            this.props.onSetCollectionAttribute(['installMode', id], value);
        };
        this.changeInstructions = (evt) => {
            var _a, _b, _c, _d;
            const { collection, onSetCollectionAttribute } = this.props;
            const modId = evt.currentTarget.getAttribute('data-modid');
            const value = (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.instructions) === null || _c === void 0 ? void 0 : _c[modId]) !== null && _d !== void 0 ? _d : '';
            this.context.api.showDialog('info', 'Instructions', {
                md: 'Instructions added to **required mods** will display alongside the mod as it installs.  \n'
                    + 'Instructions added to **optional mods** will display before the mod installs, the user '
                    + 'will be given the option to either install or skip the mod.  \n'
                    + 'All added instructions will be available in the "Instructions" tab on the Collections page.',
                input: [{ label: 'Instructions', id: 'instructions', type: 'multiline', value, placeholder: constants_1.INSTRUCTIONS_PLACEHOLDER }],
            }, [
                { label: 'Cancel' },
                { label: 'Save' },
            ], 'collection-set-instructions')
                .then(result => {
                if (result.action === 'Save') {
                    onSetCollectionAttribute(['instructions', modId], result.input['instructions']);
                }
            });
        };
        this.onQuerySource = (evt) => {
            var _a, _b, _c, _d, _e;
            const { collection } = this.props;
            const modId = evt.currentTarget.getAttribute('data-modid');
            const type = (_e = (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.source) === null || _c === void 0 ? void 0 : _c[modId]) === null || _d === void 0 ? void 0 : _d.type) !== null && _e !== void 0 ? _e : 'nexus';
            return this.querySource(modId, type);
        };
        const entries = this.generateEntries(props);
        this.initState({
            entries,
            problems: this.checkProblems(props, entries),
        });
        this.mColumns = [
            {
                id: 'name',
                name: 'Mod Name',
                description: 'Mod Name',
                calc: (entry) => (entry.mod !== undefined)
                    ? vortex_api_1.util.renderModName(entry.mod)
                    : vortex_api_1.util.renderModReference(entry.rule.reference),
                placement: 'table',
                edit: {},
                isDefaultSort: true,
                isSortable: true,
                filter: new vortex_api_1.TableTextFilter(true),
                sortFunc: (lhs, rhs, locale) => {
                    if ((this.mCollator === undefined) || (locale !== this.mLang)) {
                        this.mLang = locale;
                        this.mCollator = new Intl.Collator(locale, { sensitivity: 'base' });
                    }
                    return this.mCollator.compare(lhs, rhs);
                },
            }, {
                id: 'tags',
                name: 'Tag',
                description: 'Mod Highlights',
                customRenderer: (entry) => {
                    if (entry.mod === undefined) {
                        return (React.createElement(vortex_api_1.tooltip.Icon, { name: 'feedback-error', tooltip: this.props.t('This mod isn\'t installed.') }));
                    }
                    const color = vortex_api_1.util.getSafe(entry.mod.attributes, ['color'], '');
                    const icon = vortex_api_1.util.getSafe(entry.mod.attributes, ['icon'], '');
                    const hasProblem = (this.state.problems[entry.mod.id] !== undefined)
                        && (this.state.problems[entry.mod.id].length > 0);
                    const hasHighlight = color || icon;
                    if (!color && !icon && !hasProblem) {
                        return null;
                    }
                    return (React.createElement(React.Fragment, null,
                        hasHighlight ? (React.createElement(vortex_api_1.Icon, { className: 'highlight-base ' + (color !== '' ? color : 'highlight-default'), name: icon !== '' ? icon : 'highlight' })) : null,
                        hasProblem ? (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'incompatible', className: 'btn-embed', tooltip: this.state.problems[entry.mod.id]
                                .map(problem => problem.summary).join('\n'), "data-modid": entry.mod.id, onClick: this.showProblems })) : null));
                },
                calc: (entry) => {
                    var _a, _b, _c, _d;
                    if (entry.mod === undefined) {
                        return ['not-installed', 'has-problems'];
                    }
                    const color = (_b = (_a = entry.mod.attributes) === null || _a === void 0 ? void 0 : _a.color) !== null && _b !== void 0 ? _b : '';
                    const icon = (_d = (_c = entry.mod.attributes) === null || _c === void 0 ? void 0 : _c.icon) !== null && _d !== void 0 ? _d : '';
                    const problems = this.state.problems[entry.mod.id] || [];
                    return [color, icon, problems.length > 0 ? 'has-problems' : 'no-problems'];
                },
                placement: 'table',
                edit: {},
                filter: new vortex_api_1.OptionsFilter([{ value: 'has-problems', label: 'Has Problems' }], false, false),
            }, {
                id: 'category',
                name: 'Category',
                description: 'Mod Category',
                icon: 'sitemap',
                placement: 'table',
                calc: (mod) => {
                    var _a, _b;
                    return vortex_api_1.util.resolveCategoryName((_b = (_a = mod.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.category, this.context.api.store.getState());
                },
                isToggleable: true,
                edit: {},
                isSortable: true,
                isGroupable: (mod, t) => {
                    var _a, _b;
                    return vortex_api_1.util.resolveCategoryName((_b = (_a = mod.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.category, this.context.api.store.getState()) || t('<No category>');
                },
                filter: new vortex_api_1.OptionsFilter(() => {
                    const state = this.context.api.getState();
                    return Array.from(new Set(Object.values(this.state.entries)
                        .map(entry => { var _a, _b; return (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.category; })
                        .filter(entry => !!entry)
                        .map(entry => vortex_api_1.util.resolveCategoryName(entry, state))
                        .sort()))
                        .map(name => {
                        return { value: name, label: name };
                    });
                }, false, false),
                sortFuncRaw: (lhs, rhs, locale) => sortCategories(lhs.mod, rhs.mod, getCollator(locale), this.context.api.store.getState(), this.categorySort()),
            }, {
                id: 'required',
                name: 'Required',
                description: 'Whether the entire collection will fail if this mod is missing',
                calc: (mod) => {
                    return mod.rule.type === 'requires'
                        ? true
                        : false;
                },
                placement: 'table',
                edit: {
                    inline: true,
                    actions: false,
                    choices: () => [
                        { key: 'required', bool: true },
                        { key: 'optional', bool: false },
                    ],
                    onChangeValue: (source, value) => {
                        this.props.onRemoveRule(source.rule);
                        const newRule = _.cloneDeep(source.rule);
                        newRule.type = value ? 'requires' : 'recommends';
                        this.props.onAddRule(newRule);
                    },
                },
            }, {
                id: 'source',
                name: 'Source',
                description: 'How the user acquires the mod',
                calc: (entry) => {
                    var _a, _b, _c, _d;
                    const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                    const { collection } = this.props;
                    const type = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'source', id, 'type'], 'nexus');
                    return SOURCES[type];
                },
                placement: 'table',
                edit: {
                    inline: true,
                    actions: false,
                    choices: () => Object.keys(SOURCES).map(key => ({ key, text: SOURCES[key] })),
                    onChangeValue: (entry, value) => {
                        var _a, _b, _c, _d;
                        const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                        if (id !== undefined) {
                            this.querySource(id, value);
                        }
                    },
                },
            }, {
                id: 'edit-source',
                placement: 'table',
                edit: {},
                calc: (entry) => {
                    var _a, _b, _c, _d;
                    const { collection } = this.props;
                    const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                    const type = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'source', id, 'type'], 'nexus');
                    return SOURCES[type];
                },
                customRenderer: (entry) => {
                    var _a, _b, _c, _d;
                    const { t, collection } = this.props;
                    const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                    const type = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'source', id, 'type'], 'nexus');
                    return (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'edit', disabled: (entry.mod === undefined) || ['nexus', 'bundle'].includes(type), tooltip: t('Edit Source'), "data-modid": id, onClick: this.onQuerySource }));
                },
            }, {
                id: 'version-match',
                name: 'Version',
                description: 'The version to install',
                calc: (entry) => {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
                    const { collection } = this.props;
                    const { t } = this.props;
                    const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                    const version = (_g = (_f = (_e = entry.mod) === null || _e === void 0 ? void 0 : _e.attributes) === null || _f === void 0 ? void 0 : _f['version']) !== null && _g !== void 0 ? _g : t('N/A');
                    if (((_l = (_k = (_j = (_h = collection.attributes) === null || _h === void 0 ? void 0 : _h.collection) === null || _j === void 0 ? void 0 : _j.source) === null || _k === void 0 ? void 0 : _k[id]) === null || _l === void 0 ? void 0 : _l.type) === 'bundle') {
                        return t('Exact only ({{version}})', { replace: { version } });
                    }
                    if (entry.rule.reference.versionMatch === '*') {
                        return t('Latest');
                    }
                    else if ((entry.rule.reference.versionMatch === undefined)
                        || (entry.rule.reference.versionMatch || '').endsWith('+prefer')) {
                        return t('Prefer exact ({{version}})', { replace: { version } });
                    }
                    else {
                        return t('Exact only ({{version}})', { replace: { version } });
                    }
                },
                placement: 'table',
                edit: {
                    inline: true,
                    actions: false,
                    choices: (entry) => {
                        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
                        const { t, collection } = this.props;
                        const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                        const version = (_g = (_f = (_e = entry.mod) === null || _e === void 0 ? void 0 : _e.attributes) === null || _f === void 0 ? void 0 : _f['version']) !== null && _g !== void 0 ? _g : t('N/A');
                        if (((_l = (_k = (_j = (_h = collection.attributes) === null || _h === void 0 ? void 0 : _h.collection) === null || _j === void 0 ? void 0 : _j.source) === null || _k === void 0 ? void 0 : _k[id]) === null || _l === void 0 ? void 0 : _l.type) === 'bundle') {
                            return [
                                { key: 'exact', text: t('Exact only ({{version}})', { replace: { version } }) },
                            ];
                        }
                        return [
                            { key: 'exact', text: t('Exact only ({{version}})', { replace: { version } }) },
                            { key: 'prefer', text: t('Prefer exact ({{version}})', { replace: { version } }) },
                            { key: 'newest', text: t('Latest') },
                        ];
                    },
                    onChangeValue: (entry, value) => {
                        if (entry.mod === undefined) {
                            return;
                        }
                        const newRule = _.cloneDeep(entry.rule);
                        this.props.onRemoveRule(entry.rule);
                        newRule.reference.versionMatch = (value === 'exact')
                            ? entry.mod.attributes['version']
                            : (value === 'prefer')
                                ? '>=' + entry.mod.attributes['version'] + '+prefer'
                                : '*';
                        this.props.onAddRule(newRule);
                    },
                },
            }, {
                id: 'install-type',
                name: 'Install',
                description: 'How the mod should be installed on the user system',
                filter: new vortex_api_1.OptionsFilter([
                    { value: 'has-install-options', label: 'Has Installation Options' }
                ], false, false),
                calc: (entry) => {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                    const { collection } = this.props;
                    const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                    if (((_h = (_g = (_f = (_e = collection.attributes) === null || _e === void 0 ? void 0 : _e.collection) === null || _f === void 0 ? void 0 : _f.source) === null || _g === void 0 ? void 0 : _g[id]) === null || _h === void 0 ? void 0 : _h.type) === 'bundle') {
                        return INSTALL_MODES['clone'];
                    }
                    const hasInstallerOptions = ((_m = (_l = (_k = (_j = entry.mod) === null || _j === void 0 ? void 0 : _j.attributes) === null || _k === void 0 ? void 0 : _k.installerChoices) === null || _l === void 0 ? void 0 : _l.options) !== null && _m !== void 0 ? _m : []).length > 0;
                    const installMode = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'installMode', id], 'fresh');
                    return [INSTALL_MODES[installMode], hasInstallerOptions ? 'has-install-options' : 'no-options'];
                },
                placement: 'table',
                help: 'If set to "Fresh Install" the mod will simply be installed fresh on the users system, '
                    + 'installer (if applicable) and everything.\n'
                    + 'If set to "Replicate" Vortex will try to replicate your exact setup for this mod. '
                    + 'This does not bundle the mod itself but the list of files to install and patches if '
                    + 'necessary. This may increase the size of the collection and the time it takes to '
                    + 'export it considerably.',
                edit: {},
                customRenderer: (entry) => {
                    var _a, _b, _c, _d, _e, _f, _g, _h;
                    const { t, collection } = this.props;
                    const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                    const hasInstallerOptions = ((_h = (_g = (_f = (_e = entry.mod) === null || _e === void 0 ? void 0 : _e.attributes) === null || _f === void 0 ? void 0 : _f.installerChoices) === null || _g === void 0 ? void 0 : _g.options) !== null && _h !== void 0 ? _h : []).length > 0;
                    const installMode = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'installMode', id], 'fresh');
                    return (React.createElement(InstallModeRenderer_1.default, { hasInstallerOptions: hasInstallerOptions, currentInstallMode: installMode, modId: id, onSetInstallMode: this.changeInstallMode, options: INSTALL_MODES }));
                },
            }, {
                id: 'instructions',
                name: 'Instructions',
                icon: 'edit',
                calc: (entry) => {
                    var _a, _b, _c;
                    const { collection } = this.props;
                    if (entry.mod === undefined) {
                        return null;
                    }
                    return (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.instructions) === null || _c === void 0 ? void 0 : _c[entry.mod.id];
                },
                customRenderer: (entry, detailCell, t) => {
                    var _a, _b, _c;
                    const { collection } = this.props;
                    if (entry.mod === undefined) {
                        return null;
                    }
                    const instructions = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.instructions) === null || _c === void 0 ? void 0 : _c[entry.mod.id];
                    return (!!instructions) ? (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'edit', tooltip: t('Edit Instructions'), "data-modid": entry.mod.id, onClick: this.changeInstructions }, t('Edit'))) : (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'add', tooltip: t('Add Instructions'), "data-modid": entry.mod.id, onClick: this.changeInstructions }, t('Add')));
                },
                placement: 'table',
                edit: {},
            }, {
                id: 'local_edits',
                name: 'Binary patching',
                icon: 'edit',
                help: 'With this option enabled, any changes you did to the files in this mods will '
                    + 'also be included in the Collection.',
                placement: 'table',
                calc: (entry) => {
                    var _a, _b, _c, _d;
                    const { collection } = this.props;
                    if (entry.mod === undefined) {
                        return false;
                    }
                    return (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.saveEdits) === null || _c === void 0 ? void 0 : _c[entry.mod.id]) !== null && _d !== void 0 ? _d : false;
                },
                edit: {
                    choices: () => [
                        { key: 'ignore', bool: false },
                        { key: 'save', bool: true },
                    ],
                    inline: true,
                    actions: false,
                    onChangeValue: (source, value) => {
                        (async () => {
                            if (source.mod === undefined) {
                                return;
                            }
                            if (value && this.props.showBinpatchWarning) {
                                const result = await this.context.api.showDialog('question', 'Save Local Edits', {
                                    bbcode: 'With this option enabled, when you upload the Collection Vortex will '
                                        + 'compare your files on disk against the archive provided by the mod author '
                                        + 'and include patches so that any modifications get replicated when a user '
                                        + 'installs your collection.\n'
                                        + 'This allows for more customization but there are considerable drawbacks:\n'
                                        + '[list]'
                                        + '[*]Uploading the collection will take longer - a lot if it\'s a big mod\n'
                                        + '[*]these patches apply only to the exact same version&variant of the mod, '
                                        + 'if the user updates the mod the patch will be undone.'
                                        + '[/list]\n'
                                        + 'Therefore please only use this option if you absolutely have to.',
                                    checkboxes: [
                                        { id: 'dont_show_again', value: false, text: 'Don\'t show again' },
                                    ],
                                }, [
                                    { label: 'Cancel' },
                                    { label: 'Enable' },
                                ]);
                                if (result.action === 'Enable') {
                                    const state = this.context.api.getState();
                                    if (result.input['dont_show_again']) {
                                        this.props.onDismissBinpatchWarning();
                                    }
                                    const gameMode = vortex_api_1.selectors.activeGameId(state);
                                    const archive = state.persistent.downloads.files[source.mod.archiveId];
                                    const dlPath = vortex_api_1.selectors.downloadPathForGame(state, gameMode);
                                    if (archive !== undefined) {
                                        try {
                                            await vortex_api_1.fs.statAsync(path.join(dlPath, archive.localPath));
                                            this.props.onSetCollectionAttribute(['saveEdits', source.mod.id], value);
                                        }
                                        catch (err) {
                                            if (err.code === 'ENOENT') {
                                                this.context.api.showErrorNotification('Failed to enable "Local Edits"', 'To enable this feature, the corresponding archive has to exist to '
                                                    + 'compare against.', { allowReport: false });
                                            }
                                            else {
                                                this.context.api.showErrorNotification('Failed to enable "Local Edits"', err);
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                this.props.onSetCollectionAttribute(['saveEdits', source.mod.id], value);
                            }
                        })();
                    },
                },
            }, {
                id: 'phase',
                name: 'Phase',
                placement: 'table',
                isToggleable: true,
                isSortable: true,
                isDefaultVisible: false,
                groupName: (phase) => this.props.t('Phase {{phase}}', {
                    replace: { phase: (phase || 0).toString() },
                }),
                isGroupable: true,
                calc: mod => { var _a, _b; return (_b = (_a = mod.rule.extra) === null || _a === void 0 ? void 0 : _a['phase']) !== null && _b !== void 0 ? _b : 0; },
                edit: {},
            },
        ];
    }
    UNSAFE_componentWillMount() {
        const entries = this.generateEntries(this.props);
        this.nextState.entries = entries;
        this.nextState.problems = this.checkProblems(this.props, entries);
    }
    UNSAFE_componentWillReceiveProps(newProps) {
        if ((newProps.mods !== this.props.mods)
            || (newProps.collection !== this.props.collection)) {
            const entries = this.generateEntries(newProps);
            this.nextState.entries = entries;
            this.nextState.problems = this.checkProblems(newProps, entries);
        }
    }
    render() {
        const { t } = this.props;
        const { entries } = this.state;
        const addModsButton = () => {
            return (React.createElement(react_bootstrap_1.Button, { id: 'btn-more-mods', className: 'collection-add-mods-btn', onClick: this.addMods },
                React.createElement(vortex_api_1.Icon, { name: 'add' }),
                t('Add more mods')));
        };
        if (Object.keys(entries).length === 0) {
            return (React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'layout-list', text: t('There are no mods in this collection'), subtext: addModsButton(), fill: true }));
        }
        return (React.createElement("div", { className: 'collection-mods-container' },
            React.createElement(vortex_api_1.Table, { tableId: 'collection-mods', data: entries, staticElements: this.mColumns, actions: this.mActions, showDetails: false },
                React.createElement("div", { id: 'collection-add-mods-container' }, addModsButton())),
            React.createElement(vortex_api_1.Usage, { infoId: 'collection-mods' },
                React.createElement("p", null, t('Here you can configure which mods to install and how.')),
                React.createElement("p", null, t('Version: Choose whether the collection will install exactly the version you '
                    + 'have yourself or whatever is current on Nexus Mods.')),
                React.createElement("p", null, t('Required: Select whether the user has to install the mod or whether it\'s an optional recommendation, recommended mods are presented last and the user is given the choice to install them or not.')),
                React.createElement("p", null, t('Install: "Fresh Install" will install the mod as Vortex would usually do, '
                    + 'installer dialog and everything. "Replicate" will extract only the files you have '
                    + 'extracted yourself, in exactly the same location. This basically ensures the user '
                    + 'gets the same options as you without having to pick them but it only works when you '
                    + 'have selected "Exact version" in the Version column. It will also considerably '
                    + 'increase the time it takes to build the pack.')),
                React.createElement("p", null, t('Source: Decides how the user downloads the mod. "Nexus Mods" is easiest, use the '
                    + 'other options when the mod in only hosted on a different source. '
                    + 'The options also include "pack" which bundles the mod directly into the collection. '
                    + 'Do this only for stuff created during setup (e.g. generated LODs, '
                    + 'customized configuration files and such). '
                    + 'You must not include any material you don\'t hold the copyright to. '
                    + 'Also: Do not provide direct download links unless you have express permission to '
                    + 'do so.')))));
    }
    categorySort() {
        var _a, _b, _c;
        const state = this.context.api.getState();
        return (_c = (_b = (_a = state.settings.tables.mods.attributes) === null || _a === void 0 ? void 0 : _a['category']) === null || _b === void 0 ? void 0 : _b.sortDirection) !== null && _c !== void 0 ? _c : 'none';
    }
    generateEntries(props) {
        const { collection, mods } = props;
        if ((collection === undefined) || (collection.rules === undefined)) {
            return {};
        }
        return Object.values(collection.rules)
            .filter(rule => ['requires', 'recommends'].indexOf(rule.type) !== -1)
            .reduce((prev, rule) => {
            var _a, _b;
            const mod = vortex_api_1.util.findModByRef(_.omit(rule.reference, ['versionMatch']), mods);
            const id = (_b = (_a = mod === null || mod === void 0 ? void 0 : mod.id) !== null && _a !== void 0 ? _a : rule.reference.id) !== null && _b !== void 0 ? _b : rule.reference.idHint;
            if (id !== undefined) {
                prev[id] = { rule, mod };
            }
            return prev;
        }, {});
    }
    checkProblems(props, entries) {
        return Object.values(entries).reduce((prev, entry) => {
            var _a, _b, _c;
            const id = (_c = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : entry.rule.reference.id) !== null && _c !== void 0 ? _c : entry.rule.reference.idHint;
            if (id !== undefined) {
                prev[id] = this.updateProblems(props, entry);
            }
            return prev;
        }, {});
    }
    updateProblems(props, entry) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        const { t, collection } = props;
        if (entry.mod === undefined) {
            return;
        }
        const res = [];
        const attributes = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection;
        const source = (_b = attributes === null || attributes === void 0 ? void 0 : attributes.source) === null || _b === void 0 ? void 0 : _b[entry.mod.id];
        const sourceType = (_c = source === null || source === void 0 ? void 0 : source.type) !== null && _c !== void 0 ? _c : 'nexus';
        const installMode = (_e = (_d = attributes === null || attributes === void 0 ? void 0 : attributes.installMode) === null || _d === void 0 ? void 0 : _d[entry.mod.id]) !== null && _e !== void 0 ? _e : 'fresh';
        const saveEdits = (_g = (_f = attributes === null || attributes === void 0 ? void 0 : attributes.saveEdits) === null || _f === void 0 ? void 0 : _f[entry.mod.id]) !== null && _g !== void 0 ? _g : false;
        const { versionMatch } = entry.rule.reference;
        if ((sourceType === 'nexus')
            && (isNaN(parseInt((_h = entry.mod.attributes) === null || _h === void 0 ? void 0 : _h.modId, 10))
                || isNaN(parseInt((_j = entry.mod.attributes) === null || _j === void 0 ? void 0 : _j.fileId, 10)))) {
            res.push({
                type: 'invalid-ids',
                summary: t('Missing file identifiers'),
                message: t('When using "Nexus Mods" as a source, both the mod id and file id have to be '
                    + 'known. If you didn\'t download the mod through Vortex they may not be set. '
                    + 'To solve this you have to change the source of the mod to "Nexus Mods" '
                    + 'and use the options below "Nexus Mods IDs" to fill in the '
                    + 'missing data (the automated options should be quite reliable).'),
            });
        }
        if (((versionMatch === '*') || ((_k = versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch.endsWith) === null || _k === void 0 ? void 0 : _k.call(versionMatch, '+prefer')))
            && (installMode === 'clone')) {
            res.push({
                type: 'replicate-fuzzy-version',
                summary: t('"Replicate" requires "Exact only" as the version'),
                message: t('"Replicate" install can only be used when installing '
                    + 'a specific version of a mod. This will definitively break '
                    + 'as soon as the mod gets updated.'),
            });
        }
        if ((versionMatch === '*') && (installMode === 'choices')) {
            res.push({
                type: 'choices-fuzzy-version',
                summary: t('"Same Installer Options" should not be used with "Latest" version'),
                message: t('Installing with "Same choices options" may break if the mod gets updated, '
                    + 'you may want to switch to "Prefer exact" to be safe.'),
            });
        }
        if ((sourceType === 'bundle')
            && ((versionMatch === '*') || ((_l = versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch.endsWith) === null || _l === void 0 ? void 0 : _l.call(versionMatch, '+prefer')))) {
            res.push({
                type: 'bundled-fuzzy-version',
                summary: t('Version choice has no effect on "Bundled" mod'),
                message: t('If you bundle a mod the user gets exactly the version of the mod you '
                    + 'have, the Version selection is pointless in this case.'),
            });
        }
        else if (['browse', 'direct'].includes(sourceType)) {
            if ((_m = versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch.endsWith) === null || _m === void 0 ? void 0 : _m.call(versionMatch, '+prefer')) {
                res.push({
                    type: 'web-fuzzy-version',
                    summary: t('Version choice has no effect on mods using generic download.'),
                    message: t('The option to "prefer exact version" only works with sources that '
                        + 'support mod updates (Nexus Mods). For other sources your options '
                        + 'are to use the exact same version you have locally or to accept whatever '
                        + 'version the user downloads.'),
                });
            }
            if (!source.url) {
                res.push({
                    type: 'web-url-missing',
                    summary: t('No URL set'),
                    message: t('The sources "Browse a website" and "Direct download" require that '
                        + 'you provide a URL to download from.'),
                });
            }
        }
        if (saveEdits) {
            if ((versionMatch === '*') || ((_o = versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch.endsWith) === null || _o === void 0 ? void 0 : _o.call(versionMatch, '+prefer'))) {
                res.push({
                    type: 'local-edits-fuzzy-version',
                    summary: t('Version choice incompatible with saving local edits.'),
                    message: t('Local edits can only be applied if the user gets the exact same files '
                        + 'as you have installed locally, meaning they have to use the exact '
                        + 'same version of the mod.'),
                });
            }
            if (sourceType === 'bundle') {
                res.push({
                    type: 'local-edits-bundle',
                    summary: t('Combining the option to save edits and bundling makes no sense.'),
                    message: t('The option to "bundle" already bundles the edited files, storing '
                        + 'the edits separately would not be useful as they can\'t and '
                        + 'don\'t have to be applied.'),
                });
            }
            if (installMode === 'clone') {
                res.push({
                    type: 'replicate-vs-binpatch',
                    summary: t('"Replicate" installation can\'t be combined with "Binary patching"'),
                    message: t('"Replicate" depends on files being unchanged '
                        + 'from the originals in the archive. If you modified mod files '
                        + '(as Binary Patching implies), "Replicate" will fail.'),
                });
            }
        }
        if (sourceType === 'bundle') {
            res.push({
                type: 'bundle-copyright',
                summary: t('Only bundle mods you have the right to do so'),
                message: t('Mods are copyright protected, only pack mods if you are sure you '
                    + 'have the right to do so, e.g. if it\'s dynamically generated content '
                    + 'or if it\'s your own mod.'),
            });
        }
        else if (sourceType === 'direct') {
            res.push({
                type: 'direct-download',
                summary: t('Please verify you are allowed to do direct download on this site'),
                message: t('Most websites don\'t allow direct downloads, Plese make sure you are '
                    + 'allowed to use direct links to the specified page.'),
            });
        }
        if ((installMode === 'choices')
            && (((_r = (_q = (_p = entry.mod.attributes) === null || _p === void 0 ? void 0 : _p.installerChoices) === null || _q === void 0 ? void 0 : _q.options) !== null && _r !== void 0 ? _r : []).length === 0)) {
            res.push({
                type: 'installer-choices-not-saved',
                summary: t('No Installer Options saved for this mod'),
                message: t('The installer choices for this mod haven\'t been saved. '
                    + 'This currently only works with xml-based fomods installed with '
                    + 'Vortex 1.5.0 or later. '
                    + 'You may have to reinstall the mod for this to work.'),
            });
        }
        if (versionMatch === '') {
            res.push({
                type: 'no-version-set',
                summary: t('No version set for this mod'),
                message: t('The mod has no version number set. This isn\'t strictly necessary, we use the '
                    + 'file id to identify the exact version but for the purpose of informing the '
                    + 'user it would be nicer if a version was specified. '
                    + '(Please don\'t forget to update the collection)'),
            });
        }
        return res;
    }
    async fixInvalidIds(api, mod) {
        const modName = vortex_api_1.util.renderModName(mod);
        const result = await api.showDialog('question', modName, {
            text: 'You have to either fix the IDs for this mod or change how the collection '
                + 'acquires this mod.',
        }, [
            { label: 'Change Source' },
            { label: 'Fix IDs' },
        ]);
        if (result.action === 'Fix IDs') {
            api.events.emit('show-main-page', 'Mods');
            setTimeout(() => {
                api.events.emit('mods-select-item', mod.id, true);
                api.highlightControl(`.table-detail-modSource`, 4000);
                api.highlightControl(`.table-detail-nexusModId`, 4000);
            }, 200);
        }
        else {
            api.highlightControl(`#${vortex_api_1.util.sanitizeCSSId(mod.id)} > .cell-source`, 4000, undefined, true);
            api.highlightControl(`#${vortex_api_1.util.sanitizeCSSId(mod.id)} > .cell-edit-source`, 4000, undefined, true);
        }
    }
    async fixMissingVersion(api, mod) {
        api.events.emit('show-main-page', 'Mods');
        setTimeout(() => {
            api.events.emit('mods-select-item', mod.id, true);
            api.highlightControl(`.table-detail-versionDetail`, 4000);
        }, 200);
    }
    setCurrentVersion(entry) {
        this.props.onRemoveRule(entry.rule);
        const newRule = _.cloneDeep(entry.rule);
        newRule.reference.versionMatch = entry.mod.attributes['version'];
        this.props.onAddRule(newRule);
    }
    setPreferVersion(entry) {
        this.props.onRemoveRule(entry.rule);
        const newRule = _.cloneDeep(entry.rule);
        newRule.reference.versionMatch = '>=' + safeCoerce(entry.mod.attributes['version']) + '+prefer';
        this.props.onAddRule(newRule);
    }
    querySource(modId, type) {
        var _a;
        const { collection } = this.props;
        const src = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'source', modId], { type });
        const input = [];
        let text;
        if (type === 'bundle') {
            text = 'These files will be bundled with the collection. '
                + 'This means they will be distributed alongside the collection and '
                + 'released into the public domain.\n\n'
                + 'Bundled content should not be used to distribute mods or mod files. '
                + 'It is intended to allow curators to include configuration files or '
                + 'outputs from automated tools for the convenience of users. '
                + 'Any content that would qualify as a "mod" should be uploaded to a '
                + 'Nexus Mods mod page and included in the collection, rather than being bundled.\n\n'
                + 'You should only include content that you have permission to share freely. '
                + 'Failure to respect the permissions/license of mod authors may result in '
                + 'moderation against your account.';
        }
        else if (['direct', 'browse', 'manual'].includes(type)) {
            text = 'Please provide information the user needs to find the mod';
        }
        if (['direct', 'browse'].includes(type)) {
            input.push({ id: 'url', type: 'url', label: 'URL', value: src.url });
        }
        if (['browse', 'manual'].includes(type)) {
            input.push({
                id: 'instructions', type: 'text', label: 'Instructions',
                value: src.instructions,
            });
        }
        if ((input.length > 0) || (text !== undefined)) {
            this.context.api.showDialog('question', 'Provide mod metadata', {
                text,
                input,
                checkboxes: [
                    {
                        id: 'adult',
                        bbcode: 'Mod contains adult content. '
                            + `([url=${constants_1.ADULT_CONTENT_URL}]Adult Content Guidelines[/url])`,
                        value: (_a = src.adultContent) !== null && _a !== void 0 ? _a : false,
                    },
                ],
            }, [
                { label: 'Save' },
            ]).then((result => {
                this.props.onSetCollectionAttribute(['source', modId], {
                    type,
                    url: result.input.url,
                    instructions: result.input.instructions,
                    adultContent: result.input.adult === true,
                });
            }));
        }
        else {
            this.props.onSetCollectionAttribute(['source', modId], { type });
        }
    }
}
exports["default"] = ModsEditPage;


/***/ }),

/***/ "./src/views/CollectionPageEdit/index.tsx":
/*!************************************************!*\
  !*** ./src/views/CollectionPageEdit/index.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const gameSupport_1 = __webpack_require__(/*! ../../util/gameSupport */ "./src/util/gameSupport/index.ts");
const transformCollection_1 = __webpack_require__(/*! ../../util/transformCollection */ "./src/util/transformCollection.ts");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const session_1 = __webpack_require__(/*! ../../actions/session */ "./src/actions/session.ts");
const FileOverrides_1 = __webpack_require__(/*! ./FileOverrides */ "./src/views/CollectionPageEdit/FileOverrides.tsx");
const Instructions_1 = __webpack_require__(/*! ./Instructions */ "./src/views/CollectionPageEdit/Instructions.tsx");
const ModRules_1 = __webpack_require__(/*! ./ModRules */ "./src/views/CollectionPageEdit/ModRules.tsx");
const ModsEditPage_1 = __webpack_require__(/*! ./ModsEditPage */ "./src/views/CollectionPageEdit/ModsEditPage.tsx");
const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const INIT_PAGE = 'mods';
const emptyCollectionInfo = {
    domainName: '',
    author: '',
    authorUrl: '',
    name: '',
    description: '',
    installInstructions: '',
    gameVersions: [],
};
const emptyList = [];
class CollectionEdit extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.collectionRules = (0, memoize_one_1.default)((rules, mods) => {
            const includedMods = rules
                .filter(rule => ['requires', 'recommends'].includes(rule.type))
                .reduce((prev, rule) => {
                const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
                if (mod !== undefined) {
                    prev[mod.id] = mod;
                }
                return prev;
            }, {});
            return Object.values(includedMods)
                .reduce((prev, mod) => {
                const source = vortex_api_1.util.makeModReference(mod);
                prev = [].concat(prev, (mod.rules || [])
                    .filter(rule => {
                    var _a;
                    return !['requires', 'recommends'].includes(rule.type)
                        && (((_a = rule.extra) === null || _a === void 0 ? void 0 : _a['automatic']) !== true);
                })
                    .map(rule => (0, transformCollection_1.makeBiDirRule)(source, rule)));
                return prev;
            }, []);
        });
        this.trackTabChange = (page) => {
            const game = vortex_api_1.util.getGame(this.props.profile.gameId);
            const pageTracking = page === 'gamespecific' ? game.name : page;
            this.context.api.events.emit('analytics-track-navigation', `collections/workshop/collection/${pageTracking}`);
        };
        this.setCurrentPage = (page) => {
            this.trackTabChange(page);
            this.nextState.page = page;
        };
        this.remove = () => {
            const { collection, onRemove } = this.props;
            onRemove(collection.id);
        };
        this.upload = () => {
            const { collection, onUpload } = this.props;
            onUpload(collection.id);
        };
        this.openUrl = () => {
            var _a, _b, _c, _d;
            const collectionSlug = (_c = (_b = (_a = this.state.revision) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.slug) !== null && _c !== void 0 ? _c : (_d = this.props.collection.attributes) === null || _d === void 0 ? void 0 : _d.collectionSlug;
            if (collectionSlug === undefined) {
                return;
            }
            const { revision } = this.state;
            const { collection } = revision;
            if (((collection === null || collection === void 0 ? void 0 : collection.game) !== undefined) && ((revision === null || revision === void 0 ? void 0 : revision.revisionNumber) !== undefined)) {
                this.context.api.events.emit('analytics-track-click-event', 'Collections', 'View on site Workshop Collection');
                vortex_api_1.util.opn(vortex_api_1.util.nexusModsURL([collection.game.domainName,
                    'collections', collection.slug,
                    'revisions', revision.revisionNumber.toString()], {
                    campaign: vortex_api_1.util.Campaign.ViewCollectionAsCurator,
                    section: vortex_api_1.util.Section.Collections
                }));
            }
        };
        this.addRule = (rule) => {
            const { profile, collection } = this.props;
            this.props.onAddRule(profile.gameId, collection.id, rule);
        };
        this.removeRule = (rule) => {
            const { profile, collection } = this.props;
            this.props.onRemoveRule(profile.gameId, collection.id, rule);
        };
        this.setCollectionAttribute = (attrPath, value) => {
            const { profile, collection } = this.props;
            if (this.mAttributes === undefined) {
                this.mAttributes = collection.attributes;
            }
            const attr = vortex_api_1.util.getSafe(this.mAttributes, ['collection'], {});
            const updated = vortex_api_1.util.setSafe(attr, attrPath, value);
            this.mAttributes = vortex_api_1.util.setSafe(this.mAttributes, ['collection'], updated);
            this.props.onSetModAttribute(profile.gameId, collection.id, 'collection', updated);
        };
        this.addModsDialog = (collectionId) => {
            this.props.onAddModsDialog(collectionId);
        };
        this.showPhaseColumn = () => {
            if (this.props.phaseColumnVisible === undefined) {
                this.props.onShowPhaseColumn();
            }
        };
        this.initState({
            page: INIT_PAGE,
            collectionInfo: emptyCollectionInfo,
            revision: undefined,
        });
    }
    componentDidMount() {
        this.updateState(this.props);
    }
    UNSAFE_componentWillReceiveProps(newProps) {
        var _a;
        this.mAttributes = (_a = newProps.collection) === null || _a === void 0 ? void 0 : _a.attributes;
        if (vortex_api_1.util.getSafe(newProps.collection, ['id'], undefined)
            !== vortex_api_1.util.getSafe(this.props.collection, ['id'], undefined)) {
            this.updateState(newProps);
        }
    }
    render() {
        var _a, _b;
        const { t, mods, collection, showBinpatchWarning, exts, onDismissBinpatchWarning, onDismissPhaseUsage, profile, showPhaseUsage, pathTool } = this.props;
        const { page, revision } = this.state;
        if (profile === undefined) {
            return null;
        }
        const game = vortex_api_1.util.getGame(profile.gameId);
        const extInterfaces = exts.filter(ext => ext.editComponent !== undefined);
        const uploadDisabled = this.testUploadPossible();
        const Interface = (0, gameSupport_1.getInterface)(profile.gameId);
        const nextRev = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.revisionNumber;
        const requiredModRules = this.collectionRules((_b = collection.rules) !== null && _b !== void 0 ? _b : emptyList, mods);
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-edit-header' },
                React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                    React.createElement("h3", null,
                        t('Edit Collection'),
                        " / ",
                        vortex_api_1.util.renderModName(collection)),
                    React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'delete', tooltip: t('Remove this collection'), onClick: this.remove }, t('Remove')),
                    React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'collection-export', tooltip: uploadDisabled !== null && uploadDisabled !== void 0 ? uploadDisabled : t('Upload to Nexus Mods'), onClick: this.upload, disabled: uploadDisabled !== undefined }, t(nextRev !== undefined ? 'Upload Update' : 'Upload New')),
                    React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'open-ext', tooltip: t('Open site'), onClick: this.openUrl, disabled: (revision === undefined) }, t('View Site'))),
                t('Set up your mod collection\'s rules and site preferences.')),
            React.createElement(vortex_api_1.FlexLayout.Flex, null,
                React.createElement(react_bootstrap_1.Tabs, { id: 'collection-edit-tabs', activeKey: page, onSelect: this.setCurrentPage },
                    React.createElement(react_bootstrap_1.Tab, { key: 'mods', eventKey: 'mods', title: React.createElement("div", null,
                            t('Mods'),
                            React.createElement(react_bootstrap_1.Badge, null, (collection.rules || []).length)) },
                        React.createElement(react_bootstrap_1.Panel, { style: { position: 'relative' } },
                            React.createElement(ModsEditPage_1.default, { mods: mods, collection: collection, t: t, onSetModVersion: null, showPhaseUsage: showPhaseUsage, showBinpatchWarning: showBinpatchWarning, onAddRule: this.addRule, onRemoveRule: this.removeRule, onSetCollectionAttribute: this.setCollectionAttribute, onAddModsDialog: this.addModsDialog, onDismissPhaseUsage: onDismissPhaseUsage, onDismissBinpatchWarning: onDismissBinpatchWarning, onShowPhaseColumn: this.showPhaseColumn }))),
                    React.createElement(react_bootstrap_1.Tab, { key: 'mod-rules', eventKey: 'mod-rules', title: t('Mod Rules') },
                        React.createElement(react_bootstrap_1.Panel, null,
                            React.createElement(ModRules_1.default, { t: t, collection: collection, mods: mods, rules: requiredModRules, onSetCollectionAttribute: this.setCollectionAttribute }))),
                    React.createElement(react_bootstrap_1.Tab, { key: 'file-overrides', eventKey: 'file-overrides', title: t('File Overrides') },
                        React.createElement(react_bootstrap_1.Panel, null,
                            React.createElement(FileOverrides_1.default, { t: t, collection: collection, mods: mods, onSetCollectionAttribute: this.setCollectionAttribute, pathTool: pathTool }))),
                    React.createElement(react_bootstrap_1.Tab, { key: 'collection-instructions', eventKey: 'collection-instructions', title: t('Collection Instructions') },
                        React.createElement(react_bootstrap_1.Panel, null,
                            React.createElement(Instructions_1.default, { collection: collection, onSetCollectionAttribute: this.setCollectionAttribute }))),
                    extInterfaces.map(ext => (React.createElement(react_bootstrap_1.Tab, { key: ext.id, eventKey: ext.id, title: ext.title(t) },
                        React.createElement(react_bootstrap_1.Panel, null,
                            React.createElement(ext.editComponent, { t: t, gameId: profile.gameId, collection: collection, revisionInfo: revision, onSetCollectionAttribute: this.setCollectionAttribute }))))),
                    !!Interface ? (React.createElement(react_bootstrap_1.Tab, { key: 'gamespecific', eventKey: 'gamespecific', title: game.name },
                        React.createElement(react_bootstrap_1.Panel, null,
                            React.createElement(Interface, { t: t, gameId: profile.gameId, collection: collection, revisionInfo: revision, onSetCollectionAttribute: this.setCollectionAttribute })))) : null))));
    }
    testUploadPossible() {
        var _a;
        const { t, collection } = this.props;
        const refMods = ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type));
        if (refMods.length === 0) {
            return (t('Can\'t upload an empty collection'));
        }
        else {
            return undefined;
        }
    }
    async updateState(props) {
        var _a, _b;
        this.nextState.page = INIT_PAGE;
        if (props.collection !== undefined) {
            const { collection } = props;
            const { revisionId, collectionSlug, revisionNumber } = (_a = collection.attributes) !== null && _a !== void 0 ? _a : {};
            if ((revisionId !== undefined) || (collectionSlug !== undefined)) {
                try {
                    this.nextState.revision = (_b = (await this.props.driver.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber))) !== null && _b !== void 0 ? _b : undefined;
                }
                catch (err) {
                    (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                        revisionId, collectionSlug, revisionNumber,
                        error: err.message,
                    });
                }
            }
        }
    }
}
function mapStateToProps(state, ownProps) {
    var _a, _b, _c, _d, _e, _f;
    const { settings } = state;
    return {
        phaseColumnVisible: (_d = (_c = (_b = (_a = settings.tables['collection-mods']) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.phase) === null || _c === void 0 ? void 0 : _c.enabled) !== null && _d !== void 0 ? _d : false,
        showPhaseUsage: (_e = settings.interface.usage['collection-phase']) !== null && _e !== void 0 ? _e : true,
        showBinpatchWarning: (_f = settings.interface.usage['binpatch-warning']) !== null && _f !== void 0 ? _f : true,
    };
}
function mapDispatchToProps(dispatch) {
    return {
        onSetModAttribute: (gameId, modId, key, value) => dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, key, value)),
        onAddRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.addModRule(gameId, modId, rule)),
        onRemoveRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.removeModRule(gameId, modId, rule)),
        onAddModsDialog: (collectionId) => dispatch((0, session_1.startAddModsToCollection)(collectionId)),
        onDismissPhaseUsage: () => dispatch(vortex_api_1.actions.showUsageInstruction('collection-phase', false)),
        onDismissBinpatchWarning: () => dispatch(vortex_api_1.actions.showUsageInstruction('binpatch-warning', false)),
        onShowPhaseColumn: () => dispatch(vortex_api_1.actions.setAttributeVisible('collection-mods', 'phase', true)),
    };
}
exports["default"] = (0, react_i18next_1.withTranslation)([constants_1.NAMESPACE, 'common'])((0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(CollectionEdit));


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionBanner.tsx":
/*!***********************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionBanner.tsx ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
class CollectionBanner extends vortex_api_1.ComponentEx {
    constructor() {
        super(...arguments);
        this.goGetPremium = () => {
            this.context.api.events.emit('analytics-track-click-event', 'Go Premium', 'Collections Added Collection');
            vortex_api_1.util.opn(vortex_api_1.util.nexusModsURL(constants_1.PREMIUM_PATH, {
                section: vortex_api_1.util.Section.Users,
                campaign: vortex_api_1.util.Campaign.BuyPremium,
                source: vortex_api_1.util.Source.CollectionsAd
            }))
                .catch(err => undefined);
        };
    }
    render() {
        const { t } = this.props;
        const electricBoltIconPath = 'assets/icons/electric-bolt.svg';
        const premiumPictogramPath = 'assets/pictograms/premium-pictogram.svg';
        return (React.createElement("div", { id: 'collection-premium-banner' },
            React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                    React.createElement(vortex_api_1.FlexLayout, { type: 'row', id: 'collection-premium-banner-header' },
                        React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                            React.createElement(vortex_api_1.Image, { className: 'premium-pictogram', srcs: [premiumPictogramPath] })),
                        React.createElement(vortex_api_1.FlexLayout.Flex, null,
                            React.createElement("div", { className: 'collections-premium-banner-title' }, t('Premium'))))),
                React.createElement(vortex_api_1.FlexLayout.Flex, null,
                    React.createElement("div", { className: 'collections-premium-banner-body' }, t('Auto-download collections at max speed'))),
                React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                    React.createElement(react_bootstrap_1.Button, { id: 'get-premium-button', className: 'small', onClick: this.goGetPremium },
                        React.createElement(vortex_api_1.Image, { srcs: [electricBoltIconPath] }),
                        t('Unlock max download speeds'))))));
    }
}
exports["default"] = CollectionBanner;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionInstructions.tsx":
/*!*****************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionInstructions.tsx ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const ReactMarkdown = __webpack_require__(/*! react-markdown */ "../../node_modules/react-markdown/src/react-markdown.js");
const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
function Instructions(props) {
    var _a, _b, _c;
    const { t, collection, mods, onToggleInstructions } = props;
    const { required, optional } = React.useMemo(() => {
        var _a;
        return ((_a = collection.rules) !== null && _a !== void 0 ? _a : []).reduce((prev, rule) => {
            var _a, _b;
            if (((0, util_1.isEmpty)((_a = rule.extra) === null || _a === void 0 ? void 0 : _a.instructions))
                || !['requires', 'recommends'].includes(rule.type)) {
                return prev;
            }
            const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
            if (mod !== undefined) {
                const entry = {
                    rule,
                    mod,
                    name: vortex_api_1.util.renderModReference(rule.reference),
                    instructions: (_b = rule.extra) === null || _b === void 0 ? void 0 : _b.instructions
                };
                if (rule.type === 'requires') {
                    prev.required.push(entry);
                }
                else {
                    prev.optional.push(entry);
                }
            }
            return prev;
        }, { required: [], optional: [] });
    }, [mods, collection]);
    const installInstructions = (((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.installInstructions) === undefined ||
        ((_b = collection.attributes) === null || _b === void 0 ? void 0 : _b.installInstructions) === '') &&
        (required.length === 0) &&
        (optional.length === 0) ?
        t(constants_1.DEFAULT_INSTRUCTIONS) :
        (_c = collection.attributes) === null || _c === void 0 ? void 0 : _c.installInstructions;
    return (React.createElement(React.Fragment, null,
        React.createElement(ReactMarkdown, { className: 'collection-instructions-text', allowedElements: ['p', 'br', 'a', 'em', 'strong'], unwrapDisallowed: true }, installInstructions),
        (required.length > 0) ? (React.createElement(React.Fragment, null,
            React.createElement("h4", null, t('Instructions - Required Mods')),
            React.createElement("div", { className: 'collection-instructions-container' },
                React.createElement("table", null,
                    React.createElement("tbody", null, required.map((iter) => {
                        var _a;
                        return (React.createElement("tr", { key: iter.name },
                            React.createElement("td", { className: 'collection-mod-name' }, iter.name),
                            React.createElement("td", { className: 'collection-mod-instructions' },
                                React.createElement(ReactMarkdown, { allowedElements: ['p', 'br', 'a', 'em', 'strong'], unwrapDisallowed: true }, iter.instructions)),
                            React.createElement("td", { className: 'collection-mod-actions' },
                                React.createElement(react_bootstrap_1.Button, { "data-modid": (_a = iter.mod) === null || _a === void 0 ? void 0 : _a.id, onClick: onToggleInstructions }, t('Open instructions')))));
                    })))))) : null,
        (optional.length > 0) ? (React.createElement(React.Fragment, null,
            React.createElement("h4", null, t('Instructions - Optional Mods')),
            React.createElement("div", { className: 'collection-instructions-container' },
                React.createElement("table", null,
                    React.createElement("tbody", null, optional.map(iter => {
                        var _a;
                        return (React.createElement("tr", { key: iter.name },
                            React.createElement("td", { className: 'collection-mod-name' }, iter.name),
                            React.createElement("td", { className: 'collection-mod-instructions' },
                                React.createElement(ReactMarkdown, { allowedElements: ['p', 'br', 'a', 'em', 'strong'], unwrapDisallowed: true }, iter.instructions)),
                            React.createElement("td", { className: 'collection-mod-actions' },
                                React.createElement(react_bootstrap_1.Button, { "data-modid": (_a = iter.mod) === null || _a === void 0 ? void 0 : _a.id, onClick: onToggleInstructions }, t('Open instructions')))));
                    })))))) : null));
}
exports["default"] = Instructions;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionItemStatus.tsx":
/*!***************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionItemStatus.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const RadialProgressT = vortex_api_1.RadialProgress;
class CollectionItemStatus extends React.Component {
    render() {
        var _a, _b;
        const { t, download, mod } = this.props;
        if (mod.collectionRule['ignored'] === true) {
            return (React.createElement("div", { className: 'collection-status-ignored' },
                React.createElement(vortex_api_1.Icon, { name: 'toggle-disabled' }),
                t('Ignored')));
        }
        if (mod.state === 'installed') {
            if (mod.enabled) {
                return (React.createElement("div", { className: 'collection-status-enabled' },
                    React.createElement(vortex_api_1.Icon, { name: 'toggle-enabled' }),
                    t('Enabled')));
            }
            else {
                return (React.createElement("div", { className: 'collection-status-disabled' },
                    React.createElement(vortex_api_1.Icon, { name: 'toggle-disabled' }),
                    t('Disabled')));
            }
        }
        else if (mod.state === 'installing') {
            const progressBarData = {
                min: 0,
                max: 100,
                value: ((_a = mod.progress) !== null && _a !== void 0 ? _a : 0) * 100,
                class: 'collection-install-progress',
            };
            return (React.createElement("div", { className: 'collection-status-progress' },
                React.createElement(RadialProgressT, { className: 'collection-progress-radial', data: [progressBarData], totalRadius: 32 }),
                React.createElement("div", { className: 'progress-title' }, t('Installing...'))));
        }
        else if (mod.state === 'downloading') {
            if ((download === null || download === void 0 ? void 0 : download.state) === 'paused') {
                return (React.createElement("div", { className: 'collection-status-paused' },
                    React.createElement(vortex_api_1.Icon, { name: 'pause' }),
                    t('Download paused')));
            }
            else if ((download === null || download === void 0 ? void 0 : download.state) === 'failed') {
                return (React.createElement("div", { className: 'collection-status-failed' },
                    React.createElement(vortex_api_1.Icon, { name: 'warning' }),
                    t('Download failed')));
            }
            const progressBarData = {
                min: 0,
                max: 100,
                value: ((_b = mod.progress) !== null && _b !== void 0 ? _b : 0) * 100,
                class: 'collection-install-progress',
            };
            return (React.createElement("div", { className: 'collection-status-progress' },
                React.createElement(RadialProgressT, { className: 'collection-progress-radial', data: [progressBarData], totalRadius: 32 }),
                React.createElement("div", { className: 'progress-title' }, t('Downloading...'))));
        }
        else {
            if (mod.collectionRule.type === 'recommends') {
                return (React.createElement("div", { className: 'collection-status-notinstalled' },
                    React.createElement(vortex_api_1.Icon, { name: 'install' }),
                    " ",
                    t('Not installed')));
            }
            else {
                if (mod.state === 'downloaded') {
                    return (React.createElement("div", { className: 'collection-status-pending' },
                        React.createElement(vortex_api_1.Icon, { name: 'install' }),
                        t('Install pending')));
                }
                else {
                    return (React.createElement("div", { className: 'collection-status-pending' },
                        React.createElement(vortex_api_1.Icon, { name: 'download' }),
                        t('Download pending')));
                }
            }
        }
    }
}
exports["default"] = CollectionItemStatus;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionModDetails.tsx":
/*!***************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionModDetails.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
function CollectionModDetails(props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17;
    const { t, gameId, local, remote } = props;
    const uploaderName = (_e = (_b = (_a = local === null || local === void 0 ? void 0 : local.attributes) === null || _a === void 0 ? void 0 : _a.uploader) !== null && _b !== void 0 ? _b : (_d = (_c = remote === null || remote === void 0 ? void 0 : remote.file) === null || _c === void 0 ? void 0 : _c.owner) === null || _d === void 0 ? void 0 : _d.name) !== null && _e !== void 0 ? _e : constants_1.AUTHOR_UNKNOWN;
    const uploaderId = (_g = (_f = local === null || local === void 0 ? void 0 : local.attributes) === null || _f === void 0 ? void 0 : _f.uploaderId) !== null && _g !== void 0 ? _g : (_j = (_h = remote === null || remote === void 0 ? void 0 : remote.file) === null || _h === void 0 ? void 0 : _h.owner) === null || _j === void 0 ? void 0 : _j.memberId;
    const uploaderAvatar = (_m = (_l = (_k = remote === null || remote === void 0 ? void 0 : remote.file) === null || _k === void 0 ? void 0 : _k.owner) === null || _l === void 0 ? void 0 : _l.avatar) !== null && _m !== void 0 ? _m : 'assets/images/noavatar.png';
    const authorName = (_s = (_p = (_o = local === null || local === void 0 ? void 0 : local.attributes) === null || _o === void 0 ? void 0 : _o.author) !== null && _p !== void 0 ? _p : (_r = (_q = remote === null || remote === void 0 ? void 0 : remote.file) === null || _q === void 0 ? void 0 : _q.mod) === null || _r === void 0 ? void 0 : _r.author) !== null && _s !== void 0 ? _s : constants_1.AUTHOR_UNKNOWN;
    const modTitle = (_w = (_t = vortex_api_1.util.renderModName(local)) !== null && _t !== void 0 ? _t : (_v = (_u = remote === null || remote === void 0 ? void 0 : remote.file) === null || _u === void 0 ? void 0 : _u.mod) === null || _v === void 0 ? void 0 : _v.name) !== null && _w !== void 0 ? _w : '';
    const version = (_0 = (_y = (_x = local === null || local === void 0 ? void 0 : local.attributes) === null || _x === void 0 ? void 0 : _x.version) !== null && _y !== void 0 ? _y : (_z = remote === null || remote === void 0 ? void 0 : remote.file) === null || _z === void 0 ? void 0 : _z.version) !== null && _0 !== void 0 ? _0 : '???';
    const description = (_5 = (_2 = (_1 = local === null || local === void 0 ? void 0 : local.attributes) === null || _1 === void 0 ? void 0 : _1.shortDescription) !== null && _2 !== void 0 ? _2 : (_4 = (_3 = remote === null || remote === void 0 ? void 0 : remote.file) === null || _3 === void 0 ? void 0 : _3.mod) === null || _4 === void 0 ? void 0 : _4.summary) !== null && _5 !== void 0 ? _5 : '';
    const image = (_7 = (_6 = local === null || local === void 0 ? void 0 : local.attributes) === null || _6 === void 0 ? void 0 : _6.pictureUrl) !== null && _7 !== void 0 ? _7 : (_9 = (_8 = remote === null || remote === void 0 ? void 0 : remote.file) === null || _8 === void 0 ? void 0 : _8.mod) === null || _9 === void 0 ? void 0 : _9.pictureUrl;
    const domainName = (_12 = (_11 = (_10 = remote === null || remote === void 0 ? void 0 : remote.file) === null || _10 === void 0 ? void 0 : _10.game) === null || _11 === void 0 ? void 0 : _11.domainName) !== null && _12 !== void 0 ? _12 : vortex_api_1.util.nexusGameId(vortex_api_1.util.getGame((_14 = (_13 = local === null || local === void 0 ? void 0 : local.attributes) === null || _13 === void 0 ? void 0 : _13.gameId) !== null && _14 !== void 0 ? _14 : gameId));
    const modId = (_16 = (_15 = local === null || local === void 0 ? void 0 : local.attributes) === null || _15 === void 0 ? void 0 : _15.modId) !== null && _16 !== void 0 ? _16 : (_17 = remote === null || remote === void 0 ? void 0 : remote.file) === null || _17 === void 0 ? void 0 : _17.modId;
    const visitUploader = React.useCallback(() => {
        vortex_api_1.util.opn(`${constants_1.NEXUS_BASE_URL}/users/${uploaderId}`);
    }, [uploaderId]);
    const visitPage = React.useCallback(() => {
        vortex_api_1.util.opn(`${constants_1.NEXUS_BASE_URL}/${domainName}/mods/${modId}`);
    }, [uploaderId]);
    return (React.createElement("div", { className: 'installing-mod-overview' },
        React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-mod-detail-imagecontainer' }, (image)
                ? React.createElement(vortex_api_1.ZoomableImage, { className: 'installing-mod-image', url: image })
                : null),
            React.createElement(vortex_api_1.FlexLayout.Flex, { fill: true },
                React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                    React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                        React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                            React.createElement("div", { className: 'installing-mod-title' }, modTitle),
                            (modId !== undefined) ? (React.createElement(vortex_api_1.tooltip.IconButton, { className: 'collection-open-mod-in-browser', icon: 'open-in-browser', tooltip: t('Open Mod in Webbrowser'), onClick: visitPage })) : null)),
                    React.createElement(vortex_api_1.FlexLayout.Flex, null,
                        React.createElement("div", { className: 'collection-description' }, vortex_api_1.util.bbcodeToReact(description))),
                    React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                        React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell' },
                                React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                    React.createElement(vortex_api_1.Image, { srcs: [uploaderAvatar], circle: true }),
                                    React.createElement("div", null,
                                        React.createElement("div", { className: 'title' }, t('Uploaded by')),
                                        React.createElement("div", null, (uploaderName !== constants_1.AUTHOR_UNKNOWN)
                                            ? React.createElement("a", { onClick: visitUploader }, uploaderName)
                                            : uploaderName)))),
                            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell' },
                                React.createElement("div", { className: 'title' }, t('Created by')),
                                React.createElement("div", null, authorName)),
                            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell' },
                                React.createElement("div", { className: 'title' }, t('Version')),
                                React.createElement("div", null, version)))))))));
}
exports["default"] = CollectionModDetails;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionOverview.tsx":
/*!*************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionOverview.tsx ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const CollectionReleaseStatus_1 = __webpack_require__(/*! ../CollectionReleaseStatus */ "./src/views/CollectionReleaseStatus.tsx");
const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
const HealthIndicator_1 = __webpack_require__(/*! ./HealthIndicator */ "./src/views/CollectionPageView/HealthIndicator.tsx");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const persistent_1 = __webpack_require__(/*! ../../actions/persistent */ "./src/actions/persistent.ts");
const session_1 = __webpack_require__(/*! ../../actions/session */ "./src/actions/session.ts");
const ENDORSE_DELAY_MS = 43200000;
function EndorseButton(props) {
    var _a, _b, _c, _d;
    const { t, collection, gameId, mod, voteAllowed } = props;
    const context = React.useContext(vortex_api_1.MainContext);
    const endorse = React.useCallback(async () => {
        var _a, _b;
        const endorsedStatus = (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.endorsed) !== null && _b !== void 0 ? _b : 'Undecided';
        context.api.events.emit('endorse-mod', gameId, mod.id, endorsedStatus);
        context.api.events.emit('analytics-track-click-event', 'Collections', endorsedStatus);
        setTimeout(async () => {
            refreshCollection(context.api, collection);
        }, 500);
    }, [mod, collection]);
    const endorsedStatus = (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.endorsed) !== null && _b !== void 0 ? _b : 'Undecided';
    const endorsed = (((_c = mod.attributes) === null || _c === void 0 ? void 0 : _c.endorsed) === 'Endorsed');
    const classes = `collection-ghost-button ${endorsed ? 'endorse-yes' : 'endorse-maybe'}`;
    const { icon, toolTip } = {
        undecided: { icon: 'endorse-maybe', toolTip: t('Undecided') },
        abstained: { icon: 'endorse-maybe', toolTip: t('Abstained') },
        endorsed: { icon: 'endorse-yes', toolTip: t('Endorsed') },
        disabled: { icon: 'endorse-disabled', toolTip: t('Endorsement disabled by author') },
        pending: { icon: 'spinner_new', toolTip: t('Pending') }
    }[endorsedStatus.toLowerCase()] || { icon: 'like-maybe', toolTip: t('Undecided') };
    return (React.createElement(vortex_api_1.tooltip.IconButton, { icon: icon, tooltip: toolTip, className: classes, onClick: endorse, disabled: !voteAllowed || ((collection === null || collection === void 0 ? void 0 : collection.endorsements) === undefined), spin: endorsedStatus.toLowerCase() === 'pending' }, (_d = collection === null || collection === void 0 ? void 0 : collection.endorsements) !== null && _d !== void 0 ? _d : '?'));
}
function CommentButton(props) {
    var _a, _b;
    const { t, collection } = props;
    const context = React.useContext(vortex_api_1.MainContext);
    const click = React.useCallback(() => {
        if ((collection === null || collection === void 0 ? void 0 : collection['commentLink']) !== undefined) {
            context.api.events.emit('analytics-track-click-event', 'Collections', 'Comments');
            vortex_api_1.util.opn(collection['commentLink']);
        }
    }, [collection]);
    return (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'comments', className: 'collection-ghost-button', tooltip: t('Comments'), onClick: click, disabled: (collection === null || collection === void 0 ? void 0 : collection['commentLink']) === undefined }, (_b = (_a = collection === null || collection === void 0 ? void 0 : collection.forumTopic) === null || _a === void 0 ? void 0 : _a.postsCount) !== null && _b !== void 0 ? _b : 0));
}
async function refreshCollection(api, collection) {
    if (!(collection === null || collection === void 0 ? void 0 : collection.slug)) {
        return;
    }
    (0, vortex_api_1.log)('info', `refreshCollection ${collection.slug}`);
    const result = (await api.emitAndAwait('get-nexus-collection', collection.slug))[0];
    api.store.dispatch((0, persistent_1.updateCollectionInfo)(collection.id.toString(), result, Date.now()));
}
class CollectionOverview extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.enable = () => {
            this.props.onSetEnabled(true);
        };
        this.disable = () => {
            this.props.onSetEnabled(false);
        };
        this.openUrl = () => {
            const { revision } = this.props;
            const { collection } = revision;
            if (collection !== undefined && (revision === null || revision === void 0 ? void 0 : revision.revisionNumber) !== undefined) {
                this.context.api.events.emit('analytics-track-click-event', 'Collections', 'View on site Added Collection');
                vortex_api_1.util.opn(vortex_api_1.util.nexusModsURL([
                    collection.game.domainName,
                    'collections',
                    collection.slug,
                    'revisions',
                    revision.revisionNumber.toString(),
                ], {
                    campaign: vortex_api_1.util.Campaign.ViewCollection,
                    section: vortex_api_1.util.Section.Collections,
                }));
            }
        };
        this.cloneCollection = () => {
            const { onClone, collection } = this.props;
            if (onClone !== undefined && collection !== undefined) {
                onClone(collection.id);
                this.context.api.events.emit('analytics-track-click-event', 'Collections', 'Clone');
            }
        };
        this.remove = () => {
            const { onRemove, collection } = this.props;
            if (onRemove !== undefined && collection !== undefined) {
                onRemove(collection.id);
            }
        };
        this.voteSuccess = (success) => {
            var _a, _b;
            const { collection, profile, revision, showDownvoteResponse, showUpvoteResponse, onSuppressVoteResponse, onVoteSuccess, } = this.props;
            if (revision.collection === undefined) {
                (0, vortex_api_1.log)('error', 'failed to show vote response dialog, missing collection info');
                return;
            }
            const bugLink = `https://next.nexusmods.com/${revision.collection.game.domainName}/collections/${revision.collection.slug}?tab=Bugs`;
            const endorsedStatus = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.endorsed) !== null && _b !== void 0 ? _b : 'Undecided';
            if (success && showUpvoteResponse) {
                onVoteSuccess === null || onVoteSuccess === void 0 ? void 0 : onVoteSuccess(collection.id, success);
                if (endorsedStatus === 'Endorsed')
                    return;
                this.context.api.showDialog('question', 'Collection was successful', {
                    text: 'Congratulations! Please consider endorsing this collection if you are enjoying it. ' +
                        'Endorsing helps others discover this collection and lets the curator know you enjoyed it.',
                    checkboxes: [
                        { id: 'dont_show_again', value: false, text: "Don't show again" },
                    ],
                }, [
                    { label: 'Close' },
                    {
                        label: 'Endorse',
                        action: () => {
                            this.context.api.events.emit('endorse-mod', profile.gameId, collection.id, endorsedStatus);
                            this.context.api.events.emit('analytics-track-click-event', 'Collections', endorsedStatus);
                        },
                    },
                ])
                    .then((result) => {
                    if (result.input['dont_show_again']) {
                        onSuppressVoteResponse('upvote');
                    }
                });
            }
            else if (!success && showDownvoteResponse) {
                this.context.api.store.dispatch((0, session_1.healthDownvoteDialog)(collection.id));
            }
        };
        this.initState({ selIdx: 0 });
        this.mWorkshopActions = [
            {
                title: 'Enable',
                action: this.enable,
                condition: () => {
                    var _a, _b;
                    const { collection, incomplete, profile } = this.props;
                    return (!incomplete && ((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[collection.id]) === null || _b === void 0 ? void 0 : _b.enabled) !== true);
                },
                icon: 'toggle-enabled',
            },
            {
                title: 'View on Nexus Mods',
                action: this.openUrl,
                condition: () => {
                    var _a;
                    return ((_a = this.props.collection.attributes) === null || _a === void 0 ? void 0 : _a.collectionSlug) !== undefined &&
                        this.props.revision !== undefined;
                },
                icon: 'open-in-browser',
            },
            {
                title: 'Disable',
                action: this.disable,
                condition: () => {
                    var _a, _b;
                    const { collection, incomplete, profile } = this.props;
                    return (!incomplete && ((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[collection.id]) === null || _b === void 0 ? void 0 : _b.enabled) === true);
                },
                icon: 'toggle-disabled',
            },
            {
                title: 'Show in Mods',
                action: this.props.onShowMods,
                icon: 'inspect',
            },
            {
                title: 'Edit (Workshop)',
                action: this.cloneCollection,
                condition: () => this.props.onClone !== undefined,
                icon: 'clone',
            },
            {
                title: 'Remove',
                action: this.remove,
                condition: () => this.props.onRemove !== undefined,
                icon: 'remove',
            },
        ];
    }
    componentDidMount() {
        const { revision } = this.props;
        refreshCollection(this.context.api, revision.collection);
    }
    render() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
        const { t, collection, incomplete, profile, revision, votedSuccess } = this.props;
        const classes = ['collection-overview'];
        const timeSinceInstall = Date.now() - new Date(((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.installCompleted) ? (_b = collection.attributes) === null || _b === void 0 ? void 0 : _b.installCompleted : (_d = (_c = collection.attributes) === null || _c === void 0 ? void 0 : _c.installTime) !== null && _d !== void 0 ? _d : 0).getTime();
        const voteAllowed = timeSinceInstall >= ENDORSE_DELAY_MS;
        const rating = {
            average: parseFloat((_f = (_e = revision.collection) === null || _e === void 0 ? void 0 : _e.overallRating) !== null && _f !== void 0 ? _f : '100'),
            total: (_h = (_g = revision.collection) === null || _g === void 0 ? void 0 : _g.overallRatingCount) !== null && _h !== void 0 ? _h : 0,
        };
        return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' ') },
            React.createElement(react_bootstrap_1.Media, null,
                React.createElement(react_bootstrap_1.Media.Left, null,
                    React.createElement(CollectionTile_1.default, { t: t, imageTime: Date.now(), collection: collection, gameId: profile.gameId, details: false })),
                React.createElement(react_bootstrap_1.Media.Body, null,
                    React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                        React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                            React.createElement("div", { className: 'collection-overview-title' },
                                React.createElement("div", { className: 'collection-title' }, vortex_api_1.util.renderModName(collection)),
                                React.createElement(CollectionReleaseStatus_1.default, { t: t, active: true, enabled: (_l = (_k = (_j = profile.modState) === null || _j === void 0 ? void 0 : _j[collection.id]) === null || _k === void 0 ? void 0 : _k.enabled) !== null && _l !== void 0 ? _l : false, collection: collection, incomplete: incomplete }),
                                React.createElement("div", { className: 'flex-filler' }))),
                        React.createElement(vortex_api_1.FlexLayout.Flex, { className: 'collection-description-container' },
                            React.createElement("div", { className: 'collection-description' }, (_o = (_m = collection.attributes) === null || _m === void 0 ? void 0 : _m.shortDescription) !== null && _o !== void 0 ? _o : t('No description'))),
                        React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-page-detail-bar' },
                            React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell ' },
                                    React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                        React.createElement(vortex_api_1.Image, { srcs: [
                                                (_q = (_p = collection.attributes) === null || _p === void 0 ? void 0 : _p.uploaderAvatar) !== null && _q !== void 0 ? _q : 'assets/images/noavatar.png',
                                            ], circle: true }),
                                        React.createElement("div", null,
                                            React.createElement("div", { className: 'title' }, t('Curated by')),
                                            React.createElement("div", null, (_r = collection.attributes) === null || _r === void 0 ? void 0 : _r.uploader)))),
                                React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell hideable' },
                                    React.createElement("div", { className: 'title' }, t('Revision')),
                                    React.createElement("div", null, (_s = collection.attributes) === null || _s === void 0 ? void 0 : _s.revisionNumber)),
                                React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell' },
                                    React.createElement("div", { className: 'title' }, t('Last updated')),
                                    React.createElement("div", null, this.renderTime((_t = collection.attributes) === null || _t === void 0 ? void 0 : _t.updatedTimestamp))),
                                React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell hideable' },
                                    React.createElement("div", { className: 'title' }, t('Uploaded')),
                                    React.createElement("div", null, this.renderTime((_u = collection.attributes) === null || _u === void 0 ? void 0 : _u.uploadedTimestamp))),
                                React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                    React.createElement(EndorseButton, { t: t, collection: revision.collection, mod: collection, gameId: profile.gameId, voteAllowed: voteAllowed })),
                                React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                    React.createElement(CommentButton, { t: t, collection: revision.collection })),
                                React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                    React.createElement("div", null)))))),
                React.createElement(react_bootstrap_1.Media.Right, null,
                    React.createElement("div", { className: 'collection-health-container' },
                        React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                            React.createElement(vortex_api_1.FlexLayout.Fixed, null, (revision === null || revision === void 0 ? void 0 : revision.revisionStatus) !== 'is_private' ? (React.createElement(HealthIndicator_1.default, { t: t, revisionNumber: (_v = revision === null || revision === void 0 ? void 0 : revision.revisionNumber) !== null && _v !== void 0 ? _v : 0, value: rating, onVoteSuccess: this.voteSuccess, ownSuccess: votedSuccess, voteAllowed: voteAllowed, gameVersion: (_y = (_x = (_w = this.context.api.getState().persistent) === null || _w === void 0 ? void 0 : _w.gameMode) === null || _x === void 0 ? void 0 : _x.versions[profile.gameId]) !== null && _y !== void 0 ? _y : '?', collectionGameVersion: (_1 = (_0 = (_z = revision === null || revision === void 0 ? void 0 : revision.gameVersions) === null || _z === void 0 ? void 0 : _z[0]) === null || _0 === void 0 ? void 0 : _0.reference) !== null && _1 !== void 0 ? _1 : '?' })) : null),
                            React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                React.createElement("div", { className: 'collection-workshop-actions' },
                                    React.createElement(vortex_api_1.ActionDropdown, { t: t, id: 'collection-workshop-actions', staticElements: this.mWorkshopActions })))))))));
    }
    renderTime(timestamp) {
        const { t, language } = this.props;
        if (timestamp === undefined) {
            return t('Never');
        }
        return new Date(timestamp).toLocaleDateString(language);
    }
}
exports["default"] = CollectionOverview;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionOverviewSelection.tsx":
/*!**********************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionOverviewSelection.tsx ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const CollectionModDetails_1 = __webpack_require__(/*! ./CollectionModDetails */ "./src/views/CollectionPageView/CollectionModDetails.tsx");
const CollectionReleaseStatus_1 = __webpack_require__(/*! ../CollectionReleaseStatus */ "./src/views/CollectionReleaseStatus.tsx");
const SlideshowControls_1 = __webpack_require__(/*! ./SlideshowControls */ "./src/views/CollectionPageView/SlideshowControls.tsx");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
class CollectionOverview extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.setSelection = (idx) => {
            this.nextState.selIdx = (this.props.modSelection.length === 0)
                ? 0
                : idx % this.props.modSelection.length;
        };
        this.initState({ selIdx: 0 });
    }
    render() {
        var _a, _b, _c, _d, _e;
        const { t, collection, incomplete, modSelection, profile } = this.props;
        let { selIdx } = this.state;
        if (selIdx >= modSelection.length) {
            selIdx = 0;
        }
        const modDetails = modSelection.length > 0;
        const classes = ['collection-overview'];
        if (modDetails) {
            classes.push('collection-mod-selection');
        }
        return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' ') },
            React.createElement("div", { className: 'collection-overview-title' },
                React.createElement("div", { className: 'collection-title' }, vortex_api_1.util.renderModName(collection)),
                React.createElement(CollectionReleaseStatus_1.default, { t: t, active: true, enabled: (_c = (_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[collection.id]) === null || _b === void 0 ? void 0 : _b.enabled) !== null && _c !== void 0 ? _c : false, collection: collection, incomplete: incomplete }),
                modSelection.length > 1 ? (React.createElement(React.Fragment, null,
                    React.createElement(SlideshowControls_1.default, { t: t, numItems: modSelection.length, onChangeItem: this.setSelection, autoProgressTimeMS: 5000 }),
                    React.createElement("div", { className: 'flex-filler' }),
                    React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed', tooltip: t('Deselects mods'), icon: 'close', onClick: this.props.onDeselectMods }))) : null),
            React.createElement(CollectionModDetails_1.default, { t: t, local: (_d = modSelection[selIdx]) === null || _d === void 0 ? void 0 : _d.local, remote: (_e = modSelection[selIdx]) === null || _e === void 0 ? void 0 : _e.remote, gameId: profile.gameId })));
    }
}
exports["default"] = CollectionOverview;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionProgress.tsx":
/*!*************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionProgress.tsx ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const CollectionBanner_1 = __webpack_require__(/*! ./CollectionBanner */ "./src/views/CollectionPageView/CollectionBanner.tsx");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
class CollectionProgress extends vortex_api_1.ComponentEx {
    static getDerivedStateFromProps(props, state) {
        return {
            totalSize: (0, util_1.calculateCollectionSize)(props.mods),
        };
    }
    constructor(props) {
        super(props);
        this.initState({
            totalSize: 0,
        });
    }
    render() {
        var _a;
        const { t, activity, downloads, isPremium, mods, profile, totalSize, onCancel, onPause, onResume } = this.props;
        const group = (mod, download) => {
            var _a, _b, _c;
            if ((mod.state === 'downloading') && ((download === null || download === void 0 ? void 0 : download.state) === 'paused')) {
                return 'pending';
            }
            if ((mod.state === 'installed') && !((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[mod.id]) === null || _b === void 0 ? void 0 : _b.enabled)) {
                return 'disabled';
            }
            return (_c = {
                null: 'pending',
                installed: 'done',
                downloaded: 'pending',
                installing: 'installing',
                downloading: 'downloading',
            }[mod.state]) !== null && _c !== void 0 ? _c : 'pending';
        };
        const { pending, downloading, installing, disabled, done } = Object.values(mods).reduce((prev, mod) => {
            if ((mod.collectionRule.type === 'requires') && !mod.collectionRule['ignored']) {
                prev[group(mod, downloads[mod.archiveId])].push(mod);
            }
            return prev;
        }, { pending: [], downloading: [], installing: [], disabled: [], done: [] });
        if ((downloading.length === 0)
            && (installing.length === 0)
            && (pending.length === 0)
            && (disabled.length === 0)) {
            return null;
        }
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
            React.createElement(vortex_api_1.FlexLayout.Flex, null,
                React.createElement(react_bootstrap_1.Panel, null,
                    React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-progress-flex' },
                        (((_a = activity['dependencies']) !== null && _a !== void 0 ? _a : []).length > 0)
                            ? this.renderActivity(t('Checking Dependencies'))
                            : this.renderBars(installing, done),
                        React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                            React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-pause-cancel-flex' },
                                (onResume !== undefined) ? (React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed btn-pause-resume', onClick: onResume, disabled: onResume === null, tooltip: t('Resume'), icon: 'resume' })) : null,
                                (onPause !== undefined) ? (React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed btn-pause-resume', onClick: onPause, tooltip: t('Pause'), icon: 'pause' })) : null,
                                React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed btn-cancel', onClick: onCancel, icon: 'stop', tooltip: t('Cancel') }, t('Cancel'))))))),
            isPremium ? null : (React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-banner-container' },
                React.createElement(CollectionBanner_1.default, { t: t, totalSize: totalSize })))));
    }
    renderActivity(message) {
        return (React.createElement(vortex_api_1.FlexLayout.Flex, null,
            React.createElement(vortex_api_1.Spinner, null),
            ' ',
            message));
    }
    renderBars(installing, done) {
        const { t, downloads, mods } = this.props;
        const { totalSize } = this.state;
        const curInstall = (installing.length > 0)
            ? installing.find(iter => iter.state === 'installing')
            : undefined;
        const downloadProgress = Object.values(mods).reduce((prev, mod) => {
            var _a;
            let size = 0;
            if ((mod.state === 'downloading') || (mod.state === null)) {
                const download = downloads[mod.archiveId];
                size += (download === null || download === void 0 ? void 0 : download.received) || 0;
            }
            else {
                size += ((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.fileSize) || 0;
            }
            return prev + size;
        }, 0);
        const relevant = Object.values(mods).filter(util_1.isRelevant);
        return (React.createElement(React.Fragment, null,
            React.createElement(vortex_api_1.ProgressBar, { now: downloadProgress, max: totalSize, showPercentage: true, labelLeft: t('Downloading'), labelRight: `${vortex_api_1.util.bytesToString(downloadProgress)} / ${vortex_api_1.util.bytesToString(totalSize)}` }),
            React.createElement(vortex_api_1.ProgressBar, { now: done.length, max: relevant.length, showPercentage: true, labelLeft: installing.length > 0 ? t('Installing') : t('Waiting to install'), labelRight: curInstall !== undefined ? vortex_api_1.util.renderModName(curInstall) : undefined })));
    }
}
exports["default"] = CollectionProgress;


/***/ }),

/***/ "./src/views/CollectionPageView/HealthDownvoteDialog.tsx":
/*!***************************************************************!*\
  !*** ./src/views/CollectionPageView/HealthDownvoteDialog.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const session_1 = __webpack_require__(/*! ../../actions/session */ "./src/actions/session.ts");
const persistent_1 = __webpack_require__(/*! ../../actions/persistent */ "./src/actions/persistent.ts");
function HealthDownvoteDialog(props) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const [optionValue, setOptionValue] = React.useState(undefined);
    const [confirmationCheck, setConfirmationCheck] = React.useState(false);
    const context = React.useContext(vortex_api_1.MainContext);
    const { t } = (0, react_i18next_1.useTranslation)(constants_1.NAMESPACE);
    const dispatch = (0, react_redux_1.useDispatch)();
    const state = context.api.store.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const collectionId = (0, react_redux_1.useSelector)((state) => { var _a; return (_a = state.session.collections.healthDownvoteDialog) !== null && _a !== void 0 ? _a : undefined; });
    const collection = (collectionId !== undefined)
        ? (_a = state.persistent.mods[gameId]) === null || _a === void 0 ? void 0 : _a[collectionId]
        : undefined;
    let revisionInfo;
    let collectionInfo;
    let commentLink = '#';
    let bugLink = '#';
    if (((_b = collection === null || collection === void 0 ? void 0 : collection.attributes) === null || _b === void 0 ? void 0 : _b.revisionId) !== undefined) {
        revisionInfo = (_d = (_c = state.persistent.collections.revisions) === null || _c === void 0 ? void 0 : _c[collection.attributes.revisionId]) === null || _d === void 0 ? void 0 : _d.info;
        if ((revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.collection) !== undefined) {
            collectionInfo = (_f = (_e = state.persistent.collections.collections) === null || _e === void 0 ? void 0 : _e[revisionInfo.collection.id]) === null || _f === void 0 ? void 0 : _f.info;
            commentLink = (_g = collectionInfo === null || collectionInfo === void 0 ? void 0 : collectionInfo['commentLink']) !== null && _g !== void 0 ? _g : '#';
            bugLink = (_h = `https://next.nexusmods.com/${collectionInfo.game.domainName}/collections/${collectionInfo.slug}?tab=Bugs`) !== null && _h !== void 0 ? _h : '#';
        }
    }
    const hide = React.useCallback(() => {
        dispatch((0, session_1.healthDownvoteDialog)(undefined));
    }, []);
    const downvote = () => {
        sendRating(false);
        hide();
    };
    const onChecked = (evt) => {
        setConfirmationCheck(evt.currentTarget.checked);
    };
    const sendRating = async (success) => {
        var _a, _b;
        const revisionId = (_b = (_a = collection === null || collection === void 0 ? void 0 : collection.attributes) === null || _a === void 0 ? void 0 : _a.revisionId) !== null && _b !== void 0 ? _b : undefined;
        const vote = success ? 'positive' : 'negative';
        const voted = (await context.api.emitAndAwait('rate-nexus-collection-revision', parseInt(revisionId, 10), vote))[0];
        if (voted.success) {
            dispatch((0, persistent_1.updateSuccessRate)(revisionId, vote, voted.averageRating.average, voted.averageRating.total));
        }
    };
    return (React.createElement(vortex_api_1.Modal, { id: 'collection-health-downvote-dialog', className: 'collection-health-downvote-dialog', show: collection !== undefined, onHide: hide },
        React.createElement(vortex_api_1.Modal.Header, null,
            React.createElement(vortex_api_1.Modal.Title, null, t('Downvote Success Rating'))),
        React.createElement(vortex_api_1.Modal.Body, null,
            React.createElement("p", null, t(`Sorry to hear that the collection \"${vortex_api_1.util.renderModName(collection)}\" isn't working for you. Here are some steps that could help:`)),
            React.createElement("ol", null,
                React.createElement("li", null, "Make sure your game version matches the game version the collection was created for."),
                React.createElement("li", null, "Read the collection instructions and check if you've missed any steps."),
                React.createElement("li", null,
                    React.createElement("a", { href: commentLink }, "Check comments on Nexus Mods"),
                    " for advice and to reach out to the collection curator."),
                React.createElement("li", null,
                    React.createElement("a", { href: bugLink }, "View bug reports on Nexus Mods"),
                    " or report a new bug to help the curator fix the issue.")),
            React.createElement("h5", null, t(`Success ratings help others know if a collection installs and runs correctly. They are not a vote on whether you liked the collection or not.`)),
            React.createElement(react_bootstrap_1.FormGroup, null,
                React.createElement(react_bootstrap_1.Checkbox, { onChange: onChecked }, t('I have tried the above steps and confirm this collection does not work.')))),
        React.createElement(vortex_api_1.Modal.Footer, null,
            React.createElement(react_bootstrap_1.Button, { onClick: hide }, t('Cancel')),
            React.createElement(react_bootstrap_1.Button, { onClick: downvote, disabled: !confirmationCheck }, t('Submit')))));
}
exports["default"] = HealthDownvoteDialog;


/***/ }),

/***/ "./src/views/CollectionPageView/HealthIndicator.tsx":
/*!**********************************************************!*\
  !*** ./src/views/CollectionPageView/HealthIndicator.tsx ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function HealthIndicator(props) {
    const context = React.useContext(vortex_api_1.MainContext);
    const { t, onVoteSuccess, ownSuccess, revisionNumber, value, voteAllowed, gameVersion, collectionGameVersion } = props;
    const voteSuccess = React.useCallback((evt) => {
        const { success } = evt.currentTarget.dataset;
        const isUpvote = success === 'true';
        if (ownSuccess) {
            if (ownSuccess === 'positive' && isUpvote) {
                return;
            }
            if (ownSuccess === 'negative' && !isUpvote) {
                return;
            }
        }
        onVoteSuccess(isUpvote);
        context.api.events.emit('analytics-track-click-event', 'Collections', isUpvote ? 'Upvote Collection' : 'Downvote Collection');
    }, [ownSuccess]);
    if (value === undefined) {
        return null;
    }
    const RadialProgressT = vortex_api_1.RadialProgress;
    const rating = value.average;
    let cssClass = 'success-rating-good';
    if (rating === undefined) {
        cssClass = 'success-rating-insufficient';
    }
    else if (rating < 50) {
        cssClass = 'success-rating-bad';
    }
    else if (rating < 75) {
        cssClass = 'success-rating-dubious';
    }
    const versionMismatch = gameVersion !== collectionGameVersion;
    const gameVersionClassName = versionMismatch ? 'dialog-danger-text' : '';
    return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', className: 'collection-health-indicator' },
        React.createElement("div", { className: 'collection-health-header' },
            React.createElement("div", { className: 'collection-health-header-title' },
                React.createElement(vortex_api_1.Icon, { name: 'revision' }),
                t('Revision {{number}}', { replace: { number: revisionNumber } })),
            React.createElement("div", { className: 'collection-health-header-gameversion' },
                t('Game Version: '),
                React.createElement("span", { className: gameVersionClassName }, collectionGameVersion),
                (versionMismatch) ? (React.createElement(vortex_api_1.More, { id: 'collection-health-version-mismatch', name: t('Version Mismatch') }, t('This collection was created using a different version of the game than you have and is the most common reason why a collection doesn\'t work correctly.\n\n'
                    + 'Your version: {{gameVersion}}\n\n'
                    + 'Collection version: {{collectionGameVersion}}', { replace: { collectionGameVersion: collectionGameVersion, gameVersion: gameVersion } }))) : null)),
        React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-health-body' },
            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-revition-rating-parent' },
                React.createElement("div", { className: 'collection-revision-rating-container' },
                    React.createElement(RadialProgressT, { data: [
                            { class: cssClass, min: 0, max: 100, value: value.average },
                        ], totalRadius: 32, innerGap: 10, restOverlap: false }),
                    React.createElement("div", { className: 'centered-overlay' },
                        value.average,
                        "%")),
                React.createElement("div", { className: 'collection-revision-rating-numvotes' }, t('{{numVotes}} votes', { replace: { numVotes: value.total } }))),
            React.createElement(vortex_api_1.FlexLayout.Flex, null,
                React.createElement(vortex_api_1.FlexLayout, { type: 'column' }, (!voteAllowed) ? (React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-health-rating-text' }, t('Collection Success Rating'))) : (React.createElement(React.Fragment, null,
                    React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-health-rating-text' }, t('Did this collection work successfully?')),
                    React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                        React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-voting-pill' },
                            React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                React.createElement(vortex_api_1.tooltip.Button, { className: 'collection-ghost-button ' +
                                        (ownSuccess === 'positive' ? 'voted' : ''), tooltip: voteAllowed
                                        ? t('Collection worked (mostly)')
                                        : t('You must wait for 12 hours between downloading a collection revision and rating it'), "data-success": true, onClick: voteSuccess, disabled: !voteAllowed }, t('Yes'))),
                            React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                React.createElement(vortex_api_1.tooltip.Button, { className: 'collection-ghost-button ' +
                                        (ownSuccess === 'negative' ? 'voted' : ''), tooltip: voteAllowed
                                        ? t("Collection didn't work (in a significant way)")
                                        : t('You must wait for 12 hours between downloading a collection revision and rating it'), "data-success": false, onClick: voteSuccess, disabled: !voteAllowed }, t('No'))))))))))));
}
exports["default"] = HealthIndicator;


/***/ }),

/***/ "./src/views/CollectionPageView/SlideshowControls.tsx":
/*!************************************************************!*\
  !*** ./src/views/CollectionPageView/SlideshowControls.tsx ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const Timer_1 = __webpack_require__(/*! ./Timer */ "./src/views/CollectionPageView/Timer.tsx");
function SlideshowControls(props) {
    const { t, autoProgressTimeMS, numItems, onChangeItem } = props;
    const [paused, setPaused] = React.useState(false);
    const [idx, setIdx] = React.useState(0);
    const [lastChange, setLastChange] = React.useState(0);
    const isMounted = React.useRef(false);
    React.useEffect(() => {
        isMounted.current = true;
        return () => { isMounted.current = false; };
    }, []);
    const next = React.useCallback(() => {
        if (!isMounted.current) {
            return;
        }
        let value;
        setIdx(oldValue => {
            value = (oldValue + 1) % numItems;
            return value;
        });
        setLastChange(Date.now());
        onChangeItem(value);
    }, [numItems, onChangeItem, setIdx, setLastChange]);
    const prev = React.useCallback(() => {
        let value;
        setIdx(oldValue => {
            value = oldValue > 0 ? (oldValue - 1) : (numItems - 1);
            return value;
        });
        setLastChange(Date.now());
        onChangeItem(value);
    }, [numItems, onChangeItem, setIdx, setLastChange]);
    const togglePause = React.useCallback(() => {
        setPaused(old => !old);
    }, [setPaused]);
    return (React.createElement("div", { className: 'slideshow-controls' },
        React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'collection-previous', tooltip: t('Show previous mod'), disabled: idx === 0, onClick: prev }),
        t('{{pos}} of {{count}}', { replace: { pos: idx + 1, count: numItems } }),
        React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'collection-next', tooltip: t('Show next mod'), disabled: idx === numItems - 1, onClick: next }),
        (autoProgressTimeMS !== undefined) ? (React.createElement(vortex_api_1.tooltip.IconButton, { className: 'button-with-timer', icon: paused ? 'resume' : 'pause', tooltip: t('Start/Pause automatic advancement'), onClick: togglePause },
            React.createElement(Timer_1.default, { className: 'slideshow-timer', started: lastChange, paused: paused, duration: autoProgressTimeMS, onTrigger: next }))) : null));
}
exports["default"] = SlideshowControls;


/***/ }),

/***/ "./src/views/CollectionPageView/Timer.tsx":
/*!************************************************!*\
  !*** ./src/views/CollectionPageView/Timer.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const circumference = 100;
const radius = circumference / (2 * Math.PI);
const stroke = Math.ceil(radius / 6);
const width = radius * 2 + stroke;
const center = width / 2;
function Timer(props) {
    const { className, duration, onTrigger, paused, started } = props;
    const [timer, setTimer] = React.useState(null);
    const [active, setActive] = React.useState(true);
    const [elapsed, setElapsed] = React.useState(null);
    React.useEffect(() => {
        return () => {
            if (timer !== null) {
                clearTimeout(timer);
            }
        };
    }, []);
    React.useEffect(() => {
        setActive(false);
        setElapsed(null);
        setTimeout(() => {
            setActive(true);
        }, 10);
    }, [setActive, setElapsed, started]);
    React.useEffect(() => {
        if (timer !== null) {
            clearTimeout(timer);
        }
        if (paused) {
            setElapsed(Date.now() - started);
        }
        else {
            let remaining = duration;
            if (elapsed !== null) {
                remaining = duration - elapsed;
                setElapsed(null);
            }
            else {
                remaining = (started + duration) - Date.now();
            }
            if (remaining < 0) {
                remaining = duration;
            }
            setTimer(setTimeout(() => {
                onTrigger();
            }, remaining));
        }
    }, [setTimer, setElapsed, paused, started]);
    return (React.createElement("svg", { className: className, viewBox: `0 0 ${width} ${width}`, style: { strokeWidth: stroke } },
        React.createElement("circle", { className: 'timer-background', fill: 'none', cx: center, cy: center, r: radius }),
        React.createElement("circle", { className: 'timer-circle', style: {
                animationDuration: duration.toString() + 'ms',
                animationDirection: 'reverse',
                animationIterationCount: 'infinite',
                animationTimingFunction: 'linear',
                animationPlayState: paused ? 'paused' : 'running',
                transform: 'rotate(-90deg)',
                transformOrigin: 'center',
                display: active ? undefined : 'none',
            }, strokeDasharray: `${circumference},${circumference}`, strokeLinecap: 'round', fill: 'none', cx: center, cy: center, r: radius })));
}
exports["default"] = Timer;


/***/ }),

/***/ "./src/views/CollectionPageView/index.tsx":
/*!************************************************!*\
  !*** ./src/views/CollectionPageView/index.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const findModByRef_1 = __webpack_require__(/*! ../../util/findModByRef */ "./src/util/findModByRef.ts");
const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
const CollectionInstructions_1 = __webpack_require__(/*! ./CollectionInstructions */ "./src/views/CollectionPageView/CollectionInstructions.tsx");
const CollectionItemStatus_1 = __webpack_require__(/*! ./CollectionItemStatus */ "./src/views/CollectionPageView/CollectionItemStatus.tsx");
const CollectionOverview_1 = __webpack_require__(/*! ./CollectionOverview */ "./src/views/CollectionPageView/CollectionOverview.tsx");
const CollectionOverviewSelection_1 = __webpack_require__(/*! ./CollectionOverviewSelection */ "./src/views/CollectionPageView/CollectionOverviewSelection.tsx");
const CollectionProgress_1 = __webpack_require__(/*! ./CollectionProgress */ "./src/views/CollectionPageView/CollectionProgress.tsx");
const Promise = __webpack_require__(/*! bluebird */ "bluebird");
const _ = __webpack_require__(/*! lodash */ "lodash");
const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const ReactDOM = __webpack_require__(/*! react-dom */ "react-dom");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const semver = __webpack_require__(/*! semver */ "semver");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const getCollator = (() => {
    let collator;
    let language;
    return (locale) => {
        if ((collator === undefined) || (locale !== language)) {
            language = locale;
            collator = new Intl.Collator(locale, { sensitivity: 'base' });
        }
        return collator;
    };
})();
const STATUS_ORDER = ['Installing', 'Downloading',
    'Install Pending', 'Download Pending',
    'Enabled', 'Disabled', 'Recommended', 'Ignored'];
function arr(input) {
    return Array.isArray(input) ? input : [input];
}
function matchRepo(mod, ref) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (ref === null) {
        return false;
    }
    const modId = ((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.modId) || ((_d = (_c = (_b = mod.collectionRule) === null || _b === void 0 ? void 0 : _b.reference) === null || _c === void 0 ? void 0 : _c.repo) === null || _d === void 0 ? void 0 : _d.modId);
    const fileId = ((_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.fileId) || ((_h = (_g = (_f = mod.collectionRule) === null || _f === void 0 ? void 0 : _f.reference) === null || _g === void 0 ? void 0 : _g.repo) === null || _h === void 0 ? void 0 : _h.fileId);
    if ((modId === undefined) || (fileId === undefined)
        || (ref.modId === undefined) || (ref.fileId === undefined)) {
        return false;
    }
    return modId.toString() === ref.modId.toString()
        && fileId.toString() === ref.fileId.toString();
}
class CollectionPage extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.mInstalling = false;
        this.revisionMerged = (0, memoize_one_1.default)((collection, revision) => ({
            ...revision,
            collection,
        }));
        this.selectTab = (tab) => {
            this.context.api.events.emit('analytics-track-navigation', `collections/view/collection/${tab}`);
            this.nextState.currentTab = tab;
        };
        this.extractAndRemoveComparators = (versionString) => {
            const comparatorPattern = /[\~\^><=]+/;
            const match = versionString.match(comparatorPattern);
            const comparator = match ? match[0] : null;
            const cleanedVersion = versionString.replace(comparatorPattern, '').trim();
            return { version: cleanedVersion, comparator: comparator };
        };
        this.pause = () => {
            this.props.onPause(this.props.collection.id);
        };
        this.cancel = () => {
            this.props.onCancel(this.props.collection.id);
        };
        this.resume = () => {
            this.props.onResume(this.props.collection.id);
        };
        this.setEnabled = (enable) => {
            const { collection, profile } = this.props;
            vortex_api_1.actions.setModsEnabled(this.context.api, profile.id, [collection.id], enable);
        };
        this.showMods = () => {
            const { collection } = this.props;
            const { api } = this.context;
            const batch = [];
            batch.push(vortex_api_1.actions.setAttributeFilter('mods', undefined, undefined));
            batch.push(vortex_api_1.actions.setAttributeFilter('mods', 'dependencies', ['depends', collection.id, vortex_api_1.util.renderModName(collection)]));
            batch.push(vortex_api_1.actions.setAttributeSort('mods', 'dependencies', 'asc'));
            vortex_api_1.util.batchDispatch(api.store, batch);
            api.events.emit('show-main-page', 'Mods');
        };
        this.close = () => {
            this.props.onView(undefined);
        };
        this.unselectMods = () => {
            this.nextState.modSelection = [];
        };
        this.clone = (collectionId) => {
            const { modsEx } = this.state;
            const incomplete = Object.values(modsEx)
                .filter(mod => (mod.state !== 'installed'));
            if (incomplete.length > 0) {
                return this.context.api.showDialog('info', 'Cloning incomplete', {
                    text: 'The collection you\'re trying to clone is incomplete. Vortex can '
                        + 'not include a mod in a collection that isn\'t installed so if you continue, '
                        + 'the clone will not include these missing mods..',
                    message: incomplete.map(mod => vortex_api_1.util.renderModName(mod)).join('\n'),
                }, [
                    { label: 'Cancel' },
                    { label: 'Clone anyway', action: () => { this.props.onClone(collectionId); } },
                ]);
            }
            else {
                this.props.onClone(collectionId);
            }
        };
        this.remove = (collectionId) => {
            this.props.onCancel(collectionId);
        };
        this.changeModSelection = (modIds) => {
            const { revisionInfo } = this.props;
            const { modsEx } = this.state;
            this.nextState.modSelection = modIds.map(modId => {
                var _a, _b;
                const mod = modsEx[modId];
                return {
                    local: mod,
                    remote: (_b = (_a = revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.modFiles) === null || _a === void 0 ? void 0 : _a.find) === null || _b === void 0 ? void 0 : _b.call(_a, file => matchRepo(mod, file.file)),
                };
            });
        };
        this.setTableContainerRef = (ref) => {
            this.mTableContainerRef = (ref !== null)
                ? ReactDOM.findDOMNode(ref)
                : null;
        };
        this.toggleInstructions = (evt) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const modId = evt.currentTarget.getAttribute('data-modid');
            const { mods, onShowError, overlays } = this.props;
            const instructions = this.getModInstructions(modId);
            if (instructions === undefined) {
                const err = new vortex_api_1.util.ProcessCanceled('No instructions found', modId);
                err['attachLogOnReport'] = true;
                err['Collection'] = (_b = (_a = this.props.collection) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.collectionSlug;
                err['Revision'] = (_d = (_c = this.props.collection) === null || _c === void 0 ? void 0 : _c.attributes) === null || _d === void 0 ? void 0 : _d.revisionNumber;
                onShowError('Failed to display instructions', err, true);
                return;
            }
            const mod = mods[modId];
            const modName = vortex_api_1.util.renderModName(mod);
            if (((_e = overlays[modId]) === null || _e === void 0 ? void 0 : _e.content) !== undefined) {
                (_g = (_f = this.context.api.ext).dismissOverlay) === null || _g === void 0 ? void 0 : _g.call(_f, modId);
            }
            else {
                (_j = (_h = this.context.api.ext).showOverlay) === null || _j === void 0 ? void 0 : _j.call(_h, modId, modName, instructions, {
                    x: evt.pageX, y: evt.pageY
                });
            }
        };
        this.getModInstructions = (modId) => {
            var _a, _b;
            const { collection, mods } = this.props;
            const mod = mods[modId];
            const modRule = (_a = collection.rules) === null || _a === void 0 ? void 0 : _a.find(rule => vortex_api_1.util.testModReference(mod, rule.reference));
            return (_b = modRule === null || modRule === void 0 ? void 0 : modRule['extra']) === null || _b === void 0 ? void 0 : _b['instructions'];
        };
        this.modAtLeastDownloaded = (instanceIds) => {
            const instanceId = Array.isArray(instanceIds) ? instanceIds[0] : instanceIds;
            const mod = this.state.modsEx[instanceId];
            return mod.state !== null;
        };
        this.ignoreSelected = (modIds) => {
            const { collection, profile } = this.props;
            const { modsEx } = this.state;
            vortex_api_1.util.batchDispatch(this.context.api.store, modIds.reduce((prev, modId) => {
                prev.push(vortex_api_1.actions.addModRule(profile.gameId, collection.id, {
                    ...modsEx[modId].collectionRule,
                    ignored: true,
                }));
                return prev;
            }, []));
        };
        this.unignoreSelected = (modIds) => {
            const { collection, profile } = this.props;
            const { modsEx } = this.state;
            vortex_api_1.util.batchDispatch(this.context.api.store, modIds.reduce((prev, modId) => {
                prev.push(vortex_api_1.actions.addModRule(profile.gameId, collection.id, {
                    ...modsEx[modId].collectionRule,
                    ignored: false,
                }));
                return prev;
            }, []));
        };
        this.installManually = (modIds) => {
            const { collection } = this.props;
            const { modsEx } = this.state;
            const rules = modIds.map(modId => modsEx[modId].collectionRule);
            this.props.onInstallManually(collection.id, rules);
        };
        this.removeSelected = (modIds) => {
            var _a;
            const { t, collection, profile, onRemoveRule } = this.props;
            const { modsEx } = this.state;
            const filteredIds = modIds
                .filter(modId => modsEx[modId] !== undefined)
                .filter(modId => ['downloaded', 'installed', null].indexOf(modsEx[modId].state) !== -1);
            if (filteredIds.length === 0) {
                return;
            }
            const modNames = filteredIds
                .map(modId => (modsEx[modId].state !== null)
                ? vortex_api_1.util.renderModName(modsEx[modId], { version: true })
                : vortex_api_1.util.renderModReference(modsEx[modId].collectionRule.reference, undefined));
            const checkboxes = [
                { id: 'mod', text: t('Remove Mod'), value: true },
                { id: 'archive', text: t('Delete Archive'), value: false },
            ];
            if (((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.editable) === true) {
                checkboxes.push({ id: 'collection', text: t('Remove from Collection'), value: false });
            }
            this.context.api.showDialog('question', 'Confirm removal', {
                text: t('Do you really want to remove this mod?', {
                    count: filteredIds.length,
                    replace: { count: filteredIds.length },
                }),
                message: modNames.join('\n'),
                checkboxes,
            }, [{ label: 'Cancel' }, { label: 'Remove' }])
                .then((result) => {
                const removeMods = result.action === 'Remove' && result.input.mod;
                const removeArchive = result.action === 'Remove' && result.input.archive;
                const removeRule = result.action === 'Remove' && result.input.collection;
                const wereInstalled = filteredIds
                    .filter(key => (modsEx[key] !== undefined) && (modsEx[key].state === 'installed'))
                    .map(key => modsEx[key].id);
                const archiveIds = filteredIds
                    .filter(key => (modsEx[key] !== undefined)
                    && (['downloaded', 'installed'].includes(modsEx[key].state))
                    && (modsEx[key].archiveId !== undefined))
                    .map(key => modsEx[key].archiveId);
                const rulesToRemove = filteredIds.filter(key => modsEx[key] !== undefined);
                return (removeMods
                    ? vortex_api_1.util.removeMods(this.context.api, profile.gameId, wereInstalled)
                    : Promise.resolve())
                    .then(() => {
                    if (removeArchive) {
                        archiveIds.forEach(archiveId => {
                            this.context.api.events.emit('remove-download', archiveId);
                        });
                    }
                    return Promise.resolve();
                })
                    .then(() => {
                    if (removeRule) {
                        rulesToRemove.forEach(key => {
                            onRemoveRule(profile.gameId, collection.id, modsEx[key].collectionRule);
                        });
                    }
                });
            })
                .catch(vortex_api_1.util.ProcessCanceled, err => {
                this.context.api.sendNotification({
                    id: 'cant-remove-mod',
                    type: 'warning',
                    title: 'Failed to remove mods',
                    message: err.message,
                });
            })
                .catch(vortex_api_1.util.UserCanceled, () => null)
                .catch(err => {
                this.context.api.showErrorNotification('Failed to remove selected mods', err);
            });
        };
        this.showInMods = (modIds) => {
            const { modsEx } = this.state;
            this.showMods();
            const modId = modsEx[modIds[0]].id;
            setTimeout(() => {
                this.context.api.events.emit('mods-scroll-to', modId);
                this.context.api.highlightControl('.' + vortex_api_1.util.sanitizeCSSId(modId), 5000);
            }, 2000);
        };
        this.initState({
            modsEx: {},
            modSelection: [],
            currentTab: 'instructions',
        });
        this.mModActions = [
            {
                icon: 'install',
                title: 'Install',
                action: this.installManually,
                condition: instanceIds => {
                    const instanceId = Array.isArray(instanceIds) ? instanceIds[0] : instanceIds;
                    const mod = this.state.modsEx[instanceId];
                    return [null, 'downloaded'].includes(mod.state);
                },
            },
            {
                icon: 'delete',
                title: 'Remove',
                action: this.removeSelected,
                condition: instanceId => (typeof (instanceId) === 'string')
                    ? (['downloaded', 'installed'].includes(this.state.modsEx[instanceId].state))
                    : true,
                hotKey: { code: 46 },
            },
            {
                icon: 'show',
                title: 'Show in Mods',
                action: this.showInMods,
                condition: instanceId => this.modAtLeastDownloaded(instanceId),
                singleRowAction: true,
                multiRowAction: false,
            },
            {
                icon: 'toggle-disabled',
                title: 'Ignore',
                action: this.ignoreSelected,
                condition: instanceIds => arr(instanceIds).find(id => this.state.modsEx[id].collectionRule['ignored'] !== true) !== undefined,
            },
            {
                icon: 'toggle-enabled',
                title: 'Stop Ignoring',
                action: this.unignoreSelected,
                condition: instanceIds => arr(instanceIds).find(id => this.state.modsEx[id].collectionRule['ignored'] === true) !== undefined,
            },
        ];
        this.mAttributes = [
            {
                id: 'collection_status',
                name: 'Status',
                description: 'Is mod enabled in current profile',
                icon: 'check-o',
                customRenderer: (mod) => {
                    const download = (mod.archiveId !== undefined)
                        ? this.props.downloads[mod.archiveId]
                        : undefined;
                    return (React.createElement(CollectionItemStatus_1.default, { t: this.props.t, mod: mod, download: download, notifications: this.props.notifications, container: this.mTableContainerRef, installing: this.mInstalling }));
                },
                calc: (mod) => {
                    if (mod.collectionRule['ignored']) {
                        return ['Ignored'];
                    }
                    else if (mod.state === 'installing') {
                        return ['Installing', Math.floor(mod.progress * 100.0) / 100.0];
                    }
                    else if (mod.state === 'downloading') {
                        return ['Downloading', Math.floor(mod.progress * 100.0) / 100.0];
                    }
                    else if (mod.state === null) {
                        if (mod.collectionRule.type === 'recommends') {
                            return ['Recommended'];
                        }
                        else {
                            return ['Download Pending', 'Pending'];
                        }
                    }
                    else if (mod.state === 'downloaded') {
                        if (mod.collectionRule.type === 'recommends') {
                            return ['Recommended'];
                        }
                        else {
                            return ['Install Pending', 'Pending'];
                        }
                    }
                    return [mod.enabled === true ? 'Enabled' : 'Disabled'];
                },
                placement: 'table',
                isToggleable: false,
                edit: {},
                isSortable: true,
                sortFunc: (lhs, rhs) => {
                    return STATUS_ORDER.indexOf(lhs[0]) - STATUS_ORDER.indexOf(rhs[0]);
                },
                filter: new vortex_api_1.OptionsFilter([
                    { value: 'Enabled', label: 'Enabled' },
                    { value: 'Disabled', label: 'Disabled' },
                    { value: 'Installing', label: 'Installing' },
                    { value: 'Downloading', label: 'Downloading' },
                    { value: 'Pending', label: 'Pending' },
                    { value: 'Recommended', label: 'Not installed' },
                    { value: 'Ignored', label: 'Ignored' },
                ], true, false),
            },
            {
                id: 'required',
                name: 'Required',
                description: 'Is the mod required for this collection',
                placement: 'table',
                calc: (mod) => mod.collectionRule.type === 'requires',
                edit: {},
                filter: new vortex_api_1.OptionsFilter([
                    { value: false, label: 'Recommended' },
                    { value: true, label: 'Required' },
                ], false, false),
            },
            {
                id: 'name',
                name: 'Name',
                calc: mod => (mod.state !== null)
                    ? vortex_api_1.util.renderModReference(mod.collectionRule.reference, mod, { version: false })
                    : vortex_api_1.util.renderModReference(mod.collectionRule.reference, undefined, { version: false }),
                placement: 'table',
                edit: {},
                isToggleable: false,
                isDefaultSort: true,
                isSortable: true,
                filter: new vortex_api_1.TableTextFilter(true),
                sortFunc: (lhs, rhs, locale) => getCollator(locale).compare(lhs, rhs),
            },
            {
                id: 'version',
                name: 'Version',
                calc: mod => {
                    var _a, _b;
                    const prefer = '+prefer';
                    let verString = (_b = ((mod.state !== null)
                        ? (_a = mod.attributes.version) !== null && _a !== void 0 ? _a : mod.collectionRule.reference.versionMatch
                        : mod.collectionRule.reference.versionMatch)) !== null && _b !== void 0 ? _b : '0.0.0';
                    if (verString.endsWith(prefer)) {
                        let sv;
                        try {
                            sv = semver.minVersion(verString);
                        }
                        catch (e) {
                            const { version, comparator } = this.extractAndRemoveComparators(verString);
                            const coerced = vortex_api_1.util.coerceToSemver(version.slice(0, -(prefer.length)));
                            const range = (comparator !== null && comparator !== void 0 ? comparator : '') + coerced + prefer;
                            try {
                                sv = semver.minVersion(range);
                            }
                            catch (e2) {
                                sv = { version: coerced };
                            }
                        }
                        verString = sv.version;
                    }
                    return verString;
                },
                placement: 'table',
                edit: {},
            },
            {
                id: 'uploader',
                name: 'Uploader',
                customRenderer: (mod) => {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
                    const { t } = this.props;
                    let name;
                    let avatar;
                    if (this.props.revisionInfo !== undefined) {
                        const revMods = ((_a = this.props.revisionInfo) === null || _a === void 0 ? void 0 : _a.modFiles) || [];
                        const revMod = revMods.find(iter => matchRepo(mod, iter.file));
                        name = ((_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.uploader) || ((_d = (_c = revMod === null || revMod === void 0 ? void 0 : revMod.file) === null || _c === void 0 ? void 0 : _c.owner) === null || _d === void 0 ? void 0 : _d.name);
                        avatar = ((_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.uploaderAvatar)
                            || ((_g = (_f = revMod === null || revMod === void 0 ? void 0 : revMod.file) === null || _f === void 0 ? void 0 : _f.owner) === null || _g === void 0 ? void 0 : _g.avatar);
                    }
                    else if (mod.attributes !== undefined) {
                        name = (_h = mod.attributes) === null || _h === void 0 ? void 0 : _h.uploader;
                        avatar = (_j = mod.attributes) === null || _j === void 0 ? void 0 : _j.uploaderAvatar;
                    }
                    return (React.createElement("div", null,
                        React.createElement(react_bootstrap_1.Image, { circle: true, src: avatar || constants_1.AVATAR_FALLBACK }),
                        name || t(constants_1.AUTHOR_UNKNOWN)));
                },
                calc: mod => { var _a; return ((_a = mod === null || mod === void 0 ? void 0 : mod.attributes) === null || _a === void 0 ? void 0 : _a.author) || this.props.t(constants_1.AUTHOR_UNKNOWN); },
                placement: 'table',
                edit: {},
                isToggleable: false,
                isSortable: true,
            },
            {
                id: 'instructions',
                name: 'Instructions',
                customRenderer: (mod) => {
                    const instructions = this.getModInstructions(mod.id);
                    if (instructions === undefined) {
                        return null;
                    }
                    return (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'details', tooltip: instructions, "data-modid": mod.id, onClick: this.toggleInstructions }));
                },
                calc: mod => {
                    return this.getModInstructions(mod.id);
                },
                placement: 'table',
                edit: {},
            },
        ];
        props.onAddCallback('viewCollectionTab', (tab) => {
            if (['instructions', 'mods'].includes(tab)) {
                this.nextState.currentTab = tab;
            }
        });
    }
    async componentDidMount() {
        const { collection, userInfo } = this.props;
        const { attributes } = collection !== null && collection !== void 0 ? collection : {};
        const { revisionId, collectionSlug, revisionNumber } = attributes !== null && attributes !== void 0 ? attributes : {};
        if (((revisionId !== undefined) || (collectionSlug !== undefined))
            && (userInfo !== undefined)) {
            const { infoCache } = this.props.driver;
            try {
                await infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber);
            }
            catch (err) {
                (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                    revisionId, collectionSlug, revisionNumber,
                    error: err.message,
                });
            }
        }
        const modsEx = this.initModsEx(this.props);
        this.nextState.modsEx = modsEx;
    }
    async UNSAFE_componentWillReceiveProps(newProps) {
        if ((this.props.mods !== newProps.mods)
            || (this.props.profile !== newProps.profile)
            || (this.props.collection !== newProps.collection)
            || (this.props.downloads !== newProps.downloads)
            || this.installingNotificationsChanged(this.props, newProps)) {
            this.nextState.modsEx = this.updateModsEx(this.props, newProps);
            const { collection } = this.props;
            const { attributes } = collection;
            const { revisionId, collectionSlug, revisionNumber } = attributes !== null && attributes !== void 0 ? attributes : {};
            if ((revisionId !== undefined) || (collectionSlug !== undefined)) {
                try {
                    await this.props.driver.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber);
                }
                catch (err) {
                    (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                        revisionId, collectionSlug, revisionNumber,
                        error: err.message,
                    });
                }
            }
        }
    }
    shouldComponentUpdate(newProps, newState) {
        if ((this.props.mods !== newProps.mods)
            || (this.props.profile !== newProps.profile)
            || (this.props.downloads !== newProps.downloads)
            || (this.props.collection !== newProps.collection)
            || this.installingNotificationsChanged(this.props, newProps)
            || (this.props.activity.mods !== newProps.activity.mods)
            || (this.props.revisionInfo !== newProps.revisionInfo)
            || (this.props.showUpvoteResponse !== newProps.showUpvoteResponse)
            || (this.props.showDownvoteResponse !== newProps.showDownvoteResponse)
            || (this.state.currentTab !== newState.currentTab)
            || (this.state.modSelection !== newState.modSelection)
            || (this.state.modsEx !== newState.modsEx)) {
            return true;
        }
        return false;
    }
    render() {
        var _a, _b, _c, _d;
        const { t, activity, className, collection, collectionInfo, driver, downloads, language, mods, onSuppressVoteResponse, onVoteSuccess, profile, revisionInfo, showUpvoteResponse, showDownvoteResponse, userInfo, votedSuccess } = this.props;
        const { currentTab, modSelection, modsEx } = this.state;
        if (collection === undefined) {
            return null;
        }
        const incomplete = Object.values(modsEx)
            .find(mod => (mod.state !== 'installed')
            && !mod.collectionRule['ignored']
            && (mod.collectionRule.type === 'requires')) !== undefined;
        const totalSize = Object.values(modsEx).reduce((prev, mod) => {
            const size = vortex_api_1.util.getSafe(mod, ['attributes', 'fileSize'], 0);
            return prev + size;
        }, 0);
        if (collection !== undefined) {
            this.mInstalling = incomplete
                && !driver.installDone
                && (((_a = driver.collection) === null || _a === void 0 ? void 0 : _a.id) === (collection === null || collection === void 0 ? void 0 : collection.id));
        }
        else {
            this.mInstalling = undefined;
        }
        const selection = (_d = ((this.mInstalling && (driver.collectionInfo !== undefined))
            ? (_c = (_b = revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.modFiles) === null || _b === void 0 ? void 0 : _b.map) === null || _c === void 0 ? void 0 : _c.call(_b, file => ({ local: undefined, remote: file }))
            : modSelection)) !== null && _d !== void 0 ? _d : [];
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', className: className },
            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-overview-panel' }, (selection.length > 0)
                ? (React.createElement(CollectionOverviewSelection_1.default, { t: t, profile: profile, collection: collection, onDeselectMods: this.unselectMods, incomplete: incomplete, modSelection: selection }))
                : (React.createElement(CollectionOverview_1.default, { t: t, language: language, profile: profile, collection: collection, totalSize: totalSize, showUpvoteResponse: showUpvoteResponse, showDownvoteResponse: showDownvoteResponse, revision: this.revisionMerged(collectionInfo, revisionInfo), votedSuccess: votedSuccess, onSetEnabled: this.setEnabled, onShowMods: this.showMods, onClose: this.close, onClone: this.clone, onRemove: this.remove, onVoteSuccess: onVoteSuccess, onSuppressVoteResponse: onSuppressVoteResponse, incomplete: incomplete }))),
            React.createElement(vortex_api_1.FlexLayout.Flex, { className: 'collection-mods-panel' },
                React.createElement(react_bootstrap_1.Tabs, { id: 'collection-view-tabs', activeKey: currentTab, onSelect: this.selectTab, unmountOnExit: true, mountOnEnter: true },
                    React.createElement(react_bootstrap_1.Tab, { key: 'instructions', eventKey: 'instructions', title: t('Instructions') },
                        React.createElement(react_bootstrap_1.Panel, null,
                            React.createElement(react_bootstrap_1.Panel.Body, null,
                                React.createElement(CollectionInstructions_1.default, { t: t, collection: collection, mods: mods, onToggleInstructions: this.toggleInstructions })))),
                    React.createElement(react_bootstrap_1.Tab, { key: 'mods', eventKey: 'mods', title: t('Mods') },
                        React.createElement(react_bootstrap_1.Panel, { ref: this.setTableContainerRef },
                            React.createElement(react_bootstrap_1.Panel.Body, null,
                                React.createElement(vortex_api_1.Table, { tableId: 'collection-mods', showDetails: false, data: modsEx, staticElements: this.mAttributes, actions: this.mModActions, onChangeSelection: this.changeModSelection })))))),
            React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                React.createElement(CollectionProgress_1.default, { t: t, isPremium: userInfo === null || userInfo === void 0 ? void 0 : userInfo.isPremium, mods: modsEx, profile: profile, downloads: downloads, totalSize: totalSize, activity: activity, onCancel: this.cancel, onPause: this.mInstalling ? this.pause : undefined, onResume: this.mInstalling
                        ? undefined
                        : (driver.collection !== undefined) && !driver.installDone
                            ? null
                            : this.resume }))));
    }
    progress(props, mod) {
        var _a;
        const { downloads, notifications } = props;
        if (mod.state === 'downloading') {
            const { received, size } = downloads[mod.archiveId];
            if (!!size) {
                return received / size;
            }
        }
        else if (mod.state === 'installing') {
            const notification = notifications.find(noti => noti.id === 'install_' + mod.id);
            if (notification !== undefined) {
                return ((_a = notification.progress) !== null && _a !== void 0 ? _a : 100) / 100;
            }
            else {
                return 1;
            }
        }
        return 0;
    }
    installingNotificationsChanged(oldProps, newProps) {
        if (oldProps.notifications !== newProps.notifications) {
            const oldInstalling = oldProps.notifications
                .filter(noti => noti.id.startsWith(constants_1.INSTALLING_NOTIFICATION_ID));
            const newInstalling = newProps.notifications
                .filter(noti => noti.id.startsWith(constants_1.INSTALLING_NOTIFICATION_ID));
            return !_.isEqual(oldInstalling, newInstalling);
        }
        else {
            return false;
        }
    }
    updateModsEx(oldProps, newProps) {
        var _a, _b;
        const result = { ...this.state.modsEx };
        const modifiedDownloads = vortex_api_1.util.objDiff(oldProps.downloads, newProps.downloads);
        const modifiedMods = vortex_api_1.util.objDiff(oldProps.mods, newProps.mods);
        const modifiedState = vortex_api_1.util.objDiff((_a = oldProps.profile.modState) !== null && _a !== void 0 ? _a : {}, (_b = newProps.profile.modState) !== null && _b !== void 0 ? _b : {});
        const genRuleMap = (rules) => {
            return (rules || []).reduce((prev, rule) => {
                prev[(0, util_1.modRuleId)(rule)] = rule;
                return prev;
            }, {});
        };
        const modifiedRules = vortex_api_1.util.objDiff(genRuleMap(oldProps.collection.rules), genRuleMap(newProps.collection.rules));
        Object.keys(modifiedDownloads)
            .filter(dlId => dlId.startsWith('-'))
            .forEach(dlId => {
            const refId = Object.keys(result).find(iter => { var _a; return ((_a = result[iter]) === null || _a === void 0 ? void 0 : _a.archiveId) === dlId.slice(1); });
            delete result[refId];
        });
        const invalidateMod = modId => {
            const realId = modId.slice(1);
            const refId = Object.keys(result).find(iter => { var _a; return ((_a = result[iter]) === null || _a === void 0 ? void 0 : _a.id) === realId; });
            delete result[refId];
        };
        Object.keys(modifiedMods)
            .filter(modId => modId.startsWith('-'))
            .forEach(invalidateMod);
        Object.keys(modifiedState)
            .filter(modId => {
            var _a;
            return modId.startsWith('-')
                || ((_a = modifiedState[modId]) === null || _a === void 0 ? void 0 : _a['-enabled']) !== undefined;
        })
            .forEach(invalidateMod);
        const { collection } = newProps;
        (collection.rules || [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type))
            .forEach(rule => {
            const id = (0, util_1.modRuleId)(rule);
            if ((result[id] === undefined) || (modifiedRules[id] !== undefined)) {
                result[id] = this.modFromRule(newProps, rule);
            }
        });
        Object.keys(modifiedRules)
            .forEach(ruleId => {
            if (ruleId.startsWith('-')) {
                delete result[ruleId.slice(1)];
            }
            else if (ruleId.startsWith('+')) {
                result[ruleId.slice(1)] = this.modFromRule(newProps, modifiedRules[ruleId]);
            }
        });
        const { profile } = newProps;
        const { modsEx } = this.state;
        const pendingDL = Object.keys(modsEx).filter(modId => { var _a; return ((_a = modsEx[modId]) === null || _a === void 0 ? void 0 : _a.state) === null; });
        const pendingInstall = Object.keys(modsEx)
            .filter(modId => { var _a; return ['downloading', 'downloaded', null].includes((_a = modsEx[modId]) === null || _a === void 0 ? void 0 : _a.state); });
        const pendingFinish = Object.keys(modsEx)
            .filter(modId => { var _a; return ['installing', 'installed'].includes((_a = modsEx[modId]) === null || _a === void 0 ? void 0 : _a.state); });
        Object.keys(modifiedDownloads)
            .filter(dlId => dlId.startsWith('+'))
            .forEach(dlId => {
            const download = newProps.downloads[dlId.slice(1)];
            const match = pendingDL.find(modId => (0, findModByRef_1.testDownloadReference)(download, modsEx[modId].collectionRule.reference));
            if (match !== undefined) {
                result[match] = this.modFromDownload(dlId.slice(1), download, modsEx[match].collectionRule);
            }
        });
        const updateMod = modId => {
            const realId = modId.startsWith('+') ? modId.slice(1) : modId;
            const mod = newProps.mods[realId];
            if (mod === undefined) {
                return;
            }
            if (mod.state === 'installing') {
                const dlId = mod.archiveId;
                const download = newProps.downloads[dlId];
                const match = pendingInstall.find(iter => (0, findModByRef_1.testDownloadReference)(download, modsEx[iter].collectionRule.reference));
                if (match !== undefined) {
                    result[match] = {
                        ...this.modFromDownload(dlId, download, modsEx[match].collectionRule),
                        id: modId.slice(1),
                        state: 'installing',
                    };
                }
            }
            else {
                const match = pendingFinish.find(iter => vortex_api_1.util.testModReference(mod, modsEx[iter].collectionRule.reference));
                if (match !== undefined) {
                    result[match] = {
                        ...mod,
                        ...(profile.modState || {})[mod.id],
                        collectionRule: modsEx[match].collectionRule,
                    };
                }
            }
        };
        Object.keys(modifiedMods)
            .filter(modId => !modId.startsWith('-')
            && (modId.startsWith('+')
                || (modifiedMods[modId]['+state'] !== undefined)
                || (modifiedMods[modId]['attributes'] !== undefined)))
            .forEach(updateMod);
        Object.keys(modifiedState)
            .filter(modId => { var _a; return ((_a = modifiedState[modId]) === null || _a === void 0 ? void 0 : _a['+enabled']) !== undefined; })
            .forEach(updateMod);
        Object.keys(modifiedDownloads)
            .filter(dlId => !dlId.startsWith('-') && !dlId.startsWith('+'))
            .forEach(dlId => {
            var _a, _b, _c;
            let ruleId = Object.keys(result).find(modId => { var _a; return ((_a = result[modId]) === null || _a === void 0 ? void 0 : _a.archiveId) === dlId; });
            if ((ruleId === undefined)
                && (((_b = (_a = newProps.downloads[dlId]) === null || _a === void 0 ? void 0 : _a.modInfo) === null || _b === void 0 ? void 0 : _b.referenceTag) !== undefined)) {
                ruleId = Object.keys(result).find(id => {
                    var _a, _b;
                    return (((_a = result[id]) === null || _a === void 0 ? void 0 : _a.archiveId) === undefined)
                        && (0, findModByRef_1.testDownloadReference)(newProps.downloads[dlId], (_b = result[id]) === null || _b === void 0 ? void 0 : _b.collectionRule.reference);
                });
                if (ruleId !== undefined) {
                    result[ruleId] = {
                        ...result[ruleId],
                        archiveId: dlId,
                        state: 'downloading',
                    };
                }
            }
            if (ruleId !== undefined) {
                result[ruleId] = {
                    ...result[ruleId],
                    progress: this.progress(newProps, result[ruleId]),
                };
                const dl = newProps.downloads[(_c = result[ruleId]) === null || _c === void 0 ? void 0 : _c.archiveId];
                if (['finished', 'failed'].includes(dl.state) && !pendingFinish.includes(ruleId)) {
                    result[ruleId].state = 'downloaded';
                }
            }
        });
        newProps.notifications.forEach(noti => {
            if ((noti.id !== undefined) && (noti.id.startsWith('install_'))) {
                const modId = noti.id.slice(8);
                const ruleId = Object.keys(result).find(iter => { var _a; return ((_a = result[iter]) === null || _a === void 0 ? void 0 : _a.id) === modId; });
                if (ruleId !== undefined) {
                    result[ruleId] = {
                        ...result[ruleId],
                        progress: this.progress(newProps, result[ruleId]),
                    };
                }
            }
        });
        return result;
    }
    modFromDownload(dlId, download, rule) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6;
        const modId = (_d = (_c = (_b = (_a = download.modInfo) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.details) === null || _c === void 0 ? void 0 : _c.modId) !== null && _d !== void 0 ? _d : (_g = (_f = (_e = download.modInfo) === null || _e === void 0 ? void 0 : _e.nexus) === null || _f === void 0 ? void 0 : _f.ids) === null || _g === void 0 ? void 0 : _g.modId;
        return {
            id: dlId,
            type: '',
            installationPath: undefined,
            archiveId: dlId,
            enabledTime: 0,
            state: download.state === 'finished' ? 'downloaded' : 'downloading',
            enabled: false,
            collectionRule: rule,
            attributes: {
                customFileName: (_h = download === null || download === void 0 ? void 0 : download.modInfo) === null || _h === void 0 ? void 0 : _h.name,
                fileName: (_m = (_l = (_k = (_j = download.modInfo) === null || _j === void 0 ? void 0 : _j.nexus) === null || _k === void 0 ? void 0 : _k.fileInfo) === null || _l === void 0 ? void 0 : _l.name) !== null && _m !== void 0 ? _m : vortex_api_1.util.renderModReference(rule.reference),
                fileSize: (_o = download.size) !== null && _o !== void 0 ? _o : rule.reference.fileSize,
                name: dlId,
                version: (_r = (_q = (_p = download.modInfo) === null || _p === void 0 ? void 0 : _p.nexus) === null || _q === void 0 ? void 0 : _q.fileInfo) === null || _r === void 0 ? void 0 : _r.mod_version,
                author: (_u = (_t = (_s = download.modInfo) === null || _s === void 0 ? void 0 : _s.nexus) === null || _t === void 0 ? void 0 : _t.modInfo) === null || _u === void 0 ? void 0 : _u.author,
                uploader: (_y = (_x = (_w = (_v = download.modInfo) === null || _v === void 0 ? void 0 : _v.nexus) === null || _w === void 0 ? void 0 : _w.modInfo) === null || _x === void 0 ? void 0 : _x.user) === null || _y === void 0 ? void 0 : _y.name,
                uploaderId: (_2 = (_1 = (_0 = (_z = download.modInfo) === null || _z === void 0 ? void 0 : _z.nexus) === null || _0 === void 0 ? void 0 : _0.modInfo) === null || _1 === void 0 ? void 0 : _1.user) === null || _2 === void 0 ? void 0 : _2.id,
                category: (_5 = (_4 = (_3 = download.modInfo) === null || _3 === void 0 ? void 0 : _3.nexus) === null || _4 === void 0 ? void 0 : _4.modInfo) === null || _5 === void 0 ? void 0 : _5.category_id,
                source: ((_6 = download.modInfo) === null || _6 === void 0 ? void 0 : _6.nexus) !== undefined ? 'nexus' : undefined,
                modId,
                downloadGame: Array.isArray(download.game) ? download.game[0] : download.game,
            },
        };
    }
    modFromRule(props, rule) {
        var _a, _b;
        const { downloads, mods, profile } = props;
        const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
        if (mod !== undefined) {
            return {
                ...mods[mod.id],
                ...(_a = profile.modState) === null || _a === void 0 ? void 0 : _a[mod.id],
                collectionRule: rule,
            };
        }
        else {
            const dlId = vortex_api_1.util.findDownloadByRef(rule.reference, downloads);
            if (dlId !== undefined) {
                return this.modFromDownload(dlId, downloads[dlId], rule);
            }
            else {
                const name = vortex_api_1.util.renderModReference(rule.reference, undefined);
                return {
                    id: name,
                    state: null,
                    type: '',
                    installationPath: undefined,
                    enabledTime: 0,
                    attributes: {
                        fileSize: rule.reference.fileSize,
                        ...(rule.extra || {}),
                        fileName: (_b = rule.extra) === null || _b === void 0 ? void 0 : _b.name,
                    },
                    enabled: false,
                    collectionRule: rule,
                };
            }
        }
    }
    initModsEx(props) {
        var _a;
        const { collection } = props;
        return ((_a = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type))
            .reduce((prev, rule) => {
            const id = (0, util_1.modRuleId)(rule);
            prev[id] = this.modFromRule(props, rule);
            return prev;
        }, {});
    }
}
function mapStateToProps(state, ownProps) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { nexus } = state.persistent;
    const { collection } = ownProps;
    let votedSuccess;
    let revisionInfo;
    let collectionInfo;
    if (((_a = collection === null || collection === void 0 ? void 0 : collection.attributes) === null || _a === void 0 ? void 0 : _a.revisionId) !== undefined) {
        revisionInfo =
            (_c = (_b = state.persistent.collections.revisions) === null || _b === void 0 ? void 0 : _b[collection.attributes.revisionId]) === null || _c === void 0 ? void 0 : _c.info;
        if ((revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.collection) !== undefined) {
            collectionInfo =
                (_e = (_d = state.persistent.collections.collections) === null || _d === void 0 ? void 0 : _d[revisionInfo.collection.id]) === null || _e === void 0 ? void 0 : _e.info;
        }
        votedSuccess = (_g = (_f = revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.metadata) === null || _f === void 0 ? void 0 : _f.ratingValue) !== null && _g !== void 0 ? _g : 'abstained';
    }
    return {
        userInfo: nexus.userInfo,
        votedSuccess,
        activity: state.session.base.activity,
        language: state.settings.interface.language,
        overlays: state.session.overlays.overlays,
        collectionInfo,
        revisionInfo,
        showUpvoteResponse: (_h = state.settings.interface.usage['collection-upvote-response-dialog']) !== null && _h !== void 0 ? _h : true,
        showDownvoteResponse: (_j = state.settings.interface.usage['collection-downvote-response-dialog']) !== null && _j !== void 0 ? _j : true,
    };
}
function mapDispatchToProps(dispatch) {
    return {
        onSetModEnabled: (profileId, modId, enable) => dispatch(vortex_api_1.actions.setModEnabled(profileId, modId, enable)),
        onSetAttributeFilter: (tableId, filterId, filterValue) => dispatch(vortex_api_1.actions.setAttributeFilter(tableId, filterId, filterValue)),
        onRemoveRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.removeModRule(gameId, modId, rule)),
        onShowError: (message, details, allowReport) => vortex_api_1.util.showError(dispatch, message, details, { allowReport }),
        onSuppressVoteResponse: (response) => dispatch(vortex_api_1.actions.showUsageInstruction(`collection-${response}-response-dialog`, false)),
    };
}
exports["default"] = (0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(CollectionPage);


/***/ }),

/***/ "./src/views/CollectionReleaseStatus.tsx":
/*!***********************************************!*\
  !*** ./src/views/CollectionReleaseStatus.tsx ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function CollectionReleaseStatus(props) {
    const { t, active, collection, enabled, incomplete } = props;
    if (active) {
        if (incomplete) {
            return React.createElement("div", { className: 'collection-status incomplete' }, t('Incomplete'));
        }
        else if ((vortex_api_1.util.getSafe(collection.attributes, ['collectionId'], undefined) !== undefined)
            && vortex_api_1.util.getSafe(collection.attributes, ['editable'], false)) {
            return React.createElement("div", { className: 'collection-status published' }, t('Published'));
        }
        else if (enabled) {
            return React.createElement("div", { className: 'collection-status enabled' }, t('Enabled'));
        }
        else {
            return React.createElement("div", { className: 'collection-status disabled' }, t('Disabled'));
        }
    }
    else {
        return null;
    }
}
exports["default"] = CollectionReleaseStatus;


/***/ }),

/***/ "./src/views/CollectionTile/NewRevisionMarker.tsx":
/*!********************************************************!*\
  !*** ./src/views/CollectionTile/NewRevisionMarker.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function NewRevisionMarker(props) {
    var _a, _b, _c;
    const { t, collection, updating } = props;
    if ((((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a['newestVersion']) === undefined)
        || (parseInt((_b = collection.attributes) === null || _b === void 0 ? void 0 : _b['newestVersion'], 10)
            <= parseInt((_c = collection.attributes) === null || _c === void 0 ? void 0 : _c['version'], 10))) {
        return null;
    }
    return (React.createElement("div", { className: 'collections-new-revision' },
        React.createElement(vortex_api_1.Icon, { name: updating ? 'spinner_new' : 'details' }),
        t('Update')));
}
exports["default"] = NewRevisionMarker;


/***/ }),

/***/ "./src/views/CollectionTile/RemoteTile.tsx":
/*!*************************************************!*\
  !*** ./src/views/CollectionTile/RemoteTile.tsx ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function HoverMenu(props) {
    const { t, added, incomplete, revision, onCloneCollection, onInstallCollection, onResumeCollection, } = props;
    const installOwnCollection = React.useCallback(() => {
        if (added !== undefined) {
            onResumeCollection(added.id);
        }
        else {
            onInstallCollection(revision);
        }
    }, [added, revision, onInstallCollection, onResumeCollection]);
    const cloneOwnCollection = React.useCallback(() => {
        onCloneCollection(added.id);
    }, [onCloneCollection, added]);
    const staticElements = [];
    if ((added !== undefined) && !incomplete) {
        staticElements.push({
            title: 'Edit (Requires clone)',
            icon: 'edit',
            action: () => cloneOwnCollection(),
        });
    }
    else {
        staticElements.push({
            title: 'Install',
            icon: 'install',
            action: () => installOwnCollection(),
        }, {
            title: 'Edit',
            icon: 'edit',
            condition: (instanceId, data) => t('Your collection must be installed first and then cloned to make edits.'),
            action: () => {
            },
        });
    }
    staticElements.push();
    return (React.createElement("div", { className: 'thumbnail-hover-menu' },
        React.createElement("div", { key: 'primary-buttons', className: 'hover-content' },
            React.createElement(vortex_api_1.IconBar, { t: t, id: `collection-thumbnail-${revision.collection.slug}`, className: 'buttons', group: 'collection-actions', instanceId: revision.collection.slug, staticElements: staticElements, collapse: false, buttonType: 'both', orientation: 'vertical', clickAnywhere: true }))));
}
function RemoteTile(props) {
    var _a;
    const { t, revision, onCloneCollection, onInstallCollection, onResumeCollection } = props;
    const classes = ['collection-thumbnail', 'collection-remote'];
    const images = [];
    if (!!((_a = revision.collection.tileImage) === null || _a === void 0 ? void 0 : _a.url)) {
        images.push(revision.collection.tileImage.url);
    }
    images.push(path.join(__dirname, 'fallback_tile.png'));
    return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' ') },
        React.createElement(react_bootstrap_1.Panel.Body, { className: 'collection-thumbnail-body' },
            React.createElement(vortex_api_1.Image, { className: 'thumbnail-img', srcs: images, circle: false }),
            React.createElement("div", { className: 'bottom' },
                React.createElement("div", { className: 'collection-revision-and-rating' },
                    React.createElement("div", { className: 'revision-number' }, t('Revision {{number}}', {
                        replace: {
                            number: revision.revisionNumber,
                        }
                    })),
                    React.createElement("div", { className: classes.join(' ') },
                        React.createElement(vortex_api_1.Icon, { name: 'health' }),
                        t('{{rating}}%', { replace: { rating: revision.rating.average } }))),
                React.createElement("div", { className: 'name no-hover' }, revision.collection.name),
                React.createElement("div", { className: 'details' },
                    React.createElement("div", { className: 'author' }, t('By {{uploader}}', {
                        replace: {
                            uploader: revision.collection.user.name,
                        },
                    })),
                    React.createElement("div", null,
                        React.createElement(vortex_api_1.Icon, { name: 'mods' }),
                        revision.modFiles.length))),
            React.createElement(HoverMenu, { t: t, revision: revision, added: props.added, incomplete: props.incomplete, onInstallCollection: onInstallCollection, onCloneCollection: onCloneCollection, onResumeCollection: onResumeCollection }))));
}
exports["default"] = RemoteTile;


/***/ }),

/***/ "./src/views/CollectionTile/SuccessRating.tsx":
/*!****************************************************!*\
  !*** ./src/views/CollectionTile/SuccessRating.tsx ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuccessRating = void 0;
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function SuccessRating(props) {
    const { t, collectionSlug, infoCache, revisionNumber, revisionId } = props;
    const [rating, setRating] = React.useState(undefined);
    React.useEffect(() => {
        (async () => {
            var _a, _b;
            try {
                const rev = await infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber);
                if (((_b = (_a = rev === null || rev === void 0 ? void 0 : rev.rating) === null || _a === void 0 ? void 0 : _a.total) !== null && _b !== void 0 ? _b : 0) < 3) {
                    setRating(undefined);
                }
                else {
                    setRating(rev.rating.average);
                }
            }
            catch (err) {
                (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                    revisionId, collectionSlug, revisionNumber,
                    error: err.message,
                });
            }
        })();
    }, [revisionId]);
    const classes = [
        'collection-success-indicator',
    ];
    if (rating === undefined) {
        classes.push('success-rating-insufficient');
    }
    else if (rating < 50) {
        classes.push('success-rating-bad');
    }
    else if (rating < 75) {
        classes.push('success-rating-dubious');
    }
    else {
        classes.push('success-rating-good');
    }
    return (React.createElement("div", { className: classes.join(' ') },
        React.createElement(vortex_api_1.Icon, { name: 'health' }),
        (rating === undefined)
            ? t('Awaiting')
            : t('{{rating}}%', { replace: { rating } })));
}
exports.SuccessRating = SuccessRating;


/***/ }),

/***/ "./src/views/CollectionTile/index.tsx":
/*!********************************************!*\
  !*** ./src/views/CollectionTile/index.tsx ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const CollectionReleaseStatus_1 = __webpack_require__(/*! ../CollectionReleaseStatus */ "./src/views/CollectionReleaseStatus.tsx");
const NewRevisionMarker_1 = __webpack_require__(/*! ./NewRevisionMarker */ "./src/views/CollectionTile/NewRevisionMarker.tsx");
const SuccessRating_1 = __webpack_require__(/*! ./SuccessRating */ "./src/views/CollectionTile/SuccessRating.tsx");
function ModNameField(props) {
    const { t, name, onChange } = props;
    const [editing, setEditing] = React.useState(false);
    const [tempName, setTempName] = React.useState(name);
    const changeInput = React.useCallback((evt) => {
        setTempName(evt.currentTarget.value.slice(0, constants_1.MAX_COLLECTION_NAME_LENGTH));
    }, [setTempName]);
    const validationState = React.useCallback(() => {
        if ((tempName.length < constants_1.MIN_COLLECTION_NAME_LENGTH)
            || (tempName.length > constants_1.MAX_COLLECTION_NAME_LENGTH)) {
            return 'error';
        }
        else {
            return 'success';
        }
    }, [tempName]);
    const apply = React.useCallback(() => {
        if (validationState() === 'success') {
            onChange(tempName);
            setEditing(false);
        }
    }, [setEditing, tempName]);
    const keyPress = React.useCallback((evt) => {
        if (evt.key === 'Enter') {
            apply();
        }
    }, [apply]);
    const startEdit = React.useCallback(() => {
        setEditing(true);
    }, [setEditing]);
    return (React.createElement("div", { className: `collection-name ${editing ? 'editing' : 'displaying'}` }, editing ? (React.createElement(React.Fragment, null,
        React.createElement(react_bootstrap_1.FormGroup, { controlId: 'formBasicText', validationState: validationState() },
            React.createElement(react_bootstrap_1.FormControl, { type: 'text', value: tempName, placeholder: t('Collection Name'), onChange: changeInput, autoFocus: true, onKeyPress: keyPress })),
        React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'input-confirm', tooltip: t('Save name'), onClick: apply }))) : (React.createElement(React.Fragment, null,
        React.createElement("div", { className: 'name' }, tempName),
        React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'edit', tooltip: t('Change name'), onClick: startEdit })))));
}
class CollectionThumbnail extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.imageURLs = (0, memoize_one_1.default)((collection) => {
            var _a;
            return [(_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.pictureUrl, path.join(__dirname, 'fallback_tile.png')]
                .filter(iter => iter !== undefined);
        });
        this.changeName = (name) => {
            const { collection, onSetModAttribute, profile } = this.props;
            onSetModAttribute(profile.gameId, collection.id, 'customFileName', name);
        };
        this.initState({
            updating: false
        });
    }
    render() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const { t, collection, details, infoCache, incomplete, mods, onEdit, profile, forceRevisionDisplay } = this.props;
        if (collection === undefined) {
            return null;
        }
        const active = vortex_api_1.util.getSafe(profile, ['modState', collection.id, 'enabled'], false);
        const refMods = ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type));
        const totalSize = Object.values((_b = collection.rules) !== null && _b !== void 0 ? _b : []).reduce((prev, rule) => {
            var _a, _b, _c;
            if (rule.reference.fileSize !== undefined) {
                return prev + rule.reference.fileSize;
            }
            else if ((rule.reference.id !== undefined) && (mods !== undefined)) {
                return prev + ((_c = (_b = (_a = mods[rule.reference.id]) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.fileSize) !== null && _c !== void 0 ? _c : 0);
            }
            else {
                return prev;
            }
        }, 0);
        const classes = ['collection-thumbnail'];
        const hasMenu = (this.actions.length > 0);
        if (this.props.className !== undefined) {
            classes.push(this.props.className);
        }
        if (hasMenu) {
            classes.push('has-menu');
        }
        const { revisionId, collectionSlug, revisionNumber } = (_c = collection.attributes) !== null && _c !== void 0 ? _c : {};
        const validRemote = (revisionId !== undefined)
            && (collectionSlug !== undefined)
            && (revisionNumber !== undefined);
        return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' '), bsStyle: active ? 'primary' : 'default' },
            React.createElement(react_bootstrap_1.Panel.Body, { className: 'collection-thumbnail-body' },
                (details === true)
                    ? React.createElement(NewRevisionMarker_1.default, { t: t, collection: collection, updating: this.state.updating })
                    : null,
                React.createElement(vortex_api_1.Image, { className: 'thumbnail-img', srcs: this.imageURLs(collection), circle: false }),
                (details !== false) ? React.createElement("div", { className: 'gradient' }) : null,
                (details !== false) ? (React.createElement("div", { className: `bottom ${onEdit !== undefined ? 'editable' : ''}` },
                    React.createElement(CollectionReleaseStatus_1.default, { t: t, active: active, enabled: (_f = (_e = (_d = profile === null || profile === void 0 ? void 0 : profile.modState) === null || _d === void 0 ? void 0 : _d[collection.id]) === null || _e === void 0 ? void 0 : _e.enabled) !== null && _f !== void 0 ? _f : false, collection: collection, incomplete: incomplete }),
                    React.createElement("div", { className: 'collection-revision-and-rating' },
                        React.createElement("div", { className: 'revision-number' }, t('Revision {{number}}{{forceRevision}}', { replace: {
                                number: (_h = (_g = collection.attributes) === null || _g === void 0 ? void 0 : _g.version) !== null && _h !== void 0 ? _h : '0',
                                forceRevision: forceRevisionDisplay === undefined ? '' : ' ➔ ' + forceRevisionDisplay,
                            } })),
                        (infoCache !== undefined) && validRemote
                            ? React.createElement(SuccessRating_1.SuccessRating, { t: t, infoCache: infoCache, collectionSlug: collectionSlug, revisionNumber: revisionNumber, revisionId: revisionId })
                            : null),
                    React.createElement("div", { className: 'name no-hover' }, vortex_api_1.util.renderModName(collection, { version: false })),
                    onEdit !== undefined ? (React.createElement("div", { className: 'hover' },
                        React.createElement(ModNameField, { t: t, name: vortex_api_1.util.renderModName(collection, { version: false }), onChange: this.changeName }))) : null,
                    React.createElement("div", { className: 'details' },
                        React.createElement("div", { className: 'author' }, t('By {{uploader}}', { replace: {
                                uploader: (_k = (_j = collection.attributes) === null || _j === void 0 ? void 0 : _j.uploader) !== null && _k !== void 0 ? _k : t(constants_1.AUTHOR_UNKNOWN)
                            },
                        })),
                        React.createElement("div", null,
                            React.createElement(vortex_api_1.Icon, { name: 'mods' }),
                            refMods.length)))) : null,
                hasMenu ? (React.createElement("div", { className: 'thumbnail-hover-menu' }, this.renderMenu(refMods, totalSize))) : null)));
    }
    invoke(action, inst) {
        if ((action !== undefined) && (inst !== undefined) && (inst.length > 0)) {
            return action(inst[0]);
        }
    }
    get actions() {
        var _a;
        const { t, collection, incomplete, installing, onEdit, onPause, onUpload, onRemove, onResume, onUpdate, onView } = this.props;
        const result = [];
        if (onUpdate) {
            result.push({
                title: 'Update',
                icon: 'auto-update',
                group: 'optional',
                condition: () => {
                    const { attributes } = this.props.collection;
                    if (this.state.updating) {
                        return t('Already updating');
                    }
                    return ((attributes === null || attributes === void 0 ? void 0 : attributes.newestVersion) !== undefined)
                        && (parseInt(attributes.newestVersion, 10) > parseInt(attributes.version, 10));
                },
                action: (instanceIds) => {
                    const prom = this.invoke(onUpdate, instanceIds);
                    if (prom !== undefined) {
                        this.nextState.updating = true;
                        prom
                            .catch(err => {
                            if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                                this.context.api.showErrorNotification('Failed to update collection', err);
                            }
                        })
                            .finally(() => {
                            this.nextState.updating = false;
                        });
                    }
                },
            });
        }
        if (onView) {
            result.push({
                title: 'View',
                icon: 'show',
                action: (instanceIds) => {
                    this.invoke(onView, instanceIds);
                },
            });
            if (incomplete && (onResume !== undefined)) {
                result.push({
                    title: 'Resume',
                    icon: 'resume',
                    condition: () => {
                        if (installing === undefined) {
                            return true;
                        }
                        return (installing.id === collection.id)
                            ? false
                            : t('Another collection is being installed');
                    },
                    action: (instanceIds) => {
                        if (onResume !== undefined) {
                            this.invoke(onResume, instanceIds);
                        }
                        this.invoke(onView, instanceIds);
                    },
                });
            }
            if (incomplete && (onPause !== undefined)) {
                result.push({
                    title: 'Pause',
                    icon: 'pause',
                    condition: () => (installing === null || installing === void 0 ? void 0 : installing.id) === collection.id,
                    action: (instanceIds) => {
                        this.invoke(onPause, instanceIds);
                        this.invoke(onView, instanceIds);
                    },
                });
            }
        }
        if (onEdit) {
            result.push({
                title: 'Edit',
                icon: 'edit',
                action: (instanceIds) => this.invoke(onEdit, instanceIds),
            });
        }
        if (onRemove) {
            result.push({
                title: 'Remove',
                icon: 'remove',
                action: (instanceIds) => this.invoke(onRemove, instanceIds),
            });
        }
        if (onUpload) {
            const nextRev = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.revisionNumber;
            result.push({
                title: t(nextRev !== undefined ? 'Upload Update' : 'Upload New'),
                icon: 'upload',
                action: (instanceIds) => this.invoke(onUpload, instanceIds),
                condition: () => {
                    var _a;
                    const refMods = ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
                        .filter(rule => ['requires', 'recommends'].includes(rule.type));
                    if (refMods.length === 0) {
                        return (this.props.t('Can\'t upload an empty collection'));
                    }
                    else {
                        return true;
                    }
                },
            });
        }
        return result;
    }
    renderMenu(refMods, totalSize) {
        const { t, collection } = this.props;
        return [(React.createElement("div", { key: 'primary-buttons', className: 'hover-content' },
                React.createElement(vortex_api_1.IconBar, { id: `collection-thumbnail-${collection.id}`, className: 'buttons', group: 'collection-actions', instanceId: collection.id, staticElements: this.actions, collapse: false, buttonType: 'both', orientation: 'vertical', clickAnywhere: true, t: t })))];
    }
}
const emptyObj = {};
function mapStateToProps(state, ownProps) {
    return {
        profile: vortex_api_1.selectors.activeProfile(state),
    };
}
function mapDispatchToProps(dispatch) {
    return {
        onSetModAttribute: (gameId, modId, key, value) => dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, key, value)),
    };
}
exports["default"] = (0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(CollectionThumbnail);


/***/ }),

/***/ "./src/views/IniTweaks.tsx":
/*!*********************************!*\
  !*** ./src/views/IniTweaks.tsx ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
class Tweak extends vortex_api_1.PureComponentEx {
    constructor() {
        super(...arguments);
        this.mStatusActions = [
            {
                icon: 'toggle-enabled',
                title: 'Enabled',
                action: () => this.disable(),
                condition: () => this.props.enabled,
            },
            {
                icon: 'toggle-disabled',
                title: 'Disabled',
                action: () => this.enable(),
                condition: () => !this.props.enabled,
            },
            {
                icon: 'delete',
                title: 'Remove',
                action: () => this.remove(),
            },
        ];
        this.edit = () => {
            const { tweaksPath, fileName } = this.props;
            vortex_api_1.util.opn(path.join(tweaksPath, fileName)).catch(() => null);
        };
        this.enable = () => {
            this.toggle(true);
        };
        this.disable = () => {
            this.toggle(false);
        };
        this.remove = () => {
            const { fileName, onRemoveTweak } = this.props;
            onRemoveTweak({ fileName });
        };
        this.toggle = (enabled) => {
            const { fileName, onToggle } = this.props;
            onToggle(fileName, enabled);
        };
    }
    render() {
        const { t, fileName } = this.props;
        const match = fileName.match(/(.*)\[(.*)\]\.ini/);
        if (!match || (match.length < 3)) {
            return null;
        }
        return (React.createElement("tr", null,
            React.createElement("td", { className: 'cell-status' }, this.renderStatusActions()),
            React.createElement("td", { className: 'cell-tweak-name' }, match[1]),
            React.createElement("td", { className: 'cell-filename' }, `${match[2]}.ini`),
            React.createElement("td", { className: 'cell-edit' },
                React.createElement("a", { onClick: this.edit },
                    React.createElement(vortex_api_1.Icon, { name: 'edit' })))));
    }
    renderStatusActions() {
        const { t } = this.props;
        return (React.createElement(vortex_api_1.ActionDropdown, { t: t, buttonType: 'text', staticElements: this.mStatusActions, className: 'collections-ini-tweaks-actions' }));
    }
}
class TweakList extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.addIniTweak = () => {
            const { collection, modsPath, onAddIniTweak, settingsFiles } = this.props;
            if ((collection === null || collection === void 0 ? void 0 : collection.installationPath) && modsPath) {
                const modPath = path.join(modsPath, collection.installationPath);
                onAddIniTweak(modPath, settingsFiles)
                    .then(() => this.refreshTweaks());
            }
        };
        this.refreshTweaks = () => {
            const { collection, modsPath, onRefreshTweaks } = this.props;
            if ((collection === null || collection === void 0 ? void 0 : collection.installationPath) && modsPath) {
                const modPath = path.join(modsPath, collection.installationPath);
                onRefreshTweaks(modPath).then((newTweaks) => this.nextState.tweaks = newTweaks);
            }
        };
        this.renderTweak = (tweak) => {
            const { t, collection, modsPath } = this.props;
            const { fileName } = tweak;
            const isEnabled = vortex_api_1.util.getSafe(collection, ['enabledINITweaks'], []).indexOf(fileName) !== -1;
            return (React.createElement(Tweak, { t: t, key: `tweak-${fileName}`, tweaksPath: path.join(modsPath, collection.installationPath, constants_1.INI_TWEAKS_PATH), fileName: fileName, enabled: isEnabled, onToggle: this.toggle, onRemoveTweak: this.removeTweak }));
        };
        this.removeTweak = (tweak) => {
            const { collection, modsPath, onRemoveIniTweak } = this.props;
            if ((collection === null || collection === void 0 ? void 0 : collection.installationPath) && modsPath) {
                const modPath = path.join(modsPath, collection.installationPath);
                onRemoveIniTweak(modPath, tweak)
                    .then(() => this.refreshTweaks());
            }
        };
        this.toggle = (fileName, enabled) => {
            const { collection, gameId, onSetINITweakEnabled } = this.props;
            onSetINITweakEnabled(gameId, collection.id, fileName, enabled);
        };
        this.initState({
            tweaks: [],
        });
    }
    componentDidMount() {
        this.refreshTweaks();
    }
    render() {
        const { t, collection } = this.props;
        const { tweaks } = this.state;
        if (collection === undefined) {
            return null;
        }
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', className: 'ini-tweaks-container' },
            React.createElement(react_bootstrap_1.ControlLabel, null,
                React.createElement("p", null, t('This screen lets you set up tweaks for the game ini file that will be applied '
                    + 'to a user\'s setup when they use your collection.')),
                React.createElement("p", null, t('Users can toggle these ini tweaks individually so you may want to set up '
                    + 'multiple tweaks to give users granular control.'))),
            React.createElement(vortex_api_1.FlexLayout.Flex, null,
                React.createElement("div", { id: 'collection-initweaks-table-panel' },
                    React.createElement(react_bootstrap_1.Table, { id: 'collection-initweaks-table' },
                        React.createElement("thead", null,
                            React.createElement("tr", null,
                                React.createElement("th", { className: 'header-status' }, t('Status')),
                                React.createElement("th", { className: 'header-tweak-name' }, t('Tweak Name')),
                                React.createElement("th", { className: 'header-filename' }, t('Ini File')),
                                React.createElement("th", { className: 'header-edit' },
                                    t('Edit'),
                                    React.createElement(vortex_api_1.More, { id: 'edit-ini-file', name: t('Edit Ini File') }, t('"Edit" allows you to input the ini tweak you want to '
                                        + 'apply to the target ini file. Please provide the section as '
                                        + 'well as your tweak(s). e.g.:\n\n[General]\nsIntroSequence=0'))))),
                        React.createElement("tbody", null, tweaks.map(tweak => this.renderTweak(tweak)))),
                    React.createElement(react_bootstrap_1.Button, { onClick: this.addIniTweak }, t('Add')))),
            React.createElement(vortex_api_1.Usage, { infoId: 'ini-tweaks' },
                React.createElement("p", null, t('To assist in the testing of INI configuration application - any enabled INI modification '
                    + 'on this page will be applied to your own environment in the next deployment event; IF '
                    + 'the collection mod is enabled.')),
                React.createElement("p", null, t('To disable/enable an INI tweak, simply click on the button itself (in the status column). '
                    + 'If needed, INI tweak can be removed by clicking the arrow next to the button and selecting "Remove"')))));
    }
}
function mapStateToProps(state, ownProps) {
    return {
        modsPath: vortex_api_1.selectors.installPath(state),
    };
}
function mapDispatchToProps(dispatch) {
    return {
        onSetINITweakEnabled: (gameId, modId, tweak, enabled) => {
            dispatch(vortex_api_1.actions.setINITweakEnabled(gameId, modId, tweak, enabled));
        },
    };
}
const TweakListConnected = (0, react_i18next_1.withTranslation)([constants_1.NAMESPACE, 'common'])((0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(TweakList));
exports["default"] = TweakListConnected;


/***/ }),

/***/ "./src/views/InstallDialog/InstallChangelogDialog.tsx":
/*!************************************************************!*\
  !*** ./src/views/InstallDialog/InstallChangelogDialog.tsx ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InstallChangelogDialog = void 0;
const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const ReactMarkdown = __webpack_require__(/*! react-markdown */ "../../node_modules/react-markdown/src/react-markdown.js");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
function nop() {
}
function InstallChangelogDialogImpl(props) {
    const { collection, gameId, onCancel, onContinue, revisionInfo } = props;
    const { t } = (0, react_i18next_1.useTranslation)();
    const lang = (0, react_redux_1.useSelector)(state => state.settings.interface.language);
    const context = React.useContext(vortex_api_1.MainContext);
    const openUrl = React.useCallback(() => {
        context.api.events.emit('analytics-track-click-event', 'Collections', 'View on site Updated Collection');
        vortex_api_1.util.opn(vortex_api_1.util.nexusModsURL([revisionInfo.collection.game.domainName, 'collections', revisionInfo.collection.slug], {
            campaign: vortex_api_1.util.Campaign.ViewCollection,
            section: vortex_api_1.util.Section.Collections,
        }));
    }, [collection]);
    if (collection === undefined) {
        return null;
    }
    const changelog = revisionInfo.collectionChangelog;
    const changelogDate = new Date(changelog.createdAt);
    return (React.createElement(react_bootstrap_1.Modal, { id: 'install-changelog-dialog', show: collection !== undefined, onHide: nop },
        React.createElement(react_bootstrap_1.Modal.Header, null,
            React.createElement(react_bootstrap_1.Modal.Title, null, t('{{collectionName}} update', { replace: { collectionName: vortex_api_1.util.renderModName(collection) } }))),
        React.createElement(react_bootstrap_1.Modal.Body, null,
            React.createElement(react_bootstrap_1.Media.Left, null,
                React.createElement(CollectionTile_1.default, { t: t, gameId: gameId, collection: collection, details: 'some', imageTime: 42, forceRevisionDisplay: revisionInfo.revisionNumber })),
            React.createElement(react_bootstrap_1.Media.Right, null,
                React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                    React.createElement("h4", null, t('Revision {{revNum}} Changelog', { replace: { revNum: revisionInfo.revisionNumber } })),
                    React.createElement("div", { className: 'changelog-time' }, changelogDate.toLocaleDateString(lang))),
                React.createElement("div", { className: 'changelog-scroll' },
                    React.createElement(ReactMarkdown, null, changelog.description))),
            React.createElement(vortex_api_1.tooltip.IconButton, { className: 'collection-open-button', icon: 'open-in-browser', tooltip: t('Open Page'), onClick: openUrl }, t('View Collection'))),
        React.createElement(react_bootstrap_1.Modal.Footer, null,
            React.createElement(react_bootstrap_1.Button, { onClick: onCancel }, t('Later')),
            React.createElement(react_bootstrap_1.Button, { onClick: onContinue }, t('Download Update')))));
}
const localState = vortex_api_1.util.makeReactive({
    job: {
        collection: undefined,
        gameId: undefined,
        onCancel: () => {
        },
        onContinue: () => {
        },
        revisionInfo: undefined,
    },
});
class InstallChangelogDialog extends React.Component {
    componentDidMount() {
        var _a;
        (_a = localState['attach']) === null || _a === void 0 ? void 0 : _a.call(localState, this);
    }
    componentWillUnmount() {
        var _a;
        (_a = localState['detach']) === null || _a === void 0 ? void 0 : _a.call(localState, this);
    }
    render() {
        const { job } = localState;
        return (React.createElement(InstallChangelogDialogImpl, { collection: job === null || job === void 0 ? void 0 : job.collection, gameId: job === null || job === void 0 ? void 0 : job.gameId, revisionInfo: job === null || job === void 0 ? void 0 : job.revisionInfo, onContinue: job === null || job === void 0 ? void 0 : job.onContinue, onCancel: job === null || job === void 0 ? void 0 : job.onCancel }));
    }
}
exports.InstallChangelogDialog = InstallChangelogDialog;
function showChangelog(collection, gameId, revisionInfo) {
    return new Promise((resolve, reject) => {
        localState.job = {
            collection,
            gameId,
            revisionInfo,
            onContinue: () => {
                localState.job = undefined;
                resolve();
            },
            onCancel: () => {
                localState.job = undefined;
                reject(new vortex_api_1.util.UserCanceled());
            },
        };
    });
}
exports["default"] = showChangelog;


/***/ }),

/***/ "./src/views/InstallDialog/InstallFinishedDialog.tsx":
/*!***********************************************************!*\
  !*** ./src/views/InstallDialog/InstallFinishedDialog.tsx ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const YouCuratedThisTag_1 = __webpack_require__(/*! ./YouCuratedThisTag */ "./src/views/InstallDialog/YouCuratedThisTag.tsx");
const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
function nop() {
}
const emptyObject = {};
function InstallFinishedDialog(props) {
    var _a, _b, _c, _d, _e, _f;
    const { api, driver, onClone } = props;
    const { t } = (0, react_i18next_1.useTranslation)(api.NAMESPACE);
    const userInfo = (0, react_redux_1.useSelector)(state => { var _a, _b; return (_b = (_a = state.persistent['nexus']) === null || _a === void 0 ? void 0 : _a.userInfo) !== null && _b !== void 0 ? _b : emptyObject; });
    const forceUpdate = React.useState(0)[1];
    React.useEffect(() => {
        driver.onUpdate(() => {
            if (((driver === null || driver === void 0 ? void 0 : driver.collection) !== undefined) && ((driver === null || driver === void 0 ? void 0 : driver.step) === 'review')) {
                forceUpdate(i => i + 1);
            }
        });
    }, [driver, forceUpdate]);
    const skip = React.useCallback(async () => {
        if (driver.collection !== undefined) {
            await driver.continue();
        }
        forceUpdate(i => i + 1);
    }, [driver]);
    const showOptionals = React.useCallback(async () => {
        if (driver.collection !== undefined) {
            api.events.emit('view-collection', driver.collection.id, 'mods');
            api.store.dispatch(vortex_api_1.actions.setAttributeFilter('collection-mods', undefined, undefined));
            api.store.dispatch(vortex_api_1.actions.setAttributeFilter('collection-mods', 'required', false));
            await driver.continue();
        }
        forceUpdate(i => i + 1);
    }, [driver]);
    const installAllOptionals = React.useCallback(() => {
        if ((driver.step === 'review') && (driver.collection !== undefined)) {
            driver.installRecommended();
        }
        forceUpdate(i => i + 1);
    }, []);
    const clone = React.useCallback(async () => {
        if (driver.collection === undefined) {
            return;
        }
        const id = await onClone(driver.collection.id);
        if (id !== undefined) {
            props.editCollection(id);
            driver.continue();
        }
    }, [driver, onClone]);
    const collection = driver.collection;
    const mods = (0, react_redux_1.useSelector)(state => {
        var _a;
        return (driver.profile !== undefined)
            ? state.persistent.mods[(_a = driver.profile) === null || _a === void 0 ? void 0 : _a.gameId]
            : emptyObject;
    });
    const optionals = React.useMemo(() => {
        var _a;
        return ((_a = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => (rule.type === 'recommends')
            && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined));
    }, [collection === null || collection === void 0 ? void 0 : collection.rules, mods]);
    const game = driver.profile !== undefined ? vortex_api_1.util.getGame(driver.profile.gameId) : undefined;
    const ownCollection = ((_b = (_a = driver.collectionInfo) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.memberId) === (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId);
    return (React.createElement(vortex_api_1.Modal, { id: 'install-finished-dialog', show: (driver.collection !== undefined) && (driver.step === 'review'), onHide: nop },
        React.createElement(vortex_api_1.Modal.Header, null,
            React.createElement(vortex_api_1.Modal.Title, null, t('Collection installation complete'))),
        React.createElement(vortex_api_1.Modal.Body, null,
            React.createElement("div", { className: 'collection-finished-body' },
                React.createElement(react_bootstrap_1.Media.Left, null,
                    React.createElement(CollectionTile_1.default, { t: t, gameId: (_c = driver.profile) === null || _c === void 0 ? void 0 : _c.gameId, collection: driver.collection, details: true, imageTime: 42 })),
                React.createElement(react_bootstrap_1.Media.Right, null,
                    React.createElement("h5", null, game === null || game === void 0 ? void 0 : game.name),
                    React.createElement("h3", null, vortex_api_1.util.renderModName(driver.collection)), (_f = (_e = (_d = driver.collection) === null || _d === void 0 ? void 0 : _d.attributes) === null || _e === void 0 ? void 0 : _e.shortDescription) !== null && _f !== void 0 ? _f : t('No description'),
                    ownCollection && (optionals.length > 0) ? (React.createElement("div", null,
                        React.createElement(YouCuratedThisTag_1.default, { t: t }),
                        t('To edit this collection you must install all of the optional mods'))) : null)),
            (optionals.length > 0) ? (React.createElement("div", { className: 'collection-finished-optionals' },
                React.createElement("div", { className: 'collection-finished-optionals-text' }, t('{{numOptionals}} optional mods available', { replace: { numOptionals: optionals.length } })),
                React.createElement("p", null, t('This collection has {{count}} optional mods which are not required to '
                    + 'complete the installation but may provide additional features or options. '
                    + 'You can view these mods before installing as they may change the default '
                    + 'behavior of the collection or have additional requirements.', {
                    count: optionals.length,
                    ns: constants_1.NAMESPACE,
                })),
                React.createElement("div", { className: 'collection-finished-optional-buttons' }))) : ownCollection ? (React.createElement("div", { className: 'collection-can-clone-container' },
                React.createElement(YouCuratedThisTag_1.default, { t: t }),
                t('You now have the whole collection installed, you can start editing '
                    + 'your collection by cloning it.'),
                React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'clone', tooltip: t('Clone the collection to the workshop for editing'), onClick: clone }, t('Edit')))) : null),
        (optionals.length > 0) ? (React.createElement(vortex_api_1.Modal.Footer, null,
            React.createElement(react_bootstrap_1.Button, { onClick: skip }, t('No Thanks')),
            React.createElement(react_bootstrap_1.Button, { onClick: showOptionals }, t('View optional mods')),
            React.createElement(react_bootstrap_1.Button, { onClick: installAllOptionals }, t('Install optional mods')))) : (React.createElement(vortex_api_1.Modal.Footer, null,
            React.createElement(react_bootstrap_1.Button, { onClick: skip }, t('Done'))))));
}
exports["default"] = React.memo(InstallFinishedDialog);


/***/ }),

/***/ "./src/views/InstallDialog/InstallStartDialog.tsx":
/*!********************************************************!*\
  !*** ./src/views/InstallDialog/InstallStartDialog.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
const YouCuratedThisTag_1 = __webpack_require__(/*! ./YouCuratedThisTag */ "./src/views/InstallDialog/YouCuratedThisTag.tsx");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const react_select_1 = __webpack_require__(/*! react-select */ "react-select");
const shortid_1 = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const ReactMarkdown = __webpack_require__(/*! react-markdown */ "../../node_modules/react-markdown/src/react-markdown.js");
function nop() {
}
function InstallDialogSelectProfile(props) {
    const { t, allProfiles, onSelectProfile, profile, selectedProfile, recommendedNewProfile } = props;
    const profileOptions = Object.keys(allProfiles)
        .filter(profId => allProfiles[profId].gameId === profile.gameId)
        .map(profId => ({
        value: profId,
        label: profId === profile.id
            ? t('{{name}} (Current)', { replace: { name: profile.name } })
            : allProfiles[profId].name,
    }))
        .concat({
        value: '__new', label: t('Create new profile{{recommended}}', { replace: { recommended: recommendedNewProfile ? t(' (Recommended by curator)') : '' } })
    });
    return (React.createElement(vortex_api_1.FlexLayout, { type: 'row', id: 'collections-profile-select' },
        React.createElement(vortex_api_1.FlexLayout.Fixed, null, t('Install this collection to profile') + ':'),
        React.createElement(vortex_api_1.FlexLayout.Flex, null,
            React.createElement(react_select_1.default, { options: profileOptions, value: selectedProfile !== null && selectedProfile !== void 0 ? selectedProfile : profile.id, onChange: onSelectProfile, clearable: false }))));
}
function InstallDialogConfirmProfile(props) {
    var _a;
    const { t, collectionName, selectedProfile } = props;
    const profileName = (_a = selectedProfile === null || selectedProfile === void 0 ? void 0 : selectedProfile.name) !== null && _a !== void 0 ? _a : collectionName;
    return (React.createElement(React.Fragment, null,
        React.createElement("p", null, t('Currently installing to profile: {{profileName}}', {
            replace: {
                profileName,
            },
        })),
        React.createElement("p", null, t('Do you want to switch to this profile?'))));
}
class InstallDialog extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.changeProfile = (value) => {
            if (!!value) {
                this.nextState.selectedProfile = value.value;
            }
        };
        this.cancel = () => {
            this.props.driver.cancel();
        };
        this.next = () => {
            var _a, _b;
            if (!this.state.confirmProfile
                && (this.state.selectedProfile !== undefined)
                && (this.state.selectedProfile !== ((_b = (_a = this.props.driver) === null || _a === void 0 ? void 0 : _a.profile) === null || _b === void 0 ? void 0 : _b.id))) {
                if (this.state.selectedProfile === '__new') {
                    const { driver, onAddProfile, onSetProfilesVisible } = this.props;
                    const { profile } = driver;
                    const profileId = (0, shortid_1.generate)();
                    const name = vortex_api_1.util.renderModName(driver.collection);
                    const newProfile = {
                        id: profileId,
                        gameId: profile.gameId,
                        name,
                        modState: {},
                        lastActivated: 0,
                    };
                    onAddProfile(newProfile);
                    onSetProfilesVisible();
                    this.nextState.selectedProfile = profileId;
                }
                this.nextState.confirmProfile = true;
            }
            else {
                this.startInstall();
            }
        };
        this.switchProfile = async () => {
            const { selectedProfile } = this.state;
            await this.props.onSwitchProfile(selectedProfile);
            this.props.onSetProfilesVisible();
            this.startInstall();
        };
        this.initState({
            selectedProfile: undefined,
            confirmProfile: false,
            recommendedNewProfile: false,
        });
        if (props.driver !== undefined) {
            this.props.driver.onUpdate(() => this.forceUpdate());
        }
    }
    static getDerivedStateFromProps(props, state) {
        var _a, _b, _c;
        if (!state.selectedProfile && !!((_c = (_b = (_a = props.driver) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.attributes) === null || _c === void 0 ? void 0 : _c.recommendNewProfile)) {
            return {
                recommendedNewProfile: true,
                selectedProfile: '__new',
            };
        }
        return null;
    }
    componentDidUpdate(prevProps) {
        const { driver } = this.props;
        if (driver !== undefined) {
            if (driver !== prevProps.driver) {
                driver.onUpdate(() => this.forceUpdate());
            }
            if (driver.collection !== this.mLastCollection) {
                this.nextState.confirmProfile = false;
                this.nextState.selectedProfile = undefined;
                this.mLastCollection = driver.collection;
            }
        }
    }
    render() {
        var _a, _b, _c, _d;
        const { t, driver, allProfiles, nextProfileId, userInfo } = this.props;
        const { selectedProfile, recommendedNewProfile } = this.state;
        if ((driver === null || driver === void 0 ? void 0 : driver.profile) === undefined) {
            return null;
        }
        const { profile } = driver;
        if (nextProfileId !== profile.id) {
            return null;
        }
        let installInstructions = ((_b = (_a = driver.collection) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.installInstructions) || t(constants_1.DEFAULT_INSTRUCTIONS);
        installInstructions = installInstructions.replace(/\r?\n/g, "  \r\n");
        const game = vortex_api_1.util.getGame(profile.gameId);
        const ownCollection = ((userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId) !== undefined)
            && (((_d = (_c = driver.collectionInfo) === null || _c === void 0 ? void 0 : _c.user) === null || _d === void 0 ? void 0 : _d.memberId) === (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId));
        const collectionName = vortex_api_1.util.renderModName(driver.collection);
        return (React.createElement(vortex_api_1.Modal, { show: (driver.collection !== undefined) && (driver.step === 'query'), onHide: nop },
            React.createElement(vortex_api_1.Modal.Header, null,
                React.createElement(vortex_api_1.Modal.Title, null, t('{{gameName}} collection added', { replace: { gameName: game.name } }))),
            React.createElement(vortex_api_1.Modal.Body, null,
                React.createElement(react_bootstrap_1.Media, null,
                    React.createElement(react_bootstrap_1.Media.Left, null,
                        React.createElement(CollectionTile_1.default, { t: t, gameId: profile.gameId, collection: driver.collection, details: true, imageTime: 42 })),
                    React.createElement(react_bootstrap_1.Media.Right, { style: { width: '100%', display: 'flex' } },
                        React.createElement(react_bootstrap_1.Media.Body, null,
                            React.createElement(react_bootstrap_1.Media.Heading, null, "Collection instructions"),
                            React.createElement("p", { className: 'collections-instructions-canbereviewed' }, "Instructions can be reviewed during installation."),
                            ownCollection ? React.createElement(YouCuratedThisTag_1.default, { t: t }) : null,
                            React.createElement(ReactMarkdown, { className: 'textarea-install-collection-instructions', allowedElements: ['p', 'br', 'a', 'em', 'strong'], unwrapDisallowed: true }, installInstructions)))),
                React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                    React.createElement("p", null,
                        t('Profiles allow you to have multiple mod set-ups for a game at once and quickly switch between them.'),
                        React.createElement(vortex_api_1.More, { id: 'more-profile-instcollection', name: t('Profiles'), wikiId: 'profiles' }, vortex_api_1.util.getText('profile', 'profiles', t)))),
                (this.state.confirmProfile && (selectedProfile !== undefined)) ? (React.createElement(InstallDialogConfirmProfile, { t: t, collectionName: collectionName, selectedProfile: selectedProfile === '__new' ? undefined : allProfiles[selectedProfile] })) : (React.createElement(InstallDialogSelectProfile, { t: t, allProfiles: allProfiles, profile: profile, selectedProfile: selectedProfile, onSelectProfile: this.changeProfile, recommendedNewProfile: recommendedNewProfile })),
                React.createElement(vortex_api_1.Toggle, { checked: this.props.collectionsInstallWhileDownloading, onToggle: this.props.onSetCollectionConcurrency }, t('Install mods during collection downloads'))),
            React.createElement(vortex_api_1.Modal.Footer, null, this.state.confirmProfile ? (React.createElement(React.Fragment, null,
                React.createElement(react_bootstrap_1.Button, { onClick: this.next }, t('No')),
                React.createElement(react_bootstrap_1.Button, { onClick: this.switchProfile }, t('Yes')))) : (React.createElement(React.Fragment, null,
                React.createElement(react_bootstrap_1.Button, { onClick: this.cancel }, t('Later')),
                React.createElement(react_bootstrap_1.Button, { onClick: this.next }, t('Install Now')))))));
    }
    startInstall() {
        const { allProfiles, driver } = this.props;
        const { selectedProfile } = this.state;
        const { profile } = driver;
        if ((selectedProfile !== undefined) && (selectedProfile !== profile.id)) {
            driver.profile = allProfiles[selectedProfile];
        }
        driver.continue();
    }
}
const emptyObject = {};
function mapStateToProps(state, ownProps) {
    var _a, _b, _c;
    const { editCollectionId } = state.session.collections;
    const gameMode = (_b = (_a = ownProps.driver) === null || _a === void 0 ? void 0 : _a.profile) === null || _b === void 0 ? void 0 : _b.gameId;
    const isPremium = vortex_api_1.util.getSafe(state, ['persistent', 'nexus', 'userInfo', 'isPremium'], false);
    const collectionsInstallWhileDownloading = vortex_api_1.util.getSafe(state, ['settings', 'downloads', 'collectionsInstallWhileDownloading'], true);
    const { userInfo } = (_c = state.persistent['nexus']) !== null && _c !== void 0 ? _c : {};
    return {
        allProfiles: state.persistent.profiles,
        mods: editCollectionId !== undefined ? state.persistent.mods[gameMode] : emptyObject,
        isPremium,
        userInfo,
        nextProfileId: state.settings.profiles.nextProfileId,
        collectionsInstallWhileDownloading,
    };
}
function mapDispatchToProps(dispatch) {
    return {
        onSetModAttribute: (gameId, modId, key, value) => dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, key, value)),
        onSetModAttributes: (gameId, modId, attributes) => dispatch(vortex_api_1.actions.setModAttributes(gameId, modId, attributes)),
        onAddRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.addModRule(gameId, modId, rule)),
        onRemoveRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.removeModRule(gameId, modId, rule)),
        onAddProfile: (profile) => dispatch(vortex_api_1.actions.setProfile(profile)),
        onSetProfilesVisible: () => dispatch(vortex_api_1.actions.setProfilesVisible(true)),
        onSetCollectionConcurrency: (enabled) => dispatch(vortex_api_1.actions.setCollectionConcurrency(enabled)),
    };
}
exports["default"] = (0, react_i18next_1.withTranslation)(['common', constants_1.NAMESPACE])((0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(React.memo(InstallDialog)));


/***/ }),

/***/ "./src/views/InstallDialog/YouCuratedThisTag.tsx":
/*!*******************************************************!*\
  !*** ./src/views/InstallDialog/YouCuratedThisTag.tsx ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function Tag(props) {
    const { t } = props;
    return (React.createElement("div", { className: 'collections-you-curated-tag' },
        React.createElement(vortex_api_1.Icon, { name: 'completed' }),
        t('You curated this collection')));
}
exports["default"] = Tag;


/***/ }),

/***/ "./src/views/InstallDialog/index.tsx":
/*!*******************************************!*\
  !*** ./src/views/InstallDialog/index.tsx ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InstallStartDialog = exports.InstallFinishDialog = exports.InstallChangelogDialog = void 0;
const InstallChangelogDialog_1 = __webpack_require__(/*! ./InstallChangelogDialog */ "./src/views/InstallDialog/InstallChangelogDialog.tsx");
Object.defineProperty(exports, "InstallChangelogDialog", ({ enumerable: true, get: function () { return InstallChangelogDialog_1.InstallChangelogDialog; } }));
const InstallFinishedDialog_1 = __webpack_require__(/*! ./InstallFinishedDialog */ "./src/views/InstallDialog/InstallFinishedDialog.tsx");
exports.InstallFinishDialog = InstallFinishedDialog_1.default;
const InstallStartDialog_1 = __webpack_require__(/*! ./InstallStartDialog */ "./src/views/InstallDialog/InstallStartDialog.tsx");
exports.InstallStartDialog = InstallStartDialog_1.default;


/***/ }),

/***/ "./src/views/Tools.tsx":
/*!*****************************!*\
  !*** ./src/views/Tools.tsx ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const url_1 = __webpack_require__(/*! url */ "url");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function ToolIcon(props) {
    const { gameId, imageUrl } = props;
    if (imageUrl !== undefined) {
        const src = (0, url_1.pathToFileURL)(path.join(vortex_api_1.util.getVortexPath('userData'), gameId, 'icons', imageUrl)).href;
        return (React.createElement(react_bootstrap_1.Image, { src: src, className: 'tool-icon valid' }));
    }
    else {
        return (React.createElement(vortex_api_1.Icon, { name: 'executable', className: 'tool-icon valid' }));
    }
}
function ToolItem(props) {
    var _a, _b;
    const { enabled, gameId, onToggle, tool } = props;
    return (React.createElement("tr", null,
        React.createElement("td", null,
            React.createElement(vortex_api_1.Toggle, { dataId: tool.id, checked: enabled, onToggle: onToggle })),
        React.createElement("td", null,
            React.createElement(ToolIcon, { gameId: gameId, imageUrl: tool.logo })),
        React.createElement("td", null, tool.name),
        React.createElement("td", null, tool.path),
        React.createElement("td", null, ((_a = tool.parameters) !== null && _a !== void 0 ? _a : []).join(' ')),
        React.createElement("td", null, Object.keys((_b = tool.environment) !== null && _b !== void 0 ? _b : {})
            .map(key => `${key}=${tool.environment[key]}`).join(', '))));
}
const emptyArray = [];
function Tools(props) {
    const { t, collection, onSetCollectionAttribute } = props;
    const gameMode = (0, react_redux_1.useSelector)(vortex_api_1.selectors.activeGameId);
    const includedTools = (0, react_redux_1.useSelector)(state => {
        var _a, _b, _c;
        return (_c = (_b = (_a = state.persistent.mods[gameMode][collection.id].attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.includedTools) !== null && _c !== void 0 ? _c : emptyArray;
    });
    const toggleCB = React.useCallback((newValue, toolId) => {
        onSetCollectionAttribute(['includedTools'], newValue
            ? [].concat(includedTools, [toolId])
            : includedTools.filter(id => id !== toolId));
    }, [includedTools, onSetCollectionAttribute]);
    const tools = (0, react_redux_1.useSelector)((state) => state.settings.gameMode.discovered[gameMode].tools);
    const custom = Object.values(tools !== null && tools !== void 0 ? tools : {})
        .filter(tool => tool.custom && !tool.hidden);
    return (React.createElement("div", { className: 'collection-scrollable' },
        React.createElement(react_bootstrap_1.ControlLabel, null,
            React.createElement("p", null, t('This screen lets you include tools you manually configured to be run from Vortex.')),
            React.createElement("p", null, t('Obviously users will need to have these tools installed. If they aren\'t '
                + 'included in the game and not installed as a mod through this collection, '
                + 'you should include instructions for the user on how to get the tool.'))),
        React.createElement(react_bootstrap_1.Table, { id: 'collection-tools-table' },
            React.createElement("thead", null,
                React.createElement("tr", null,
                    React.createElement("th", { className: 'header-status' }, t('Status')),
                    React.createElement("th", { className: 'header-icon' }, t('Icon')),
                    React.createElement("th", { className: 'header-name' }, t('Name')),
                    React.createElement("th", { className: 'header-path' }, t('Path')),
                    React.createElement("th", { className: 'header-args' }, t('Args')),
                    React.createElement("th", { className: 'header-env' }, t('Environment')))),
            React.createElement("tbody", null, custom.map(item => (React.createElement(ToolItem, { key: item.id, t: t, tool: item, gameId: gameMode, enabled: includedTools.includes(item.id), onToggle: toggleCB })))))));
}
exports["default"] = Tools;


/***/ }),

/***/ "bluebird":
/*!***************************!*\
  !*** external "bluebird" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("bluebird");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("lodash");

/***/ }),

/***/ "node-7z":
/*!**************************!*\
  !*** external "node-7z" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node-7z");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("react");

/***/ }),

/***/ "react-bootstrap":
/*!**********************************!*\
  !*** external "react-bootstrap" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-bootstrap");

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-dom");

/***/ }),

/***/ "react-i18next":
/*!********************************!*\
  !*** external "react-i18next" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-i18next");

/***/ }),

/***/ "react-redux":
/*!******************************!*\
  !*** external "react-redux" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-redux");

/***/ }),

/***/ "react-select":
/*!*******************************!*\
  !*** external "react-select" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-select");

/***/ }),

/***/ "redux-act":
/*!****************************!*\
  !*** external "redux-act" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("redux-act");

/***/ }),

/***/ "semver":
/*!*************************!*\
  !*** external "semver" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("semver");

/***/ }),

/***/ "turbowalk":
/*!****************************!*\
  !*** external "turbowalk" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("turbowalk");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "vortex-api":
/*!*****************************!*\
  !*** external "vortex-api" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("vortex-api");

/***/ }),

/***/ "vortexmt":
/*!***************************!*\
  !*** external "vortexmt" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("vortexmt");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const persistent_1 = __webpack_require__(/*! ./actions/persistent */ "./src/actions/persistent.ts");
const persistent_2 = __webpack_require__(/*! ./reducers/persistent */ "./src/reducers/persistent.ts");
const session_1 = __webpack_require__(/*! ./reducers/session */ "./src/reducers/session.ts");
const settings_1 = __webpack_require__(/*! ./reducers/settings */ "./src/reducers/settings.ts");
const defaults_1 = __webpack_require__(/*! ./util/defaults */ "./src/util/defaults.ts");
const extension_1 = __webpack_require__(/*! ./util/extension */ "./src/util/extension.ts");
const InstallDriver_1 = __webpack_require__(/*! ./util/InstallDriver */ "./src/util/InstallDriver.ts");
const transformCollection_1 = __webpack_require__(/*! ./util/transformCollection */ "./src/util/transformCollection.ts");
const util_1 = __webpack_require__(/*! ./util/util */ "./src/util/util.ts");
const AddModsDialog_1 = __webpack_require__(/*! ./views/AddModsDialog */ "./src/views/AddModsDialog.tsx");
const HealthDownvoteDialog_1 = __webpack_require__(/*! ./views/CollectionPageView/HealthDownvoteDialog */ "./src/views/CollectionPageView/HealthDownvoteDialog.tsx");
const CollectionList_1 = __webpack_require__(/*! ./views/CollectionList */ "./src/views/CollectionList/index.tsx");
const InstallDialog_1 = __webpack_require__(/*! ./views/InstallDialog */ "./src/views/InstallDialog/index.tsx");
const CollectionModsPageAttributeRenderer_1 = __webpack_require__(/*! ./views/CollectionModsPageAttributeRenderer */ "./src/views/CollectionModsPageAttributeRenderer.tsx");
const collectionCreate_1 = __webpack_require__(/*! ./collectionCreate */ "./src/collectionCreate.ts");
const collectionInstall_1 = __webpack_require__(/*! ./collectionInstall */ "./src/collectionInstall.ts");
const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
const eventHandlers_1 = __webpack_require__(/*! ./eventHandlers */ "./src/eventHandlers.ts");
const initweaks_1 = __webpack_require__(/*! ./initweaks */ "./src/initweaks.ts");
const tools_1 = __webpack_require__(/*! ./tools */ "./src/tools.ts");
const PromiseBB = __webpack_require__(/*! bluebird */ "bluebird");
const _ = __webpack_require__(/*! lodash */ "lodash");
const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const shortid_1 = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
const url_1 = __webpack_require__(/*! url */ "url");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function isEditableCollection(state, modIds) {
    const gameMode = vortex_api_1.selectors.activeGameId(state);
    const mod = state.persistent.mods[gameMode][modIds[0]];
    if (mod === undefined) {
        return false;
    }
    return vortex_api_1.util.getSafe(mod.attributes, ['editable'], false);
}
function profileCollectionExists(api, profileId) {
    const state = api.store.getState();
    const gameMode = vortex_api_1.selectors.activeGameId(state);
    const mods = state.persistent.mods[gameMode];
    return mods[(0, transformCollection_1.makeCollectionId)(profileId)] !== undefined;
}
function onlyLocalRules(rule) {
    return ['requires', 'recommends'].includes(rule.type)
        && (rule.reference.fileExpression === undefined)
        && (rule.reference.fileMD5 === undefined)
        && (rule.reference.logicalFileName === undefined)
        && (rule.reference.repo === undefined);
}
const modsBeingRemoved = new Set();
function makeModKey(gameId, modId) {
    return `${gameId}_${modId}`;
}
function makeWillRemoveMods() {
    return (gameId, modIds) => {
        modIds.forEach(modId => modsBeingRemoved.add(makeModKey(gameId, modId)));
        return Promise.resolve();
    };
}
function makeDidRemoveMods() {
    return (gameId, modIds) => {
        modIds.forEach(modId => modsBeingRemoved.delete(makeModKey(gameId, modId)));
        return Promise.resolve();
    };
}
function makeOnUnfulfilledRules(api) {
    const reported = new Set();
    return (profileId, modId, rules) => {
        var _a;
        const state = api.store.getState();
        const profile = vortex_api_1.selectors.profileById(state, profileId);
        const gameId = profile.gameId;
        if (modsBeingRemoved.has(makeModKey(gameId, modId))) {
            return PromiseBB.resolve(false);
        }
        const collection = vortex_api_1.util.getSafe(state.persistent.mods, [gameId, modId], undefined);
        if ((collection !== undefined)
            && !reported.has(modId)
            && (state.persistent.mods[gameId][modId].type === constants_1.MOD_TYPE)
            && !((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.editable)) {
            const collectionProfile = Object.keys(state.persistent.profiles)
                .find(iter => (0, transformCollection_1.makeCollectionId)(iter) === modId);
            const notiActions = [{
                    title: 'Disable',
                    action: dismiss => {
                        dismiss();
                        if (profile !== undefined) {
                            api.store.dispatch(vortex_api_1.actions.setModEnabled(profile.id, modId, false));
                        }
                    },
                }];
            if (collectionProfile !== undefined) {
                notiActions.unshift({
                    title: 'Update',
                    action: dismiss => {
                        (0, collectionCreate_1.initFromProfile)(api, collectionProfile)
                            .then(dismiss)
                            .catch(err => api.showErrorNotification('Failed to update collection', err));
                    },
                });
            }
            else if (profile !== undefined) {
                notiActions.unshift({
                    title: 'Resume',
                    action: dismiss => {
                        driver.start(profile, collection);
                        dismiss();
                    },
                });
            }
            reported.add(modId);
            api.sendNotification({
                id: (0, util_1.getUnfulfilledNotificationId)(collection.id),
                type: 'info',
                title: 'Collection incomplete',
                message: vortex_api_1.util.renderModName(collection),
                actions: notiActions,
            });
            return PromiseBB.resolve(true);
        }
        else {
            return PromiseBB.resolve(false);
        }
    };
}
let driver;
async function cloneInstalledCollection(api, collectionId) {
    const state = api.getState();
    const gameMode = vortex_api_1.selectors.activeGameId(state);
    const mods = state.persistent.mods[gameMode];
    const result = await api.showDialog('question', 'Clone collection "{{collectionName}}"?', {
        text: 'Cloning a collection means you can make edits to the collection in the workshop '
            + 'and share your changes with the community.\n'
            + 'If this collection is your own, your uploads will be revisions of that existing '
            + 'collection, otherwise you will create a new collection associated with your own '
            + 'account.',
        parameters: {
            collectionName: vortex_api_1.util.renderModName(mods[collectionId]),
        },
    }, [
        { label: 'Cancel' },
        { label: 'Clone' },
    ]);
    if (result.action === 'Clone') {
        const id = (0, transformCollection_1.makeCollectionId)((0, shortid_1.generate)());
        return (0, transformCollection_1.cloneCollection)(api, gameMode, id, collectionId);
    }
    else {
        return Promise.resolve(undefined);
    }
}
async function createNewCollection(api, profile, name) {
    const id = (0, transformCollection_1.makeCollectionId)((0, shortid_1.generate)());
    await (0, transformCollection_1.createCollection)(api, profile.gameId, id, name, []);
    api.sendNotification({
        type: 'success',
        id: 'collection-created',
        title: 'Collection created',
        message: name,
        actions: [
            {
                title: 'Edit',
                action: dismiss => {
                    api.events.emit('edit-collection', id);
                    dismiss();
                },
            },
        ],
    });
}
async function installCollection(api, revision) {
    return api.showDialog('question', 'Collection not installed', {
        text: 'You can only edit collections that are fully installed in this '
            + 'setup. Please ensure you install the collection with all '
            + 'optional items, then clone the collection into the Workshop.'
    }, [
        { label: 'Cancel' },
        { label: 'Install' },
    ])
        .then(result => {
        if (result.action === 'Install') {
            const gameId = revision.collection.game.domainName;
            api.events.emit('start-download', [`nxm://${gameId}/collections/${revision.collection.slug}/revisions/${revision.revisionNumber}`], {}, undefined, (err) => {
                if ((err !== null) && !(err instanceof vortex_api_1.util.UserCanceled)) {
                    api.showErrorNotification('Failed to download collection', err);
                }
            }, undefined, { allowInstall: 'force' });
        }
    });
}
async function pauseCollection(api, gameId, modId, silent) {
    var _a;
    const state = api.getState();
    const mods = state.persistent.mods[gameId];
    const downloads = state.persistent.downloads.files;
    const collection = mods[modId];
    if (collection === undefined) {
        return;
    }
    ((_a = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _a !== void 0 ? _a : []).forEach(rule => {
        const dlId = vortex_api_1.util.findDownloadByRef(rule.reference, downloads);
        if (dlId !== undefined) {
            api.events.emit('pause-download', dlId);
        }
    });
    await api.emitAndAwait('cancel-dependency-install', modId);
    driver.cancel();
    api.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + modId);
    if (silent !== true) {
        api.sendNotification({
            id: 'collection-pausing',
            type: 'success',
            title: 'Collection pausing',
            message: 'Already queued mod installations will still finish',
        });
    }
}
async function removeCollection(api, gameId, modId, cancel) {
    var _a, _b, _c;
    const state = api.getState();
    const mods = state.persistent.mods[gameId];
    const t = api.translate;
    const collection = mods[modId];
    if (collection === undefined) {
        return;
    }
    const filter = rule => (rule.type === 'requires')
        && (rule['ignored'] !== true)
        && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined);
    const incomplete = ((_a = collection.rules) !== null && _a !== void 0 ? _a : []).find(filter);
    const message = cancel && incomplete
        ? 'Are you sure you want to cancel the installation?'
        : 'Are you sure you want to remove the collection?';
    const result = await api.showDialog('question', message, {
        text: 'This collection will be removed from Vortex and unlinked from any associated mods. '
            + 'You can also choose to uninstall mods related to this collection and delete the '
            + 'downloaded archives.\n'
            + '\nPlease note, some mods may be required by multiple collections.\n'
            + '\nAre you sure you want to remove "{{collectionName}}" from your collections?',
        parameters: {
            collectionName: vortex_api_1.util.renderModName(collection),
        },
        checkboxes: [
            { id: 'delete_mods', text: t('Remove mods'), value: false },
            { id: 'delete_archives', text: t('Delete mod archives'), value: false },
        ],
    }, [
        { label: 'Cancel' },
        { label: 'Remove Collection' },
    ]);
    if (result.action === 'Cancel') {
        return;
    }
    const deleteArchives = result.input.delete_archives;
    const deleteMods = result.input.delete_mods;
    modsBeingRemoved.add(makeModKey(gameId, modId));
    await pauseCollection(api, gameId, modId, true);
    let progress = 0;
    const notiId = (0, shortid_1.generate)();
    const modName = vortex_api_1.util.renderModName(collection);
    const doProgress = (step, value) => {
        if (value <= progress) {
            return;
        }
        progress = value;
        api.sendNotification({
            id: notiId,
            type: 'activity',
            title: 'Removing {{name}}',
            message: step,
            progress,
            replace: {
                name: modName,
            },
        });
    };
    try {
        doProgress('Removing downloads', 0);
        const downloads = state.persistent.downloads.files;
        let completed = 0;
        await Promise.all(((_b = collection.rules) !== null && _b !== void 0 ? _b : []).map(async (rule) => {
            const dlId = vortex_api_1.util.findDownloadByRef(rule.reference, downloads);
            if (dlId !== undefined) {
                const download = state.persistent.downloads.files[dlId];
                if ((download !== undefined)
                    && (deleteArchives || (download.state !== 'finished'))) {
                    await vortex_api_1.util.toPromise(cb => api.events.emit('remove-download', dlId, cb));
                }
            }
            doProgress('Removing downloads', 50 * ((completed++) / collection.rules.length));
        }));
        doProgress('Removing mods', 50);
        completed = 0;
        if (deleteMods) {
            const removeMods = ((_c = collection.rules) !== null && _c !== void 0 ? _c : [])
                .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
                .filter(mod => mod !== undefined)
                .map(mod => mod.id);
            await vortex_api_1.util.toPromise(cb => api.events.emit('remove-mods', gameId, removeMods, cb, {
                progressCB: (idx, length, name) => {
                    doProgress(name, 50 + (50 * idx) / length);
                },
            }));
        }
        {
            doProgress('Removing collection', 0.99);
            const download = state.persistent.downloads.files[collection.archiveId];
            if (download !== undefined) {
                await vortex_api_1.util.toPromise(cb => api.events.emit('remove-download', collection.archiveId, cb));
            }
            await vortex_api_1.util.toPromise(cb => api.events.emit('remove-mod', gameId, modId, cb, {
                incomplete: true,
            }));
        }
    }
    catch (err) {
        if (!(err instanceof vortex_api_1.util.UserCanceled)) {
            api.showErrorNotification('Failed to remove mods', err, {
                message: modName,
                allowReport: !(err instanceof vortex_api_1.util.ProcessCanceled),
                warning: (err instanceof vortex_api_1.util.ProcessCanceled),
            });
        }
    }
    finally {
        modsBeingRemoved.delete(makeModKey(gameId, modId));
        api.dismissNotification(notiId);
    }
}
function genAttributeExtractor(api) {
    return (modInfo, modPath) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        const collectionId = (_d = (_c = (_b = (_a = modInfo.download) === null || _a === void 0 ? void 0 : _a.modInfo) === null || _b === void 0 ? void 0 : _b.nexus) === null || _c === void 0 ? void 0 : _c.ids) === null || _d === void 0 ? void 0 : _d.collectionId;
        const revisionId = (_h = (_g = (_f = (_e = modInfo.download) === null || _e === void 0 ? void 0 : _e.modInfo) === null || _f === void 0 ? void 0 : _f.nexus) === null || _g === void 0 ? void 0 : _g.ids) === null || _h === void 0 ? void 0 : _h.revisionId;
        const collectionSlug = (_m = (_l = (_k = (_j = modInfo.download) === null || _j === void 0 ? void 0 : _j.modInfo) === null || _k === void 0 ? void 0 : _k.nexus) === null || _l === void 0 ? void 0 : _l.ids) === null || _m === void 0 ? void 0 : _m.collectionSlug;
        const revisionNumber = (_r = (_q = (_p = (_o = modInfo.download) === null || _o === void 0 ? void 0 : _o.modInfo) === null || _p === void 0 ? void 0 : _p.nexus) === null || _q === void 0 ? void 0 : _q.ids) === null || _r === void 0 ? void 0 : _r.revisionNumber;
        const referenceTag = (_t = (_s = modInfo.download) === null || _s === void 0 ? void 0 : _s.modInfo) === null || _t === void 0 ? void 0 : _t.referenceTag;
        const result = {
            collectionId,
            revisionId,
            collectionSlug,
            revisionNumber,
            referenceTag,
        };
        return PromiseBB.resolve(result);
    };
}
function generateCollectionMap(mods) {
    const collections = Object.values(mods).filter(mod => mod.type === constants_1.MOD_TYPE);
    const result = {};
    collections.forEach(coll => {
        var _a;
        return ((_a = coll.rules) !== null && _a !== void 0 ? _a : []).forEach(rule => {
            if (rule.reference.id !== undefined) {
                vortex_api_1.util.setdefault(result, rule.reference.id, []).push(coll);
            }
            else {
                const installed = vortex_api_1.util.findModByRef(rule.reference, mods);
                if (installed !== undefined) {
                    vortex_api_1.util.setdefault(result, installed.id, []).push(coll);
                }
            }
        });
    });
    return result;
}
function collectionListEqual(lArgs, rArgs) {
    const lhs = lArgs[0];
    const rhs = rArgs[0];
    if (lhs === rhs) {
        return true;
    }
    const keys = Object.keys(lhs);
    if (!_.isEqual(keys, Object.keys(rhs))) {
        return false;
    }
    const ruleDiff = keys.find(modId => (lhs[modId].state !== rhs[modId].state) || (lhs[modId].rules !== rhs[modId].rules));
    return ruleDiff === undefined;
}
function generateCollectionOptions(mods) {
    return Object.values(mods)
        .filter(mod => mod.type === constants_1.MOD_TYPE)
        .map(mod => ({ label: vortex_api_1.util.renderModName(mod), value: mod.id }));
}
async function updateMeta(api) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const state = api.getState();
    const gameMode = vortex_api_1.selectors.activeGameId(state);
    const mods = (_a = state.persistent.mods[gameMode]) !== null && _a !== void 0 ? _a : {};
    const collections = Object.keys(mods)
        .filter(modId => mods[modId].type === constants_1.MOD_TYPE);
    const notiId = (0, shortid_1.generate)();
    const progress = (name, idx) => {
        api.sendNotification({
            id: notiId,
            type: 'activity',
            title: 'Updating Collection Information',
            message: name,
            progress: (idx * 100) / collections.length,
        });
    };
    for (let i = 0; i < collections.length; ++i) {
        const modId = collections[i];
        const { revisionId, collectionSlug, revisionNumber } = (_b = mods[modId].attributes) !== null && _b !== void 0 ? _b : {};
        try {
            if ((revisionId !== undefined) || (collectionSlug !== undefined)) {
                progress(vortex_api_1.util.renderModName(mods[modId]), i);
                const info = await driver.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber, 'force');
                if (!!info) {
                    const currentRevision = info.collection.revisions
                        .filter(rev => rev.revisionStatus === 'published')
                        .sort((lhs, rhs) => rhs.revisionNumber - lhs.revisionNumber)[0];
                    api.store.dispatch(vortex_api_1.actions.setModAttributes(gameMode, modId, {
                        collectionSlug: info.collection.slug,
                        revisionNumber: info.revisionNumber,
                        author: (_c = info.collection.user) === null || _c === void 0 ? void 0 : _c.name,
                        uploader: (_d = info.collection.user) === null || _d === void 0 ? void 0 : _d.name,
                        uploaderAvatar: (_e = info.collection.user) === null || _e === void 0 ? void 0 : _e.avatar,
                        uploaderId: (_f = info.collection.user) === null || _f === void 0 ? void 0 : _f.memberId,
                        pictureUrl: (_g = info.collection.tileImage) === null || _g === void 0 ? void 0 : _g.url,
                        description: info.collection.description,
                        shortDescription: info.collection.summary,
                        newestFileId: currentRevision === null || currentRevision === void 0 ? void 0 : currentRevision.revisionNumber,
                        newestVersion: (_j = (_h = currentRevision === null || currentRevision === void 0 ? void 0 : currentRevision.revisionNumber) === null || _h === void 0 ? void 0 : _h.toString) === null || _j === void 0 ? void 0 : _j.call(_h),
                        metadata: info.metadata,
                        rating: info.rating,
                    }));
                }
            }
        }
        catch (err) {
            api.showErrorNotification('Failed to check collection for update', err);
        }
    }
    localState.ownCollections = (await api.emitAndAwait('get-my-collections', gameMode))[0] || [];
    api.dismissNotification(notiId);
}
let collectionChangedCB;
function onAddSelectionImpl(api, collectionId, modIds) {
    const state = api.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const collection = state.persistent.mods[gameId][collectionId];
    if (collection !== undefined) {
        modIds.forEach(modId => {
            if (!(0, collectionCreate_1.alreadyIncluded)(collection.rules, modId)) {
                api.store.dispatch(vortex_api_1.actions.addModRule(gameId, collectionId, {
                    type: 'requires',
                    reference: {
                        id: modId,
                    },
                }));
            }
        });
    }
    else {
        (0, vortex_api_1.log)('warn', 'failed to add mods to collection, collection no longer found', { gameId, collectionId, modIds });
    }
}
const localState = vortex_api_1.util.makeReactive({
    ownCollections: [],
});
function register(context, collectionsCB) {
    context.registerReducer(['session', 'collections'], session_1.default);
    context.registerReducer(['settings', 'collections'], settings_1.default);
    context.registerReducer(['persistent', 'collections'], persistent_2.default);
    const onSwitchProfile = (profileId) => {
        return new Promise((resolve, reject) => {
            context.api.events.once('profile-did-change', (newProfileId) => {
                if (newProfileId === profileId) {
                    resolve();
                }
                else {
                    (0, vortex_api_1.log)('warn', `Failed to switch to profile ${profileId}; got ${newProfileId}`);
                    const profile = vortex_api_1.selectors.profileById(context.api.getState(), profileId);
                    if (profile === undefined) {
                        reject(new Error(`Failed to switch to profile ${profileId}; got ${newProfileId}`));
                    }
                    context.api.store.dispatch(vortex_api_1.actions.setNextProfile(profileId));
                    resolve();
                }
            });
            context.api.store.dispatch(vortex_api_1.actions.setNextProfile(profileId));
        });
    };
    context.registerDialog('collection-install', InstallDialog_1.InstallStartDialog, () => ({
        driver,
        onSwitchProfile,
    }));
    const onClone = (collectionId) => cloneInstalledCollection(context.api, collectionId);
    const onCreateCollection = (profile, name) => createNewCollection(context.api, profile, name);
    const onRemoveCollection = (gameId, modId, cancel) => removeCollection(context.api, gameId, modId, cancel);
    const onUpdateMeta = () => updateMeta(context.api);
    const editCollection = (id) => collectionsCB.editCollection(id);
    const onInstallCollection = (revision) => installCollection(context.api, revision);
    context.registerDialog('collection-finish', InstallDialog_1.InstallFinishDialog, () => ({
        api: context.api,
        driver,
        onClone,
        editCollection,
    }));
    context.registerDialog('collection-changelog', InstallDialog_1.InstallChangelogDialog, () => ({}));
    const onAddSelection = (collectionId, modIds) => onAddSelectionImpl(context.api, collectionId, modIds);
    context.registerDialog('add-mod-to-collection', AddModsDialog_1.default, () => ({
        onAddSelection,
    }));
    context.registerDialog('collection-health-downvote', HealthDownvoteDialog_1.default, () => ({}));
    let resetPageCB;
    const resetCB = (cb) => resetPageCB = cb;
    const onAddCallback = (cbName, cb) => {
        collectionsCB[cbName] = cb;
    };
    context.registerMainPage('collection', 'Collections', CollectionList_1.default, {
        hotkey: 'C',
        group: 'per-game',
        visible: () => vortex_api_1.selectors.activeGameId(context.api.store.getState()) !== undefined,
        props: () => ({
            driver,
            localState,
            onInstallCollection,
            onAddCallback,
            onRemoveCollection,
            onCloneCollection: onClone,
            onCreateCollection,
            onUpdateMeta,
            resetCB,
            pathTool,
        }),
        onReset: () => resetPageCB === null || resetPageCB === void 0 ? void 0 : resetPageCB(),
        priority: 90,
    });
    context.registerModType(constants_1.MOD_TYPE, 200, () => true, () => undefined, () => PromiseBB.resolve(false), {
        name: 'Collection',
        customDependencyManagement: true,
        noConflicts: true,
    });
    const stateFunc = () => context.api.store.getState();
    const emptyArray = [];
    const emptyObj = {};
    const collectionsMapFunc = (0, memoize_one_1.default)(generateCollectionMap, collectionListEqual);
    const collectionsMap = () => {
        var _a;
        return collectionsMapFunc((_a = stateFunc().persistent.mods[vortex_api_1.selectors.activeGameId(stateFunc())]) !== null && _a !== void 0 ? _a : emptyObj);
    };
    const collectionOptions = (0, memoize_one_1.default)(generateCollectionOptions);
    const collectionChanged = new vortex_api_1.util.Debouncer(() => {
        collectionChangedCB === null || collectionChangedCB === void 0 ? void 0 : collectionChangedCB();
        return null;
    }, 500);
    const collectionAttribute = {
        id: 'collection',
        name: 'Collection',
        description: 'Collection(s) this mod was installed from (if any)',
        icon: 'collection',
        placement: 'both',
        customRenderer: (mod, detailCell) => {
            const collections = collectionsMap()[mod.id] || emptyArray;
            return React.createElement(CollectionModsPageAttributeRenderer_1.default, { modId: mod.id, collections, detailCell }, []);
        },
        calc: (mod) => {
            const collections = collectionsMap()[mod.id];
            return (collections === undefined)
                ? '' : collections.map(iter => iter.id);
        },
        externalData: (onChanged) => {
            collectionChangedCB = onChanged;
        },
        isToggleable: true,
        edit: {},
        filter: new vortex_api_1.OptionsFilter((() => {
            var _a;
            const mods = (_a = stateFunc().persistent.mods[vortex_api_1.selectors.activeGameId(stateFunc())]) !== null && _a !== void 0 ? _a : {};
            return [
                { label: `<${context.api.translate('None')}>`, value: vortex_api_1.OptionsFilter.EMPTY },
                ...collectionOptions(mods),
            ];
        }), false, false),
        isGroupable: true,
        groupName: (modId) => { var _a; return vortex_api_1.util.renderModName((_a = stateFunc().persistent.mods[vortex_api_1.selectors.activeGameId(stateFunc())]) === null || _a === void 0 ? void 0 : _a[modId]); },
        isDefaultVisible: false,
    };
    context.registerTableAttribute('mods', collectionAttribute);
    context.registerAction('mods-action-icons', 25, 'collection-edit', {}, 'Edit Collection', (modIds) => {
        context.api.events.emit('show-main-page', 'Collections');
        setTimeout(() => {
            if ((collectionsCB !== undefined) && (collectionsCB.editCollection !== undefined)) {
                collectionsCB.editCollection(modIds[0]);
            }
        }, 100);
    }, (modIds) => isEditableCollection(context.api.getState(), modIds));
    context.registerAction('mods-action-icons', 50, 'conflict', {}, 'Apply Collection Rules', (modIds) => {
        const state = context.api.getState();
        const gameId = vortex_api_1.selectors.activeGameId(state);
        context.api.events.emit('did-install-dependencies', gameId, modIds[0], false);
    }, (modIds) => {
        const state = context.api.getState();
        const gameId = vortex_api_1.selectors.activeGameId(state);
        const mod = state.persistent.mods[gameId][modIds[0]];
        if (mod === undefined) {
            return false;
        }
        return (mod.type === constants_1.MOD_TYPE);
    });
    context.registerAction('profile-actions', 150, 'highlight-lab', {}, 'Init Collection', (profileIds) => {
        (0, collectionCreate_1.initFromProfile)(context.api, profileIds[0])
            .catch(err => context.api.showErrorNotification('Failed to init collection', err));
    }, (profileIds) => !profileCollectionExists(context.api, profileIds[0]));
    context.registerAction('profile-actions', 150, 'highlight-lab', {}, 'Update Collection', (profileIds) => {
        (0, collectionCreate_1.initFromProfile)(context.api, profileIds[0])
            .catch(err => context.api.showErrorNotification('Failed to update collection', err));
    }, (profileIds) => profileCollectionExists(context.api, profileIds[0]));
    context.registerAction('mods-action-icons', 300, 'collection', {}, 'Add to Collection...', (instanceIds) => (0, collectionCreate_1.addCollectionAction)(context.api, instanceIds)
        .then(() => collectionChanged.schedule())
        .catch(err => context.api.showErrorNotification('failed to add mod to collection', err)), (instanceIds) => (0, collectionCreate_1.addCollectionCondition)(context.api, instanceIds));
    context.registerAction('mods-multirow-actions', 300, 'collection', {}, 'Add to Collection...', (instanceIds) => (0, collectionCreate_1.addCollectionAction)(context.api, instanceIds)
        .then(() => collectionChanged.schedule())
        .catch(err => context.api.showErrorNotification('failed to add mod to collection', err)), (instanceIds) => (0, collectionCreate_1.addCollectionCondition)(context.api, instanceIds));
    context.registerAction('mods-action-icons', 300, 'collection', {}, 'Remove from Collection...', (instanceIds) => (0, collectionCreate_1.removeCollectionAction)(context.api, instanceIds)
        .then(() => collectionChanged.schedule())
        .catch(err => context.api.showErrorNotification('failed to remove mod from collection', err)), (instanceIds) => (0, collectionCreate_1.removeCollectionCondition)(context.api, instanceIds));
    context.registerAction('mods-multirow-actions', 300, 'collection', {}, 'Remove from Collection...', (instanceIds) => (0, collectionCreate_1.removeCollectionAction)(context.api, instanceIds)
        .then(() => collectionChanged.schedule())
        .catch(err => context.api.showErrorNotification('failed to remove mod from collection', err)), (instanceIds) => (0, collectionCreate_1.removeCollectionCondition)(context.api, instanceIds));
    context.registerAttributeExtractor(100, genAttributeExtractor(context.api));
    context.registerInstaller('collection', 5, (0, util_1.bbProm)(collectionInstall_1.testSupported), (0, util_1.bbProm)((0, collectionInstall_1.makeInstall)(context.api)));
    context['registerCollectionFeature'] =
        (id, generate, parse, clone, title, condition, editComponent) => {
            (0, extension_1.addExtension)({ id, generate, parse, clone, condition, title, editComponent });
        };
    context.registerActionCheck('ADD_NOTIFICATION', (state, action) => {
        var _a, _b, _c;
        const notification = action['payload'];
        const ruleMatches = rule => { var _a; return rule.reference.tag === ((_a = notification.replace) === null || _a === void 0 ? void 0 : _a.tag); };
        let collection;
        if (((driver === null || driver === void 0 ? void 0 : driver.collection) !== undefined) && notification.id.startsWith('multiple-plugins-')) {
            if (driver.profile !== undefined) {
                collection = (_b = (_a = state.persistent.mods[driver.profile.gameId]) === null || _a === void 0 ? void 0 : _a[driver.collection.id]) !== null && _b !== void 0 ? _b : driver.collection;
            }
            else {
                collection = driver.collection;
            }
        }
        if (((_c = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _c !== void 0 ? _c : []).find(ruleMatches) !== undefined) {
            return false;
        }
        return undefined;
    });
}
async function triggerVoteNotification(api, revisionId, collectionSlug, revisionNumber) {
    if ((collectionSlug === undefined) || (revisionNumber === undefined)) {
        return Promise.resolve();
    }
    const revInfo = await driver.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber);
    if (!revInfo) {
        return Promise.resolve();
    }
    const sendRating = async (success) => {
        const vote = success ? 'positive' : 'negative';
        const voted = (await api.emitAndAwait('rate-nexus-collection-revision', parseInt(revisionId, 10), vote))[0];
        if (voted.success) {
            api.store.dispatch((0, persistent_1.updateSuccessRate)(revisionId, vote, voted.averageRating.average, voted.averageRating.total));
        }
    };
    return new Promise((resolve, reject) => {
        api.sendNotification({
            type: 'info',
            message: revInfo.collection.name,
            title: 'Did the Collection work for you?',
            noDismiss: true,
            actions: [
                {
                    title: 'Yes',
                    action: dismiss => {
                        api.events.emit('analytics-track-click-event', 'Notifications', 'Success rating - Yes');
                        sendRating(true);
                        resolve();
                        dismiss();
                    },
                },
                {
                    title: 'No',
                    action: dismiss => {
                        api.events.emit('analytics-track-click-event', 'Notifications', 'Success rating - No');
                        sendRating(false);
                        resolve();
                        dismiss();
                    },
                },
                {
                    icon: 'close',
                    action: dismiss => {
                        api.events.emit('analytics-track-click-event', 'Notifications', 'Success rating - Dismiss');
                        resolve();
                        dismiss();
                    },
                },
            ],
        });
    });
}
async function checkVoteRequest(api) {
    var _a;
    let elapsed = 0;
    const state = api.getState();
    const pendingVotes = (_a = state.persistent['collections'].pendingVotes) !== null && _a !== void 0 ? _a : {};
    const now = Date.now();
    for (const revisionId of Object.keys(pendingVotes)) {
        const pendingInfo = pendingVotes[revisionId];
        if (now - pendingInfo.time >= constants_1.TIME_BEFORE_VOTE) {
            await triggerVoteNotification(api, revisionId, pendingInfo.collectionSlug, pendingInfo.revisionNumber);
            api.store.dispatch((0, persistent_1.clearPendingVote)(revisionId));
        }
        else {
            elapsed = Math.max(elapsed, now - pendingInfo.time);
        }
    }
    return constants_1.TIME_BEFORE_VOTE - elapsed;
}
function once(api, collectionsCB) {
    const { store } = api;
    const applyCollectionModDefaults = new vortex_api_1.util.Debouncer(() => {
        const gameMode = vortex_api_1.selectors.activeGameId(state());
        const mods = vortex_api_1.util.getSafe(state(), ['persistent', 'mods', gameMode], {});
        const collectionIds = Object.keys(mods).filter(id => { var _a; return (((_a = mods[id]) === null || _a === void 0 ? void 0 : _a.type) === constants_1.MOD_TYPE); });
        const redActions = collectionIds.reduce((accum, id) => {
            var _a;
            const collection = mods[id];
            if ((collection === undefined) || (collection.attributes['editable'] !== true)) {
                return accum;
            }
            const collMods = ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
                .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
                .filter(rule => rule !== undefined);
            const action = (0, defaults_1.genDefaultsAction)(api, id, collMods, gameMode);
            if (action !== undefined) {
                accum.push(action);
            }
            return accum;
        }, []);
        if (redActions.length > 0) {
            vortex_api_1.util.batchDispatch(api.store, redActions);
        }
        return null;
    }, 1000);
    driver = new InstallDriver_1.default(api);
    driver.onUpdate(() => {
        if (driver.step === 'start') {
            driver.continue();
        }
        if (driver.step === 'review') {
            if (driver.collection === undefined)
                return;
            const gameId = driver.profile.gameId;
            const modId = driver.collection.id;
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'installCompleted', Date.now()));
        }
    });
    const doCheckVoteRequest = () => {
        checkVoteRequest(api)
            .then((nextCheck) => {
            setTimeout(doCheckVoteRequest, nextCheck);
        });
    };
    setTimeout(doCheckVoteRequest, constants_1.DELAY_FIRST_VOTE_REQUEST);
    api.setStylesheet('collections', path.join(__dirname, 'style.scss'));
    const state = () => store.getState();
    api.onStateChange(['persistent', 'mods'], (prev, cur) => {
        var _a, _b;
        const gameMode = vortex_api_1.selectors.activeGameId(api.getState());
        const prevG = (_a = prev[gameMode]) !== null && _a !== void 0 ? _a : {};
        const curG = (_b = cur[gameMode]) !== null && _b !== void 0 ? _b : {};
        const allIds = Array.from(new Set([].concat(Object.keys(prevG), Object.keys(curG))));
        const collections = allIds.filter(id => { var _a, _b; return (((_a = prevG[id]) === null || _a === void 0 ? void 0 : _a.type) === constants_1.MOD_TYPE) || (((_b = curG[id]) === null || _b === void 0 ? void 0 : _b.type) === constants_1.MOD_TYPE); });
        const changed = collections.find(modId => { var _a, _b, _c, _d; return (((_b = (_a = prevG[modId]) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.customFileName) !== ((_d = (_c = curG[modId]) === null || _c === void 0 ? void 0 : _c.attributes) === null || _d === void 0 ? void 0 : _d.customFileName)); });
        if (changed !== undefined) {
            collectionChangedCB === null || collectionChangedCB === void 0 ? void 0 : collectionChangedCB();
        }
        const foundRuleChanges = collections.find((id) => {
            var _a, _b, _c, _d, _e, _f;
            if (((_a = prevG[id]) === null || _a === void 0 ? void 0 : _a.rules) === ((_b = curG[id]) === null || _b === void 0 ? void 0 : _b.rules)) {
                return false;
            }
            const added = _.difference((_c = curG[id]) === null || _c === void 0 ? void 0 : _c.rules, (_d = prevG[id]) === null || _d === void 0 ? void 0 : _d.rules);
            const removed = _.difference((_e = prevG[id]) === null || _e === void 0 ? void 0 : _e.rules, (_f = curG[id]) === null || _f === void 0 ? void 0 : _f.rules);
            return (removed.length > 0) || (added.find(rule => ['requires', 'recommends'].includes(rule.type)) !== undefined);
        }) !== undefined;
        if (foundRuleChanges) {
            applyCollectionModDefaults.schedule();
            if (changed === undefined) {
                collectionChangedCB === null || collectionChangedCB === void 0 ? void 0 : collectionChangedCB();
            }
        }
    });
    api.events.on('did-dismiss-overlay', (overlayId, itemId) => {
        var _a, _b, _c;
        const OVERLAY_ID = 'collection-instructions-overlay';
        const state = api.getState();
        const { gameId } = (_a = driver.profile) !== null && _a !== void 0 ? _a : {};
        const mods = (_b = state.persistent.mods[gameId]) !== null && _b !== void 0 ? _b : {};
        if ((driver.lastCollection !== undefined)
            && (mods[driver.lastCollection.id] !== undefined)
            && (itemId !== undefined)
            && (state.settings.notifications.suppress[OVERLAY_ID] !== true)) {
            const collections = mods[driver.lastCollection.id];
            const match = ((_c = collections.rules) !== null && _c !== void 0 ? _c : [])
                .find(rule => (rule.type === 'requires') && (rule.reference.tag === itemId));
            if (match !== undefined) {
                api.showDialog('info', 'Mod instructions', {
                    text: 'You can refer back to closed mod instructions at any time in the Instructions tab on '
                        + 'the Collections page.',
                    checkboxes: [
                        { id: 'dont_show_again', value: false, text: 'Don\'t show again' },
                    ],
                }, [
                    { label: 'Take me to instructions' },
                    { label: 'Close' },
                ], OVERLAY_ID)
                    .then((result) => {
                    if (result.input['dont_show_again']) {
                        api.store.dispatch(vortex_api_1.actions.suppressNotification(OVERLAY_ID, true));
                    }
                    if (result.action === 'Take me to instructions') {
                        api.events.emit('show-main-page', 'Collections');
                        setTimeout(() => {
                            var _a, _b;
                            (_b = (_a = collectionsCB()).viewCollection) === null || _b === void 0 ? void 0 : _b.call(_a, driver.lastCollection.id);
                        }, 100);
                    }
                })
                    .catch(err => {
                    (0, vortex_api_1.log)('warn', 'failed to show mod instructions suppress dialog', { error: err.message });
                });
            }
        }
    });
    api.events.on('did-install-mod', async (gameId, archiveId, modId) => {
        var _a, _b, _c;
        const profileId = vortex_api_1.selectors.lastActiveProfileForGame(state(), gameId);
        const profile = vortex_api_1.selectors.profileById(state(), profileId);
        if (profile === undefined) {
            return;
        }
        const mod = vortex_api_1.util.getSafe(state().persistent.mods, [gameId, modId], undefined);
        if (mod === undefined) {
            return;
        }
        if (mod.type === constants_1.MOD_TYPE) {
            if (driver.collection === undefined) {
                const awaitProfileSwitch = (_b = (_a = api.ext) === null || _a === void 0 ? void 0 : _a.awaitProfileSwitch) !== null && _b !== void 0 ? _b : (() => Promise.resolve());
                await awaitProfileSwitch();
                driver.query(profile, mod);
            }
            else {
                api.sendNotification({
                    type: 'info',
                    message: 'Collection can\'t be installed as another one is being installed already',
                });
            }
        }
        else if (driver.collection !== undefined) {
            const { collection, revisionId } = driver;
            const isDependency = ((_c = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _c !== void 0 ? _c : []).find(rule => {
                const validType = ['requires', 'recommends'].includes(rule.type);
                if (!validType) {
                    return false;
                }
                const matchedRule = vortex_api_1.util.testModReference(mod, rule.reference);
                return matchedRule;
            }) !== undefined;
            if (isDependency) {
                const modRules = await driver.infoCache.getCollectionModRules(revisionId, collection, gameId);
                vortex_api_1.util.batchDispatch(api.store, (modRules !== null && modRules !== void 0 ? modRules : []).reduce((prev, rule) => {
                    if (vortex_api_1.util.testModReference(mod, rule.source)) {
                        prev.push(vortex_api_1.actions.addModRule(gameId, modId, {
                            type: rule.type,
                            reference: rule.reference,
                            extra: {
                                fromCollection: collection.id,
                            },
                        }));
                    }
                    return prev;
                }, []));
            }
        }
    });
    api.onAsync('will-remove-mods', makeWillRemoveMods());
    api.onAsync('did-remove-mods', makeDidRemoveMods());
    api.onAsync('unfulfilled-rules', makeOnUnfulfilledRules(api));
    api.events.on('collection-update', (0, eventHandlers_1.onCollectionUpdate)(api, driver));
    api.events.on('did-finish-download', (dlId, outcome) => {
        if (outcome === 'finished') {
            const download = state().persistent.downloads.files[dlId];
            if (download === undefined) {
                return;
            }
        }
    });
    api.events.on('did-download-collection', async (dlId) => {
        var _a, _b, _c;
        try {
            const dlInfo = vortex_api_1.util.getSafe(state().persistent.downloads.files, [dlId], undefined);
            const profile = vortex_api_1.selectors.activeProfile(state());
            if ((profile === undefined) || (dlInfo === undefined)) {
                return;
            }
            if (!dlInfo.game.includes(profile.gameId)) {
                (0, vortex_api_1.log)('info', 'Collection downloaded for a different game than is being managed', { gameMode: profile.gameId, game: dlInfo.game });
                const expectedGame = vortex_api_1.util.getGame(dlInfo.game[0]);
                const actualGame = vortex_api_1.util.getGame(profile.gameId);
                api.sendNotification({
                    message: '"{{collectionName}}" - This collection is intended for {{expectedGame}} '
                        + 'and cannot be installed to {{actualGame}}',
                    type: 'info',
                    replace: {
                        collectionName: (_b = (_a = dlInfo.modInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : dlInfo.localPath,
                        expectedGame: (_c = expectedGame === null || expectedGame === void 0 ? void 0 : expectedGame.name) !== null && _c !== void 0 ? _c : api.translate('an unsupported game'),
                        actualGame: actualGame.name,
                    },
                });
                return;
            }
            else {
                await vortex_api_1.util.toPromise(cb => api.events.emit('start-install-download', dlId, {
                    allowAutoEnable: false,
                }, cb));
            }
        }
        catch (err) {
            if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                api.showErrorNotification('Failed to add collection', err, {
                    allowReport: !(err instanceof vortex_api_1.util.ProcessCanceled),
                });
            }
        }
    });
    api.events.on('view-collection', (modId, tabId) => {
        api.events.emit('show-main-page', 'Collections');
        setTimeout(() => {
            var _a, _b, _c, _d;
            (_b = (_a = collectionsCB()).viewCollection) === null || _b === void 0 ? void 0 : _b.call(_a, modId);
            (_d = (_c = collectionsCB()).viewCollectionTab) === null || _d === void 0 ? void 0 : _d.call(_c, tabId);
        }, 100);
    });
    api.events.on('edit-collection', (modId) => {
        api.events.emit('show-main-page', 'Collections');
        setTimeout(() => {
            var _a, _b;
            (_b = (_a = collectionsCB()).editCollection) === null || _b === void 0 ? void 0 : _b.call(_a, modId);
        }, 100);
    });
    api.events.on('resume-collection', (gameId, modId) => {
        var _a;
        const state = api.getState();
        const profileId = vortex_api_1.selectors.lastActiveProfileForGame(state, gameId);
        const profile = state.persistent.profiles[profileId];
        const mod = (_a = state.persistent.mods[gameId]) === null || _a === void 0 ? void 0 : _a[modId];
        (0, vortex_api_1.log)('info', 'resume collection', { gameId, modId, archiveId: mod === null || mod === void 0 ? void 0 : mod.archiveId });
        driver.start(profile, mod);
    });
    api.onStateChange(['persistent', 'collections', 'collections'], (prev, cur) => {
        const state = api.getState();
        const changedIds = Object.keys(cur).filter(id => { var _a; return cur[id].info !== ((_a = prev[id]) === null || _a === void 0 ? void 0 : _a.info); });
        const knownGames = vortex_api_1.selectors.knownGames(state);
        const { mods } = state.persistent;
        changedIds.forEach(collId => {
            const coll = cur[collId].info;
            const gameId = vortex_api_1.util.convertGameIdReverse(knownGames, coll.game.domainName);
            const collModId = Object.keys(mods[gameId])
                .find(modId => mods[gameId][modId].attributes['collectionId'] === coll.id);
            if ((collModId !== undefined) && !mods[gameId][collModId].attributes.editable) {
                const newestVersion = coll.revisions
                    .filter(rev => rev.revisionStatus === 'published')
                    .sort((lhs, rhs) => rhs.revisionNumber - lhs.revisionNumber);
                if (newestVersion.length > 0) {
                    api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, collModId, 'newestVersion', newestVersion[0].revisionNumber.toString()));
                }
            }
        });
    });
    vortex_api_1.util.installIconSet('collections', path.join(__dirname, 'icons.svg'))
        .catch(err => api.showErrorNotification('failed to install icon set', err));
    const iconPath = path.join(__dirname, 'collectionicon.svg');
    document.getElementById('content').style
        .setProperty('--collection-icon', `url(${(0, url_1.pathToFileURL)(iconPath).href})`);
    const updateOwnCollectionsCB = (gameId) => api.emitAndAwait('get-my-collections', gameId)
        .then(result => {
        var _a;
        localState.ownCollections = (_a = result[0]) !== null && _a !== void 0 ? _a : [];
    });
    api.events.on('gamemode-activated', updateOwnCollectionsCB);
    api.onStateChange(['persistent', 'nexus', 'userInfo'], (prev, cur) => {
        const gameMode = vortex_api_1.selectors.activeGameId(api.getState());
        updateOwnCollectionsCB(gameMode);
    });
    driver.infoCache.clearCache();
}
const pathTool = {
    relative: path.relative,
};
function init(context) {
    const collectionsCB = {};
    register(context, collectionsCB);
    (0, initweaks_1.default)(context);
    (0, tools_1.default)(context);
    context.once(() => {
        once(context.api, () => collectionsCB);
    });
    return true;
}
exports["default"] = init;

})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=bundledPlugins/collections/modpacks.js.map