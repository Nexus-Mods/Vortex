{"version":3,"file":"index.js","mappings":";;;;;;;;;;AAAa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,mBAAO,CAAC,0BAAU;AACrD,0BAA0B,mBAAO,CAAC,kBAAM;AACxC,qBAAqB,mBAAO,CAAC,8BAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8BAA8B;AAC/D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI,WAAW;AACpB;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ,+BAA+B,OAAO,MAAM,WAAW,iBAAiB;AAC7H,4BAA4B,OAAO,SAAS,OAAO;AACnD,SAAS;AACT;AACA;AACA;AACA,sBAAsB,4BAA4B,EAAE,UAAU;AAC9D,uBAAuB,yBAAyB;AAChD,KAAK;AACL;AACA;AACA;AACA,qFAAqF,UAAU;AAC/F,yFAAyF,WAAW,YAAY;AAChH,qBAAqB,mBAAmB;AACxC,oHAAoH,UAAU;AAC9H;AACA,wDAAwD,MAAM,UAAU,KAAK,OAAO,WAAW,iEAAiE;AAChK,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,oEAAoE,kBAAkB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,kBAAe;;;;;;;;;;;ACpQf,qC;;;;;;;;;;ACAA,iC;;;;;;;;;;ACAA,uC;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://gamebryo-archive-check/./src/index.ts","webpack://gamebryo-archive-check/external commonjs2 \"bluebird\"","webpack://gamebryo-archive-check/external commonjs2 \"path\"","webpack://gamebryo-archive-check/external commonjs2 \"vortex-api\"","webpack://gamebryo-archive-check/webpack/bootstrap","webpack://gamebryo-archive-check/webpack/before-startup","webpack://gamebryo-archive-check/webpack/startup","webpack://gamebryo-archive-check/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bluebird_1 = __importDefault(require(\"bluebird\"));\nconst path = __importStar(require(\"path\"));\nconst vortex_api_1 = require(\"vortex-api\");\nconst archiveData = [\n    {\n        gameId: 'skyrim',\n        gameName: 'Skyrim (2011)',\n        version: [104, 103],\n        type: 'BSA',\n    },\n    {\n        gameId: 'skyrimse',\n        gameName: 'Skyrim Special Edition',\n        version: [105],\n        type: 'BSA',\n    },\n    {\n        gameId: 'skyrimvr',\n        gameName: 'Skyrim VR',\n        version: [105],\n        type: 'BSA',\n    },\n    {\n        gameId: 'oblivion',\n        gameName: 'Oblivion',\n        version: [103],\n        type: 'BSA',\n    },\n    {\n        gameId: 'fallout3',\n        gameName: 'Fallout 3',\n        version: [104],\n        type: 'BSA',\n    },\n    {\n        gameId: 'newvegas',\n        gameName: 'Fallout New Vegas',\n        version: [104],\n        type: 'BSA',\n    },\n    {\n        gameId: 'fallout4',\n        gameName: 'Fallout 4',\n        version: [8, 7, 1],\n        type: 'BA2',\n    },\n    {\n        gameId: 'fallout4vr',\n        gameName: 'Fallout 4 VR',\n        version: [1],\n        type: 'BA2',\n    },\n    {\n        gameId: 'fallout76',\n        gameName: 'Fallout 76',\n        version: [1],\n        type: 'BA2',\n    },\n    {\n        gameId: 'starfield',\n        gameName: 'Starfield',\n        version: [3, 2, 1],\n        type: 'BA2',\n    },\n];\nfunction runTest(context) {\n    const state = context.api.getState();\n    const plugInfo = vortex_api_1.util.getSafe(state, ['session', 'plugins', 'pluginInfo'], {});\n    return checkForErrors(context.api, plugInfo);\n}\nfunction main(context) {\n    context.requireExtension('gamebryo-plugin-management');\n    context.registerTest('incompatible-mod-archives', 'plugins-changed', () => runTest(context));\n    return true;\n}\nfunction checkForErrors(api, pluginsObj) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const state = api.getState();\n        const activeGameId = vortex_api_1.selectors.activeGameId(state);\n        const gameData = archiveData.find(g => g.gameId === activeGameId);\n        if (!gameData) {\n            return bluebird_1.default.resolve(undefined);\n        }\n        if (!pluginsObj || !Object.keys(pluginsObj)) {\n            return bluebird_1.default.resolve(undefined);\n        }\n        const plugins = Object.keys(pluginsObj)\n            .map(k => pluginsObj[k])\n            .sort((a, b) => a.loadOrder > b.loadOrder ? 1 : -1);\n        const archiveLoaders = plugins.filter(p => !p.isNative\n            && p.loadsArchive\n            && vortex_api_1.util.getSafe(state, ['loadOrder', p.id, 'enabled'], false));\n        const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', activeGameId], {});\n        const discovery = vortex_api_1.util.getSafe(state, ['settings', 'gameMode', 'discovered', activeGameId, 'path'], undefined);\n        const dataFolder = discovery ? path.join(discovery, 'data') : undefined;\n        const normalize = (fileName) => {\n            const noExt = path.basename(fileName, path.extname(fileName)).toLowerCase();\n            return noExt.normalize('NFC');\n        };\n        const checkNotifId = 'checking-archives-all';\n        try {\n            const dataFiles = yield vortex_api_1.fs.readdirAsync(dataFolder);\n            const dataArchives = dataFiles.filter(f => ['.ba2', '.bsa'].includes(path.extname(f)));\n            const archivesToCheck = archiveLoaders.reduce((accum, plugin) => {\n                const arcs = dataArchives\n                    .filter(a => normalize(a).startsWith(normalize(plugin.name)))\n                    .map(a => ({ name: a, plugin: plugin.name }));\n                accum = accum.concat(arcs);\n                return accum;\n            }, []);\n            if (!archivesToCheck.length) {\n                return bluebird_1.default.resolve(undefined);\n            }\n            let pos = 0;\n            const progress = (archiveName) => {\n                api.store.dispatch(vortex_api_1.actions.addNotification({\n                    id: checkNotifId,\n                    progress: (pos * 100) / archivesToCheck.length,\n                    title: 'Checking archives',\n                    message: archiveName,\n                    type: 'activity',\n                }));\n                ++pos;\n            };\n            const issues = yield archivesToCheck.reduce((accumP, archive) => __awaiter(this, void 0, void 0, function* () {\n                const accum = yield accumP;\n                progress(archive.name);\n                try {\n                    const version = yield streamArchiveVersion(path.join(dataFolder, archive.name));\n                    if (gameData.version.includes(version)) {\n                        return accum;\n                    }\n                    const plugin = plugins.find(p => p.name === archive.plugin);\n                    const mod = plugin ? mods[plugin.modId] : undefined;\n                    accum.push({\n                        name: archive.name,\n                        version,\n                        validVersion: gameData.version.join('/'),\n                        plugin,\n                        mod,\n                    });\n                    return accum;\n                }\n                catch (err) {\n                    (0, vortex_api_1.log)('error', 'Error checking archive versions', err);\n                    return accum;\n                }\n            }), Promise.resolve([]));\n            api.dismissNotification(checkNotifId);\n            return ((issues === null || issues === void 0 ? void 0 : issues.length) > 0)\n                ? genTestResult(api, issues, gameData)\n                : bluebird_1.default.resolve(undefined);\n        }\n        catch (err) {\n            api.dismissNotification(checkNotifId);\n            api.showErrorNotification('Error checking for archive errors', err);\n            return bluebird_1.default.resolve(undefined);\n        }\n    });\n}\nfunction genTestResult(api, issues, gameData) {\n    const t = api.translate;\n    const thisGame = gameData.gameName;\n    const groupedErrors = issues.reduce((accum, cur) => {\n        if (cur.mod) {\n            accum[cur.mod.id] = [].concat(accum[cur.mod.id] || [], cur);\n        }\n        else {\n            accum.noMod.push(cur);\n        }\n        return accum;\n    }, { noMod: [] });\n    const errorsByMod = Object.keys(groupedErrors).map(key => {\n        const group = groupedErrors[key];\n        const mod = key !== 'noMod' ? group[0].mod : { id: '', attributes: {} };\n        const attr = mod.attributes;\n        const modName = attr.customName || attr.logicalFileName || attr.name || mod.id;\n        if (!group.length) {\n            return '';\n        }\n        const archiveErrors = group.map(a => {\n            const games = archiveData\n                .filter(g => g.version.includes(a.version[0]))\n                .map(g => g.gameName).join('/') || t('an unknown game');\n            const plugin = a.plugin.name;\n            const errMsg = t('Is loaded by {{plugin}}, but is intended for use in {{games}}.', { replace: { plugin, games } });\n            return `[*][b]${a.name}[/b] - ${errMsg}`;\n        });\n        const groupInfo = modName\n            ? modName\n            : t('not managed by Vortex');\n        return `[h5]${t('Incompatible Archives')} ${groupInfo}:[/h5]`\n            + `[list]${archiveErrors.join('\\n')}[/list]<br/><br/>`;\n    });\n    return bluebird_1.default.resolve({\n        description: {\n            short: 'Incompatible mod archive(s)',\n            long: t('Some of the archives in your load order are incompatible with {{thisGame}}. '\n                + 'Using incompatible archives may cause your game to crash on load.', { replace: { thisGame } })\n                + `${errorsByMod.join()}`\n                + t('You can fix this problem yourself by removing any mods that are not intended to be used with {{thisGame}}. '\n                    + 'If you downloaded these mods from the correct game site at Nexus Mods, you should inform the mod author of this issue. '\n                    + 'Archives for this game must be {{ext}} files (v{{ver}}).', { replace: { thisGame, ext: gameData.type, ver: gameData.version.join('/') } }),\n        },\n        severity: 'error',\n    });\n}\nfunction streamArchiveVersion(filePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const stream = vortex_api_1.fs.createReadStream(filePath, { start: 0, end: 8 });\n        return new Promise((resolve, reject) => {\n            const data = Buffer.alloc(9);\n            stream.on('data', chunk => {\n                data.fill(chunk);\n                const versionBytes = data.slice(4, 8);\n                const version = versionBytes.reduce((accum, entry) => accum += entry, 0);\n                resolve(version);\n            });\n            stream.on('error', () => resolve(0));\n        })\n            .finally(() => stream.destroy());\n    });\n}\nexports.default = main;\n","module.exports = require(\"bluebird\");","module.exports = require(\"path\");","module.exports = require(\"vortex-api\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":[],"sourceRoot":""}