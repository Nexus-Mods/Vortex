/******/ (() => { // webpackBootstrap
/******/ 	const __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray/index.js ***!
  \***********************************************************************/
/***/ ((module) => {

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }

      module.exports = _arrayLikeToArray;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }

      module.exports = _arrayWithHoles;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      const arrayLikeToArray = __webpack_require__(/*! @babel/runtime/helpers/arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray/index.js");

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return arrayLikeToArray(arr);
      }

      module.exports = _arrayWithoutHoles;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js ***!
  \****************************************************************************/
/***/ ((module) => {

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      module.exports = _assertThisInitialized;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      module.exports = _classCallCheck;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass/index.js ***!
  \******************************************************************/
/***/ ((module) => {

      function _defineProperties(target, props) {
        for (let i = 0; i < props.length; i++) {
          const descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      module.exports = _createClass;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      module.exports = _defineProperty;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/extends/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/extends/index.js ***!
  \**************************************************************/
/***/ ((module) => {

      function _extends() {
        module.exports = _extends = Object.assign || function (target) {
          for (let i = 1; i < arguments.length; i++) {
            const source = arguments[i];

            for (const key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        };

        module.exports["default"] = module.exports, module.exports.__esModule = true;
        return _extends.apply(this, arguments);
      }

      module.exports = _extends;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

      function _getPrototypeOf(o) {
        module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        module.exports["default"] = module.exports, module.exports.__esModule = true;
        return _getPrototypeOf(o);
      }

      module.exports = _getPrototypeOf;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      const setPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf/index.js");

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) setPrototypeOf(subClass, superClass);
      }

      module.exports = _inherits;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray/index.js ***!
  \**********************************************************************/
/***/ ((module) => {

      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
      }

      module.exports = _iterableToArray;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit/index.js ***!
  \***************************************************************************/
/***/ ((module) => {

      function _iterableToArrayLimit(arr, i) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
        const _arr = [];
        let _n = true;
        let _d = false;
        let _e = undefined;

        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }

        return _arr;
      }

      module.exports = _iterableToArrayLimit;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest/index.js ***!
  \**********************************************************************/
/***/ ((module) => {

      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      module.exports = _nonIterableRest;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread/index.js ***!
  \************************************************************************/
/***/ ((module) => {

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      module.exports = _nonIterableSpread;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutProperties/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectWithoutProperties/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      const objectWithoutPropertiesLoose = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose/index.js");

      function _objectWithoutProperties(source, excluded) {
        if (source == null) return {};
        const target = objectWithoutPropertiesLoose(source, excluded);
        let key, i;

        if (Object.getOwnPropertySymbols) {
          const sourceSymbolKeys = Object.getOwnPropertySymbols(source);

          for (i = 0; i < sourceSymbolKeys.length; i++) {
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
          }
        }

        return target;
      }

      module.exports = _objectWithoutProperties;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose/index.js ***!
  \***********************************************************************************/
/***/ ((module) => {

      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null) return {};
        const target = {};
        const sourceKeys = Object.keys(source);
        let key, i;

        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          target[key] = source[key];
        }

        return target;
      }

      module.exports = _objectWithoutPropertiesLoose;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      const _typeof = (__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof/index.js")["default"]);

      const assertThisInitialized = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return assertThisInitialized(self);
      }

      module.exports = _possibleConstructorReturn;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

      function _setPrototypeOf(o, p) {
        module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        module.exports["default"] = module.exports, module.exports.__esModule = true;
        return _setPrototypeOf(o, p);
      }

      module.exports = _setPrototypeOf;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      const arrayWithHoles = __webpack_require__(/*! @babel/runtime/helpers/arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles/index.js");

      const iterableToArrayLimit = __webpack_require__(/*! @babel/runtime/helpers/iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit/index.js");

      const unsupportedIterableToArray = __webpack_require__(/*! @babel/runtime/helpers/unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray/index.js");

      const nonIterableRest = __webpack_require__(/*! @babel/runtime/helpers/nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest/index.js");

      function _slicedToArray(arr, i) {
        return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
      }

      module.exports = _slicedToArray;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      const arrayWithoutHoles = __webpack_require__(/*! @babel/runtime/helpers/arrayWithoutHoles */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles/index.js");

      const iterableToArray = __webpack_require__(/*! @babel/runtime/helpers/iterableToArray */ "./node_modules/@babel/runtime/helpers/iterableToArray/index.js");

      const unsupportedIterableToArray = __webpack_require__(/*! @babel/runtime/helpers/unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray/index.js");

      const nonIterableSpread = __webpack_require__(/*! @babel/runtime/helpers/nonIterableSpread */ "./node_modules/@babel/runtime/helpers/nonIterableSpread/index.js");

      function _toConsumableArray(arr) {
        return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
      }

      module.exports = _toConsumableArray;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof/index.js ***!
  \*************************************************************/
/***/ ((module) => {

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          module.exports = _typeof = function _typeof(obj) {
            return typeof obj;
          };

          module.exports["default"] = module.exports, module.exports.__esModule = true;
        } else {
          module.exports = _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };

          module.exports["default"] = module.exports, module.exports.__esModule = true;
        }

        return _typeof(obj);
      }

      module.exports = _typeof;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray/index.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      const arrayLikeToArray = __webpack_require__(/*! @babel/runtime/helpers/arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray/index.js");

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return arrayLikeToArray(o, minLen);
        let n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
      }

      module.exports = _unsupportedIterableToArray;
      module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/clsx/dist/clsx.m.js":
/*!******************************************!*\
  !*** ./node_modules/clsx/dist/clsx.m.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
      function toVal(mix) {
        let k, y, str='';

        if (typeof mix === 'string' || typeof mix === 'number') {
          str += mix;
        } else if (typeof mix === 'object') {
          if (Array.isArray(mix)) {
            for (k=0; k < mix.length; k++) {
              if (mix[k]) {
                if (y = toVal(mix[k])) {
                  str && (str += ' ');
                  str += y;
                }
              }
            }
          } else {
            for (k in mix) {
              if (mix[k]) {
                str && (str += ' ');
                str += k;
              }
            }
          }
        }

        return str;
      }

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
        let i=0, tmp, x, str='';
        while (i < arguments.length) {
          if (tmp = arguments[i++]) {
            if (x = toVal(tmp)) {
              str && (str += ' ');
              str += x
            }
          }
        }
        return str;
      }


/***/ }),

/***/ "./node_modules/cose-base/cose-base.js":
/*!*********************************************!*\
  !*** ./node_modules/cose-base/cose-base.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

      (function webpackUniversalModuleDefinition(root, factory) {
        if(true)
          module.exports = factory(__webpack_require__(/*! layout-base */ "./node_modules/layout-base/layout-base.js"));
        else {}
      })(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {
        return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	const installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_643__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		const module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_643__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_643__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_643__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__nested_webpack_require_643__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_643__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_643__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_643__.n = function(module) {
/******/ 		const getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_643__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_643__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_643__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_643__(__nested_webpack_require_643__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

            module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_3185__) {

            "use strict";


            const FDLayoutConstants = __nested_webpack_require_3185__(0).FDLayoutConstants;

            function CoSEConstants() {}

//CoSEConstants inherits static props in FDLayoutConstants
            for (const prop in FDLayoutConstants) {
              CoSEConstants[prop] = FDLayoutConstants[prop];
            }

            CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;
            CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;
            CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;
            CoSEConstants.TILE = true;
            CoSEConstants.TILING_PADDING_VERTICAL = 10;
            CoSEConstants.TILING_PADDING_HORIZONTAL = 10;
            CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout

            module.exports = CoSEConstants;

/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_4002__) {

            "use strict";


            const FDLayoutEdge = __nested_webpack_require_4002__(0).FDLayoutEdge;

            function CoSEEdge(source, target, vEdge) {
              FDLayoutEdge.call(this, source, target, vEdge);
            }

            CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);
            for (const prop in FDLayoutEdge) {
              CoSEEdge[prop] = FDLayoutEdge[prop];
            }

            module.exports = CoSEEdge;

/***/ }),
/* 3 */
/***/ (function(module, exports, __nested_webpack_require_4409__) {

            "use strict";


            const LGraph = __nested_webpack_require_4409__(0).LGraph;

            function CoSEGraph(parent, graphMgr, vGraph) {
              LGraph.call(this, parent, graphMgr, vGraph);
            }

            CoSEGraph.prototype = Object.create(LGraph.prototype);
            for (const prop in LGraph) {
              CoSEGraph[prop] = LGraph[prop];
            }

            module.exports = CoSEGraph;

/***/ }),
/* 4 */
/***/ (function(module, exports, __nested_webpack_require_4790__) {

            "use strict";


            const LGraphManager = __nested_webpack_require_4790__(0).LGraphManager;

            function CoSEGraphManager(layout) {
              LGraphManager.call(this, layout);
            }

            CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);
            for (const prop in LGraphManager) {
              CoSEGraphManager[prop] = LGraphManager[prop];
            }

            module.exports = CoSEGraphManager;

/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_5205__) {

            "use strict";


            const FDLayoutNode = __nested_webpack_require_5205__(0).FDLayoutNode;
            const IMath = __nested_webpack_require_5205__(0).IMath;

            function CoSENode(gm, loc, size, vNode) {
              FDLayoutNode.call(this, gm, loc, size, vNode);
            }

            CoSENode.prototype = Object.create(FDLayoutNode.prototype);
            for (const prop in FDLayoutNode) {
              CoSENode[prop] = FDLayoutNode[prop];
            }

            CoSENode.prototype.move = function () {
              const layout = this.graphManager.getLayout();
              this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;
              this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;

              if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {
                this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);
              }

              if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {
                this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);
              }

  // a simple node, just move it
              if (this.child == null) {
                this.moveBy(this.displacementX, this.displacementY);
              }
  // an empty compound node, again just move it
              else if (this.child.getNodes().length == 0) {
                this.moveBy(this.displacementX, this.displacementY);
              }
    // non-empty compound node, propogate movement to children as well
              else {
                this.propogateDisplacementToChildren(this.displacementX, this.displacementY);
              }

              layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);

              this.springForceX = 0;
              this.springForceY = 0;
              this.repulsionForceX = 0;
              this.repulsionForceY = 0;
              this.gravitationForceX = 0;
              this.gravitationForceY = 0;
              this.displacementX = 0;
              this.displacementY = 0;
            };

            CoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {
              const nodes = this.getChild().getNodes();
              let node;
              for (let i = 0; i < nodes.length; i++) {
                node = nodes[i];
                if (node.getChild() == null) {
                  node.moveBy(dX, dY);
                  node.displacementX += dX;
                  node.displacementY += dY;
                } else {
                  node.propogateDisplacementToChildren(dX, dY);
                }
              }
            };

            CoSENode.prototype.setPred1 = function (pred1) {
              this.pred1 = pred1;
            };

            CoSENode.prototype.getPred1 = function () {
              return pred1;
            };

            CoSENode.prototype.getPred2 = function () {
              return pred2;
            };

            CoSENode.prototype.setNext = function (next) {
              this.next = next;
            };

            CoSENode.prototype.getNext = function () {
              return next;
            };

            CoSENode.prototype.setProcessed = function (processed) {
              this.processed = processed;
            };

            CoSENode.prototype.isProcessed = function () {
              return processed;
            };

            module.exports = CoSENode;

/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_8085__) {

            "use strict";


            const FDLayout = __nested_webpack_require_8085__(0).FDLayout;
            const CoSEGraphManager = __nested_webpack_require_8085__(4);
            const CoSEGraph = __nested_webpack_require_8085__(3);
            const CoSENode = __nested_webpack_require_8085__(5);
            const CoSEEdge = __nested_webpack_require_8085__(2);
            const CoSEConstants = __nested_webpack_require_8085__(1);
            const FDLayoutConstants = __nested_webpack_require_8085__(0).FDLayoutConstants;
            const LayoutConstants = __nested_webpack_require_8085__(0).LayoutConstants;
            const Point = __nested_webpack_require_8085__(0).Point;
            const PointD = __nested_webpack_require_8085__(0).PointD;
            const Layout = __nested_webpack_require_8085__(0).Layout;
            const Integer = __nested_webpack_require_8085__(0).Integer;
            const IGeometry = __nested_webpack_require_8085__(0).IGeometry;
            const LGraph = __nested_webpack_require_8085__(0).LGraph;
            const Transform = __nested_webpack_require_8085__(0).Transform;

            function CoSELayout() {
              FDLayout.call(this);

              this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled
            }

            CoSELayout.prototype = Object.create(FDLayout.prototype);

            for (const prop in FDLayout) {
              CoSELayout[prop] = FDLayout[prop];
            }

            CoSELayout.prototype.newGraphManager = function () {
              const gm = new CoSEGraphManager(this);
              this.graphManager = gm;
              return gm;
            };

            CoSELayout.prototype.newGraph = function (vGraph) {
              return new CoSEGraph(null, this.graphManager, vGraph);
            };

            CoSELayout.prototype.newNode = function (vNode) {
              return new CoSENode(this.graphManager, vNode);
            };

            CoSELayout.prototype.newEdge = function (vEdge) {
              return new CoSEEdge(null, null, vEdge);
            };

            CoSELayout.prototype.initParameters = function () {
              FDLayout.prototype.initParameters.call(this, arguments);
              if (!this.isSubLayout) {
                if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {
                  this.idealEdgeLength = 10;
                } else {
                  this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;
                }

                this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;
                this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;
                this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;
                this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;
                this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;
                this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;
                this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;

    // variables for tree reduction support
                this.prunedNodesAll = [];
                this.growTreeIterations = 0;
                this.afterGrowthIterations = 0;
                this.isTreeGrowing = false;
                this.isGrowthFinished = false;

    // variables for cooling
                this.coolingCycle = 0;
                this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;
                this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;
                this.coolingAdjuster = 1;
              }
            };

            CoSELayout.prototype.layout = function () {
              const createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;
              if (createBendsAsNeeded) {
                this.createBendpoints();
                this.graphManager.resetAllEdges();
              }

              this.level = 0;
              return this.classicLayout();
            };

            CoSELayout.prototype.classicLayout = function () {
              this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();
              this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);
              this.calcNoOfChildrenForAllNodes();
              this.graphManager.calcLowestCommonAncestors();
              this.graphManager.calcInclusionTreeDepths();
              this.graphManager.getRoot().calcEstimatedSize();
              this.calcIdealEdgeLengths();

              if (!this.incremental) {
                const forest = this.getFlatForest();

    // The graph associated with this layout is flat and a forest
                if (forest.length > 0) {
                  this.positionNodesRadially(forest);
                }
    // The graph associated with this layout is not flat or a forest
                else {
        // Reduce the trees when incremental mode is not enabled and graph is not a forest 
                  this.reduceTrees();
        // Update nodes that gravity will be applied
                  this.graphManager.resetAllNodesToApplyGravitation();
                  var allNodes = new Set(this.getAllNodes());
                  var intersection = this.nodesWithGravity.filter(function (x) {
                    return allNodes.has(x);
                  });
                  this.graphManager.setAllNodesToApplyGravitation(intersection);

                  this.positionNodesRandomly();
                }
              } else {
                if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {
      // Reduce the trees in incremental mode if only this constant is set to true 
                  this.reduceTrees();
      // Update nodes that gravity will be applied
                  this.graphManager.resetAllNodesToApplyGravitation();
                  var allNodes = new Set(this.getAllNodes());
                  var intersection = this.nodesWithGravity.filter(function (x) {
                    return allNodes.has(x);
                  });
                  this.graphManager.setAllNodesToApplyGravitation(intersection);
                }
              }

              this.initSpringEmbedder();
              this.runSpringEmbedder();

              return true;
            };

            CoSELayout.prototype.tick = function () {
              this.totalIterations++;

              if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {
                if (this.prunedNodesAll.length > 0) {
                  this.isTreeGrowing = true;
                } else {
                  return true;
                }
              }

              if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {
                if (this.isConverged()) {
                  if (this.prunedNodesAll.length > 0) {
                    this.isTreeGrowing = true;
                  } else {
                    return true;
                  }
                }

                this.coolingCycle++;

                if (this.layoutQuality == 0) {
      // quality - "draft"
                  this.coolingAdjuster = this.coolingCycle;
                } else if (this.layoutQuality == 1) {
      // quality - "default"
                  this.coolingAdjuster = this.coolingCycle / 3;
                }

    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3
                this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);
                this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));
              }
  // Operations while tree is growing again 
              if (this.isTreeGrowing) {
                if (this.growTreeIterations % 10 == 0) {
                  if (this.prunedNodesAll.length > 0) {
                    this.graphManager.updateBounds();
                    this.updateGrid();
                    this.growTree(this.prunedNodesAll);
        // Update nodes that gravity will be applied
                    this.graphManager.resetAllNodesToApplyGravitation();
                    const allNodes = new Set(this.getAllNodes());
                    const intersection = this.nodesWithGravity.filter(function (x) {
                      return allNodes.has(x);
                    });
                    this.graphManager.setAllNodesToApplyGravitation(intersection);

                    this.graphManager.updateBounds();
                    this.updateGrid();
                    this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;
                  } else {
                    this.isTreeGrowing = false;
                    this.isGrowthFinished = true;
                  }
                }
                this.growTreeIterations++;
              }
  // Operations after growth is finished
              if (this.isGrowthFinished) {
                if (this.isConverged()) {
                  return true;
                }
                if (this.afterGrowthIterations % 10 == 0) {
                  this.graphManager.updateBounds();
                  this.updateGrid();
                }
                this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);
                this.afterGrowthIterations++;
              }

              const gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;
              const forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;

              this.totalDisplacement = 0;
              this.graphManager.updateBounds();
              this.calcSpringForces();
              this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);
              this.calcGravitationalForces();
              this.moveNodes();
              this.animate();

              return false; // Layout is not ended yet return false
            };

            CoSELayout.prototype.getPositionsData = function () {
              const allNodes = this.graphManager.getAllNodes();
              const pData = {};
              for (let i = 0; i < allNodes.length; i++) {
                const rect = allNodes[i].rect;
                const id = allNodes[i].id;
                pData[id] = {
                  id: id,
                  x: rect.getCenterX(),
                  y: rect.getCenterY(),
                  w: rect.width,
                  h: rect.height
                };
              }

              return pData;
            };

            CoSELayout.prototype.runSpringEmbedder = function () {
              this.initialAnimationPeriod = 25;
              this.animationPeriod = this.initialAnimationPeriod;
              let layoutEnded = false;

  // If aminate option is 'during' signal that layout is supposed to start iterating
              if (FDLayoutConstants.ANIMATE === 'during') {
                this.emit('layoutstarted');
              } else {
    // If aminate option is 'during' tick() function will be called on index.js
                while (!layoutEnded) {
                  layoutEnded = this.tick();
                }

                this.graphManager.updateBounds();
              }
            };

            CoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {
              let nodeList = [];
              let graph;

              const graphs = this.graphManager.getGraphs();
              const size = graphs.length;
              let i;
              for (i = 0; i < size; i++) {
                graph = graphs[i];

                graph.updateConnected();

                if (!graph.isConnected) {
                  nodeList = nodeList.concat(graph.getNodes());
                }
              }

              return nodeList;
            };

            CoSELayout.prototype.createBendpoints = function () {
              let edges = [];
              edges = edges.concat(this.graphManager.getAllEdges());
              const visited = new Set();
              let i;
              for (i = 0; i < edges.length; i++) {
                const edge = edges[i];

                if (!visited.has(edge)) {
                  const source = edge.getSource();
                  const target = edge.getTarget();

                  if (source == target) {
                    edge.getBendpoints().push(new PointD());
                    edge.getBendpoints().push(new PointD());
                    this.createDummyNodesForBendpoints(edge);
                    visited.add(edge);
                  } else {
                    let edgeList = [];

                    edgeList = edgeList.concat(source.getEdgeListToNode(target));
                    edgeList = edgeList.concat(target.getEdgeListToNode(source));

                    if (!visited.has(edgeList[0])) {
                      if (edgeList.length > 1) {
                        var k;
                        for (k = 0; k < edgeList.length; k++) {
                          const multiEdge = edgeList[k];
                          multiEdge.getBendpoints().push(new PointD());
                          this.createDummyNodesForBendpoints(multiEdge);
                        }
                      }
                      edgeList.forEach(function (edge) {
                        visited.add(edge);
                      });
                    }
                  }
                }

                if (visited.size == edges.length) {
                  break;
                }
              }
            };

            CoSELayout.prototype.positionNodesRadially = function (forest) {
  // We tile the trees to a grid row by row; first tree starts at (0,0)
              const currentStartingPoint = new Point(0, 0);
              const numberOfColumns = Math.ceil(Math.sqrt(forest.length));
              let height = 0;
              let currentY = 0;
              let currentX = 0;
              let point = new PointD(0, 0);

              for (let i = 0; i < forest.length; i++) {
                if (i % numberOfColumns == 0) {
      // Start of a new row, make the x coordinate 0, increment the
      // y coordinate with the max height of the previous row
                  currentX = 0;
                  currentY = height;

                  if (i != 0) {
                    currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;
                  }

                  height = 0;
                }

                const tree = forest[i];

    // Find the center of the tree
                const centerNode = Layout.findCenterOfTree(tree);

    // Set the staring point of the next tree
                currentStartingPoint.x = currentX;
                currentStartingPoint.y = currentY;

    // Do a radial layout starting with the center
                point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);

                if (point.y > height) {
                  height = Math.floor(point.y);
                }

                currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);
              }

              this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));
            };

            CoSELayout.radialLayout = function (tree, centerNode, startingPoint) {
              const radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);
              CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);
              const bounds = LGraph.calculateBounds(tree);

              const transform = new Transform();
              transform.setDeviceOrgX(bounds.getMinX());
              transform.setDeviceOrgY(bounds.getMinY());
              transform.setWorldOrgX(startingPoint.x);
              transform.setWorldOrgY(startingPoint.y);

              for (let i = 0; i < tree.length; i++) {
                const node = tree[i];
                node.transform(transform);
              }

              const bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());

              return transform.inverseTransformPoint(bottomRight);
            };

            CoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {
  // First, position this node by finding its angle.
              let halfInterval = (endAngle - startAngle + 1) / 2;

              if (halfInterval < 0) {
                halfInterval += 180;
              }

              const nodeAngle = (halfInterval + startAngle) % 360;
              const teta = nodeAngle * IGeometry.TWO_PI / 360;

  // Make polar to java cordinate conversion.
              const cos_teta = Math.cos(teta);
              const x_ = distance * Math.cos(teta);
              const y_ = distance * Math.sin(teta);

              node.setCenter(x_, y_);

  // Traverse all neighbors of this node and recursively call this
  // function.
              let neighborEdges = [];
              neighborEdges = neighborEdges.concat(node.getEdges());
              let childCount = neighborEdges.length;

              if (parentOfNode != null) {
                childCount--;
              }

              let branchCount = 0;

              let incEdgesCount = neighborEdges.length;
              let startIndex;

              const edges = node.getEdgesBetween(parentOfNode);

  // If there are multiple edges, prune them until there remains only one
  // edge.
              while (edges.length > 1) {
    //neighborEdges.remove(edges.remove(0));
                const temp = edges[0];
                edges.splice(0, 1);
                const index = neighborEdges.indexOf(temp);
                if (index >= 0) {
                  neighborEdges.splice(index, 1);
                }
                incEdgesCount--;
                childCount--;
              }

              if (parentOfNode != null) {
    //assert edges.length == 1;
                startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;
              } else {
                startIndex = 0;
              }

              const stepAngle = Math.abs(endAngle - startAngle) / childCount;

              for (let i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {
                const currentNeighbor = neighborEdges[i].getOtherEnd(node);

    // Don't back traverse to root node in current tree.
                if (currentNeighbor == parentOfNode) {
                  continue;
                }

                const childStartAngle = (startAngle + branchCount * stepAngle) % 360;
                const childEndAngle = (childStartAngle + stepAngle) % 360;

                CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);

                branchCount++;
              }
            };

            CoSELayout.maxDiagonalInTree = function (tree) {
              let maxDiagonal = Integer.MIN_VALUE;

              for (let i = 0; i < tree.length; i++) {
                const node = tree[i];
                const diagonal = node.getDiagonal();

                if (diagonal > maxDiagonal) {
                  maxDiagonal = diagonal;
                }
              }

              return maxDiagonal;
            };

            CoSELayout.prototype.calcRepulsionRange = function () {
  // formula is 2 x (level + 1) x idealEdgeLength
              return 2 * (this.level + 1) * this.idealEdgeLength;
            };

// Tiling methods

// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's
            CoSELayout.prototype.groupZeroDegreeMembers = function () {
              const self = this;
  // array of [parent_id x oneDegreeNode_id]
              const tempMemberGroups = {}; // A temporary map of parent node and its zero degree members
              this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled
              this.idToDummyNode = {}; // A map of id to dummy node 

              const zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled
              const allNodes = this.graphManager.getAllNodes();

  // Fill zero degree list
              for (var i = 0; i < allNodes.length; i++) {
                var node = allNodes[i];
                const parent = node.getParent();
    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list
                if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {
                  zeroDegree.push(node);
                }
              }

  // Create a map of parent node and its zero degree members
              for (var i = 0; i < zeroDegree.length; i++) {
                var node = zeroDegree[i]; // Zero degree node itself
                const p_id = node.getParent().id; // Parent id

                if (typeof tempMemberGroups[p_id] === "undefined") tempMemberGroups[p_id] = [];

                tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups
              }

  // If there are at least two nodes at a level, create a dummy compound for them
              Object.keys(tempMemberGroups).forEach(function (p_id) {
                if (tempMemberGroups[p_id].length > 1) {
                  const dummyCompoundId = "DummyCompound_" + p_id; // The id of dummy compound which will be created soon
                  self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups

                  const parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound

      // Create a dummy compound with calculated id
                  const dummyCompound = new CoSENode(self.graphManager);
                  dummyCompound.id = dummyCompoundId;
                  dummyCompound.paddingLeft = parent.paddingLeft || 0;
                  dummyCompound.paddingRight = parent.paddingRight || 0;
                  dummyCompound.paddingBottom = parent.paddingBottom || 0;
                  dummyCompound.paddingTop = parent.paddingTop || 0;

                  self.idToDummyNode[dummyCompoundId] = dummyCompound;

                  const dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);
                  const parentGraph = parent.getChild();

      // Add dummy compound to parent the graph
                  parentGraph.add(dummyCompound);

      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent
                  for (let i = 0; i < tempMemberGroups[p_id].length; i++) {
                    const node = tempMemberGroups[p_id][i];

                    parentGraph.remove(node);
                    dummyParentGraph.add(node);
                  }
                }
              });
            };

            CoSELayout.prototype.clearCompounds = function () {
              const childGraphMap = {};
              const idToNode = {};

  // Get compound ordering by finding the inner one first
              this.performDFSOnCompounds();

              for (let i = 0; i < this.compoundOrder.length; i++) {

                idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];
                childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());

    // Remove children of compounds
                this.graphManager.remove(this.compoundOrder[i].getChild());
                this.compoundOrder[i].child = null;
              }

              this.graphManager.resetAllNodes();

  // Tile the removed children
              this.tileCompoundMembers(childGraphMap, idToNode);
            };

            CoSELayout.prototype.clearZeroDegreeMembers = function () {
              const self = this;
              const tiledZeroDegreePack = this.tiledZeroDegreePack = [];

              Object.keys(this.memberGroups).forEach(function (id) {
                const compoundNode = self.idToDummyNode[id]; // Get the dummy compound

                tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);

    // Set the width and height of the dummy compound as calculated
                compoundNode.rect.width = tiledZeroDegreePack[id].width;
                compoundNode.rect.height = tiledZeroDegreePack[id].height;
              });
            };

            CoSELayout.prototype.repopulateCompounds = function () {
              for (let i = this.compoundOrder.length - 1; i >= 0; i--) {
                const lCompoundNode = this.compoundOrder[i];
                const id = lCompoundNode.id;
                const horizontalMargin = lCompoundNode.paddingLeft;
                const verticalMargin = lCompoundNode.paddingTop;

                this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);
              }
            };

            CoSELayout.prototype.repopulateZeroDegreeMembers = function () {
              const self = this;
              const tiledPack = this.tiledZeroDegreePack;

              Object.keys(tiledPack).forEach(function (id) {
                const compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id
                const horizontalMargin = compoundNode.paddingLeft;
                const verticalMargin = compoundNode.paddingTop;

    // Adjust the positions of nodes wrt its compound
                self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);
              });
            };

            CoSELayout.prototype.getToBeTiled = function (node) {
              const id = node.id;
  //firstly check the previous results
              if (this.toBeTiled[id] != null) {
                return this.toBeTiled[id];
              }

  //only compound nodes are to be tiled
              const childGraph = node.getChild();
              if (childGraph == null) {
                this.toBeTiled[id] = false;
                return false;
              }

              const children = childGraph.getNodes(); // Get the children nodes

  //a compound node is not to be tiled if all of its compound children are not to be tiled
              for (let i = 0; i < children.length; i++) {
                const theChild = children[i];

                if (this.getNodeDegree(theChild) > 0) {
                  this.toBeTiled[id] = false;
                  return false;
                }

    //pass the children not having the compound structure
                if (theChild.getChild() == null) {
                  this.toBeTiled[theChild.id] = false;
                  continue;
                }

                if (!this.getToBeTiled(theChild)) {
                  this.toBeTiled[id] = false;
                  return false;
                }
              }
              this.toBeTiled[id] = true;
              return true;
            };

// Get degree of a node depending of its edges and independent of its children
            CoSELayout.prototype.getNodeDegree = function (node) {
              const id = node.id;
              const edges = node.getEdges();
              let degree = 0;

  // For the edges connected
              for (let i = 0; i < edges.length; i++) {
                const edge = edges[i];
                if (edge.getSource().id !== edge.getTarget().id) {
                  degree = degree + 1;
                }
              }
              return degree;
            };

// Get degree of a node with its children
            CoSELayout.prototype.getNodeDegreeWithChildren = function (node) {
              let degree = this.getNodeDegree(node);
              if (node.getChild() == null) {
                return degree;
              }
              const children = node.getChild().getNodes();
              for (let i = 0; i < children.length; i++) {
                const child = children[i];
                degree += this.getNodeDegreeWithChildren(child);
              }
              return degree;
            };

            CoSELayout.prototype.performDFSOnCompounds = function () {
              this.compoundOrder = [];
              this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());
            };

            CoSELayout.prototype.fillCompexOrderByDFS = function (children) {
              for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.getChild() != null) {
                  this.fillCompexOrderByDFS(child.getChild().getNodes());
                }
                if (this.getToBeTiled(child)) {
                  this.compoundOrder.push(child);
                }
              }
            };

/**
* This method places each zero degree member wrt given (x,y) coordinates (top left).
*/
            CoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {
              x += compoundHorizontalMargin;
              y += compoundVerticalMargin;

              const left = x;

              for (let i = 0; i < organization.rows.length; i++) {
                const row = organization.rows[i];
                x = left;
                let maxHeight = 0;

                for (let j = 0; j < row.length; j++) {
                  const lnode = row[j];

                  lnode.rect.x = x; // + lnode.rect.width / 2;
                  lnode.rect.y = y; // + lnode.rect.height / 2;

                  x += lnode.rect.width + organization.horizontalPadding;

                  if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;
                }

                y += maxHeight + organization.verticalPadding;
              }
            };

            CoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {
              const self = this;
              this.tiledMemberPack = [];

              Object.keys(childGraphMap).forEach(function (id) {
    // Get the compound node
                const compoundNode = idToNode[id];

                self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);

                compoundNode.rect.width = self.tiledMemberPack[id].width;
                compoundNode.rect.height = self.tiledMemberPack[id].height;
              });
            };

            CoSELayout.prototype.tileNodes = function (nodes, minWidth) {
              const verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;
              const horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;
              const organization = {
                rows: [],
                rowWidth: [],
                rowHeight: [],
                width: 0,
                height: minWidth, // assume minHeight equals to minWidth
                verticalPadding: verticalPadding,
                horizontalPadding: horizontalPadding
              };

  // Sort the nodes in ascending order of their areas
              nodes.sort(function (n1, n2) {
                if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;
                if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;
                return 0;
              });

  // Create the organization -> tile members
              for (let i = 0; i < nodes.length; i++) {
                const lNode = nodes[i];

                if (organization.rows.length == 0) {
                  this.insertNodeToRow(organization, lNode, 0, minWidth);
                } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {
                  this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);
                } else {
                  this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);
                }

                this.shiftToLastRow(organization);
              }

              return organization;
            };

            CoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {
              const minCompoundSize = minWidth;

  // Add new row if needed
              if (rowIndex == organization.rows.length) {
                const secondDimension = [];

                organization.rows.push(secondDimension);
                organization.rowWidth.push(minCompoundSize);
                organization.rowHeight.push(0);
              }

  // Update row width
              let w = organization.rowWidth[rowIndex] + node.rect.width;

              if (organization.rows[rowIndex].length > 0) {
                w += organization.horizontalPadding;
              }

              organization.rowWidth[rowIndex] = w;
  // Update compound width
              if (organization.width < w) {
                organization.width = w;
              }

  // Update height
              let h = node.rect.height;
              if (rowIndex > 0) h += organization.verticalPadding;

              let extraHeight = 0;
              if (h > organization.rowHeight[rowIndex]) {
                extraHeight = organization.rowHeight[rowIndex];
                organization.rowHeight[rowIndex] = h;
                extraHeight = organization.rowHeight[rowIndex] - extraHeight;
              }

              organization.height += extraHeight;

  // Insert node
              organization.rows[rowIndex].push(node);
            };

//Scans the rows of an organization and returns the one with the min width
            CoSELayout.prototype.getShortestRowIndex = function (organization) {
              let r = -1;
              let min = Number.MAX_VALUE;

              for (let i = 0; i < organization.rows.length; i++) {
                if (organization.rowWidth[i] < min) {
                  r = i;
                  min = organization.rowWidth[i];
                }
              }
              return r;
            };

//Scans the rows of an organization and returns the one with the max width
            CoSELayout.prototype.getLongestRowIndex = function (organization) {
              let r = -1;
              let max = Number.MIN_VALUE;

              for (let i = 0; i < organization.rows.length; i++) {

                if (organization.rowWidth[i] > max) {
                  r = i;
                  max = organization.rowWidth[i];
                }
              }

              return r;
            };

/**
* This method checks whether adding extra width to the organization violates
* the aspect ratio(1) or not.
*/
            CoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {

              const sri = this.getShortestRowIndex(organization);

              if (sri < 0) {
                return true;
              }

              const min = organization.rowWidth[sri];

              if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;

              let hDiff = 0;

  // Adding to an existing row
              if (organization.rowHeight[sri] < extraHeight) {
                if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];
              }

              let add_to_row_ratio;
              if (organization.width - min >= extraWidth + organization.horizontalPadding) {
                add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);
              } else {
                add_to_row_ratio = (organization.height + hDiff) / organization.width;
              }

  // Adding a new row for this node
              hDiff = extraHeight + organization.verticalPadding;
              let add_new_row_ratio;
              if (organization.width < extraWidth) {
                add_new_row_ratio = (organization.height + hDiff) / extraWidth;
              } else {
                add_new_row_ratio = (organization.height + hDiff) / organization.width;
              }

              if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;

              if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;

              return add_to_row_ratio < add_new_row_ratio;
            };

//If moving the last node from the longest row and adding it to the last
//row makes the bounding box smaller, do it.
            CoSELayout.prototype.shiftToLastRow = function (organization) {
              const longest = this.getLongestRowIndex(organization);
              const last = organization.rowWidth.length - 1;
              const row = organization.rows[longest];
              const node = row[row.length - 1];

              const diff = node.width + organization.horizontalPadding;

  // Check if there is enough space on the last row
              if (organization.width - organization.rowWidth[last] > diff && longest != last) {
    // Remove the last element of the longest row
                row.splice(-1, 1);

    // Push it to the last row
                organization.rows[last].push(node);

                organization.rowWidth[longest] = organization.rowWidth[longest] - diff;
                organization.rowWidth[last] = organization.rowWidth[last] + diff;
                organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];

    // Update heights of the organization
                let maxHeight = Number.MIN_VALUE;
                for (let i = 0; i < row.length; i++) {
                  if (row[i].height > maxHeight) maxHeight = row[i].height;
                }
                if (longest > 0) maxHeight += organization.verticalPadding;

                const prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];

                organization.rowHeight[longest] = maxHeight;
                if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;

                const finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];
                organization.height += finalTotal - prevTotal;

                this.shiftToLastRow(organization);
              }
            };

            CoSELayout.prototype.tilingPreLayout = function () {
              if (CoSEConstants.TILE) {
    // Find zero degree nodes and create a compound for each level
                this.groupZeroDegreeMembers();
    // Tile and clear children of each compound
                this.clearCompounds();
    // Separately tile and clear zero degree nodes for each level
                this.clearZeroDegreeMembers();
              }
            };

            CoSELayout.prototype.tilingPostLayout = function () {
              if (CoSEConstants.TILE) {
                this.repopulateZeroDegreeMembers();
                this.repopulateCompounds();
              }
            };

// -----------------------------------------------------------------------------
// Section: Tree Reduction methods
// -----------------------------------------------------------------------------
// Reduce trees 
            CoSELayout.prototype.reduceTrees = function () {
              const prunedNodesAll = [];
              let containsLeaf = true;
              let node;

              while (containsLeaf) {
                const allNodes = this.graphManager.getAllNodes();
                const prunedNodesInStepTemp = [];
                containsLeaf = false;

                for (let i = 0; i < allNodes.length; i++) {
                  node = allNodes[i];
                  if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {
                    prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);
                    containsLeaf = true;
                  }
                }
                if (containsLeaf == true) {
                  const prunedNodesInStep = [];
                  for (let j = 0; j < prunedNodesInStepTemp.length; j++) {
                    if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {
                      prunedNodesInStep.push(prunedNodesInStepTemp[j]);
                      prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);
                    }
                  }
                  prunedNodesAll.push(prunedNodesInStep);
                  this.graphManager.resetAllNodes();
                  this.graphManager.resetAllEdges();
                }
              }
              this.prunedNodesAll = prunedNodesAll;
            };

// Grow tree one step 
            CoSELayout.prototype.growTree = function (prunedNodesAll) {
              const lengthOfPrunedNodesInStep = prunedNodesAll.length;
              const prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];

              let nodeData;
              for (let i = 0; i < prunedNodesInStep.length; i++) {
                nodeData = prunedNodesInStep[i];

                this.findPlaceforPrunedNode(nodeData);

                nodeData[2].add(nodeData[0]);
                nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);
              }

              prunedNodesAll.splice(prunedNodesAll.length - 1, 1);
              this.graphManager.resetAllNodes();
              this.graphManager.resetAllEdges();
            };

// Find an appropriate position to replace pruned node, this method can be improved
            CoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {

              let gridForPrunedNode;
              let nodeToConnect;
              const prunedNode = nodeData[0];
              if (prunedNode == nodeData[1].source) {
                nodeToConnect = nodeData[1].target;
              } else {
                nodeToConnect = nodeData[1].source;
              }
              const startGridX = nodeToConnect.startX;
              const finishGridX = nodeToConnect.finishX;
              const startGridY = nodeToConnect.startY;
              const finishGridY = nodeToConnect.finishY;

              const upNodeCount = 0;
              const downNodeCount = 0;
              const rightNodeCount = 0;
              const leftNodeCount = 0;
              const controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];

              if (startGridY > 0) {
                for (var i = startGridX; i <= finishGridX; i++) {
                  controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;
                }
              }
              if (finishGridX < this.grid.length - 1) {
                for (var i = startGridY; i <= finishGridY; i++) {
                  controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;
                }
              }
              if (finishGridY < this.grid[0].length - 1) {
                for (var i = startGridX; i <= finishGridX; i++) {
                  controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;
                }
              }
              if (startGridX > 0) {
                for (var i = startGridY; i <= finishGridY; i++) {
                  controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;
                }
              }
              let min = Integer.MAX_VALUE;
              let minCount;
              let minIndex;
              for (let j = 0; j < controlRegions.length; j++) {
                if (controlRegions[j] < min) {
                  min = controlRegions[j];
                  minCount = 1;
                  minIndex = j;
                } else if (controlRegions[j] == min) {
                  minCount++;
                }
              }

              if (minCount == 3 && min == 0) {
                if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {
                  gridForPrunedNode = 1;
                } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {
                  gridForPrunedNode = 0;
                } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {
                  gridForPrunedNode = 3;
                } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {
                  gridForPrunedNode = 2;
                }
              } else if (minCount == 2 && min == 0) {
                var random = Math.floor(Math.random() * 2);
                if (controlRegions[0] == 0 && controlRegions[1] == 0) {
      
                  if (random == 0) {
                    gridForPrunedNode = 0;
                  } else {
                    gridForPrunedNode = 1;
                  }
                } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {
                  if (random == 0) {
                    gridForPrunedNode = 0;
                  } else {
                    gridForPrunedNode = 2;
                  }
                } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {
                  if (random == 0) {
                    gridForPrunedNode = 0;
                  } else {
                    gridForPrunedNode = 3;
                  }
                } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {
                  if (random == 0) {
                    gridForPrunedNode = 1;
                  } else {
                    gridForPrunedNode = 2;
                  }
                } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {
                  if (random == 0) {
                    gridForPrunedNode = 1;
                  } else {
                    gridForPrunedNode = 3;
                  }
                } else {
                  if (random == 0) {
                    gridForPrunedNode = 2;
                  } else {
                    gridForPrunedNode = 3;
                  }
                }
              } else if (minCount == 4 && min == 0) {
                var random = Math.floor(Math.random() * 4);
                gridForPrunedNode = random;
              } else {
                gridForPrunedNode = minIndex;
              }

              if (gridForPrunedNode == 0) {
                prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);
              } else if (gridForPrunedNode == 1) {
                prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());
              } else if (gridForPrunedNode == 2) {
                prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);
              } else {
                prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());
              }
            };

            module.exports = CoSELayout;

/***/ }),
/* 7 */
/***/ (function(module, exports, __nested_webpack_require_45620__) {

            "use strict";


            const coseBase = {};

            coseBase.layoutBase = __nested_webpack_require_45620__(0);
            coseBase.CoSEConstants = __nested_webpack_require_45620__(1);
            coseBase.CoSEEdge = __nested_webpack_require_45620__(2);
            coseBase.CoSEGraph = __nested_webpack_require_45620__(3);
            coseBase.CoSEGraphManager = __nested_webpack_require_45620__(4);
            coseBase.CoSELayout = __nested_webpack_require_45620__(6);
            coseBase.CoSENode = __nested_webpack_require_45620__(5);

            module.exports = coseBase;

/***/ })
/******/ ]);
      });

/***/ }),

/***/ "./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

      (function webpackUniversalModuleDefinition(root, factory) {
        if(true)
          module.exports = factory(__webpack_require__(/*! cose-base */ "./node_modules/cose-base/cose-base.js"));
        else {}
      })(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {
        return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	const installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_659__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		const module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_659__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_659__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_659__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__nested_webpack_require_659__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_659__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_659__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_659__.n = function(module) {
/******/ 		const getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_659__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_659__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_659__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_659__(__nested_webpack_require_659__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

            module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_3201__) {

            "use strict";


            const LayoutConstants = __nested_webpack_require_3201__(0).layoutBase.LayoutConstants;
            const FDLayoutConstants = __nested_webpack_require_3201__(0).layoutBase.FDLayoutConstants;
            const CoSEConstants = __nested_webpack_require_3201__(0).CoSEConstants;
            const CoSELayout = __nested_webpack_require_3201__(0).CoSELayout;
            const CoSENode = __nested_webpack_require_3201__(0).CoSENode;
            const PointD = __nested_webpack_require_3201__(0).layoutBase.PointD;
            const DimensionD = __nested_webpack_require_3201__(0).layoutBase.DimensionD;

            const defaults = {
  // Called on `layoutready`
              ready: function ready() {},
  // Called on `layoutstop`
              stop: function stop() {},
  // 'draft', 'default' or 'proof" 
  // - 'draft' fast cooling rate 
  // - 'default' moderate cooling rate 
  // - "proof" slow cooling rate
              quality: 'default',
  // include labels in node dimensions
              nodeDimensionsIncludeLabels: false,
  // number of ticks per frame; higher is faster but more jerky
              refresh: 30,
  // Whether to fit the network view after when done
              fit: true,
  // Padding on fit
              padding: 10,
  // Whether to enable incremental mode
              randomize: true,
  // Node repulsion (non overlapping) multiplier
              nodeRepulsion: 4500,
  // Ideal edge (non nested) length
              idealEdgeLength: 50,
  // Divisor to compute edge forces
              edgeElasticity: 0.45,
  // Nesting factor (multiplier) to compute ideal edge length for nested edges
              nestingFactor: 0.1,
  // Gravity force (constant)
              gravity: 0.25,
  // Maximum number of iterations to perform
              numIter: 2500,
  // For enabling tiling
              tile: true,
  // Type of layout animation. The option set is {'during', 'end', false}
              animate: 'end',
  // Duration for animate:end
              animationDuration: 500,
  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)
              tilingPaddingVertical: 10,
  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)
              tilingPaddingHorizontal: 10,
  // Gravity range (constant) for compounds
              gravityRangeCompound: 1.5,
  // Gravity force (constant) for compounds
              gravityCompound: 1.0,
  // Gravity range (constant)
              gravityRange: 3.8,
  // Initial cooling factor for incremental layout
              initialEnergyOnIncremental: 0.5
            };

            function extend(defaults, options) {
              const obj = {};

              for (var i in defaults) {
                obj[i] = defaults[i];
              }

              for (var i in options) {
                obj[i] = options[i];
              }

              return obj;
            }

            function _CoSELayout(_options) {
              this.options = extend(defaults, _options);
              getUserOptions(this.options);
            }

            var getUserOptions = function getUserOptions(options) {
              if (options.nodeRepulsion != null) CoSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;
              if (options.idealEdgeLength != null) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;
              if (options.edgeElasticity != null) CoSEConstants.DEFAULT_SPRING_STRENGTH = FDLayoutConstants.DEFAULT_SPRING_STRENGTH = options.edgeElasticity;
              if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;
              if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;
              if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;
              if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;
              if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;
              if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;
              if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;

              if (options.quality == 'draft') LayoutConstants.QUALITY = 0;else if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 1;

              CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;
              CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;
              CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;
              CoSEConstants.TILE = options.tile;
              CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;
              CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;
            };

            _CoSELayout.prototype.run = function () {
              let ready;
              let frameId;
              const options = this.options;
              const idToLNode = this.idToLNode = {};
              const layout = this.layout = new CoSELayout();
              const self = this;

              self.stopped = false;

              this.cy = this.options.cy;

              this.cy.trigger({ type: 'layoutstart', layout: this });

              const gm = layout.newGraphManager();
              this.gm = gm;

              const nodes = this.options.eles.nodes();
              const edges = this.options.eles.edges();

              this.root = gm.addRoot();
              this.processChildrenList(this.root, this.getTopMostNodes(nodes), layout);

              for (let i = 0; i < edges.length; i++) {
                const edge = edges[i];
                const sourceNode = this.idToLNode[edge.data("source")];
                const targetNode = this.idToLNode[edge.data("target")];
                if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {
                  const e1 = gm.add(layout.newEdge(), sourceNode, targetNode);
                  e1.id = edge.id();
                }
              }

              const getPositions = function getPositions(ele, i) {
                if (typeof ele === "number") {
                  ele = i;
                }
                const theId = ele.data('id');
                const lNode = self.idToLNode[theId];

                return {
                  x: lNode.getRect().getCenterX(),
                  y: lNode.getRect().getCenterY()
                };
              };

  /*
   * Reposition nodes in iterations animatedly
   */
              const iterateAnimated = function iterateAnimated() {
    // Thigs to perform after nodes are repositioned on screen
                const afterReposition = function afterReposition() {
                  if (options.fit) {
                    options.cy.fit(options.eles, options.padding);
                  }

                  if (!ready) {
                    ready = true;
                    self.cy.one('layoutready', options.ready);
                    self.cy.trigger({ type: 'layoutready', layout: self });
                  }
                };

                const ticksPerFrame = self.options.refresh;
                let isDone;

                for (let i = 0; i < ticksPerFrame && !isDone; i++) {
                  isDone = self.stopped || self.layout.tick();
                }

    // If layout is done
                if (isDone) {
      // If the layout is not a sublayout and it is successful perform post layout.
                  if (layout.checkLayoutSuccess() && !layout.isSubLayout) {
                    layout.doPostLayout();
                  }

      // If layout has a tilingPostLayout function property call it.
                  if (layout.tilingPostLayout) {
                    layout.tilingPostLayout();
                  }

                  layout.isLayoutFinished = true;

                  self.options.eles.nodes().positions(getPositions);

                  afterReposition();

      // trigger layoutstop when the layout stops (e.g. finishes)
                  self.cy.one('layoutstop', self.options.stop);
                  self.cy.trigger({ type: 'layoutstop', layout: self });

                  if (frameId) {
                    cancelAnimationFrame(frameId);
                  }

                  ready = false;
                  return;
                }

                const animationData = self.layout.getPositionsData(); // Get positions of layout nodes note that all nodes may not be layout nodes because of tiling

    // Position nodes, for the nodes whose id does not included in data (because they are removed from their parents and included in dummy compounds)
    // use position of their ancestors or dummy ancestors
                options.eles.nodes().positions(function (ele, i) {
                  if (typeof ele === "number") {
                    ele = i;
                  }
      // If ele is a compound node, then its position will be defined by its children
                  if (!ele.isParent()) {
                    const theId = ele.id();
                    let pNode = animationData[theId];
                    let temp = ele;
        // If pNode is undefined search until finding position data of its first ancestor (It may be dummy as well)
                    while (pNode == null) {
                      pNode = animationData[temp.data('parent')] || animationData['DummyCompound_' + temp.data('parent')];
                      animationData[theId] = pNode;
                      temp = temp.parent()[0];
                      if (temp == undefined) {
                        break;
                      }
                    }
                    if (pNode != null) {
                      return {
                        x: pNode.x,
                        y: pNode.y
                      };
                    } else {
                      return {
                        x: ele.position('x'),
                        y: ele.position('y')
                      };
                    }
                  }
                });

                afterReposition();

                frameId = requestAnimationFrame(iterateAnimated);
              };

  /*
  * Listen 'layoutstarted' event and start animated iteration if animate option is 'during'
  */
              layout.addListener('layoutstarted', function () {
                if (self.options.animate === 'during') {
                  frameId = requestAnimationFrame(iterateAnimated);
                }
              });

              layout.runLayout(); // Run cose layout

  /*
   * If animate option is not 'during' ('end' or false) perform these here (If it is 'during' similar things are already performed)
   */
              if (this.options.animate !== "during") {
                self.options.eles.nodes().not(":parent").layoutPositions(self, self.options, getPositions); // Use layout positions to reposition the nodes it considers the options parameter
                ready = false;
              }

              return this; // chaining
            };

//Get the top most ones of a list of nodes
            _CoSELayout.prototype.getTopMostNodes = function (nodes) {
              const nodesMap = {};
              for (let i = 0; i < nodes.length; i++) {
                nodesMap[nodes[i].id()] = true;
              }
              const roots = nodes.filter(function (ele, i) {
                if (typeof ele === "number") {
                  ele = i;
                }
                let parent = ele.parent()[0];
                while (parent != null) {
                  if (nodesMap[parent.id()]) {
                    return false;
                  }
                  parent = parent.parent()[0];
                }
                return true;
              });

              return roots;
            };

            _CoSELayout.prototype.processChildrenList = function (parent, children, layout) {
              const size = children.length;
              for (let i = 0; i < size; i++) {
                const theChild = children[i];
                const children_of_children = theChild.children();
                var theNode;

                const dimensions = theChild.layoutDimensions({
                  nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels
                });

                if (theChild.outerWidth() != null && theChild.outerHeight() != null) {
                  theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));
                } else {
                  theNode = parent.add(new CoSENode(this.graphManager));
                }
    // Attach id to the layout node
                theNode.id = theChild.data("id");
    // Attach the paddings of cy node to layout node
                theNode.paddingLeft = parseInt(theChild.css('padding'));
                theNode.paddingTop = parseInt(theChild.css('padding'));
                theNode.paddingRight = parseInt(theChild.css('padding'));
                theNode.paddingBottom = parseInt(theChild.css('padding'));

    //Attach the label properties to compound if labels will be included in node dimensions  
                if (this.options.nodeDimensionsIncludeLabels) {
                  if (theChild.isParent()) {
                    const labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false }).w;
                    const labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false }).h;
                    const labelPos = theChild.css("text-halign");
                    theNode.labelWidth = labelWidth;
                    theNode.labelHeight = labelHeight;
                    theNode.labelPos = labelPos;
                  }
                }

    // Map the layout node
                this.idToLNode[theChild.data("id")] = theNode;

                if (isNaN(theNode.rect.x)) {
                  theNode.rect.x = 0;
                }

                if (isNaN(theNode.rect.y)) {
                  theNode.rect.y = 0;
                }

                if (children_of_children != null && children_of_children.length > 0) {
                  var theNewGraph;
                  theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);
                  this.processChildrenList(theNewGraph, children_of_children, layout);
                }
              }
            };

/**
 * @brief : called on continuous layouts to stop them before they finish
 */
            _CoSELayout.prototype.stop = function () {
              this.stopped = true;

              return this; // chaining
            };

            const register = function register(cytoscape) {
  //  var Layout = getLayout( cytoscape );

              cytoscape('layout', 'cose-bilkent', _CoSELayout);
            };

// auto reg for globals
            if (typeof cytoscape !== 'undefined') {
              register(cytoscape);
            }

            module.exports = register;

/***/ })
/******/ ]);
      });

/***/ }),

/***/ "./node_modules/cytoscape/dist/cytoscape.cjs.js":
/*!******************************************************!*\
  !*** ./node_modules/cytoscape/dist/cytoscape.cjs.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";
/**
 * Copyright (c) 2016-2021, The Cytoscape Consortium.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the Software), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



      function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

      const util = _interopDefault(__webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js"));
      const Heap = _interopDefault(__webpack_require__(/*! heap */ "./node_modules/heap/index.js"));

      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function (obj) {
            return typeof obj;
          };
        } else {
          _typeof = function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (let i = 0; i < props.length; i++) {
          const descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
      }

      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }

      function _iterableToArrayLimit(arr, i) {
        const _arr = [];
        let _n = true;
        let _d = false;
        let _e = undefined;

        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }

        return _arr;
      }

      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }

      const window$1 = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef

      const navigator = window$1 ? window$1.navigator : null;
      const document$1 = window$1 ? window$1.document : null;

      const typeofstr = _typeof('');

      const typeofobj = _typeof({});

      const typeoffn = _typeof(function () {});

      const typeofhtmlele = typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement);

      const instanceStr = function instanceStr(obj) {
        return obj && obj.instanceString && fn(obj.instanceString) ? obj.instanceString() : null;
      };

      const string = function string(obj) {
        return obj != null && _typeof(obj) == typeofstr;
      };
      var fn = function fn(obj) {
        return obj != null && _typeof(obj) === typeoffn;
      };
      const array = function array(obj) {
        return !elementOrCollection(obj) && (Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array);
      };
      const plainObject = function plainObject(obj) {
        return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;
      };
      const object = function object(obj) {
        return obj != null && _typeof(obj) === typeofobj;
      };
      const number = function number(obj) {
        return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);
      };
      const integer = function integer(obj) {
        return number(obj) && Math.floor(obj) === obj;
      };
      const htmlElement = function htmlElement(obj) {
        if ('undefined' === typeofhtmlele) {
          return undefined;
        } else {
          return null != obj && obj instanceof HTMLElement;
        }
      };
      var elementOrCollection = function elementOrCollection(obj) {
        return element(obj) || collection(obj);
      };
      var element = function element(obj) {
        return instanceStr(obj) === 'collection' && obj._private.single;
      };
      var collection = function collection(obj) {
        return instanceStr(obj) === 'collection' && !obj._private.single;
      };
      const core = function core(obj) {
        return instanceStr(obj) === 'core';
      };
      const stylesheet = function stylesheet(obj) {
        return instanceStr(obj) === 'stylesheet';
      };
      const event = function event(obj) {
        return instanceStr(obj) === 'event';
      };
      const emptyString = function emptyString(obj) {
        if (obj === undefined || obj === null) {
    // null is empty
          return true;
        } else if (obj === '' || obj.match(/^\s+$/)) {
          return true; // empty string is empty
        }

        return false; // otherwise, we don't know what we've got
      };
      const domElement = function domElement(obj) {
        if (typeof HTMLElement === 'undefined') {
          return false; // we're not in a browser so it doesn't matter
        } else {
          return obj instanceof HTMLElement;
        }
      };
      const boundingBox = function boundingBox(obj) {
        return plainObject(obj) && number(obj.x1) && number(obj.x2) && number(obj.y1) && number(obj.y2);
      };
      const promise = function promise(obj) {
        return object(obj) && fn(obj.then);
      };
      const ms = function ms() {
        return navigator && navigator.userAgent.match(/msie|trident|edge/i);
      }; // probably a better way to detect this...

      const memoize = function memoize(fn, keyFn) {
        if (!keyFn) {
          keyFn = function keyFn() {
            if (arguments.length === 1) {
              return arguments[0];
            } else if (arguments.length === 0) {
              return 'undefined';
            }

            const args = [];

            for (let i = 0; i < arguments.length; i++) {
              args.push(arguments[i]);
            }

            return args.join('$');
          };
        }

        const memoizedFn = function memoizedFn() {
          const self = this;
          const args = arguments;
          let ret;
          const k = keyFn.apply(self, args);
          const cache = memoizedFn.cache;

          if (!(ret = cache[k])) {
            ret = cache[k] = fn.apply(self, args);
          }

          return ret;
        };

        memoizedFn.cache = {};
        return memoizedFn;
      };

      const camel2dash = memoize(function (str) {
        return str.replace(/([A-Z])/g, function (v) {
          return '-' + v.toLowerCase();
        });
      });
      const dash2camel = memoize(function (str) {
        return str.replace(/(-\w)/g, function (v) {
          return v[1].toUpperCase();
        });
      });
      const prependCamel = memoize(function (prefix, str) {
        return prefix + str[0].toUpperCase() + str.substring(1);
      }, function (prefix, str) {
        return prefix + '$' + str;
      });
      const capitalize = function capitalize(str) {
        if (emptyString(str)) {
          return str;
        }

        return str.charAt(0).toUpperCase() + str.substring(1);
      };

      const number$1 = '(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))';
      const rgba = 'rgb[a]?\\((' + number$1 + '[%]?)\\s*,\\s*(' + number$1 + '[%]?)\\s*,\\s*(' + number$1 + '[%]?)(?:\\s*,\\s*(' + number$1 + '))?\\)';
      const rgbaNoBackRefs = 'rgb[a]?\\((?:' + number$1 + '[%]?)\\s*,\\s*(?:' + number$1 + '[%]?)\\s*,\\s*(?:' + number$1 + '[%]?)(?:\\s*,\\s*(?:' + number$1 + '))?\\)';
      const hsla = 'hsl[a]?\\((' + number$1 + ')\\s*,\\s*(' + number$1 + '[%])\\s*,\\s*(' + number$1 + '[%])(?:\\s*,\\s*(' + number$1 + '))?\\)';
      const hslaNoBackRefs = 'hsl[a]?\\((?:' + number$1 + ')\\s*,\\s*(?:' + number$1 + '[%])\\s*,\\s*(?:' + number$1 + '[%])(?:\\s*,\\s*(?:' + number$1 + '))?\\)';
      const hex3 = '\\#[0-9a-fA-F]{3}';
      const hex6 = '\\#[0-9a-fA-F]{6}';

      const ascending = function ascending(a, b) {
        if (a < b) {
          return -1;
        } else if (a > b) {
          return 1;
        } else {
          return 0;
        }
      };
      const descending = function descending(a, b) {
        return -1 * ascending(a, b);
      };

      const extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {
        const args = arguments;

        for (let i = 1; i < args.length; i++) {
          const obj = args[i];

          if (obj == null) {
            continue;
          }

          const keys = Object.keys(obj);

          for (let j = 0; j < keys.length; j++) {
            const k = keys[j];
            tgt[k] = obj[k];
          }
        }

        return tgt;
      };

      const hex2tuple = function hex2tuple(hex) {
        if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {
          return;
        }

        const shortHex = hex.length === 4;
        let r, g, b;
        const base = 16;

        if (shortHex) {
          r = parseInt(hex[1] + hex[1], base);
          g = parseInt(hex[2] + hex[2], base);
          b = parseInt(hex[3] + hex[3], base);
        } else {
          r = parseInt(hex[1] + hex[2], base);
          g = parseInt(hex[3] + hex[4], base);
          b = parseInt(hex[5] + hex[6], base);
        }

        return [r, g, b];
      }; // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)

      const hsl2tuple = function hsl2tuple(hsl) {
        let ret;
        let h, s, l, a, r, g, b;

        function hue2rgb(p, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        }

        const m = new RegExp('^' + hsla + '$').exec(hsl);

        if (m) {
    // get hue
          h = parseInt(m[1]);

          if (h < 0) {
            h = (360 - -1 * h % 360) % 360;
          } else if (h > 360) {
            h = h % 360;
          }

          h /= 360; // normalise on [0, 1]

          s = parseFloat(m[2]);

          if (s < 0 || s > 100) {
            return;
          } // saturation is [0, 100]


          s = s / 100; // normalise on [0, 1]

          l = parseFloat(m[3]);

          if (l < 0 || l > 100) {
            return;
          } // lightness is [0, 100]


          l = l / 100; // normalise on [0, 1]

          a = m[4];

          if (a !== undefined) {
            a = parseFloat(a);

            if (a < 0 || a > 1) {
              return;
            } // alpha is [0, 1]

          } // now, convert to rgb
    // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript


          if (s === 0) {
            r = g = b = Math.round(l * 255); // achromatic
          } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));
            g = Math.round(255 * hue2rgb(p, q, h));
            b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));
          }

          ret = [r, g, b, a];
        }

        return ret;
      }; // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)

      const rgb2tuple = function rgb2tuple(rgb) {
        let ret;
        const m = new RegExp('^' + rgba + '$').exec(rgb);

        if (m) {
          ret = [];
          const isPct = [];

          for (let i = 1; i <= 3; i++) {
            let channel = m[i];

            if (channel[channel.length - 1] === '%') {
              isPct[i] = true;
            }

            channel = parseFloat(channel);

            if (isPct[i]) {
              channel = channel / 100 * 255; // normalise to [0, 255]
            }

            if (channel < 0 || channel > 255) {
              return;
            } // invalid channel value


            ret.push(Math.floor(channel));
          }

          const atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
          const allArePct = isPct[1] && isPct[2] && isPct[3];

          if (atLeastOneIsPct && !allArePct) {
            return;
          } // must all be percent values if one is


          let alpha = m[4];

          if (alpha !== undefined) {
            alpha = parseFloat(alpha);

            if (alpha < 0 || alpha > 1) {
              return;
            } // invalid alpha value


            ret.push(alpha);
          }
        }

        return ret;
      };
      const colorname2tuple = function colorname2tuple(color) {
        return colors[color.toLowerCase()];
      };
      const color2tuple = function color2tuple(color) {
        return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);
      };
      var colors = {
  // special colour names
        transparent: [0, 0, 0, 0],
  // NB alpha === 0
  // regular colours
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        grey: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };

      const setMap = function setMap(options) {
        let obj = options.map;
        const keys = options.keys;
        const l = keys.length;

        for (let i = 0; i < l; i++) {
          const key = keys[i];

          if (plainObject(key)) {
            throw Error('Tried to set map with object key');
          }

          if (i < keys.length - 1) {
      // extend the map if necessary
            if (obj[key] == null) {
              obj[key] = {};
            }

            obj = obj[key];
          } else {
      // set the value
            obj[key] = options.value;
          }
        }
      }; // gets the value in a map even if it's not built in places

      const getMap = function getMap(options) {
        let obj = options.map;
        const keys = options.keys;
        const l = keys.length;

        for (let i = 0; i < l; i++) {
          const key = keys[i];

          if (plainObject(key)) {
            throw Error('Tried to get map with object key');
          }

          obj = obj[key];

          if (obj == null) {
            return obj;
          }
        }

        return obj;
      }; // deletes the entry in the map

      const performance = window$1 ? window$1.performance : null;
      const pnow = performance && performance.now ? function () {
        return performance.now();
      } : function () {
        return Date.now();
      };

      const raf = function () {
        if (window$1) {
          if (window$1.requestAnimationFrame) {
            return function (fn) {
              window$1.requestAnimationFrame(fn);
            };
          } else if (window$1.mozRequestAnimationFrame) {
            return function (fn) {
              window$1.mozRequestAnimationFrame(fn);
            };
          } else if (window$1.webkitRequestAnimationFrame) {
            return function (fn) {
              window$1.webkitRequestAnimationFrame(fn);
            };
          } else if (window$1.msRequestAnimationFrame) {
            return function (fn) {
              window$1.msRequestAnimationFrame(fn);
            };
          }
        }

        return function (fn) {
          if (fn) {
            setTimeout(function () {
              fn(pnow());
            }, 1000 / 60);
          }
        };
      }();

      const requestAnimationFrame = function requestAnimationFrame(fn) {
        return raf(fn);
      };
      const performanceNow = pnow;

      const DEFAULT_HASH_SEED = 9261;
      const K = 65599; // 37 also works pretty well

      const DEFAULT_HASH_SEED_ALT = 5381;
      const hashIterableInts = function hashIterableInts(iterator) {
        const seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;
  // sdbm/string-hash
        let hash = seed;
        let entry;

        for (;;) {
          entry = iterator.next();

          if (entry.done) {
            break;
          }

          hash = hash * K + entry.value | 0;
        }

        return hash;
      };
      const hashInt = function hashInt(num) {
        const seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;
  // sdbm/string-hash
        return seed * K + num | 0;
      };
      const hashIntAlt = function hashIntAlt(num) {
        const seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED_ALT;
  // djb2/string-hash
        return (seed << 5) + seed + num | 0;
      };
      const combineHashes = function combineHashes(hash1, hash2) {
        return hash1 * 0x200000 + hash2;
      };
      const combineHashesArray = function combineHashesArray(hashes) {
        return hashes[0] * 0x200000 + hashes[1];
      };
      const hashArrays = function hashArrays(hashes1, hashes2) {
        return [hashInt(hashes1[0], hashes2[0]), hashIntAlt(hashes1[1], hashes2[1])];
      };
      const hashIntsArray = function hashIntsArray(ints, seed) {
        const entry = {
          value: 0,
          done: false
        };
        let i = 0;
        const length = ints.length;
        const iterator = {
          next: function next() {
            if (i < length) {
              entry.value = ints[i++];
            } else {
              entry.done = true;
            }

            return entry;
          }
        };
        return hashIterableInts(iterator, seed);
      };
      const hashString = function hashString(str, seed) {
        const entry = {
          value: 0,
          done: false
        };
        let i = 0;
        const length = str.length;
        const iterator = {
          next: function next() {
            if (i < length) {
              entry.value = str.charCodeAt(i++);
            } else {
              entry.done = true;
            }

            return entry;
          }
        };
        return hashIterableInts(iterator, seed);
      };
      const hashStrings = function hashStrings() {
        return hashStringsArray(arguments);
      };
      var hashStringsArray = function hashStringsArray(strs) {
        let hash;

        for (let i = 0; i < strs.length; i++) {
          const str = strs[i];

          if (i === 0) {
            hash = hashString(str);
          } else {
            hash = hashString(str, hash);
          }
        }

        return hash;
      };

/*global console */
      let warningsEnabled = true;
      const warnSupported = console.warn != null; // eslint-disable-line no-console

      const traceSupported = console.trace != null; // eslint-disable-line no-console

      const MAX_INT = Number.MAX_SAFE_INTEGER || 9007199254740991;
      const trueify = function trueify() {
        return true;
      };
      const falsify = function falsify() {
        return false;
      };
      const zeroify = function zeroify() {
        return 0;
      };
      const noop = function noop() {};
      const error = function error(msg) {
        throw new Error(msg);
      };
      const warnings = function warnings(enabled) {
        if (enabled !== undefined) {
          warningsEnabled = !!enabled;
        } else {
          return warningsEnabled;
        }
      };
      const warn = function warn(msg) {
  /* eslint-disable no-console */
        if (!warnings()) {
          return;
        }

        if (warnSupported) {
          console.warn(msg);
        } else {
          console.log(msg);

          if (traceSupported) {
            console.trace();
          }
        }
      };
/* eslint-enable */

      const clone = function clone(obj) {
        return extend({}, obj);
      }; // gets a shallow copy of the argument

      const copy = function copy(obj) {
        if (obj == null) {
          return obj;
        }

        if (array(obj)) {
          return obj.slice();
        } else if (plainObject(obj)) {
          return clone(obj);
        } else {
          return obj;
        }
      };
      const copyArray = function copyArray(arr) {
        return arr.slice();
      };
      const uuid = function uuid(a, b
/* placeholders */
      ) {
        for ( // loop :)
          b = a = ''; // b - result , a - numeric letiable
          a++ < 36; //
          b += a * 51 & 52 // if "a" is not 9 or 14 or 19 or 24
            ? //  return a random number or 4
            (a ^ 15 // if "a" is not 15
              ? // genetate a random number from 0 to 15
              8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless "a" is 20, in which case a random number from 8 to 11
              : 4 //  otherwise 4
            ).toString(16) : '-' //  in other cases (if "a" is 9,14,19,24) insert "-"
        ) {
        }

        return b;
      };
      const _staticEmptyObject = {};
      const staticEmptyObject = function staticEmptyObject() {
        return _staticEmptyObject;
      };
      const defaults = function defaults(_defaults) {
        const keys = Object.keys(_defaults);
        return function (opts) {
          const filledOpts = {};

          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const optVal = opts == null ? undefined : opts[key];
            filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;
          }

          return filledOpts;
        };
      };
      const removeFromArray = function removeFromArray(arr, ele, manyCopies) {
        for (let i = arr.length; i >= 0; i--) {
          if (arr[i] === ele) {
            arr.splice(i, 1);

            if (!manyCopies) {
              break;
            }
          }
        }
      };
      const clearArray = function clearArray(arr) {
        arr.splice(0, arr.length);
      };
      const push = function push(arr, otherArr) {
        for (let i = 0; i < otherArr.length; i++) {
          const el = otherArr[i];
          arr.push(el);
        }
      };
      const getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {
        if (prefix) {
          propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
        }

        return obj[propName];
      };
      const setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {
        if (prefix) {
          propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
        }

        obj[propName] = value;
      };

/* global Map */
      const ObjectMap =
/*#__PURE__*/
function () {
  function ObjectMap() {
    _classCallCheck(this, ObjectMap);

    this._obj = {};
  }

  _createClass(ObjectMap, [{
    key: "set",
    value: function set(key, val) {
      this._obj[key] = val;
      return this;
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      this._obj[key] = undefined;
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      this._obj = {};
    }
  }, {
    key: "has",
    value: function has(key) {
      return this._obj[key] !== undefined;
    }
  }, {
    key: "get",
    value: function get(key) {
      return this._obj[key];
    }
  }]);

  return ObjectMap;
}();

      const Map$1 = typeof Map !== 'undefined' ? Map : ObjectMap;

/* global Set */
      const undef =  "undefined" ;

      const ObjectSet =
/*#__PURE__*/
function () {
  function ObjectSet(arrayOrObjectSet) {
    _classCallCheck(this, ObjectSet);

    this._obj = Object.create(null);
    this.size = 0;

    if (arrayOrObjectSet != null) {
      let arr;

      if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {
        arr = arrayOrObjectSet.toArray();
      } else {
        arr = arrayOrObjectSet;
      }

      for (let i = 0; i < arr.length; i++) {
        this.add(arr[i]);
      }
    }
  }

  _createClass(ObjectSet, [{
    key: "instanceString",
    value: function instanceString() {
      return 'set';
    }
  }, {
    key: "add",
    value: function add(val) {
      const o = this._obj;

      if (o[val] !== 1) {
        o[val] = 1;
        this.size++;
      }
    }
  }, {
    key: "delete",
    value: function _delete(val) {
      const o = this._obj;

      if (o[val] === 1) {
        o[val] = 0;
        this.size--;
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this._obj = Object.create(null);
    }
  }, {
    key: "has",
    value: function has(val) {
      return this._obj[val] === 1;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      const _this = this;

      return Object.keys(this._obj).filter(function (key) {
        return _this.has(key);
      });
    }
  }, {
    key: "forEach",
    value: function forEach(callback, thisArg) {
      return this.toArray().forEach(callback, thisArg);
    }
  }]);

  return ObjectSet;
}();

      const Set$1 = (typeof Set === "undefined" ? "undefined" : _typeof(Set)) !== undef ? Set : ObjectSet;

      const Element = function Element(cy, params) {
        const restore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        if (cy === undefined || params === undefined || !core(cy)) {
          error('An element must have a core reference and parameters set');
          return;
        }

        let group = params.group; // try to automatically infer the group if unspecified

        if (group == null) {
          if (params.data && params.data.source != null && params.data.target != null) {
            group = 'edges';
          } else {
            group = 'nodes';
          }
        } // validate group


        if (group !== 'nodes' && group !== 'edges') {
          error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');
          return;
        } // make the element array-like, just like a collection


        this.length = 1;
        this[0] = this; // NOTE: when something is added here, add also to ele.json()

        const _p = this._private = {
          cy: cy,
          single: true,
    // indicates this is an element
          data: params.data || {},
    // data object
          position: params.position || {
            x: 0,
            y: 0
          },
    // (x, y) position pair
          autoWidth: undefined,
    // width and height of nodes calculated by the renderer when set to special 'auto' value
          autoHeight: undefined,
          autoPadding: undefined,
          compoundBoundsClean: false,
    // whether the compound dimensions need to be recalculated the next time dimensions are read
          listeners: [],
    // array of bound listeners
          group: group,
    // string; 'nodes' or 'edges'
          style: {},
    // properties as set by the style
          rstyle: {},
    // properties for style sent from the renderer to the core
          styleCxts: [],
    // applied style contexts from the styler
          styleKeys: {},
    // per-group keys of style property values
          removed: true,
    // whether it's inside the vis; true if removed (set true here since we call restore)
          selected: params.selected ? true : false,
    // whether it's selected
          selectable: params.selectable === undefined ? true : params.selectable ? true : false,
    // whether it's selectable
          locked: params.locked ? true : false,
    // whether the element is locked (cannot be moved)
          grabbed: false,
    // whether the element is grabbed by the mouse; renderer sets this privately
          grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,
    // whether the element can be grabbed
          pannable: params.pannable === undefined ? group === 'edges' ? true : false : params.pannable ? true : false,
    // whether the element has passthrough panning enabled
          active: false,
    // whether the element is active from user interaction
          classes: new Set$1(),
    // map ( className => true )
          animation: {
      // object for currently-running animations
            current: [],
            queue: []
          },
          rscratch: {},
    // object in which the renderer can store information
          scratch: params.scratch || {},
    // scratch objects
          edges: [],
    // array of connected edges
          children: [],
    // array of children
          parent: null,
    // parent ref
          traversalCache: {},
    // cache of output of traversal functions
          backgrounding: false,
    // whether background images are loading
          bbCache: null,
    // cache of the current bounding box
          bbCacheShift: {
            x: 0,
            y: 0
          },
    // shift applied to cached bb to be applied on next get
          bodyBounds: null,
    // bounds cache of element body, w/o overlay
          overlayBounds: null,
    // bounds cache of element body, including overlay
          labelBounds: {
      // bounds cache of labels
            all: null,
            source: null,
            target: null,
            main: null
          },
          arrowBounds: {
      // bounds cache of edge arrows
            source: null,
            target: null,
            'mid-source': null,
            'mid-target': null
          }
        };

        if (_p.position.x == null) {
          _p.position.x = 0;
        }

        if (_p.position.y == null) {
          _p.position.y = 0;
        } // renderedPosition overrides if specified


        if (params.renderedPosition) {
          const rpos = params.renderedPosition;
          const pan = cy.pan();
          const zoom = cy.zoom();
          _p.position = {
            x: (rpos.x - pan.x) / zoom,
            y: (rpos.y - pan.y) / zoom
          };
        }

        let classes = [];

        if (array(params.classes)) {
          classes = params.classes;
        } else if (string(params.classes)) {
          classes = params.classes.split(/\s+/);
        }

        for (let i = 0, l = classes.length; i < l; i++) {
          const cls = classes[i];

          if (!cls || cls === '') {
            continue;
          }

          _p.classes.add(cls);
        }

        this.createEmitter();
        const bypass = params.style || params.css;

        if (bypass) {
          warn('Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead.');
          this.style(bypass);
        }

        if (restore === undefined || restore) {
          this.restore();
        }
      };

      const defineSearch = function defineSearch(params) {
        params = {
          bfs: params.bfs || !params.dfs,
          dfs: params.dfs || !params.bfs
        }; // from pseudocode on wikipedia

        return function searchFn(roots, fn$1, directed) {
          let options;

          if (plainObject(roots) && !elementOrCollection(roots)) {
            options = roots;
            roots = options.roots || options.root;
            fn$1 = options.visit;
            directed = options.directed;
          }

          directed = arguments.length === 2 && !fn(fn$1) ? fn$1 : directed;
          fn$1 = fn(fn$1) ? fn$1 : function () {};
          const cy = this._private.cy;
          const v = roots = string(roots) ? this.filter(roots) : roots;
          const Q = [];
          const connectedNodes = [];
          const connectedBy = {};
          const id2depth = {};
          const V = {};
          let j = 0;
          let found;

          const _this$byGroup = this.byGroup(),
            nodes = _this$byGroup.nodes,
            edges = _this$byGroup.edges; // enqueue v


          for (let i = 0; i < v.length; i++) {
            const vi = v[i];
            const viId = vi.id();

            if (vi.isNode()) {
              Q.unshift(vi);

              if (params.bfs) {
                V[viId] = true;
                connectedNodes.push(vi);
              }

              id2depth[viId] = 0;
            }
          }

          const _loop2 = function _loop2() {
            const v = params.bfs ? Q.shift() : Q.pop();
            const vId = v.id();

            if (params.dfs) {
              if (V[vId]) {
                return "continue";
              }

              V[vId] = true;
              connectedNodes.push(v);
            }

            const depth = id2depth[vId];
            const prevEdge = connectedBy[vId];
            const src = prevEdge != null ? prevEdge.source() : null;
            const tgt = prevEdge != null ? prevEdge.target() : null;
            const prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];
            let ret = void 0;
            ret = fn$1(v, prevEdge, prevNode, j++, depth);

            if (ret === true) {
              found = v;
              return "break";
            }

            if (ret === false) {
              return "break";
            }

            const vwEdges = v.connectedEdges().filter(function (e) {
              return (!directed || e.source().same(v)) && edges.has(e);
            });

            for (let _i2 = 0; _i2 < vwEdges.length; _i2++) {
              const e = vwEdges[_i2];
              let w = e.connectedNodes().filter(function (n) {
                return !n.same(v) && nodes.has(n);
              });
              const wId = w.id();

              if (w.length !== 0 && !V[wId]) {
                w = w[0];
                Q.push(w);

                if (params.bfs) {
                  V[wId] = true;
                  connectedNodes.push(w);
                }

                connectedBy[wId] = e;
                id2depth[wId] = id2depth[vId] + 1;
              }
            }
          };

          _loop: while (Q.length !== 0) {
            const _ret = _loop2();

            switch (_ret) {
              case "continue":
                continue;

              case "break":
                break _loop;
            }
          }

          const connectedEles = cy.collection();

          for (let _i = 0; _i < connectedNodes.length; _i++) {
            const node = connectedNodes[_i];
            const edge = connectedBy[node.id()];

            if (edge != null) {
              connectedEles.push(edge);
            }

            connectedEles.push(node);
          }

          return {
            path: cy.collection(connectedEles),
            found: cy.collection(found)
          };
        };
      }; // search, spanning trees, etc


      const elesfn = {
        breadthFirstSearch: defineSearch({
          bfs: true
        }),
        depthFirstSearch: defineSearch({
          dfs: true
        })
      }; // nice, short mathemathical alias

      elesfn.bfs = elesfn.breadthFirstSearch;
      elesfn.dfs = elesfn.depthFirstSearch;

      const dijkstraDefaults = defaults({
        root: null,
        weight: function weight(edge) {
          return 1;
        },
        directed: false
      });
      const elesfn$1 = {
        dijkstra: function dijkstra(options) {
          if (!plainObject(options)) {
            const args = arguments;
            options = {
              root: args[0],
              weight: args[1],
              directed: args[2]
            };
          }

          const _dijkstraDefaults = dijkstraDefaults(options),
            root = _dijkstraDefaults.root,
            weight = _dijkstraDefaults.weight,
            directed = _dijkstraDefaults.directed;

          const eles = this;
          const weightFn = weight;
          const source = string(root) ? this.filter(root)[0] : root[0];
          const dist = {};
          const prev = {};
          const knownDist = {};

          const _this$byGroup = this.byGroup(),
            nodes = _this$byGroup.nodes,
            edges = _this$byGroup.edges;

          edges.unmergeBy(function (ele) {
            return ele.isLoop();
          });

          const getDist = function getDist(node) {
            return dist[node.id()];
          };

          const setDist = function setDist(node, d) {
            dist[node.id()] = d;
            Q.updateItem(node);
          };

          var Q = new Heap(function (a, b) {
            return getDist(a) - getDist(b);
          });

          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            dist[node.id()] = node.same(source) ? 0 : Infinity;
            Q.push(node);
          }

          const distBetween = function distBetween(u, v) {
            const uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);
            let smallestDistance = Infinity;
            let smallestEdge;

            for (let _i = 0; _i < uvs.length; _i++) {
              const edge = uvs[_i];

              const _weight = weightFn(edge);

              if (_weight < smallestDistance || !smallestEdge) {
                smallestDistance = _weight;
                smallestEdge = edge;
              }
            }

            return {
              edge: smallestEdge,
              dist: smallestDistance
            };
          };

          while (Q.size() > 0) {
            const u = Q.pop();
            const smalletsDist = getDist(u);
            const uid = u.id();
            knownDist[uid] = smalletsDist;

            if (smalletsDist === Infinity) {
              continue;
            }

            const neighbors = u.neighborhood().intersect(nodes);

            for (let _i2 = 0; _i2 < neighbors.length; _i2++) {
              const v = neighbors[_i2];
              const vid = v.id();
              const vDist = distBetween(u, v);
              const alt = smalletsDist + vDist.dist;

              if (alt < getDist(v)) {
                setDist(v, alt);
                prev[vid] = {
                  node: u,
                  edge: vDist.edge
                };
              }
            } // for

          } // while


          return {
            distanceTo: function distanceTo(node) {
              const target = string(node) ? nodes.filter(node)[0] : node[0];
              return knownDist[target.id()];
            },
            pathTo: function pathTo(node) {
              const target = string(node) ? nodes.filter(node)[0] : node[0];
              const S = [];
              let u = target;
              let uid = u.id();

              if (target.length > 0) {
                S.unshift(target);

                while (prev[uid]) {
                  const p = prev[uid];
                  S.unshift(p.edge);
                  S.unshift(p.node);
                  u = p.node;
                  uid = u.id();
                }
              }

              return eles.spawn(S);
            }
          };
        }
      };

      const elesfn$2 = {
  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
        kruskal: function kruskal(weightFn) {
          weightFn = weightFn || function (edge) {
            return 1;
          };

          const _this$byGroup = this.byGroup(),
            nodes = _this$byGroup.nodes,
            edges = _this$byGroup.edges;

          const numNodes = nodes.length;
          const forest = new Array(numNodes);
          const A = nodes; // assumes byGroup() creates new collections that can be safely mutated

          const findSetIndex = function findSetIndex(ele) {
            for (let i = 0; i < forest.length; i++) {
              const eles = forest[i];

              if (eles.has(ele)) {
                return i;
              }
            }
          }; // start with one forest per node


          for (let i = 0; i < numNodes; i++) {
            forest[i] = this.spawn(nodes[i]);
          }

          const S = edges.sort(function (a, b) {
            return weightFn(a) - weightFn(b);
          });

          for (let _i = 0; _i < S.length; _i++) {
            const edge = S[_i];
            const u = edge.source()[0];
            const v = edge.target()[0];
            const setUIndex = findSetIndex(u);
            const setVIndex = findSetIndex(v);
            const setU = forest[setUIndex];
            const setV = forest[setVIndex];

            if (setUIndex !== setVIndex) {
              A.merge(edge); // combine forests for u and v

              setU.merge(setV);
              forest.splice(setVIndex, 1);
            }
          }

          return A;
        }
      };

      const aStarDefaults = defaults({
        root: null,
        goal: null,
        weight: function weight(edge) {
          return 1;
        },
        heuristic: function heuristic(edge) {
          return 0;
        },
        directed: false
      });
      const elesfn$3 = {
  // Implemented from pseudocode from wikipedia
        aStar: function aStar(options) {
          const cy = this.cy();

          let _aStarDefaults = aStarDefaults(options),
            root = _aStarDefaults.root,
            goal = _aStarDefaults.goal,
            heuristic = _aStarDefaults.heuristic,
            directed = _aStarDefaults.directed,
            weight = _aStarDefaults.weight;

          root = cy.collection(root)[0];
          goal = cy.collection(goal)[0];
          const sid = root.id();
          const tid = goal.id();
          const gScore = {};
          const fScore = {};
          const closedSetIds = {};
          const openSet = new Heap(function (a, b) {
            return fScore[a.id()] - fScore[b.id()];
          });
          const openSetIds = new Set$1();
          const cameFrom = {};
          const cameFromEdge = {};

          const addToOpenSet = function addToOpenSet(ele, id) {
            openSet.push(ele);
            openSetIds.add(id);
          };

          let cMin, cMinId;

          const popFromOpenSet = function popFromOpenSet() {
            cMin = openSet.pop();
            cMinId = cMin.id();
            openSetIds["delete"](cMinId);
          };

          const isInOpenSet = function isInOpenSet(id) {
            return openSetIds.has(id);
          };

          addToOpenSet(root, sid);
          gScore[sid] = 0;
          fScore[sid] = heuristic(root); // Counter

          let steps = 0; // Main loop

          while (openSet.size() > 0) {
            popFromOpenSet();
            steps++; // If we've found our goal, then we are done

            if (cMinId === tid) {
              const path = [];
              let pathNode = goal;
              let pathNodeId = tid;
              let pathEdge = cameFromEdge[pathNodeId];

              for (;;) {
                path.unshift(pathNode);

                if (pathEdge != null) {
                  path.unshift(pathEdge);
                }

                pathNode = cameFrom[pathNodeId];

                if (pathNode == null) {
                  break;
                }

                pathNodeId = pathNode.id();
                pathEdge = cameFromEdge[pathNodeId];
              }

              return {
                found: true,
                distance: gScore[cMinId],
                path: this.spawn(path),
                steps: steps
              };
            } // Add cMin to processed nodes


            closedSetIds[cMinId] = true; // Update scores for neighbors of cMin
      // Take into account if graph is directed or not

            const vwEdges = cMin._private.edges;

            for (let i = 0; i < vwEdges.length; i++) {
              const e = vwEdges[i]; // edge must be in set of calling eles

              if (!this.hasElementWithId(e.id())) {
                continue;
              } // cMin must be the source of edge if directed


              if (directed && e.data('source') !== cMinId) {
                continue;
              }

              const wSrc = e.source();
              const wTgt = e.target();
              const w = wSrc.id() !== cMinId ? wSrc : wTgt;
              const wid = w.id(); // node must be in set of calling eles

              if (!this.hasElementWithId(wid)) {
                continue;
              } // if node is in closedSet, ignore it


              if (closedSetIds[wid]) {
                continue;
              } // New tentative score for node w


              const tempScore = gScore[cMinId] + weight(e); // Update gScore for node w if:
        //   w not present in openSet
        // OR
        //   tentative gScore is less than previous value
        // w not in openSet

              if (!isInOpenSet(wid)) {
                gScore[wid] = tempScore;
                fScore[wid] = tempScore + heuristic(w);
                addToOpenSet(w, wid);
                cameFrom[wid] = cMin;
                cameFromEdge[wid] = e;
                continue;
              } // w already in openSet, but with greater gScore


              if (tempScore < gScore[wid]) {
                gScore[wid] = tempScore;
                fScore[wid] = tempScore + heuristic(w);
                cameFrom[wid] = cMin;
              }
            } // End of neighbors update

          } // End of main loop
    // If we've reached here, then we've not reached our goal


          return {
            found: false,
            distance: undefined,
            path: undefined,
            steps: steps
          };
        }
      }; // elesfn

      const floydWarshallDefaults = defaults({
        weight: function weight(edge) {
          return 1;
        },
        directed: false
      });
      const elesfn$4 = {
  // Implemented from pseudocode from wikipedia
        floydWarshall: function floydWarshall(options) {
          const cy = this.cy();

          const _floydWarshallDefault = floydWarshallDefaults(options),
            weight = _floydWarshallDefault.weight,
            directed = _floydWarshallDefault.directed;

          const weightFn = weight;

          const _this$byGroup = this.byGroup(),
            nodes = _this$byGroup.nodes,
            edges = _this$byGroup.edges;

          const N = nodes.length;
          const Nsq = N * N;

          const indexOf = function indexOf(node) {
            return nodes.indexOf(node);
          };

          const atIndex = function atIndex(i) {
            return nodes[i];
          }; // Initialize distance matrix


          const dist = new Array(Nsq);

          for (let n = 0; n < Nsq; n++) {
            const j = n % N;
            const i = (n - j) / N;

            if (i === j) {
              dist[n] = 0;
            } else {
              dist[n] = Infinity;
            }
          } // Initialize matrix used for path reconstruction
    // Initialize distance matrix


          const next = new Array(Nsq);
          const edgeNext = new Array(Nsq); // Process edges

          for (let _i = 0; _i < edges.length; _i++) {
            const edge = edges[_i];
            const src = edge.source()[0];
            const tgt = edge.target()[0];

            if (src === tgt) {
              continue;
            } // exclude loops


            const s = indexOf(src);
            const t = indexOf(tgt);
            const st = s * N + t; // source to target index

            const _weight = weightFn(edge); // Check if already process another edge between same 2 nodes


            if (dist[st] > _weight) {
              dist[st] = _weight;
              next[st] = t;
              edgeNext[st] = edge;
            } // If undirected graph, process 'reversed' edge


            if (!directed) {
              const ts = t * N + s; // target to source index

              if (!directed && dist[ts] > _weight) {
                dist[ts] = _weight;
                next[ts] = s;
                edgeNext[ts] = edge;
              }
            }
          } // Main loop


          for (let k = 0; k < N; k++) {
            for (let _i2 = 0; _i2 < N; _i2++) {
              const ik = _i2 * N + k;

              for (let _j = 0; _j < N; _j++) {
                const ij = _i2 * N + _j;
                const kj = k * N + _j;

                if (dist[ik] + dist[kj] < dist[ij]) {
                  dist[ij] = dist[ik] + dist[kj];
                  next[ij] = next[ik];
                }
              }
            }
          }

          const getArgEle = function getArgEle(ele) {
            return (string(ele) ? cy.filter(ele) : ele)[0];
          };

          const indexOfArgEle = function indexOfArgEle(ele) {
            return indexOf(getArgEle(ele));
          };

          const res = {
            distance: function distance(from, to) {
              const i = indexOfArgEle(from);
              const j = indexOfArgEle(to);
              return dist[i * N + j];
            },
            path: function path(from, to) {
              let i = indexOfArgEle(from);
              const j = indexOfArgEle(to);
              const fromNode = atIndex(i);

              if (i === j) {
                return fromNode.collection();
              }

              if (next[i * N + j] == null) {
                return cy.collection();
              }

              const path = cy.collection();
              let prev = i;
              let edge;
              path.merge(fromNode);

              while (i !== j) {
                prev = i;
                i = next[i * N + j];
                edge = edgeNext[prev * N + i];
                path.merge(edge);
                path.merge(atIndex(i));
              }

              return path;
            }
          };
          return res;
        } // floydWarshall

      }; // elesfn

      const bellmanFordDefaults = defaults({
        weight: function weight(edge) {
          return 1;
        },
        directed: false,
        root: null
      });
      const elesfn$5 = {
  // Implemented from pseudocode from wikipedia
        bellmanFord: function bellmanFord(options) {
          const _this = this;

          let _bellmanFordDefaults = bellmanFordDefaults(options),
            weight = _bellmanFordDefaults.weight,
            directed = _bellmanFordDefaults.directed,
            root = _bellmanFordDefaults.root;

          const weightFn = weight;
          const eles = this;
          const cy = this.cy();

          const _this$byGroup = this.byGroup(),
            edges = _this$byGroup.edges,
            nodes = _this$byGroup.nodes;

          const numNodes = nodes.length;
          const infoMap = new Map$1();
          let hasNegativeWeightCycle = false;
          const negativeWeightCycles = [];
          root = cy.collection(root)[0]; // in case selector passed

          edges.unmergeBy(function (edge) {
            return edge.isLoop();
          });
          const numEdges = edges.length;

          const getInfo = function getInfo(node) {
            let obj = infoMap.get(node.id());

            if (!obj) {
              obj = {};
              infoMap.set(node.id(), obj);
            }

            return obj;
          };

          const getNodeFromTo = function getNodeFromTo(to) {
            return (string(to) ? cy.$(to) : to)[0];
          };

          const distanceTo = function distanceTo(to) {
            return getInfo(getNodeFromTo(to)).dist;
          };

          const pathTo = function pathTo(to) {
            const thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;
            const end = getNodeFromTo(to);
            const path = [];
            let node = end;

            for (;;) {
              if (node == null) {
                return _this.spawn();
              }

              const _getInfo = getInfo(node),
                edge = _getInfo.edge,
                pred = _getInfo.pred;

              path.unshift(node[0]);

              if (node.same(thisStart) && path.length > 0) {
                break;
              }

              if (edge != null) {
                path.unshift(edge);
              }

              node = pred;
            }

            return eles.spawn(path);
          }; // Initializations { dist, pred, edge }


          for (let i = 0; i < numNodes; i++) {
            const node = nodes[i];
            const info = getInfo(node);

            if (node.same(root)) {
              info.dist = 0;
            } else {
              info.dist = Infinity;
            }

            info.pred = null;
            info.edge = null;
          } // Edges relaxation


          let replacedEdge = false;

          const checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {
            const dist = info1.dist + weight;

            if (dist < info2.dist && !edge.same(info1.edge)) {
              info2.dist = dist;
              info2.pred = node1;
              info2.edge = edge;
              replacedEdge = true;
            }
          };

          for (let _i = 1; _i < numNodes; _i++) {
            replacedEdge = false;

            for (let e = 0; e < numEdges; e++) {
              const edge = edges[e];
              const src = edge.source();
              const tgt = edge.target();

              const _weight = weightFn(edge);

              const srcInfo = getInfo(src);
              const tgtInfo = getInfo(tgt);
              checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight); // If undirected graph, we need to take into account the 'reverse' edge

              if (!directed) {
                checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);
              }
            }

            if (!replacedEdge) {
              break;
            }
          }

          if (replacedEdge) {
      // Check for negative weight cycles
            for (let _e = 0; _e < numEdges; _e++) {
              const _edge = edges[_e];

              const _src = _edge.source();

              const _tgt = _edge.target();

              const _weight2 = weightFn(_edge);

              const srcDist = getInfo(_src).dist;
              const tgtDist = getInfo(_tgt).dist;

              if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {
                warn('Graph contains a negative weight cycle for Bellman-Ford');
                hasNegativeWeightCycle = true;
                break;
              }
            }
          }

          return {
            distanceTo: distanceTo,
            pathTo: pathTo,
            hasNegativeWeightCycle: hasNegativeWeightCycle,
            negativeWeightCycles: negativeWeightCycles
          };
        } // bellmanFord

      }; // elesfn

      const sqrt2 = Math.sqrt(2); // Function which colapses 2 (meta) nodes into one
// Updates the remaining edge lists
// Receives as a paramater the edge which causes the collapse

      const collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {
        if (remainingEdges.length === 0) {
          error("Karger-Stein must be run on a connected (sub)graph");
        }

        const edgeInfo = remainingEdges[edgeIndex];
        const sourceIn = edgeInfo[1];
        const targetIn = edgeInfo[2];
        const partition1 = nodeMap[sourceIn];
        const partition2 = nodeMap[targetIn];
        const newEdges = remainingEdges; // re-use array
  // Delete all edges between partition1 and partition2

        for (let i = newEdges.length - 1; i >= 0; i--) {
          const edge = newEdges[i];
          const src = edge[1];
          const tgt = edge[2];

          if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {
            newEdges.splice(i, 1);
          }
        } // All edges pointing to partition2 should now point to partition1


        for (let _i = 0; _i < newEdges.length; _i++) {
          const _edge = newEdges[_i];

          if (_edge[1] === partition2) {
      // Check source
            newEdges[_i] = _edge.slice(); // copy

            newEdges[_i][1] = partition1;
          } else if (_edge[2] === partition2) {
      // Check target
            newEdges[_i] = _edge.slice(); // copy

            newEdges[_i][2] = partition1;
          }
        } // Move all nodes from partition2 to partition1


        for (let _i2 = 0; _i2 < nodeMap.length; _i2++) {
          if (nodeMap[_i2] === partition2) {
            nodeMap[_i2] = partition1;
          }
        }

        return newEdges;
      }; // Contracts a graph until we reach a certain number of meta nodes


      const contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {
        while (size > sizeLimit) {
    // Choose an edge randomly
          const edgeIndex = Math.floor(Math.random() * remainingEdges.length); // Collapse graph based on edge

          remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);
          size--;
        }

        return remainingEdges;
      };

      const elesfn$6 = {
  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
        kargerStein: function kargerStein() {
          const _this = this;

          const _this$byGroup = this.byGroup(),
            nodes = _this$byGroup.nodes,
            edges = _this$byGroup.edges;

          edges.unmergeBy(function (edge) {
            return edge.isLoop();
          });
          const numNodes = nodes.length;
          const numEdges = edges.length;
          const numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
          const stopSize = Math.floor(numNodes / sqrt2);

          if (numNodes < 2) {
            error('At least 2 nodes are required for Karger-Stein algorithm');
            return undefined;
          } // Now store edge destination as indexes
    // Format for each edge (edge index, source node index, target node index)


          const edgeIndexes = [];

          for (let i = 0; i < numEdges; i++) {
            const e = edges[i];
            edgeIndexes.push([i, nodes.indexOf(e.source()), nodes.indexOf(e.target())]);
          } // We will store the best cut found here


          let minCutSize = Infinity;
          let minCutEdgeIndexes = [];
          const minCutNodeMap = new Array(numNodes); // Initial meta node partition

          const metaNodeMap = new Array(numNodes);
          const metaNodeMap2 = new Array(numNodes);

          const copyNodesMap = function copyNodesMap(from, to) {
            for (let _i3 = 0; _i3 < numNodes; _i3++) {
              to[_i3] = from[_i3];
            }
          }; // Main loop


          for (let iter = 0; iter <= numIter; iter++) {
      // Reset meta node partition
            for (let _i4 = 0; _i4 < numNodes; _i4++) {
              metaNodeMap[_i4] = _i4;
            } // Contract until stop point (stopSize nodes)


            const edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);
            const edgesState2 = edgesState.slice(); // copy
      // Create a copy of the colapsed nodes state

            copyNodesMap(metaNodeMap, metaNodeMap2); // Run 2 iterations starting in the stop state

            const res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
            const res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2); // Is any of the 2 results the best cut so far?

            if (res1.length <= res2.length && res1.length < minCutSize) {
              minCutSize = res1.length;
              minCutEdgeIndexes = res1;
              copyNodesMap(metaNodeMap, minCutNodeMap);
            } else if (res2.length <= res1.length && res2.length < minCutSize) {
              minCutSize = res2.length;
              minCutEdgeIndexes = res2;
              copyNodesMap(metaNodeMap2, minCutNodeMap);
            }
          } // end of main loop
    // Construct result


          const cut = this.spawn(minCutEdgeIndexes.map(function (e) {
            return edges[e[0]];
          }));
          const partition1 = this.spawn();
          const partition2 = this.spawn(); // traverse metaNodeMap for best cut

          const witnessNodePartition = minCutNodeMap[0];

          for (let _i5 = 0; _i5 < minCutNodeMap.length; _i5++) {
            const partitionId = minCutNodeMap[_i5];
            const node = nodes[_i5];

            if (partitionId === witnessNodePartition) {
              partition1.merge(node);
            } else {
              partition2.merge(node);
            }
          } // construct components corresponding to each disjoint subset of nodes


          const constructComponent = function constructComponent(subset) {
            const component = _this.spawn();

            subset.forEach(function (node) {
              component.merge(node);
              node.connectedEdges().forEach(function (edge) {
          // ensure edge is within calling collection and edge is not in cut
                if (_this.contains(edge) && !cut.contains(edge)) {
                  component.merge(edge);
                }
              });
            });
            return component;
          };

          const components = [constructComponent(partition1), constructComponent(partition2)];
          const ret = {
            cut: cut,
            components: components,
      // n.b. partitions are included to be compatible with the old api spec
      // (could be removed in a future major version)
            partition1: partition1,
            partition2: partition2
          };
          return ret;
        }
      }; // elesfn

      const copyPosition = function copyPosition(p) {
        return {
          x: p.x,
          y: p.y
        };
      };
      const modelToRenderedPosition = function modelToRenderedPosition(p, zoom, pan) {
        return {
          x: p.x * zoom + pan.x,
          y: p.y * zoom + pan.y
        };
      };
      const renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {
        return {
          x: (p.x - pan.x) / zoom,
          y: (p.y - pan.y) / zoom
        };
      };
      const array2point = function array2point(arr) {
        return {
          x: arr[0],
          y: arr[1]
        };
      };
      const min = function min(arr) {
        const begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        const end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
        let min = Infinity;

        for (let i = begin; i < end; i++) {
          const val = arr[i];

          if (isFinite(val)) {
            min = Math.min(val, min);
          }
        }

        return min;
      };
      const max = function max(arr) {
        const begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        const end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
        let max = -Infinity;

        for (let i = begin; i < end; i++) {
          const val = arr[i];

          if (isFinite(val)) {
            max = Math.max(val, max);
          }
        }

        return max;
      };
      const mean = function mean(arr) {
        const begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        const end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
        let total = 0;
        let n = 0;

        for (let i = begin; i < end; i++) {
          const val = arr[i];

          if (isFinite(val)) {
            total += val;
            n++;
          }
        }

        return total / n;
      };
      const median = function median(arr) {
        const begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        const end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
        const copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        const includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;

        if (copy) {
          arr = arr.slice(begin, end);
        } else {
          if (end < arr.length) {
            arr.splice(end, arr.length - end);
          }

          if (begin > 0) {
            arr.splice(0, begin);
          }
        } // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start


        let off = 0; // offset from non-finite values

        for (let i = arr.length - 1; i >= 0; i--) {
          const v = arr[i];

          if (includeHoles) {
            if (!isFinite(v)) {
              arr[i] = -Infinity;
              off++;
            }
          } else {
      // just remove it if we don't want to consider holes
            arr.splice(i, 1);
          }
        }

        if (sort) {
          arr.sort(function (a, b) {
            return a - b;
          }); // requires copy = true if you don't want to change the orig
        }

        const len = arr.length;
        const mid = Math.floor(len / 2);

        if (len % 2 !== 0) {
          return arr[mid + 1 + off];
        } else {
          return (arr[mid - 1 + off] + arr[mid + off]) / 2;
        }
      };
      const deg2rad = function deg2rad(deg) {
        return Math.PI * deg / 180;
      };
      const getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {
        return Math.atan2(dispY, dispX) - Math.PI / 2;
      };
      const log2 = Math.log2 || function (n) {
        return Math.log(n) / Math.log(2);
      };
      const signum = function signum(x) {
        if (x > 0) {
          return 1;
        } else if (x < 0) {
          return -1;
        } else {
          return 0;
        }
      };
      const dist = function dist(p1, p2) {
        return Math.sqrt(sqdist(p1, p2));
      };
      var sqdist = function sqdist(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return dx * dx + dy * dy;
      };
      const inPlaceSumNormalize = function inPlaceSumNormalize(v) {
        const length = v.length; // First, get sum of all elements

        let total = 0;

        for (let i = 0; i < length; i++) {
          total += v[i];
        } // Now, divide each by the sum of all elements


        for (let _i = 0; _i < length; _i++) {
          v[_i] = v[_i] / total;
        }

        return v;
      };

      const qbezierAt = function qbezierAt(p0, p1, p2, t) {
        return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
      };
      const qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {
        return {
          x: qbezierAt(p0.x, p1.x, p2.x, t),
          y: qbezierAt(p0.y, p1.y, p2.y, t)
        };
      };
      const lineAt = function lineAt(p0, p1, t, d) {
        const vec = {
          x: p1.x - p0.x,
          y: p1.y - p0.y
        };
        const vecDist = dist(p0, p1);
        const normVec = {
          x: vec.x / vecDist,
          y: vec.y / vecDist
        };
        t = t == null ? 0 : t;
        d = d != null ? d : t * vecDist;
        return {
          x: p0.x + normVec.x * d,
          y: p0.y + normVec.y * d
        };
      };
      const bound = function bound(min, val, max) {
        return Math.max(min, Math.min(max, val));
      }; // makes a full bb (x1, y1, x2, y2, w, h) from implicit params

      const makeBoundingBox = function makeBoundingBox(bb) {
        if (bb == null) {
          return {
            x1: Infinity,
            y1: Infinity,
            x2: -Infinity,
            y2: -Infinity,
            w: 0,
            h: 0
          };
        } else if (bb.x1 != null && bb.y1 != null) {
          if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {
            return {
              x1: bb.x1,
              y1: bb.y1,
              x2: bb.x2,
              y2: bb.y2,
              w: bb.x2 - bb.x1,
              h: bb.y2 - bb.y1
            };
          } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {
            return {
              x1: bb.x1,
              y1: bb.y1,
              x2: bb.x1 + bb.w,
              y2: bb.y1 + bb.h,
              w: bb.w,
              h: bb.h
            };
          }
        }
      };
      const copyBoundingBox = function copyBoundingBox(bb) {
        return {
          x1: bb.x1,
          x2: bb.x2,
          w: bb.w,
          y1: bb.y1,
          y2: bb.y2,
          h: bb.h
        };
      };
      const clearBoundingBox = function clearBoundingBox(bb) {
        bb.x1 = Infinity;
        bb.y1 = Infinity;
        bb.x2 = -Infinity;
        bb.y2 = -Infinity;
        bb.w = 0;
        bb.h = 0;
      };
      const updateBoundingBox = function updateBoundingBox(bb1, bb2) {
  // update bb1 with bb2 bounds
        bb1.x1 = Math.min(bb1.x1, bb2.x1);
        bb1.x2 = Math.max(bb1.x2, bb2.x2);
        bb1.w = bb1.x2 - bb1.x1;
        bb1.y1 = Math.min(bb1.y1, bb2.y1);
        bb1.y2 = Math.max(bb1.y2, bb2.y2);
        bb1.h = bb1.y2 - bb1.y1;
      };
      const expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {
        bb.x1 = Math.min(bb.x1, x);
        bb.x2 = Math.max(bb.x2, x);
        bb.w = bb.x2 - bb.x1;
        bb.y1 = Math.min(bb.y1, y);
        bb.y2 = Math.max(bb.y2, y);
        bb.h = bb.y2 - bb.y1;
      };
      const expandBoundingBox = function expandBoundingBox(bb) {
        const padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        bb.x1 -= padding;
        bb.x2 += padding;
        bb.y1 -= padding;
        bb.y2 += padding;
        bb.w = bb.x2 - bb.x1;
        bb.h = bb.y2 - bb.y1;
        return bb;
      };
      const expandBoundingBoxSides = function expandBoundingBoxSides(bb) {
        const padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0];
        let top, right, bottom, left;

        if (padding.length === 1) {
          top = right = bottom = left = padding[0];
        } else if (padding.length === 2) {
          top = bottom = padding[0];
          left = right = padding[1];
        } else if (padding.length === 4) {
          const _padding = _slicedToArray(padding, 4);

          top = _padding[0];
          right = _padding[1];
          bottom = _padding[2];
          left = _padding[3];
        }

        bb.x1 -= left;
        bb.x2 += right;
        bb.y1 -= top;
        bb.y2 += bottom;
        bb.w = bb.x2 - bb.x1;
        bb.h = bb.y2 - bb.y1;
        return bb;
      };

      const assignBoundingBox = function assignBoundingBox(bb1, bb2) {
        bb1.x1 = bb2.x1;
        bb1.y1 = bb2.y1;
        bb1.x2 = bb2.x2;
        bb1.y2 = bb2.y2;
        bb1.w = bb1.x2 - bb1.x1;
        bb1.h = bb1.y2 - bb1.y1;
      };
      const boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {
  // case: one bb to right of other
        if (bb1.x1 > bb2.x2) {
          return false;
        }

        if (bb2.x1 > bb1.x2) {
          return false;
        } // case: one bb to left of other


        if (bb1.x2 < bb2.x1) {
          return false;
        }

        if (bb2.x2 < bb1.x1) {
          return false;
        } // case: one bb above other


        if (bb1.y2 < bb2.y1) {
          return false;
        }

        if (bb2.y2 < bb1.y1) {
          return false;
        } // case: one bb below other


        if (bb1.y1 > bb2.y2) {
          return false;
        }

        if (bb2.y1 > bb1.y2) {
          return false;
        } // otherwise, must have some overlap


        return true;
      };
      const inBoundingBox = function inBoundingBox(bb, x, y) {
        return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
      };
      const pointInBoundingBox = function pointInBoundingBox(bb, pt) {
        return inBoundingBox(bb, pt.x, pt.y);
      };
      const boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {
        return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);
      };
      const roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {
        const cornerRadius = getRoundRectangleRadius(width, height);
        const halfWidth = width / 2;
        const halfHeight = height / 2; // Check intersections with straight line segments

        let straightLineIntersections; // Top segment, left to right

        {
          const topStartX = nodeX - halfWidth + cornerRadius - padding;
          const topStartY = nodeY - halfHeight - padding;
          const topEndX = nodeX + halfWidth - cornerRadius + padding;
          const topEndY = topStartY;
          straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

          if (straightLineIntersections.length > 0) {
            return straightLineIntersections;
          }
        } // Right segment, top to bottom

        {
          const rightStartX = nodeX + halfWidth + padding;
          const rightStartY = nodeY - halfHeight + cornerRadius - padding;
          const rightEndX = rightStartX;
          const rightEndY = nodeY + halfHeight - cornerRadius + padding;
          straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);

          if (straightLineIntersections.length > 0) {
            return straightLineIntersections;
          }
        } // Bottom segment, left to right

        {
          const bottomStartX = nodeX - halfWidth + cornerRadius - padding;
          const bottomStartY = nodeY + halfHeight + padding;
          const bottomEndX = nodeX + halfWidth - cornerRadius + padding;
          const bottomEndY = bottomStartY;
          straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);

          if (straightLineIntersections.length > 0) {
            return straightLineIntersections;
          }
        } // Left segment, top to bottom

        {
          const leftStartX = nodeX - halfWidth - padding;
          const leftStartY = nodeY - halfHeight + cornerRadius - padding;
          const leftEndX = leftStartX;
          const leftEndY = nodeY + halfHeight - cornerRadius + padding;
          straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);

          if (straightLineIntersections.length > 0) {
            return straightLineIntersections;
          }
        } // Check intersections with arc segments

        let arcIntersections; // Top Left

        {
          const topLeftCenterX = nodeX - halfWidth + cornerRadius;
          const topLeftCenterY = nodeY - halfHeight + cornerRadius;
          arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

          if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {
            return [arcIntersections[0], arcIntersections[1]];
          }
        } // Top Right

        {
          const topRightCenterX = nodeX + halfWidth - cornerRadius;
          const topRightCenterY = nodeY - halfHeight + cornerRadius;
          arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

          if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {
            return [arcIntersections[0], arcIntersections[1]];
          }
        } // Bottom Right

        {
          const bottomRightCenterX = nodeX + halfWidth - cornerRadius;
          const bottomRightCenterY = nodeY + halfHeight - cornerRadius;
          arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

          if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {
            return [arcIntersections[0], arcIntersections[1]];
          }
        } // Bottom Left

        {
          const bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
          const bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
          arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

          if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {
            return [arcIntersections[0], arcIntersections[1]];
          }
        }
        return []; // if nothing
      };
      const inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {
        const t = tolerance;
        const x1 = Math.min(lx1, lx2);
        const x2 = Math.max(lx1, lx2);
        const y1 = Math.min(ly1, ly2);
        const y2 = Math.max(ly1, ly2);
        return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;
      };
      const inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {
        const bb = {
          x1: Math.min(x1, x3, x2) - tolerance,
          x2: Math.max(x1, x3, x2) + tolerance,
          y1: Math.min(y1, y3, y2) - tolerance,
          y2: Math.max(y1, y3, y2) + tolerance
        }; // if outside the rough bounding box for the bezier, then it can't be a hit

        if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {
    // console.log('bezier out of rough bb')
          return false;
        } else {
    // console.log('do more expensive check');
          return true;
        }
      };
      const solveQuadratic = function solveQuadratic(a, b, c, val) {
        c -= val;
        const r = b * b - 4 * a * c;

        if (r < 0) {
          return [];
        }

        const sqrtR = Math.sqrt(r);
        const denom = 2 * a;
        const root1 = (-b + sqrtR) / denom;
        const root2 = (-b - sqrtR) / denom;
        return [root1, root2];
      };
      const solveCubic = function solveCubic(a, b, c, d, result) {
  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
  // r is the real component, i is the imaginary component
  // An implementation of the Cardano method from the year 1545
  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots
        const epsilon = 0.00001; // avoid division by zero while keeping the overall expression close in value

        if (a === 0) {
          a = epsilon;
        }

        b /= a;
        c /= a;
        d /= a;
        let discriminant, q, r, dum1, s, t, term1, r13;
        q = (3.0 * c - b * b) / 9.0;
        r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
        r /= 54.0;
        discriminant = q * q * q + r * r;
        result[1] = 0;
        term1 = b / 3.0;

        if (discriminant > 0) {
          s = r + Math.sqrt(discriminant);
          s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);
          t = r - Math.sqrt(discriminant);
          t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);
          result[0] = -term1 + s + t;
          term1 += (s + t) / 2.0;
          result[4] = result[2] = -term1;
          term1 = Math.sqrt(3.0) * (-t + s) / 2;
          result[3] = term1;
          result[5] = -term1;
          return;
        }

        result[5] = result[3] = 0;

        if (discriminant === 0) {
          r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);
          result[0] = -term1 + 2.0 * r13;
          result[4] = result[2] = -(r13 + term1);
          return;
        }

        q = -q;
        dum1 = q * q * q;
        dum1 = Math.acos(r / Math.sqrt(dum1));
        r13 = 2.0 * Math.sqrt(q);
        result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
        result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
        result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);
        return;
      };
      const sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {
  // Find minimum distance by using the minimum of the distance
  // function between the given point and the curve
  // This gives the coefficients of the resulting cubic equation
  // whose roots tell us where a possible minimum is
  // (Coefficients are divided by 4)
        const a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;
        const b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;
        const c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;
        const d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y; // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);

        const roots = []; // Use the cubic solving algorithm

        solveCubic(a, b, c, d, roots);
        const zeroThreshold = 0.0000001;
        const params = [];

        for (let index = 0; index < 6; index += 2) {
          if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {
            params.push(roots[index]);
          }
        }

        params.push(1.0);
        params.push(0.0);
        let minDistanceSquared = -1;
        let curX, curY, distSquared;

        for (let i = 0; i < params.length; i++) {
          curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;
          curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;
          distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2); // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));

          if (minDistanceSquared >= 0) {
            if (distSquared < minDistanceSquared) {
              minDistanceSquared = distSquared;
            }
          } else {
            minDistanceSquared = distSquared;
          }
        }

        return minDistanceSquared;
      };
      const sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {
        const offset = [x - x1, y - y1];
        const line = [x2 - x1, y2 - y1];
        const lineSq = line[0] * line[0] + line[1] * line[1];
        const hypSq = offset[0] * offset[0] + offset[1] * offset[1];
        const dotProduct = offset[0] * line[0] + offset[1] * line[1];
        const adjSq = dotProduct * dotProduct / lineSq;

        if (dotProduct < 0) {
          return hypSq;
        }

        if (adjSq > lineSq) {
          return (x - x2) * (x - x2) + (y - y2) * (y - y2);
        }

        return hypSq - adjSq;
      };
      const pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {
        let x1, y1, x2, y2;
        let y3; // Intersect with vertical line through (x, y)

        let up = 0; // let down = 0;

        for (let i = 0; i < points.length / 2; i++) {
          x1 = points[i * 2];
          y1 = points[i * 2 + 1];

          if (i + 1 < points.length / 2) {
            x2 = points[(i + 1) * 2];
            y2 = points[(i + 1) * 2 + 1];
          } else {
            x2 = points[(i + 1 - points.length / 2) * 2];
            y2 = points[(i + 1 - points.length / 2) * 2 + 1];
          }

          if (x1 == x && x2 == x) ; else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {
            y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;

            if (y3 > y) {
              up++;
            } // if( y3 < y ){
      // down++;
      // }

          } else {
            continue;
          }
        }

        if (up % 2 === 0) {
          return false;
        } else {
          return true;
        }
      };
      const pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {
        const transformedPoints = new Array(basePoints.length); // Gives negative angle

        let angle;

        if (direction[0] != null) {
          angle = Math.atan(direction[1] / direction[0]);

          if (direction[0] < 0) {
            angle = angle + Math.PI / 2;
          } else {
            angle = -angle - Math.PI / 2;
          }
        } else {
          angle = direction;
        }

        const cos = Math.cos(-angle);
        const sin = Math.sin(-angle); //    console.log("base: " + basePoints);

        for (let i = 0; i < transformedPoints.length / 2; i++) {
          transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);
          transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);
          transformedPoints[i * 2] += centerX;
          transformedPoints[i * 2 + 1] += centerY;
        }

        let points;

        if (padding > 0) {
          const expandedLineSet = expandPolygon(transformedPoints, -padding);
          points = joinLines(expandedLineSet);
        } else {
          points = transformedPoints;
        }

        return pointInsidePolygonPoints(x, y, points);
      };
      const pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height) {
        const cutPolygonPoints = new Array(basePoints.length);
        const halfW = width / 2;
        const halfH = height / 2;
        const cornerRadius = getRoundPolygonRadius(width, height);
        const squaredCornerRadius = cornerRadius * cornerRadius;

        for (let i = 0; i < basePoints.length / 4; i++) {
          let sourceUv = void 0,
            destUv = void 0;

          if (i === 0) {
            sourceUv = basePoints.length - 2;
          } else {
            sourceUv = i * 4 - 2;
          }

          destUv = i * 4 + 2;
          const px = centerX + halfW * basePoints[i * 4];
          const py = centerY + halfH * basePoints[i * 4 + 1];
          const cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
          const offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
          const cp0x = px - offset * basePoints[sourceUv];
          const cp0y = py - offset * basePoints[sourceUv + 1];
          const cp1x = px + offset * basePoints[destUv];
          const cp1y = py + offset * basePoints[destUv + 1];
          cutPolygonPoints[i * 4] = cp0x;
          cutPolygonPoints[i * 4 + 1] = cp0y;
          cutPolygonPoints[i * 4 + 2] = cp1x;
          cutPolygonPoints[i * 4 + 3] = cp1y;
          let orthx = basePoints[sourceUv + 1];
          let orthy = -basePoints[sourceUv];
          const cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];

          if (cosAlpha < 0) {
            orthx *= -1;
            orthy *= -1;
          }

          const cx = cp0x + orthx * cornerRadius;
          const cy = cp0y + orthy * cornerRadius;
          const squaredDistance = Math.pow(cx - x, 2) + Math.pow(cy - y, 2);

          if (squaredDistance <= squaredCornerRadius) {
            return true;
          }
        }

        return pointInsidePolygonPoints(x, y, cutPolygonPoints);
      };
      var joinLines = function joinLines(lineSet) {
        const vertices = new Array(lineSet.length / 2);
        let currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
        let nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;

        for (let i = 0; i < lineSet.length / 4; i++) {
          currentLineStartX = lineSet[i * 4];
          currentLineStartY = lineSet[i * 4 + 1];
          currentLineEndX = lineSet[i * 4 + 2];
          currentLineEndY = lineSet[i * 4 + 3];

          if (i < lineSet.length / 4 - 1) {
            nextLineStartX = lineSet[(i + 1) * 4];
            nextLineStartY = lineSet[(i + 1) * 4 + 1];
            nextLineEndX = lineSet[(i + 1) * 4 + 2];
            nextLineEndY = lineSet[(i + 1) * 4 + 3];
          } else {
            nextLineStartX = lineSet[0];
            nextLineStartY = lineSet[1];
            nextLineEndX = lineSet[2];
            nextLineEndY = lineSet[3];
          }

          const intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);
          vertices[i * 2] = intersection[0];
          vertices[i * 2 + 1] = intersection[1];
        }

        return vertices;
      };
      var expandPolygon = function expandPolygon(points, pad) {
        const expandedLineSet = new Array(points.length * 2);
        let currentPointX, currentPointY, nextPointX, nextPointY;

        for (let i = 0; i < points.length / 2; i++) {
          currentPointX = points[i * 2];
          currentPointY = points[i * 2 + 1];

          if (i < points.length / 2 - 1) {
            nextPointX = points[(i + 1) * 2];
            nextPointY = points[(i + 1) * 2 + 1];
          } else {
            nextPointX = points[0];
            nextPointY = points[1];
          } // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]
    // Assume CCW polygon winding


          const offsetX = nextPointY - currentPointY;
          const offsetY = -(nextPointX - currentPointX); // Normalize

          const offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
          const normalizedOffsetX = offsetX / offsetLength;
          const normalizedOffsetY = offsetY / offsetLength;
          expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
          expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
          expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
          expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
        }

        return expandedLineSet;
      };
      const intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {
        let dispX = centerX - x;
        let dispY = centerY - y;
        dispX /= ellipseWradius;
        dispY /= ellipseHradius;
        const len = Math.sqrt(dispX * dispX + dispY * dispY);
        const newLength = len - 1;

        if (newLength < 0) {
          return [];
        }

        const lenProportion = newLength / len;
        return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
      };
      const checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {
        x -= centerX;
        y -= centerY;
        x /= width / 2 + padding;
        y /= height / 2 + padding;
        return x * x + y * y <= 1;
      }; // Returns intersections of increasing distance from line's start point

      var intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {
  // Calculate d, direction vector of line
        const d = [x2 - x1, y2 - y1]; // Direction vector of line

        const f = [x1 - centerX, y1 - centerY];
        const a = d[0] * d[0] + d[1] * d[1];
        const b = 2 * (f[0] * d[0] + f[1] * d[1]);
        const c = f[0] * f[0] + f[1] * f[1] - radius * radius;
        const discriminant = b * b - 4 * a * c;

        if (discriminant < 0) {
          return [];
        }

        const t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
        const t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
        const tMin = Math.min(t1, t2);
        const tMax = Math.max(t1, t2);
        const inRangeParams = [];

        if (tMin >= 0 && tMin <= 1) {
          inRangeParams.push(tMin);
        }

        if (tMax >= 0 && tMax <= 1) {
          inRangeParams.push(tMax);
        }

        if (inRangeParams.length === 0) {
          return [];
        }

        const nearIntersectionX = inRangeParams[0] * d[0] + x1;
        const nearIntersectionY = inRangeParams[0] * d[1] + y1;

        if (inRangeParams.length > 1) {
          if (inRangeParams[0] == inRangeParams[1]) {
            return [nearIntersectionX, nearIntersectionY];
          } else {
            const farIntersectionX = inRangeParams[1] * d[0] + x1;
            const farIntersectionY = inRangeParams[1] * d[1] + y1;
            return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
          }
        } else {
          return [nearIntersectionX, nearIntersectionY];
        }
      };
      const midOfThree = function midOfThree(a, b, c) {
        if (b <= a && a <= c || c <= a && a <= b) {
          return a;
        } else if (a <= b && b <= c || c <= b && b <= a) {
          return b;
        } else {
          return c;
        }
      }; // (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)

      var finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
        const dx13 = x1 - x3;
        const dx21 = x2 - x1;
        const dx43 = x4 - x3;
        const dy13 = y1 - y3;
        const dy21 = y2 - y1;
        const dy43 = y4 - y3;
        const ua_t = dx43 * dy13 - dy43 * dx13;
        const ub_t = dx21 * dy13 - dy21 * dx13;
        const u_b = dy43 * dx21 - dx43 * dy21;

        if (u_b !== 0) {
          const ua = ua_t / u_b;
          const ub = ub_t / u_b;
          const flptThreshold = 0.001;

          const _min = 0 - flptThreshold;

          const _max = 1 + flptThreshold;

          if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {
            return [x1 + ua * dx21, y1 + ua * dy21];
          } else {
            if (!infiniteLines) {
              return [];
            } else {
              return [x1 + ua * dx21, y1 + ua * dy21];
            }
          }
        } else {
          if (ua_t === 0 || ub_t === 0) {
      // Parallel, coincident lines. Check if overlap
      // Check endpoint of second line
            if (midOfThree(x1, x2, x4) === x4) {
              return [x4, y4];
            } // Check start point of second line


            if (midOfThree(x1, x2, x3) === x3) {
              return [x3, y3];
            } // Endpoint of first line


            if (midOfThree(x3, x4, x2) === x2) {
              return [x2, y2];
            }

            return [];
          } else {
      // Parallel, non-coincident
            return [];
          }
        }
      }; // math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )
// intersect a node polygon (pts transformed)
//
// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )
// intersect the points (no transform)

      const polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {
        const intersections = [];
        let intersection;
        const transformedPoints = new Array(basePoints.length);
        let doTransform = true;

        if (width == null) {
          doTransform = false;
        }

        let points;

        if (doTransform) {
          for (let i = 0; i < transformedPoints.length / 2; i++) {
            transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
            transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
          }

          if (padding > 0) {
            const expandedLineSet = expandPolygon(transformedPoints, -padding);
            points = joinLines(expandedLineSet);
          } else {
            points = transformedPoints;
          }
        } else {
          points = basePoints;
        }

        let currentX, currentY, nextX, nextY;

        for (let _i2 = 0; _i2 < points.length / 2; _i2++) {
          currentX = points[_i2 * 2];
          currentY = points[_i2 * 2 + 1];

          if (_i2 < points.length / 2 - 1) {
            nextX = points[(_i2 + 1) * 2];
            nextY = points[(_i2 + 1) * 2 + 1];
          } else {
            nextX = points[0];
            nextY = points[1];
          }

          intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);

          if (intersection.length !== 0) {
            intersections.push(intersection[0], intersection[1]);
          }
        }

        return intersections;
      };
      const roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {
        const intersections = [];
        let intersection;
        const lines = new Array(basePoints.length);
        const halfW = width / 2;
        const halfH = height / 2;
        const cornerRadius = getRoundPolygonRadius(width, height);

        for (let i = 0; i < basePoints.length / 4; i++) {
          let sourceUv = void 0,
            destUv = void 0;

          if (i === 0) {
            sourceUv = basePoints.length - 2;
          } else {
            sourceUv = i * 4 - 2;
          }

          destUv = i * 4 + 2;
          const px = centerX + halfW * basePoints[i * 4];
          const py = centerY + halfH * basePoints[i * 4 + 1];
          const cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
          const offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
          const cp0x = px - offset * basePoints[sourceUv];
          const cp0y = py - offset * basePoints[sourceUv + 1];
          const cp1x = px + offset * basePoints[destUv];
          const cp1y = py + offset * basePoints[destUv + 1];

          if (i === 0) {
            lines[basePoints.length - 2] = cp0x;
            lines[basePoints.length - 1] = cp0y;
          } else {
            lines[i * 4 - 2] = cp0x;
            lines[i * 4 - 1] = cp0y;
          }

          lines[i * 4] = cp1x;
          lines[i * 4 + 1] = cp1y;
          let orthx = basePoints[sourceUv + 1];
          let orthy = -basePoints[sourceUv];
          const cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];

          if (cosAlpha < 0) {
            orthx *= -1;
            orthy *= -1;
          }

          const cx = cp0x + orthx * cornerRadius;
          const cy = cp0y + orthy * cornerRadius;
          intersection = intersectLineCircle(x, y, centerX, centerY, cx, cy, cornerRadius);

          if (intersection.length !== 0) {
            intersections.push(intersection[0], intersection[1]);
          }
        }

        for (let _i3 = 0; _i3 < lines.length / 4; _i3++) {
          intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[_i3 * 4], lines[_i3 * 4 + 1], lines[_i3 * 4 + 2], lines[_i3 * 4 + 3], false);

          if (intersection.length !== 0) {
            intersections.push(intersection[0], intersection[1]);
          }
        }

        if (intersections.length > 2) {
          const lowestIntersection = [intersections[0], intersections[1]];
          let lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);

          for (let _i4 = 1; _i4 < intersections.length / 2; _i4++) {
            const squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);

            if (squaredDistance <= lowestSquaredDistance) {
              lowestIntersection[0] = intersections[_i4 * 2];
              lowestIntersection[1] = intersections[_i4 * 2 + 1];
              lowestSquaredDistance = squaredDistance;
            }
          }

          return lowestIntersection;
        }

        return intersections;
      };
      const shortenIntersection = function shortenIntersection(intersection, offset, amount) {
        const disp = [intersection[0] - offset[0], intersection[1] - offset[1]];
        const length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
        let lenRatio = (length - amount) / length;

        if (lenRatio < 0) {
          lenRatio = 0.00001;
        }

        return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
      };
      const generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {
        let points = generateUnitNgonPoints(sides, rotationRadians);
        points = fitPolygonToSquare(points);
        return points;
      };
      var fitPolygonToSquare = function fitPolygonToSquare(points) {
        let x, y;
        const sides = points.length / 2;
        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;

        for (let i = 0; i < sides; i++) {
          x = points[2 * i];
          y = points[2 * i + 1];
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        } // stretch factors


        const sx = 2 / (maxX - minX);
        const sy = 2 / (maxY - minY);

        for (let _i5 = 0; _i5 < sides; _i5++) {
          x = points[2 * _i5] = points[2 * _i5] * sx;
          y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }

        if (minY < -1) {
          for (let _i6 = 0; _i6 < sides; _i6++) {
            y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);
          }
        }

        return points;
      };
      var generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {
        const increment = 1.0 / sides * 2 * Math.PI;
        let startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
        startAngle += rotationRadians;
        const points = new Array(sides * 2);
        let currentAngle;

        for (let i = 0; i < sides; i++) {
          currentAngle = i * increment + startAngle;
          points[2 * i] = Math.cos(currentAngle); // x

          points[2 * i + 1] = Math.sin(-currentAngle); // y
        }

        return points;
      }; // Set the default radius, unless half of width or height is smaller than default

      var getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {
        return Math.min(width / 4, height / 4, 8);
      }; // Set the default radius

      var getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {
        return Math.min(width / 10, height / 10, 8);
      };
      const getCutRectangleCornerLength = function getCutRectangleCornerLength() {
        return 8;
      };
      const bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {
        return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];
      }; // get curve width, height, and control point position offsets as a percentage of node height / width

      const getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {
        return {
          heightOffset: Math.min(15, 0.05 * height),
          widthOffset: Math.min(100, 0.25 * width),
          ctrlPtOffsetPct: 0.05
        };
      };

      const pageRankDefaults = defaults({
        dampingFactor: 0.8,
        precision: 0.000001,
        iterations: 200,
        weight: function weight(edge) {
          return 1;
        }
      });
      const elesfn$7 = {
        pageRank: function pageRank(options) {
          const _pageRankDefaults = pageRankDefaults(options),
            dampingFactor = _pageRankDefaults.dampingFactor,
            precision = _pageRankDefaults.precision,
            iterations = _pageRankDefaults.iterations,
            weight = _pageRankDefaults.weight;

          const cy = this._private.cy;

          const _this$byGroup = this.byGroup(),
            nodes = _this$byGroup.nodes,
            edges = _this$byGroup.edges;

          const numNodes = nodes.length;
          const numNodesSqd = numNodes * numNodes;
          const numEdges = edges.length; // Construct transposed adjacency matrix
    // First lets have a zeroed matrix of the right size
    // We'll also keep track of the sum of each column

          const matrix = new Array(numNodesSqd);
          const columnSum = new Array(numNodes);
          const additionalProb = (1 - dampingFactor) / numNodes; // Create null matrix

          for (let i = 0; i < numNodes; i++) {
            for (let j = 0; j < numNodes; j++) {
              const n = i * numNodes + j;
              matrix[n] = 0;
            }

            columnSum[i] = 0;
          } // Now, process edges


          for (let _i = 0; _i < numEdges; _i++) {
            const edge = edges[_i];
            const srcId = edge.data('source');
            const tgtId = edge.data('target'); // Don't include loops in the matrix

            if (srcId === tgtId) {
              continue;
            }

            const s = nodes.indexOfId(srcId);
            const t = nodes.indexOfId(tgtId);
            const w = weight(edge);

            const _n = t * numNodes + s; // Update matrix


            matrix[_n] += w; // Update column sum

            columnSum[s] += w;
          } // Add additional probability based on damping factor
    // Also, take into account columns that have sum = 0


          const p = 1.0 / numNodes + additionalProb; // Shorthand
    // Traverse matrix, column by column

          for (let _j = 0; _j < numNodes; _j++) {
            if (columnSum[_j] === 0) {
        // No 'links' out from node jth, assume equal probability for each possible node
              for (let _i2 = 0; _i2 < numNodes; _i2++) {
                const _n2 = _i2 * numNodes + _j;

                matrix[_n2] = p;
              }
            } else {
        // Node jth has outgoing link, compute normalized probabilities
              for (let _i3 = 0; _i3 < numNodes; _i3++) {
                const _n3 = _i3 * numNodes + _j;

                matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;
              }
            }
          } // Compute dominant eigenvector using power method


          let eigenvector = new Array(numNodes);
          let temp = new Array(numNodes);
          let previous; // Start with a vector of all 1's
    // Also, initialize a null vector which will be used as shorthand

          for (let _i4 = 0; _i4 < numNodes; _i4++) {
            eigenvector[_i4] = 1;
          }

          for (let iter = 0; iter < iterations; iter++) {
      // Temp array with all 0's
            for (let _i5 = 0; _i5 < numNodes; _i5++) {
              temp[_i5] = 0;
            } // Multiply matrix with previous result


            for (let _i6 = 0; _i6 < numNodes; _i6++) {
              for (let _j2 = 0; _j2 < numNodes; _j2++) {
                const _n4 = _i6 * numNodes + _j2;

                temp[_i6] += matrix[_n4] * eigenvector[_j2];
              }
            }

            inPlaceSumNormalize(temp);
            previous = eigenvector;
            eigenvector = temp;
            temp = previous;
            let diff = 0; // Compute difference (squared module) of both vectors

            for (let _i7 = 0; _i7 < numNodes; _i7++) {
              const delta = previous[_i7] - eigenvector[_i7];
              diff += delta * delta;
            } // If difference is less than the desired threshold, stop iterating


            if (diff < precision) {
              break;
            }
          } // Construct result


          const res = {
            rank: function rank(node) {
              node = cy.collection(node)[0];
              return eigenvector[nodes.indexOf(node)];
            }
          };
          return res;
        } // pageRank

      }; // elesfn

      const defaults$1 = defaults({
        root: null,
        weight: function weight(edge) {
          return 1;
        },
        directed: false,
        alpha: 0
      });
      const elesfn$8 = {
        degreeCentralityNormalized: function degreeCentralityNormalized(options) {
          options = defaults$1(options);
          const cy = this.cy();
          const nodes = this.nodes();
          const numNodes = nodes.length;

          if (!options.directed) {
            const degrees = {};
            let maxDegree = 0;

            for (let i = 0; i < numNodes; i++) {
              const node = nodes[i]; // add current node to the current options object and call degreeCentrality

              options.root = node;
              const currDegree = this.degreeCentrality(options);

              if (maxDegree < currDegree.degree) {
                maxDegree = currDegree.degree;
              }

              degrees[node.id()] = currDegree.degree;
            }

            return {
              degree: function degree(node) {
                if (maxDegree === 0) {
                  return 0;
                }

                if (string(node)) {
            // from is a selector string
                  node = cy.filter(node);
                }

                return degrees[node.id()] / maxDegree;
              }
            };
          } else {
            const indegrees = {};
            const outdegrees = {};
            let maxIndegree = 0;
            let maxOutdegree = 0;

            for (let _i = 0; _i < numNodes; _i++) {
              const _node = nodes[_i];

              const id = _node.id(); // add current node to the current options object and call degreeCentrality


              options.root = _node;

              const _currDegree = this.degreeCentrality(options);

              if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;
              if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;
              indegrees[id] = _currDegree.indegree;
              outdegrees[id] = _currDegree.outdegree;
            }

            return {
              indegree: function indegree(node) {
                if (maxIndegree == 0) {
                  return 0;
                }

                if (string(node)) {
            // from is a selector string
                  node = cy.filter(node);
                }

                return indegrees[node.id()] / maxIndegree;
              },
              outdegree: function outdegree(node) {
                if (maxOutdegree === 0) {
                  return 0;
                }

                if (string(node)) {
            // from is a selector string
                  node = cy.filter(node);
                }

                return outdegrees[node.id()] / maxOutdegree;
              }
            };
          }
        },
  // degreeCentralityNormalized
  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
        degreeCentrality: function degreeCentrality(options) {
          options = defaults$1(options);
          const cy = this.cy();
          const callingEles = this;
          let _options = options,
            root = _options.root,
            weight = _options.weight,
            directed = _options.directed,
            alpha = _options.alpha;
          root = cy.collection(root)[0];

          if (!directed) {
            const connEdges = root.connectedEdges().intersection(callingEles);
            const k = connEdges.length;
            let s = 0; // Now, sum edge weights

            for (let i = 0; i < connEdges.length; i++) {
              s += weight(connEdges[i]);
            }

            return {
              degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
            };
          } else {
            const edges = root.connectedEdges();
            const incoming = edges.filter(function (edge) {
              return edge.target().same(root) && callingEles.has(edge);
            });
            const outgoing = edges.filter(function (edge) {
              return edge.source().same(root) && callingEles.has(edge);
            });
            const k_in = incoming.length;
            const k_out = outgoing.length;
            let s_in = 0;
            let s_out = 0; // Now, sum incoming edge weights

            for (let _i2 = 0; _i2 < incoming.length; _i2++) {
              s_in += weight(incoming[_i2]);
            } // Now, sum outgoing edge weights


            for (let _i3 = 0; _i3 < outgoing.length; _i3++) {
              s_out += weight(outgoing[_i3]);
            }

            return {
              indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
              outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
            };
          }
        } // degreeCentrality

      }; // elesfn
// nice, short mathemathical alias

      elesfn$8.dc = elesfn$8.degreeCentrality;
      elesfn$8.dcn = elesfn$8.degreeCentralityNormalised = elesfn$8.degreeCentralityNormalized;

      const defaults$2 = defaults({
        harmonic: true,
        weight: function weight() {
          return 1;
        },
        directed: false,
        root: null
      });
      const elesfn$9 = {
        closenessCentralityNormalized: function closenessCentralityNormalized(options) {
          const _defaults = defaults$2(options),
            harmonic = _defaults.harmonic,
            weight = _defaults.weight,
            directed = _defaults.directed;

          const cy = this.cy();
          const closenesses = {};
          let maxCloseness = 0;
          const nodes = this.nodes();
          const fw = this.floydWarshall({
            weight: weight,
            directed: directed
          }); // Compute closeness for every node and find the maximum closeness

          for (let i = 0; i < nodes.length; i++) {
            let currCloseness = 0;
            const node_i = nodes[i];

            for (let j = 0; j < nodes.length; j++) {
              if (i !== j) {
                const d = fw.distance(node_i, nodes[j]);

                if (harmonic) {
                  currCloseness += 1 / d;
                } else {
                  currCloseness += d;
                }
              }
            }

            if (!harmonic) {
              currCloseness = 1 / currCloseness;
            }

            if (maxCloseness < currCloseness) {
              maxCloseness = currCloseness;
            }

            closenesses[node_i.id()] = currCloseness;
          }

          return {
            closeness: function closeness(node) {
              if (maxCloseness == 0) {
                return 0;
              }

              if (string(node)) {
          // from is a selector string
                node = cy.filter(node)[0].id();
              } else {
          // from is a node
                node = node.id();
              }

              return closenesses[node] / maxCloseness;
            }
          };
        },
  // Implemented from pseudocode from wikipedia
        closenessCentrality: function closenessCentrality(options) {
          let _defaults2 = defaults$2(options),
            root = _defaults2.root,
            weight = _defaults2.weight,
            directed = _defaults2.directed,
            harmonic = _defaults2.harmonic;

          root = this.filter(root)[0]; // we need distance from this node to every other node

          const dijkstra = this.dijkstra({
            root: root,
            weight: weight,
            directed: directed
          });
          let totalDistance = 0;
          const nodes = this.nodes();

          for (let i = 0; i < nodes.length; i++) {
            const n = nodes[i];

            if (!n.same(root)) {
              const d = dijkstra.distanceTo(n);

              if (harmonic) {
                totalDistance += 1 / d;
              } else {
                totalDistance += d;
              }
            }
          }

          return harmonic ? totalDistance : 1 / totalDistance;
        } // closenessCentrality

      }; // elesfn
// nice, short mathemathical alias

      elesfn$9.cc = elesfn$9.closenessCentrality;
      elesfn$9.ccn = elesfn$9.closenessCentralityNormalised = elesfn$9.closenessCentralityNormalized;

      const defaults$3 = defaults({
        weight: null,
        directed: false
      });
      const elesfn$a = {
  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
        betweennessCentrality: function betweennessCentrality(options) {
          const _defaults = defaults$3(options),
            directed = _defaults.directed,
            weight = _defaults.weight;

          const weighted = weight != null;
          const cy = this.cy(); // starting

          const V = this.nodes();
          const A = {};
          const _C = {};
          let max = 0;
          const C = {
            set: function set(key, val) {
              _C[key] = val;

              if (val > max) {
                max = val;
              }
            },
            get: function get(key) {
              return _C[key];
            }
          }; // A contains the neighborhoods of every node

          for (let i = 0; i < V.length; i++) {
            const v = V[i];
            const vid = v.id();

            if (directed) {
              A[vid] = v.outgoers().nodes(); // get outgoers of every node
            } else {
              A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node
            }

            C.set(vid, 0);
          }

          const _loop = function _loop(s) {
            const sid = V[s].id();
            const S = []; // stack

            const P = {};
            const g = {};
            const d = {};
            const Q = new Heap(function (a, b) {
              return d[a] - d[b];
            }); // queue
      // init dictionaries

            for (let _i = 0; _i < V.length; _i++) {
              const _vid = V[_i].id();

              P[_vid] = [];
              g[_vid] = 0;
              d[_vid] = Infinity;
            }

            g[sid] = 1; // sigma

            d[sid] = 0; // distance to s

            Q.push(sid);

            while (!Q.empty()) {
              const _v = Q.pop();

              S.push(_v);

              if (weighted) {
                for (let j = 0; j < A[_v].length; j++) {
                  let w = A[_v][j];
                  const vEle = cy.getElementById(_v);
                  let edge = void 0;

                  if (vEle.edgesTo(w).length > 0) {
                    edge = vEle.edgesTo(w)[0];
                  } else {
                    edge = w.edgesTo(vEle)[0];
                  }

                  const edgeWeight = weight(edge);
                  w = w.id();

                  if (d[w] > d[_v] + edgeWeight) {
                    d[w] = d[_v] + edgeWeight;

                    if (Q.nodes.indexOf(w) < 0) {
                //if w is not in Q
                      Q.push(w);
                    } else {
                // update position if w is in Q
                      Q.updateItem(w);
                    }

                    g[w] = 0;
                    P[w] = [];
                  }

                  if (d[w] == d[_v] + edgeWeight) {
                    g[w] = g[w] + g[_v];
                    P[w].push(_v);
                  }
                }
              } else {
                for (let _j = 0; _j < A[_v].length; _j++) {
                  const _w = A[_v][_j].id();

                  if (d[_w] == Infinity) {
                    Q.push(_w);
                    d[_w] = d[_v] + 1;
                  }

                  if (d[_w] == d[_v] + 1) {
                    g[_w] = g[_w] + g[_v];

                    P[_w].push(_v);
                  }
                }
              }
            }

            const e = {};

            for (let _i2 = 0; _i2 < V.length; _i2++) {
              e[V[_i2].id()] = 0;
            }

            while (S.length > 0) {
              const _w2 = S.pop();

              for (let _j2 = 0; _j2 < P[_w2].length; _j2++) {
                const _v2 = P[_w2][_j2];
                e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);
              }

              if (_w2 != V[s].id()) {
                C.set(_w2, C.get(_w2) + e[_w2]);
              }
            }
          };

          for (let s = 0; s < V.length; s++) {
            _loop(s);
          }

          const ret = {
            betweenness: function betweenness(node) {
              const id = cy.collection(node).id();
              return C.get(id);
            },
            betweennessNormalized: function betweennessNormalized(node) {
              if (max == 0) {
                return 0;
              }

              const id = cy.collection(node).id();
              return C.get(id) / max;
            }
          }; // alias

          ret.betweennessNormalised = ret.betweennessNormalized;
          return ret;
        } // betweennessCentrality

      }; // elesfn
// nice, short mathemathical alias

      elesfn$a.bc = elesfn$a.betweennessCentrality;

// Implemented by Zoe Xi @zoexi for GSOC 2016
/* eslint-disable no-unused-vars */

      const defaults$4 = defaults({
        expandFactor: 2,
  // affects time of computation and cluster granularity to some extent: M * M
        inflateFactor: 2,
  // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)
        multFactor: 1,
  // optional self loops for each node. Use a neutral value to improve cluster computations.
        maxIterations: 20,
  // maximum number of iterations of the MCL algorithm in a single run
        attributes: [// attributes/features used to group nodes, ie. similarity values between nodes
          function (edge) {
            return 1;
          }]
      });
/* eslint-enable */

      const setOptions = function setOptions(options) {
        return defaults$4(options);
      };
/* eslint-enable */


      const getSimilarity = function getSimilarity(edge, attributes) {
        let total = 0;

        for (let i = 0; i < attributes.length; i++) {
          total += attributes[i](edge);
        }

        return total;
      };

      const addLoops = function addLoops(M, n, val) {
        for (let i = 0; i < n; i++) {
          M[i * n + i] = val;
        }
      };

      const normalize = function normalize(M, n) {
        let sum;

        for (let col = 0; col < n; col++) {
          sum = 0;

          for (let row = 0; row < n; row++) {
            sum += M[row * n + col];
          }

          for (let _row = 0; _row < n; _row++) {
            M[_row * n + col] = M[_row * n + col] / sum;
          }
        }
      }; // TODO: blocked matrix multiplication?


      const mmult = function mmult(A, B, n) {
        const C = new Array(n * n);

        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            C[i * n + j] = 0;
          }

          for (let k = 0; k < n; k++) {
            for (let _j = 0; _j < n; _j++) {
              C[i * n + _j] += A[i * n + k] * B[k * n + _j];
            }
          }
        }

        return C;
      };

      const expand = function expand(M, n, expandFactor
/** power **/
      ) {
        const _M = M.slice(0);

        for (let p = 1; p < expandFactor; p++) {
          M = mmult(M, _M, n);
        }

        return M;
      };

      const inflate = function inflate(M, n, inflateFactor
/** r **/
      ) {
        const _M = new Array(n * n); // M(i,j) ^ inflatePower


        for (let i = 0; i < n * n; i++) {
          _M[i] = Math.pow(M[i], inflateFactor);
        }

        normalize(_M, n);
        return _M;
      };

      const hasConverged = function hasConverged(M, _M, n2, roundFactor) {
  // Check that both matrices have the same elements (i,j)
        for (let i = 0; i < n2; i++) {
          const v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places

          const v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);

          if (v1 !== v2) {
            return false;
          }
        }

        return true;
      };

      const assign = function assign(M, n, nodes, cy) {
        const clusters = [];

        for (let i = 0; i < n; i++) {
          const cluster = [];

          for (let j = 0; j < n; j++) {
      // Row-wise attractors and elements that they attract belong in same cluster
            if (Math.round(M[i * n + j] * 1000) / 1000 > 0) {
              cluster.push(nodes[j]);
            }
          }

          if (cluster.length !== 0) {
            clusters.push(cy.collection(cluster));
          }
        }

        return clusters;
      };

      const isDuplicate = function isDuplicate(c1, c2) {
        for (let i = 0; i < c1.length; i++) {
          if (!c2[i] || c1[i].id() !== c2[i].id()) {
            return false;
          }
        }

        return true;
      };

      const removeDuplicates = function removeDuplicates(clusters) {
        for (let i = 0; i < clusters.length; i++) {
          for (let j = 0; j < clusters.length; j++) {
            if (i != j && isDuplicate(clusters[i], clusters[j])) {
              clusters.splice(j, 1);
            }
          }
        }

        return clusters;
      };

      const markovClustering = function markovClustering(options) {
        const nodes = this.nodes();
        const edges = this.edges();
        const cy = this.cy(); // Set parameters of algorithm:

        const opts = setOptions(options); // Map each node to its position in node array

        const id2position = {};

        for (let i = 0; i < nodes.length; i++) {
          id2position[nodes[i].id()] = i;
        } // Generate stochastic matrix M from input graph G (should be symmetric/undirected)


        const n = nodes.length,
          n2 = n * n;

        let M = new Array(n2),
          _M;

        for (let _i = 0; _i < n2; _i++) {
          M[_i] = 0;
        }

        for (let e = 0; e < edges.length; e++) {
          const edge = edges[e];
          const _i2 = id2position[edge.source().id()];
          const j = id2position[edge.target().id()];
          const sim = getSimilarity(edge, opts.attributes);
          M[_i2 * n + j] += sim; // G should be symmetric and undirected

          M[j * n + _i2] += sim;
        } // Begin Markov cluster algorithm
  // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal


        addLoops(M, n, opts.multFactor); // Step 2: M = normalize( M );

        normalize(M, n);
        let isStillMoving = true;
        let iterations = 0;

        while (isStillMoving && iterations < opts.maxIterations) {
          isStillMoving = false; // Step 3:

          _M = expand(M, n, opts.expandFactor); // Step 4:

          M = inflate(_M, n, opts.inflateFactor); // Step 5: check to see if ~steady state has been reached

          if (!hasConverged(M, _M, n2, 4)) {
            isStillMoving = true;
          }

          iterations++;
        } // Build clusters from matrix


        let clusters = assign(M, n, nodes, cy); // Remove duplicate clusters due to symmetry of graph and M matrix

        clusters = removeDuplicates(clusters);
        return clusters;
      };

      const markovClustering$1 = {
        markovClustering: markovClustering,
        mcl: markovClustering
      };

// Common distance metrics for clustering algorithms

      const identity = function identity(x) {
        return x;
      };

      const absDiff = function absDiff(p, q) {
        return Math.abs(q - p);
      };

      const addAbsDiff = function addAbsDiff(total, p, q) {
        return total + absDiff(p, q);
      };

      const addSquaredDiff = function addSquaredDiff(total, p, q) {
        return total + Math.pow(q - p, 2);
      };

      const sqrt = function sqrt(x) {
        return Math.sqrt(x);
      };

      const maxAbsDiff = function maxAbsDiff(currentMax, p, q) {
        return Math.max(currentMax, absDiff(p, q));
      };

      const getDistance = function getDistance(length, getP, getQ, init, visit) {
        const post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity;
        let ret = init;
        let p, q;

        for (let dim = 0; dim < length; dim++) {
          p = getP(dim);
          q = getQ(dim);
          ret = visit(ret, p, q);
        }

        return post(ret);
      };

      const distances = {
        euclidean: function euclidean(length, getP, getQ) {
          if (length >= 2) {
            return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);
          } else {
      // for single attr case, more efficient to avoid sqrt
            return getDistance(length, getP, getQ, 0, addAbsDiff);
          }
        },
        squaredEuclidean: function squaredEuclidean(length, getP, getQ) {
          return getDistance(length, getP, getQ, 0, addSquaredDiff);
        },
        manhattan: function manhattan(length, getP, getQ) {
          return getDistance(length, getP, getQ, 0, addAbsDiff);
        },
        max: function max(length, getP, getQ) {
          return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);
        }
      }; // in case the user accidentally doesn't use camel case

      distances['squared-euclidean'] = distances['squaredEuclidean'];
      distances['squaredeuclidean'] = distances['squaredEuclidean'];
      function clusteringDistance (method, length, getP, getQ, nodeP, nodeQ) {
        let impl;

        if (fn(method)) {
          impl = method;
        } else {
          impl = distances[method] || distances.euclidean;
        }

        if (length === 0 && fn(method)) {
          return impl(nodeP, nodeQ);
        } else {
          return impl(length, getP, getQ, nodeP, nodeQ);
        }
      }

      const defaults$5 = defaults({
        k: 2,
        m: 2,
        sensitivityThreshold: 0.0001,
        distance: 'euclidean',
        maxIterations: 10,
        attributes: [],
        testMode: false,
        testCentroids: null
      });

      const setOptions$1 = function setOptions(options) {
        return defaults$5(options);
      };
/* eslint-enable */


      const getDist = function getDist(type, node, centroid, attributes, mode) {
        const noNodeP = mode !== 'kMedoids';
        const getP = noNodeP ? function (i) {
          return centroid[i];
        } : function (i) {
          return attributes[i](centroid);
        };

        const getQ = function getQ(i) {
          return attributes[i](node);
        };

        const nodeP = centroid;
        const nodeQ = node;
        return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);
      };

      const randomCentroids = function randomCentroids(nodes, k, attributes) {
        const ndim = attributes.length;
        const min = new Array(ndim);
        const max = new Array(ndim);
        const centroids = new Array(k);
        let centroid = null; // Find min, max values for each attribute dimension

        for (let i = 0; i < ndim; i++) {
          min[i] = nodes.min(attributes[i]).value;
          max[i] = nodes.max(attributes[i]).value;
        } // Build k centroids, each represented as an n-dim feature vector


        for (let c = 0; c < k; c++) {
          centroid = [];

          for (let _i = 0; _i < ndim; _i++) {
            centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value
          }

          centroids[c] = centroid;
        }

        return centroids;
      };

      const classify = function classify(node, centroids, distance, attributes, type) {
        let min = Infinity;
        let index = 0;

        for (let i = 0; i < centroids.length; i++) {
          const dist = getDist(distance, node, centroids[i], attributes, type);

          if (dist < min) {
            min = dist;
            index = i;
          }
        }

        return index;
      };

      const buildCluster = function buildCluster(centroid, nodes, assignment) {
        const cluster = [];
        let node = null;

        for (let n = 0; n < nodes.length; n++) {
          node = nodes[n];

          if (assignment[node.id()] === centroid) {
      //console.log("Node " + node.id() + " is associated with medoid #: " + m);
            cluster.push(node);
          }
        }

        return cluster;
      };

      const haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {
        return Math.abs(v2 - v1) <= sensitivityThreshold;
      };

      const haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {
        for (let i = 0; i < v1.length; i++) {
          for (let j = 0; j < v1[i].length; j++) {
            const diff = Math.abs(v1[i][j] - v2[i][j]);

            if (diff > sensitivityThreshold) {
              return false;
            }
          }
        }

        return true;
      };

      const seenBefore = function seenBefore(node, medoids, n) {
        for (let i = 0; i < n; i++) {
          if (node === medoids[i]) return true;
        }

        return false;
      };

      const randomMedoids = function randomMedoids(nodes, k) {
        const medoids = new Array(k); // For small data sets, the probability of medoid conflict is greater,
  // so we need to check to see if we've already seen or chose this node before.

        if (nodes.length < 50) {
    // Randomly select k medoids from the n nodes
          for (let i = 0; i < k; i++) {
            let node = nodes[Math.floor(Math.random() * nodes.length)]; // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).
      // Instead choose a different random node.

            while (seenBefore(node, medoids, i)) {
              node = nodes[Math.floor(Math.random() * nodes.length)];
            }

            medoids[i] = node;
          }
        } else {
    // Relatively large data set, so pretty safe to not check and just select random nodes
          for (let _i2 = 0; _i2 < k; _i2++) {
            medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];
          }
        }

        return medoids;
      };

      const findCost = function findCost(potentialNewMedoid, cluster, attributes) {
        let cost = 0;

        for (let n = 0; n < cluster.length; n++) {
          cost += getDist('manhattan', cluster[n], potentialNewMedoid, attributes, 'kMedoids');
        }

        return cost;
      };

      const kMeans = function kMeans(options) {
        const cy = this.cy();
        const nodes = this.nodes();
        let node = null; // Set parameters of algorithm: # of clusters, distance metric, etc.

        const opts = setOptions$1(options); // Begin k-means algorithm

        const clusters = new Array(opts.k);
        const assignment = {};
        let centroids; // Step 1: Initialize centroid positions

        if (opts.testMode) {
          if (typeof opts.testCentroids === 'number') {
            centroids = randomCentroids(nodes, opts.k, opts.attributes);
          } else if (_typeof(opts.testCentroids) === 'object') {
            centroids = opts.testCentroids;
          } else {
            centroids = randomCentroids(nodes, opts.k, opts.attributes);
          }
        } else {
          centroids = randomCentroids(nodes, opts.k, opts.attributes);
        }

        let isStillMoving = true;
        let iterations = 0;

        while (isStillMoving && iterations < opts.maxIterations) {
    // Step 2: Assign nodes to the nearest centroid
          for (let n = 0; n < nodes.length; n++) {
            node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #

            assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, 'kMeans');
          } // Step 3: For each of the k clusters, update its centroid


          isStillMoving = false;

          for (let c = 0; c < opts.k; c++) {
      // Get all nodes that belong to this cluster
            const cluster = buildCluster(c, nodes, assignment);

            if (cluster.length === 0) {
        // If cluster is empty, break out early & move to next cluster
              continue;
            } // Update centroids by calculating avg of all nodes within the cluster.


            const ndim = opts.attributes.length;
            const centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]

            const newCentroid = new Array(ndim);
            const sum = new Array(ndim);

            for (let d = 0; d < ndim; d++) {
              sum[d] = 0.0;

              for (let i = 0; i < cluster.length; i++) {
                node = cluster[i];
                sum[d] += opts.attributes[d](node);
              }

              newCentroid[d] = sum[d] / cluster.length; // Check to see if algorithm has converged, i.e. when centroids no longer change

              if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {
                isStillMoving = true;
              }
            }

            centroids[c] = newCentroid;
            clusters[c] = cy.collection(cluster);
          }

          iterations++;
        }

        return clusters;
      };

      const kMedoids = function kMedoids(options) {
        const cy = this.cy();
        const nodes = this.nodes();
        let node = null;
        const opts = setOptions$1(options); // Begin k-medoids algorithm

        const clusters = new Array(opts.k);
        let medoids;
        const assignment = {};
        let curCost;
        const minCosts = new Array(opts.k); // minimum cost configuration for each cluster
  // Step 1: Initialize k medoids

        if (opts.testMode) {
          if (typeof opts.testCentroids === 'number') ; else if (_typeof(opts.testCentroids) === 'object') {
            medoids = opts.testCentroids;
          } else {
            medoids = randomMedoids(nodes, opts.k);
          }
        } else {
          medoids = randomMedoids(nodes, opts.k);
        }

        let isStillMoving = true;
        let iterations = 0;

        while (isStillMoving && iterations < opts.maxIterations) {
    // Step 2: Assign nodes to the nearest medoid
          for (let n = 0; n < nodes.length; n++) {
            node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #

            assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, 'kMedoids');
          }

          isStillMoving = false; // Step 3: For each medoid m, and for each node assciated with mediod m,
    // select the node with the lowest configuration cost as new medoid.

          for (let m = 0; m < medoids.length; m++) {
      // Get all nodes that belong to this medoid
            const cluster = buildCluster(m, nodes, assignment);

            if (cluster.length === 0) {
        // If cluster is empty, break out early & move to next cluster
              continue;
            }

            minCosts[m] = findCost(medoids[m], cluster, opts.attributes); // original cost
      // Select different medoid if its configuration has the lowest cost

            for (let _n = 0; _n < cluster.length; _n++) {
              curCost = findCost(cluster[_n], cluster, opts.attributes);

              if (curCost < minCosts[m]) {
                minCosts[m] = curCost;
                medoids[m] = cluster[_n];
                isStillMoving = true;
              }
            }

            clusters[m] = cy.collection(cluster);
          }

          iterations++;
        }

        return clusters;
      };

      const updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {
        let numerator, denominator;

        for (let n = 0; n < nodes.length; n++) {
          for (let c = 0; c < centroids.length; c++) {
            weight[n][c] = Math.pow(U[n][c], opts.m);
          }
        }

        for (let _c = 0; _c < centroids.length; _c++) {
          for (let dim = 0; dim < opts.attributes.length; dim++) {
            numerator = 0;
            denominator = 0;

            for (let _n2 = 0; _n2 < nodes.length; _n2++) {
              numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);
              denominator += weight[_n2][_c];
            }

            centroids[_c][dim] = numerator / denominator;
          }
        }
      };

      const updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {
  // Save previous step
        for (let i = 0; i < U.length; i++) {
          _U[i] = U[i].slice();
        }

        let sum, numerator, denominator;
        const pow = 2 / (opts.m - 1);

        for (let c = 0; c < centroids.length; c++) {
          for (let n = 0; n < nodes.length; n++) {
            sum = 0;

            for (let k = 0; k < centroids.length; k++) {
        // against all other centroids
              numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, 'cmeans');
              denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, 'cmeans');
              sum += Math.pow(numerator / denominator, pow);
            }

            U[n][c] = 1 / sum;
          }
        }
      };

      const assign$1 = function assign(nodes, U, opts, cy) {
        const clusters = new Array(opts.k);

        for (let c = 0; c < clusters.length; c++) {
          clusters[c] = [];
        }

        let max;
        let index;

        for (let n = 0; n < U.length; n++) {
    // for each node (U is N x C matrix)
          max = -Infinity;
          index = -1; // Determine which cluster the node is most likely to belong in

          for (let _c2 = 0; _c2 < U[0].length; _c2++) {
            if (U[n][_c2] > max) {
              max = U[n][_c2];
              index = _c2;
            }
          }

          clusters[index].push(nodes[n]);
        } // Turn every array into a collection of nodes


        for (let _c3 = 0; _c3 < clusters.length; _c3++) {
          clusters[_c3] = cy.collection(clusters[_c3]);
        }

        return clusters;
      };

      const fuzzyCMeans = function fuzzyCMeans(options) {
        const cy = this.cy();
        const nodes = this.nodes();
        const opts = setOptions$1(options); // Begin fuzzy c-means algorithm

        let clusters;
        let centroids;
        let U;

        let _U;

        let weight; // Step 1: Initialize letiables.

        _U = new Array(nodes.length);

        for (let i = 0; i < nodes.length; i++) {
    // N x C matrix
          _U[i] = new Array(opts.k);
        }

        U = new Array(nodes.length);

        for (let _i3 = 0; _i3 < nodes.length; _i3++) {
    // N x C matrix
          U[_i3] = new Array(opts.k);
        }

        for (let _i4 = 0; _i4 < nodes.length; _i4++) {
          let total = 0;

          for (let j = 0; j < opts.k; j++) {
            U[_i4][j] = Math.random();
            total += U[_i4][j];
          }

          for (let _j = 0; _j < opts.k; _j++) {
            U[_i4][_j] = U[_i4][_j] / total;
          }
        }

        centroids = new Array(opts.k);

        for (let _i5 = 0; _i5 < opts.k; _i5++) {
          centroids[_i5] = new Array(opts.attributes.length);
        }

        weight = new Array(nodes.length);

        for (let _i6 = 0; _i6 < nodes.length; _i6++) {
    // N x C matrix
          weight[_i6] = new Array(opts.k);
        } // end init FCM


        let isStillMoving = true;
        let iterations = 0;

        while (isStillMoving && iterations < opts.maxIterations) {
          isStillMoving = false; // Step 2: Calculate the centroids for each step.

          updateCentroids(centroids, nodes, U, weight, opts); // Step 3: Update the partition matrix U.

          updateMembership(U, _U, centroids, nodes, opts); // Step 4: Check for convergence.

          if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {
            isStillMoving = true;
          }

          iterations++;
        } // Assign nodes to clusters with highest probability.


        clusters = assign$1(nodes, U, opts, cy);
        return {
          clusters: clusters,
          degreeOfMembership: U
        };
      };

      const kClustering = {
        kMeans: kMeans,
        kMedoids: kMedoids,
        fuzzyCMeans: fuzzyCMeans,
        fcm: fuzzyCMeans
      };

// Implemented by Zoe Xi @zoexi for GSOC 2016
      const defaults$6 = defaults({
        distance: 'euclidean',
  // distance metric to compare nodes
        linkage: 'min',
  // linkage criterion : how to determine the distance between clusters of nodes
        mode: 'threshold',
  // mode:'threshold' => clusters must be threshold distance apart
        threshold: Infinity,
  // the distance threshold
  // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters
        addDendrogram: false,
  // whether to add the dendrogram to the graph for viz
        dendrogramDepth: 0,
  // depth at which dendrogram branches are merged into the returned clusters
        attributes: [] // array of attr functions

      });
      const linkageAliases = {
        'single': 'min',
        'complete': 'max'
      };

      const setOptions$2 = function setOptions(options) {
        const opts = defaults$6(options);
        const preferredAlias = linkageAliases[opts.linkage];

        if (preferredAlias != null) {
          opts.linkage = preferredAlias;
        }

        return opts;
      };

      const mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {
  // Find two closest clusters from cached mins
        let minKey = 0;
        let min = Infinity;
        let dist;
        const attrs = opts.attributes;

        const getDist = function getDist(n1, n2) {
          return clusteringDistance(opts.distance, attrs.length, function (i) {
            return attrs[i](n1);
          }, function (i) {
            return attrs[i](n2);
          }, n1, n2);
        };

        for (let i = 0; i < clusters.length; i++) {
          const key = clusters[i].key;
          const _dist = dists[key][mins[key]];

          if (_dist < min) {
            minKey = key;
            min = _dist;
          }
        }

        if (opts.mode === 'threshold' && min >= opts.threshold || opts.mode === 'dendrogram' && clusters.length === 1) {
          return false;
        }

        const c1 = index[minKey];
        const c2 = index[mins[minKey]];
        let merged; // Merge two closest clusters

        if (opts.mode === 'dendrogram') {
          merged = {
            left: c1,
            right: c2,
            key: c1.key
          };
        } else {
          merged = {
            value: c1.value.concat(c2.value),
            key: c1.key
          };
        }

        clusters[c1.index] = merged;
        clusters.splice(c2.index, 1);
        index[c1.key] = merged; // Update distances with new merged cluster

        for (let _i = 0; _i < clusters.length; _i++) {
          const cur = clusters[_i];

          if (c1.key === cur.key) {
            dist = Infinity;
          } else if (opts.linkage === 'min') {
            dist = dists[c1.key][cur.key];

            if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {
              dist = dists[c2.key][cur.key];
            }
          } else if (opts.linkage === 'max') {
            dist = dists[c1.key][cur.key];

            if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {
              dist = dists[c2.key][cur.key];
            }
          } else if (opts.linkage === 'mean') {
            dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);
          } else {
            if (opts.mode === 'dendrogram') dist = getDist(cur.value, c1.value);else dist = getDist(cur.value[0], c1.value[0]);
          }

          dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric
        } // Update cached mins


        for (let _i2 = 0; _i2 < clusters.length; _i2++) {
          const key1 = clusters[_i2].key;

          if (mins[key1] === c1.key || mins[key1] === c2.key) {
            let _min = key1;

            for (let j = 0; j < clusters.length; j++) {
              const key2 = clusters[j].key;

              if (dists[key1][key2] < dists[key1][_min]) {
                _min = key2;
              }
            }

            mins[key1] = _min;
          }

          clusters[_i2].index = _i2;
        } // Clean up meta data used for clustering


        c1.key = c2.key = c1.index = c2.index = null;
        return true;
      };

      const getAllChildren = function getAllChildren(root, arr, cy) {
        if (!root) return;

        if (root.value) {
          arr.push(root.value);
        } else {
          if (root.left) getAllChildren(root.left, arr);
          if (root.right) getAllChildren(root.right, arr);
        }
      };

      const buildDendrogram = function buildDendrogram(root, cy) {
        if (!root) return '';

        if (root.left && root.right) {
          const leftStr = buildDendrogram(root.left, cy);
          const rightStr = buildDendrogram(root.right, cy);
          const node = cy.add({
            group: 'nodes',
            data: {
              id: leftStr + ',' + rightStr
            }
          });
          cy.add({
            group: 'edges',
            data: {
              source: leftStr,
              target: node.id()
            }
          });
          cy.add({
            group: 'edges',
            data: {
              source: rightStr,
              target: node.id()
            }
          });
          return node.id();
        } else if (root.value) {
          return root.value.id();
        }
      };

      const buildClustersFromTree = function buildClustersFromTree(root, k, cy) {
        if (!root) return [];
        let left = [],
          right = [],
          leaves = [];

        if (k === 0) {
    // don't cut tree, simply return all nodes as 1 single cluster
          if (root.left) getAllChildren(root.left, left);
          if (root.right) getAllChildren(root.right, right);
          leaves = left.concat(right);
          return [cy.collection(leaves)];
        } else if (k === 1) {
    // cut at root
          if (root.value) {
      // leaf node
            return [cy.collection(root.value)];
          } else {
            if (root.left) getAllChildren(root.left, left);
            if (root.right) getAllChildren(root.right, right);
            return [cy.collection(left), cy.collection(right)];
          }
        } else {
          if (root.value) {
            return [cy.collection(root.value)];
          } else {
            if (root.left) left = buildClustersFromTree(root.left, k - 1, cy);
            if (root.right) right = buildClustersFromTree(root.right, k - 1, cy);
            return left.concat(right);
          }
        }
      };
/* eslint-enable */


      const hierarchicalClustering = function hierarchicalClustering(options) {
        const cy = this.cy();
        const nodes = this.nodes(); // Set parameters of algorithm: linkage type, distance metric, etc.

        const opts = setOptions$2(options);
        const attrs = opts.attributes;

        const getDist = function getDist(n1, n2) {
          return clusteringDistance(opts.distance, attrs.length, function (i) {
            return attrs[i](n1);
          }, function (i) {
            return attrs[i](n2);
          }, n1, n2);
        }; // Begin hierarchical algorithm


        const clusters = [];
        const dists = []; // distances between each pair of clusters

        const mins = []; // closest cluster for each cluster

        const index = []; // hash of all clusters by key
  // In agglomerative (bottom-up) clustering, each node starts as its own cluster

        for (let n = 0; n < nodes.length; n++) {
          const cluster = {
            value: opts.mode === 'dendrogram' ? nodes[n] : [nodes[n]],
            key: n,
            index: n
          };
          clusters[n] = cluster;
          index[n] = cluster;
          dists[n] = [];
          mins[n] = 0;
        } // Calculate the distance between each pair of clusters


        for (let i = 0; i < clusters.length; i++) {
          for (let j = 0; j <= i; j++) {
            let dist = void 0;

            if (opts.mode === 'dendrogram') {
        // modes store cluster values differently
              dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);
            } else {
              dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);
            }

            dists[i][j] = dist;
            dists[j][i] = dist;

            if (dist < dists[i][mins[i]]) {
              mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j
            }
          }
        } // Find the closest pair of clusters and merge them into a single cluster.
  // Update distances between new cluster and each of the old clusters, and loop until threshold reached.


        let merged = mergeClosest(clusters, index, dists, mins, opts);

        while (merged) {
          merged = mergeClosest(clusters, index, dists, mins, opts);
        }

        let retClusters; // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges
  // in addition to returning the clusters.

        if (opts.mode === 'dendrogram') {
          retClusters = buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);
          if (opts.addDendrogram) buildDendrogram(clusters[0], cy);
        } else {
    // Regular mode simply returns the clusters
          retClusters = new Array(clusters.length);
          clusters.forEach(function (cluster, i) {
      // Clean up meta data used for clustering
            cluster.key = cluster.index = null;
            retClusters[i] = cy.collection(cluster.value);
          });
        }

        return retClusters;
      };

      const hierarchicalClustering$1 = {
        hierarchicalClustering: hierarchicalClustering,
        hca: hierarchicalClustering
      };

// Implemented by Zoe Xi @zoexi for GSOC 2016
      const defaults$7 = defaults({
        distance: 'euclidean',
  // distance metric to compare attributes between two nodes
        preference: 'median',
  // suitability of a data point to serve as an exemplar
        damping: 0.8,
  // damping factor between [0.5, 1)
        maxIterations: 1000,
  // max number of iterations to run
        minIterations: 100,
  // min number of iterations to run in order for clustering to stop
        attributes: [// functions to quantify the similarity between any two points
    // e.g. node => node.data('weight')
        ]
      });

      const setOptions$3 = function setOptions(options) {
        const dmp = options.damping;
        const pref = options.preference;

        if (!(0.5 <= dmp && dmp < 1)) {
          error("Damping must range on [0.5, 1).  Got: ".concat(dmp));
        }

        const validPrefs = ['median', 'mean', 'min', 'max'];

        if (!(validPrefs.some(function (v) {
          return v === pref;
        }) || number(pref))) {
          error("Preference must be one of [".concat(validPrefs.map(function (p) {
            return "'".concat(p, "'");
          }).join(', '), "] or a number.  Got: ").concat(pref));
        }

        return defaults$7(options);
      };
/* eslint-enable */


      const getSimilarity$1 = function getSimilarity(type, n1, n2, attributes) {
        const attr = function attr(n, i) {
          return attributes[i](n);
        }; // nb negative because similarity should have an inverse relationship to distance


        return -clusteringDistance(type, attributes.length, function (i) {
          return attr(n1, i);
        }, function (i) {
          return attr(n2, i);
        }, n1, n2);
      };

      const getPreference = function getPreference(S, preference) {
  // larger preference = greater # of clusters
        let p = null;

        if (preference === 'median') {
          p = median(S);
        } else if (preference === 'mean') {
          p = mean(S);
        } else if (preference === 'min') {
          p = min(S);
        } else if (preference === 'max') {
          p = max(S);
        } else {
    // Custom preference number, as set by user
          p = preference;
        }

        return p;
      };

      const findExemplars = function findExemplars(n, R, A) {
        const indices = [];

        for (let i = 0; i < n; i++) {
          if (R[i * n + i] + A[i * n + i] > 0) {
            indices.push(i);
          }
        }

        return indices;
      };

      const assignClusters = function assignClusters(n, S, exemplars) {
        const clusters = [];

        for (let i = 0; i < n; i++) {
          let index = -1;
          let max = -Infinity;

          for (let ei = 0; ei < exemplars.length; ei++) {
            const e = exemplars[ei];

            if (S[i * n + e] > max) {
              index = e;
              max = S[i * n + e];
            }
          }

          if (index > 0) {
            clusters.push(index);
          }
        }

        for (let _ei = 0; _ei < exemplars.length; _ei++) {
          clusters[exemplars[_ei]] = exemplars[_ei];
        }

        return clusters;
      };

      const assign$2 = function assign(n, S, exemplars) {
        let clusters = assignClusters(n, S, exemplars);

        for (let ei = 0; ei < exemplars.length; ei++) {
          const ii = [];

          for (let c = 0; c < clusters.length; c++) {
            if (clusters[c] === exemplars[ei]) {
              ii.push(c);
            }
          }

          let maxI = -1;
          let maxSum = -Infinity;

          for (let i = 0; i < ii.length; i++) {
            let sum = 0;

            for (let j = 0; j < ii.length; j++) {
              sum += S[ii[j] * n + ii[i]];
            }

            if (sum > maxSum) {
              maxI = i;
              maxSum = sum;
            }
          }

          exemplars[ei] = ii[maxI];
        }

        clusters = assignClusters(n, S, exemplars);
        return clusters;
      };

      const affinityPropagation = function affinityPropagation(options) {
        const cy = this.cy();
        const nodes = this.nodes();
        const opts = setOptions$3(options); // Map each node to its position in node array

        const id2position = {};

        for (let i = 0; i < nodes.length; i++) {
          id2position[nodes[i].id()] = i;
        } // Begin affinity propagation algorithm


        let n; // number of data points

        let n2; // size of matrices

        let S; // similarity matrix (1D array)

        let p; // preference/suitability of a data point to serve as an exemplar

        let R; // responsibility matrix (1D array)

        let A; // availability matrix (1D array)

        n = nodes.length;
        n2 = n * n; // Initialize and build S similarity matrix

        S = new Array(n2);

        for (let _i = 0; _i < n2; _i++) {
          S[_i] = -Infinity; // for cases where two data points shouldn't be linked together
        }

        for (let _i2 = 0; _i2 < n; _i2++) {
          for (let j = 0; j < n; j++) {
            if (_i2 !== j) {
              S[_i2 * n + j] = getSimilarity$1(opts.distance, nodes[_i2], nodes[j], opts.attributes);
            }
          }
        } // Place preferences on the diagonal of S


        p = getPreference(S, opts.preference);

        for (let _i3 = 0; _i3 < n; _i3++) {
          S[_i3 * n + _i3] = p;
        } // Initialize R responsibility matrix


        R = new Array(n2);

        for (let _i4 = 0; _i4 < n2; _i4++) {
          R[_i4] = 0.0;
        } // Initialize A availability matrix


        A = new Array(n2);

        for (let _i5 = 0; _i5 < n2; _i5++) {
          A[_i5] = 0.0;
        }

        const old = new Array(n);
        const Rp = new Array(n);
        const se = new Array(n);

        for (let _i6 = 0; _i6 < n; _i6++) {
          old[_i6] = 0.0;
          Rp[_i6] = 0.0;
          se[_i6] = 0;
        }

        const e = new Array(n * opts.minIterations);

        for (let _i7 = 0; _i7 < e.length; _i7++) {
          e[_i7] = 0;
        }

        let iter;

        for (iter = 0; iter < opts.maxIterations; iter++) {
    // main algorithmic loop
    // Update R responsibility matrix
          for (let _i8 = 0; _i8 < n; _i8++) {
            let max = -Infinity,
              max2 = -Infinity,
              maxI = -1,
              AS = 0.0;

            for (let _j = 0; _j < n; _j++) {
              old[_j] = R[_i8 * n + _j];
              AS = A[_i8 * n + _j] + S[_i8 * n + _j];

              if (AS >= max) {
                max2 = max;
                max = AS;
                maxI = _j;
              } else if (AS > max2) {
                max2 = AS;
              }
            }

            for (let _j2 = 0; _j2 < n; _j2++) {
              R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];
            }

            R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];
          } // Update A availability matrix


          for (let _i9 = 0; _i9 < n; _i9++) {
            let sum = 0;

            for (let _j3 = 0; _j3 < n; _j3++) {
              old[_j3] = A[_j3 * n + _i9];
              Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);
              sum += Rp[_j3];
            }

            sum -= Rp[_i9];
            Rp[_i9] = R[_i9 * n + _i9];
            sum += Rp[_i9];

            for (let _j4 = 0; _j4 < n; _j4++) {
              A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];
            }

            A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];
          } // Check for convergence


          let K = 0;

          for (let _i10 = 0; _i10 < n; _i10++) {
            const E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;
            e[iter % opts.minIterations * n + _i10] = E;
            K += E;
          }

          if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {
            let _sum = 0;

            for (let _i11 = 0; _i11 < n; _i11++) {
              se[_i11] = 0;

              for (let _j5 = 0; _j5 < opts.minIterations; _j5++) {
                se[_i11] += e[_j5 * n + _i11];
              }

              if (se[_i11] === 0 || se[_i11] === opts.minIterations) {
                _sum++;
              }
            }

            if (_sum === n) {
        // then we have convergence
              break;
            }
          }
        } // Identify exemplars (cluster centers)


        const exemplarsIndices = findExemplars(n, R, A); // Assign nodes to clusters

        const clusterIndices = assign$2(n, S, exemplarsIndices);
        const clusters = {};

        for (let c = 0; c < exemplarsIndices.length; c++) {
          clusters[exemplarsIndices[c]] = [];
        }

        for (let _i12 = 0; _i12 < nodes.length; _i12++) {
          const pos = id2position[nodes[_i12].id()];

          const clusterIndex = clusterIndices[pos];

          if (clusterIndex != null) {
      // the node may have not been assigned a cluster if no valid attributes were specified
            clusters[clusterIndex].push(nodes[_i12]);
          }
        }

        const retClusters = new Array(exemplarsIndices.length);

        for (let _c = 0; _c < exemplarsIndices.length; _c++) {
          retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);
        }

        return retClusters;
      };

      const affinityPropagation$1 = {
        affinityPropagation: affinityPropagation,
        ap: affinityPropagation
      };

      const hierholzerDefaults = defaults({
        root: undefined,
        directed: false
      });
      const elesfn$b = {
        hierholzer: function hierholzer(options) {
          if (!plainObject(options)) {
            const args = arguments;
            options = {
              root: args[0],
              directed: args[1]
            };
          }

          const _hierholzerDefaults = hierholzerDefaults(options),
            root = _hierholzerDefaults.root,
            directed = _hierholzerDefaults.directed;

          const eles = this;
          let dflag = false;
          let oddIn;
          let oddOut;
          let startVertex;
          if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();
          const nodes = {};
          const edges = {};

          if (directed) {
            eles.forEach(function (ele) {
              const id = ele.id();

              if (ele.isNode()) {
                const ind = ele.indegree(true);
                const outd = ele.outdegree(true);
                const d1 = ind - outd;
                const d2 = outd - ind;

                if (d1 == 1) {
                  if (oddIn) dflag = true;else oddIn = id;
                } else if (d2 == 1) {
                  if (oddOut) dflag = true;else oddOut = id;
                } else if (d2 > 1 || d1 > 1) {
                  dflag = true;
                }

                nodes[id] = [];
                ele.outgoers().forEach(function (e) {
                  if (e.isEdge()) nodes[id].push(e.id());
                });
              } else {
                edges[id] = [undefined, ele.target().id()];
              }
            });
          } else {
            eles.forEach(function (ele) {
              const id = ele.id();

              if (ele.isNode()) {
                const d = ele.degree(true);

                if (d % 2) {
                  if (!oddIn) oddIn = id;else if (!oddOut) oddOut = id;else dflag = true;
                }

                nodes[id] = [];
                ele.connectedEdges().forEach(function (e) {
                  return nodes[id].push(e.id());
                });
              } else {
                edges[id] = [ele.source().id(), ele.target().id()];
              }
            });
          }

          const result = {
            found: false,
            trail: undefined
          };
          if (dflag) return result;else if (oddOut && oddIn) {
            if (directed) {
              if (startVertex && oddOut != startVertex) {
                return result;
              }

              startVertex = oddOut;
            } else {
              if (startVertex && oddOut != startVertex && oddIn != startVertex) {
                return result;
              } else if (!startVertex) {
                startVertex = oddOut;
              }
            }
          } else {
            if (!startVertex) startVertex = eles[0].id();
          }

          const walk = function walk(v) {
            let currentNode = v;
            const subtour = [v];
            let adj, adjTail, adjHead;

            while (nodes[currentNode].length) {
              adj = nodes[currentNode].shift();
              adjTail = edges[adj][0];
              adjHead = edges[adj][1];

              if (currentNode != adjHead) {
                nodes[adjHead] = nodes[adjHead].filter(function (e) {
                  return e != adj;
                });
                currentNode = adjHead;
              } else if (!directed && currentNode != adjTail) {
                nodes[adjTail] = nodes[adjTail].filter(function (e) {
                  return e != adj;
                });
                currentNode = adjTail;
              }

              subtour.unshift(adj);
              subtour.unshift(currentNode);
            }

            return subtour;
          };

          const trail = [];
          let subtour = [];
          subtour = walk(startVertex);

          while (subtour.length != 1) {
            if (nodes[subtour[0]].length == 0) {
              trail.unshift(eles.getElementById(subtour.shift()));
              trail.unshift(eles.getElementById(subtour.shift()));
            } else {
              subtour = walk(subtour.shift()).concat(subtour);
            }
          }

          trail.unshift(eles.getElementById(subtour.shift())); // final node

          for (const d in nodes) {
            if (nodes[d].length) {
              return result;
            }
          }

          result.found = true;
          result.trail = this.spawn(trail, true);
          return result;
        }
      };

      const hopcroftTarjanBiconnected = function hopcroftTarjanBiconnected() {
        const eles = this;
        const nodes = {};
        let id = 0;
        let edgeCount = 0;
        const components = [];
        const stack = [];
        const visitedEdges = {};

        const buildComponent = function buildComponent(x, y) {
          let i = stack.length - 1;
          const cutset = [];
          const component = eles.spawn();

          while (stack[i].x != x || stack[i].y != y) {
            cutset.push(stack.pop().edge);
            i--;
          }

          cutset.push(stack.pop().edge);
          cutset.forEach(function (edge) {
            const connectedNodes = edge.connectedNodes().intersection(eles);
            component.merge(edge);
            connectedNodes.forEach(function (node) {
              const nodeId = node.id();
              const connectedEdges = node.connectedEdges().intersection(eles);
              component.merge(node);

              if (!nodes[nodeId].cutVertex) {
                component.merge(connectedEdges);
              } else {
                component.merge(connectedEdges.filter(function (edge) {
                  return edge.isLoop();
                }));
              }
            });
          });
          components.push(component);
        };

        const biconnectedSearch = function biconnectedSearch(root, currentNode, parent) {
          if (root === parent) edgeCount += 1;
          nodes[currentNode] = {
            id: id,
            low: id++,
            cutVertex: false
          };
          const edges = eles.getElementById(currentNode).connectedEdges().intersection(eles);

          if (edges.size() === 0) {
            components.push(eles.spawn(eles.getElementById(currentNode)));
          } else {
            let sourceId, targetId, otherNodeId, edgeId;
            edges.forEach(function (edge) {
              sourceId = edge.source().id();
              targetId = edge.target().id();
              otherNodeId = sourceId === currentNode ? targetId : sourceId;

              if (otherNodeId !== parent) {
                edgeId = edge.id();

                if (!visitedEdges[edgeId]) {
                  visitedEdges[edgeId] = true;
                  stack.push({
                    x: currentNode,
                    y: otherNodeId,
                    edge: edge
                  });
                }

                if (!(otherNodeId in nodes)) {
                  biconnectedSearch(root, otherNodeId, currentNode);
                  nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].low);

                  if (nodes[currentNode].id <= nodes[otherNodeId].low) {
                    nodes[currentNode].cutVertex = true;
                    buildComponent(currentNode, otherNodeId);
                  }
                } else {
                  nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].id);
                }
              }
            });
          }
        };

        eles.forEach(function (ele) {
          if (ele.isNode()) {
            const nodeId = ele.id();

            if (!(nodeId in nodes)) {
              edgeCount = 0;
              biconnectedSearch(nodeId, nodeId);
              nodes[nodeId].cutVertex = edgeCount > 1;
            }
          }
        });
        const cutVertices = Object.keys(nodes).filter(function (id) {
          return nodes[id].cutVertex;
        }).map(function (id) {
          return eles.getElementById(id);
        });
        return {
          cut: eles.spawn(cutVertices),
          components: components
        };
      };

      const hopcroftTarjanBiconnected$1 = {
        hopcroftTarjanBiconnected: hopcroftTarjanBiconnected,
        htbc: hopcroftTarjanBiconnected,
        htb: hopcroftTarjanBiconnected,
        hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected
      };

      const tarjanStronglyConnected = function tarjanStronglyConnected() {
        const eles = this;
        const nodes = {};
        let index = 0;
        const components = [];
        const stack = [];
        let cut = eles.spawn(eles);

        const stronglyConnectedSearch = function stronglyConnectedSearch(sourceNodeId) {
          stack.push(sourceNodeId);
          nodes[sourceNodeId] = {
            index: index,
            low: index++,
            explored: false
          };
          const connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);
          connectedEdges.forEach(function (edge) {
            const targetNodeId = edge.target().id();

            if (targetNodeId !== sourceNodeId) {
              if (!(targetNodeId in nodes)) {
                stronglyConnectedSearch(targetNodeId);
              }

              if (!nodes[targetNodeId].explored) {
                nodes[sourceNodeId].low = Math.min(nodes[sourceNodeId].low, nodes[targetNodeId].low);
              }
            }
          });

          if (nodes[sourceNodeId].index === nodes[sourceNodeId].low) {
            const componentNodes = eles.spawn();

            for (;;) {
              const nodeId = stack.pop();
              componentNodes.merge(eles.getElementById(nodeId));
              nodes[nodeId].low = nodes[sourceNodeId].index;
              nodes[nodeId].explored = true;

              if (nodeId === sourceNodeId) {
                break;
              }
            }

            const componentEdges = componentNodes.edgesWith(componentNodes);
            const component = componentNodes.merge(componentEdges);
            components.push(component);
            cut = cut.difference(component);
          }
        };

        eles.forEach(function (ele) {
          if (ele.isNode()) {
            const nodeId = ele.id();

            if (!(nodeId in nodes)) {
              stronglyConnectedSearch(nodeId);
            }
          }
        });
        return {
          cut: cut,
          components: components
        };
      };

      const tarjanStronglyConnected$1 = {
        tarjanStronglyConnected: tarjanStronglyConnected,
        tsc: tarjanStronglyConnected,
        tscc: tarjanStronglyConnected,
        tarjanStronglyConnectedComponents: tarjanStronglyConnected
      };

      const elesfn$c = {};
      [elesfn, elesfn$1, elesfn$2, elesfn$3, elesfn$4, elesfn$5, elesfn$6, elesfn$7, elesfn$8, elesfn$9, elesfn$a, markovClustering$1, kClustering, hierarchicalClustering$1, affinityPropagation$1, elesfn$b, hopcroftTarjanBiconnected$1, tarjanStronglyConnected$1].forEach(function (props) {
        extend(elesfn$c, props);
      });

/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/

/*  promise states [Promises/A+ 2.1]  */
      const STATE_PENDING = 0;
/*  [Promises/A+ 2.1.1]  */

      const STATE_FULFILLED = 1;
/*  [Promises/A+ 2.1.2]  */

      const STATE_REJECTED = 2;
/*  [Promises/A+ 2.1.3]  */

/*  promise object constructor  */

      const api = function api(executor) {
  /*  optionally support non-constructor/plain-function call  */
        if (!(this instanceof api)) return new api(executor);
  /*  initialize object  */

        this.id = 'Thenable/1.0.7';
        this.state = STATE_PENDING;
  /*  initial state  */

        this.fulfillValue = undefined;
  /*  initial value  */

  /*  [Promises/A+ 1.3, 2.1.2.2]  */

        this.rejectReason = undefined;
  /*  initial reason */

  /*  [Promises/A+ 1.5, 2.1.3.2]  */

        this.onFulfilled = [];
  /*  initial handlers  */

        this.onRejected = [];
  /*  initial handlers  */

  /*  provide optional information-hiding proxy  */

        this.proxy = {
          then: this.then.bind(this)
        };
  /*  support optional executor function  */

        if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
      };
/*  promise API methods  */


      api.prototype = {
  /*  promise resolving methods  */
        fulfill: function fulfill(value) {
          return deliver(this, STATE_FULFILLED, 'fulfillValue', value);
        },
        reject: function reject(value) {
          return deliver(this, STATE_REJECTED, 'rejectReason', value);
        },

  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
        then: function then(onFulfilled, onRejected) {
          const curr = this;
          const next = new api();
    /*  [Promises/A+ 2.2.7]  */

          curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill'));
    /*  [Promises/A+ 2.2.2/2.2.6]  */

          curr.onRejected.push(resolver(onRejected, next, 'reject'));
    /*  [Promises/A+ 2.2.3/2.2.6]  */

          execute(curr);
          return next.proxy;
    /*  [Promises/A+ 2.2.7, 3.3]  */
        }
      };
/*  deliver an action  */

      var deliver = function deliver(curr, state, name, value) {
        if (curr.state === STATE_PENDING) {
          curr.state = state;
    /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */

          curr[name] = value;
    /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */

          execute(curr);
        }

        return curr;
      };
/*  execute all handlers  */


      var execute = function execute(curr) {
        if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);
      };
/*  execute particular set of handlers  */


      var execute_handlers = function execute_handlers(curr, name, value) {
  /* global setImmediate: true */

  /* global setTimeout: true */

  /*  short-circuit processing  */
        if (curr[name].length === 0) return;
  /*  iterate over all handlers, exactly once  */

        const handlers = curr[name];
        curr[name] = [];
  /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */

        const func = function func() {
          for (let i = 0; i < handlers.length; i++) {
            handlers[i](value);
          }
    /*  [Promises/A+ 2.2.5]  */

        };
  /*  execute procedure asynchronously  */

  /*  [Promises/A+ 2.2.4, 3.1]  */


        if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);
      };
/*  generate a resolver function  */


      var resolver = function resolver(cb, next, method) {
        return function (value) {
          if (typeof cb !== 'function')
      /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
            next[method].call(next, value);
      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
          else {
            let result;

            try {
              result = cb(value);
            }
        /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
            catch (e) {
              next.reject(e);
          /*  [Promises/A+ 2.2.7.2]  */

              return;
            }

            resolve(next, result);
        /*  [Promises/A+ 2.2.7.1]  */
          }
        };
      };
/*  "Promise Resolution Procedure"  */

/*  [Promises/A+ 2.3]  */


      var resolve = function resolve(promise, x) {
  /*  sanity check arguments  */

  /*  [Promises/A+ 2.3.1]  */
        if (promise === x || promise.proxy === x) {
          promise.reject(new TypeError('cannot resolve promise with itself'));
          return;
        }
  /*  surgically check for a "then" method
    (mainly to just call the "getter" of "then" only once)  */


        let then;

        if (_typeof(x) === 'object' && x !== null || typeof x === 'function') {
          try {
            then = x.then;
          }
    /*  [Promises/A+ 2.3.3.1, 3.5]  */
          catch (e) {
            promise.reject(e);
      /*  [Promises/A+ 2.3.3.2]  */

            return;
          }
        }
  /*  handle own Thenables    [Promises/A+ 2.3.2]
    and similar "thenables" [Promises/A+ 2.3.3]  */


        if (typeof then === 'function') {
          let resolved = false;

          try {
      /*  call retrieved "then" method */

      /*  [Promises/A+ 2.3.3.3]  */
            then.call(x,
      /*  resolvePromise  */

      /*  [Promises/A+ 2.3.3.3.1]  */
                      function (y) {
                        if (resolved) return;
                        resolved = true;
        /*  [Promises/A+ 2.3.3.3.3]  */

                        if (y === x)
          /*  [Promises/A+ 3.6]  */
                          promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);
                      },
      /*  rejectPromise  */

      /*  [Promises/A+ 2.3.3.3.2]  */
                      function (r) {
                        if (resolved) return;
                        resolved = true;
        /*  [Promises/A+ 2.3.3.3.3]  */

                        promise.reject(r);
                      });
          } catch (e) {
            if (!resolved)
        /*  [Promises/A+ 2.3.3.3.3]  */
              promise.reject(e);
      /*  [Promises/A+ 2.3.3.3.4]  */
          }

          return;
        }
  /*  handle other values  */


        promise.fulfill(x);
  /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
      }; // so we always have Promise.all()


      api.all = function (ps) {
        return new api(function (resolveAll, rejectAll) {
          const vals = new Array(ps.length);
          let doneCount = 0;

          const fulfill = function fulfill(i, val) {
            vals[i] = val;
            doneCount++;

            if (doneCount === ps.length) {
              resolveAll(vals);
            }
          };

          for (let i = 0; i < ps.length; i++) {
            (function (i) {
              const p = ps[i];
              const isPromise = p != null && p.then != null;

              if (isPromise) {
                p.then(function (val) {
                  fulfill(i, val);
                }, function (err) {
                  rejectAll(err);
                });
              } else {
                const val = p;
                fulfill(i, val);
              }
            })(i);
          }
        });
      };

      api.resolve = function (val) {
        return new api(function (resolve, reject) {
          resolve(val);
        });
      };

      api.reject = function (val) {
        return new api(function (resolve, reject) {
          reject(val);
        });
      };

      const Promise$1 = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef

      const Animation = function Animation(target, opts, opts2) {
        const isCore = core(target);
        const isEle = !isCore;

        const _p = this._private = extend({
          duration: 1000
        }, opts, opts2);

        _p.target = target;
        _p.style = _p.style || _p.css;
        _p.started = false;
        _p.playing = false;
        _p.hooked = false;
        _p.applying = false;
        _p.progress = 0;
        _p.completes = [];
        _p.frames = [];

        if (_p.complete && fn(_p.complete)) {
          _p.completes.push(_p.complete);
        }

        if (isEle) {
          const pos = target.position();
          _p.startPosition = _p.startPosition || {
            x: pos.x,
            y: pos.y
          };
          _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);
        }

        if (isCore) {
          const pan = target.pan();
          _p.startPan = {
            x: pan.x,
            y: pan.y
          };
          _p.startZoom = target.zoom();
        } // for future timeline/animations impl


        this.length = 1;
        this[0] = this;
      };

      const anifn = Animation.prototype;
      extend(anifn, {
        instanceString: function instanceString() {
          return 'animation';
        },
        hook: function hook() {
          const _p = this._private;

          if (!_p.hooked) {
      // add to target's animation queue
            let q;
            const tAni = _p.target._private.animation;

            if (_p.queue) {
              q = tAni.queue;
            } else {
              q = tAni.current;
            }

            q.push(this); // add to the animation loop pool

            if (elementOrCollection(_p.target)) {
              _p.target.cy().addToAnimationPool(_p.target);
            }

            _p.hooked = true;
          }

          return this;
        },
        play: function play() {
          const _p = this._private; // autorewind

          if (_p.progress === 1) {
            _p.progress = 0;
          }

          _p.playing = true;
          _p.started = false; // needs to be started by animation loop

          _p.stopped = false;
          this.hook(); // the animation loop will start the animation...

          return this;
        },
        playing: function playing() {
          return this._private.playing;
        },
        apply: function apply() {
          const _p = this._private;
          _p.applying = true;
          _p.started = false; // needs to be started by animation loop

          _p.stopped = false;
          this.hook(); // the animation loop will apply the animation at this progress

          return this;
        },
        applying: function applying() {
          return this._private.applying;
        },
        pause: function pause() {
          const _p = this._private;
          _p.playing = false;
          _p.started = false;
          return this;
        },
        stop: function stop() {
          const _p = this._private;
          _p.playing = false;
          _p.started = false;
          _p.stopped = true; // to be removed from animation queues

          return this;
        },
        rewind: function rewind() {
          return this.progress(0);
        },
        fastforward: function fastforward() {
          return this.progress(1);
        },
        time: function time(t) {
          const _p = this._private;

          if (t === undefined) {
            return _p.progress * _p.duration;
          } else {
            return this.progress(t / _p.duration);
          }
        },
        progress: function progress(p) {
          const _p = this._private;
          const wasPlaying = _p.playing;

          if (p === undefined) {
            return _p.progress;
          } else {
            if (wasPlaying) {
              this.pause();
            }

            _p.progress = p;
            _p.started = false;

            if (wasPlaying) {
              this.play();
            }
          }

          return this;
        },
        completed: function completed() {
          return this._private.progress === 1;
        },
        reverse: function reverse() {
          const _p = this._private;
          const wasPlaying = _p.playing;

          if (wasPlaying) {
            this.pause();
          }

          _p.progress = 1 - _p.progress;
          _p.started = false;

          const swap = function swap(a, b) {
            const _pa = _p[a];

            if (_pa == null) {
              return;
            }

            _p[a] = _p[b];
            _p[b] = _pa;
          };

          swap('zoom', 'startZoom');
          swap('pan', 'startPan');
          swap('position', 'startPosition'); // swap styles

          if (_p.style) {
            for (let i = 0; i < _p.style.length; i++) {
              const prop = _p.style[i];
              const name = prop.name;
              const startStyleProp = _p.startStyle[name];
              _p.startStyle[name] = prop;
              _p.style[i] = startStyleProp;
            }
          }

          if (wasPlaying) {
            this.play();
          }

          return this;
        },
        promise: function promise(type) {
          const _p = this._private;
          let arr;

          switch (type) {
            case 'frame':
              arr = _p.frames;
              break;

            default:
            case 'complete':
            case 'completed':
              arr = _p.completes;
          }

          return new Promise$1(function (resolve, reject) {
            arr.push(function () {
              resolve();
            });
          });
        }
      });
      anifn.complete = anifn.completed;
      anifn.run = anifn.play;
      anifn.running = anifn.playing;

      const define = {
        animated: function animated() {
          return function animatedImpl() {
            const self = this;
            const selfIsArrayLike = self.length !== undefined;
            const all = selfIsArrayLike ? self : [self]; // put in array if not array-like

            const cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return false;
            }

            const ele = all[0];

            if (ele) {
              return ele._private.animation.current.length > 0;
            }
          };
        },
  // animated
        clearQueue: function clearQueue() {
          return function clearQueueImpl() {
            const self = this;
            const selfIsArrayLike = self.length !== undefined;
            const all = selfIsArrayLike ? self : [self]; // put in array if not array-like

            const cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            for (let i = 0; i < all.length; i++) {
              const ele = all[i];
              ele._private.animation.queue = [];
            }

            return this;
          };
        },
  // clearQueue
        delay: function delay() {
          return function delayImpl(time, complete) {
            const cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            return this.animate({
              delay: time,
              duration: time,
              complete: complete
            });
          };
        },
  // delay
        delayAnimation: function delayAnimation() {
          return function delayAnimationImpl(time, complete) {
            const cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            return this.animation({
              delay: time,
              duration: time,
              complete: complete
            });
          };
        },
  // delay
        animation: function animation() {
          return function animationImpl(properties, params) {
            const self = this;
            const selfIsArrayLike = self.length !== undefined;
            const all = selfIsArrayLike ? self : [self]; // put in array if not array-like

            const cy = this._private.cy || this;
            const isCore = !selfIsArrayLike;
            const isEles = !isCore;

            if (!cy.styleEnabled()) {
              return this;
            }

            const style = cy.style();
            properties = extend({}, properties, params);
            const propertiesEmpty = Object.keys(properties).length === 0;

            if (propertiesEmpty) {
              return new Animation(all[0], properties); // nothing to animate
            }

            if (properties.duration === undefined) {
              properties.duration = 400;
            }

            switch (properties.duration) {
              case 'slow':
                properties.duration = 600;
                break;

              case 'fast':
                properties.duration = 200;
                break;
            }

            if (isEles) {
              properties.style = style.getPropsList(properties.style || properties.css);
              properties.css = undefined;
            }

            if (isEles && properties.renderedPosition != null) {
              const rpos = properties.renderedPosition;
              const pan = cy.pan();
              const zoom = cy.zoom();
              properties.position = renderedToModelPosition(rpos, zoom, pan);
            } // override pan w/ panBy if set


            if (isCore && properties.panBy != null) {
              const panBy = properties.panBy;
              const cyPan = cy.pan();
              properties.pan = {
                x: cyPan.x + panBy.x,
                y: cyPan.y + panBy.y
              };
            } // override pan w/ center if set


            const center = properties.center || properties.centre;

            if (isCore && center != null) {
              const centerPan = cy.getCenterPan(center.eles, properties.zoom);

              if (centerPan != null) {
                properties.pan = centerPan;
              }
            } // override pan & zoom w/ fit if set


            if (isCore && properties.fit != null) {
              const fit = properties.fit;
              const fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);

              if (fitVp != null) {
                properties.pan = fitVp.pan;
                properties.zoom = fitVp.zoom;
              }
            } // override zoom (& potentially pan) w/ zoom obj if set


            if (isCore && plainObject(properties.zoom)) {
              const vp = cy.getZoomedViewport(properties.zoom);

              if (vp != null) {
                if (vp.zoomed) {
                  properties.zoom = vp.zoom;
                }

                if (vp.panned) {
                  properties.pan = vp.pan;
                }
              } else {
                properties.zoom = null; // an inavalid zoom (e.g. no delta) gets automatically destroyed
              }
            }

            return new Animation(all[0], properties);
          };
        },
  // animate
        animate: function animate() {
          return function animateImpl(properties, params) {
            const self = this;
            const selfIsArrayLike = self.length !== undefined;
            const all = selfIsArrayLike ? self : [self]; // put in array if not array-like

            const cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            if (params) {
              properties = extend({}, properties, params);
            } // manually hook and run the animation


            for (let i = 0; i < all.length; i++) {
              const ele = all[i];
              const queue = ele.animated() && (properties.queue === undefined || properties.queue);
              const ani = ele.animation(properties, queue ? {
                queue: true
              } : undefined);
              ani.play();
            }

            return this; // chaining
          };
        },
  // animate
        stop: function stop() {
          return function stopImpl(clearQueue, jumpToEnd) {
            const self = this;
            const selfIsArrayLike = self.length !== undefined;
            const all = selfIsArrayLike ? self : [self]; // put in array if not array-like

            const cy = this._private.cy || this;

            if (!cy.styleEnabled()) {
              return this;
            }

            for (let i = 0; i < all.length; i++) {
              const ele = all[i];
              const _p = ele._private;
              const anis = _p.animation.current;

              for (let j = 0; j < anis.length; j++) {
                const ani = anis[j];
                const ani_p = ani._private;

                if (jumpToEnd) {
            // next iteration of the animation loop, the animation
            // will go straight to the end and be removed
                  ani_p.duration = 0;
                }
              } // clear the queue of future animations


              if (clearQueue) {
                _p.animation.queue = [];
              }

              if (!jumpToEnd) {
                _p.animation.current = [];
              }
            } // we have to notify (the animation loop doesn't do it for us on `stop`)


            cy.notify('draw');
            return this;
          };
        } // stop

      }; // define

      const define$1 = {
  // access data field
        data: function data(params) {
          const defaults = {
            field: 'data',
            bindingEvent: 'data',
            allowBinding: false,
            allowSetting: false,
            allowGetting: false,
            settingEvent: 'data',
            settingTriggersEvent: false,
            triggerFnName: 'trigger',
            immutableKeys: {},
      // key => true if immutable
            updateStyle: false,
            beforeGet: function beforeGet(self) {},
            beforeSet: function beforeSet(self, obj) {},
            onSet: function onSet(self) {},
            canSet: function canSet(self) {
              return true;
            }
          };
          params = extend({}, defaults, params);
          return function dataImpl(name, value) {
            const p = params;
            const self = this;
            const selfIsArrayLike = self.length !== undefined;
            const all = selfIsArrayLike ? self : [self]; // put in array if not array-like

            const single = selfIsArrayLike ? self[0] : self; // .data('foo', ...)

            if (string(name)) {
        // set or get property
        // .data('foo')
              if (p.allowGetting && value === undefined) {
          // get
                let ret;

                if (single) {
                  p.beforeGet(single);
                  ret = single._private[p.field][name];
                }

                return ret; // .data('foo', 'bar')
              } else if (p.allowSetting && value !== undefined) {
          // set
                const valid = !p.immutableKeys[name];

                if (valid) {
                  const change = _defineProperty({}, name, value);

                  p.beforeSet(self, change);

                  for (let i = 0, l = all.length; i < l; i++) {
                    const ele = all[i];

                    if (p.canSet(ele)) {
                      ele._private[p.field][name] = value;
                    }
                  } // update mappers if asked


                  if (p.updateStyle) {
                    self.updateStyle();
                  } // call onSet callback


                  p.onSet(self);

                  if (p.settingTriggersEvent) {
                    self[p.triggerFnName](p.settingEvent);
                  }
                }
              } // .data({ 'foo': 'bar' })

            } else if (p.allowSetting && plainObject(name)) {
        // extend
              const obj = name;
              let k, v;
              const keys = Object.keys(obj);
              p.beforeSet(self, obj);

              for (let _i = 0; _i < keys.length; _i++) {
                k = keys[_i];
                v = obj[k];

                const _valid = !p.immutableKeys[k];

                if (_valid) {
                  for (let j = 0; j < all.length; j++) {
                    const _ele = all[j];

                    if (p.canSet(_ele)) {
                      _ele._private[p.field][k] = v;
                    }
                  }
                }
              } // update mappers if asked


              if (p.updateStyle) {
                self.updateStyle();
              } // call onSet callback


              p.onSet(self);

              if (p.settingTriggersEvent) {
                self[p.triggerFnName](p.settingEvent);
              } // .data(function(){ ... })

            } else if (p.allowBinding && fn(name)) {
        // bind to event
              const fn$1 = name;
              self.on(p.bindingEvent, fn$1); // .data()
            } else if (p.allowGetting && name === undefined) {
        // get whole object
              let _ret;

              if (single) {
                p.beforeGet(single);
                _ret = single._private[p.field];
              }

              return _ret;
            }

            return self; // maintain chainability
          }; // function
        },
  // data
  // remove data field
        removeData: function removeData(params) {
          const defaults = {
            field: 'data',
            event: 'data',
            triggerFnName: 'trigger',
            triggerEvent: false,
            immutableKeys: {} // key => true if immutable

          };
          params = extend({}, defaults, params);
          return function removeDataImpl(names) {
            const p = params;
            const self = this;
            const selfIsArrayLike = self.length !== undefined;
            const all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      // .removeData('foo bar')

            if (string(names)) {
        // then get the list of keys, and delete them
              const keys = names.split(/\s+/);
              const l = keys.length;

              for (let i = 0; i < l; i++) {
          // delete each non-empty key
                const key = keys[i];

                if (emptyString(key)) {
                  continue;
                }

                const valid = !p.immutableKeys[key]; // not valid if immutable

                if (valid) {
                  for (let i_a = 0, l_a = all.length; i_a < l_a; i_a++) {
                    all[i_a]._private[p.field][key] = undefined;
                  }
                }
              }

              if (p.triggerEvent) {
                self[p.triggerFnName](p.event);
              } // .removeData()

            } else if (names === undefined) {
        // then delete all keys
              for (let _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {
                const _privateFields = all[_i_a]._private[p.field];

                const _keys = Object.keys(_privateFields);

                for (let _i2 = 0; _i2 < _keys.length; _i2++) {
                  const _key = _keys[_i2];
                  const validKeyToDelete = !p.immutableKeys[_key];

                  if (validKeyToDelete) {
                    _privateFields[_key] = undefined;
                  }
                }
              }

              if (p.triggerEvent) {
                self[p.triggerFnName](p.event);
              }
            }

            return self; // maintain chaining
          }; // function
        } // removeData

      }; // define

      const define$2 = {
        eventAliasesOn: function eventAliasesOn(proto) {
          const p = proto;
          p.addListener = p.listen = p.bind = p.on;
          p.unlisten = p.unbind = p.off = p.removeListener;
          p.trigger = p.emit; // this is just a wrapper alias of .on()

          p.pon = p.promiseOn = function (events, selector) {
            const self = this;
            const args = Array.prototype.slice.call(arguments, 0);
            return new Promise$1(function (resolve, reject) {
              const callback = function callback(e) {
                self.off.apply(self, offArgs);
                resolve(e);
              };

              const onArgs = args.concat([callback]);
              var offArgs = onArgs.concat([]);
              self.on.apply(self, onArgs);
            });
          };
        }
      }; // define

// use this module to cherry pick functions into your prototype
      const define$3 = {};
      [define, define$1, define$2].forEach(function (m) {
        extend(define$3, m);
      });

      const elesfn$d = {
        animate: define$3.animate(),
        animation: define$3.animation(),
        animated: define$3.animated(),
        clearQueue: define$3.clearQueue(),
        delay: define$3.delay(),
        delayAnimation: define$3.delayAnimation(),
        stop: define$3.stop()
      };

      const elesfn$e = {
        classes: function classes(_classes) {
          const self = this;

          if (_classes === undefined) {
            const ret = [];

            self[0]._private.classes.forEach(function (cls) {
              return ret.push(cls);
            });

            return ret;
          } else if (!array(_classes)) {
      // extract classes from string
            _classes = (_classes || '').match(/\S+/g) || [];
          }

          const changed = [];
          const classesSet = new Set$1(_classes); // check and update each ele

          for (let j = 0; j < self.length; j++) {
            const ele = self[j];
            const _p = ele._private;
            const eleClasses = _p.classes;
            let changedEle = false; // check if ele has all of the passed classes

            for (let i = 0; i < _classes.length; i++) {
              const cls = _classes[i];
              const eleHasClass = eleClasses.has(cls);

              if (!eleHasClass) {
                changedEle = true;
                break;
              }
            } // check if ele has classes outside of those passed


            if (!changedEle) {
              changedEle = eleClasses.size !== _classes.length;
            }

            if (changedEle) {
              _p.classes = classesSet;
              changed.push(ele);
            }
          } // trigger update style on those eles that had class changes


          if (changed.length > 0) {
            this.spawn(changed).updateStyle().emit('class');
          }

          return self;
        },
        addClass: function addClass(classes) {
          return this.toggleClass(classes, true);
        },
        hasClass: function hasClass(className) {
          const ele = this[0];
          return ele != null && ele._private.classes.has(className);
        },
        toggleClass: function toggleClass(classes, toggle) {
          if (!array(classes)) {
      // extract classes from string
            classes = classes.match(/\S+/g) || [];
          }

          const self = this;
          const toggleUndefd = toggle === undefined;
          const changed = []; // eles who had classes changed

          for (let i = 0, il = self.length; i < il; i++) {
            const ele = self[i];
            const eleClasses = ele._private.classes;
            let changedEle = false;

            for (let j = 0; j < classes.length; j++) {
              const cls = classes[j];
              const hasClass = eleClasses.has(cls);
              let changedNow = false;

              if (toggle || toggleUndefd && !hasClass) {
                eleClasses.add(cls);
                changedNow = true;
              } else if (!toggle || toggleUndefd && hasClass) {
                eleClasses["delete"](cls);
                changedNow = true;
              }

              if (!changedEle && changedNow) {
                changed.push(ele);
                changedEle = true;
              }
            } // for j classes

          } // for i eles
    // trigger update style on those eles that had class changes


          if (changed.length > 0) {
            this.spawn(changed).updateStyle().emit('class');
          }

          return self;
        },
        removeClass: function removeClass(classes) {
          return this.toggleClass(classes, false);
        },
        flashClass: function flashClass(classes, duration) {
          const self = this;

          if (duration == null) {
            duration = 250;
          } else if (duration === 0) {
            return self; // nothing to do really
          }

          self.addClass(classes);
          setTimeout(function () {
            self.removeClass(classes);
          }, duration);
          return self;
        }
      };
      elesfn$e.className = elesfn$e.classNames = elesfn$e.classes;

      const tokens = {
        metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]',
  // chars we need to escape in let names, etc
        comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=',
  // binary comparison op (used in data selectors)
        boolOp: '\\?|\\!|\\^',
  // boolean (unary) operators (used in data selectors)
        string: '"(?:\\\\"|[^"])*"' + '|' + "'(?:\\\\'|[^'])*'",
  // string literals (used in data selectors) -- doublequotes | singlequotes
        number: number$1,
  // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
        meta: 'degree|indegree|outdegree',
  // allowed metadata fields (i.e. allowed functions to use from Collection)
        separator: '\\s*,\\s*',
  // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
        descendant: '\\s+',
        child: '\\s+>\\s+',
        subject: '\\$',
        group: 'node|edge|\\*',
        directedEdge: '\\s+->\\s+',
        undirectedEdge: '\\s+<->\\s+'
      };
      tokens.variable = '(?:[\\w-]|(?:\\\\' + tokens.metaChar + '))+'; // a variable name

      tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number

      tokens.className = tokens.variable; // a class name (follows variable conventions)

      tokens.id = tokens.variable; // an element id (follows variable conventions)

      (function () {
        let ops, op, i; // add @ variants to comparatorOp

        ops = tokens.comparatorOp.split('|');

        for (i = 0; i < ops.length; i++) {
          op = ops[i];
          tokens.comparatorOp += '|@' + op;
        } // add ! variants to comparatorOp


        ops = tokens.comparatorOp.split('|');

        for (i = 0; i < ops.length; i++) {
          op = ops[i];

          if (op.indexOf('!') >= 0) {
            continue;
          } // skip ops that explicitly contain !


          if (op === '=') {
            continue;
          } // skip = b/c != is explicitly defined


          tokens.comparatorOp += '|\\!' + op;
        }
      })();

/**
 * Make a new query object
 *
 * @prop type {Type} The type enum (int) of the query
 * @prop checks List of checks to make against an ele to test for a match
 */
      const newQuery = function newQuery() {
        return {
          checks: []
        };
      };

/**
 * A check type enum-like object.  Uses integer values for fast match() lookup.
 * The ordering does not matter as long as the ints are unique.
 */
      const Type = {
  /** E.g. node */
        GROUP: 0,

  /** A collection of elements */
        COLLECTION: 1,

  /** A filter(ele) function */
        FILTER: 2,

  /** E.g. [foo > 1] */
        DATA_COMPARE: 3,

  /** E.g. [foo] */
        DATA_EXIST: 4,

  /** E.g. [?foo] */
        DATA_BOOL: 5,

  /** E.g. [[degree > 2]] */
        META_COMPARE: 6,

  /** E.g. :selected */
        STATE: 7,

  /** E.g. #foo */
        ID: 8,

  /** E.g. .foo */
        CLASS: 9,

  /** E.g. #foo <-> #bar */
        UNDIRECTED_EDGE: 10,

  /** E.g. #foo -> #bar */
        DIRECTED_EDGE: 11,

  /** E.g. $#foo -> #bar */
        NODE_SOURCE: 12,

  /** E.g. #foo -> $#bar */
        NODE_TARGET: 13,

  /** E.g. $#foo <-> #bar */
        NODE_NEIGHBOR: 14,

  /** E.g. #foo > #bar */
        CHILD: 15,

  /** E.g. #foo #bar */
        DESCENDANT: 16,

  /** E.g. $#foo > #bar */
        PARENT: 17,

  /** E.g. $#foo #bar */
        ANCESTOR: 18,

  /** E.g. #foo > $bar > #baz */
        COMPOUND_SPLIT: 19,

  /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */
        TRUE: 20
      };

      const stateSelectors = [{
        selector: ':selected',
        matches: function matches(ele) {
          return ele.selected();
        }
      }, {
        selector: ':unselected',
        matches: function matches(ele) {
          return !ele.selected();
        }
      }, {
        selector: ':selectable',
        matches: function matches(ele) {
          return ele.selectable();
        }
      }, {
        selector: ':unselectable',
        matches: function matches(ele) {
          return !ele.selectable();
        }
      }, {
        selector: ':locked',
        matches: function matches(ele) {
          return ele.locked();
        }
      }, {
        selector: ':unlocked',
        matches: function matches(ele) {
          return !ele.locked();
        }
      }, {
        selector: ':visible',
        matches: function matches(ele) {
          return ele.visible();
        }
      }, {
        selector: ':hidden',
        matches: function matches(ele) {
          return !ele.visible();
        }
      }, {
        selector: ':transparent',
        matches: function matches(ele) {
          return ele.transparent();
        }
      }, {
        selector: ':grabbed',
        matches: function matches(ele) {
          return ele.grabbed();
        }
      }, {
        selector: ':free',
        matches: function matches(ele) {
          return !ele.grabbed();
        }
      }, {
        selector: ':removed',
        matches: function matches(ele) {
          return ele.removed();
        }
      }, {
        selector: ':inside',
        matches: function matches(ele) {
          return !ele.removed();
        }
      }, {
        selector: ':grabbable',
        matches: function matches(ele) {
          return ele.grabbable();
        }
      }, {
        selector: ':ungrabbable',
        matches: function matches(ele) {
          return !ele.grabbable();
        }
      }, {
        selector: ':animated',
        matches: function matches(ele) {
          return ele.animated();
        }
      }, {
        selector: ':unanimated',
        matches: function matches(ele) {
          return !ele.animated();
        }
      }, {
        selector: ':parent',
        matches: function matches(ele) {
          return ele.isParent();
        }
      }, {
        selector: ':childless',
        matches: function matches(ele) {
          return ele.isChildless();
        }
      }, {
        selector: ':child',
        matches: function matches(ele) {
          return ele.isChild();
        }
      }, {
        selector: ':orphan',
        matches: function matches(ele) {
          return ele.isOrphan();
        }
      }, {
        selector: ':nonorphan',
        matches: function matches(ele) {
          return ele.isChild();
        }
      }, {
        selector: ':compound',
        matches: function matches(ele) {
          if (ele.isNode()) {
            return ele.isParent();
          } else {
            return ele.source().isParent() || ele.target().isParent();
          }
        }
      }, {
        selector: ':loop',
        matches: function matches(ele) {
          return ele.isLoop();
        }
      }, {
        selector: ':simple',
        matches: function matches(ele) {
          return ele.isSimple();
        }
      }, {
        selector: ':active',
        matches: function matches(ele) {
          return ele.active();
        }
      }, {
        selector: ':inactive',
        matches: function matches(ele) {
          return !ele.active();
        }
      }, {
        selector: ':backgrounding',
        matches: function matches(ele) {
          return ele.backgrounding();
        }
      }, {
        selector: ':nonbackgrounding',
        matches: function matches(ele) {
          return !ele.backgrounding();
        }
      }].sort(function (a, b) {
  // n.b. selectors that are starting substrings of others must have the longer ones first
        return descending(a.selector, b.selector);
      });

      const lookup = function () {
        const selToFn = {};
        let s;

        for (let i = 0; i < stateSelectors.length; i++) {
          s = stateSelectors[i];
          selToFn[s.selector] = s.matches;
        }

        return selToFn;
      }();

      const stateSelectorMatches = function stateSelectorMatches(sel, ele) {
        return lookup[sel](ele);
      };
      const stateSelectorRegex = '(' + stateSelectors.map(function (s) {
        return s.selector;
      }).join('|') + ')';

// so that values get compared properly in Selector.filter()

      const cleanMetaChars = function cleanMetaChars(str) {
        return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {
          return $1;
        });
      };

      const replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {
        selector[selector.length - 1] = replacementQuery;
      }; // NOTE: add new expression syntax here to have it recognised by the parser;
// - a query contains all adjacent (i.e. no separator in between) expressions;
// - the current query is stored in selector[i]
// - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward


      const exprs = [{
        name: 'group',
  // just used for identifying when debugging
        query: true,
        regex: '(' + tokens.group + ')',
        populate: function populate(selector, query, _ref) {
          const _ref2 = _slicedToArray(_ref, 1),
            group = _ref2[0];

          query.checks.push({
            type: Type.GROUP,
            value: group === '*' ? group : group + 's'
          });
        }
      }, {
        name: 'state',
        query: true,
        regex: stateSelectorRegex,
        populate: function populate(selector, query, _ref3) {
          const _ref4 = _slicedToArray(_ref3, 1),
            state = _ref4[0];

          query.checks.push({
            type: Type.STATE,
            value: state
          });
        }
      }, {
        name: 'id',
        query: true,
        regex: '\\#(' + tokens.id + ')',
        populate: function populate(selector, query, _ref5) {
          const _ref6 = _slicedToArray(_ref5, 1),
            id = _ref6[0];

          query.checks.push({
            type: Type.ID,
            value: cleanMetaChars(id)
          });
        }
      }, {
        name: 'className',
        query: true,
        regex: '\\.(' + tokens.className + ')',
        populate: function populate(selector, query, _ref7) {
          const _ref8 = _slicedToArray(_ref7, 1),
            className = _ref8[0];

          query.checks.push({
            type: Type.CLASS,
            value: cleanMetaChars(className)
          });
        }
      }, {
        name: 'dataExists',
        query: true,
        regex: '\\[\\s*(' + tokens.variable + ')\\s*\\]',
        populate: function populate(selector, query, _ref9) {
          const _ref10 = _slicedToArray(_ref9, 1),
            variable = _ref10[0];

          query.checks.push({
            type: Type.DATA_EXIST,
            field: cleanMetaChars(variable)
          });
        }
      }, {
        name: 'dataCompare',
        query: true,
        regex: '\\[\\s*(' + tokens.variable + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.value + ')\\s*\\]',
        populate: function populate(selector, query, _ref11) {
          let _ref12 = _slicedToArray(_ref11, 3),
            variable = _ref12[0],
            comparatorOp = _ref12[1],
            value = _ref12[2];

          const valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

          if (valueIsString) {
            value = value.substring(1, value.length - 1);
          } else {
            value = parseFloat(value);
          }

          query.checks.push({
            type: Type.DATA_COMPARE,
            field: cleanMetaChars(variable),
            operator: comparatorOp,
            value: value
          });
        }
      }, {
        name: 'dataBool',
        query: true,
        regex: '\\[\\s*(' + tokens.boolOp + ')\\s*(' + tokens.variable + ')\\s*\\]',
        populate: function populate(selector, query, _ref13) {
          const _ref14 = _slicedToArray(_ref13, 2),
            boolOp = _ref14[0],
            variable = _ref14[1];

          query.checks.push({
            type: Type.DATA_BOOL,
            field: cleanMetaChars(variable),
            operator: boolOp
          });
        }
      }, {
        name: 'metaCompare',
        query: true,
        regex: '\\[\\[\\s*(' + tokens.meta + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.number + ')\\s*\\]\\]',
        populate: function populate(selector, query, _ref15) {
          const _ref16 = _slicedToArray(_ref15, 3),
            meta = _ref16[0],
            comparatorOp = _ref16[1],
            number = _ref16[2];

          query.checks.push({
            type: Type.META_COMPARE,
            field: cleanMetaChars(meta),
            operator: comparatorOp,
            value: parseFloat(number)
          });
        }
      }, {
        name: 'nextQuery',
        separator: true,
        regex: tokens.separator,
        populate: function populate(selector, query) {
          const currentSubject = selector.currentSubject;
          const edgeCount = selector.edgeCount;
          const compoundCount = selector.compoundCount;
          const lastQ = selector[selector.length - 1];

          if (currentSubject != null) {
            lastQ.subject = currentSubject;
            selector.currentSubject = null;
          }

          lastQ.edgeCount = edgeCount;
          lastQ.compoundCount = compoundCount;
          selector.edgeCount = 0;
          selector.compoundCount = 0; // go on to next query

          const nextQuery = selector[selector.length++] = newQuery();
          return nextQuery; // this is the new query to be filled by the following exprs
        }
      }, {
        name: 'directedEdge',
        separator: true,
        regex: tokens.directedEdge,
        populate: function populate(selector, query) {
          if (selector.currentSubject == null) {
      // undirected edge
            const edgeQuery = newQuery();
            const source = query;
            const target = newQuery();
            edgeQuery.checks.push({
              type: Type.DIRECTED_EDGE,
              source: source,
              target: target
            }); // the query in the selector should be the edge rather than the source

            replaceLastQuery(selector, query, edgeQuery);
            selector.edgeCount++; // we're now populating the target query with expressions that follow

            return target;
          } else {
      // source/target
            const srcTgtQ = newQuery();
            const _source = query;

            const _target = newQuery();

            srcTgtQ.checks.push({
              type: Type.NODE_SOURCE,
              source: _source,
              target: _target
            }); // the query in the selector should be the neighbourhood rather than the node

            replaceLastQuery(selector, query, srcTgtQ);
            selector.edgeCount++;
            return _target; // now populating the target with the following expressions
          }
        }
      }, {
        name: 'undirectedEdge',
        separator: true,
        regex: tokens.undirectedEdge,
        populate: function populate(selector, query) {
          if (selector.currentSubject == null) {
      // undirected edge
            const edgeQuery = newQuery();
            const source = query;
            const target = newQuery();
            edgeQuery.checks.push({
              type: Type.UNDIRECTED_EDGE,
              nodes: [source, target]
            }); // the query in the selector should be the edge rather than the source

            replaceLastQuery(selector, query, edgeQuery);
            selector.edgeCount++; // we're now populating the target query with expressions that follow

            return target;
          } else {
      // neighbourhood
            const nhoodQ = newQuery();
            const node = query;
            const neighbor = newQuery();
            nhoodQ.checks.push({
              type: Type.NODE_NEIGHBOR,
              node: node,
              neighbor: neighbor
            }); // the query in the selector should be the neighbourhood rather than the node

            replaceLastQuery(selector, query, nhoodQ);
            return neighbor; // now populating the neighbor with following expressions
          }
        }
      }, {
        name: 'child',
        separator: true,
        regex: tokens.child,
        populate: function populate(selector, query) {
          if (selector.currentSubject == null) {
      // default: child query
            const parentChildQuery = newQuery();
            const child = newQuery();
            const parent = selector[selector.length - 1];
            parentChildQuery.checks.push({
              type: Type.CHILD,
              parent: parent,
              child: child
            }); // the query in the selector should be the '>' itself

            replaceLastQuery(selector, query, parentChildQuery);
            selector.compoundCount++; // we're now populating the child query with expressions that follow

            return child;
          } else if (selector.currentSubject === query) {
      // compound split query
            const compound = newQuery();
            const left = selector[selector.length - 1];
            const right = newQuery();
            const subject = newQuery();

            const _child = newQuery();

            const _parent = newQuery(); // set up the root compound q


            compound.checks.push({
              type: Type.COMPOUND_SPLIT,
              left: left,
              right: right,
              subject: subject
            }); // populate the subject and replace the q at the old spot (within left) with TRUE

            subject.checks = query.checks; // take the checks from the left

            query.checks = [{
              type: Type.TRUE
            }]; // checks under left refs the subject implicitly
      // set up the right q

            _parent.checks.push({
              type: Type.TRUE
            }); // parent implicitly refs the subject


            right.checks.push({
              type: Type.PARENT,
        // type is swapped on right side queries
              parent: _parent,
              child: _child // empty for now

            });
            replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`

            selector.currentSubject = subject;
            selector.compoundCount++;
            return _child; // now populating the right side's child
          } else {
      // parent query
      // info for parent query
            const _parent2 = newQuery();

            const _child2 = newQuery();

            const pcQChecks = [{
              type: Type.PARENT,
              parent: _parent2,
              child: _child2
            }]; // the parent-child query takes the place of the query previously being populated

            _parent2.checks = query.checks; // the previous query contains the checks for the parent

            query.checks = pcQChecks; // pc query takes over

            selector.compoundCount++;
            return _child2; // we're now populating the child
          }
        }
      }, {
        name: 'descendant',
        separator: true,
        regex: tokens.descendant,
        populate: function populate(selector, query) {
          if (selector.currentSubject == null) {
      // default: descendant query
            const ancChQuery = newQuery();
            const descendant = newQuery();
            const ancestor = selector[selector.length - 1];
            ancChQuery.checks.push({
              type: Type.DESCENDANT,
              ancestor: ancestor,
              descendant: descendant
            }); // the query in the selector should be the '>' itself

            replaceLastQuery(selector, query, ancChQuery);
            selector.compoundCount++; // we're now populating the descendant query with expressions that follow

            return descendant;
          } else if (selector.currentSubject === query) {
      // compound split query
            const compound = newQuery();
            const left = selector[selector.length - 1];
            const right = newQuery();
            const subject = newQuery();

            const _descendant = newQuery();

            const _ancestor = newQuery(); // set up the root compound q


            compound.checks.push({
              type: Type.COMPOUND_SPLIT,
              left: left,
              right: right,
              subject: subject
            }); // populate the subject and replace the q at the old spot (within left) with TRUE

            subject.checks = query.checks; // take the checks from the left

            query.checks = [{
              type: Type.TRUE
            }]; // checks under left refs the subject implicitly
      // set up the right q

            _ancestor.checks.push({
              type: Type.TRUE
            }); // ancestor implicitly refs the subject


            right.checks.push({
              type: Type.ANCESTOR,
        // type is swapped on right side queries
              ancestor: _ancestor,
              descendant: _descendant // empty for now

            });
            replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`

            selector.currentSubject = subject;
            selector.compoundCount++;
            return _descendant; // now populating the right side's descendant
          } else {
      // ancestor query
      // info for parent query
            const _ancestor2 = newQuery();

            const _descendant2 = newQuery();

            const adQChecks = [{
              type: Type.ANCESTOR,
              ancestor: _ancestor2,
              descendant: _descendant2
            }]; // the parent-child query takes the place of the query previously being populated

            _ancestor2.checks = query.checks; // the previous query contains the checks for the parent

            query.checks = adQChecks; // pc query takes over

            selector.compoundCount++;
            return _descendant2; // we're now populating the child
          }
        }
      }, {
        name: 'subject',
        modifier: true,
        regex: tokens.subject,
        populate: function populate(selector, query) {
          if (selector.currentSubject != null && selector.currentSubject !== query) {
            warn('Redefinition of subject in selector `' + selector.toString() + '`');
            return false;
          }

          selector.currentSubject = query;
          const topQ = selector[selector.length - 1];
          const topChk = topQ.checks[0];
          const topType = topChk == null ? null : topChk.type;

          if (topType === Type.DIRECTED_EDGE) {
      // directed edge with subject on the target
      // change to target node check
            topChk.type = Type.NODE_TARGET;
          } else if (topType === Type.UNDIRECTED_EDGE) {
      // undirected edge with subject on the second node
      // change to neighbor check
            topChk.type = Type.NODE_NEIGHBOR;
            topChk.node = topChk.nodes[1]; // second node is subject

            topChk.neighbor = topChk.nodes[0]; // clean up unused fields for new type

            topChk.nodes = null;
          }
        }
      }];
      exprs.forEach(function (e) {
        return e.regexObj = new RegExp('^' + e.regex);
      });

/**
 * Of all the expressions, find the first match in the remaining text.
 * @param {string} remaining The remaining text to parse
 * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`
 */

      const consumeExpr = function consumeExpr(remaining) {
        let expr;
        let match;
        let name;

        for (let j = 0; j < exprs.length; j++) {
          const e = exprs[j];
          const n = e.name;
          const m = remaining.match(e.regexObj);

          if (m != null) {
            match = m;
            expr = e;
            name = n;
            const consumed = m[0];
            remaining = remaining.substring(consumed.length);
            break; // we've consumed one expr, so we can return now
          }
        }

        return {
          expr: expr,
          match: match,
          name: name,
          remaining: remaining
        };
      };
/**
 * Consume all the leading whitespace
 * @param {string} remaining The text to consume
 * @returns The text with the leading whitespace removed
 */


      const consumeWhitespace = function consumeWhitespace(remaining) {
        const match = remaining.match(/^\s+/);

        if (match) {
          const consumed = match[0];
          remaining = remaining.substring(consumed.length);
        }

        return remaining;
      };
/**
 * Parse the string and store the parsed representation in the Selector.
 * @param {string} selector The selector string
 * @returns `true` if the selector was successfully parsed, `false` otherwise
 */


      const parse = function parse(selector) {
        const self = this;
        let remaining = self.inputText = selector;
        let currentQuery = self[0] = newQuery();
        self.length = 1;
        remaining = consumeWhitespace(remaining); // get rid of leading whitespace

        for (;;) {
          const exprInfo = consumeExpr(remaining);

          if (exprInfo.expr == null) {
            warn('The selector `' + selector + '`is invalid');
            return false;
          } else {
            const args = exprInfo.match.slice(1); // let the token populate the selector object in currentQuery

            const ret = exprInfo.expr.populate(self, currentQuery, args);

            if (ret === false) {
              return false; // exit if population failed
            } else if (ret != null) {
              currentQuery = ret; // change the current query to be filled if the expr specifies
            }
          }

          remaining = exprInfo.remaining; // we're done when there's nothing left to parse

          if (remaining.match(/^\s*$/)) {
            break;
          }
        }

        const lastQ = self[self.length - 1];

        if (self.currentSubject != null) {
          lastQ.subject = self.currentSubject;
        }

        lastQ.edgeCount = self.edgeCount;
        lastQ.compoundCount = self.compoundCount;

        for (let i = 0; i < self.length; i++) {
          const q = self[i]; // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations

          if (q.compoundCount > 0 && q.edgeCount > 0) {
            warn('The selector `' + selector + '` is invalid because it uses both a compound selector and an edge selector');
            return false;
          }

          if (q.edgeCount > 1) {
            warn('The selector `' + selector + '` is invalid because it uses multiple edge selectors');
            return false;
          } else if (q.edgeCount === 1) {
            warn('The selector `' + selector + '` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.');
          }
        }

        return true; // success
      };
/**
 * Get the selector represented as a string.  This value uses default formatting,
 * so things like spacing may differ from the input text passed to the constructor.
 * @returns {string} The selector string
 */


      const toString = function toString() {
        if (this.toStringCache != null) {
          return this.toStringCache;
        }

        const clean = function clean(obj) {
          if (obj == null) {
            return '';
          } else {
            return obj;
          }
        };

        const cleanVal = function cleanVal(val) {
          if (string(val)) {
            return '"' + val + '"';
          } else {
            return clean(val);
          }
        };

        const space = function space(val) {
          return ' ' + val + ' ';
        };

        const checkToString = function checkToString(check, subject) {
          const type = check.type,
            value = check.value;

          switch (type) {
            case Type.GROUP:
            {
              const group = clean(value);
              return group.substring(0, group.length - 1);
            }

            case Type.DATA_COMPARE:
            {
              const field = check.field,
                operator = check.operator;
              return '[' + field + space(clean(operator)) + cleanVal(value) + ']';
            }

            case Type.DATA_BOOL:
            {
              const _operator = check.operator,
                _field = check.field;
              return '[' + clean(_operator) + _field + ']';
            }

            case Type.DATA_EXIST:
            {
              const _field2 = check.field;
              return '[' + _field2 + ']';
            }

            case Type.META_COMPARE:
            {
              const _operator2 = check.operator,
                _field3 = check.field;
              return '[[' + _field3 + space(clean(_operator2)) + cleanVal(value) + ']]';
            }

            case Type.STATE:
            {
              return value;
            }

            case Type.ID:
            {
              return '#' + value;
            }

            case Type.CLASS:
            {
              return '.' + value;
            }

            case Type.PARENT:
            case Type.CHILD:
            {
              return queryToString(check.parent, subject) + space('>') + queryToString(check.child, subject);
            }

            case Type.ANCESTOR:
            case Type.DESCENDANT:
            {
              return queryToString(check.ancestor, subject) + ' ' + queryToString(check.descendant, subject);
            }

            case Type.COMPOUND_SPLIT:
            {
              const lhs = queryToString(check.left, subject);
              const sub = queryToString(check.subject, subject);
              const rhs = queryToString(check.right, subject);
              return lhs + (lhs.length > 0 ? ' ' : '') + sub + rhs;
            }

            case Type.TRUE:
            {
              return '';
            }
          }
        };

        var queryToString = function queryToString(query, subject) {
          return query.checks.reduce(function (str, chk, i) {
            return str + (subject === query && i === 0 ? '$' : '') + checkToString(chk, subject);
          }, '');
        };

        let str = '';

        for (let i = 0; i < this.length; i++) {
          const query = this[i];
          str += queryToString(query, query.subject);

          if (this.length > 1 && i < this.length - 1) {
            str += ', ';
          }
        }

        this.toStringCache = str;
        return str;
      };
      const parse$1 = {
        parse: parse,
        toString: toString
      };

      const valCmp = function valCmp(fieldVal, operator, value) {
        let matches;
        const isFieldStr = string(fieldVal);
        const isFieldNum = number(fieldVal);
        const isValStr = string(value);
        let fieldStr, valStr;
        let caseInsensitive = false;
        let notExpr = false;
        let isIneqCmp = false;

        if (operator.indexOf('!') >= 0) {
          operator = operator.replace('!', '');
          notExpr = true;
        }

        if (operator.indexOf('@') >= 0) {
          operator = operator.replace('@', '');
          caseInsensitive = true;
        }

        if (isFieldStr || isValStr || caseInsensitive) {
          fieldStr = !isFieldStr && !isFieldNum ? '' : '' + fieldVal;
          valStr = '' + value;
        } // if we're doing a case insensitive comparison, then we're using a STRING comparison
  // even if we're comparing numbers


        if (caseInsensitive) {
          fieldVal = fieldStr = fieldStr.toLowerCase();
          value = valStr = valStr.toLowerCase();
        }

        switch (operator) {
          case '*=':
            matches = fieldStr.indexOf(valStr) >= 0;
            break;

          case '$=':
            matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;
            break;

          case '^=':
            matches = fieldStr.indexOf(valStr) === 0;
            break;

          case '=':
            matches = fieldVal === value;
            break;

          case '>':
            isIneqCmp = true;
            matches = fieldVal > value;
            break;

          case '>=':
            isIneqCmp = true;
            matches = fieldVal >= value;
            break;

          case '<':
            isIneqCmp = true;
            matches = fieldVal < value;
            break;

          case '<=':
            isIneqCmp = true;
            matches = fieldVal <= value;
            break;

          default:
            matches = false;
            break;
        } // apply the not op, but null vals for inequalities should always stay non-matching


        if (notExpr && (fieldVal != null || !isIneqCmp)) {
          matches = !matches;
        }

        return matches;
      };
      const boolCmp = function boolCmp(fieldVal, operator) {
        switch (operator) {
          case '?':
            return fieldVal ? true : false;

          case '!':
            return fieldVal ? false : true;

          case '^':
            return fieldVal === undefined;
        }
      };
      const existCmp = function existCmp(fieldVal) {
        return fieldVal !== undefined;
      };
      const data = function data(ele, field) {
        return ele.data(field);
      };
      const meta = function meta(ele, field) {
        return ele[field]();
      };

/** A lookup of `match(check, ele)` functions by `Type` int */

      const match = [];
/**
 * Returns whether the query matches for the element
 * @param query The `{ type, value, ... }` query object
 * @param ele The element to compare against
*/

      const matches = function matches(query, ele) {
        return query.checks.every(function (chk) {
          return match[chk.type](chk, ele);
        });
      };

      match[Type.GROUP] = function (check, ele) {
        const group = check.value;
        return group === '*' || group === ele.group();
      };

      match[Type.STATE] = function (check, ele) {
        const stateSelector = check.value;
        return stateSelectorMatches(stateSelector, ele);
      };

      match[Type.ID] = function (check, ele) {
        const id = check.value;
        return ele.id() === id;
      };

      match[Type.CLASS] = function (check, ele) {
        const cls = check.value;
        return ele.hasClass(cls);
      };

      match[Type.META_COMPARE] = function (check, ele) {
        const field = check.field,
          operator = check.operator,
          value = check.value;
        return valCmp(meta(ele, field), operator, value);
      };

      match[Type.DATA_COMPARE] = function (check, ele) {
        const field = check.field,
          operator = check.operator,
          value = check.value;
        return valCmp(data(ele, field), operator, value);
      };

      match[Type.DATA_BOOL] = function (check, ele) {
        const field = check.field,
          operator = check.operator;
        return boolCmp(data(ele, field), operator);
      };

      match[Type.DATA_EXIST] = function (check, ele) {
        const field = check.field,
          operator = check.operator;
        return existCmp(data(ele, field));
      };

      match[Type.UNDIRECTED_EDGE] = function (check, ele) {
        const qA = check.nodes[0];
        const qB = check.nodes[1];
        const src = ele.source();
        const tgt = ele.target();
        return matches(qA, src) && matches(qB, tgt) || matches(qB, src) && matches(qA, tgt);
      };

      match[Type.NODE_NEIGHBOR] = function (check, ele) {
        return matches(check.node, ele) && ele.neighborhood().some(function (n) {
          return n.isNode() && matches(check.neighbor, n);
        });
      };

      match[Type.DIRECTED_EDGE] = function (check, ele) {
        return matches(check.source, ele.source()) && matches(check.target, ele.target());
      };

      match[Type.NODE_SOURCE] = function (check, ele) {
        return matches(check.source, ele) && ele.outgoers().some(function (n) {
          return n.isNode() && matches(check.target, n);
        });
      };

      match[Type.NODE_TARGET] = function (check, ele) {
        return matches(check.target, ele) && ele.incomers().some(function (n) {
          return n.isNode() && matches(check.source, n);
        });
      };

      match[Type.CHILD] = function (check, ele) {
        return matches(check.child, ele) && matches(check.parent, ele.parent());
      };

      match[Type.PARENT] = function (check, ele) {
        return matches(check.parent, ele) && ele.children().some(function (c) {
          return matches(check.child, c);
        });
      };

      match[Type.DESCENDANT] = function (check, ele) {
        return matches(check.descendant, ele) && ele.ancestors().some(function (a) {
          return matches(check.ancestor, a);
        });
      };

      match[Type.ANCESTOR] = function (check, ele) {
        return matches(check.ancestor, ele) && ele.descendants().some(function (d) {
          return matches(check.descendant, d);
        });
      };

      match[Type.COMPOUND_SPLIT] = function (check, ele) {
        return matches(check.subject, ele) && matches(check.left, ele) && matches(check.right, ele);
      };

      match[Type.TRUE] = function () {
        return true;
      };

      match[Type.COLLECTION] = function (check, ele) {
        const collection = check.value;
        return collection.has(ele);
      };

      match[Type.FILTER] = function (check, ele) {
        const filter = check.value;
        return filter(ele);
      };

      const filter = function filter(collection) {
        const self = this; // for 1 id #foo queries, just get the element

        if (self.length === 1 && self[0].checks.length === 1 && self[0].checks[0].type === Type.ID) {
          return collection.getElementById(self[0].checks[0].value).collection();
        }

        let selectorFunction = function selectorFunction(element) {
          for (let j = 0; j < self.length; j++) {
            const query = self[j];

            if (matches(query, element)) {
              return true;
            }
          }

          return false;
        };

        if (self.text() == null) {
          selectorFunction = function selectorFunction() {
            return true;
          };
        }

        return collection.filter(selectorFunction);
      }; // filter
// does selector match a single element?


      const matches$1 = function matches$1(ele) {
        const self = this;

        for (let j = 0; j < self.length; j++) {
          const query = self[j];

          if (matches(query, ele)) {
            return true;
          }
        }

        return false;
      }; // matches


      const matching = {
        matches: matches$1,
        filter: filter
      };

      const Selector = function Selector(selector) {
        this.inputText = selector;
        this.currentSubject = null;
        this.compoundCount = 0;
        this.edgeCount = 0;
        this.length = 0;

        if (selector == null || string(selector) && selector.match(/^\s*$/)) ; else if (elementOrCollection(selector)) {
          this.addQuery({
            checks: [{
              type: Type.COLLECTION,
              value: selector.collection()
            }]
          });
        } else if (fn(selector)) {
          this.addQuery({
            checks: [{
              type: Type.FILTER,
              value: selector
            }]
          });
        } else if (string(selector)) {
          if (!this.parse(selector)) {
            this.invalid = true;
          }
        } else {
          error('A selector must be created from a string; found ');
        }
      };

      const selfn = Selector.prototype;
      [parse$1, matching].forEach(function (p) {
        return extend(selfn, p);
      });

      selfn.text = function () {
        return this.inputText;
      };

      selfn.size = function () {
        return this.length;
      };

      selfn.eq = function (i) {
        return this[i];
      };

      selfn.sameText = function (otherSel) {
        return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();
      };

      selfn.addQuery = function (q) {
        this[this.length++] = q;
      };

      selfn.selector = selfn.toString;

      const elesfn$f = {
        allAre: function allAre(selector) {
          const selObj = new Selector(selector);
          return this.every(function (ele) {
            return selObj.matches(ele);
          });
        },
        is: function is(selector) {
          const selObj = new Selector(selector);
          return this.some(function (ele) {
            return selObj.matches(ele);
          });
        },
        some: function some(fn, thisArg) {
          for (let i = 0; i < this.length; i++) {
            const ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

            if (ret) {
              return true;
            }
          }

          return false;
        },
        every: function every(fn, thisArg) {
          for (let i = 0; i < this.length; i++) {
            const ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

            if (!ret) {
              return false;
            }
          }

          return true;
        },
        same: function same(collection) {
    // cheap collection ref check
          if (this === collection) {
            return true;
          }

          collection = this.cy().collection(collection);
          const thisLength = this.length;
          const collectionLength = collection.length; // cheap length check

          if (thisLength !== collectionLength) {
            return false;
          } // cheap element ref check


          if (thisLength === 1) {
            return this[0] === collection[0];
          }

          return this.every(function (ele) {
            return collection.hasElementWithId(ele.id());
          });
        },
        anySame: function anySame(collection) {
          collection = this.cy().collection(collection);
          return this.some(function (ele) {
            return collection.hasElementWithId(ele.id());
          });
        },
        allAreNeighbors: function allAreNeighbors(collection) {
          collection = this.cy().collection(collection);
          const nhood = this.neighborhood();
          return collection.every(function (ele) {
            return nhood.hasElementWithId(ele.id());
          });
        },
        contains: function contains(collection) {
          collection = this.cy().collection(collection);
          const self = this;
          return collection.every(function (ele) {
            return self.hasElementWithId(ele.id());
          });
        }
      };
      elesfn$f.allAreNeighbours = elesfn$f.allAreNeighbors;
      elesfn$f.has = elesfn$f.contains;
      elesfn$f.equal = elesfn$f.equals = elesfn$f.same;

      const cache = function cache(fn, name) {
        return function traversalCache(arg1, arg2, arg3, arg4) {
          const selectorOrEles = arg1;
          const eles = this;
          let key;

          if (selectorOrEles == null) {
            key = '';
          } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {
            key = selectorOrEles.id();
          }

          if (eles.length === 1 && key) {
            const _p = eles[0]._private;
            const tch = _p.traversalCache = _p.traversalCache || {};
            const ch = tch[name] = tch[name] || [];
            const hash = hashString(key);
            const cacheHit = ch[hash];

            if (cacheHit) {
              return cacheHit;
            } else {
              return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);
            }
          } else {
            return fn.call(eles, arg1, arg2, arg3, arg4);
          }
        };
      };

      const elesfn$g = {
        parent: function parent(selector) {
          const parents = []; // optimisation for single ele call

          if (this.length === 1) {
            const parent = this[0]._private.parent;

            if (parent) {
              return parent;
            }
          }

          for (let i = 0; i < this.length; i++) {
            const ele = this[i];
            const _parent = ele._private.parent;

            if (_parent) {
              parents.push(_parent);
            }
          }

          return this.spawn(parents, true).filter(selector);
        },
        parents: function parents(selector) {
          const parents = [];
          let eles = this.parent();

          while (eles.nonempty()) {
            for (let i = 0; i < eles.length; i++) {
              const ele = eles[i];
              parents.push(ele);
            }

            eles = eles.parent();
          }

          return this.spawn(parents, true).filter(selector);
        },
        commonAncestors: function commonAncestors(selector) {
          let ancestors;

          for (let i = 0; i < this.length; i++) {
            const ele = this[i];
            const parents = ele.parents();
            ancestors = ancestors || parents;
            ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set
          }

          return ancestors.filter(selector);
        },
        orphans: function orphans(selector) {
          return this.stdFilter(function (ele) {
            return ele.isOrphan();
          }).filter(selector);
        },
        nonorphans: function nonorphans(selector) {
          return this.stdFilter(function (ele) {
            return ele.isChild();
          }).filter(selector);
        },
        children: cache(function (selector) {
          const children = [];

          for (let i = 0; i < this.length; i++) {
            const ele = this[i];
            const eleChildren = ele._private.children;

            for (let j = 0; j < eleChildren.length; j++) {
              children.push(eleChildren[j]);
            }
          }

          return this.spawn(children, true).filter(selector);
        }, 'children'),
        siblings: function siblings(selector) {
          return this.parent().children().not(this).filter(selector);
        },
        isParent: function isParent() {
          const ele = this[0];

          if (ele) {
            return ele.isNode() && ele._private.children.length !== 0;
          }
        },
        isChildless: function isChildless() {
          const ele = this[0];

          if (ele) {
            return ele.isNode() && ele._private.children.length === 0;
          }
        },
        isChild: function isChild() {
          const ele = this[0];

          if (ele) {
            return ele.isNode() && ele._private.parent != null;
          }
        },
        isOrphan: function isOrphan() {
          const ele = this[0];

          if (ele) {
            return ele.isNode() && ele._private.parent == null;
          }
        },
        descendants: function descendants(selector) {
          const elements = [];

          function add(eles) {
            for (let i = 0; i < eles.length; i++) {
              const ele = eles[i];
              elements.push(ele);

              if (ele.children().nonempty()) {
                add(ele.children());
              }
            }
          }

          add(this.children());
          return this.spawn(elements, true).filter(selector);
        }
      };

      function forEachCompound(eles, fn, includeSelf, recursiveStep) {
        const q = [];
        const did = new Set$1();
        const cy = eles.cy();
        const hasCompounds = cy.hasCompoundNodes();

        for (let i = 0; i < eles.length; i++) {
          const ele = eles[i];

          if (includeSelf) {
            q.push(ele);
          } else if (hasCompounds) {
            recursiveStep(q, did, ele);
          }
        }

        while (q.length > 0) {
          const _ele = q.shift();

          fn(_ele);
          did.add(_ele.id());

          if (hasCompounds) {
            recursiveStep(q, did, _ele);
          }
        }

        return eles;
      }

      function addChildren(q, did, ele) {
        if (ele.isParent()) {
          const children = ele._private.children;

          for (let i = 0; i < children.length; i++) {
            const child = children[i];

            if (!did.has(child.id())) {
              q.push(child);
            }
          }
        }
      } // very efficient version of eles.add( eles.descendants() ).forEach()
// for internal use


      elesfn$g.forEachDown = function (fn) {
        const includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return forEachCompound(this, fn, includeSelf, addChildren);
      };

      function addParent(q, did, ele) {
        if (ele.isChild()) {
          const parent = ele._private.parent;

          if (!did.has(parent.id())) {
            q.push(parent);
          }
        }
      }

      elesfn$g.forEachUp = function (fn) {
        const includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return forEachCompound(this, fn, includeSelf, addParent);
      };

      function addParentAndChildren(q, did, ele) {
        addParent(q, did, ele);
        addChildren(q, did, ele);
      }

      elesfn$g.forEachUpAndDown = function (fn) {
        const includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return forEachCompound(this, fn, includeSelf, addParentAndChildren);
      }; // aliases


      elesfn$g.ancestors = elesfn$g.parents;

      let fn$1, elesfn$h;
      fn$1 = elesfn$h = {
        data: define$3.data({
          field: 'data',
          bindingEvent: 'data',
          allowBinding: true,
          allowSetting: true,
          settingEvent: 'data',
          settingTriggersEvent: true,
          triggerFnName: 'trigger',
          allowGetting: true,
          immutableKeys: {
            'id': true,
            'source': true,
            'target': true,
            'parent': true
          },
          updateStyle: true
        }),
        removeData: define$3.removeData({
          field: 'data',
          event: 'data',
          triggerFnName: 'trigger',
          triggerEvent: true,
          immutableKeys: {
            'id': true,
            'source': true,
            'target': true,
            'parent': true
          },
          updateStyle: true
        }),
        scratch: define$3.data({
          field: 'scratch',
          bindingEvent: 'scratch',
          allowBinding: true,
          allowSetting: true,
          settingEvent: 'scratch',
          settingTriggersEvent: true,
          triggerFnName: 'trigger',
          allowGetting: true,
          updateStyle: true
        }),
        removeScratch: define$3.removeData({
          field: 'scratch',
          event: 'scratch',
          triggerFnName: 'trigger',
          triggerEvent: true,
          updateStyle: true
        }),
        rscratch: define$3.data({
          field: 'rscratch',
          allowBinding: false,
          allowSetting: true,
          settingTriggersEvent: false,
          allowGetting: true
        }),
        removeRscratch: define$3.removeData({
          field: 'rscratch',
          triggerEvent: false
        }),
        id: function id() {
          const ele = this[0];

          if (ele) {
            return ele._private.data.id;
          }
        }
      }; // aliases

      fn$1.attr = fn$1.data;
      fn$1.removeAttr = fn$1.removeData;
      const data$1 = elesfn$h;

      const elesfn$i = {};

      function defineDegreeFunction(callback) {
        return function (includeLoops) {
          const self = this;

          if (includeLoops === undefined) {
            includeLoops = true;
          }

          if (self.length === 0) {
            return;
          }

          if (self.isNode() && !self.removed()) {
            let degree = 0;
            const node = self[0];
            const connectedEdges = node._private.edges;

            for (let i = 0; i < connectedEdges.length; i++) {
              const edge = connectedEdges[i];

              if (!includeLoops && edge.isLoop()) {
                continue;
              }

              degree += callback(node, edge);
            }

            return degree;
          } else {
            return;
          }
        };
      }

      extend(elesfn$i, {
        degree: defineDegreeFunction(function (node, edge) {
          if (edge.source().same(edge.target())) {
            return 2;
          } else {
            return 1;
          }
        }),
        indegree: defineDegreeFunction(function (node, edge) {
          if (edge.target().same(node)) {
            return 1;
          } else {
            return 0;
          }
        }),
        outdegree: defineDegreeFunction(function (node, edge) {
          if (edge.source().same(node)) {
            return 1;
          } else {
            return 0;
          }
        })
      });

      function defineDegreeBoundsFunction(degreeFn, callback) {
        return function (includeLoops) {
          let ret;
          const nodes = this.nodes();

          for (let i = 0; i < nodes.length; i++) {
            const ele = nodes[i];
            const degree = ele[degreeFn](includeLoops);

            if (degree !== undefined && (ret === undefined || callback(degree, ret))) {
              ret = degree;
            }
          }

          return ret;
        };
      }

      extend(elesfn$i, {
        minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {
          return degree < min;
        }),
        maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {
          return degree > max;
        }),
        minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {
          return degree < min;
        }),
        maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {
          return degree > max;
        }),
        minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {
          return degree < min;
        }),
        maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {
          return degree > max;
        })
      });
      extend(elesfn$i, {
        totalDegree: function totalDegree(includeLoops) {
          let total = 0;
          const nodes = this.nodes();

          for (let i = 0; i < nodes.length; i++) {
            total += nodes[i].degree(includeLoops);
          }

          return total;
        }
      });

      let fn$2, elesfn$j;

      const beforePositionSet = function beforePositionSet(eles, newPos, silent) {
        for (let i = 0; i < eles.length; i++) {
          const ele = eles[i];

          if (!ele.locked()) {
            const oldPos = ele._private.position;
            const delta = {
              x: newPos.x != null ? newPos.x - oldPos.x : 0,
              y: newPos.y != null ? newPos.y - oldPos.y : 0
            };

            if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {
              ele.children().shift(delta, silent);
            }

            ele.dirtyBoundingBoxCache();
          }
        }
      };

      const positionDef = {
        field: 'position',
        bindingEvent: 'position',
        allowBinding: true,
        allowSetting: true,
        settingEvent: 'position',
        settingTriggersEvent: true,
        triggerFnName: 'emitAndNotify',
        allowGetting: true,
        validKeys: ['x', 'y'],
        beforeGet: function beforeGet(ele) {
          ele.updateCompoundBounds();
        },
        beforeSet: function beforeSet(eles, newPos) {
          beforePositionSet(eles, newPos, false);
        },
        onSet: function onSet(eles) {
          eles.dirtyCompoundBoundsCache();
        },
        canSet: function canSet(ele) {
          return !ele.locked();
        }
      };
      fn$2 = elesfn$j = {
        position: define$3.data(positionDef),
  // position but no notification to renderer
        silentPosition: define$3.data(extend({}, positionDef, {
          allowBinding: false,
          allowSetting: true,
          settingTriggersEvent: false,
          allowGetting: false,
          beforeSet: function beforeSet(eles, newPos) {
            beforePositionSet(eles, newPos, true);
          },
          onSet: function onSet(eles) {
            eles.dirtyCompoundBoundsCache();
          }
        })),
        positions: function positions(pos, silent) {
          if (plainObject(pos)) {
            if (silent) {
              this.silentPosition(pos);
            } else {
              this.position(pos);
            }
          } else if (fn(pos)) {
            const _fn = pos;
            const cy = this.cy();
            cy.startBatch();

            for (let i = 0; i < this.length; i++) {
              const ele = this[i];

              let _pos = void 0;

              if (_pos = _fn(ele, i)) {
                if (silent) {
                  ele.silentPosition(_pos);
                } else {
                  ele.position(_pos);
                }
              }
            }

            cy.endBatch();
          }

          return this; // chaining
        },
        silentPositions: function silentPositions(pos) {
          return this.positions(pos, true);
        },
        shift: function shift(dim, val, silent) {
          let delta;

          if (plainObject(dim)) {
            delta = {
              x: number(dim.x) ? dim.x : 0,
              y: number(dim.y) ? dim.y : 0
            };
            silent = val;
          } else if (string(dim) && number(val)) {
            delta = {
              x: 0,
              y: 0
            };
            delta[dim] = val;
          }

          if (delta != null) {
            const cy = this.cy();
            cy.startBatch();

            for (let i = 0; i < this.length; i++) {
              const ele = this[i];
              const pos = ele.position();
              const newPos = {
                x: pos.x + delta.x,
                y: pos.y + delta.y
              };

              if (silent) {
                ele.silentPosition(newPos);
              } else {
                ele.position(newPos);
              }
            }

            cy.endBatch();
          }

          return this;
        },
        silentShift: function silentShift(dim, val) {
          if (plainObject(dim)) {
            this.shift(dim, true);
          } else if (string(dim) && number(val)) {
            this.shift(dim, val, true);
          }

          return this;
        },
  // get/set the rendered (i.e. on screen) positon of the element
        renderedPosition: function renderedPosition(dim, val) {
          const ele = this[0];
          const cy = this.cy();
          const zoom = cy.zoom();
          const pan = cy.pan();
          let rpos = plainObject(dim) ? dim : undefined;
          const setting = rpos !== undefined || val !== undefined && string(dim);

          if (ele && ele.isNode()) {
      // must have an element and must be a node to return position
            if (setting) {
              for (let i = 0; i < this.length; i++) {
                const _ele = this[i];

                if (val !== undefined) {
            // set one dimension
                  _ele.position(dim, (val - pan[dim]) / zoom);
                } else if (rpos !== undefined) {
            // set whole position
                  _ele.position(renderedToModelPosition(rpos, zoom, pan));
                }
              }
            } else {
        // getting
              const pos = ele.position();
              rpos = modelToRenderedPosition(pos, zoom, pan);

              if (dim === undefined) {
          // then return the whole rendered position
                return rpos;
              } else {
          // then return the specified dimension
                return rpos[dim];
              }
            }
          } else if (!setting) {
            return undefined; // for empty collection case
          }

          return this; // chaining
        },
  // get/set the position relative to the parent
        relativePosition: function relativePosition(dim, val) {
          const ele = this[0];
          const cy = this.cy();
          let ppos = plainObject(dim) ? dim : undefined;
          const setting = ppos !== undefined || val !== undefined && string(dim);
          const hasCompoundNodes = cy.hasCompoundNodes();

          if (ele && ele.isNode()) {
      // must have an element and must be a node to return position
            if (setting) {
              for (let i = 0; i < this.length; i++) {
                const _ele2 = this[i];
                let parent = hasCompoundNodes ? _ele2.parent() : null;
                const hasParent = parent && parent.length > 0;
                const relativeToParent = hasParent;

                if (hasParent) {
                  parent = parent[0];
                }

                const origin = relativeToParent ? parent.position() : {
                  x: 0,
                  y: 0
                };

                if (val !== undefined) {
            // set one dimension
                  _ele2.position(dim, val + origin[dim]);
                } else if (ppos !== undefined) {
            // set whole position
                  _ele2.position({
                    x: ppos.x + origin.x,
                    y: ppos.y + origin.y
                  });
                }
              }
            } else {
        // getting
              const pos = ele.position();

              let _parent = hasCompoundNodes ? ele.parent() : null;

              const _hasParent = _parent && _parent.length > 0;

              const _relativeToParent = _hasParent;

              if (_hasParent) {
                _parent = _parent[0];
              }

              const _origin = _relativeToParent ? _parent.position() : {
                x: 0,
                y: 0
              };

              ppos = {
                x: pos.x - _origin.x,
                y: pos.y - _origin.y
              };

              if (dim === undefined) {
          // then return the whole rendered position
                return ppos;
              } else {
          // then return the specified dimension
                return ppos[dim];
              }
            }
          } else if (!setting) {
            return undefined; // for empty collection case
          }

          return this; // chaining
        }
      }; // aliases

      fn$2.modelPosition = fn$2.point = fn$2.position;
      fn$2.modelPositions = fn$2.points = fn$2.positions;
      fn$2.renderedPoint = fn$2.renderedPosition;
      fn$2.relativePoint = fn$2.relativePosition;
      const position = elesfn$j;

      let fn$3, elesfn$k;
      fn$3 = elesfn$k = {};

      elesfn$k.renderedBoundingBox = function (options) {
        const bb = this.boundingBox(options);
        const cy = this.cy();
        const zoom = cy.zoom();
        const pan = cy.pan();
        const x1 = bb.x1 * zoom + pan.x;
        const x2 = bb.x2 * zoom + pan.x;
        const y1 = bb.y1 * zoom + pan.y;
        const y2 = bb.y2 * zoom + pan.y;
        return {
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2,
          w: x2 - x1,
          h: y2 - y1
        };
      };

      elesfn$k.dirtyCompoundBoundsCache = function () {
        const silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        const cy = this.cy();

        if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
          return this;
        }

        this.forEachUp(function (ele) {
          if (ele.isParent()) {
            const _p = ele._private;
            _p.compoundBoundsClean = false;
            _p.bbCache = null;

            if (!silent) {
              ele.emitAndNotify('bounds');
            }
          }
        });
        return this;
      };

      elesfn$k.updateCompoundBounds = function () {
        const force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        const cy = this.cy(); // not possible to do on non-compound graphs or with the style disabled

        if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
          return this;
        } // save cycles when batching -- but bounds will be stale (or not exist yet)


        if (!force && cy.batching()) {
          return this;
        }

        function update(parent) {
          if (!parent.isParent()) {
            return;
          }

          const _p = parent._private;
          const children = parent.children();
          const includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';
          const min = {
            width: {
              val: parent.pstyle('min-width').pfValue,
              left: parent.pstyle('min-width-bias-left'),
              right: parent.pstyle('min-width-bias-right')
            },
            height: {
              val: parent.pstyle('min-height').pfValue,
              top: parent.pstyle('min-height-bias-top'),
              bottom: parent.pstyle('min-height-bias-bottom')
            }
          };
          let bb = children.boundingBox({
            includeLabels: includeLabels,
            includeOverlays: false,
      // updating the compound bounds happens outside of the regular
      // cache cycle (i.e. before fired events)
            useCache: false
          });
          const pos = _p.position; // if children take up zero area then keep position and fall back on stylesheet w/h

          if (bb.w === 0 || bb.h === 0) {
            bb = {
              w: parent.pstyle('width').pfValue,
              h: parent.pstyle('height').pfValue
            };
            bb.x1 = pos.x - bb.w / 2;
            bb.x2 = pos.x + bb.w / 2;
            bb.y1 = pos.y - bb.h / 2;
            bb.y2 = pos.y + bb.h / 2;
          }

          function computeBiasValues(propDiff, propBias, propBiasComplement) {
            let biasDiff = 0;
            let biasComplementDiff = 0;
            const biasTotal = propBias + propBiasComplement;

            if (propDiff > 0 && biasTotal > 0) {
              biasDiff = propBias / biasTotal * propDiff;
              biasComplementDiff = propBiasComplement / biasTotal * propDiff;
            }

            return {
              biasDiff: biasDiff,
              biasComplementDiff: biasComplementDiff
            };
          }

          function computePaddingValues(width, height, paddingObject, relativeTo) {
      // Assuming percentage is number from 0 to 1
            if (paddingObject.units === '%') {
              switch (relativeTo) {
                case 'width':
                  return width > 0 ? paddingObject.pfValue * width : 0;

                case 'height':
                  return height > 0 ? paddingObject.pfValue * height : 0;

                case 'average':
                  return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;

                case 'min':
                  return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;

                case 'max':
                  return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;

                default:
                  return 0;
              }
            } else if (paddingObject.units === 'px') {
              return paddingObject.pfValue;
            } else {
              return 0;
            }
          }

          let leftVal = min.width.left.value;

          if (min.width.left.units === 'px' && min.width.val > 0) {
            leftVal = leftVal * 100 / min.width.val;
          }

          let rightVal = min.width.right.value;

          if (min.width.right.units === 'px' && min.width.val > 0) {
            rightVal = rightVal * 100 / min.width.val;
          }

          let topVal = min.height.top.value;

          if (min.height.top.units === 'px' && min.height.val > 0) {
            topVal = topVal * 100 / min.height.val;
          }

          let bottomVal = min.height.bottom.value;

          if (min.height.bottom.units === 'px' && min.height.val > 0) {
            bottomVal = bottomVal * 100 / min.height.val;
          }

          const widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);
          const diffLeft = widthBiasDiffs.biasDiff;
          const diffRight = widthBiasDiffs.biasComplementDiff;
          const heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);
          const diffTop = heightBiasDiffs.biasDiff;
          const diffBottom = heightBiasDiffs.biasComplementDiff;
          _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);
          _p.autoWidth = Math.max(bb.w, min.width.val);
          pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;
          _p.autoHeight = Math.max(bb.h, min.height.val);
          pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;
        }

        for (let i = 0; i < this.length; i++) {
          const ele = this[i];
          const _p = ele._private;

          if (!_p.compoundBoundsClean || force) {
            update(ele);

            if (!cy.batching()) {
              _p.compoundBoundsClean = true;
            }
          }
        }

        return this;
      };

      const noninf = function noninf(x) {
        if (x === Infinity || x === -Infinity) {
          return 0;
        }

        return x;
      };

      const updateBounds = function updateBounds(b, x1, y1, x2, y2) {
  // don't update with zero area boxes
        if (x2 - x1 === 0 || y2 - y1 === 0) {
          return;
        } // don't update with null dim


        if (x1 == null || y1 == null || x2 == null || y2 == null) {
          return;
        }

        b.x1 = x1 < b.x1 ? x1 : b.x1;
        b.x2 = x2 > b.x2 ? x2 : b.x2;
        b.y1 = y1 < b.y1 ? y1 : b.y1;
        b.y2 = y2 > b.y2 ? y2 : b.y2;
        b.w = b.x2 - b.x1;
        b.h = b.y2 - b.y1;
      };

      const updateBoundsFromBox = function updateBoundsFromBox(b, b2) {
        if (b2 == null) {
          return b;
        }

        return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);
      };

      const prefixedProperty = function prefixedProperty(obj, field, prefix) {
        return getPrefixedProperty(obj, field, prefix);
      };

      const updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {
        if (ele.cy().headless()) {
          return;
        }

        const _p = ele._private;
        const rstyle = _p.rstyle;
        const halfArW = rstyle.arrowWidth / 2;
        const arrowType = ele.pstyle(prefix + '-arrow-shape').value;
        let x;
        let y;

        if (arrowType !== 'none') {
          if (prefix === 'source') {
            x = rstyle.srcX;
            y = rstyle.srcY;
          } else if (prefix === 'target') {
            x = rstyle.tgtX;
            y = rstyle.tgtY;
          } else {
            x = rstyle.midX;
            y = rstyle.midY;
          } // always store the individual arrow bounds


          const bbs = _p.arrowBounds = _p.arrowBounds || {};
          const bb = bbs[prefix] = bbs[prefix] || {};
          bb.x1 = x - halfArW;
          bb.y1 = y - halfArW;
          bb.x2 = x + halfArW;
          bb.y2 = y + halfArW;
          bb.w = bb.x2 - bb.x1;
          bb.h = bb.y2 - bb.y1;
          expandBoundingBox(bb, 1);
          updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);
        }
      };

      const updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {
        if (ele.cy().headless()) {
          return;
        }

        let prefixDash;

        if (prefix) {
          prefixDash = prefix + '-';
        } else {
          prefixDash = '';
        }

        const _p = ele._private;
        const rstyle = _p.rstyle;
        const label = ele.pstyle(prefixDash + 'label').strValue;

        if (label) {
          const halign = ele.pstyle('text-halign');
          const valign = ele.pstyle('text-valign');
          const labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);
          const labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);
          const labelX = prefixedProperty(rstyle, 'labelX', prefix);
          const labelY = prefixedProperty(rstyle, 'labelY', prefix);
          const marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;
          const marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;
          const isEdge = ele.isEdge();
          const rotation = ele.pstyle(prefixDash + 'text-rotation');
          const outlineWidth = ele.pstyle('text-outline-width').pfValue;
          const borderWidth = ele.pstyle('text-border-width').pfValue;
          const halfBorderWidth = borderWidth / 2;
          const padding = ele.pstyle('text-background-padding').pfValue;
          const marginOfError = 2; // expand to work around browser dimension inaccuracies

          const lh = labelHeight;
          const lw = labelWidth;
          const lw_2 = lw / 2;
          const lh_2 = lh / 2;
          let lx1, lx2, ly1, ly2;

          if (isEdge) {
            lx1 = labelX - lw_2;
            lx2 = labelX + lw_2;
            ly1 = labelY - lh_2;
            ly2 = labelY + lh_2;
          } else {
            switch (halign.value) {
              case 'left':
                lx1 = labelX - lw;
                lx2 = labelX;
                break;

              case 'center':
                lx1 = labelX - lw_2;
                lx2 = labelX + lw_2;
                break;

              case 'right':
                lx1 = labelX;
                lx2 = labelX + lw;
                break;
            }

            switch (valign.value) {
              case 'top':
                ly1 = labelY - lh;
                ly2 = labelY;
                break;

              case 'center':
                ly1 = labelY - lh_2;
                ly2 = labelY + lh_2;
                break;

              case 'bottom':
                ly1 = labelY;
                ly2 = labelY + lh;
                break;
            }
          } // shift by margin and expand by outline and border


          lx1 += marginX - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;
          lx2 += marginX + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;
          ly1 += marginY - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;
          ly2 += marginY + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError; // always store the unrotated label bounds separately

          const bbPrefix = prefix || 'main';
          const bbs = _p.labelBounds;
          const bb = bbs[bbPrefix] = bbs[bbPrefix] || {};
          bb.x1 = lx1;
          bb.y1 = ly1;
          bb.x2 = lx2;
          bb.y2 = ly2;
          bb.w = lx2 - lx1;
          bb.h = ly2 - ly1;
          const isAutorotate = isEdge && rotation.strValue === 'autorotate';
          const isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;

          if (isAutorotate || isPfValue) {
            const theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;
            const cos = Math.cos(theta);
            const sin = Math.sin(theta); // rotation point (default value for center-center)

            let xo = (lx1 + lx2) / 2;
            let yo = (ly1 + ly2) / 2;

            if (!isEdge) {
              switch (halign.value) {
                case 'left':
                  xo = lx2;
                  break;

                case 'right':
                  xo = lx1;
                  break;
              }

              switch (valign.value) {
                case 'top':
                  yo = ly2;
                  break;

                case 'bottom':
                  yo = ly1;
                  break;
              }
            }

            const rotate = function rotate(x, y) {
              x = x - xo;
              y = y - yo;
              return {
                x: x * cos - y * sin + xo,
                y: x * sin + y * cos + yo
              };
            };

            const px1y1 = rotate(lx1, ly1);
            const px1y2 = rotate(lx1, ly2);
            const px2y1 = rotate(lx2, ly1);
            const px2y2 = rotate(lx2, ly2);
            lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
            lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
            ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
            ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
          }

          const bbPrefixRot = bbPrefix + 'Rot';
          const bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};
          bbRot.x1 = lx1;
          bbRot.y1 = ly1;
          bbRot.x2 = lx2;
          bbRot.y2 = ly2;
          bbRot.w = lx2 - lx1;
          bbRot.h = ly2 - ly1;
          updateBounds(bounds, lx1, ly1, lx2, ly2);
          updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);
        }

        return bounds;
      }; // get the bounding box of the elements (in raw model position)


      const boundingBoxImpl = function boundingBoxImpl(ele, options) {
        const cy = ele._private.cy;
        const styleEnabled = cy.styleEnabled();
        const headless = cy.headless();
        const bounds = makeBoundingBox();
        const _p = ele._private;
        const isNode = ele.isNode();
        const isEdge = ele.isEdge();
        let ex1, ex2, ey1, ey2; // extrema of body / lines

        let x, y; // node pos

        const rstyle = _p.rstyle;
        const manualExpansion = isNode && styleEnabled ? ele.pstyle('bounds-expansion').pfValue : [0]; // must use `display` prop only, as reading `compound.width()` causes recursion
  // (other factors like width values will be considered later in this function anyway)

        const isDisplayed = function isDisplayed(ele) {
          return ele.pstyle('display').value !== 'none';
        };

        const displayed = !styleEnabled || isDisplayed(ele) // must take into account connected nodes b/c of implicit edge hiding on display:none node
  && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));

        if (displayed) {
    // displayed suffices, since we will find zero area eles anyway
          let overlayOpacity = 0;
          let overlayPadding = 0;

          if (styleEnabled && options.includeOverlays) {
            overlayOpacity = ele.pstyle('overlay-opacity').value;

            if (overlayOpacity !== 0) {
              overlayPadding = ele.pstyle('overlay-padding').value;
            }
          }

          let w = 0;
          let wHalf = 0;

          if (styleEnabled) {
            w = ele.pstyle('width').pfValue;
            wHalf = w / 2;
          }

          if (isNode && options.includeNodes) {
            const pos = ele.position();
            x = pos.x;
            y = pos.y;

            const _w = ele.outerWidth();

            const halfW = _w / 2;
            const h = ele.outerHeight();
            const halfH = h / 2; // handle node dimensions
      /////////////////////////

            ex1 = x - halfW;
            ex2 = x + halfW;
            ey1 = y - halfH;
            ey2 = y + halfH;
            updateBounds(bounds, ex1, ey1, ex2, ey2);
          } else if (isEdge && options.includeEdges) {
            if (styleEnabled && !headless) {
              const curveStyle = ele.pstyle('curve-style').strValue; // handle edge dimensions (rough box estimate)
        //////////////////////////////////////////////

              ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);
              ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);
              ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);
              ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY); // take into account edge width

              ex1 -= wHalf;
              ex2 += wHalf;
              ey1 -= wHalf;
              ey2 += wHalf;
              updateBounds(bounds, ex1, ey1, ex2, ey2); // precise edges
        ////////////////

              if (curveStyle === 'haystack') {
                const hpts = rstyle.haystackPts;

                if (hpts && hpts.length === 2) {
                  ex1 = hpts[0].x;
                  ey1 = hpts[0].y;
                  ex2 = hpts[1].x;
                  ey2 = hpts[1].y;

                  if (ex1 > ex2) {
                    const temp = ex1;
                    ex1 = ex2;
                    ex2 = temp;
                  }

                  if (ey1 > ey2) {
                    const _temp = ey1;
                    ey1 = ey2;
                    ey2 = _temp;
                  }

                  updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);
                }
              } else if (curveStyle === 'bezier' || curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'taxi') {
                let pts;

                switch (curveStyle) {
                  case 'bezier':
                  case 'unbundled-bezier':
                    pts = rstyle.bezierPts;
                    break;

                  case 'segments':
                  case 'taxi':
                    pts = rstyle.linePts;
                    break;
                }

                if (pts != null) {
                  for (let j = 0; j < pts.length; j++) {
                    const pt = pts[j];
                    ex1 = pt.x - wHalf;
                    ex2 = pt.x + wHalf;
                    ey1 = pt.y - wHalf;
                    ey2 = pt.y + wHalf;
                    updateBounds(bounds, ex1, ey1, ex2, ey2);
                  }
                }
              } // bezier-like or segment-like edge

            } else {
        // headless or style disabled
        // fallback on source and target positions
        //////////////////////////////////////////
              const n1 = ele.source();
              const n1pos = n1.position();
              const n2 = ele.target();
              const n2pos = n2.position();
              ex1 = n1pos.x;
              ex2 = n2pos.x;
              ey1 = n1pos.y;
              ey2 = n2pos.y;

              if (ex1 > ex2) {
                const _temp2 = ex1;
                ex1 = ex2;
                ex2 = _temp2;
              }

              if (ey1 > ey2) {
                const _temp3 = ey1;
                ey1 = ey2;
                ey2 = _temp3;
              } // take into account edge width


              ex1 -= wHalf;
              ex2 += wHalf;
              ey1 -= wHalf;
              ey2 += wHalf;
              updateBounds(bounds, ex1, ey1, ex2, ey2);
            } // headless or style disabled

          } // edges
    // handle edge arrow size
    /////////////////////////


          if (styleEnabled && options.includeEdges && isEdge) {
            updateBoundsFromArrow(bounds, ele, 'mid-source');
            updateBoundsFromArrow(bounds, ele, 'mid-target');
            updateBoundsFromArrow(bounds, ele, 'source');
            updateBoundsFromArrow(bounds, ele, 'target');
          } // ghost
    ////////


          if (styleEnabled) {
            const ghost = ele.pstyle('ghost').value === 'yes';

            if (ghost) {
              const gx = ele.pstyle('ghost-offset-x').pfValue;
              const gy = ele.pstyle('ghost-offset-y').pfValue;
              updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);
            }
          } // always store the body bounds separately from the labels


          const bbBody = _p.bodyBounds = _p.bodyBounds || {};
          assignBoundingBox(bbBody, bounds);
          expandBoundingBoxSides(bbBody, manualExpansion);
          expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies
    // overlay
    //////////

          if (styleEnabled) {
            ex1 = bounds.x1;
            ex2 = bounds.x2;
            ey1 = bounds.y1;
            ey2 = bounds.y2;
            updateBounds(bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding);
          } // always store the body bounds separately from the labels


          const bbOverlay = _p.overlayBounds = _p.overlayBounds || {};
          assignBoundingBox(bbOverlay, bounds);
          expandBoundingBoxSides(bbOverlay, manualExpansion);
          expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies
    // handle label dimensions
    //////////////////////////

          const bbLabels = _p.labelBounds = _p.labelBounds || {};

          if (bbLabels.all != null) {
            clearBoundingBox(bbLabels.all);
          } else {
            bbLabels.all = makeBoundingBox();
          }

          if (styleEnabled && options.includeLabels) {
            if (options.includeMainLabels) {
              updateBoundsFromLabel(bounds, ele, null);
            }

            if (isEdge) {
              if (options.includeSourceLabels) {
                updateBoundsFromLabel(bounds, ele, 'source');
              }

              if (options.includeTargetLabels) {
                updateBoundsFromLabel(bounds, ele, 'target');
              }
            }
          } // style enabled for labels

        } // if displayed


        bounds.x1 = noninf(bounds.x1);
        bounds.y1 = noninf(bounds.y1);
        bounds.x2 = noninf(bounds.x2);
        bounds.y2 = noninf(bounds.y2);
        bounds.w = noninf(bounds.x2 - bounds.x1);
        bounds.h = noninf(bounds.y2 - bounds.y1);

        if (bounds.w > 0 && bounds.h > 0 && displayed) {
          expandBoundingBoxSides(bounds, manualExpansion); // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides

          expandBoundingBox(bounds, 1);
        }

        return bounds;
      };

      const getKey = function getKey(opts) {
        let i = 0;

        const tf = function tf(val) {
          return (val ? 1 : 0) << i++;
        };

        let key = 0;
        key += tf(opts.incudeNodes);
        key += tf(opts.includeEdges);
        key += tf(opts.includeLabels);
        key += tf(opts.includeMainLabels);
        key += tf(opts.includeSourceLabels);
        key += tf(opts.includeTargetLabels);
        key += tf(opts.includeOverlays);
        return key;
      };

      const getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {
        if (ele.isEdge()) {
          const p1 = ele.source().position();
          const p2 = ele.target().position();

          const r = function r(x) {
            return Math.round(x);
          };

          return hashIntsArray([r(p1.x), r(p1.y), r(p2.x), r(p2.y)]);
        } else {
          return 0;
        }
      };

      const cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {
        const _p = ele._private;
        let bb;
        const isEdge = ele.isEdge();
        const key = opts == null ? defBbOptsKey : getKey(opts);
        const usingDefOpts = key === defBbOptsKey;
        const currPosKey = getBoundingBoxPosKey(ele);
        const isPosKeySame = _p.bbCachePosKey === currPosKey;
        const useCache = opts.useCache && isPosKeySame;

        const isDirty = function isDirty(ele) {
          return ele._private.bbCache == null || ele._private.styleDirty;
        };

        const needRecalc = !useCache || isDirty(ele) || isEdge && isDirty(ele.source()) || isDirty(ele.target());

        if (needRecalc) {
          if (!isPosKeySame) {
            ele.recalculateRenderedStyle(useCache);
          }

          bb = boundingBoxImpl(ele, defBbOpts);
          _p.bbCache = bb;
          _p.bbCachePosKey = currPosKey;
        } else {
          bb = _p.bbCache;
        } // not using def opts => need to build up bb from combination of sub bbs


        if (!usingDefOpts) {
          const isNode = ele.isNode();
          bb = makeBoundingBox();

          if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {
            if (opts.includeOverlays) {
              updateBoundsFromBox(bb, _p.overlayBounds);
            } else {
              updateBoundsFromBox(bb, _p.bodyBounds);
            }
          }

          if (opts.includeLabels) {
            if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) {
              updateBoundsFromBox(bb, _p.labelBounds.all);
            } else {
              if (opts.includeMainLabels) {
                updateBoundsFromBox(bb, _p.labelBounds.mainRot);
              }

              if (opts.includeSourceLabels) {
                updateBoundsFromBox(bb, _p.labelBounds.sourceRot);
              }

              if (opts.includeTargetLabels) {
                updateBoundsFromBox(bb, _p.labelBounds.targetRot);
              }
            }
          }

          bb.w = bb.x2 - bb.x1;
          bb.h = bb.y2 - bb.y1;
        }

        return bb;
      };

      var defBbOpts = {
        includeNodes: true,
        includeEdges: true,
        includeLabels: true,
        includeMainLabels: true,
        includeSourceLabels: true,
        includeTargetLabels: true,
        includeOverlays: true,
        useCache: true
      };
      var defBbOptsKey = getKey(defBbOpts);
      const filledBbOpts = defaults(defBbOpts);

      elesfn$k.boundingBox = function (options) {
        let bounds; // the main usecase is ele.boundingBox() for a single element with no/def options
  // specified s.t. the cache is used, so check for this case to make it faster by
  // avoiding the overhead of the rest of the function

        if (this.length === 1 && this[0]._private.bbCache != null && !this[0]._private.styleDirty && (options === undefined || options.useCache === undefined || options.useCache === true)) {
          if (options === undefined) {
            options = defBbOpts;
          } else {
            options = filledBbOpts(options);
          }

          bounds = cachedBoundingBoxImpl(this[0], options);
        } else {
          bounds = makeBoundingBox();
          options = options || defBbOpts;
          const opts = filledBbOpts(options);
          const eles = this;
          const cy = eles.cy();
          const styleEnabled = cy.styleEnabled();

          if (styleEnabled) {
            for (let i = 0; i < eles.length; i++) {
              const ele = eles[i];
              const _p = ele._private;
              const currPosKey = getBoundingBoxPosKey(ele);
              const isPosKeySame = _p.bbCachePosKey === currPosKey;
              const useCache = opts.useCache && isPosKeySame && !_p.styleDirty;
              ele.recalculateRenderedStyle(useCache);
            }
          }

          this.updateCompoundBounds(!options.useCache);

          for (let _i = 0; _i < eles.length; _i++) {
            const _ele = eles[_i];
            updateBoundsFromBox(bounds, cachedBoundingBoxImpl(_ele, opts));
          }
        }

        bounds.x1 = noninf(bounds.x1);
        bounds.y1 = noninf(bounds.y1);
        bounds.x2 = noninf(bounds.x2);
        bounds.y2 = noninf(bounds.y2);
        bounds.w = noninf(bounds.x2 - bounds.x1);
        bounds.h = noninf(bounds.y2 - bounds.y1);
        return bounds;
      };

      elesfn$k.dirtyBoundingBoxCache = function () {
        for (let i = 0; i < this.length; i++) {
          const _p = this[i]._private;
          _p.bbCache = null;
          _p.bbCachePosKey = null;
          _p.bodyBounds = null;
          _p.overlayBounds = null;
          _p.labelBounds.all = null;
          _p.labelBounds.source = null;
          _p.labelBounds.target = null;
          _p.labelBounds.main = null;
          _p.labelBounds.sourceRot = null;
          _p.labelBounds.targetRot = null;
          _p.labelBounds.mainRot = null;
          _p.arrowBounds.source = null;
          _p.arrowBounds.target = null;
          _p.arrowBounds['mid-source'] = null;
          _p.arrowBounds['mid-target'] = null;
        }

        this.emitAndNotify('bounds');
        return this;
      }; // private helper to get bounding box for custom node positions
// - good for perf in certain cases but currently requires dirtying the rendered style
// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...
// - try to use for only things like discrete layouts where the node position would change anyway


      elesfn$k.boundingBoxAt = function (fn) {
        let nodes = this.nodes();
        const cy = this.cy();
        const hasCompoundNodes = cy.hasCompoundNodes();
        let parents = cy.collection();

        if (hasCompoundNodes) {
          parents = nodes.filter(function (node) {
            return node.isParent();
          });
          nodes = nodes.not(parents);
        }

        if (plainObject(fn)) {
          const obj = fn;

          fn = function fn() {
            return obj;
          };
        }

        const storeOldPos = function storeOldPos(node, i) {
          return node._private.bbAtOldPos = fn(node, i);
        };

        const getOldPos = function getOldPos(node) {
          return node._private.bbAtOldPos;
        };

        cy.startBatch();
        nodes.forEach(storeOldPos).silentPositions(fn);

        if (hasCompoundNodes) {
          parents.dirtyCompoundBoundsCache();
          parents.dirtyBoundingBoxCache();
          parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle
        }

        const bb = copyBoundingBox(this.boundingBox({
          useCache: false
        }));
        nodes.silentPositions(getOldPos);

        if (hasCompoundNodes) {
          parents.dirtyCompoundBoundsCache();
          parents.dirtyBoundingBoxCache();
          parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle
        }

        cy.endBatch();
        return bb;
      };

      fn$3.boundingbox = fn$3.bb = fn$3.boundingBox;
      fn$3.renderedBoundingbox = fn$3.renderedBoundingBox;
      const bounds = elesfn$k;

      let fn$4, elesfn$l;
      fn$4 = elesfn$l = {};

      const defineDimFns = function defineDimFns(opts) {
        opts.uppercaseName = capitalize(opts.name);
        opts.autoName = 'auto' + opts.uppercaseName;
        opts.labelName = 'label' + opts.uppercaseName;
        opts.outerName = 'outer' + opts.uppercaseName;
        opts.uppercaseOuterName = capitalize(opts.outerName);

        fn$4[opts.name] = function dimImpl() {
          const ele = this[0];
          const _p = ele._private;
          const cy = _p.cy;
          const styleEnabled = cy._private.styleEnabled;

          if (ele) {
            if (styleEnabled) {
              if (ele.isParent()) {
                ele.updateCompoundBounds();
                return _p[opts.autoName] || 0;
              }

              const d = ele.pstyle(opts.name);

              switch (d.strValue) {
                case 'label':
                  ele.recalculateRenderedStyle();
                  return _p.rstyle[opts.labelName] || 0;

                default:
                  return d.pfValue;
              }
            } else {
              return 1;
            }
          }
        };

        fn$4['outer' + opts.uppercaseName] = function outerDimImpl() {
          const ele = this[0];
          const _p = ele._private;
          const cy = _p.cy;
          const styleEnabled = cy._private.styleEnabled;

          if (ele) {
            if (styleEnabled) {
              const dim = ele[opts.name]();
              const border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side

              const padding = 2 * ele.padding();
              return dim + border + padding;
            } else {
              return 1;
            }
          }
        };

        fn$4['rendered' + opts.uppercaseName] = function renderedDimImpl() {
          const ele = this[0];

          if (ele) {
            const d = ele[opts.name]();
            return d * this.cy().zoom();
          }
        };

        fn$4['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {
          const ele = this[0];

          if (ele) {
            const od = ele[opts.outerName]();
            return od * this.cy().zoom();
          }
        };
      };

      defineDimFns({
        name: 'width'
      });
      defineDimFns({
        name: 'height'
      });

      elesfn$l.padding = function () {
        const ele = this[0];
        const _p = ele._private;

        if (ele.isParent()) {
          ele.updateCompoundBounds();

          if (_p.autoPadding !== undefined) {
            return _p.autoPadding;
          } else {
            return ele.pstyle('padding').pfValue;
          }
        } else {
          return ele.pstyle('padding').pfValue;
        }
      };

      elesfn$l.paddedHeight = function () {
        const ele = this[0];
        return ele.height() + 2 * ele.padding();
      };

      elesfn$l.paddedWidth = function () {
        const ele = this[0];
        return ele.width() + 2 * ele.padding();
      };

      const widthHeight = elesfn$l;

      const ifEdge = function ifEdge(ele, getValue) {
        if (ele.isEdge()) {
          return getValue(ele);
        }
      };

      const ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {
        if (ele.isEdge()) {
          const cy = ele.cy();
          return modelToRenderedPosition(getPoint(ele), cy.zoom(), cy.pan());
        }
      };

      const ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {
        if (ele.isEdge()) {
          const cy = ele.cy();
          const pan = cy.pan();
          const zoom = cy.zoom();
          return getPoints(ele).map(function (p) {
            return modelToRenderedPosition(p, zoom, pan);
          });
        }
      };

      const controlPoints = function controlPoints(ele) {
        return ele.renderer().getControlPoints(ele);
      };

      const segmentPoints = function segmentPoints(ele) {
        return ele.renderer().getSegmentPoints(ele);
      };

      const sourceEndpoint = function sourceEndpoint(ele) {
        return ele.renderer().getSourceEndpoint(ele);
      };

      const targetEndpoint = function targetEndpoint(ele) {
        return ele.renderer().getTargetEndpoint(ele);
      };

      const midpoint = function midpoint(ele) {
        return ele.renderer().getEdgeMidpoint(ele);
      };

      const pts = {
        controlPoints: {
          get: controlPoints,
          mult: true
        },
        segmentPoints: {
          get: segmentPoints,
          mult: true
        },
        sourceEndpoint: {
          get: sourceEndpoint
        },
        targetEndpoint: {
          get: targetEndpoint
        },
        midpoint: {
          get: midpoint
        }
      };

      const renderedName = function renderedName(name) {
        return 'rendered' + name[0].toUpperCase() + name.substr(1);
      };

      const edgePoints = Object.keys(pts).reduce(function (obj, name) {
        const spec = pts[name];
        const rName = renderedName(name);

        obj[name] = function () {
          return ifEdge(this, spec.get);
        };

        if (spec.mult) {
          obj[rName] = function () {
            return ifEdgeRenderedPositions(this, spec.get);
          };
        } else {
          obj[rName] = function () {
            return ifEdgeRenderedPosition(this, spec.get);
          };
        }

        return obj;
      }, {});

      const dimensions = extend({}, position, bounds, widthHeight, edgePoints);

/*!
Event object based on jQuery events, MIT license

https://jquery.org/license/
https://tldrlegal.com/license/mit-license
https://github.com/jquery/jquery/blob/master/src/event.js
*/
      const Event = function Event(src, props) {
        this.recycle(src, props);
      };

      function returnFalse() {
        return false;
      }

      function returnTrue() {
        return true;
      } // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


      Event.prototype = {
        instanceString: function instanceString() {
          return 'event';
        },
        recycle: function recycle(src, props) {
          this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;

          if (src != null && src.preventDefault) {
      // Browser Event object
            this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

            this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;
          } else if (src != null && src.type) {
      // Plain object containing all event details
            props = src;
          } else {
      // Event string
            this.type = src;
          } // Put explicitly provided properties onto the event object


          if (props != null) {
      // more efficient to manually copy fields we use
            this.originalEvent = props.originalEvent;
            this.type = props.type != null ? props.type : this.type;
            this.cy = props.cy;
            this.target = props.target;
            this.position = props.position;
            this.renderedPosition = props.renderedPosition;
            this.namespace = props.namespace;
            this.layout = props.layout;
          }

          if (this.cy != null && this.position != null && this.renderedPosition == null) {
      // create a rendered position based on the passed position
            const pos = this.position;
            const zoom = this.cy.zoom();
            const pan = this.cy.pan();
            this.renderedPosition = {
              x: pos.x * zoom + pan.x,
              y: pos.y * zoom + pan.y
            };
          } // Create a timestamp if incoming event doesn't have one


          this.timeStamp = src && src.timeStamp || Date.now();
        },
        preventDefault: function preventDefault() {
          this.isDefaultPrevented = returnTrue;
          const e = this.originalEvent;

          if (!e) {
            return;
          } // if preventDefault exists run it on the original event


          if (e.preventDefault) {
            e.preventDefault();
          }
        },
        stopPropagation: function stopPropagation() {
          this.isPropagationStopped = returnTrue;
          const e = this.originalEvent;

          if (!e) {
            return;
          } // if stopPropagation exists run it on the original event


          if (e.stopPropagation) {
            e.stopPropagation();
          }
        },
        stopImmediatePropagation: function stopImmediatePropagation() {
          this.isImmediatePropagationStopped = returnTrue;
          this.stopPropagation();
        },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
      };

      const eventRegex = /^([^.]+)(\.(?:[^.]+))?$/; // regex for matching event strings (e.g. "click.namespace")

      const universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally

      const defaults$8 = {
        qualifierCompare: function qualifierCompare(q1, q2) {
          return q1 === q2;
        },
        eventMatches: function eventMatches()
  /*context, listener, eventObj*/
        {
          return true;
        },
        addEventFields: function addEventFields()
  /*context, evt*/
        {},
        callbackContext: function callbackContext(context
  /*, listener, eventObj*/
        ) {
          return context;
        },
        beforeEmit: function beforeEmit()
  /* context, listener, eventObj */
        {},
        afterEmit: function afterEmit()
  /* context, listener, eventObj */
        {},
        bubble: function bubble()
  /*context*/
        {
          return false;
        },
        parent: function parent()
  /*context*/
        {
          return null;
        },
        context: null
      };
      const defaultsKeys = Object.keys(defaults$8);
      const emptyOpts = {};

      function Emitter() {
        const opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;
        const context = arguments.length > 1 ? arguments[1] : undefined;

  // micro-optimisation vs Object.assign() -- reduces Element instantiation time
        for (let i = 0; i < defaultsKeys.length; i++) {
          const key = defaultsKeys[i];
          this[key] = opts[key] || defaults$8[key];
        }

        this.context = context || this.context;
        this.listeners = [];
        this.emitting = 0;
      }

      const p = Emitter.prototype;

      const forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {
        if (fn(qualifier)) {
          callback = qualifier;
          qualifier = null;
        }

        if (confOverrides) {
          if (conf == null) {
            conf = confOverrides;
          } else {
            conf = extend({}, conf, confOverrides);
          }
        }

        const eventList = array(events) ? events : events.split(/\s+/);

        for (let i = 0; i < eventList.length; i++) {
          const evt = eventList[i];

          if (emptyString(evt)) {
            continue;
          }

          const match = evt.match(eventRegex); // type[.namespace]

          if (match) {
            const type = match[1];
            const namespace = match[2] ? match[2] : null;
            const ret = handler(self, evt, type, namespace, qualifier, callback, conf);

            if (ret === false) {
              break;
            } // allow exiting early

          }
        }
      };

      const makeEventObj = function makeEventObj(self, obj) {
        self.addEventFields(self.context, obj);
        return new Event(obj.type, obj);
      };

      const forEachEventObj = function forEachEventObj(self, handler, events) {
        if (event(events)) {
          handler(self, events);
          return;
        } else if (plainObject(events)) {
          handler(self, makeEventObj(self, events));
          return;
        }

        const eventList = array(events) ? events : events.split(/\s+/);

        for (let i = 0; i < eventList.length; i++) {
          const evt = eventList[i];

          if (emptyString(evt)) {
            continue;
          }

          const match = evt.match(eventRegex); // type[.namespace]

          if (match) {
            const type = match[1];
            const namespace = match[2] ? match[2] : null;
            const eventObj = makeEventObj(self, {
              type: type,
              namespace: namespace,
              target: self.context
            });
            handler(self, eventObj);
          }
        }
      };

      p.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {
        forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {
          if (fn(callback)) {
            self.listeners.push({
              event: event,
        // full event string
              callback: callback,
        // callback to run
              type: type,
        // the event type (e.g. 'click')
              namespace: namespace,
        // the event namespace (e.g. ".foo")
              qualifier: qualifier,
        // a restriction on whether to match this emitter
              conf: conf // additional configuration

            });
          }
        }, events, qualifier, callback, conf, confOverrides);
        return this;
      };

      p.one = function (events, qualifier, callback, conf) {
        return this.on(events, qualifier, callback, conf, {
          one: true
        });
      };

      p.removeListener = p.off = function (events, qualifier, callback, conf) {
        const _this = this;

        if (this.emitting !== 0) {
          this.listeners = copyArray(this.listeners);
        }

        const listeners = this.listeners;

        const _loop = function _loop(i) {
          const listener = listeners[i];
          forEachEvent(_this, function (self, event, type, namespace, qualifier, callback
    /*, conf*/
          ) {
            if ((listener.type === type || events === '*') && (!namespace && listener.namespace !== '.*' || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {
              listeners.splice(i, 1);
              return false;
            }
          }, events, qualifier, callback, conf);
        };

        for (let i = listeners.length - 1; i >= 0; i--) {
          _loop(i);
        }

        return this;
      };

      p.removeAllListeners = function () {
        return this.removeListener('*');
      };

      p.emit = p.trigger = function (events, extraParams, manualCallback) {
        let listeners = this.listeners;
        let numListenersBeforeEmit = listeners.length;
        this.emitting++;

        if (!array(extraParams)) {
          extraParams = [extraParams];
        }

        forEachEventObj(this, function (self, eventObj) {
          if (manualCallback != null) {
            listeners = [{
              event: eventObj.event,
              type: eventObj.type,
              namespace: eventObj.namespace,
              callback: manualCallback
            }];
            numListenersBeforeEmit = listeners.length;
          }

          const _loop2 = function _loop2(i) {
            const listener = listeners[i];

            if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {
              const args = [eventObj];

              if (extraParams != null) {
                push(args, extraParams);
              }

              self.beforeEmit(self.context, listener, eventObj);

              if (listener.conf && listener.conf.one) {
                self.listeners = self.listeners.filter(function (l) {
                  return l !== listener;
                });
              }

              const context = self.callbackContext(self.context, listener, eventObj);
              const ret = listener.callback.apply(context, args);
              self.afterEmit(self.context, listener, eventObj);

              if (ret === false) {
                eventObj.stopPropagation();
                eventObj.preventDefault();
              }
            } // if listener matches

          };

          for (let i = 0; i < numListenersBeforeEmit; i++) {
            _loop2(i);
          } // for listener


          if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {
            self.parent(self.context).emit(eventObj, extraParams);
          }
        }, events);
        this.emitting--;
        return this;
      };

      const emitterOptions = {
        qualifierCompare: function qualifierCompare(selector1, selector2) {
          if (selector1 == null || selector2 == null) {
            return selector1 == null && selector2 == null;
          } else {
            return selector1.sameText(selector2);
          }
        },
        eventMatches: function eventMatches(ele, listener, eventObj) {
          const selector = listener.qualifier;

          if (selector != null) {
            return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
          }

          return true;
        },
        addEventFields: function addEventFields(ele, evt) {
          evt.cy = ele.cy();
          evt.target = ele;
        },
        callbackContext: function callbackContext(ele, listener, eventObj) {
          return listener.qualifier != null ? eventObj.target : ele;
        },
        beforeEmit: function beforeEmit(context, listener
  /*, eventObj*/
        ) {
          if (listener.conf && listener.conf.once) {
            listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);
          }
        },
        bubble: function bubble() {
          return true;
        },
        parent: function parent(ele) {
          return ele.isChild() ? ele.parent() : ele.cy();
        }
      };

      const argSelector = function argSelector(arg) {
        if (string(arg)) {
          return new Selector(arg);
        } else {
          return arg;
        }
      };

      const elesfn$m = {
        createEmitter: function createEmitter() {
          for (let i = 0; i < this.length; i++) {
            const ele = this[i];
            const _p = ele._private;

            if (!_p.emitter) {
              _p.emitter = new Emitter(emitterOptions, ele);
            }
          }

          return this;
        },
        emitter: function emitter() {
          return this._private.emitter;
        },
        on: function on(events, selector, callback) {
          const argSel = argSelector(selector);

          for (let i = 0; i < this.length; i++) {
            const ele = this[i];
            ele.emitter().on(events, argSel, callback);
          }

          return this;
        },
        removeListener: function removeListener(events, selector, callback) {
          const argSel = argSelector(selector);

          for (let i = 0; i < this.length; i++) {
            const ele = this[i];
            ele.emitter().removeListener(events, argSel, callback);
          }

          return this;
        },
        removeAllListeners: function removeAllListeners() {
          for (let i = 0; i < this.length; i++) {
            const ele = this[i];
            ele.emitter().removeAllListeners();
          }

          return this;
        },
        one: function one(events, selector, callback) {
          const argSel = argSelector(selector);

          for (let i = 0; i < this.length; i++) {
            const ele = this[i];
            ele.emitter().one(events, argSel, callback);
          }

          return this;
        },
        once: function once(events, selector, callback) {
          const argSel = argSelector(selector);

          for (let i = 0; i < this.length; i++) {
            const ele = this[i];
            ele.emitter().on(events, argSel, callback, {
              once: true,
              onceCollection: this
            });
          }
        },
        emit: function emit(events, extraParams) {
          for (let i = 0; i < this.length; i++) {
            const ele = this[i];
            ele.emitter().emit(events, extraParams);
          }

          return this;
        },
        emitAndNotify: function emitAndNotify(event, extraParams) {
    // for internal use only
          if (this.length === 0) {
            return;
          } // empty collections don't need to notify anything
    // notify renderer


          this.cy().notify(event, this);
          this.emit(event, extraParams);
          return this;
        }
      };
      define$3.eventAliasesOn(elesfn$m);

      const elesfn$n = {
        nodes: function nodes(selector) {
          return this.filter(function (ele) {
            return ele.isNode();
          }).filter(selector);
        },
        edges: function edges(selector) {
          return this.filter(function (ele) {
            return ele.isEdge();
          }).filter(selector);
        },
  // internal helper to get nodes and edges as separate collections with single iteration over elements
        byGroup: function byGroup() {
          const nodes = this.spawn();
          const edges = this.spawn();

          for (let i = 0; i < this.length; i++) {
            const ele = this[i];

            if (ele.isNode()) {
              nodes.push(ele);
            } else {
              edges.push(ele);
            }
          }

          return {
            nodes: nodes,
            edges: edges
          };
        },
        filter: function filter(_filter, thisArg) {
          if (_filter === undefined) {
      // check this first b/c it's the most common/performant case
            return this;
          } else if (string(_filter) || elementOrCollection(_filter)) {
            return new Selector(_filter).filter(this);
          } else if (fn(_filter)) {
            const filterEles = this.spawn();
            const eles = this;

            for (let i = 0; i < eles.length; i++) {
              const ele = eles[i];
              const include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);

              if (include) {
                filterEles.push(ele);
              }
            }

            return filterEles;
          }

          return this.spawn(); // if not handled by above, give 'em an empty collection
        },
        not: function not(toRemove) {
          if (!toRemove) {
            return this;
          } else {
            if (string(toRemove)) {
              toRemove = this.filter(toRemove);
            }

            const elements = this.spawn();

            for (let i = 0; i < this.length; i++) {
              const element = this[i];
              const remove = toRemove.has(element);

              if (!remove) {
                elements.push(element);
              }
            }

            return elements;
          }
        },
        absoluteComplement: function absoluteComplement() {
          const cy = this.cy();
          return cy.mutableElements().not(this);
        },
        intersect: function intersect(other) {
    // if a selector is specified, then filter by it instead
          if (string(other)) {
            const selector = other;
            return this.filter(selector);
          }

          const elements = this.spawn();
          const col1 = this;
          const col2 = other;
          const col1Smaller = this.length < other.length;
          const colS = col1Smaller ? col1 : col2;
          const colL = col1Smaller ? col2 : col1;

          for (let i = 0; i < colS.length; i++) {
            const ele = colS[i];

            if (colL.has(ele)) {
              elements.push(ele);
            }
          }

          return elements;
        },
        xor: function xor(other) {
          const cy = this._private.cy;

          if (string(other)) {
            other = cy.$(other);
          }

          const elements = this.spawn();
          const col1 = this;
          const col2 = other;

          const add = function add(col, other) {
            for (let i = 0; i < col.length; i++) {
              const ele = col[i];
              const id = ele._private.data.id;
              const inOther = other.hasElementWithId(id);

              if (!inOther) {
                elements.push(ele);
              }
            }
          };

          add(col1, col2);
          add(col2, col1);
          return elements;
        },
        diff: function diff(other) {
          const cy = this._private.cy;

          if (string(other)) {
            other = cy.$(other);
          }

          const left = this.spawn();
          const right = this.spawn();
          const both = this.spawn();
          const col1 = this;
          const col2 = other;

          const add = function add(col, other, retEles) {
            for (let i = 0; i < col.length; i++) {
              const ele = col[i];
              const id = ele._private.data.id;
              const inOther = other.hasElementWithId(id);

              if (inOther) {
                both.merge(ele);
              } else {
                retEles.push(ele);
              }
            }
          };

          add(col1, col2, left);
          add(col2, col1, right);
          return {
            left: left,
            right: right,
            both: both
          };
        },
        add: function add(toAdd) {
          const cy = this._private.cy;

          if (!toAdd) {
            return this;
          }

          if (string(toAdd)) {
            const selector = toAdd;
            toAdd = cy.mutableElements().filter(selector);
          }

          const elements = this.spawnSelf();

          for (let i = 0; i < toAdd.length; i++) {
            const ele = toAdd[i];
            const add = !this.has(ele);

            if (add) {
              elements.push(ele);
            }
          }

          return elements;
        },
  // in place merge on calling collection
        merge: function merge(toAdd) {
          const _p = this._private;
          const cy = _p.cy;

          if (!toAdd) {
            return this;
          }

          if (toAdd && string(toAdd)) {
            const selector = toAdd;
            toAdd = cy.mutableElements().filter(selector);
          }

          const map = _p.map;

          for (let i = 0; i < toAdd.length; i++) {
            const toAddEle = toAdd[i];
            const id = toAddEle._private.data.id;
            const add = !map.has(id);

            if (add) {
              const index = this.length++;
              this[index] = toAddEle;
              map.set(id, {
                ele: toAddEle,
                index: index
              });
            }
          }

          return this; // chaining
        },
        unmergeAt: function unmergeAt(i) {
          const ele = this[i];
          const id = ele.id();
          const _p = this._private;
          const map = _p.map; // remove ele

          this[i] = undefined;
          map["delete"](id);
          const unmergedLastEle = i === this.length - 1; // replace empty spot with last ele in collection

          if (this.length > 1 && !unmergedLastEle) {
            const lastEleI = this.length - 1;
            const lastEle = this[lastEleI];
            const lastEleId = lastEle._private.data.id;
            this[lastEleI] = undefined;
            this[i] = lastEle;
            map.set(lastEleId, {
              ele: lastEle,
              index: i
            });
          } // the collection is now 1 ele smaller


          this.length--;
          return this;
        },
  // remove single ele in place in calling collection
        unmergeOne: function unmergeOne(ele) {
          ele = ele[0];
          const _p = this._private;
          const id = ele._private.data.id;
          const map = _p.map;
          const entry = map.get(id);

          if (!entry) {
            return this; // no need to remove
          }

          const i = entry.index;
          this.unmergeAt(i);
          return this;
        },
  // remove eles in place on calling collection
        unmerge: function unmerge(toRemove) {
          const cy = this._private.cy;

          if (!toRemove) {
            return this;
          }

          if (toRemove && string(toRemove)) {
            const selector = toRemove;
            toRemove = cy.mutableElements().filter(selector);
          }

          for (let i = 0; i < toRemove.length; i++) {
            this.unmergeOne(toRemove[i]);
          }

          return this; // chaining
        },
        unmergeBy: function unmergeBy(toRmFn) {
          for (let i = this.length - 1; i >= 0; i--) {
            const ele = this[i];

            if (toRmFn(ele)) {
              this.unmergeAt(i);
            }
          }

          return this;
        },
        map: function map(mapFn, thisArg) {
          const arr = [];
          const eles = this;

          for (let i = 0; i < eles.length; i++) {
            const ele = eles[i];
            const ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);
            arr.push(ret);
          }

          return arr;
        },
        reduce: function reduce(fn, initialValue) {
          let val = initialValue;
          const eles = this;

          for (let i = 0; i < eles.length; i++) {
            val = fn(val, eles[i], i, eles);
          }

          return val;
        },
        max: function max(valFn, thisArg) {
          let max = -Infinity;
          let maxEle;
          const eles = this;

          for (let i = 0; i < eles.length; i++) {
            const ele = eles[i];
            const val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

            if (val > max) {
              max = val;
              maxEle = ele;
            }
          }

          return {
            value: max,
            ele: maxEle
          };
        },
        min: function min(valFn, thisArg) {
          let min = Infinity;
          let minEle;
          const eles = this;

          for (let i = 0; i < eles.length; i++) {
            const ele = eles[i];
            const val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

            if (val < min) {
              min = val;
              minEle = ele;
            }
          }

          return {
            value: min,
            ele: minEle
          };
        }
      }; // aliases

      const fn$5 = elesfn$n;
      fn$5['u'] = fn$5['|'] = fn$5['+'] = fn$5.union = fn$5.or = fn$5.add;
      fn$5['\\'] = fn$5['!'] = fn$5['-'] = fn$5.difference = fn$5.relativeComplement = fn$5.subtract = fn$5.not;
      fn$5['n'] = fn$5['&'] = fn$5['.'] = fn$5.and = fn$5.intersection = fn$5.intersect;
      fn$5['^'] = fn$5['(+)'] = fn$5['(-)'] = fn$5.symmetricDifference = fn$5.symdiff = fn$5.xor;
      fn$5.fnFilter = fn$5.filterFn = fn$5.stdFilter = fn$5.filter;
      fn$5.complement = fn$5.abscomp = fn$5.absoluteComplement;

      const elesfn$o = {
        isNode: function isNode() {
          return this.group() === 'nodes';
        },
        isEdge: function isEdge() {
          return this.group() === 'edges';
        },
        isLoop: function isLoop() {
          return this.isEdge() && this.source()[0] === this.target()[0];
        },
        isSimple: function isSimple() {
          return this.isEdge() && this.source()[0] !== this.target()[0];
        },
        group: function group() {
          const ele = this[0];

          if (ele) {
            return ele._private.group;
          }
        }
      };

/**
 *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),
 *  and z-index (low to high).  These styles affect how this applies:
 *
 *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the
 *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from
 *      root to leaves of the compound graph.  The last drawn is `top`.
 *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.
 *      `manual` ignores this convention and draws based on the `z-index` value setting.
 *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher
 *      `z-index` will be drawn on top of an element with a lower `z-index`.
 */

      const zIndexSort = function zIndexSort(a, b) {
        const cy = a.cy();
        const hasCompoundNodes = cy.hasCompoundNodes();

        function getDepth(ele) {
          const style = ele.pstyle('z-compound-depth');

          if (style.value === 'auto') {
            return hasCompoundNodes ? ele.zDepth() : 0;
          } else if (style.value === 'bottom') {
            return -1;
          } else if (style.value === 'top') {
            return MAX_INT;
          } // 'orphan'


          return 0;
        }

        const depthDiff = getDepth(a) - getDepth(b);

        if (depthDiff !== 0) {
          return depthDiff;
        }

        function getEleDepth(ele) {
          const style = ele.pstyle('z-index-compare');

          if (style.value === 'auto') {
            return ele.isNode() ? 1 : 0;
          } // 'manual'


          return 0;
        }

        const eleDiff = getEleDepth(a) - getEleDepth(b);

        if (eleDiff !== 0) {
          return eleDiff;
        }

        const zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;

        if (zDiff !== 0) {
          return zDiff;
        } // compare indices in the core (order added to graph w/ last on top)


        return a.poolIndex() - b.poolIndex();
      };

      const elesfn$p = {
        forEach: function forEach(fn$1, thisArg) {
          if (fn(fn$1)) {
            const N = this.length;

            for (let i = 0; i < N; i++) {
              const ele = this[i];
              const ret = thisArg ? fn$1.apply(thisArg, [ele, i, this]) : fn$1(ele, i, this);

              if (ret === false) {
                break;
              } // exit each early on return false

            }
          }

          return this;
        },
        toArray: function toArray() {
          const array = [];

          for (let i = 0; i < this.length; i++) {
            array.push(this[i]);
          }

          return array;
        },
        slice: function slice(start, end) {
          const array = [];
          const thisSize = this.length;

          if (end == null) {
            end = thisSize;
          }

          if (start == null) {
            start = 0;
          }

          if (start < 0) {
            start = thisSize + start;
          }

          if (end < 0) {
            end = thisSize + end;
          }

          for (let i = start; i >= 0 && i < end && i < thisSize; i++) {
            array.push(this[i]);
          }

          return this.spawn(array);
        },
        size: function size() {
          return this.length;
        },
        eq: function eq(i) {
          return this[i] || this.spawn();
        },
        first: function first() {
          return this[0] || this.spawn();
        },
        last: function last() {
          return this[this.length - 1] || this.spawn();
        },
        empty: function empty() {
          return this.length === 0;
        },
        nonempty: function nonempty() {
          return !this.empty();
        },
        sort: function sort(sortFn) {
          if (!fn(sortFn)) {
            return this;
          }

          const sorted = this.toArray().sort(sortFn);
          return this.spawn(sorted);
        },
        sortByZIndex: function sortByZIndex() {
          return this.sort(zIndexSort);
        },
        zDepth: function zDepth() {
          const ele = this[0];

          if (!ele) {
            return undefined;
          } // let cy = ele.cy();


          const _p = ele._private;
          const group = _p.group;

          if (group === 'nodes') {
            const depth = _p.data.parent ? ele.parents().size() : 0;

            if (!ele.isParent()) {
              return MAX_INT - 1; // childless nodes always on top
            }

            return depth;
          } else {
            const src = _p.source;
            const tgt = _p.target;
            const srcDepth = src.zDepth();
            const tgtDepth = tgt.zDepth();
            return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent
          }
        }
      };
      elesfn$p.each = elesfn$p.forEach;

      const defineSymbolIterator = function defineSymbolIterator() {
        const typeofUndef =  "undefined" ;
        const isIteratorSupported = (typeof Symbol === "undefined" ? "undefined" : _typeof(Symbol)) != typeofUndef && _typeof(Symbol.iterator) != typeofUndef; // eslint-disable-line no-undef

        if (isIteratorSupported) {
          elesfn$p[Symbol.iterator] = function () {
            const _this = this;

      // eslint-disable-line no-undef
            const entry = {
              value: undefined,
              done: false
            };
            let i = 0;
            const length = this.length;
            return _defineProperty({
              next: function next() {
                if (i < length) {
                  entry.value = _this[i++];
                } else {
                  entry.value = undefined;
                  entry.done = true;
                }

                return entry;
              }
            }, Symbol.iterator, function () {
        // eslint-disable-line no-undef
              return this;
            });
          };
        }
      };

      defineSymbolIterator();

      const getLayoutDimensionOptions = defaults({
        nodeDimensionsIncludeLabels: false
      });
      const elesfn$q = {
  // Calculates and returns node dimensions { x, y } based on options given
        layoutDimensions: function layoutDimensions(options) {
          options = getLayoutDimensionOptions(options);
          let dims;

          if (!this.takesUpSpace()) {
            dims = {
              w: 0,
              h: 0
            };
          } else if (options.nodeDimensionsIncludeLabels) {
            const bbDim = this.boundingBox();
            dims = {
              w: bbDim.w,
              h: bbDim.h
            };
          } else {
            dims = {
              w: this.outerWidth(),
              h: this.outerHeight()
            };
          } // sanitise the dimensions for external layouts (avoid division by zero)


          if (dims.w === 0 || dims.h === 0) {
            dims.w = dims.h = 1;
          }

          return dims;
        },
  // using standard layout options, apply position function (w/ or w/o animation)
        layoutPositions: function layoutPositions(layout, options, fn) {
          const nodes = this.nodes().filter(function (n) {
            return !n.isParent();
          });
          const cy = this.cy();
          const layoutEles = options.eles; // nodes & edges

          const getMemoizeKey = function getMemoizeKey(node) {
            return node.id();
          };

          const fnMem = memoize(fn, getMemoizeKey); // memoized version of position function

          layout.emit({
            type: 'layoutstart',
            layout: layout
          });
          layout.animations = [];

          const calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {
            const center = {
              x: nodesBb.x1 + nodesBb.w / 2,
              y: nodesBb.y1 + nodesBb.h / 2
            };
            const spacingVector = {
        // scale from center of bounding box (not necessarily 0,0)
              x: (pos.x - center.x) * spacing,
              y: (pos.y - center.y) * spacing
            };
            return {
              x: center.x + spacingVector.x,
              y: center.y + spacingVector.y
            };
          };

          const useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;

          const spacingBb = function spacingBb() {
            if (!useSpacingFactor) {
              return null;
            }

            const bb = makeBoundingBox();

            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              const pos = fnMem(node, i);
              expandBoundingBoxByPoint(bb, pos.x, pos.y);
            }

            return bb;
          };

          const bb = spacingBb();
          const getFinalPos = memoize(function (node, i) {
            let newPos = fnMem(node, i);

            if (useSpacingFactor) {
              const spacing = Math.abs(options.spacingFactor);
              newPos = calculateSpacing(spacing, bb, newPos);
            }

            if (options.transform != null) {
              newPos = options.transform(node, newPos);
            }

            return newPos;
          }, getMemoizeKey);

          if (options.animate) {
            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              const newPos = getFinalPos(node, i);
              const animateNode = options.animateFilter == null || options.animateFilter(node, i);

              if (animateNode) {
                const ani = node.animation({
                  position: newPos,
                  duration: options.animationDuration,
                  easing: options.animationEasing
                });
                layout.animations.push(ani);
              } else {
                node.position(newPos);
              }
            }

            if (options.fit) {
              const fitAni = cy.animation({
                fit: {
                  boundingBox: layoutEles.boundingBoxAt(getFinalPos),
                  padding: options.padding
                },
                duration: options.animationDuration,
                easing: options.animationEasing
              });
              layout.animations.push(fitAni);
            } else if (options.zoom !== undefined && options.pan !== undefined) {
              const zoomPanAni = cy.animation({
                zoom: options.zoom,
                pan: options.pan,
                duration: options.animationDuration,
                easing: options.animationEasing
              });
              layout.animations.push(zoomPanAni);
            }

            layout.animations.forEach(function (ani) {
              return ani.play();
            });
            layout.one('layoutready', options.ready);
            layout.emit({
              type: 'layoutready',
              layout: layout
            });
            Promise$1.all(layout.animations.map(function (ani) {
              return ani.promise();
            })).then(function () {
              layout.one('layoutstop', options.stop);
              layout.emit({
                type: 'layoutstop',
                layout: layout
              });
            });
          } else {
            nodes.positions(getFinalPos);

            if (options.fit) {
              cy.fit(options.eles, options.padding);
            }

            if (options.zoom != null) {
              cy.zoom(options.zoom);
            }

            if (options.pan) {
              cy.pan(options.pan);
            }

            layout.one('layoutready', options.ready);
            layout.emit({
              type: 'layoutready',
              layout: layout
            });
            layout.one('layoutstop', options.stop);
            layout.emit({
              type: 'layoutstop',
              layout: layout
            });
          }

          return this; // chaining
        },
        layout: function layout(options) {
          const cy = this.cy();
          return cy.makeLayout(extend({}, options, {
            eles: this
          }));
        }
      }; // aliases:

      elesfn$q.createLayout = elesfn$q.makeLayout = elesfn$q.layout;

      function styleCache(key, fn, ele) {
        const _p = ele._private;
        const cache = _p.styleCache = _p.styleCache || [];
        let val;

        if ((val = cache[key]) != null) {
          return val;
        } else {
          val = cache[key] = fn(ele);
          return val;
        }
      }

      function cacheStyleFunction(key, fn) {
        key = hashString(key);
        return function cachedStyleFunction(ele) {
          return styleCache(key, fn, ele);
        };
      }

      function cachePrototypeStyleFunction(key, fn) {
        key = hashString(key);

        const selfFn = function selfFn(ele) {
          return fn.call(ele);
        };

        return function cachedPrototypeStyleFunction() {
          const ele = this[0];

          if (ele) {
            return styleCache(key, selfFn, ele);
          }
        };
      }

      const elesfn$r = {
        recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {
          const cy = this.cy();
          const renderer = cy.renderer();
          const styleEnabled = cy.styleEnabled();

          if (renderer && styleEnabled) {
            renderer.recalculateRenderedStyle(this, useCache);
          }

          return this;
        },
        dirtyStyleCache: function dirtyStyleCache() {
          const cy = this.cy();

          const dirty = function dirty(ele) {
            return ele._private.styleCache = null;
          };

          if (cy.hasCompoundNodes()) {
            let eles;
            eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
            eles.merge(eles.connectedEdges());
            eles.forEach(dirty);
          } else {
            this.forEach(function (ele) {
              dirty(ele);
              ele.connectedEdges().forEach(dirty);
            });
          }

          return this;
        },
  // fully updates (recalculates) the style for the elements
        updateStyle: function updateStyle(notifyRenderer) {
          const cy = this._private.cy;

          if (!cy.styleEnabled()) {
            return this;
          }

          if (cy.batching()) {
            const bEles = cy._private.batchStyleEles;
            bEles.merge(this);
            return this; // chaining and exit early when batching
          }

          const hasCompounds = cy.hasCompoundNodes();
          let updatedEles = this;
          notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

          if (hasCompounds) {
      // then add everything up and down for compound selector checks
            updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
          } // let changedEles = style.apply( updatedEles );


          const changedEles = updatedEles;

          if (notifyRenderer) {
            changedEles.emitAndNotify('style'); // let renderer know we changed style
          } else {
            changedEles.emit('style'); // just fire the event
          }

          updatedEles.forEach(function (ele) {
            return ele._private.styleDirty = true;
          });
          return this; // chaining
        },
  // private: clears dirty flag and recalculates style
        cleanStyle: function cleanStyle() {
          const cy = this.cy();

          if (!cy.styleEnabled()) {
            return;
          }

          for (let i = 0; i < this.length; i++) {
            const ele = this[i];

            if (ele._private.styleDirty) {
        // n.b. this flag should be set before apply() to avoid potential infinite recursion
              ele._private.styleDirty = false;
              cy.style().apply(ele);
            }
          }
        },
  // get the internal parsed style object for the specified property
        parsedStyle: function parsedStyle(property) {
          const includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          const ele = this[0];
          const cy = ele.cy();

          if (!cy.styleEnabled()) {
            return;
          }

          if (ele) {
            this.cleanStyle();
            const overriddenStyle = ele._private.style[property];

            if (overriddenStyle != null) {
              return overriddenStyle;
            } else if (includeNonDefault) {
              return cy.style().getDefaultProperty(property);
            } else {
              return null;
            }
          }
        },
        numericStyle: function numericStyle(property) {
          const ele = this[0];

          if (!ele.cy().styleEnabled()) {
            return;
          }

          if (ele) {
            const pstyle = ele.pstyle(property);
            return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;
          }
        },
        numericStyleUnits: function numericStyleUnits(property) {
          const ele = this[0];

          if (!ele.cy().styleEnabled()) {
            return;
          }

          if (ele) {
            return ele.pstyle(property).units;
          }
        },
  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
        renderedStyle: function renderedStyle(property) {
          const cy = this.cy();

          if (!cy.styleEnabled()) {
            return this;
          }

          const ele = this[0];

          if (ele) {
            return cy.style().getRenderedStyle(ele, property);
          }
        },
  // read the calculated css style of the element or override the style (via a bypass)
        style: function style(name, value) {
          const cy = this.cy();

          if (!cy.styleEnabled()) {
            return this;
          }

          const updateTransitions = false;
          const style = cy.style();

          if (plainObject(name)) {
      // then extend the bypass
            const props = name;
            style.applyBypass(this, props, updateTransitions);
            this.emitAndNotify('style'); // let the renderer know we've updated style
          } else if (string(name)) {
            if (value === undefined) {
        // then get the property from the style
              const ele = this[0];

              if (ele) {
                return style.getStylePropertyValue(ele, name);
              } else {
          // empty collection => can't get any value
                return;
              }
            } else {
        // then set the bypass with the property value
              style.applyBypass(this, name, value, updateTransitions);
              this.emitAndNotify('style'); // let the renderer know we've updated style
            }
          } else if (name === undefined) {
            const _ele = this[0];

            if (_ele) {
              return style.getRawStyle(_ele);
            } else {
        // empty collection => can't get any value
              return;
            }
          }

          return this; // chaining
        },
        removeStyle: function removeStyle(names) {
          const cy = this.cy();

          if (!cy.styleEnabled()) {
            return this;
          }

          const updateTransitions = false;
          const style = cy.style();
          const eles = this;

          if (names === undefined) {
            for (let i = 0; i < eles.length; i++) {
              const ele = eles[i];
              style.removeAllBypasses(ele, updateTransitions);
            }
          } else {
            names = names.split(/\s+/);

            for (let _i = 0; _i < eles.length; _i++) {
              const _ele2 = eles[_i];
              style.removeBypasses(_ele2, names, updateTransitions);
            }
          }

          this.emitAndNotify('style'); // let the renderer know we've updated style

          return this; // chaining
        },
        show: function show() {
          this.css('display', 'element');
          return this; // chaining
        },
        hide: function hide() {
          this.css('display', 'none');
          return this; // chaining
        },
        effectiveOpacity: function effectiveOpacity() {
          const cy = this.cy();

          if (!cy.styleEnabled()) {
            return 1;
          }

          const hasCompoundNodes = cy.hasCompoundNodes();
          const ele = this[0];

          if (ele) {
            const _p = ele._private;
            let parentOpacity = ele.pstyle('opacity').value;

            if (!hasCompoundNodes) {
              return parentOpacity;
            }

            const parents = !_p.data.parent ? null : ele.parents();

            if (parents) {
              for (let i = 0; i < parents.length; i++) {
                const parent = parents[i];
                const opacity = parent.pstyle('opacity').value;
                parentOpacity = opacity * parentOpacity;
              }
            }

            return parentOpacity;
          }
        },
        transparent: function transparent() {
          const cy = this.cy();

          if (!cy.styleEnabled()) {
            return false;
          }

          const ele = this[0];
          const hasCompoundNodes = ele.cy().hasCompoundNodes();

          if (ele) {
            if (!hasCompoundNodes) {
              return ele.pstyle('opacity').value === 0;
            } else {
              return ele.effectiveOpacity() === 0;
            }
          }
        },
        backgrounding: function backgrounding() {
          const cy = this.cy();

          if (!cy.styleEnabled()) {
            return false;
          }

          const ele = this[0];
          return ele._private.backgrounding ? true : false;
        }
      };

      function checkCompound(ele, parentOk) {
        const _p = ele._private;
        const parents = _p.data.parent ? ele.parents() : null;

        if (parents) {
          for (let i = 0; i < parents.length; i++) {
            const parent = parents[i];

            if (!parentOk(parent)) {
              return false;
            }
          }
        }

        return true;
      }

      function defineDerivedStateFunction(specs) {
        const ok = specs.ok;
        const edgeOkViaNode = specs.edgeOkViaNode || specs.ok;
        const parentOk = specs.parentOk || specs.ok;
        return function () {
          const cy = this.cy();

          if (!cy.styleEnabled()) {
            return true;
          }

          const ele = this[0];
          const hasCompoundNodes = cy.hasCompoundNodes();

          if (ele) {
            const _p = ele._private;

            if (!ok(ele)) {
              return false;
            }

            if (ele.isNode()) {
              return !hasCompoundNodes || checkCompound(ele, parentOk);
            } else {
              const src = _p.source;
              const tgt = _p.target;
              return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));
            }
          }
        };
      }

      const eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {
        return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);
      });
      elesfn$r.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({
        ok: eleTakesUpSpace
      }));
      const eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {
        return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);
      });
      const parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {
        return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);
      });
      elesfn$r.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({
        ok: eleInteractive,
        parentOk: parentInteractive,
        edgeOkViaNode: eleTakesUpSpace
      }));

      elesfn$r.noninteractive = function () {
        const ele = this[0];

        if (ele) {
          return !ele.interactive();
        }
      };

      const eleVisible = cacheStyleFunction('eleVisible', function (ele) {
        return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);
      });
      const edgeVisibleViaNode = eleTakesUpSpace;
      elesfn$r.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({
        ok: eleVisible,
        edgeOkViaNode: edgeVisibleViaNode
      }));

      elesfn$r.hidden = function () {
        const ele = this[0];

        if (ele) {
          return !ele.visible();
        }
      };

      elesfn$r.isBundledBezier = cachePrototypeStyleFunction('isBundledBezier', function () {
        if (!this.cy().styleEnabled()) {
          return false;
        }

        return !this.removed() && this.pstyle('curve-style').value === 'bezier' && this.takesUpSpace();
      });
      elesfn$r.bypass = elesfn$r.css = elesfn$r.style;
      elesfn$r.renderedCss = elesfn$r.renderedStyle;
      elesfn$r.removeBypass = elesfn$r.removeCss = elesfn$r.removeStyle;
      elesfn$r.pstyle = elesfn$r.parsedStyle;

      const elesfn$s = {};

      function defineSwitchFunction(params) {
        return function () {
          const args = arguments;
          const changedEles = []; // e.g. cy.nodes().select( data, handler )

          if (args.length === 2) {
            const data = args[0];
            const handler = args[1];
            this.on(params.event, data, handler);
          } // e.g. cy.nodes().select( handler )
          else if (args.length === 1 && fn(args[0])) {
            const _handler = args[0];
            this.on(params.event, _handler);
          } // e.g. cy.nodes().select()
      // e.g. (private) cy.nodes().select(['tapselect'])
          else if (args.length === 0 || args.length === 1 && array(args[0])) {
            const addlEvents = args.length === 1 ? args[0] : null;

            for (let i = 0; i < this.length; i++) {
              const ele = this[i];
              let able = !params.ableField || ele._private[params.ableField];
              const changed = ele._private[params.field] != params.value;

              if (params.overrideAble) {
                const overrideAble = params.overrideAble(ele);

                if (overrideAble !== undefined) {
                  able = overrideAble;

                  if (!overrideAble) {
                    return this;
                  } // to save cycles assume not able for all on override

                }
              }

              if (able) {
                ele._private[params.field] = params.value;

                if (changed) {
                  changedEles.push(ele);
                }
              }
            }

            const changedColl = this.spawn(changedEles);
            changedColl.updateStyle(); // change of state => possible change of style

            changedColl.emit(params.event);

            if (addlEvents) {
              changedColl.emit(addlEvents);
            }
          }

          return this;
        };
      }

      function defineSwitchSet(params) {
        elesfn$s[params.field] = function () {
          const ele = this[0];

          if (ele) {
            if (params.overrideField) {
              const val = params.overrideField(ele);

              if (val !== undefined) {
                return val;
              }
            }

            return ele._private[params.field];
          }
        };

        elesfn$s[params.on] = defineSwitchFunction({
          event: params.on,
          field: params.field,
          ableField: params.ableField,
          overrideAble: params.overrideAble,
          value: true
        });
        elesfn$s[params.off] = defineSwitchFunction({
          event: params.off,
          field: params.field,
          ableField: params.ableField,
          overrideAble: params.overrideAble,
          value: false
        });
      }

      defineSwitchSet({
        field: 'locked',
        overrideField: function overrideField(ele) {
          return ele.cy().autolock() ? true : undefined;
        },
        on: 'lock',
        off: 'unlock'
      });
      defineSwitchSet({
        field: 'grabbable',
        overrideField: function overrideField(ele) {
          return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;
        },
        on: 'grabify',
        off: 'ungrabify'
      });
      defineSwitchSet({
        field: 'selected',
        ableField: 'selectable',
        overrideAble: function overrideAble(ele) {
          return ele.cy().autounselectify() ? false : undefined;
        },
        on: 'select',
        off: 'unselect'
      });
      defineSwitchSet({
        field: 'selectable',
        overrideField: function overrideField(ele) {
          return ele.cy().autounselectify() ? false : undefined;
        },
        on: 'selectify',
        off: 'unselectify'
      });
      elesfn$s.deselect = elesfn$s.unselect;

      elesfn$s.grabbed = function () {
        const ele = this[0];

        if (ele) {
          return ele._private.grabbed;
        }
      };

      defineSwitchSet({
        field: 'active',
        on: 'activate',
        off: 'unactivate'
      });
      defineSwitchSet({
        field: 'pannable',
        on: 'panify',
        off: 'unpanify'
      });

      elesfn$s.inactive = function () {
        const ele = this[0];

        if (ele) {
          return !ele._private.active;
        }
      };

      const elesfn$t = {}; // DAG functions
////////////////

      const defineDagExtremity = function defineDagExtremity(params) {
        return function dagExtremityImpl(selector) {
          const eles = this;
          const ret = [];

          for (let i = 0; i < eles.length; i++) {
            const ele = eles[i];

            if (!ele.isNode()) {
              continue;
            }

            let disqualified = false;
            const edges = ele.connectedEdges();

            for (let j = 0; j < edges.length; j++) {
              const edge = edges[j];
              const src = edge.source();
              const tgt = edge.target();

              if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {
                disqualified = true;
                break;
              }
            }

            if (!disqualified) {
              ret.push(ele);
            }
          }

          return this.spawn(ret, true).filter(selector);
        };
      };

      const defineDagOneHop = function defineDagOneHop(params) {
        return function (selector) {
          const eles = this;
          const oEles = [];

          for (let i = 0; i < eles.length; i++) {
            const ele = eles[i];

            if (!ele.isNode()) {
              continue;
            }

            const edges = ele.connectedEdges();

            for (let j = 0; j < edges.length; j++) {
              const edge = edges[j];
              const src = edge.source();
              const tgt = edge.target();

              if (params.outgoing && src === ele) {
                oEles.push(edge);
                oEles.push(tgt);
              } else if (params.incoming && tgt === ele) {
                oEles.push(edge);
                oEles.push(src);
              }
            }
          }

          return this.spawn(oEles, true).filter(selector);
        };
      };

      const defineDagAllHops = function defineDagAllHops(params) {
        return function (selector) {
          let eles = this;
          const sEles = [];
          const sElesIds = {};

          for (;;) {
            const next = params.outgoing ? eles.outgoers() : eles.incomers();

            if (next.length === 0) {
              break;
            } // done if none left


            let newNext = false;

            for (let i = 0; i < next.length; i++) {
              const n = next[i];
              const nid = n.id();

              if (!sElesIds[nid]) {
                sElesIds[nid] = true;
                sEles.push(n);
                newNext = true;
              }
            }

            if (!newNext) {
              break;
            } // done if touched all outgoers already


            eles = next;
          }

          return this.spawn(sEles, true).filter(selector);
        };
      };

      elesfn$t.clearTraversalCache = function () {
        for (let i = 0; i < this.length; i++) {
          this[i]._private.traversalCache = null;
        }
      };

      extend(elesfn$t, {
  // get the root nodes in the DAG
        roots: defineDagExtremity({
          noIncomingEdges: true
        }),
  // get the leaf nodes in the DAG
        leaves: defineDagExtremity({
          noOutgoingEdges: true
        }),
  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
        outgoers: cache(defineDagOneHop({
          outgoing: true
        }), 'outgoers'),
  // aka DAG descendants
        successors: defineDagAllHops({
          outgoing: true
        }),
  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
        incomers: cache(defineDagOneHop({
          incoming: true
        }), 'incomers'),
  // aka DAG ancestors
        predecessors: defineDagAllHops({
          incoming: true
        })
      }); // Neighbourhood functions
//////////////////////////

      extend(elesfn$t, {
        neighborhood: cache(function (selector) {
          const elements = [];
          const nodes = this.nodes();

          for (let i = 0; i < nodes.length; i++) {
      // for all nodes
            const node = nodes[i];
            const connectedEdges = node.connectedEdges(); // for each connected edge, add the edge and the other node

            for (let j = 0; j < connectedEdges.length; j++) {
              const edge = connectedEdges[j];
              const src = edge.source();
              const tgt = edge.target();
              const otherNode = node === src ? tgt : src; // need check in case of loop

              if (otherNode.length > 0) {
                elements.push(otherNode[0]); // add node 1 hop away
              } // add connected edge


              elements.push(edge[0]);
            }
          }

          return this.spawn(elements, true).filter(selector);
        }, 'neighborhood'),
        closedNeighborhood: function closedNeighborhood(selector) {
          return this.neighborhood().add(this).filter(selector);
        },
        openNeighborhood: function openNeighborhood(selector) {
          return this.neighborhood(selector);
        }
      }); // aliases

      elesfn$t.neighbourhood = elesfn$t.neighborhood;
      elesfn$t.closedNeighbourhood = elesfn$t.closedNeighborhood;
      elesfn$t.openNeighbourhood = elesfn$t.openNeighborhood; // Edge functions
/////////////////

      extend(elesfn$t, {
        source: cache(function sourceImpl(selector) {
          const ele = this[0];
          let src;

          if (ele) {
            src = ele._private.source || ele.cy().collection();
          }

          return src && selector ? src.filter(selector) : src;
        }, 'source'),
        target: cache(function targetImpl(selector) {
          const ele = this[0];
          let tgt;

          if (ele) {
            tgt = ele._private.target || ele.cy().collection();
          }

          return tgt && selector ? tgt.filter(selector) : tgt;
        }, 'target'),
        sources: defineSourceFunction({
          attr: 'source'
        }),
        targets: defineSourceFunction({
          attr: 'target'
        })
      });

      function defineSourceFunction(params) {
        return function sourceImpl(selector) {
          const sources = [];

          for (let i = 0; i < this.length; i++) {
            const ele = this[i];
            const src = ele._private[params.attr];

            if (src) {
              sources.push(src);
            }
          }

          return this.spawn(sources, true).filter(selector);
        };
      }

      extend(elesfn$t, {
        edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),
        edgesTo: cache(defineEdgesWithFunction({
          thisIsSrc: true
        }), 'edgesTo')
      });

      function defineEdgesWithFunction(params) {
        return function edgesWithImpl(otherNodes) {
          const elements = [];
          const cy = this._private.cy;
          const p = params || {}; // get elements if a selector is specified

          if (string(otherNodes)) {
            otherNodes = cy.$(otherNodes);
          }

          for (let h = 0; h < otherNodes.length; h++) {
            const edges = otherNodes[h]._private.edges;

            for (let i = 0; i < edges.length; i++) {
              const edge = edges[i];
              const edgeData = edge._private.data;
              const thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);
              const otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);
              const edgeConnectsThisAndOther = thisToOther || otherToThis;

              if (!edgeConnectsThisAndOther) {
                continue;
              }

              if (p.thisIsSrc || p.thisIsTgt) {
                if (p.thisIsSrc && !thisToOther) {
                  continue;
                }

                if (p.thisIsTgt && !otherToThis) {
                  continue;
                }
              }

              elements.push(edge);
            }
          }

          return this.spawn(elements, true);
        };
      }

      extend(elesfn$t, {
        connectedEdges: cache(function (selector) {
          const retEles = [];
          const eles = this;

          for (let i = 0; i < eles.length; i++) {
            const node = eles[i];

            if (!node.isNode()) {
              continue;
            }

            const edges = node._private.edges;

            for (let j = 0; j < edges.length; j++) {
              const edge = edges[j];
              retEles.push(edge);
            }
          }

          return this.spawn(retEles, true).filter(selector);
        }, 'connectedEdges'),
        connectedNodes: cache(function (selector) {
          const retEles = [];
          const eles = this;

          for (let i = 0; i < eles.length; i++) {
            const edge = eles[i];

            if (!edge.isEdge()) {
              continue;
            }

            retEles.push(edge.source()[0]);
            retEles.push(edge.target()[0]);
          }

          return this.spawn(retEles, true).filter(selector);
        }, 'connectedNodes'),
        parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),
        codirectedEdges: cache(defineParallelEdgesFunction({
          codirected: true
        }), 'codirectedEdges')
      });

      function defineParallelEdgesFunction(params) {
        const defaults = {
          codirected: false
        };
        params = extend({}, defaults, params);
        return function parallelEdgesImpl(selector) {
    // micro-optimised for renderer
          const elements = [];
          const edges = this.edges();
          const p = params; // look at all the edges in the collection

          for (let i = 0; i < edges.length; i++) {
            const edge1 = edges[i];
            const edge1_p = edge1._private;
            const src1 = edge1_p.source;
            const srcid1 = src1._private.data.id;
            const tgtid1 = edge1_p.data.target;
            const srcEdges1 = src1._private.edges; // look at edges connected to the src node of this edge

            for (let j = 0; j < srcEdges1.length; j++) {
              const edge2 = srcEdges1[j];
              const edge2data = edge2._private.data;
              const tgtid2 = edge2data.target;
              const srcid2 = edge2data.source;
              const codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
              const oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;

              if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {
                elements.push(edge2);
              }
            }
          }

          return this.spawn(elements, true).filter(selector);
        };
      } // Misc functions
/////////////////


      extend(elesfn$t, {
        components: function components(root) {
          const self = this;
          const cy = self.cy();
          const visited = cy.collection();
          let unvisited = root == null ? self.nodes() : root.nodes();
          const components = [];

          if (root != null && unvisited.empty()) {
      // root may contain only edges
            unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides
          }

          const visitInComponent = function visitInComponent(node, component) {
            visited.merge(node);
            unvisited.unmerge(node);
            component.merge(node);
          };

          if (unvisited.empty()) {
            return self.spawn();
          }

          const _loop = function _loop() {
      // each iteration yields a component
            const cmpt = cy.collection();
            components.push(cmpt);
            const root = unvisited[0];
            visitInComponent(root, cmpt);
            self.bfs({
              directed: false,
              roots: root,
              visit: function visit(v) {
                return visitInComponent(v, cmpt);
              }
            });
            cmpt.forEach(function (node) {
              node.connectedEdges().forEach(function (e) {
          // connectedEdges() usually cached
                if (self.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {
            // has() is cheap
                  cmpt.merge(e); // forEach() only considers nodes -- sets N at call time
                }
              });
            });
          };

          do {
            _loop();
          } while (unvisited.length > 0);

          return components;
        },
        component: function component() {
          const ele = this[0];
          return ele.cy().mutableElements().components(ele)[0];
        }
      });
      elesfn$t.componentsOf = elesfn$t.components;

      const Collection = function Collection(cy, elements) {
        const unique = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (cy === undefined) {
          error('A collection must have a reference to the core');
          return;
        }

        const map = new Map$1();
        let createdElements = false;

        if (!elements) {
          elements = [];
        } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {
          createdElements = true; // make elements from json and restore all at once later

          const eles = [];
          const elesIds = new Set$1();

          for (let i = 0, l = elements.length; i < l; i++) {
            const json = elements[i];

            if (json.data == null) {
              json.data = {};
            }

            const _data = json.data; // make sure newly created elements have valid ids

            if (_data.id == null) {
              _data.id = uuid();
            } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {
              continue; // can't create element if prior id already exists
            }

            const ele = new Element(cy, json, false);
            eles.push(ele);
            elesIds.add(_data.id);
          }

          elements = eles;
        }

        this.length = 0;

        for (let _i = 0, _l = elements.length; _i < _l; _i++) {
          const element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements

          if (element$1 == null) {
            continue;
          }

          const id = element$1._private.data.id;

          if (!unique || !map.has(id)) {
            if (unique) {
              map.set(id, {
                index: this.length,
                ele: element$1
              });
            }

            this[this.length] = element$1;
            this.length++;
          }
        }

        this._private = {
          eles: this,
          cy: cy,

          get map() {
            if (this.lazyMap == null) {
              this.rebuildMap();
            }

            return this.lazyMap;
          },

          set map(m) {
            this.lazyMap = m;
          },

          rebuildMap: function rebuildMap() {
            const m = this.lazyMap = new Map$1();
            const eles = this.eles;

            for (let _i2 = 0; _i2 < eles.length; _i2++) {
              const _ele = eles[_i2];
              m.set(_ele.id(), {
                index: _i2,
                ele: _ele
              });
            }
          }
        };

        if (unique) {
          this._private.map = map;
        } // restore the elements if we created them from json


        if (createdElements) {
          this.restore();
        }
      }; // Functions
////////////////////////////////////////////////////////////////////////////////////////////////////
// keep the prototypes in sync (an element has the same functions as a collection)
// and use elefn and elesfn as shorthands to the prototypes


      const elesfn$u = Element.prototype = Collection.prototype = Object.create(Array.prototype);

      elesfn$u.instanceString = function () {
        return 'collection';
      };

      elesfn$u.spawn = function (eles, unique) {
        return new Collection(this.cy(), eles, unique);
      };

      elesfn$u.spawnSelf = function () {
        return this.spawn(this);
      };

      elesfn$u.cy = function () {
        return this._private.cy;
      };

      elesfn$u.renderer = function () {
        return this._private.cy.renderer();
      };

      elesfn$u.element = function () {
        return this[0];
      };

      elesfn$u.collection = function () {
        if (collection(this)) {
          return this;
        } else {
    // an element
          return new Collection(this._private.cy, [this]);
        }
      };

      elesfn$u.unique = function () {
        return new Collection(this._private.cy, this, true);
      };

      elesfn$u.hasElementWithId = function (id) {
        id = '' + id; // id must be string

        return this._private.map.has(id);
      };

      elesfn$u.getElementById = function (id) {
        id = '' + id; // id must be string

        const cy = this._private.cy;

        const entry = this._private.map.get(id);

        return entry ? entry.ele : new Collection(cy); // get ele or empty collection
      };

      elesfn$u.$id = elesfn$u.getElementById;

      elesfn$u.poolIndex = function () {
        const cy = this._private.cy;
        const eles = cy._private.elements;
        const id = this[0]._private.data.id;
        return eles._private.map.get(id).index;
      };

      elesfn$u.indexOf = function (ele) {
        const id = ele[0]._private.data.id;
        return this._private.map.get(id).index;
      };

      elesfn$u.indexOfId = function (id) {
        id = '' + id; // id must be string

        return this._private.map.get(id).index;
      };

      elesfn$u.json = function (obj) {
        let ele = this.element();
        const cy = this.cy();

        if (ele == null && obj) {
          return this;
        } // can't set to no eles


        if (ele == null) {
          return undefined;
        } // can't get from no eles


        const p = ele._private;

        if (plainObject(obj)) {
    // set
          cy.startBatch();

          if (obj.data) {
            ele.data(obj.data);
            const _data2 = p.data;

            if (ele.isEdge()) {
        // source and target are immutable via data()
              let move = false;
              const spec = {};
              const src = obj.data.source;
              const tgt = obj.data.target;

              if (src != null && src != _data2.source) {
                spec.source = '' + src; // id must be string

                move = true;
              }

              if (tgt != null && tgt != _data2.target) {
                spec.target = '' + tgt; // id must be string

                move = true;
              }

              if (move) {
                ele = ele.move(spec);
              }
            } else {
        // parent is immutable via data()
              const newParentValSpecd = 'parent' in obj.data;
              let parent = obj.data.parent;

              if (newParentValSpecd && (parent != null || _data2.parent != null) && parent != _data2.parent) {
                if (parent === undefined) {
            // can't set undefined imperatively, so use null
                  parent = null;
                }

                if (parent != null) {
                  parent = '' + parent; // id must be string
                }

                ele = ele.move({
                  parent: parent
                });
              }
            }
          }

          if (obj.position) {
            ele.position(obj.position);
          } // ignore group -- immutable


          const checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {
            const obj_k = obj[k];

            if (obj_k != null && obj_k !== p[k]) {
              if (obj_k) {
                ele[trueFnName]();
              } else {
                ele[falseFnName]();
              }
            }
          };

          checkSwitch('removed', 'remove', 'restore');
          checkSwitch('selected', 'select', 'unselect');
          checkSwitch('selectable', 'selectify', 'unselectify');
          checkSwitch('locked', 'lock', 'unlock');
          checkSwitch('grabbable', 'grabify', 'ungrabify');
          checkSwitch('pannable', 'panify', 'unpanify');

          if (obj.classes != null) {
            ele.classes(obj.classes);
          }

          cy.endBatch();
          return this;
        } else if (obj === undefined) {
    // get
          const json = {
            data: copy(p.data),
            position: copy(p.position),
            group: p.group,
            removed: p.removed,
            selected: p.selected,
            selectable: p.selectable,
            locked: p.locked,
            grabbable: p.grabbable,
            pannable: p.pannable,
            classes: null
          };
          json.classes = '';
          let i = 0;
          p.classes.forEach(function (cls) {
            return json.classes += i++ === 0 ? cls : ' ' + cls;
          });
          return json;
        }
      };

      elesfn$u.jsons = function () {
        const jsons = [];

        for (let i = 0; i < this.length; i++) {
          const ele = this[i];
          const json = ele.json();
          jsons.push(json);
        }

        return jsons;
      };

      elesfn$u.clone = function () {
        const cy = this.cy();
        const elesArr = [];

        for (let i = 0; i < this.length; i++) {
          const ele = this[i];
          const json = ele.json();
          const clone = new Element(cy, json, false); // NB no restore

          elesArr.push(clone);
        }

        return new Collection(cy, elesArr);
      };

      elesfn$u.copy = elesfn$u.clone;

      elesfn$u.restore = function () {
        const notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        const addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        const self = this;
        const cy = self.cy();
        const cy_p = cy._private; // create arrays of nodes and edges, since we need to
  // restore the nodes first

        const nodes = [];
        const edges = [];
        let elements;

        for (let _i3 = 0, l = self.length; _i3 < l; _i3++) {
          const ele = self[_i3];

          if (addToPool && !ele.removed()) {
      // don't need to handle this ele
            continue;
          } // keep nodes first in the array and edges after


          if (ele.isNode()) {
      // put to front of array if node
            nodes.push(ele);
          } else {
      // put to end of array if edge
            edges.push(ele);
          }
        }

        elements = nodes.concat(edges);
        let i;

        const removeFromElements = function removeFromElements() {
          elements.splice(i, 1);
          i--;
        }; // now, restore each element


        for (i = 0; i < elements.length; i++) {
          const _ele2 = elements[i];
          const _private = _ele2._private;
          const _data3 = _private.data; // the traversal cache should start fresh when ele is added

          _ele2.clearTraversalCache(); // set id and validate


          if (!addToPool && !_private.removed) ; else if (_data3.id === undefined) {
            _data3.id = uuid();
          } else if (number(_data3.id)) {
            _data3.id = '' + _data3.id; // now it's a string
          } else if (emptyString(_data3.id) || !string(_data3.id)) {
            error('Can not create element with invalid string ID `' + _data3.id + '`'); // can't create element if it has empty string as id or non-string id

            removeFromElements();
            continue;
          } else if (cy.hasElementWithId(_data3.id)) {
            error('Can not create second element with ID `' + _data3.id + '`'); // can't create element if one already has that id

            removeFromElements();
            continue;
          }

          const id = _data3.id; // id is finalised, now let's keep a ref

          if (_ele2.isNode()) {
      // extra checks for nodes
            const pos = _private.position; // make sure the nodes have a defined position

            if (pos.x == null) {
              pos.x = 0;
            }

            if (pos.y == null) {
              pos.y = 0;
            }
          }

          if (_ele2.isEdge()) {
      // extra checks for edges
            const edge = _ele2;
            const fields = ['source', 'target'];
            const fieldsLength = fields.length;
            let badSourceOrTarget = false;

            for (let j = 0; j < fieldsLength; j++) {
              const field = fields[j];
              let val = _data3[field];

              if (number(val)) {
                val = _data3[field] = '' + _data3[field]; // now string
              }

              if (val == null || val === '') {
          // can't create if source or target is not defined properly
                error('Can not create edge `' + id + '` with unspecified ' + field);
                badSourceOrTarget = true;
              } else if (!cy.hasElementWithId(val)) {
          // can't create edge if one of its nodes doesn't exist
                error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
                badSourceOrTarget = true;
              }
            }

            if (badSourceOrTarget) {
              removeFromElements();
              continue;
            } // can't create this


            const src = cy.getElementById(_data3.source);
            const tgt = cy.getElementById(_data3.target); // only one edge in node if loop

            if (src.same(tgt)) {
              src._private.edges.push(edge);
            } else {
              src._private.edges.push(edge);

              tgt._private.edges.push(edge);
            }

            edge._private.source = src;
            edge._private.target = tgt;
          } // if is edge
    // create mock ids / indexes maps for element so it can be used like collections


          _private.map = new Map$1();

          _private.map.set(id, {
            ele: _ele2,
            index: 0
          });

          _private.removed = false;

          if (addToPool) {
            cy.addToPool(_ele2);
          }
        } // for each element
  // do compound node sanity checks


        for (let _i4 = 0; _i4 < nodes.length; _i4++) {
    // each node
          const node = nodes[_i4];
          const _data4 = node._private.data;

          if (number(_data4.parent)) {
      // then automake string
            _data4.parent = '' + _data4.parent;
          }

          const parentId = _data4.parent;
          const specifiedParent = parentId != null;

          if (specifiedParent) {
            const parent = cy.getElementById(parentId);

            if (parent.empty()) {
        // non-existant parent; just remove it
              _data4.parent = undefined;
            } else {
              let selfAsParent = false;
              let ancestor = parent;

              while (!ancestor.empty()) {
                if (node.same(ancestor)) {
            // mark self as parent and remove from data
                  selfAsParent = true;
                  _data4.parent = undefined; // remove parent reference
            // exit or we loop forever

                  break;
                }

                ancestor = ancestor.parent();
              }

              if (!selfAsParent) {
          // connect with children
                parent[0]._private.children.push(node);

                node._private.parent = parent[0]; // let the core know we have a compound graph

                cy_p.hasCompoundNodes = true;
              }
            } // else

          } // if specified parent

        } // for each node


        if (elements.length > 0) {
          const restored = elements.length === self.length ? self : new Collection(cy, elements);

          for (let _i5 = 0; _i5 < restored.length; _i5++) {
            const _ele3 = restored[_i5];

            if (_ele3.isNode()) {
              continue;
            } // adding an edge invalidates the traversal caches for the parallel edges


            _ele3.parallelEdges().clearTraversalCache(); // adding an edge invalidates the traversal cache for the connected nodes


            _ele3.source().clearTraversalCache();

            _ele3.target().clearTraversalCache();
          }

          let toUpdateStyle;

          if (cy_p.hasCompoundNodes) {
            toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());
          } else {
            toUpdateStyle = restored;
          }

          toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);

          if (notifyRenderer) {
            restored.emitAndNotify('add');
          } else if (addToPool) {
            restored.emit('add');
          }
        }

        return self; // chainability
      };

      elesfn$u.removed = function () {
        const ele = this[0];
        return ele && ele._private.removed;
      };

      elesfn$u.inside = function () {
        const ele = this[0];
        return ele && !ele._private.removed;
      };

      elesfn$u.remove = function () {
        const notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        const removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        const self = this;
        const elesToRemove = [];
        const elesToRemoveIds = {};
        const cy = self._private.cy; // add connected edges

        function addConnectedEdges(node) {
          const edges = node._private.edges;

          for (let i = 0; i < edges.length; i++) {
            add(edges[i]);
          }
        } // add descendant nodes


        function addChildren(node) {
          const children = node._private.children;

          for (let i = 0; i < children.length; i++) {
            add(children[i]);
          }
        }

        function add(ele) {
          const alreadyAdded = elesToRemoveIds[ele.id()];

          if (removeFromPool && ele.removed() || alreadyAdded) {
            return;
          } else {
            elesToRemoveIds[ele.id()] = true;
          }

          if (ele.isNode()) {
            elesToRemove.push(ele); // nodes are removed last

            addConnectedEdges(ele);
            addChildren(ele);
          } else {
            elesToRemove.unshift(ele); // edges are removed first
          }
        } // make the list of elements to remove
  // (may be removing more than specified due to connected edges etc)


        for (let i = 0, l = self.length; i < l; i++) {
          const ele = self[i];
          add(ele);
        }

        function removeEdgeRef(node, edge) {
          const connectedEdges = node._private.edges;
          removeFromArray(connectedEdges, edge); // removing an edges invalidates the traversal cache for its nodes

          node.clearTraversalCache();
        }

        function removeParallelRef(pllEdge) {
    // removing an edge invalidates the traversal caches for the parallel edges
          pllEdge.clearTraversalCache();
        }

        const alteredParents = [];
        alteredParents.ids = {};

        function removeChildRef(parent, ele) {
          ele = ele[0];
          parent = parent[0];
          const children = parent._private.children;
          const pid = parent.id();
          removeFromArray(children, ele); // remove parent => child ref

          ele._private.parent = null; // remove child => parent ref

          if (!alteredParents.ids[pid]) {
            alteredParents.ids[pid] = true;
            alteredParents.push(parent);
          }
        }

        self.dirtyCompoundBoundsCache();

        if (removeFromPool) {
          cy.removeFromPool(elesToRemove); // remove from core pool
        }

        for (let _i6 = 0; _i6 < elesToRemove.length; _i6++) {
          const _ele4 = elesToRemove[_i6];

          if (_ele4.isEdge()) {
      // remove references to this edge in its connected nodes
            const src = _ele4.source()[0];

            const tgt = _ele4.target()[0];

            removeEdgeRef(src, _ele4);
            removeEdgeRef(tgt, _ele4);

            const pllEdges = _ele4.parallelEdges();

            for (let j = 0; j < pllEdges.length; j++) {
              const pllEdge = pllEdges[j];
              removeParallelRef(pllEdge);

              if (pllEdge.isBundledBezier()) {
                pllEdge.dirtyBoundingBoxCache();
              }
            }
          } else {
      // remove reference to parent
            const parent = _ele4.parent();

            if (parent.length !== 0) {
              removeChildRef(parent, _ele4);
            }
          }

          if (removeFromPool) {
      // mark as removed
            _ele4._private.removed = true;
          }
        } // check to see if we have a compound graph or not


        const elesStillInside = cy._private.elements;
        cy._private.hasCompoundNodes = false;

        for (let _i7 = 0; _i7 < elesStillInside.length; _i7++) {
          const _ele5 = elesStillInside[_i7];

          if (_ele5.isParent()) {
            cy._private.hasCompoundNodes = true;
            break;
          }
        }

        const removedElements = new Collection(this.cy(), elesToRemove);

        if (removedElements.size() > 0) {
    // must manually notify since trigger won't do this automatically once removed
          if (notifyRenderer) {
            removedElements.emitAndNotify('remove');
          } else if (removeFromPool) {
            removedElements.emit('remove');
          }
        } // the parents who were modified by the removal need their style updated


        for (let _i8 = 0; _i8 < alteredParents.length; _i8++) {
          const _ele6 = alteredParents[_i8];

          if (!removeFromPool || !_ele6.removed()) {
            _ele6.updateStyle();
          }
        }

        return removedElements;
      };

      elesfn$u.move = function (struct) {
        const cy = this._private.cy;
        const eles = this; // just clean up refs, caches, etc. in the same way as when removing and then restoring
  // (our calls to remove/restore do not remove from the graph or make events)

        const notifyRenderer = false;
        const modifyPool = false;

        const toString = function toString(id) {
          return id == null ? id : '' + id;
        }; // id must be string


        if (struct.source !== undefined || struct.target !== undefined) {
          const srcId = toString(struct.source);
          const tgtId = toString(struct.target);
          const srcExists = srcId != null && cy.hasElementWithId(srcId);
          const tgtExists = tgtId != null && cy.hasElementWithId(tgtId);

          if (srcExists || tgtExists) {
            cy.batch(function () {
        // avoid duplicate style updates
              eles.remove(notifyRenderer, modifyPool); // clean up refs etc.

              eles.emitAndNotify('moveout');

              for (let i = 0; i < eles.length; i++) {
                const ele = eles[i];
                const _data5 = ele._private.data;

                if (ele.isEdge()) {
                  if (srcExists) {
                    _data5.source = srcId;
                  }

                  if (tgtExists) {
                    _data5.target = tgtId;
                  }
                }
              }

              eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.
            });
            eles.emitAndNotify('move');
          }
        } else if (struct.parent !== undefined) {
    // move node to new parent
          const parentId = toString(struct.parent);
          const parentExists = parentId === null || cy.hasElementWithId(parentId);

          if (parentExists) {
            const pidToAssign = parentId === null ? undefined : parentId;
            cy.batch(function () {
        // avoid duplicate style updates
              const updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.

              updated.emitAndNotify('moveout');

              for (let i = 0; i < eles.length; i++) {
                const ele = eles[i];
                const _data6 = ele._private.data;

                if (ele.isNode()) {
                  _data6.parent = pidToAssign;
                }
              }

              updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.
            });
            eles.emitAndNotify('move');
          }
        }

        return this;
      };

      [elesfn$c, elesfn$d, elesfn$e, elesfn$f, elesfn$g, data$1, elesfn$i, dimensions, elesfn$m, elesfn$n, elesfn$o, elesfn$p, elesfn$q, elesfn$r, elesfn$s, elesfn$t].forEach(function (props) {
        extend(elesfn$u, props);
      });

      const corefn = {
        add: function add(opts) {
          let elements;
          const cy = this; // add the elements

          if (elementOrCollection(opts)) {
            const eles = opts;

            if (eles._private.cy === cy) {
        // same instance => just restore
              elements = eles.restore();
            } else {
        // otherwise, copy from json
              const jsons = [];

              for (let i = 0; i < eles.length; i++) {
                const ele = eles[i];
                jsons.push(ele.json());
              }

              elements = new Collection(cy, jsons);
            }
          } // specify an array of options
          else if (array(opts)) {
            const _jsons = opts;
            elements = new Collection(cy, _jsons);
          } // specify via opts.nodes and opts.edges
          else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {
            const elesByGroup = opts;
            const _jsons2 = [];
            const grs = ['nodes', 'edges'];

            for (let _i = 0, il = grs.length; _i < il; _i++) {
              const group = grs[_i];
              const elesArray = elesByGroup[group];

              if (array(elesArray)) {
                for (let j = 0, jl = elesArray.length; j < jl; j++) {
                  const json = extend({
                    group: group
                  }, elesArray[j]);

                  _jsons2.push(json);
                }
              }
            }

            elements = new Collection(cy, _jsons2);
          } // specify options for one element
          else {
            const _json = opts;
            elements = new Element(cy, _json).collection();
          }

          return elements;
        },
        remove: function remove(collection) {
          if (elementOrCollection(collection)) ; else if (string(collection)) {
            const selector = collection;
            collection = this.$(selector);
          }

          return collection.remove();
        }
      };

/* global Float32Array */

/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
      function generateCubicBezier(mX1, mY1, mX2, mY2) {
        const NEWTON_ITERATIONS = 4,
          NEWTON_MIN_SLOPE = 0.001,
          SUBDIVISION_PRECISION = 0.0000001,
          SUBDIVISION_MAX_ITERATIONS = 10,
          kSplineTableSize = 11,
          kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
          float32ArraySupported = typeof Float32Array !== 'undefined';
  /* Must contain four arguments. */

        if (arguments.length !== 4) {
          return false;
        }
  /* Arguments must be numbers. */


        for (let i = 0; i < 4; ++i) {
          if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
            return false;
          }
        }
  /* X values must be in the [0, 1] range. */


        mX1 = Math.min(mX1, 1);
        mX2 = Math.min(mX2, 1);
        mX1 = Math.max(mX1, 0);
        mX2 = Math.max(mX2, 0);
        const mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

        function A(aA1, aA2) {
          return 1.0 - 3.0 * aA2 + 3.0 * aA1;
        }

        function B(aA1, aA2) {
          return 3.0 * aA2 - 6.0 * aA1;
        }

        function C(aA1) {
          return 3.0 * aA1;
        }

        function calcBezier(aT, aA1, aA2) {
          return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
        }

        function getSlope(aT, aA1, aA2) {
          return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
        }

        function newtonRaphsonIterate(aX, aGuessT) {
          for (let _i = 0; _i < NEWTON_ITERATIONS; ++_i) {
            const currentSlope = getSlope(aGuessT, mX1, mX2);

            if (currentSlope === 0.0) {
              return aGuessT;
            }

            const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
          }

          return aGuessT;
        }

        function calcSampleValues() {
          for (let _i2 = 0; _i2 < kSplineTableSize; ++_i2) {
            mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);
          }
        }

        function binarySubdivide(aX, aA, aB) {
          let currentX,
            currentT,
            i = 0;

          do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;

            if (currentX > 0.0) {
              aB = currentT;
            } else {
              aA = currentT;
            }
          } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

          return currentT;
        }

        function getTForX(aX) {
          let intervalStart = 0.0,
            currentSample = 1,
            lastSample = kSplineTableSize - 1;

          for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }

          --currentSample;
          const dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),
            guessForT = intervalStart + dist * kSampleStepSize,
            initialSlope = getSlope(guessForT, mX1, mX2);

          if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT);
          } else if (initialSlope === 0.0) {
            return guessForT;
          } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
          }
        }

        let _precomputed = false;

        function precompute() {
          _precomputed = true;

          if (mX1 !== mY1 || mX2 !== mY2) {
            calcSampleValues();
          }
        }

        const f = function f(aX) {
          if (!_precomputed) {
            precompute();
          }

          if (mX1 === mY1 && mX2 === mY2) {
            return aX;
          }

          if (aX === 0) {
            return 0;
          }

          if (aX === 1) {
            return 1;
          }

          return calcBezier(getTForX(aX), mY1, mY2);
        };

        f.getControlPoints = function () {
          return [{
            x: mX1,
            y: mY1
          }, {
            x: mX2,
            y: mY2
          }];
        };

        const str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";

        f.toString = function () {
          return str;
        };

        return f;
      }

/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */

/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
      const generateSpringRK4 = function () {
        function springAccelerationForState(state) {
          return -state.tension * state.x - state.friction * state.v;
        }

        function springEvaluateStateWithDerivative(initialState, dt, derivative) {
          const state = {
            x: initialState.x + derivative.dx * dt,
            v: initialState.v + derivative.dv * dt,
            tension: initialState.tension,
            friction: initialState.friction
          };
          return {
            dx: state.v,
            dv: springAccelerationForState(state)
          };
        }

        function springIntegrateState(state, dt) {
          const a = {
              dx: state.v,
              dv: springAccelerationForState(state)
            },
            b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
            c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
            d = springEvaluateStateWithDerivative(state, dt, c),
            dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
            dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);
          state.x = state.x + dxdt * dt;
          state.v = state.v + dvdt * dt;
          return state;
        }

        return function springRK4Factory(tension, friction, duration) {
          let initState = {
              x: -1,
              v: 0,
              tension: null,
              friction: null
            },
            path = [0],
            time_lapsed = 0,
            tolerance = 1 / 10000,
            DT = 16 / 1000,
            have_duration,
            dt,
            last_state;
          tension = parseFloat(tension) || 500;
          friction = parseFloat(friction) || 20;
          duration = duration || null;
          initState.tension = tension;
          initState.friction = friction;
          have_duration = duration !== null;
    /* Calculate the actual time it takes for this animation to complete with the provided conditions. */

          if (have_duration) {
      /* Run the simulation without a duration. */
            time_lapsed = springRK4Factory(tension, friction);
      /* Compute the adjusted time delta. */

            dt = time_lapsed / duration * DT;
          } else {
            dt = DT;
          }

          for (;;) {
      /* Next/step function .*/
            last_state = springIntegrateState(last_state || initState, dt);
      /* Store the position. */

            path.push(1 + last_state.x);
            time_lapsed += 16;
      /* If the change threshold is reached, break. */

            if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
              break;
            }
          }
    /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
       computed path and returns a snapshot of the position according to a given percentComplete. */


          return !have_duration ? time_lapsed : function (percentComplete) {
            return path[percentComplete * (path.length - 1) | 0];
          };
        };
      }();

      const cubicBezier = function cubicBezier(t1, p1, t2, p2) {
        const bezier = generateCubicBezier(t1, p1, t2, p2);
        return function (start, end, percent) {
          return start + (end - start) * bezier(percent);
        };
      };

      var easings = {
        'linear': function linear(start, end, percent) {
          return start + (end - start) * percent;
        },
  // default easings
        'ease': cubicBezier(0.25, 0.1, 0.25, 1),
        'ease-in': cubicBezier(0.42, 0, 1, 1),
        'ease-out': cubicBezier(0, 0, 0.58, 1),
        'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),
  // sine
        'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),
        'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),
        'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),
  // quad
        'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),
        'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),
        'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),
  // cubic
        'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),
        'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),
        'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),
  // quart
        'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),
        'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),
        'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),
  // quint
        'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),
        'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),
        'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),
  // expo
        'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),
        'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),
        'ease-in-out-expo': cubicBezier(1, 0, 0, 1),
  // circ
        'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),
        'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),
        'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),
  // user param easings...
        'spring': function spring(tension, friction, duration) {
          if (duration === 0) {
      // can't get a spring w/ duration 0
            return easings.linear; // duration 0 => jump to end so impl doesn't matter
          }

          const spring = generateSpringRK4(tension, friction, duration);
          return function (start, end, percent) {
            return start + (end - start) * spring(percent);
          };
        },
        'cubic-bezier': cubicBezier
      };

      function getEasedValue(type, start, end, percent, easingFn) {
        if (percent === 1) {
          return end;
        }

        if (start === end) {
          return end;
        }

        let val = easingFn(start, end, percent);

        if (type == null) {
          return val;
        }

        if (type.roundValue || type.color) {
          val = Math.round(val);
        }

        if (type.min !== undefined) {
          val = Math.max(val, type.min);
        }

        if (type.max !== undefined) {
          val = Math.min(val, type.max);
        }

        return val;
      }

      function getValue(prop, spec) {
        if (prop.pfValue != null || prop.value != null) {
          if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {
            return prop.pfValue;
          } else {
            return prop.value;
          }
        } else {
          return prop;
        }
      }

      function ease(startProp, endProp, percent, easingFn, propSpec) {
        const type = propSpec != null ? propSpec.type : null;

        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        }

        const start = getValue(startProp, propSpec);
        const end = getValue(endProp, propSpec);

        if (number(start) && number(end)) {
          return getEasedValue(type, start, end, percent, easingFn);
        } else if (array(start) && array(end)) {
          const easedArr = [];

          for (let i = 0; i < end.length; i++) {
            const si = start[i];
            const ei = end[i];

            if (si != null && ei != null) {
              const val = getEasedValue(type, si, ei, percent, easingFn);
              easedArr.push(val);
            } else {
              easedArr.push(ei);
            }
          }

          return easedArr;
        }

        return undefined;
      }

      function step(self, ani, now, isCore) {
        const isEles = !isCore;
        const _p = self._private;
        const ani_p = ani._private;
        const pEasing = ani_p.easing;
        const startTime = ani_p.startTime;
        const cy = isCore ? self : self.cy();
        const style = cy.style();

        if (!ani_p.easingImpl) {
          if (pEasing == null) {
      // use default
            ani_p.easingImpl = easings['linear'];
          } else {
      // then define w/ name
            let easingVals;

            if (string(pEasing)) {
              const easingProp = style.parse('transition-timing-function', pEasing);
              easingVals = easingProp.value;
            } else {
        // then assume preparsed array
              easingVals = pEasing;
            }

            let name, args;

            if (string(easingVals)) {
              name = easingVals;
              args = [];
            } else {
              name = easingVals[1];
              args = easingVals.slice(2).map(function (n) {
                return +n;
              });
            }

            if (args.length > 0) {
        // create with args
              if (name === 'spring') {
                args.push(ani_p.duration); // need duration to generate spring
              }

              ani_p.easingImpl = easings[name].apply(null, args);
            } else {
        // static impl by name
              ani_p.easingImpl = easings[name];
            }
          }
        }

        const easing = ani_p.easingImpl;
        let percent;

        if (ani_p.duration === 0) {
          percent = 1;
        } else {
          percent = (now - startTime) / ani_p.duration;
        }

        if (ani_p.applying) {
          percent = ani_p.progress;
        }

        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        }

        if (ani_p.delay == null) {
    // then update
          const startPos = ani_p.startPosition;
          const endPos = ani_p.position;

          if (endPos && isEles && !self.locked()) {
            const newPos = {};

            if (valid(startPos.x, endPos.x)) {
              newPos.x = ease(startPos.x, endPos.x, percent, easing);
            }

            if (valid(startPos.y, endPos.y)) {
              newPos.y = ease(startPos.y, endPos.y, percent, easing);
            }

            self.position(newPos);
          }

          const startPan = ani_p.startPan;
          const endPan = ani_p.pan;
          const pan = _p.pan;
          const animatingPan = endPan != null && isCore;

          if (animatingPan) {
            if (valid(startPan.x, endPan.x)) {
              pan.x = ease(startPan.x, endPan.x, percent, easing);
            }

            if (valid(startPan.y, endPan.y)) {
              pan.y = ease(startPan.y, endPan.y, percent, easing);
            }

            self.emit('pan');
          }

          const startZoom = ani_p.startZoom;
          const endZoom = ani_p.zoom;
          const animatingZoom = endZoom != null && isCore;

          if (animatingZoom) {
            if (valid(startZoom, endZoom)) {
              _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);
            }

            self.emit('zoom');
          }

          if (animatingPan || animatingZoom) {
            self.emit('viewport');
          }

          const props = ani_p.style;

          if (props && props.length > 0 && isEles) {
            for (let i = 0; i < props.length; i++) {
              const prop = props[i];
              const _name = prop.name;
              const end = prop;
              const start = ani_p.startStyle[_name];
              const propSpec = style.properties[start.name];
              const easedVal = ease(start, end, percent, easing, propSpec);
              style.overrideBypass(self, _name, easedVal);
            } // for props


            self.emit('style');
          } // if

        }

        ani_p.progress = percent;
        return percent;
      }

      function valid(start, end) {
        if (start == null || end == null) {
          return false;
        }

        if (number(start) && number(end)) {
          return true;
        } else if (start && end) {
          return true;
        }

        return false;
      }

      function startAnimation(self, ani, now, isCore) {
        const ani_p = ani._private;
        ani_p.started = true;
        ani_p.startTime = now - ani_p.progress * ani_p.duration;
      }

      function stepAll(now, cy) {
        const eles = cy._private.aniEles;
        const doneEles = [];

        function stepOne(ele, isCore) {
          const _p = ele._private;
          const current = _p.animation.current;
          const queue = _p.animation.queue;
          let ranAnis = false; // if nothing currently animating, get something from the queue

          if (current.length === 0) {
            const next = queue.shift();

            if (next) {
              current.push(next);
            }
          }

          const callbacks = function callbacks(_callbacks) {
            for (let j = _callbacks.length - 1; j >= 0; j--) {
              const cb = _callbacks[j];
              cb();
            }

            _callbacks.splice(0, _callbacks.length);
          }; // step and remove if done


          for (let i = current.length - 1; i >= 0; i--) {
            const ani = current[i];
            const ani_p = ani._private;

            if (ani_p.stopped) {
              current.splice(i, 1);
              ani_p.hooked = false;
              ani_p.playing = false;
              ani_p.started = false;
              callbacks(ani_p.frames);
              continue;
            }

            if (!ani_p.playing && !ani_p.applying) {
              continue;
            } // an apply() while playing shouldn't do anything


            if (ani_p.playing && ani_p.applying) {
              ani_p.applying = false;
            }

            if (!ani_p.started) {
              startAnimation(ele, ani, now);
            }

            step(ele, ani, now, isCore);

            if (ani_p.applying) {
              ani_p.applying = false;
            }

            callbacks(ani_p.frames);

            if (ani_p.step != null) {
              ani_p.step(now);
            }

            if (ani.completed()) {
              current.splice(i, 1);
              ani_p.hooked = false;
              ani_p.playing = false;
              ani_p.started = false;
              callbacks(ani_p.completes);
            }

            ranAnis = true;
          }

          if (!isCore && current.length === 0 && queue.length === 0) {
            doneEles.push(ele);
          }

          return ranAnis;
        } // stepElement
  // handle all eles


        let ranEleAni = false;

        for (let e = 0; e < eles.length; e++) {
          const ele = eles[e];
          const handledThisEle = stepOne(ele);
          ranEleAni = ranEleAni || handledThisEle;
        } // each element


        const ranCoreAni = stepOne(cy, true); // notify renderer

        if (ranEleAni || ranCoreAni) {
          if (eles.length > 0) {
            cy.notify('draw', eles);
          } else {
            cy.notify('draw');
          }
        } // remove elements from list of currently animating if its queues are empty


        eles.unmerge(doneEles);
        cy.emit('step');
      } // stepAll

      const corefn$1 = {
  // pull in animation functions
        animate: define$3.animate(),
        animation: define$3.animation(),
        animated: define$3.animated(),
        clearQueue: define$3.clearQueue(),
        delay: define$3.delay(),
        delayAnimation: define$3.delayAnimation(),
        stop: define$3.stop(),
        addToAnimationPool: function addToAnimationPool(eles) {
          const cy = this;

          if (!cy.styleEnabled()) {
            return;
          } // save cycles when no style used


          cy._private.aniEles.merge(eles);
        },
        stopAnimationLoop: function stopAnimationLoop() {
          this._private.animationsRunning = false;
        },
        startAnimationLoop: function startAnimationLoop() {
          const cy = this;
          cy._private.animationsRunning = true;

          if (!cy.styleEnabled()) {
            return;
          } // save cycles when no style used
    // NB the animation loop will exec in headless environments if style enabled
    // and explicit cy.destroy() is necessary to stop the loop


          function headlessStep() {
            if (!cy._private.animationsRunning) {
              return;
            }

            requestAnimationFrame(function animationStep(now) {
              stepAll(now, cy);
              headlessStep();
            });
          }

          const renderer = cy.renderer();

          if (renderer && renderer.beforeRender) {
      // let the renderer schedule animations
            renderer.beforeRender(function rendererAnimationStep(willDraw, now) {
              stepAll(now, cy);
            }, renderer.beforeRenderPriorities.animations);
          } else {
      // manage the animation loop ourselves
            headlessStep(); // first call
          }
        }
      };

      const emitterOptions$1 = {
        qualifierCompare: function qualifierCompare(selector1, selector2) {
          if (selector1 == null || selector2 == null) {
            return selector1 == null && selector2 == null;
          } else {
            return selector1.sameText(selector2);
          }
        },
        eventMatches: function eventMatches(cy, listener, eventObj) {
          const selector = listener.qualifier;

          if (selector != null) {
            return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
          }

          return true;
        },
        addEventFields: function addEventFields(cy, evt) {
          evt.cy = cy;
          evt.target = cy;
        },
        callbackContext: function callbackContext(cy, listener, eventObj) {
          return listener.qualifier != null ? eventObj.target : cy;
        }
      };

      const argSelector$1 = function argSelector(arg) {
        if (string(arg)) {
          return new Selector(arg);
        } else {
          return arg;
        }
      };

      const elesfn$v = {
        createEmitter: function createEmitter() {
          const _p = this._private;

          if (!_p.emitter) {
            _p.emitter = new Emitter(emitterOptions$1, this);
          }

          return this;
        },
        emitter: function emitter() {
          return this._private.emitter;
        },
        on: function on(events, selector, callback) {
          this.emitter().on(events, argSelector$1(selector), callback);
          return this;
        },
        removeListener: function removeListener(events, selector, callback) {
          this.emitter().removeListener(events, argSelector$1(selector), callback);
          return this;
        },
        removeAllListeners: function removeAllListeners() {
          this.emitter().removeAllListeners();
          return this;
        },
        one: function one(events, selector, callback) {
          this.emitter().one(events, argSelector$1(selector), callback);
          return this;
        },
        once: function once(events, selector, callback) {
          this.emitter().one(events, argSelector$1(selector), callback);
          return this;
        },
        emit: function emit(events, extraParams) {
          this.emitter().emit(events, extraParams);
          return this;
        },
        emitAndNotify: function emitAndNotify(event, eles) {
          this.emit(event);
          this.notify(event, eles);
          return this;
        }
      };
      define$3.eventAliasesOn(elesfn$v);

      const corefn$2 = {
        png: function png(options) {
          const renderer = this._private.renderer;
          options = options || {};
          return renderer.png(options);
        },
        jpg: function jpg(options) {
          const renderer = this._private.renderer;
          options = options || {};
          options.bg = options.bg || '#fff';
          return renderer.jpg(options);
        }
      };
      corefn$2.jpeg = corefn$2.jpg;

      const corefn$3 = {
        layout: function layout(options) {
          const cy = this;

          if (options == null) {
            error('Layout options must be specified to make a layout');
            return;
          }

          if (options.name == null) {
            error('A `name` must be specified to make a layout');
            return;
          }

          const name = options.name;
          const Layout = cy.extension('layout', name);

          if (Layout == null) {
            error('No such layout `' + name + '` found.  Did you forget to import it and `cytoscape.use()` it?');
            return;
          }

          let eles;

          if (string(options.eles)) {
            eles = cy.$(options.eles);
          } else {
            eles = options.eles != null ? options.eles : cy.$();
          }

          const layout = new Layout(extend({}, options, {
            cy: cy,
            eles: eles
          }));
          return layout;
        }
      };
      corefn$3.createLayout = corefn$3.makeLayout = corefn$3.layout;

      const corefn$4 = {
        notify: function notify(eventName, eventEles) {
          const _p = this._private;

          if (this.batching()) {
            _p.batchNotifications = _p.batchNotifications || {};
            const eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();

            if (eventEles != null) {
              eles.merge(eventEles);
            }

            return; // notifications are disabled during batching
          }

          if (!_p.notificationsEnabled) {
            return;
          } // exit on disabled


          const renderer = this.renderer(); // exit if destroy() called on core or renderer in between frames #1499 #1528

          if (this.destroyed() || !renderer) {
            return;
          }

          renderer.notify(eventName, eventEles);
        },
        notifications: function notifications(bool) {
          const p = this._private;

          if (bool === undefined) {
            return p.notificationsEnabled;
          } else {
            p.notificationsEnabled = bool ? true : false;
          }

          return this;
        },
        noNotifications: function noNotifications(callback) {
          this.notifications(false);
          callback();
          this.notifications(true);
        },
        batching: function batching() {
          return this._private.batchCount > 0;
        },
        startBatch: function startBatch() {
          const _p = this._private;

          if (_p.batchCount == null) {
            _p.batchCount = 0;
          }

          if (_p.batchCount === 0) {
            _p.batchStyleEles = this.collection();
            _p.batchNotifications = {};
          }

          _p.batchCount++;
          return this;
        },
        endBatch: function endBatch() {
          const _p = this._private;

          if (_p.batchCount === 0) {
            return this;
          }

          _p.batchCount--;

          if (_p.batchCount === 0) {
      // update style for dirty eles
            _p.batchStyleEles.updateStyle();

            const renderer = this.renderer(); // notify the renderer of queued eles and event types

            Object.keys(_p.batchNotifications).forEach(function (eventName) {
              const eles = _p.batchNotifications[eventName];

              if (eles.empty()) {
                renderer.notify(eventName);
              } else {
                renderer.notify(eventName, eles);
              }
            });
          }

          return this;
        },
        batch: function batch(callback) {
          this.startBatch();
          callback();
          this.endBatch();
          return this;
        },
  // for backwards compatibility
        batchData: function batchData(map) {
          const cy = this;
          return this.batch(function () {
            const ids = Object.keys(map);

            for (let i = 0; i < ids.length; i++) {
              const id = ids[i];
              const data = map[id];
              const ele = cy.getElementById(id);
              ele.data(data);
            }
          });
        }
      };

      const rendererDefaults = defaults({
        hideEdgesOnViewport: false,
        textureOnViewport: false,
        motionBlur: false,
        motionBlurOpacity: 0.05,
        pixelRatio: undefined,
        desktopTapThreshold: 4,
        touchTapThreshold: 8,
        wheelSensitivity: 1,
        debug: false,
        showFps: false
      });
      const corefn$5 = {
        renderTo: function renderTo(context, zoom, pan, pxRatio) {
          const r = this._private.renderer;
          r.renderTo(context, zoom, pan, pxRatio);
          return this;
        },
        renderer: function renderer() {
          return this._private.renderer;
        },
        forceRender: function forceRender() {
          this.notify('draw');
          return this;
        },
        resize: function resize() {
          this.invalidateSize();
          this.emitAndNotify('resize');
          return this;
        },
        initRenderer: function initRenderer(options) {
          const cy = this;
          const RendererProto = cy.extension('renderer', options.name);

          if (RendererProto == null) {
            error("Can not initialise: No such renderer `".concat(options.name, "` found. Did you forget to import it and `cytoscape.use()` it?"));
            return;
          }

          if (options.wheelSensitivity !== undefined) {
            warn("You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.");
          }

          const rOpts = rendererDefaults(options);
          rOpts.cy = cy;
          cy._private.renderer = new RendererProto(rOpts);
          this.notify('init');
        },
        destroyRenderer: function destroyRenderer() {
          const cy = this;
          cy.notify('destroy'); // destroy the renderer

          const domEle = cy.container();

          if (domEle) {
            domEle._cyreg = null;

            while (domEle.childNodes.length > 0) {
              domEle.removeChild(domEle.childNodes[0]);
            }
          }

          cy._private.renderer = null; // to be extra safe, remove the ref

          cy.mutableElements().forEach(function (ele) {
            const _p = ele._private;
            _p.rscratch = {};
            _p.rstyle = {};
            _p.animation.current = [];
            _p.animation.queue = [];
          });
        },
        onRender: function onRender(fn) {
          return this.on('render', fn);
        },
        offRender: function offRender(fn) {
          return this.off('render', fn);
        }
      };
      corefn$5.invalidateDimensions = corefn$5.resize;

      const corefn$6 = {
  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
        collection: function collection(eles, opts) {
          if (string(eles)) {
            return this.$(eles);
          } else if (elementOrCollection(eles)) {
            return eles.collection();
          } else if (array(eles)) {
            return new Collection(this, eles, opts);
          }

          return new Collection(this);
        },
        nodes: function nodes(selector) {
          const nodes = this.$(function (ele) {
            return ele.isNode();
          });

          if (selector) {
            return nodes.filter(selector);
          }

          return nodes;
        },
        edges: function edges(selector) {
          const edges = this.$(function (ele) {
            return ele.isEdge();
          });

          if (selector) {
            return edges.filter(selector);
          }

          return edges;
        },
  // search the graph like jQuery
        $: function $(selector) {
          const eles = this._private.elements;

          if (selector) {
            return eles.filter(selector);
          } else {
            return eles.spawnSelf();
          }
        },
        mutableElements: function mutableElements() {
          return this._private.elements;
        }
      }; // aliases

      corefn$6.elements = corefn$6.filter = corefn$6.$;

      const styfn = {}; // keys for style blocks, e.g. ttfftt

      const TRUE = 't';
      const FALSE = 'f'; // (potentially expensive calculation)
// apply the style to the element based on
// - its bypass
// - what selectors match it

      styfn.apply = function (eles) {
        const self = this;
        const _p = self._private;
        const cy = _p.cy;
        const updatedEles = cy.collection();

        for (let ie = 0; ie < eles.length; ie++) {
          const ele = eles[ie];
          const cxtMeta = self.getContextMeta(ele);

          if (cxtMeta.empty) {
            continue;
          }

          const cxtStyle = self.getContextStyle(cxtMeta);
          const app = self.applyContextStyle(cxtMeta, cxtStyle, ele);

          if (ele._private.appliedInitStyle) {
            self.updateTransitions(ele, app.diffProps);
          } else {
            ele._private.appliedInitStyle = true;
          }

          const hintsDiff = self.updateStyleHints(ele);

          if (hintsDiff) {
            updatedEles.push(ele);
          }
        } // for elements


        return updatedEles;
      };

      styfn.getPropertiesDiff = function (oldCxtKey, newCxtKey) {
        const self = this;
        const cache = self._private.propDiffs = self._private.propDiffs || {};
        const dualCxtKey = oldCxtKey + '-' + newCxtKey;
        const cachedVal = cache[dualCxtKey];

        if (cachedVal) {
          return cachedVal;
        }

        const diffProps = [];
        const addedProp = {};

        for (let i = 0; i < self.length; i++) {
          const cxt = self[i];
          const oldHasCxt = oldCxtKey[i] === TRUE;
          const newHasCxt = newCxtKey[i] === TRUE;
          const cxtHasDiffed = oldHasCxt !== newHasCxt;
          const cxtHasMappedProps = cxt.mappedProperties.length > 0;

          if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {
            let props = void 0;

            if (cxtHasDiffed && cxtHasMappedProps) {
              props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
            } else if (cxtHasDiffed) {
              props = cxt.properties; // need to check them all
            } else if (cxtHasMappedProps) {
              props = cxt.mappedProperties; // only need to check mapped
            }

            for (let j = 0; j < props.length; j++) {
              const prop = props[j];
              const name = prop.name; // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
        // is cached)

              let laterCxtOverrides = false;

              for (let k = i + 1; k < self.length; k++) {
                const laterCxt = self[k];
                const hasLaterCxt = newCxtKey[k] === TRUE;

                if (!hasLaterCxt) {
                  continue;
                } // can't override unless the context is active


                laterCxtOverrides = laterCxt.properties[prop.name] != null;

                if (laterCxtOverrides) {
                  break;
                } // exit early as long as one later context overrides

              }

              if (!addedProp[name] && !laterCxtOverrides) {
                addedProp[name] = true;
                diffProps.push(name);
              }
            } // for props

          } // if

        } // for contexts


        cache[dualCxtKey] = diffProps;
        return diffProps;
      };

      styfn.getContextMeta = function (ele) {
        const self = this;
        let cxtKey = '';
        let diffProps;
        const prevKey = ele._private.styleCxtKey || ''; // get the cxt key

        for (let i = 0; i < self.length; i++) {
          const context = self[i];
          const contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'

          if (contextSelectorMatches) {
            cxtKey += TRUE;
          } else {
            cxtKey += FALSE;
          }
        } // for context


        diffProps = self.getPropertiesDiff(prevKey, cxtKey);
        ele._private.styleCxtKey = cxtKey;
        return {
          key: cxtKey,
          diffPropNames: diffProps,
          empty: diffProps.length === 0
        };
      }; // gets a computed ele style object based on matched contexts


      styfn.getContextStyle = function (cxtMeta) {
        const cxtKey = cxtMeta.key;
        const self = this;
        const cxtStyles = this._private.contextStyles = this._private.contextStyles || {}; // if already computed style, returned cached copy

        if (cxtStyles[cxtKey]) {
          return cxtStyles[cxtKey];
        }

        const style = {
          _private: {
            key: cxtKey
          }
        };

        for (let i = 0; i < self.length; i++) {
          const cxt = self[i];
          const hasCxt = cxtKey[i] === TRUE;

          if (!hasCxt) {
            continue;
          }

          for (let j = 0; j < cxt.properties.length; j++) {
            const prop = cxt.properties[j];
            style[prop.name] = prop;
          }
        }

        cxtStyles[cxtKey] = style;
        return style;
      };

      styfn.applyContextStyle = function (cxtMeta, cxtStyle, ele) {
        const self = this;
        const diffProps = cxtMeta.diffPropNames;
        const retDiffProps = {};
        const types = self.types;

        for (let i = 0; i < diffProps.length; i++) {
          const diffPropName = diffProps[i];
          let cxtProp = cxtStyle[diffPropName];
          const eleProp = ele.pstyle(diffPropName);

          if (!cxtProp) {
      // no context prop means delete
            if (!eleProp) {
              continue; // no existing prop means nothing needs to be removed
        // nb affects initial application on mapped values like control-point-distances
            } else if (eleProp.bypass) {
              cxtProp = {
                name: diffPropName,
                deleteBypassed: true
              };
            } else {
              cxtProp = {
                name: diffPropName,
                "delete": true
              };
            }
          } // save cycles when the context prop doesn't need to be applied


          if (eleProp === cxtProp) {
            continue;
          } // save cycles when a mapped context prop doesn't need to be applied


          if (cxtProp.mapped === types.fn // context prop is function mapper
    && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)
    && eleProp.mapping != null // ele prop is a concrete value from from a mapper
    && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper
          ) {
        // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)
            const mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy

            const fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss

            if (fnValue === mapping.prevFnValue) {
              continue;
            }
          }

          const retDiffProp = retDiffProps[diffPropName] = {
            prev: eleProp
          };
          self.applyParsedProperty(ele, cxtProp);
          retDiffProp.next = ele.pstyle(diffPropName);

          if (retDiffProp.next && retDiffProp.next.bypass) {
            retDiffProp.next = retDiffProp.next.bypassed;
          }
        }

        return {
          diffProps: retDiffProps
        };
      };

      styfn.updateStyleHints = function (ele) {
        const _p = ele._private;
        const self = this;
        let propNames = self.propertyGroupNames;
        const propGrKeys = self.propertyGroupKeys;

        const propHash = function propHash(ele, propNames, seedKey) {
          return self.getPropertiesHash(ele, propNames, seedKey);
        };

        const oldStyleKey = _p.styleKey;

        if (ele.removed()) {
          return false;
        }

        const isNode = _p.group === 'nodes'; // get the style key hashes per prop group
  // but lazily -- only use non-default prop values to reduce the number of hashes
  //

        const overriddenStyles = ele._private.style;
        propNames = Object.keys(overriddenStyles);

        for (let i = 0; i < propGrKeys.length; i++) {
          const grKey = propGrKeys[i];
          _p.styleKeys[grKey] = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];
        }

        const updateGrKey1 = function updateGrKey1(val, grKey) {
          return _p.styleKeys[grKey][0] = hashInt(val, _p.styleKeys[grKey][0]);
        };

        const updateGrKey2 = function updateGrKey2(val, grKey) {
          return _p.styleKeys[grKey][1] = hashIntAlt(val, _p.styleKeys[grKey][1]);
        };

        const updateGrKey = function updateGrKey(val, grKey) {
          updateGrKey1(val, grKey);
          updateGrKey2(val, grKey);
        };

        const updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {
          for (let j = 0; j < strVal.length; j++) {
            const ch = strVal.charCodeAt(j);
            updateGrKey1(ch, grKey);
            updateGrKey2(ch, grKey);
          }
        }; // - hashing works on 32 bit ints b/c we use bitwise ops
  // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)
  // - raise up small numbers so more significant digits are seen by hashing
  // - make small numbers larger than a normal value to avoid collisions
  // - works in practice and it's relatively cheap


        const N = 2000000000;

        const cleanNum = function cleanNum(val) {
          return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;
        };

        for (let _i = 0; _i < propNames.length; _i++) {
          const name = propNames[_i];
          const parsedProp = overriddenStyles[name];

          if (parsedProp == null) {
            continue;
          }

          const propInfo = this.properties[name];
          const type = propInfo.type;
          const _grKey = propInfo.groupKey;
          let normalizedNumberVal = void 0;

          if (propInfo.hashOverride != null) {
            normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);
          } else if (parsedProp.pfValue != null) {
            normalizedNumberVal = parsedProp.pfValue;
          } // might not be a number if it allows enums


          const numberVal = propInfo.enums == null ? parsedProp.value : null;
          const haveNormNum = normalizedNumberVal != null;
          const haveUnitedNum = numberVal != null;
          const haveNum = haveNormNum || haveUnitedNum;
          const units = parsedProp.units; // numbers are cheaper to hash than strings
    // 1 hash op vs n hash ops (for length n string)

          if (type.number && haveNum && !type.multiple) {
            const v = haveNormNum ? normalizedNumberVal : numberVal;
            updateGrKey(cleanNum(v), _grKey);

            if (!haveNormNum && units != null) {
              updateGrKeyWStr(units, _grKey);
            }
          } else {
            updateGrKeyWStr(parsedProp.strValue, _grKey);
          }
        } // overall style key
  //


        const hash = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];

        for (let _i2 = 0; _i2 < propGrKeys.length; _i2++) {
          const _grKey2 = propGrKeys[_i2];
          const grHash = _p.styleKeys[_grKey2];
          hash[0] = hashInt(grHash[0], hash[0]);
          hash[1] = hashIntAlt(grHash[1], hash[1]);
        }

        _p.styleKey = combineHashes(hash[0], hash[1]); // label dims
  //

        const sk = _p.styleKeys;
        _p.labelDimsKey = combineHashesArray(sk.labelDimensions);
        const labelKeys = propHash(ele, ['label'], sk.labelDimensions);
        _p.labelKey = combineHashesArray(labelKeys);
        _p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));

        if (!isNode) {
          const sourceLabelKeys = propHash(ele, ['source-label'], sk.labelDimensions);
          _p.sourceLabelKey = combineHashesArray(sourceLabelKeys);
          _p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));
          const targetLabelKeys = propHash(ele, ['target-label'], sk.labelDimensions);
          _p.targetLabelKey = combineHashesArray(targetLabelKeys);
          _p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));
        } // node
  //


        if (isNode) {
          const _p$styleKeys = _p.styleKeys,
            nodeBody = _p$styleKeys.nodeBody,
            nodeBorder = _p$styleKeys.nodeBorder,
            backgroundImage = _p$styleKeys.backgroundImage,
            compound = _p$styleKeys.compound,
            pie = _p$styleKeys.pie;
          const nodeKeys = [nodeBody, nodeBorder, backgroundImage, compound, pie].filter(function (k) {
            return k != null;
          }).reduce(hashArrays, [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT]);
          _p.nodeKey = combineHashesArray(nodeKeys);
          _p.hasPie = pie != null && pie[0] !== DEFAULT_HASH_SEED && pie[1] !== DEFAULT_HASH_SEED_ALT;
        }

        return oldStyleKey !== _p.styleKey;
      };

      styfn.clearStyleHints = function (ele) {
        const _p = ele._private;
        _p.styleCxtKey = '';
        _p.styleKeys = {};
        _p.styleKey = null;
        _p.labelKey = null;
        _p.labelStyleKey = null;
        _p.sourceLabelKey = null;
        _p.sourceLabelStyleKey = null;
        _p.targetLabelKey = null;
        _p.targetLabelStyleKey = null;
        _p.nodeKey = null;
        _p.hasPie = null;
      }; // apply a property to the style (for internal use)
// returns whether application was successful
//
// now, this function flattens the property, and here's how:
//
// for parsedProp:{ bypass: true, deleteBypass: true }
// no property is generated, instead the bypass property in the
// element's style is replaced by what's pointed to by the `bypassed`
// field in the bypass property (i.e. restoring the property the
// bypass was overriding)
//
// for parsedProp:{ mapped: truthy }
// the generated flattenedProp:{ mapping: prop }
//
// for parsedProp:{ bypass: true }
// the generated flattenedProp:{ bypassed: parsedProp }


      styfn.applyParsedProperty = function (ele, parsedProp) {
        const self = this;
        let prop = parsedProp;
        const style = ele._private.style;
        let flatProp;
        const types = self.types;
        const type = self.properties[prop.name].type;
        const propIsBypass = prop.bypass;
        const origProp = style[prop.name];
        const origPropIsBypass = origProp && origProp.bypass;
        const _p = ele._private;
        const flatPropMapping = 'mapping';

        const getVal = function getVal(p) {
          if (p == null) {
            return null;
          } else if (p.pfValue != null) {
            return p.pfValue;
          } else {
            return p.value;
          }
        };

        const checkTriggers = function checkTriggers() {
          const fromVal = getVal(origProp);
          const toVal = getVal(prop);
          self.checkTriggers(ele, prop.name, fromVal, toVal);
        };

        if (prop && prop.name.substr(0, 3) === 'pie') {
          warn('The pie style properties are deprecated.  Create charts using background images instead.');
        } // edge sanity checks to prevent the client from making serious mistakes


        if (parsedProp.name === 'curve-style' && ele.isEdge() && ( // loops must be bundled beziers
          parsedProp.value !== 'bezier' && ele.isLoop() || // edges connected to compound nodes can not be haystacks
  parsedProp.value === 'haystack' && (ele.source().isParent() || ele.target().isParent()))) {
          prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);
        }

        if (prop["delete"]) {
    // delete the property and use the default value on falsey value
          style[prop.name] = undefined;
          checkTriggers();
          return true;
        }

        if (prop.deleteBypassed) {
    // delete the property that the
          if (!origProp) {
            checkTriggers();
            return true; // can't delete if no prop
          } else if (origProp.bypass) {
      // delete bypassed
            origProp.bypassed = undefined;
            checkTriggers();
            return true;
          } else {
            return false; // we're unsuccessful deleting the bypassed
          }
        } // check if we need to delete the current bypass


        if (prop.deleteBypass) {
    // then this property is just here to indicate we need to delete
          if (!origProp) {
            checkTriggers();
            return true; // property is already not defined
          } else if (origProp.bypass) {
      // then replace the bypass property with the original
      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
            style[prop.name] = origProp.bypassed;
            checkTriggers();
            return true;
          } else {
            return false; // we're unsuccessful deleting the bypass
          }
        }

        const printMappingErr = function printMappingErr() {
          warn('Do not assign mappings to elements without corresponding data (i.e. ele `' + ele.id() + '` has no mapping for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');
        }; // put the property in the style objects


        switch (prop.mapped) {
    // flatten the property if mapped
          case types.mapData:
          {
        // flatten the field (e.g. data.foo.bar)
            const fields = prop.field.split('.');
            let fieldVal = _p.data;

            for (let i = 0; i < fields.length && fieldVal; i++) {
              const field = fields[i];
              fieldVal = fieldVal[field];
            }

            if (fieldVal == null) {
              printMappingErr();
              return false;
            }

            let percent;

            if (!number(fieldVal)) {
          // then don't apply and fall back on the existing style
              warn('Do not use continuous mappers without specifying numeric data (i.e. `' + prop.field + ': ' + fieldVal + '` for `' + ele.id() + '` is non-numeric)');
              return false;
            } else {
              const fieldWidth = prop.fieldMax - prop.fieldMin;

              if (fieldWidth === 0) {
            // safety check -- not strictly necessary as no props of zero range should be passed here
                percent = 0;
              } else {
                percent = (fieldVal - prop.fieldMin) / fieldWidth;
              }
            } // make sure to bound percent value


            if (percent < 0) {
              percent = 0;
            } else if (percent > 1) {
              percent = 1;
            }

            if (type.color) {
              const r1 = prop.valueMin[0];
              const r2 = prop.valueMax[0];
              const g1 = prop.valueMin[1];
              const g2 = prop.valueMax[1];
              const b1 = prop.valueMin[2];
              const b2 = prop.valueMax[2];
              const a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
              const a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];
              const clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];
              flatProp = {
            // colours are simple, so just create the flat property instead of expensive string parsing
                bypass: prop.bypass,
            // we're a bypass if the mapping property is a bypass
                name: prop.name,
                value: clr,
                strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
              };
            } else if (type.number) {
              const calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
              flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);
            } else {
              return false; // can only map to colours and numbers
            }

            if (!flatProp) {
          // if we can't flatten the property, then don't apply the property and fall back on the existing style
              printMappingErr();
              return false;
            }

            flatProp.mapping = prop; // keep a reference to the mapping

            prop = flatProp; // the flattened (mapped) property is the one we want

            break;
          }
    // direct mapping

          case types.data:
          {
        // flatten the field (e.g. data.foo.bar)
            const _fields = prop.field.split('.');

            let _fieldVal = _p.data;

            for (let _i3 = 0; _i3 < _fields.length && _fieldVal; _i3++) {
              const _field = _fields[_i3];
              _fieldVal = _fieldVal[_field];
            }

            if (_fieldVal != null) {
              flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);
            }

            if (!flatProp) {
          // if we can't flatten the property, then don't apply and fall back on the existing style
              printMappingErr();
              return false;
            }

            flatProp.mapping = prop; // keep a reference to the mapping

            prop = flatProp; // the flattened (mapped) property is the one we want

            break;
          }

          case types.fn:
          {
            const fn = prop.value;
            const fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function

            prop.prevFnValue = fnRetVal;

            if (fnRetVal == null) {
              warn('Custom function mappers may not return null (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is null)');
              return false;
            }

            flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);

            if (!flatProp) {
              warn('Custom function mappers may not return invalid values for the property type (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is invalid)');
              return false;
            }

            flatProp.mapping = copy(prop); // keep a reference to the mapping

            prop = flatProp; // the flattened (mapped) property is the one we want

            break;
          }

          case undefined:
            break;
    // just set the property

          default:
            return false;
    // not a valid mapping
        } // if the property is a bypass property, then link the resultant property to the original one


        if (propIsBypass) {
          if (origPropIsBypass) {
      // then this bypass overrides the existing one
            prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
          } else {
      // then link the orig prop to the new bypass
            prop.bypassed = origProp;
          }

          style[prop.name] = prop; // and set
        } else {
    // prop is not bypass
          if (origPropIsBypass) {
      // then keep the orig prop (since it's a bypass) and link to the new prop
            origProp.bypassed = prop;
          } else {
      // then just replace the old prop with the new one
            style[prop.name] = prop;
          }
        }

        checkTriggers();
        return true;
      };

      styfn.cleanElements = function (eles, keepBypasses) {
        for (let i = 0; i < eles.length; i++) {
          const ele = eles[i];
          this.clearStyleHints(ele);
          ele.dirtyCompoundBoundsCache();
          ele.dirtyBoundingBoxCache();

          if (!keepBypasses) {
            ele._private.style = {};
          } else {
            const style = ele._private.style;
            const propNames = Object.keys(style);

            for (let j = 0; j < propNames.length; j++) {
              const propName = propNames[j];
              const eleProp = style[propName];

              if (eleProp != null) {
                if (eleProp.bypass) {
                  eleProp.bypassed = null;
                } else {
                  style[propName] = null;
                }
              }
            }
          }
        }
      }; // updates the visual style for all elements (useful for manual style modification after init)


      styfn.update = function () {
        const cy = this._private.cy;
        const eles = cy.mutableElements();
        eles.updateStyle();
      }; // diffProps : { name => { prev, next } }


      styfn.updateTransitions = function (ele, diffProps) {
        const self = this;
        const _p = ele._private;
        const props = ele.pstyle('transition-property').value;
        const duration = ele.pstyle('transition-duration').pfValue;
        const delay = ele.pstyle('transition-delay').pfValue;

        if (props.length > 0 && duration > 0) {
          const style = {}; // build up the style to animate towards

          let anyPrev = false;

          for (let i = 0; i < props.length; i++) {
            const prop = props[i];
            const styProp = ele.pstyle(prop);
            const diffProp = diffProps[prop];

            if (!diffProp) {
              continue;
            }

            const prevProp = diffProp.prev;
            const fromProp = prevProp;
            const toProp = diffProp.next != null ? diffProp.next : styProp;
            let diff = false;
            let initVal = void 0;
            const initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)

            if (!fromProp) {
              continue;
            } // consider px values


            if (number(fromProp.pfValue) && number(toProp.pfValue)) {
              diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy

              initVal = fromProp.pfValue + initDt * diff; // consider numerical values
            } else if (number(fromProp.value) && number(toProp.value)) {
              diff = toProp.value - fromProp.value; // nonzero is truthy

              initVal = fromProp.value + initDt * diff; // consider colour values
            } else if (array(fromProp.value) && array(toProp.value)) {
              diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];
              initVal = fromProp.strValue;
            } // the previous value is good for an animation only if it's different


            if (diff) {
              style[prop] = toProp.strValue; // to val

              this.applyBypass(ele, prop, initVal); // from val

              anyPrev = true;
            }
          } // end if props allow ani
    // can't transition if there's nothing previous to transition from


          if (!anyPrev) {
            return;
          }

          _p.transitioning = true;
          new Promise$1(function (resolve) {
            if (delay > 0) {
              ele.delayAnimation(delay).play().promise().then(resolve);
            } else {
              resolve();
            }
          }).then(function () {
            return ele.animation({
              style: style,
              duration: duration,
              easing: ele.pstyle('transition-timing-function').value,
              queue: false
            }).play().promise();
          }).then(function () {
      // if( !isBypass ){
            self.removeBypasses(ele, props);
            ele.emitAndNotify('style'); // }

            _p.transitioning = false;
          });
        } else if (_p.transitioning) {
          this.removeBypasses(ele, props);
          ele.emitAndNotify('style');
          _p.transitioning = false;
        }
      };

      styfn.checkTrigger = function (ele, name, fromValue, toValue, getTrigger, onTrigger) {
        const prop = this.properties[name];
        const triggerCheck = getTrigger(prop);

        if (triggerCheck != null && triggerCheck(fromValue, toValue)) {
          onTrigger(prop);
        }
      };

      styfn.checkZOrderTrigger = function (ele, name, fromValue, toValue) {
        const _this = this;

        this.checkTrigger(ele, name, fromValue, toValue, function (prop) {
          return prop.triggersZOrder;
        }, function () {
          _this._private.cy.notify('zorder', ele);
        });
      };

      styfn.checkBoundsTrigger = function (ele, name, fromValue, toValue) {
        this.checkTrigger(ele, name, fromValue, toValue, function (prop) {
          return prop.triggersBounds;
        }, function (prop) {
          ele.dirtyCompoundBoundsCache();
          ele.dirtyBoundingBoxCache(); // if the prop change makes the bb of pll bezier edges invalid,
    // then dirty the pll edge bb cache as well

          if ( // only for beziers -- so performance of other edges isn't affected
            name === 'curve-style' && (fromValue === 'bezier' || toValue === 'bezier') && prop.triggersBoundsOfParallelBeziers) {
            ele.parallelEdges().forEach(function (pllEdge) {
              if (pllEdge.isBundledBezier()) {
                pllEdge.dirtyBoundingBoxCache();
              }
            });
          }
        });
      };

      styfn.checkTriggers = function (ele, name, fromValue, toValue) {
        ele.dirtyStyleCache();
        this.checkZOrderTrigger(ele, name, fromValue, toValue);
        this.checkBoundsTrigger(ele, name, fromValue, toValue);
      };

      const styfn$1 = {}; // bypasses are applied to an existing style on an element, and just tacked on temporarily
// returns true iff application was successful for at least 1 specified property

      styfn$1.applyBypass = function (eles, name, value, updateTransitions) {
        const self = this;
        const props = [];
        const isBypass = true; // put all the properties (can specify one or many) in an array after parsing them

        if (name === '*' || name === '**') {
    // apply to all property names
          if (value !== undefined) {
            for (let i = 0; i < self.properties.length; i++) {
              const prop = self.properties[i];
              const _name = prop.name;
              const parsedProp = this.parse(_name, value, true);

              if (parsedProp) {
                props.push(parsedProp);
              }
            }
          }
        } else if (string(name)) {
    // then parse the single property
          const _parsedProp = this.parse(name, value, true);

          if (_parsedProp) {
            props.push(_parsedProp);
          }
        } else if (plainObject(name)) {
    // then parse each property
          const specifiedProps = name;
          updateTransitions = value;
          const names = Object.keys(specifiedProps);

          for (let _i = 0; _i < names.length; _i++) {
            const _name2 = names[_i];
            let _value = specifiedProps[_name2];

            if (_value === undefined) {
        // try camel case name too
              _value = specifiedProps[dash2camel(_name2)];
            }

            if (_value !== undefined) {
              const _parsedProp2 = this.parse(_name2, _value, true);

              if (_parsedProp2) {
                props.push(_parsedProp2);
              }
            }
          }
        } else {
    // can't do anything without well defined properties
          return false;
        } // we've failed if there are no valid properties


        if (props.length === 0) {
          return false;
        } // now, apply the bypass properties on the elements


        let ret = false; // return true if at least one succesful bypass applied

        for (let _i2 = 0; _i2 < eles.length; _i2++) {
    // for each ele
          const ele = eles[_i2];
          const diffProps = {};
          let diffProp = void 0;

          for (let j = 0; j < props.length; j++) {
      // for each prop
            const _prop = props[j];

            if (updateTransitions) {
              const prevProp = ele.pstyle(_prop.name);
              diffProp = diffProps[_prop.name] = {
                prev: prevProp
              };
            }

            ret = this.applyParsedProperty(ele, copy(_prop)) || ret;

            if (updateTransitions) {
              diffProp.next = ele.pstyle(_prop.name);
            }
          } // for props


          if (ret) {
            this.updateStyleHints(ele);
          }

          if (updateTransitions) {
            this.updateTransitions(ele, diffProps, isBypass);
          }
        } // for eles


        return ret;
      }; // only useful in specific cases like animation


      styfn$1.overrideBypass = function (eles, name, value) {
        name = camel2dash(name);

        for (let i = 0; i < eles.length; i++) {
          const ele = eles[i];
          const prop = ele._private.style[name];
          const type = this.properties[name].type;
          const isColor = type.color;
          const isMulti = type.mutiple;
          const oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;

          if (!prop || !prop.bypass) {
      // need a bypass if one doesn't exist
            this.applyBypass(ele, name, value);
          } else {
            prop.value = value;

            if (prop.pfValue != null) {
              prop.pfValue = value;
            }

            if (isColor) {
              prop.strValue = 'rgb(' + value.join(',') + ')';
            } else if (isMulti) {
              prop.strValue = value.join(' ');
            } else {
              prop.strValue = '' + value;
            }

            this.updateStyleHints(ele);
          }

          this.checkTriggers(ele, name, oldValue, value);
        }
      };

      styfn$1.removeAllBypasses = function (eles, updateTransitions) {
        return this.removeBypasses(eles, this.propertyNames, updateTransitions);
      };

      styfn$1.removeBypasses = function (eles, props, updateTransitions) {
        const isBypass = true;

        for (let j = 0; j < eles.length; j++) {
          const ele = eles[j];
          const diffProps = {};

          for (let i = 0; i < props.length; i++) {
            const name = props[i];
            const prop = this.properties[name];
            const prevProp = ele.pstyle(prop.name);

            if (!prevProp || !prevProp.bypass) {
        // if a bypass doesn't exist for the prop, nothing needs to be removed
              continue;
            }

            const value = ''; // empty => remove bypass

            const parsedProp = this.parse(name, value, true);
            const diffProp = diffProps[prop.name] = {
              prev: prevProp
            };
            this.applyParsedProperty(ele, parsedProp);
            diffProp.next = ele.pstyle(prop.name);
          } // for props


          this.updateStyleHints(ele);

          if (updateTransitions) {
            this.updateTransitions(ele, diffProps, isBypass);
          }
        } // for eles

      };

      const styfn$2 = {}; // gets what an em size corresponds to in pixels relative to a dom element

      styfn$2.getEmSizeInPixels = function () {
        const px = this.containerCss('font-size');

        if (px != null) {
          return parseFloat(px);
        } else {
          return 1; // for headless
        }
      }; // gets css property from the core container


      styfn$2.containerCss = function (propName) {
        const cy = this._private.cy;
        const domElement = cy.container();

        if (window$1 && domElement && window$1.getComputedStyle) {
          return window$1.getComputedStyle(domElement).getPropertyValue(propName);
        }
      };

      const styfn$3 = {}; // gets the rendered style for an element

      styfn$3.getRenderedStyle = function (ele, prop) {
        if (prop) {
          return this.getStylePropertyValue(ele, prop, true);
        } else {
          return this.getRawStyle(ele, true);
        }
      }; // gets the raw style for an element


      styfn$3.getRawStyle = function (ele, isRenderedVal) {
        const self = this;
        ele = ele[0]; // insure it's an element

        if (ele) {
          const rstyle = {};

          for (let i = 0; i < self.properties.length; i++) {
            const prop = self.properties[i];
            const val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);

            if (val != null) {
              rstyle[prop.name] = val;
              rstyle[dash2camel(prop.name)] = val;
            }
          }

          return rstyle;
        }
      };

      styfn$3.getIndexedStyle = function (ele, property, subproperty, index) {
        const pstyle = ele.pstyle(property)[subproperty][index];
        return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];
      };

      styfn$3.getStylePropertyValue = function (ele, propName, isRenderedVal) {
        const self = this;
        ele = ele[0]; // insure it's an element

        if (ele) {
          let prop = self.properties[propName];

          if (prop.alias) {
            prop = prop.pointsTo;
          }

          const type = prop.type;
          const styleProp = ele.pstyle(prop.name);

          if (styleProp) {
            const value = styleProp.value,
              units = styleProp.units,
              strValue = styleProp.strValue;

            if (isRenderedVal && type.number && value != null && number(value)) {
              const zoom = ele.cy().zoom();

              const getRenderedValue = function getRenderedValue(val) {
                return val * zoom;
              };

              const getValueStringWithUnits = function getValueStringWithUnits(val, units) {
                return getRenderedValue(val) + units;
              };

              const isArrayValue = array(value);
              const haveUnits = isArrayValue ? units.every(function (u) {
                return u != null;
              }) : units != null;

              if (haveUnits) {
                if (isArrayValue) {
                  return value.map(function (v, i) {
                    return getValueStringWithUnits(v, units[i]);
                  }).join(' ');
                } else {
                  return getValueStringWithUnits(value, units);
                }
              } else {
                if (isArrayValue) {
                  return value.map(function (v) {
                    return string(v) ? v : '' + getRenderedValue(v);
                  }).join(' ');
                } else {
                  return '' + getRenderedValue(value);
                }
              }
            } else if (strValue != null) {
              return strValue;
            }
          }

          return null;
        }
      };

      styfn$3.getAnimationStartStyle = function (ele, aniProps) {
        const rstyle = {};

        for (let i = 0; i < aniProps.length; i++) {
          const aniProp = aniProps[i];
          const name = aniProp.name;
          let styleProp = ele.pstyle(name);

          if (styleProp !== undefined) {
      // then make a prop of it
            if (plainObject(styleProp)) {
              styleProp = this.parse(name, styleProp.strValue);
            } else {
              styleProp = this.parse(name, styleProp);
            }
          }

          if (styleProp) {
            rstyle[name] = styleProp;
          }
        }

        return rstyle;
      };

      styfn$3.getPropsList = function (propsObj) {
        const self = this;
        const rstyle = [];
        const style = propsObj;
        const props = self.properties;

        if (style) {
          const names = Object.keys(style);

          for (let i = 0; i < names.length; i++) {
            const name = names[i];
            const val = style[name];
            const prop = props[name] || props[camel2dash(name)];
            const styleProp = this.parse(prop.name, val);

            if (styleProp) {
              rstyle.push(styleProp);
            }
          }
        }

        return rstyle;
      };

      styfn$3.getNonDefaultPropertiesHash = function (ele, propNames, seed) {
        const hash = seed.slice();
        let name, val, strVal, chVal;
        let i, j;

        for (i = 0; i < propNames.length; i++) {
          name = propNames[i];
          val = ele.pstyle(name, false);

          if (val == null) {
            continue;
          } else if (val.pfValue != null) {
            hash[0] = hashInt(chVal, hash[0]);
            hash[1] = hashIntAlt(chVal, hash[1]);
          } else {
            strVal = val.strValue;

            for (j = 0; j < strVal.length; j++) {
              chVal = strVal.charCodeAt(j);
              hash[0] = hashInt(chVal, hash[0]);
              hash[1] = hashIntAlt(chVal, hash[1]);
            }
          }
        }

        return hash;
      };

      styfn$3.getPropertiesHash = styfn$3.getNonDefaultPropertiesHash;

      const styfn$4 = {};

      styfn$4.appendFromJson = function (json) {
        const style = this;

        for (let i = 0; i < json.length; i++) {
          const context = json[i];
          const selector = context.selector;
          const props = context.style || context.css;
          const names = Object.keys(props);
          style.selector(selector); // apply selector

          for (let j = 0; j < names.length; j++) {
            const name = names[j];
            const value = props[name];
            style.css(name, value); // apply property
          }
        }

        return style;
      }; // accessible cy.style() function


      styfn$4.fromJson = function (json) {
        const style = this;
        style.resetToDefault();
        style.appendFromJson(json);
        return style;
      }; // get json from cy.style() api


      styfn$4.json = function () {
        const json = [];

        for (let i = this.defaultLength; i < this.length; i++) {
          const cxt = this[i];
          const selector = cxt.selector;
          const props = cxt.properties;
          const css = {};

          for (let j = 0; j < props.length; j++) {
            const prop = props[j];
            css[prop.name] = prop.strValue;
          }

          json.push({
            selector: !selector ? 'core' : selector.toString(),
            style: css
          });
        }

        return json;
      };

      const styfn$5 = {};

      styfn$5.appendFromString = function (string) {
        const self = this;
        const style = this;
        let remaining = '' + string;
        let selAndBlockStr;
        let blockRem;
        let propAndValStr; // remove comments from the style string

        remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

        function removeSelAndBlockFromRemaining() {
    // remove the parsed selector and block from the remaining text to parse
          if (remaining.length > selAndBlockStr.length) {
            remaining = remaining.substr(selAndBlockStr.length);
          } else {
            remaining = '';
          }
        }

        function removePropAndValFromRem() {
    // remove the parsed property and value from the remaining block text to parse
          if (blockRem.length > propAndValStr.length) {
            blockRem = blockRem.substr(propAndValStr.length);
          } else {
            blockRem = '';
          }
        }

        for (;;) {
          const nothingLeftToParse = remaining.match(/^\s*$/);

          if (nothingLeftToParse) {
            break;
          }

          const selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

          if (!selAndBlock) {
            warn('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
            break;
          }

          selAndBlockStr = selAndBlock[0]; // parse the selector

          const selectorStr = selAndBlock[1];

          if (selectorStr !== 'core') {
            const selector = new Selector(selectorStr);

            if (selector.invalid) {
              warn('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr); // skip this selector and block

              removeSelAndBlockFromRemaining();
              continue;
            }
          } // parse the block of properties and values


          const blockStr = selAndBlock[2];
          let invalidBlock = false;
          blockRem = blockStr;
          const props = [];

          for (;;) {
            const _nothingLeftToParse = blockRem.match(/^\s*$/);

            if (_nothingLeftToParse) {
              break;
            }

            const propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

            if (!propAndVal) {
              warn('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
              invalidBlock = true;
              break;
            }

            propAndValStr = propAndVal[0];
            const propStr = propAndVal[1];
            const valStr = propAndVal[2];
            const prop = self.properties[propStr];

            if (!prop) {
              warn('Skipping property: Invalid property name in: ' + propAndValStr); // skip this property in the block

              removePropAndValFromRem();
              continue;
            }

            const parsedProp = style.parse(propStr, valStr);

            if (!parsedProp) {
              warn('Skipping property: Invalid property definition in: ' + propAndValStr); // skip this property in the block

              removePropAndValFromRem();
              continue;
            }

            props.push({
              name: propStr,
              val: valStr
            });
            removePropAndValFromRem();
          }

          if (invalidBlock) {
            removeSelAndBlockFromRemaining();
            break;
          } // put the parsed block in the style


          style.selector(selectorStr);

          for (let i = 0; i < props.length; i++) {
            const _prop = props[i];
            style.css(_prop.name, _prop.val);
          }

          removeSelAndBlockFromRemaining();
        }

        return style;
      };

      styfn$5.fromString = function (string) {
        const style = this;
        style.resetToDefault();
        style.appendFromString(string);
        return style;
      };

      const styfn$6 = {};

      (function () {
        const number = number$1;
        const rgba = rgbaNoBackRefs;
        const hsla = hslaNoBackRefs;
        const hex3$1 = hex3;
        const hex6$1 = hex6;

        const data = function data(prefix) {
          return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$';
        };

        const mapData = function mapData(prefix) {
          const mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3$1 + '|' + hex6$1;
          return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
        };

        const urlRegexes = ['^url\\s*\\(\\s*[\'"]?(.+?)[\'"]?\\s*\\)$', '^(none)$', '^(.+)$']; // each visual style property has a type and needs to be validated according to it

        styfn$6.types = {
          time: {
            number: true,
            min: 0,
            units: 's|ms',
            implicitUnits: 'ms'
          },
          percent: {
            number: true,
            min: 0,
            max: 100,
            units: '%',
            implicitUnits: '%'
          },
          percentages: {
            number: true,
            min: 0,
            max: 100,
            units: '%',
            implicitUnits: '%',
            multiple: true
          },
          zeroOneNumber: {
            number: true,
            min: 0,
            max: 1,
            unitless: true
          },
          zeroOneNumbers: {
            number: true,
            min: 0,
            max: 1,
            unitless: true,
            multiple: true
          },
          nOneOneNumber: {
            number: true,
            min: -1,
            max: 1,
            unitless: true
          },
          nonNegativeInt: {
            number: true,
            min: 0,
            integer: true,
            unitless: true
          },
          position: {
            enums: ['parent', 'origin']
          },
          nodeSize: {
            number: true,
            min: 0,
            enums: ['label']
          },
          number: {
            number: true,
            unitless: true
          },
          numbers: {
            number: true,
            unitless: true,
            multiple: true
          },
          positiveNumber: {
            number: true,
            unitless: true,
            min: 0,
            strictMin: true
          },
          size: {
            number: true,
            min: 0
          },
          bidirectionalSize: {
            number: true
          },
    // allows negative
          bidirectionalSizeMaybePercent: {
            number: true,
            allowPercent: true
          },
    // allows negative
          bidirectionalSizes: {
            number: true,
            multiple: true
          },
    // allows negative
          sizeMaybePercent: {
            number: true,
            min: 0,
            allowPercent: true
          },
          axisDirection: {
            enums: ['horizontal', 'leftward', 'rightward', 'vertical', 'upward', 'downward', 'auto']
          },
          paddingRelativeTo: {
            enums: ['width', 'height', 'average', 'min', 'max']
          },
          bgWH: {
            number: true,
            min: 0,
            allowPercent: true,
            enums: ['auto'],
            multiple: true
          },
          bgPos: {
            number: true,
            allowPercent: true,
            multiple: true
          },
          bgRelativeTo: {
            enums: ['inner', 'include-padding'],
            multiple: true
          },
          bgRepeat: {
            enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'],
            multiple: true
          },
          bgFit: {
            enums: ['none', 'contain', 'cover'],
            multiple: true
          },
          bgCrossOrigin: {
            enums: ['anonymous', 'use-credentials'],
            multiple: true
          },
          bgClip: {
            enums: ['none', 'node'],
            multiple: true
          },
          bgContainment: {
            enums: ['inside', 'over'],
            multiple: true
          },
          color: {
            color: true
          },
          colors: {
            color: true,
            multiple: true
          },
          fill: {
            enums: ['solid', 'linear-gradient', 'radial-gradient']
          },
          bool: {
            enums: ['yes', 'no']
          },
          bools: {
            enums: ['yes', 'no'],
            multiple: true
          },
          lineStyle: {
            enums: ['solid', 'dotted', 'dashed']
          },
          lineCap: {
            enums: ['butt', 'round', 'square']
          },
          borderStyle: {
            enums: ['solid', 'dotted', 'dashed', 'double']
          },
          curveStyle: {
            enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments', 'straight', 'taxi']
          },
          fontFamily: {
            regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$'
          },
          fontStyle: {
            enums: ['italic', 'normal', 'oblique']
          },
          fontWeight: {
            enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900]
          },
          textDecoration: {
            enums: ['none', 'underline', 'overline', 'line-through']
          },
          textTransform: {
            enums: ['none', 'uppercase', 'lowercase']
          },
          textWrap: {
            enums: ['none', 'wrap', 'ellipsis']
          },
          textOverflowWrap: {
            enums: ['whitespace', 'anywhere']
          },
          textBackgroundShape: {
            enums: ['rectangle', 'roundrectangle', 'round-rectangle']
          },
          nodeShape: {
            enums: ['rectangle', 'roundrectangle', 'round-rectangle', 'cutrectangle', 'cut-rectangle', 'bottomroundrectangle', 'bottom-round-rectangle', 'barrel', 'ellipse', 'triangle', 'round-triangle', 'square', 'pentagon', 'round-pentagon', 'hexagon', 'round-hexagon', 'concavehexagon', 'concave-hexagon', 'heptagon', 'round-heptagon', 'octagon', 'round-octagon', 'tag', 'round-tag', 'star', 'diamond', 'round-diamond', 'vee', 'rhomboid', 'polygon']
          },
          compoundIncludeLabels: {
            enums: ['include', 'exclude']
          },
          arrowShape: {
            enums: ['tee', 'triangle', 'triangle-tee', 'circle-triangle', 'triangle-cross', 'triangle-backcurve', 'vee', 'square', 'circle', 'diamond', 'chevron', 'none']
          },
          arrowFill: {
            enums: ['filled', 'hollow']
          },
          display: {
            enums: ['element', 'none']
          },
          visibility: {
            enums: ['hidden', 'visible']
          },
          zCompoundDepth: {
            enums: ['bottom', 'orphan', 'auto', 'top']
          },
          zIndexCompare: {
            enums: ['auto', 'manual']
          },
          valign: {
            enums: ['top', 'center', 'bottom']
          },
          halign: {
            enums: ['left', 'center', 'right']
          },
          justification: {
            enums: ['left', 'center', 'right', 'auto']
          },
          text: {
            string: true
          },
          data: {
            mapping: true,
            regex: data('data')
          },
          layoutData: {
            mapping: true,
            regex: data('layoutData')
          },
          scratch: {
            mapping: true,
            regex: data('scratch')
          },
          mapData: {
            mapping: true,
            regex: mapData('mapData')
          },
          mapLayoutData: {
            mapping: true,
            regex: mapData('mapLayoutData')
          },
          mapScratch: {
            mapping: true,
            regex: mapData('mapScratch')
          },
          fn: {
            mapping: true,
            fn: true
          },
          url: {
            regexes: urlRegexes,
            singleRegexMatchValue: true
          },
          urls: {
            regexes: urlRegexes,
            singleRegexMatchValue: true,
            multiple: true
          },
          propList: {
            propList: true
          },
          angle: {
            number: true,
            units: 'deg|rad',
            implicitUnits: 'rad'
          },
          textRotation: {
            number: true,
            units: 'deg|rad',
            implicitUnits: 'rad',
            enums: ['none', 'autorotate']
          },
          polygonPointList: {
            number: true,
            multiple: true,
            evenMultiple: true,
            min: -1,
            max: 1,
            unitless: true
          },
          edgeDistances: {
            enums: ['intersection', 'node-position']
          },
          edgeEndpoint: {
            number: true,
            multiple: true,
            units: '%|px|em|deg|rad',
            implicitUnits: 'px',
            enums: ['inside-to-node', 'outside-to-node', 'outside-to-node-or-label', 'outside-to-line', 'outside-to-line-or-label'],
            singleEnum: true,
            validate: function validate(valArr, unitsArr) {
              switch (valArr.length) {
                case 2:
            // can be % or px only
                  return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';

                case 1:
            // can be enum, deg, or rad only
                  return string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';

                default:
                  return false;
              }
            }
          },
          easing: {
            regexes: ['^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$', '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'],
            enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']
          },
          gradientDirection: {
            enums: ['to-bottom', 'to-top', 'to-left', 'to-right', 'to-bottom-right', 'to-bottom-left', 'to-top-right', 'to-top-left', 'to-right-bottom', 'to-left-bottom', 'to-right-top', 'to-left-top']
          },
          boundsExpansion: {
            number: true,
            multiple: true,
            min: 0,
            validate: function validate(valArr) {
              const length = valArr.length;
              return length === 1 || length === 2 || length === 4;
            }
          }
        };
        const diff = {
          zeroNonZero: function zeroNonZero(val1, val2) {
            if ((val1 == null || val2 == null) && val1 !== val2) {
              return true; // null cases could represent any value
            }

            if (val1 == 0 && val2 != 0) {
              return true;
            } else if (val1 != 0 && val2 == 0) {
              return true;
            } else {
              return false;
            }
          },
          any: function any(val1, val2) {
            return val1 != val2;
          },
          emptyNonEmpty: function emptyNonEmpty(str1, str2) {
            const empty1 = emptyString(str1);
            const empty2 = emptyString(str2);
            return empty1 && !empty2 || !empty1 && empty2;
          }
        }; // define visual style properties
  //
  // - n.b. adding a new group of props may require updates to updateStyleHints()
  // - adding new props to an existing group gets handled automatically

        const t = styfn$6.types;
        const mainLabel = [{
          name: 'label',
          type: t.text,
          triggersBounds: diff.any,
          triggersZOrder: diff.emptyNonEmpty
        }, {
          name: 'text-rotation',
          type: t.textRotation,
          triggersBounds: diff.any
        }, {
          name: 'text-margin-x',
          type: t.bidirectionalSize,
          triggersBounds: diff.any
        }, {
          name: 'text-margin-y',
          type: t.bidirectionalSize,
          triggersBounds: diff.any
        }];
        const sourceLabel = [{
          name: 'source-label',
          type: t.text,
          triggersBounds: diff.any
        }, {
          name: 'source-text-rotation',
          type: t.textRotation,
          triggersBounds: diff.any
        }, {
          name: 'source-text-margin-x',
          type: t.bidirectionalSize,
          triggersBounds: diff.any
        }, {
          name: 'source-text-margin-y',
          type: t.bidirectionalSize,
          triggersBounds: diff.any
        }, {
          name: 'source-text-offset',
          type: t.size,
          triggersBounds: diff.any
        }];
        const targetLabel = [{
          name: 'target-label',
          type: t.text,
          triggersBounds: diff.any
        }, {
          name: 'target-text-rotation',
          type: t.textRotation,
          triggersBounds: diff.any
        }, {
          name: 'target-text-margin-x',
          type: t.bidirectionalSize,
          triggersBounds: diff.any
        }, {
          name: 'target-text-margin-y',
          type: t.bidirectionalSize,
          triggersBounds: diff.any
        }, {
          name: 'target-text-offset',
          type: t.size,
          triggersBounds: diff.any
        }];
        const labelDimensions = [{
          name: 'font-family',
          type: t.fontFamily,
          triggersBounds: diff.any
        }, {
          name: 'font-style',
          type: t.fontStyle,
          triggersBounds: diff.any
        }, {
          name: 'font-weight',
          type: t.fontWeight,
          triggersBounds: diff.any
        }, {
          name: 'font-size',
          type: t.size,
          triggersBounds: diff.any
        }, {
          name: 'text-transform',
          type: t.textTransform,
          triggersBounds: diff.any
        }, {
          name: 'text-wrap',
          type: t.textWrap,
          triggersBounds: diff.any
        }, {
          name: 'text-overflow-wrap',
          type: t.textOverflowWrap,
          triggersBounds: diff.any
        }, {
          name: 'text-max-width',
          type: t.size,
          triggersBounds: diff.any
        }, {
          name: 'text-outline-width',
          type: t.size,
          triggersBounds: diff.any
        }, {
          name: 'line-height',
          type: t.positiveNumber,
          triggersBounds: diff.any
        }];
        const commonLabel = [{
          name: 'text-valign',
          type: t.valign,
          triggersBounds: diff.any
        }, {
          name: 'text-halign',
          type: t.halign,
          triggersBounds: diff.any
        }, {
          name: 'color',
          type: t.color
        }, {
          name: 'text-outline-color',
          type: t.color
        }, {
          name: 'text-outline-opacity',
          type: t.zeroOneNumber
        }, {
          name: 'text-background-color',
          type: t.color
        }, {
          name: 'text-background-opacity',
          type: t.zeroOneNumber
        }, {
          name: 'text-background-padding',
          type: t.size,
          triggersBounds: diff.any
        }, {
          name: 'text-border-opacity',
          type: t.zeroOneNumber
        }, {
          name: 'text-border-color',
          type: t.color
        }, {
          name: 'text-border-width',
          type: t.size,
          triggersBounds: diff.any
        }, {
          name: 'text-border-style',
          type: t.borderStyle,
          triggersBounds: diff.any
        }, {
          name: 'text-background-shape',
          type: t.textBackgroundShape,
          triggersBounds: diff.any
        }, {
          name: 'text-justification',
          type: t.justification
        }];
        const behavior = [{
          name: 'events',
          type: t.bool
        }, {
          name: 'text-events',
          type: t.bool
        }];
        const visibility = [{
          name: 'display',
          type: t.display,
          triggersZOrder: diff.any,
          triggersBounds: diff.any,
          triggersBoundsOfParallelBeziers: true
        }, {
          name: 'visibility',
          type: t.visibility,
          triggersZOrder: diff.any
        }, {
          name: 'opacity',
          type: t.zeroOneNumber,
          triggersZOrder: diff.zeroNonZero
        }, {
          name: 'text-opacity',
          type: t.zeroOneNumber
        }, {
          name: 'min-zoomed-font-size',
          type: t.size
        }, {
          name: 'z-compound-depth',
          type: t.zCompoundDepth,
          triggersZOrder: diff.any
        }, {
          name: 'z-index-compare',
          type: t.zIndexCompare,
          triggersZOrder: diff.any
        }, {
          name: 'z-index',
          type: t.nonNegativeInt,
          triggersZOrder: diff.any
        }];
        const overlay = [{
          name: 'overlay-padding',
          type: t.size,
          triggersBounds: diff.any
        }, {
          name: 'overlay-color',
          type: t.color
        }, {
          name: 'overlay-opacity',
          type: t.zeroOneNumber,
          triggersBounds: diff.zeroNonZero
        }];
        const transition = [{
          name: 'transition-property',
          type: t.propList
        }, {
          name: 'transition-duration',
          type: t.time
        }, {
          name: 'transition-delay',
          type: t.time
        }, {
          name: 'transition-timing-function',
          type: t.easing
        }];

        const nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {
          if (parsedProp.value === 'label') {
            return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)
          } else {
            return parsedProp.pfValue;
          }
        };

        const nodeBody = [{
          name: 'height',
          type: t.nodeSize,
          triggersBounds: diff.any,
          hashOverride: nodeSizeHashOverride
        }, {
          name: 'width',
          type: t.nodeSize,
          triggersBounds: diff.any,
          hashOverride: nodeSizeHashOverride
        }, {
          name: 'shape',
          type: t.nodeShape,
          triggersBounds: diff.any
        }, {
          name: 'shape-polygon-points',
          type: t.polygonPointList,
          triggersBounds: diff.any
        }, {
          name: 'background-color',
          type: t.color
        }, {
          name: 'background-fill',
          type: t.fill
        }, {
          name: 'background-opacity',
          type: t.zeroOneNumber
        }, {
          name: 'background-blacken',
          type: t.nOneOneNumber
        }, {
          name: 'background-gradient-stop-colors',
          type: t.colors
        }, {
          name: 'background-gradient-stop-positions',
          type: t.percentages
        }, {
          name: 'background-gradient-direction',
          type: t.gradientDirection
        }, {
          name: 'padding',
          type: t.sizeMaybePercent,
          triggersBounds: diff.any
        }, {
          name: 'padding-relative-to',
          type: t.paddingRelativeTo,
          triggersBounds: diff.any
        }, {
          name: 'bounds-expansion',
          type: t.boundsExpansion,
          triggersBounds: diff.any
        }];
        const nodeBorder = [{
          name: 'border-color',
          type: t.color
        }, {
          name: 'border-opacity',
          type: t.zeroOneNumber
        }, {
          name: 'border-width',
          type: t.size,
          triggersBounds: diff.any
        }, {
          name: 'border-style',
          type: t.borderStyle
        }];
        const backgroundImage = [{
          name: 'background-image',
          type: t.urls
        }, {
          name: 'background-image-crossorigin',
          type: t.bgCrossOrigin
        }, {
          name: 'background-image-opacity',
          type: t.zeroOneNumbers
        }, {
          name: 'background-image-containment',
          type: t.bgContainment
        }, {
          name: 'background-image-smoothing',
          type: t.bools
        }, {
          name: 'background-position-x',
          type: t.bgPos
        }, {
          name: 'background-position-y',
          type: t.bgPos
        }, {
          name: 'background-width-relative-to',
          type: t.bgRelativeTo
        }, {
          name: 'background-height-relative-to',
          type: t.bgRelativeTo
        }, {
          name: 'background-repeat',
          type: t.bgRepeat
        }, {
          name: 'background-fit',
          type: t.bgFit
        }, {
          name: 'background-clip',
          type: t.bgClip
        }, {
          name: 'background-width',
          type: t.bgWH
        }, {
          name: 'background-height',
          type: t.bgWH
        }, {
          name: 'background-offset-x',
          type: t.bgPos
        }, {
          name: 'background-offset-y',
          type: t.bgPos
        }];
        const compound = [{
          name: 'position',
          type: t.position,
          triggersBounds: diff.any
        }, {
          name: 'compound-sizing-wrt-labels',
          type: t.compoundIncludeLabels,
          triggersBounds: diff.any
        }, {
          name: 'min-width',
          type: t.size,
          triggersBounds: diff.any
        }, {
          name: 'min-width-bias-left',
          type: t.sizeMaybePercent,
          triggersBounds: diff.any
        }, {
          name: 'min-width-bias-right',
          type: t.sizeMaybePercent,
          triggersBounds: diff.any
        }, {
          name: 'min-height',
          type: t.size,
          triggersBounds: diff.any
        }, {
          name: 'min-height-bias-top',
          type: t.sizeMaybePercent,
          triggersBounds: diff.any
        }, {
          name: 'min-height-bias-bottom',
          type: t.sizeMaybePercent,
          triggersBounds: diff.any
        }];
        const edgeLine = [{
          name: 'line-style',
          type: t.lineStyle
        }, {
          name: 'line-color',
          type: t.color
        }, {
          name: 'line-fill',
          type: t.fill
        }, {
          name: 'line-cap',
          type: t.lineCap
        }, {
          name: 'line-opacity',
          type: t.zeroOneNumber
        }, {
          name: 'line-dash-pattern',
          type: t.numbers
        }, {
          name: 'line-dash-offset',
          type: t.number
        }, {
          name: 'line-gradient-stop-colors',
          type: t.colors
        }, {
          name: 'line-gradient-stop-positions',
          type: t.percentages
        }, {
          name: 'curve-style',
          type: t.curveStyle,
          triggersBounds: diff.any,
          triggersBoundsOfParallelBeziers: true
        }, {
          name: 'haystack-radius',
          type: t.zeroOneNumber,
          triggersBounds: diff.any
        }, {
          name: 'source-endpoint',
          type: t.edgeEndpoint,
          triggersBounds: diff.any
        }, {
          name: 'target-endpoint',
          type: t.edgeEndpoint,
          triggersBounds: diff.any
        }, {
          name: 'control-point-step-size',
          type: t.size,
          triggersBounds: diff.any
        }, {
          name: 'control-point-distances',
          type: t.bidirectionalSizes,
          triggersBounds: diff.any
        }, {
          name: 'control-point-weights',
          type: t.numbers,
          triggersBounds: diff.any
        }, {
          name: 'segment-distances',
          type: t.bidirectionalSizes,
          triggersBounds: diff.any
        }, {
          name: 'segment-weights',
          type: t.numbers,
          triggersBounds: diff.any
        }, {
          name: 'taxi-turn',
          type: t.bidirectionalSizeMaybePercent,
          triggersBounds: diff.any
        }, {
          name: 'taxi-turn-min-distance',
          type: t.size,
          triggersBounds: diff.any
        }, {
          name: 'taxi-direction',
          type: t.axisDirection,
          triggersBounds: diff.any
        }, {
          name: 'edge-distances',
          type: t.edgeDistances,
          triggersBounds: diff.any
        }, {
          name: 'arrow-scale',
          type: t.positiveNumber,
          triggersBounds: diff.any
        }, {
          name: 'loop-direction',
          type: t.angle,
          triggersBounds: diff.any
        }, {
          name: 'loop-sweep',
          type: t.angle,
          triggersBounds: diff.any
        }, {
          name: 'source-distance-from-node',
          type: t.size,
          triggersBounds: diff.any
        }, {
          name: 'target-distance-from-node',
          type: t.size,
          triggersBounds: diff.any
        }];
        const ghost = [{
          name: 'ghost',
          type: t.bool,
          triggersBounds: diff.any
        }, {
          name: 'ghost-offset-x',
          type: t.bidirectionalSize,
          triggersBounds: diff.any
        }, {
          name: 'ghost-offset-y',
          type: t.bidirectionalSize,
          triggersBounds: diff.any
        }, {
          name: 'ghost-opacity',
          type: t.zeroOneNumber
        }];
        const core = [{
          name: 'selection-box-color',
          type: t.color
        }, {
          name: 'selection-box-opacity',
          type: t.zeroOneNumber
        }, {
          name: 'selection-box-border-color',
          type: t.color
        }, {
          name: 'selection-box-border-width',
          type: t.size
        }, {
          name: 'active-bg-color',
          type: t.color
        }, {
          name: 'active-bg-opacity',
          type: t.zeroOneNumber
        }, {
          name: 'active-bg-size',
          type: t.size
        }, {
          name: 'outside-texture-bg-color',
          type: t.color
        }, {
          name: 'outside-texture-bg-opacity',
          type: t.zeroOneNumber
        }]; // pie backgrounds for nodes

        const pie = [];
        styfn$6.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)

        pie.push({
          name: 'pie-size',
          type: t.sizeMaybePercent
        });

        for (let i = 1; i <= styfn$6.pieBackgroundN; i++) {
          pie.push({
            name: 'pie-' + i + '-background-color',
            type: t.color
          });
          pie.push({
            name: 'pie-' + i + '-background-size',
            type: t.percent
          });
          pie.push({
            name: 'pie-' + i + '-background-opacity',
            type: t.zeroOneNumber
          });
        } // edge arrows


        const edgeArrow = [];
        const arrowPrefixes = styfn$6.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];
        [{
          name: 'arrow-shape',
          type: t.arrowShape,
          triggersBounds: diff.any
        }, {
          name: 'arrow-color',
          type: t.color
        }, {
          name: 'arrow-fill',
          type: t.arrowFill
        }].forEach(function (prop) {
          arrowPrefixes.forEach(function (prefix) {
            const name = prefix + '-' + prop.name;
            const type = prop.type,
              triggersBounds = prop.triggersBounds;
            edgeArrow.push({
              name: name,
              type: type,
              triggersBounds: triggersBounds
            });
          });
        }, {});
        const props = styfn$6.properties = [].concat(behavior, transition, visibility, overlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, backgroundImage, pie, compound, edgeLine, edgeArrow, core);
        const propGroups = styfn$6.propertyGroups = {
    // common to all eles
          behavior: behavior,
          transition: transition,
          visibility: visibility,
          overlay: overlay,
          ghost: ghost,
    // labels
          commonLabel: commonLabel,
          labelDimensions: labelDimensions,
          mainLabel: mainLabel,
          sourceLabel: sourceLabel,
          targetLabel: targetLabel,
    // node props
          nodeBody: nodeBody,
          nodeBorder: nodeBorder,
          backgroundImage: backgroundImage,
          pie: pie,
          compound: compound,
    // edge props
          edgeLine: edgeLine,
          edgeArrow: edgeArrow,
          core: core
        };
        const propGroupNames = styfn$6.propertyGroupNames = {};
        const propGroupKeys = styfn$6.propertyGroupKeys = Object.keys(propGroups);
        propGroupKeys.forEach(function (key) {
          propGroupNames[key] = propGroups[key].map(function (prop) {
            return prop.name;
          });
          propGroups[key].forEach(function (prop) {
            return prop.groupKey = key;
          });
        }); // define aliases

        const aliases = styfn$6.aliases = [{
          name: 'content',
          pointsTo: 'label'
        }, {
          name: 'control-point-distance',
          pointsTo: 'control-point-distances'
        }, {
          name: 'control-point-weight',
          pointsTo: 'control-point-weights'
        }, {
          name: 'edge-text-rotation',
          pointsTo: 'text-rotation'
        }, {
          name: 'padding-left',
          pointsTo: 'padding'
        }, {
          name: 'padding-right',
          pointsTo: 'padding'
        }, {
          name: 'padding-top',
          pointsTo: 'padding'
        }, {
          name: 'padding-bottom',
          pointsTo: 'padding'
        }]; // list of property names

        styfn$6.propertyNames = props.map(function (p) {
          return p.name;
        }); // allow access of properties by name ( e.g. style.properties.height )

        for (let _i = 0; _i < props.length; _i++) {
          const prop = props[_i];
          props[prop.name] = prop; // allow lookup by name
        } // map aliases


        for (let _i2 = 0; _i2 < aliases.length; _i2++) {
          const alias = aliases[_i2];
          const pointsToProp = props[alias.pointsTo];
          const aliasProp = {
            name: alias.name,
            alias: true,
            pointsTo: pointsToProp
          }; // add alias prop for parsing

          props.push(aliasProp);
          props[alias.name] = aliasProp; // allow lookup by name
        }
      })();

      styfn$6.getDefaultProperty = function (name) {
        return this.getDefaultProperties()[name];
      };

      styfn$6.getDefaultProperties = function () {
        const _p = this._private;

        if (_p.defaultProperties != null) {
          return _p.defaultProperties;
        }

        const rawProps = extend({
    // core props
          'selection-box-color': '#ddd',
          'selection-box-opacity': 0.65,
          'selection-box-border-color': '#aaa',
          'selection-box-border-width': 1,
          'active-bg-color': 'black',
          'active-bg-opacity': 0.15,
          'active-bg-size': 30,
          'outside-texture-bg-color': '#000',
          'outside-texture-bg-opacity': 0.125,
    // common node/edge props
          'events': 'yes',
          'text-events': 'no',
          'text-valign': 'top',
          'text-halign': 'center',
          'text-justification': 'auto',
          'line-height': 1,
          'color': '#000',
          'text-outline-color': '#000',
          'text-outline-width': 0,
          'text-outline-opacity': 1,
          'text-opacity': 1,
          'text-decoration': 'none',
          'text-transform': 'none',
          'text-wrap': 'none',
          'text-overflow-wrap': 'whitespace',
          'text-max-width': 9999,
          'text-background-color': '#000',
          'text-background-opacity': 0,
          'text-background-shape': 'rectangle',
          'text-background-padding': 0,
          'text-border-opacity': 0,
          'text-border-width': 0,
          'text-border-style': 'solid',
          'text-border-color': '#000',
          'font-family': 'Helvetica Neue, Helvetica, sans-serif',
          'font-style': 'normal',
          'font-weight': 'normal',
          'font-size': 16,
          'min-zoomed-font-size': 0,
          'text-rotation': 'none',
          'source-text-rotation': 'none',
          'target-text-rotation': 'none',
          'visibility': 'visible',
          'display': 'element',
          'opacity': 1,
          'z-compound-depth': 'auto',
          'z-index-compare': 'auto',
          'z-index': 0,
          'label': '',
          'text-margin-x': 0,
          'text-margin-y': 0,
          'source-label': '',
          'source-text-offset': 0,
          'source-text-margin-x': 0,
          'source-text-margin-y': 0,
          'target-label': '',
          'target-text-offset': 0,
          'target-text-margin-x': 0,
          'target-text-margin-y': 0,
          'overlay-opacity': 0,
          'overlay-color': '#000',
          'overlay-padding': 10,
          'transition-property': 'none',
          'transition-duration': 0,
          'transition-delay': 0,
          'transition-timing-function': 'linear',
    // node props
          'background-blacken': 0,
          'background-color': '#999',
          'background-fill': 'solid',
          'background-opacity': 1,
          'background-image': 'none',
          'background-image-crossorigin': 'anonymous',
          'background-image-opacity': 1,
          'background-image-containment': 'inside',
          'background-image-smoothing': 'yes',
          'background-position-x': '50%',
          'background-position-y': '50%',
          'background-offset-x': 0,
          'background-offset-y': 0,
          'background-width-relative-to': 'include-padding',
          'background-height-relative-to': 'include-padding',
          'background-repeat': 'no-repeat',
          'background-fit': 'none',
          'background-clip': 'node',
          'background-width': 'auto',
          'background-height': 'auto',
          'border-color': '#000',
          'border-opacity': 1,
          'border-width': 0,
          'border-style': 'solid',
          'height': 30,
          'width': 30,
          'shape': 'ellipse',
          'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',
          'bounds-expansion': 0,
    // node gradient
          'background-gradient-direction': 'to-bottom',
          'background-gradient-stop-colors': '#999',
          'background-gradient-stop-positions': '0%',
    // ghost props
          'ghost': 'no',
          'ghost-offset-y': 0,
          'ghost-offset-x': 0,
          'ghost-opacity': 0,
    // compound props
          'padding': 0,
          'padding-relative-to': 'width',
          'position': 'origin',
          'compound-sizing-wrt-labels': 'include',
          'min-width': 0,
          'min-width-bias-left': 0,
          'min-width-bias-right': 0,
          'min-height': 0,
          'min-height-bias-top': 0,
          'min-height-bias-bottom': 0
        }, {
    // node pie bg
          'pie-size': '100%'
        }, [{
          name: 'pie-{{i}}-background-color',
          value: 'black'
        }, {
          name: 'pie-{{i}}-background-size',
          value: '0%'
        }, {
          name: 'pie-{{i}}-background-opacity',
          value: 1
        }].reduce(function (css, prop) {
          for (let i = 1; i <= styfn$6.pieBackgroundN; i++) {
            const name = prop.name.replace('{{i}}', i);
            const val = prop.value;
            css[name] = val;
          }

          return css;
        }, {}), {
    // edge props
          'line-style': 'solid',
          'line-color': '#999',
          'line-fill': 'solid',
          'line-cap': 'butt',
          'line-opacity': 1,
          'line-gradient-stop-colors': '#999',
          'line-gradient-stop-positions': '0%',
          'control-point-step-size': 40,
          'control-point-weights': 0.5,
          'segment-weights': 0.5,
          'segment-distances': 20,
          'taxi-turn': '50%',
          'taxi-turn-min-distance': 10,
          'taxi-direction': 'auto',
          'edge-distances': 'intersection',
          'curve-style': 'haystack',
          'haystack-radius': 0,
          'arrow-scale': 1,
          'loop-direction': '-45deg',
          'loop-sweep': '-90deg',
          'source-distance-from-node': 0,
          'target-distance-from-node': 0,
          'source-endpoint': 'outside-to-node',
          'target-endpoint': 'outside-to-node',
          'line-dash-pattern': [6, 3],
          'line-dash-offset': 0
        }, [{
          name: 'arrow-shape',
          value: 'none'
        }, {
          name: 'arrow-color',
          value: '#999'
        }, {
          name: 'arrow-fill',
          value: 'filled'
        }].reduce(function (css, prop) {
          styfn$6.arrowPrefixes.forEach(function (prefix) {
            const name = prefix + '-' + prop.name;
            const val = prop.value;
            css[name] = val;
          });
          return css;
        }, {}));
        const parsedProps = {};

        for (let i = 0; i < this.properties.length; i++) {
          const prop = this.properties[i];

          if (prop.pointsTo) {
            continue;
          }

          const name = prop.name;
          const val = rawProps[name];
          const parsedProp = this.parse(name, val);
          parsedProps[name] = parsedProp;
        }

        _p.defaultProperties = parsedProps;
        return _p.defaultProperties;
      };

      styfn$6.addDefaultStylesheet = function () {
        this.selector(':parent').css({
          'shape': 'rectangle',
          'padding': 10,
          'background-color': '#eee',
          'border-color': '#ccc',
          'border-width': 1
        }).selector('edge').css({
          'width': 3
        }).selector(':loop').css({
          'curve-style': 'bezier'
        }).selector('edge:compound').css({
          'curve-style': 'bezier',
          'source-endpoint': 'outside-to-line',
          'target-endpoint': 'outside-to-line'
        }).selector(':selected').css({
          'background-color': '#0169D9',
          'line-color': '#0169D9',
          'source-arrow-color': '#0169D9',
          'target-arrow-color': '#0169D9',
          'mid-source-arrow-color': '#0169D9',
          'mid-target-arrow-color': '#0169D9'
        }).selector(':parent:selected').css({
          'background-color': '#CCE1F9',
          'border-color': '#aec8e5'
        }).selector(':active').css({
          'overlay-color': 'black',
          'overlay-padding': 10,
          'overlay-opacity': 0.25
        });
        this.defaultLength = this.length;
      };

      const styfn$7 = {}; // a caching layer for property parsing

      styfn$7.parse = function (name, value, propIsBypass, propIsFlat) {
        const self = this; // function values can't be cached in all cases, and there isn't much benefit of caching them anyway

        if (fn(value)) {
          return self.parseImplWarn(name, value, propIsBypass, propIsFlat);
        }

        const flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;
        const bypassKey = propIsBypass ? 't' : 'f';
        const valueKey = '' + value;
        const argHash = hashStrings(name, valueKey, bypassKey, flatKey);
        const propCache = self.propCache = self.propCache || [];
        let ret;

        if (!(ret = propCache[argHash])) {
          ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);
        } // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden
  // - mappings can't be shared b/c mappings are per-element


        if (propIsBypass || propIsFlat === 'mapping') {
    // need a copy since props are mutated later in their lifecycles
          ret = copy(ret);

          if (ret) {
            ret.value = copy(ret.value); // because it could be an array, e.g. colour
          }
        }

        return ret;
      };

      styfn$7.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {
        const prop = this.parseImpl(name, value, propIsBypass, propIsFlat);

        if (!prop && value != null) {
          warn("The style property `".concat(name, ": ").concat(value, "` is invalid"));
        }

        if (prop && (prop.name === 'width' || prop.name === 'height') && value === 'label') {
          warn('The style value of `label` is deprecated for `' + prop.name + '`');
        }

        return prop;
      }; // parse a property; return null on invalid; return parsed property otherwise
// fields :
// - name : the name of the property
// - value : the parsed, native-typed value of the property
// - strValue : a string value that represents the property value in valid css
// - bypass : true iff the property is a bypass property


      styfn$7.parseImpl = function (name, value, propIsBypass, propIsFlat) {
        const self = this;
        name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')

        let property = self.properties[name];
        const passedValue = value;
        const types = self.types;

        if (!property) {
          return null;
        } // return null on property of unknown name


        if (value === undefined) {
          return null;
        } // can't assign undefined
  // the property may be an alias


        if (property.alias) {
          property = property.pointsTo;
          name = property.name;
        }

        const valueIsString = string(value);

        if (valueIsString) {
    // trim the value to make parsing easier
          value = value.trim();
        }

        const type = property.type;

        if (!type) {
          return null;
        } // no type, no luck
  // check if bypass is null or empty string (i.e. indication to delete bypass property)


        if (propIsBypass && (value === '' || value === null)) {
          return {
            name: name,
            value: value,
            bypass: true,
            deleteBypass: true
          };
        } // check if value is a function used as a mapper


        if (fn(value)) {
          return {
            name: name,
            value: value,
            strValue: 'fn',
            mapped: types.fn,
            bypass: propIsBypass
          };
        } // check if value is mapped


        let data, mapData;

        if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== 'a') ; else if (value.length >= 7 && value[0] === 'd' && (data = new RegExp(types.data.regex).exec(value))) {
          if (propIsBypass) {
            return false;
          } // mappers not allowed in bypass


          const mapped = types.data;
          return {
            name: name,
            value: data,
            strValue: '' + value,
            mapped: mapped,
            field: data[1],
            bypass: propIsBypass
          };
        } else if (value.length >= 10 && value[0] === 'm' && (mapData = new RegExp(types.mapData.regex).exec(value))) {
          if (propIsBypass) {
            return false;
          } // mappers not allowed in bypass


          if (type.multiple) {
            return false;
          } // impossible to map to num


          const _mapped = types.mapData; // we can map only if the type is a colour or a number

          if (!(type.color || type.number)) {
            return false;
          }

          const valueMin = this.parse(name, mapData[4]); // parse to validate

          if (!valueMin || valueMin.mapped) {
            return false;
          } // can't be invalid or mapped


          const valueMax = this.parse(name, mapData[5]); // parse to validate

          if (!valueMax || valueMax.mapped) {
            return false;
          } // can't be invalid or mapped
    // check if valueMin and valueMax are the same


          if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {
            warn('`' + name + ': ' + value + '` is not a valid mapper because the output range is zero; converting to `' + name + ': ' + valueMin.strValue + '`');
            return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range
          } else if (type.color) {
            const c1 = valueMin.value;
            const c2 = valueMax.value;
            const same = c1[0] === c2[0] // red
      && c1[1] === c2[1] // green
      && c1[2] === c2[2] // blue
      && ( // optional alpha
        c1[3] === c2[3] // same alpha outright
      || (c1[3] == null || c1[3] === 1) && ( // full opacity for colour 1?
        c2[3] == null || c2[3] === 1) // full opacity for colour 2?
      );

            if (same) {
              return false;
            } // can't make a mapper without a range

          }

          return {
            name: name,
            value: mapData,
            strValue: '' + value,
            mapped: _mapped,
            field: mapData[1],
            fieldMin: parseFloat(mapData[2]),
      // min & max are numeric
            fieldMax: parseFloat(mapData[3]),
            valueMin: valueMin.value,
            valueMax: valueMax.value,
            bypass: propIsBypass
          };
        }

        if (type.multiple && propIsFlat !== 'multiple') {
          let vals;

          if (valueIsString) {
            vals = value.split(/\s+/);
          } else if (array(value)) {
            vals = value;
          } else {
            vals = [value];
          }

          if (type.evenMultiple && vals.length % 2 !== 0) {
            return null;
          }

          const valArr = [];
          const unitsArr = [];
          const pfValArr = [];
          let strVal = '';
          let hasEnum = false;

          for (let i = 0; i < vals.length; i++) {
            const p = self.parse(name, vals[i], propIsBypass, 'multiple');
            hasEnum = hasEnum || string(p.value);
            valArr.push(p.value);
            pfValArr.push(p.pfValue != null ? p.pfValue : p.value);
            unitsArr.push(p.units);
            strVal += (i > 0 ? ' ' : '') + p.strValue;
          }

          if (type.validate && !type.validate(valArr, unitsArr)) {
            return null;
          }

          if (type.singleEnum && hasEnum) {
            if (valArr.length === 1 && string(valArr[0])) {
              return {
                name: name,
                value: valArr[0],
                strValue: valArr[0],
                bypass: propIsBypass
              };
            } else {
              return null;
            }
          }

          return {
            name: name,
            value: valArr,
            pfValue: pfValArr,
            strValue: strVal,
            bypass: propIsBypass,
            units: unitsArr
          };
        } // several types also allow enums


        const checkEnums = function checkEnums() {
          for (let _i = 0; _i < type.enums.length; _i++) {
            const en = type.enums[_i];

            if (en === value) {
              return {
                name: name,
                value: value,
                strValue: '' + value,
                bypass: propIsBypass
              };
            }
          }

          return null;
        }; // check the type and return the appropriate object


        if (type.number) {
          let units;
          let implicitUnits = 'px'; // not set => px

          if (type.units) {
      // use specified units if set
            units = type.units;
          }

          if (type.implicitUnits) {
            implicitUnits = type.implicitUnits;
          }

          if (!type.unitless) {
            if (valueIsString) {
              let unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');

              if (units) {
                unitsRegex = units;
              } // only allow explicit units if so set


              const match = value.match('^(' + number$1 + ')(' + unitsRegex + ')?' + '$');

              if (match) {
                value = match[1];
                units = match[2] || implicitUnits;
              }
            } else if (!units || type.implicitUnits) {
              units = implicitUnits; // implicitly px if unspecified
            }
          }

          value = parseFloat(value); // if not a number and enums not allowed, then the value is invalid

          if (isNaN(value) && type.enums === undefined) {
            return null;
          } // check if this number type also accepts special keywords in place of numbers
    // (i.e. `left`, `auto`, etc)


          if (isNaN(value) && type.enums !== undefined) {
            value = passedValue;
            return checkEnums();
          } // check if value must be an integer


          if (type.integer && !integer(value)) {
            return null;
          } // check value is within range


          if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {
            return null;
          }

          const ret = {
            name: name,
            value: value,
            strValue: '' + value + (units ? units : ''),
            units: units,
            bypass: propIsBypass
          }; // normalise value in pixels

          if (type.unitless || units !== 'px' && units !== 'em') {
            ret.pfValue = value;
          } else {
            ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;
          } // normalise value in ms


          if (units === 'ms' || units === 's') {
            ret.pfValue = units === 'ms' ? value : 1000 * value;
          } // normalise value in rad


          if (units === 'deg' || units === 'rad') {
            ret.pfValue = units === 'rad' ? value : deg2rad(value);
          } // normalize value in %


          if (units === '%') {
            ret.pfValue = value / 100;
          }

          return ret;
        } else if (type.propList) {
          const props = [];
          const propsStr = '' + value;

          if (propsStr === 'none') ; else {
      // go over each prop
            const propsSplit = propsStr.split(/\s*,\s*|\s+/);

            for (let _i2 = 0; _i2 < propsSplit.length; _i2++) {
              const propName = propsSplit[_i2].trim();

              if (self.properties[propName]) {
                props.push(propName);
              } else {
                warn('`' + propName + '` is not a valid property name');
              }
            }

            if (props.length === 0) {
              return null;
            }
          }

          return {
            name: name,
            value: props,
            strValue: props.length === 0 ? 'none' : props.join(' '),
            bypass: propIsBypass
          };
        } else if (type.color) {
          const tuple = color2tuple(value);

          if (!tuple) {
            return null;
          }

          return {
            name: name,
            value: tuple,
            pfValue: tuple,
            strValue: 'rgb(' + tuple[0] + ',' + tuple[1] + ',' + tuple[2] + ')',
      // n.b. no spaces b/c of multiple support
            bypass: propIsBypass
          };
        } else if (type.regex || type.regexes) {
    // first check enums
          if (type.enums) {
            const enumProp = checkEnums();

            if (enumProp) {
              return enumProp;
            }
          }

          const regexes = type.regexes ? type.regexes : [type.regex];

          for (let _i3 = 0; _i3 < regexes.length; _i3++) {
            const regex = new RegExp(regexes[_i3]); // make a regex from the type string

            const m = regex.exec(value);

            if (m) {
        // regex matches
              return {
                name: name,
                value: type.singleRegexMatchValue ? m[1] : m,
                strValue: '' + value,
                bypass: propIsBypass
              };
            }
          }

          return null; // didn't match any
        } else if (type.string) {
    // just return
          return {
            name: name,
            value: '' + value,
            strValue: '' + value,
            bypass: propIsBypass
          };
        } else if (type.enums) {
    // check enums last because it's a combo type in others
          return checkEnums();
        } else {
          return null; // not a type we can handle
        }
      };

      const Style = function Style(cy) {
        if (!(this instanceof Style)) {
          return new Style(cy);
        }

        if (!core(cy)) {
          error('A style must have a core reference');
          return;
        }

        this._private = {
          cy: cy,
          coreStyle: {}
        };
        this.length = 0;
        this.resetToDefault();
      };

      const styfn$8 = Style.prototype;

      styfn$8.instanceString = function () {
        return 'style';
      }; // remove all contexts


      styfn$8.clear = function () {
        const _p = this._private;
        const cy = _p.cy;
        const eles = cy.elements();

        for (let i = 0; i < this.length; i++) {
          this[i] = undefined;
        }

        this.length = 0;
        _p.contextStyles = {};
        _p.propDiffs = {};
        this.cleanElements(eles, true);
        eles.forEach(function (ele) {
          const ele_p = ele[0]._private;
          ele_p.styleDirty = true;
          ele_p.appliedInitStyle = false;
        });
        return this; // chaining
      };

      styfn$8.resetToDefault = function () {
        this.clear();
        this.addDefaultStylesheet();
        return this;
      }; // builds a style object for the 'core' selector


      styfn$8.core = function (propName) {
        return this._private.coreStyle[propName] || this.getDefaultProperty(propName);
      }; // create a new context from the specified selector string and switch to that context


      styfn$8.selector = function (selectorStr) {
  // 'core' is a special case and does not need a selector
        const selector = selectorStr === 'core' ? null : new Selector(selectorStr);
        const i = this.length++; // new context means new index

        this[i] = {
          selector: selector,
          properties: [],
          mappedProperties: [],
          index: i
        };
        return this; // chaining
      }; // add one or many css rules to the current context


      styfn$8.css = function () {
        const self = this;
        const args = arguments;

        if (args.length === 1) {
          const map = args[0];

          for (let i = 0; i < self.properties.length; i++) {
            const prop = self.properties[i];
            let mapVal = map[prop.name];

            if (mapVal === undefined) {
              mapVal = map[dash2camel(prop.name)];
            }

            if (mapVal !== undefined) {
              this.cssRule(prop.name, mapVal);
            }
          }
        } else if (args.length === 2) {
          this.cssRule(args[0], args[1]);
        } // do nothing if args are invalid


        return this; // chaining
      };

      styfn$8.style = styfn$8.css; // add a single css rule to the current context

      styfn$8.cssRule = function (name, value) {
  // name-value pair
        const property = this.parse(name, value); // add property to current context if valid

        if (property) {
          const i = this.length - 1;
          this[i].properties.push(property);
          this[i].properties[property.name] = property; // allow access by name as well

          if (property.name.match(/pie-(\d+)-background-size/) && property.value) {
            this._private.hasPie = true;
          }

          if (property.mapped) {
            this[i].mappedProperties.push(property);
          } // add to core style if necessary


          const currentSelectorIsCore = !this[i].selector;

          if (currentSelectorIsCore) {
            this._private.coreStyle[property.name] = property;
          }
        }

        return this; // chaining
      };

      styfn$8.append = function (style) {
        if (stylesheet(style)) {
          style.appendToStyle(this);
        } else if (array(style)) {
          this.appendFromJson(style);
        } else if (string(style)) {
          this.appendFromString(style);
        } // you probably wouldn't want to append a Style, since you'd duplicate the default parts


        return this;
      }; // static function


      Style.fromJson = function (cy, json) {
        const style = new Style(cy);
        style.fromJson(json);
        return style;
      };

      Style.fromString = function (cy, string) {
        return new Style(cy).fromString(string);
      };

      [styfn, styfn$1, styfn$2, styfn$3, styfn$4, styfn$5, styfn$6, styfn$7].forEach(function (props) {
        extend(styfn$8, props);
      });
      Style.types = styfn$8.types;
      Style.properties = styfn$8.properties;
      Style.propertyGroups = styfn$8.propertyGroups;
      Style.propertyGroupNames = styfn$8.propertyGroupNames;
      Style.propertyGroupKeys = styfn$8.propertyGroupKeys;

      const corefn$7 = {
        style: function style(newStyle) {
          if (newStyle) {
            const s = this.setStyle(newStyle);
            s.update();
          }

          return this._private.style;
        },
        setStyle: function setStyle(style) {
          const _p = this._private;

          if (stylesheet(style)) {
            _p.style = style.generateStyle(this);
          } else if (array(style)) {
            _p.style = Style.fromJson(this, style);
          } else if (string(style)) {
            _p.style = Style.fromString(this, style);
          } else {
            _p.style = Style(this);
          }

          return _p.style;
        },
  // e.g. cy.data() changed => recalc ele mappers
        updateStyle: function updateStyle() {
          this.mutableElements().updateStyle(); // just send to all eles
        }
      };

      const defaultSelectionType = 'single';
      const corefn$8 = {
        autolock: function autolock(bool) {
          if (bool !== undefined) {
            this._private.autolock = bool ? true : false;
          } else {
            return this._private.autolock;
          }

          return this; // chaining
        },
        autoungrabify: function autoungrabify(bool) {
          if (bool !== undefined) {
            this._private.autoungrabify = bool ? true : false;
          } else {
            return this._private.autoungrabify;
          }

          return this; // chaining
        },
        autounselectify: function autounselectify(bool) {
          if (bool !== undefined) {
            this._private.autounselectify = bool ? true : false;
          } else {
            return this._private.autounselectify;
          }

          return this; // chaining
        },
        selectionType: function selectionType(selType) {
          const _p = this._private;

          if (_p.selectionType == null) {
            _p.selectionType = defaultSelectionType;
          }

          if (selType !== undefined) {
            if (selType === 'additive' || selType === 'single') {
              _p.selectionType = selType;
            }
          } else {
            return _p.selectionType;
          }

          return this;
        },
        panningEnabled: function panningEnabled(bool) {
          if (bool !== undefined) {
            this._private.panningEnabled = bool ? true : false;
          } else {
            return this._private.panningEnabled;
          }

          return this; // chaining
        },
        userPanningEnabled: function userPanningEnabled(bool) {
          if (bool !== undefined) {
            this._private.userPanningEnabled = bool ? true : false;
          } else {
            return this._private.userPanningEnabled;
          }

          return this; // chaining
        },
        zoomingEnabled: function zoomingEnabled(bool) {
          if (bool !== undefined) {
            this._private.zoomingEnabled = bool ? true : false;
          } else {
            return this._private.zoomingEnabled;
          }

          return this; // chaining
        },
        userZoomingEnabled: function userZoomingEnabled(bool) {
          if (bool !== undefined) {
            this._private.userZoomingEnabled = bool ? true : false;
          } else {
            return this._private.userZoomingEnabled;
          }

          return this; // chaining
        },
        boxSelectionEnabled: function boxSelectionEnabled(bool) {
          if (bool !== undefined) {
            this._private.boxSelectionEnabled = bool ? true : false;
          } else {
            return this._private.boxSelectionEnabled;
          }

          return this; // chaining
        },
        pan: function pan() {
          const args = arguments;
          const pan = this._private.pan;
          let dim, val, dims, x, y;

          switch (args.length) {
            case 0:
        // .pan()
              return pan;

            case 1:
              if (string(args[0])) {
          // .pan('x')
                dim = args[0];
                return pan[dim];
              } else if (plainObject(args[0])) {
          // .pan({ x: 0, y: 100 })
                if (!this._private.panningEnabled) {
                  return this;
                }

                dims = args[0];
                x = dims.x;
                y = dims.y;

                if (number(x)) {
                  pan.x = x;
                }

                if (number(y)) {
                  pan.y = y;
                }

                this.emit('pan viewport');
              }

              break;

            case 2:
        // .pan('x', 100)
              if (!this._private.panningEnabled) {
                return this;
              }

              dim = args[0];
              val = args[1];

              if ((dim === 'x' || dim === 'y') && number(val)) {
                pan[dim] = val;
              }

              this.emit('pan viewport');
              break;
      // invalid
          }

          this.notify('viewport');
          return this; // chaining
        },
        panBy: function panBy(arg0, arg1) {
          const args = arguments;
          const pan = this._private.pan;
          let dim, val, dims, x, y;

          if (!this._private.panningEnabled) {
            return this;
          }

          switch (args.length) {
            case 1:
              if (plainObject(arg0)) {
          // .panBy({ x: 0, y: 100 })
                dims = args[0];
                x = dims.x;
                y = dims.y;

                if (number(x)) {
                  pan.x += x;
                }

                if (number(y)) {
                  pan.y += y;
                }

                this.emit('pan viewport');
              }

              break;

            case 2:
        // .panBy('x', 100)
              dim = arg0;
              val = arg1;

              if ((dim === 'x' || dim === 'y') && number(val)) {
                pan[dim] += val;
              }

              this.emit('pan viewport');
              break;
      // invalid
          }

          this.notify('viewport');
          return this; // chaining
        },
        fit: function fit(elements, padding) {
          const viewportState = this.getFitViewport(elements, padding);

          if (viewportState) {
            const _p = this._private;
            _p.zoom = viewportState.zoom;
            _p.pan = viewportState.pan;
            this.emit('pan zoom viewport');
            this.notify('viewport');
          }

          return this; // chaining
        },
        getFitViewport: function getFitViewport(elements, padding) {
          if (number(elements) && padding === undefined) {
      // elements is optional
            padding = elements;
            elements = undefined;
          }

          if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
            return;
          }

          let bb;

          if (string(elements)) {
            const sel = elements;
            elements = this.$(sel);
          } else if (boundingBox(elements)) {
      // assume bb
            const bbe = elements;
            bb = {
              x1: bbe.x1,
              y1: bbe.y1,
              x2: bbe.x2,
              y2: bbe.y2
            };
            bb.w = bb.x2 - bb.x1;
            bb.h = bb.y2 - bb.y1;
          } else if (!elementOrCollection(elements)) {
            elements = this.mutableElements();
          }

          if (elementOrCollection(elements) && elements.empty()) {
            return;
          } // can't fit to nothing


          bb = bb || elements.boundingBox();
          const w = this.width();
          const h = this.height();
          let zoom;
          padding = number(padding) ? padding : 0;

          if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {
            zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h); // crop zoom

            zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
            zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;
            const pan = {
        // now pan to middle
              x: (w - zoom * (bb.x1 + bb.x2)) / 2,
              y: (h - zoom * (bb.y1 + bb.y2)) / 2
            };
            return {
              zoom: zoom,
              pan: pan
            };
          }

          return;
        },
        zoomRange: function zoomRange(min, max) {
          const _p = this._private;

          if (max == null) {
            const opts = min;
            min = opts.min;
            max = opts.max;
          }

          if (number(min) && number(max) && min <= max) {
            _p.minZoom = min;
            _p.maxZoom = max;
          } else if (number(min) && max === undefined && min <= _p.maxZoom) {
            _p.minZoom = min;
          } else if (number(max) && min === undefined && max >= _p.minZoom) {
            _p.maxZoom = max;
          }

          return this;
        },
        minZoom: function minZoom(zoom) {
          if (zoom === undefined) {
            return this._private.minZoom;
          } else {
            return this.zoomRange({
              min: zoom
            });
          }
        },
        maxZoom: function maxZoom(zoom) {
          if (zoom === undefined) {
            return this._private.maxZoom;
          } else {
            return this.zoomRange({
              max: zoom
            });
          }
        },
        getZoomedViewport: function getZoomedViewport(params) {
          const _p = this._private;
          const currentPan = _p.pan;
          const currentZoom = _p.zoom;
          let pos; // in rendered px

          let zoom;
          let bail = false;

          if (!_p.zoomingEnabled) {
      // zooming disabled
            bail = true;
          }

          if (number(params)) {
      // then set the zoom
            zoom = params;
          } else if (plainObject(params)) {
      // then zoom about a point
            zoom = params.level;

            if (params.position != null) {
              pos = modelToRenderedPosition(params.position, currentZoom, currentPan);
            } else if (params.renderedPosition != null) {
              pos = params.renderedPosition;
            }

            if (pos != null && !_p.panningEnabled) {
        // panning disabled
              bail = true;
            }
          } // crop zoom


          zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;
          zoom = zoom < _p.minZoom ? _p.minZoom : zoom; // can't zoom with invalid params

          if (bail || !number(zoom) || zoom === currentZoom || pos != null && (!number(pos.x) || !number(pos.y))) {
            return null;
          }

          if (pos != null) {
      // set zoom about position
            const pan1 = currentPan;
            const zoom1 = currentZoom;
            const zoom2 = zoom;
            const pan2 = {
              x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,
              y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y
            };
            return {
              zoomed: true,
              panned: true,
              zoom: zoom2,
              pan: pan2
            };
          } else {
      // just set the zoom
            return {
              zoomed: true,
              panned: false,
              zoom: zoom,
              pan: currentPan
            };
          }
        },
        zoom: function zoom(params) {
          if (params === undefined) {
      // get
            return this._private.zoom;
          } else {
      // set
            const vp = this.getZoomedViewport(params);
            const _p = this._private;

            if (vp == null || !vp.zoomed) {
              return this;
            }

            _p.zoom = vp.zoom;

            if (vp.panned) {
              _p.pan.x = vp.pan.x;
              _p.pan.y = vp.pan.y;
            }

            this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');
            this.notify('viewport');
            return this; // chaining
          }
        },
        viewport: function viewport(opts) {
          const _p = this._private;
          let zoomDefd = true;
          let panDefd = true;
          const events = []; // to trigger

          let zoomFailed = false;
          let panFailed = false;

          if (!opts) {
            return this;
          }

          if (!number(opts.zoom)) {
            zoomDefd = false;
          }

          if (!plainObject(opts.pan)) {
            panDefd = false;
          }

          if (!zoomDefd && !panDefd) {
            return this;
          }

          if (zoomDefd) {
            const z = opts.zoom;

            if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {
              zoomFailed = true;
            } else {
              _p.zoom = z;
              events.push('zoom');
            }
          }

          if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {
            const p = opts.pan;

            if (number(p.x)) {
              _p.pan.x = p.x;
              panFailed = false;
            }

            if (number(p.y)) {
              _p.pan.y = p.y;
              panFailed = false;
            }

            if (!panFailed) {
              events.push('pan');
            }
          }

          if (events.length > 0) {
            events.push('viewport');
            this.emit(events.join(' '));
            this.notify('viewport');
          }

          return this; // chaining
        },
        center: function center(elements) {
          const pan = this.getCenterPan(elements);

          if (pan) {
            this._private.pan = pan;
            this.emit('pan viewport');
            this.notify('viewport');
          }

          return this; // chaining
        },
        getCenterPan: function getCenterPan(elements, zoom) {
          if (!this._private.panningEnabled) {
            return;
          }

          if (string(elements)) {
            const selector = elements;
            elements = this.mutableElements().filter(selector);
          } else if (!elementOrCollection(elements)) {
            elements = this.mutableElements();
          }

          if (elements.length === 0) {
            return;
          } // can't centre pan to nothing


          const bb = elements.boundingBox();
          const w = this.width();
          const h = this.height();
          zoom = zoom === undefined ? this._private.zoom : zoom;
          const pan = {
      // middle
            x: (w - zoom * (bb.x1 + bb.x2)) / 2,
            y: (h - zoom * (bb.y1 + bb.y2)) / 2
          };
          return pan;
        },
        reset: function reset() {
          if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
            return this;
          }

          this.viewport({
            pan: {
              x: 0,
              y: 0
            },
            zoom: 1
          });
          return this; // chaining
        },
        invalidateSize: function invalidateSize() {
          this._private.sizeCache = null;
        },
        size: function size() {
          const _p = this._private;
          const container = _p.container;
          return _p.sizeCache = _p.sizeCache || (container ? function () {
            const style = window$1.getComputedStyle(container);

            const val = function val(name) {
              return parseFloat(style.getPropertyValue(name));
            };

            return {
              width: container.clientWidth - val('padding-left') - val('padding-right'),
              height: container.clientHeight - val('padding-top') - val('padding-bottom')
            };
          }() : {
      // fallback if no container (not 0 b/c can be used for dividing etc)
            width: 1,
            height: 1
          });
        },
        width: function width() {
          return this.size().width;
        },
        height: function height() {
          return this.size().height;
        },
        extent: function extent() {
          const pan = this._private.pan;
          const zoom = this._private.zoom;
          const rb = this.renderedExtent();
          const b = {
            x1: (rb.x1 - pan.x) / zoom,
            x2: (rb.x2 - pan.x) / zoom,
            y1: (rb.y1 - pan.y) / zoom,
            y2: (rb.y2 - pan.y) / zoom
          };
          b.w = b.x2 - b.x1;
          b.h = b.y2 - b.y1;
          return b;
        },
        renderedExtent: function renderedExtent() {
          const width = this.width();
          const height = this.height();
          return {
            x1: 0,
            y1: 0,
            x2: width,
            y2: height,
            w: width,
            h: height
          };
        }
      }; // aliases

      corefn$8.centre = corefn$8.center; // backwards compatibility

      corefn$8.autolockNodes = corefn$8.autolock;
      corefn$8.autoungrabifyNodes = corefn$8.autoungrabify;

      const fn$6 = {
        data: define$3.data({
          field: 'data',
          bindingEvent: 'data',
          allowBinding: true,
          allowSetting: true,
          settingEvent: 'data',
          settingTriggersEvent: true,
          triggerFnName: 'trigger',
          allowGetting: true,
          updateStyle: true
        }),
        removeData: define$3.removeData({
          field: 'data',
          event: 'data',
          triggerFnName: 'trigger',
          triggerEvent: true,
          updateStyle: true
        }),
        scratch: define$3.data({
          field: 'scratch',
          bindingEvent: 'scratch',
          allowBinding: true,
          allowSetting: true,
          settingEvent: 'scratch',
          settingTriggersEvent: true,
          triggerFnName: 'trigger',
          allowGetting: true,
          updateStyle: true
        }),
        removeScratch: define$3.removeData({
          field: 'scratch',
          event: 'scratch',
          triggerFnName: 'trigger',
          triggerEvent: true,
          updateStyle: true
        })
      }; // aliases

      fn$6.attr = fn$6.data;
      fn$6.removeAttr = fn$6.removeData;

      const Core = function Core(opts) {
        const cy = this;
        opts = extend({}, opts);
        let container = opts.container; // allow for passing a wrapped jquery object
  // e.g. cytoscape({ container: $('#cy') })

        if (container && !htmlElement(container) && htmlElement(container[0])) {
          container = container[0];
        }

        let reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery

        reg = reg || {};

        if (reg && reg.cy) {
          reg.cy.destroy();
          reg = {}; // old instance => replace reg completely
        }

        const readies = reg.readies = reg.readies || [];

        if (container) {
          container._cyreg = reg;
        } // make sure container assoc'd reg points to this cy


        reg.cy = cy;
        const head = window$1 !== undefined && container !== undefined && !opts.headless;
        const options = opts;
        options.layout = extend({
          name: head ? 'grid' : 'null'
        }, options.layout);
        options.renderer = extend({
          name: head ? 'canvas' : 'null'
        }, options.renderer);

        const defVal = function defVal(def, val, altVal) {
          if (val !== undefined) {
            return val;
          } else if (altVal !== undefined) {
            return altVal;
          } else {
            return def;
          }
        };

        const _p = this._private = {
          container: container,
    // html dom ele container
          ready: false,
    // whether ready has been triggered
          options: options,
    // cached options
          elements: new Collection(this),
    // elements in the graph
          listeners: [],
    // list of listeners
          aniEles: new Collection(this),
    // elements being animated
          data: options.data || {},
    // data for the core
          scratch: {},
    // scratch object for core
          layout: null,
          renderer: null,
          destroyed: false,
    // whether destroy was called
          notificationsEnabled: true,
    // whether notifications are sent to the renderer
          minZoom: 1e-50,
          maxZoom: 1e50,
          zoomingEnabled: defVal(true, options.zoomingEnabled),
          userZoomingEnabled: defVal(true, options.userZoomingEnabled),
          panningEnabled: defVal(true, options.panningEnabled),
          userPanningEnabled: defVal(true, options.userPanningEnabled),
          boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),
          autolock: defVal(false, options.autolock, options.autolockNodes),
          autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
          autounselectify: defVal(false, options.autounselectify),
          styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
          zoom: number(options.zoom) ? options.zoom : 1,
          pan: {
            x: plainObject(options.pan) && number(options.pan.x) ? options.pan.x : 0,
            y: plainObject(options.pan) && number(options.pan.y) ? options.pan.y : 0
          },
          animation: {
      // object for currently-running animations
            current: [],
            queue: []
          },
          hasCompoundNodes: false
        };

        this.createEmitter(); // set selection type

        this.selectionType(options.selectionType); // init zoom bounds

        this.zoomRange({
          min: options.minZoom,
          max: options.maxZoom
        });

        const loadExtData = function loadExtData(extData, next) {
          const anyIsPromise = extData.some(promise);

          if (anyIsPromise) {
            return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init
          } else {
            next(extData); // exec synchronously for convenience
          }
        }; // start with the default stylesheet so we have something before loading an external stylesheet


        if (_p.styleEnabled) {
          cy.setStyle([]);
        } // create the renderer


        const rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options

        cy.initRenderer(rendererOptions);

        const setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {
          cy.notifications(false); // remove old elements

          const oldEles = cy.mutableElements();

          if (oldEles.length > 0) {
            oldEles.remove();
          }

          if (elements != null) {
            if (plainObject(elements) || array(elements)) {
              cy.add(elements);
            }
          }

          cy.one('layoutready', function (e) {
            cy.notifications(true);
            cy.emit(e); // we missed this event by turning notifications off, so pass it on

            cy.one('load', onload);
            cy.emitAndNotify('load');
          }).one('layoutstop', function () {
            cy.one('done', ondone);
            cy.emit('done');
          });
          const layoutOpts = extend({}, cy._private.options.layout);
          layoutOpts.eles = cy.elements();
          cy.layout(layoutOpts).run();
        };

        loadExtData([options.style, options.elements], function (thens) {
          const initStyle = thens[0];
          const initEles = thens[1]; // init style

          if (_p.styleEnabled) {
            cy.style().append(initStyle);
          } // initial load


          setElesAndLayout(initEles, function () {
      // onready
            cy.startAnimationLoop();
            _p.ready = true; // if a ready callback is specified as an option, the bind it

            if (fn(options.ready)) {
              cy.on('ready', options.ready);
            } // bind all the ready handlers registered before creating this instance


            for (let i = 0; i < readies.length; i++) {
              const fn$1 = readies[i];
              cy.on('ready', fn$1);
            }

            if (reg) {
              reg.readies = [];
            } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc


            cy.emit('ready');
          }, options.done);
        });
      };

      const corefn$9 = Core.prototype; // short alias

      extend(corefn$9, {
        instanceString: function instanceString() {
          return 'core';
        },
        isReady: function isReady() {
          return this._private.ready;
        },
        destroyed: function destroyed() {
          return this._private.destroyed;
        },
        ready: function ready(fn) {
          if (this.isReady()) {
            this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event
          } else {
            this.on('ready', fn);
          }

          return this;
        },
        destroy: function destroy() {
          const cy = this;
          if (cy.destroyed()) return;
          cy.stopAnimationLoop();
          cy.destroyRenderer();
          this.emit('destroy');
          cy._private.destroyed = true;
          return cy;
        },
        hasElementWithId: function hasElementWithId(id) {
          return this._private.elements.hasElementWithId(id);
        },
        getElementById: function getElementById(id) {
          return this._private.elements.getElementById(id);
        },
        hasCompoundNodes: function hasCompoundNodes() {
          return this._private.hasCompoundNodes;
        },
        headless: function headless() {
          return this._private.renderer.isHeadless();
        },
        styleEnabled: function styleEnabled() {
          return this._private.styleEnabled;
        },
        addToPool: function addToPool(eles) {
          this._private.elements.merge(eles);

          return this; // chaining
        },
        removeFromPool: function removeFromPool(eles) {
          this._private.elements.unmerge(eles);

          return this;
        },
        container: function container() {
          return this._private.container || null;
        },
        mount: function mount(container) {
          if (container == null) {
            return;
          }

          const cy = this;
          const _p = cy._private;
          const options = _p.options;

          if (!htmlElement(container) && htmlElement(container[0])) {
            container = container[0];
          }

          cy.stopAnimationLoop();
          cy.destroyRenderer();
          _p.container = container;
          _p.styleEnabled = true;
          cy.invalidateSize();
          cy.initRenderer(extend({}, options, options.renderer, {
      // allow custom renderer name to be re-used, otherwise use canvas
            name: options.renderer.name === 'null' ? 'canvas' : options.renderer.name
          }));
          cy.startAnimationLoop();
          cy.style(options.style);
          cy.emit('mount');
          return cy;
        },
        unmount: function unmount() {
          const cy = this;
          cy.stopAnimationLoop();
          cy.destroyRenderer();
          cy.initRenderer({
            name: 'null'
          });
          cy.emit('unmount');
          return cy;
        },
        options: function options() {
          return copy(this._private.options);
        },
        json: function json(obj) {
          const cy = this;
          const _p = cy._private;
          const eles = cy.mutableElements();

          const getFreshRef = function getFreshRef(ele) {
            return cy.getElementById(ele.id());
          };

          if (plainObject(obj)) {
      // set
            cy.startBatch();

            if (obj.elements) {
              const idInJson = {};

              const updateEles = function updateEles(jsons, gr) {
                const toAdd = [];
                const toMod = [];

                for (let i = 0; i < jsons.length; i++) {
                  const json = jsons[i];

                  if (!json.data.id) {
                    warn('cy.json() cannot handle elements without an ID attribute');
                    continue;
                  }

                  const id = '' + json.data.id; // id must be string

                  const ele = cy.getElementById(id);
                  idInJson[id] = true;

                  if (ele.length !== 0) {
              // existing element should be updated
                    toMod.push({
                      ele: ele,
                      json: json
                    });
                  } else {
              // otherwise should be added
                    if (gr) {
                      json.group = gr;
                      toAdd.push(json);
                    } else {
                      toAdd.push(json);
                    }
                  }
                }

                cy.add(toAdd);

                for (let _i = 0; _i < toMod.length; _i++) {
                  const _toMod$_i = toMod[_i],
                    _ele = _toMod$_i.ele,
                    _json = _toMod$_i.json;

                  _ele.json(_json);
                }
              };

              if (array(obj.elements)) {
          // elements: []
                updateEles(obj.elements);
              } else {
          // elements: { nodes: [], edges: [] }
                const grs = ['nodes', 'edges'];

                for (let i = 0; i < grs.length; i++) {
                  const gr = grs[i];
                  const elements = obj.elements[gr];

                  if (array(elements)) {
                    updateEles(elements, gr);
                  }
                }
              }

              const parentsToRemove = cy.collection();
              eles.filter(function (ele) {
                return !idInJson[ele.id()];
              }).forEach(function (ele) {
                if (ele.isParent()) {
                  parentsToRemove.merge(ele);
                } else {
                  ele.remove();
                }
              }); // so that children are not removed w/parent

              parentsToRemove.forEach(function (ele) {
                return ele.children().move({
                  parent: null
                });
              }); // intermediate parents may be moved by prior line, so make sure we remove by fresh refs

              parentsToRemove.forEach(function (ele) {
                return getFreshRef(ele).remove();
              });
            }

            if (obj.style) {
              cy.style(obj.style);
            }

            if (obj.zoom != null && obj.zoom !== _p.zoom) {
              cy.zoom(obj.zoom);
            }

            if (obj.pan) {
              if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {
                cy.pan(obj.pan);
              }
            }

            if (obj.data) {
              cy.data(obj.data);
            }

            const fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify'];

            for (let _i2 = 0; _i2 < fields.length; _i2++) {
              const f = fields[_i2];

              if (obj[f] != null) {
                cy[f](obj[f]);
              }
            }

            cy.endBatch();
            return this; // chaining
          } else {
      // get
            const flat = !!obj;
            const json = {};

            if (flat) {
              json.elements = this.elements().map(function (ele) {
                return ele.json();
              });
            } else {
              json.elements = {};
              eles.forEach(function (ele) {
                const group = ele.group();

                if (!json.elements[group]) {
                  json.elements[group] = [];
                }

                json.elements[group].push(ele.json());
              });
            }

            if (this._private.styleEnabled) {
              json.style = cy.style().json();
            }

            json.data = copy(cy.data());
            const options = _p.options;
            json.zoomingEnabled = _p.zoomingEnabled;
            json.userZoomingEnabled = _p.userZoomingEnabled;
            json.zoom = _p.zoom;
            json.minZoom = _p.minZoom;
            json.maxZoom = _p.maxZoom;
            json.panningEnabled = _p.panningEnabled;
            json.userPanningEnabled = _p.userPanningEnabled;
            json.pan = copy(_p.pan);
            json.boxSelectionEnabled = _p.boxSelectionEnabled;
            json.renderer = copy(options.renderer);
            json.hideEdgesOnViewport = options.hideEdgesOnViewport;
            json.textureOnViewport = options.textureOnViewport;
            json.wheelSensitivity = options.wheelSensitivity;
            json.motionBlur = options.motionBlur;
            return json;
          }
        }
      });
      corefn$9.$id = corefn$9.getElementById;
      [corefn, corefn$1, elesfn$v, corefn$2, corefn$3, corefn$4, corefn$5, corefn$6, corefn$7, corefn$8, fn$6].forEach(function (props) {
        extend(corefn$9, props);
      });

/* eslint-disable no-unused-vars */

      const defaults$9 = {
        fit: true,
  // whether to fit the viewport to the graph
        directed: false,
  // whether the tree is directed downwards (or edges can point in any direction if false)
        padding: 30,
  // padding on fit
        circle: false,
  // put depths in concentric circles if true, put depths top down if false
        grid: false,
  // whether to create an even grid into which the DAG is placed (circle:false only)
        spacingFactor: 1.75,
  // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
        boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
        nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
        roots: undefined,
  // the roots of the trees
        maximal: false,
  // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only)
        animate: false,
  // whether to transition the node positions
        animationDuration: 500,
  // duration of animation in ms if enabled
        animationEasing: undefined,
  // easing of animation if enabled,
        animateFilter: function animateFilter(node, i) {
          return true;
        },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined,
  // callback on layoutready
        stop: undefined,
  // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts

      };
/* eslint-enable */

      const getInfo = function getInfo(ele) {
        return ele.scratch('breadthfirst');
      };

      const setInfo = function setInfo(ele, obj) {
        return ele.scratch('breadthfirst', obj);
      };

      function BreadthFirstLayout(options) {
        this.options = extend({}, defaults$9, options);
      }

      BreadthFirstLayout.prototype.run = function () {
        const params = this.options;
        const options = params;
        const cy = params.cy;
        const eles = options.eles;
        const nodes = eles.nodes().filter(function (n) {
          return !n.isParent();
        });
        const graph = eles;
        const directed = options.directed;
        const maximal = options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code

        const bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0,
          y1: 0,
          w: cy.width(),
          h: cy.height()
        });
        let roots;

        if (elementOrCollection(options.roots)) {
          roots = options.roots;
        } else if (array(options.roots)) {
          const rootsArray = [];

          for (let i = 0; i < options.roots.length; i++) {
            const id = options.roots[i];
            const ele = cy.getElementById(id);
            rootsArray.push(ele);
          }

          roots = cy.collection(rootsArray);
        } else if (string(options.roots)) {
          roots = cy.$(options.roots);
        } else {
          if (directed) {
            roots = nodes.roots();
          } else {
            const components = eles.components();
            roots = cy.collection();

            const _loop = function _loop(_i) {
              const comp = components[_i];
              const maxDegree = comp.maxDegree(false);
              const compRoots = comp.filter(function (ele) {
                return ele.degree(false) === maxDegree;
              });
              roots = roots.add(compRoots);
            };

            for (let _i = 0; _i < components.length; _i++) {
              _loop(_i);
            }
          }
        }

        const depths = [];
        const foundByBfs = {};

        const addToDepth = function addToDepth(ele, d) {
          if (depths[d] == null) {
            depths[d] = [];
          }

          const i = depths[d].length;
          depths[d].push(ele);
          setInfo(ele, {
            index: i,
            depth: d
          });
        };

        const changeDepth = function changeDepth(ele, newDepth) {
          const _getInfo = getInfo(ele),
            depth = _getInfo.depth,
            index = _getInfo.index;

          depths[depth][index] = null;
          addToDepth(ele, newDepth);
        }; // find the depths of the nodes


        graph.bfs({
          roots: roots,
          directed: options.directed,
          visit: function visit(node, edge, pNode, i, depth) {
            const ele = node[0];
            const id = ele.id();
            addToDepth(ele, depth);
            foundByBfs[id] = true;
          }
        }); // check for nodes not found by bfs

        const orphanNodes = [];

        for (let _i2 = 0; _i2 < nodes.length; _i2++) {
          const _ele = nodes[_i2];

          if (foundByBfs[_ele.id()]) {
            continue;
          } else {
            orphanNodes.push(_ele);
          }
        } // assign the nodes a depth and index


        const assignDepthsAt = function assignDepthsAt(i) {
          const eles = depths[i];

          for (let j = 0; j < eles.length; j++) {
            const _ele2 = eles[j];

            if (_ele2 == null) {
              eles.splice(j, 1);
              j--;
              continue;
            }

            setInfo(_ele2, {
              depth: i,
              index: j
            });
          }
        };

        const assignDepths = function assignDepths() {
          for (let _i3 = 0; _i3 < depths.length; _i3++) {
            assignDepthsAt(_i3);
          }
        };

        const adjustMaximally = function adjustMaximally(ele, shifted) {
          const eInfo = getInfo(ele);
          const incomers = ele.incomers().filter(function (el) {
            return el.isNode() && eles.has(el);
          });
          let maxDepth = -1;
          const id = ele.id();

          for (let k = 0; k < incomers.length; k++) {
            const incmr = incomers[k];
            const iInfo = getInfo(incmr);
            maxDepth = Math.max(maxDepth, iInfo.depth);
          }

          if (eInfo.depth <= maxDepth) {
            if (shifted[id]) {
              return null;
            }

            changeDepth(ele, maxDepth + 1);
            shifted[id] = true;
            return true;
          }

          return false;
        }; // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)


        if (directed && maximal) {
          const Q = [];
          const shifted = {};

          const enqueue = function enqueue(n) {
            return Q.push(n);
          };

          const dequeue = function dequeue() {
            return Q.shift();
          };

          nodes.forEach(function (n) {
            return Q.push(n);
          });

          while (Q.length > 0) {
            const _ele3 = dequeue();

            const didShift = adjustMaximally(_ele3, shifted);

            if (didShift) {
              _ele3.outgoers().filter(function (el) {
                return el.isNode() && eles.has(el);
              }).forEach(enqueue);
            } else if (didShift === null) {
              warn('Detected double maximal shift for node `' + _ele3.id() + '`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.');
              break; // exit on failure
            }
          }
        }

        assignDepths(); // clear holes
  // find min distance we need to leave between nodes

        let minDistance = 0;

        if (options.avoidOverlap) {
          for (let _i4 = 0; _i4 < nodes.length; _i4++) {
            const n = nodes[_i4];
            const nbb = n.layoutDimensions(options);
            const w = nbb.w;
            const h = nbb.h;
            minDistance = Math.max(minDistance, w, h);
          }
        } // get the weighted percent for an element based on its connectivity to other levels


        const cachedWeightedPercent = {};

        const getWeightedPercent = function getWeightedPercent(ele) {
          if (cachedWeightedPercent[ele.id()]) {
            return cachedWeightedPercent[ele.id()];
          }

          const eleDepth = getInfo(ele).depth;
          const neighbors = ele.neighborhood();
          let percent = 0;
          let samples = 0;

          for (let _i5 = 0; _i5 < neighbors.length; _i5++) {
            const neighbor = neighbors[_i5];

            if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {
              continue;
            }

            const bf = getInfo(neighbor);

            if (bf == null) {
              continue;
            }

            const index = bf.index;
            const depth = bf.depth; // unassigned neighbours shouldn't affect the ordering

            if (index == null || depth == null) {
              continue;
            }

            const nDepth = depths[depth].length;

            if (depth < eleDepth) {
        // only get influenced by elements above
              percent += index / nDepth;
              samples++;
            }
          }

          samples = Math.max(1, samples);
          percent = percent / samples;

          if (samples === 0) {
      // put lone nodes at the start
            percent = 0;
          }

          cachedWeightedPercent[ele.id()] = percent;
          return percent;
        }; // rearrange the indices in each depth level based on connectivity


        const sortFn = function sortFn(a, b) {
          const apct = getWeightedPercent(a);
          const bpct = getWeightedPercent(b);
          const diff = apct - bpct;

          if (diff === 0) {
            return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons
          } else {
            return diff;
          }
        }; // sort each level to make connected nodes closer


        for (let _i6 = 0; _i6 < depths.length; _i6++) {
          depths[_i6].sort(sortFn);

          assignDepthsAt(_i6);
        } // assign orphan nodes to a new top-level depth


        const orphanDepth = [];

        for (let _i7 = 0; _i7 < orphanNodes.length; _i7++) {
          orphanDepth.push(orphanNodes[_i7]);
        }

        depths.unshift(orphanDepth);
        assignDepths();
        let biggestDepthSize = 0;

        for (let _i8 = 0; _i8 < depths.length; _i8++) {
          biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);
        }

        const center = {
          x: bb.x1 + bb.w / 2,
          y: bb.x1 + bb.h / 2
        };
        const maxDepthSize = depths.reduce(function (max, eles) {
          return Math.max(max, eles.length);
        }, 0);

        const getPosition = function getPosition(ele) {
          const _getInfo2 = getInfo(ele),
            depth = _getInfo2.depth,
            index = _getInfo2.index;

          const depthSize = depths[depth].length;
          const distanceX = Math.max(bb.w / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);
          const distanceY = Math.max(bb.h / (depths.length + 1), minDistance);
          let radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);
          radiusStepSize = Math.max(radiusStepSize, minDistance);

          if (!options.circle) {
            const epos = {
              x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
              y: (depth + 1) * distanceY
            };
            return epos;
          } else {
            let radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
            const theta = 2 * Math.PI / depths[depth].length * index;

            if (depth === 0 && depths[0].length === 1) {
              radius = 1;
            }

            return {
              x: center.x + radius * Math.cos(theta),
              y: center.y + radius * Math.sin(theta)
            };
          }
        };

        eles.nodes().layoutPositions(this, options, getPosition);
        return this; // chaining
      };

      const defaults$a = {
        fit: true,
  // whether to fit the viewport to the graph
        padding: 30,
  // the padding on fit
        boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox and radius if not enough space
        nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
        spacingFactor: undefined,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
        radius: undefined,
  // the radius of the circle
        startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
        sweep: undefined,
  // how many radians should be between the first and last node (defaults to full circle)
        clockwise: true,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
        sort: undefined,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
        animate: false,
  // whether to transition the node positions
        animationDuration: 500,
  // duration of animation in ms if enabled
        animationEasing: undefined,
  // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined,
  // callback on layoutready
        stop: undefined,
  // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts 

      };

      function CircleLayout(options) {
        this.options = extend({}, defaults$a, options);
      }

      CircleLayout.prototype.run = function () {
        const params = this.options;
        const options = params;
        const cy = params.cy;
        const eles = options.eles;
        const clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
        let nodes = eles.nodes().not(':parent');

        if (options.sort) {
          nodes = nodes.sort(options.sort);
        }

        const bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0,
          y1: 0,
          w: cy.width(),
          h: cy.height()
        });
        const center = {
          x: bb.x1 + bb.w / 2,
          y: bb.y1 + bb.h / 2
        };
        const sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;
        const dTheta = sweep / Math.max(1, nodes.length - 1);
        let r;
        let minDistance = 0;

        for (let i = 0; i < nodes.length; i++) {
          const n = nodes[i];
          const nbb = n.layoutDimensions(options);
          const w = nbb.w;
          const h = nbb.h;
          minDistance = Math.max(minDistance, w, h);
        }

        if (number(options.radius)) {
          r = options.radius;
        } else if (nodes.length <= 1) {
          r = 0;
        } else {
          r = Math.min(bb.h, bb.w) / 2 - minDistance;
        } // calculate the radius


        if (nodes.length > 1 && options.avoidOverlap) {
    // but only if more than one node (can't overlap)
          minDistance *= 1.75; // just to have some nice spacing

          const dcos = Math.cos(dTheta) - Math.cos(0);
          const dsin = Math.sin(dTheta) - Math.sin(0);
          const rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping

          r = Math.max(rMin, r);
        }

        const getPos = function getPos(ele, i) {
          const theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);
          const rx = r * Math.cos(theta);
          const ry = r * Math.sin(theta);
          const pos = {
            x: center.x + rx,
            y: center.y + ry
          };
          return pos;
        };

        eles.nodes().layoutPositions(this, options, getPos);
        return this; // chaining
      };

      const defaults$b = {
        fit: true,
  // whether to fit the viewport to the graph
        padding: 30,
  // the padding on fit
        startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
        sweep: undefined,
  // how many radians should be between the first and last node (defaults to full circle)
        clockwise: true,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
        equidistant: false,
  // whether levels have an equal radial distance betwen them, may cause bounding box overflow
        minNodeSpacing: 10,
  // min spacing between outside of nodes (used for radius adjustment)
        boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
        nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
        height: undefined,
  // height of layout area (overrides container height)
        width: undefined,
  // width of layout area (overrides container width)
        spacingFactor: undefined,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
        concentric: function concentric(node) {
    // returns numeric value for each node, placing higher nodes in levels towards the centre
          return node.degree();
        },
        levelWidth: function levelWidth(nodes) {
    // the variation of concentric values in each level
          return nodes.maxDegree() / 4;
        },
        animate: false,
  // whether to transition the node positions
        animationDuration: 500,
  // duration of animation in ms if enabled
        animationEasing: undefined,
  // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined,
  // callback on layoutready
        stop: undefined,
  // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts

      };

      function ConcentricLayout(options) {
        this.options = extend({}, defaults$b, options);
      }

      ConcentricLayout.prototype.run = function () {
        const params = this.options;
        const options = params;
        const clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
        const cy = params.cy;
        const eles = options.eles;
        const nodes = eles.nodes().not(':parent');
        const bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0,
          y1: 0,
          w: cy.width(),
          h: cy.height()
        });
        const center = {
          x: bb.x1 + bb.w / 2,
          y: bb.y1 + bb.h / 2
        };
        const nodeValues = []; // { node, value }

        let maxNodeSize = 0;

        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          let value = void 0; // calculate the node value

          value = options.concentric(node);
          nodeValues.push({
            value: value,
            node: node
          }); // for style mapping

          node._private.scratch.concentric = value;
        } // in case we used the `concentric` in style


        nodes.updateStyle(); // calculate max size now based on potentially updated mappers

        for (let _i = 0; _i < nodes.length; _i++) {
          const _node = nodes[_i];

          const nbb = _node.layoutDimensions(options);

          maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);
        } // sort node values in descreasing order


        nodeValues.sort(function (a, b) {
          return b.value - a.value;
        });
        const levelWidth = options.levelWidth(nodes); // put the values into levels

        const levels = [[]];
        let currentLevel = levels[0];

        for (let _i2 = 0; _i2 < nodeValues.length; _i2++) {
          const val = nodeValues[_i2];

          if (currentLevel.length > 0) {
            const diff = Math.abs(currentLevel[0].value - val.value);

            if (diff >= levelWidth) {
              currentLevel = [];
              levels.push(currentLevel);
            }
          }

          currentLevel.push(val);
        } // create positions from levels


        let minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

        if (!options.avoidOverlap) {
    // then strictly constrain to bb
          const firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
          const maxR = Math.min(bb.w, bb.h) / 2 - minDist;
          const rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);
          minDist = Math.min(minDist, rStep);
        } // find the metrics for each level


        let r = 0;

        for (let _i3 = 0; _i3 < levels.length; _i3++) {
          const level = levels[_i3];
          const sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;
          const dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius

          if (level.length > 1 && options.avoidOverlap) {
      // but only if more than one node (can't overlap)
            const dcos = Math.cos(dTheta) - Math.cos(0);
            const dsin = Math.sin(dTheta) - Math.sin(0);
            const rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping

            r = Math.max(rMin, r);
          }

          level.r = r;
          r += minDist;
        }

        if (options.equidistant) {
          let rDeltaMax = 0;
          let _r = 0;

          for (let _i4 = 0; _i4 < levels.length; _i4++) {
            const _level = levels[_i4];
            const rDelta = _level.r - _r;
            rDeltaMax = Math.max(rDeltaMax, rDelta);
          }

          _r = 0;

          for (let _i5 = 0; _i5 < levels.length; _i5++) {
            const _level2 = levels[_i5];

            if (_i5 === 0) {
              _r = _level2.r;
            }

            _level2.r = _r;
            _r += rDeltaMax;
          }
        } // calculate the node positions


        const pos = {}; // id => position

        for (let _i6 = 0; _i6 < levels.length; _i6++) {
          const _level3 = levels[_i6];
          const _dTheta = _level3.dTheta;
          const _r2 = _level3.r;

          for (let j = 0; j < _level3.length; j++) {
            const _val = _level3[j];
            const theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;
            const p = {
              x: center.x + _r2 * Math.cos(theta),
              y: center.y + _r2 * Math.sin(theta)
            };
            pos[_val.node.id()] = p;
          }
        } // position the nodes


        eles.nodes().layoutPositions(this, options, function (ele) {
          const id = ele.id();
          return pos[id];
        });
        return this; // chaining
      };

/*
The CoSE layout was written by Gerardo Huck.
https://www.linkedin.com/in/gerardohuck/

Based on the following article:
http://dl.acm.org/citation.cfm?id=1498047

Modifications tracked on Github.
*/
      let DEBUG;
/**
 * @brief :  default layout options
 */

      const defaults$c = {
  // Called on `layoutready`
        ready: function ready() {},
  // Called on `layoutstop`
        stop: function stop() {},
  // Whether to animate while running the layout
  // true : Animate continuously as the layout is running
  // false : Just show the end result
  // 'end' : Animate with the end result, from the initial positions to the end positions
        animate: true,
  // Easing of the animation for animate:'end'
        animationEasing: undefined,
  // The duration of the animation for animate:'end'
        animationDuration: undefined,
  // A function that determines whether the node should be animated
  // All nodes animated by default on animate enabled
  // Non-animated nodes are positioned immediately when the layout starts
        animateFilter: function animateFilter(node, i) {
          return true;
        },
  // The layout animates only after this many milliseconds for animate:true
  // (prevents flashing on fast runs)
        animationThreshold: 250,
  // Number of iterations between consecutive screen positions update
        refresh: 20,
  // Whether to fit the network view after when done
        fit: true,
  // Padding on fit
        padding: 30,
  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        boundingBox: undefined,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
        nodeDimensionsIncludeLabels: false,
  // Randomize the initial positions of the nodes (true) or use existing positions (false)
        randomize: false,
  // Extra spacing between components in non-compound graphs
        componentSpacing: 40,
  // Node repulsion (non overlapping) multiplier
        nodeRepulsion: function nodeRepulsion(node) {
          return 2048;
        },
  // Node repulsion (overlapping) multiplier
        nodeOverlap: 4,
  // Ideal edge (non nested) length
        idealEdgeLength: function idealEdgeLength(edge) {
          return 32;
        },
  // Divisor to compute edge forces
        edgeElasticity: function edgeElasticity(edge) {
          return 32;
        },
  // Nesting factor (multiplier) to compute ideal edge length for nested edges
        nestingFactor: 1.2,
  // Gravity force (constant)
        gravity: 1,
  // Maximum number of iterations to perform
        numIter: 1000,
  // Initial temperature (maximum node displacement)
        initialTemp: 1000,
  // Cooling factor (how the temperature is reduced between consecutive iterations
        coolingFactor: 0.99,
  // Lower temperature threshold (below this point the layout will end)
        minTemp: 1.0
      };
/**
 * @brief       : constructor
 * @arg options : object containing layout options
 */

      function CoseLayout(options) {
        this.options = extend({}, defaults$c, options);
        this.options.layout = this;
      }
/**
 * @brief : runs the layout
 */


      CoseLayout.prototype.run = function () {
        const options = this.options;
        const cy = options.cy;
        const layout = this;
        layout.stopped = false;

        if (options.animate === true || options.animate === false) {
          layout.emit({
            type: 'layoutstart',
            layout: layout
          });
        } // Set DEBUG - Global variable


        if (true === options.debug) {
          DEBUG = true;
        } else {
          DEBUG = false;
        } // Initialize layout info


        const layoutInfo = createLayoutInfo(cy, layout, options); // Show LayoutInfo contents if debugging

        if (DEBUG) {
          printLayoutInfo(layoutInfo);
        } // If required, randomize node positions


        if (options.randomize) {
          randomizePositions(layoutInfo);
        }

        const startTime = performanceNow();

        const refresh = function refresh() {
          refreshPositions(layoutInfo, cy, options); // Fit the graph if necessary

          if (true === options.fit) {
            cy.fit(options.padding);
          }
        };

        const mainLoop = function mainLoop(i) {
          if (layout.stopped || i >= options.numIter) {
      // logDebug("Layout manually stopped. Stopping computation in step " + i);
            return false;
          } // Do one step in the phisical simulation


          step$1(layoutInfo, options); // Update temperature

          layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor; // logDebug("New temperature: " + layoutInfo.temperature);

          if (layoutInfo.temperature < options.minTemp) {
      // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
            return false;
          }

          return true;
        };

        const done = function done() {
          if (options.animate === true || options.animate === false) {
            refresh(); // Layout has finished

            layout.one('layoutstop', options.stop);
            layout.emit({
              type: 'layoutstop',
              layout: layout
            });
          } else {
            const nodes = options.eles.nodes();
            const getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);
            nodes.layoutPositions(layout, options, getScaledPos);
          }
        };

        let i = 0;
        let loopRet = true;

        if (options.animate === true) {
          const frame = function frame() {
            let f = 0;

            while (loopRet && f < options.refresh) {
              loopRet = mainLoop(i);
              i++;
              f++;
            }

            if (!loopRet) {
        // it's done
              separateComponents(layoutInfo, options);
              done();
            } else {
              const now = performanceNow();

              if (now - startTime >= options.animationThreshold) {
                refresh();
              }

              requestAnimationFrame(frame);
            }
          };

          frame();
        } else {
          while (loopRet) {
            loopRet = mainLoop(i);
            i++;
          }

          separateComponents(layoutInfo, options);
          done();
        }

        return this; // chaining
      };
/**
 * @brief : called on continuous layouts to stop them before they finish
 */


      CoseLayout.prototype.stop = function () {
        this.stopped = true;

        if (this.thread) {
          this.thread.stop();
        }

        this.emit('layoutstop');
        return this; // chaining
      };

      CoseLayout.prototype.destroy = function () {
        if (this.thread) {
          this.thread.stop();
        }

        return this; // chaining
      };
/**
 * @brief     : Creates an object which is contains all the data
 *              used in the layout process
 * @arg cy    : cytoscape.js object
 * @return    : layoutInfo object initialized
 */


      var createLayoutInfo = function createLayoutInfo(cy, layout, options) {
  // Shortcut
        const edges = options.eles.edges();
        const nodes = options.eles.nodes();
        const layoutInfo = {
          isCompound: cy.hasCompoundNodes(),
          layoutNodes: [],
          idToIndex: {},
          nodeSize: nodes.size(),
          graphSet: [],
          indexToGraph: [],
          layoutEdges: [],
          edgeSize: edges.size(),
          temperature: options.initialTemp,
          clientWidth: cy.width(),
          clientHeight: cy.width(),
          boundingBox: makeBoundingBox(options.boundingBox ? options.boundingBox : {
            x1: 0,
            y1: 0,
            w: cy.width(),
            h: cy.height()
          })
        };
        const components = options.eles.components();
        const id2cmptId = {};

        for (var i = 0; i < components.length; i++) {
          const component = components[i];

          for (var j = 0; j < component.length; j++) {
            var node = component[j];
            id2cmptId[node.id()] = i;
          }
        } // Iterate over all nodes, creating layout nodes


        for (var i = 0; i < layoutInfo.nodeSize; i++) {
          var n = nodes[i];
          const nbb = n.layoutDimensions(options);
          var tempNode = {};
          tempNode.isLocked = n.locked();
          tempNode.id = n.data('id');
          tempNode.parentId = n.data('parent');
          tempNode.cmptId = id2cmptId[n.id()];
          tempNode.children = [];
          tempNode.positionX = n.position('x');
          tempNode.positionY = n.position('y');
          tempNode.offsetX = 0;
          tempNode.offsetY = 0;
          tempNode.height = nbb.w;
          tempNode.width = nbb.h;
          tempNode.maxX = tempNode.positionX + tempNode.width / 2;
          tempNode.minX = tempNode.positionX - tempNode.width / 2;
          tempNode.maxY = tempNode.positionY + tempNode.height / 2;
          tempNode.minY = tempNode.positionY - tempNode.height / 2;
          tempNode.padLeft = parseFloat(n.style('padding'));
          tempNode.padRight = parseFloat(n.style('padding'));
          tempNode.padTop = parseFloat(n.style('padding'));
          tempNode.padBottom = parseFloat(n.style('padding')); // forces

          tempNode.nodeRepulsion = fn(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion; // Add new node

          layoutInfo.layoutNodes.push(tempNode); // Add entry to id-index map

          layoutInfo.idToIndex[tempNode.id] = i;
        } // Inline implementation of a queue, used for traversing the graph in BFS order


        const queue = [];
        let start = 0; // Points to the start the queue

        let end = -1; // Points to the end of the queue

        const tempGraph = []; // Second pass to add child information and
  // initialize queue for hierarchical traversal

        for (var i = 0; i < layoutInfo.nodeSize; i++) {
          var n = layoutInfo.layoutNodes[i];
          const p_id = n.parentId; // Check if node n has a parent node

          if (null != p_id) {
      // Add node Id to parent's list of children
            layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
          } else {
      // If a node doesn't have a parent, then it's in the root graph
            queue[++end] = n.id;
            tempGraph.push(n.id);
          }
        } // Add root graph to graphSet


        layoutInfo.graphSet.push(tempGraph); // Traverse the graph, level by level,

        while (start <= end) {
    // Get the node to visit and remove it from queue
          const node_id = queue[start++];
          const node_ix = layoutInfo.idToIndex[node_id];
          var node = layoutInfo.layoutNodes[node_ix];
          const children = node.children;

          if (children.length > 0) {
      // Add children nodes as a new graph to graph set
            layoutInfo.graphSet.push(children); // Add children to que queue to be visited

            for (var i = 0; i < children.length; i++) {
              queue[++end] = children[i];
            }
          }
        } // Create indexToGraph map


        for (var i = 0; i < layoutInfo.graphSet.length; i++) {
          const graph = layoutInfo.graphSet[i];

          for (var j = 0; j < graph.length; j++) {
            const index = layoutInfo.idToIndex[graph[j]];
            layoutInfo.indexToGraph[index] = i;
          }
        } // Iterate over all edges, creating Layout Edges


        for (var i = 0; i < layoutInfo.edgeSize; i++) {
          const e = edges[i];
          const tempEdge = {};
          tempEdge.id = e.data('id');
          tempEdge.sourceId = e.data('source');
          tempEdge.targetId = e.data('target'); // Compute ideal length

          let idealLength = fn(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;
          const elasticity = fn(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity; // Check if it's an inter graph edge

          const sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];
          const targetIx = layoutInfo.idToIndex[tempEdge.targetId];
          const sourceGraph = layoutInfo.indexToGraph[sourceIx];
          const targetGraph = layoutInfo.indexToGraph[targetIx];

          if (sourceGraph != targetGraph) {
      // Find lowest common graph ancestor
            const lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo); // Compute sum of node depths, relative to lca graph

            const lcaGraph = layoutInfo.graphSet[lca];
            let depth = 0; // Source depth

            var tempNode = layoutInfo.layoutNodes[sourceIx];

            while (-1 === lcaGraph.indexOf(tempNode.id)) {
              tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
              depth++;
            } // Target depth


            tempNode = layoutInfo.layoutNodes[targetIx];

            while (-1 === lcaGraph.indexOf(tempNode.id)) {
              tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
              depth++;
            } // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
      //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
      //  ". Depth: " + depth);
      // Update idealLength


            idealLength *= depth * options.nestingFactor;
          }

          tempEdge.idealLength = idealLength;
          tempEdge.elasticity = elasticity;
          layoutInfo.layoutEdges.push(tempEdge);
        } // Finally, return layoutInfo object


        return layoutInfo;
      };
/**
 * @brief : This function finds the index of the lowest common
 *          graph ancestor between 2 nodes in the subtree
 *          (from the graph hierarchy induced tree) whose
 *          root is graphIx
 *
 * @arg node1: node1's ID
 * @arg node2: node2's ID
 * @arg layoutInfo: layoutInfo object
 *
 */


      var findLCA = function findLCA(node1, node2, layoutInfo) {
  // Find their common ancester, starting from the root graph
        const res = findLCA_aux(node1, node2, 0, layoutInfo);

        if (2 > res.count) {
    // If aux function couldn't find the common ancester,
    // then it is the root graph
          return 0;
        } else {
          return res.graph;
        }
      };
/**
 * @brief          : Auxiliary function used for LCA computation
 *
 * @arg node1      : node1's ID
 * @arg node2      : node2's ID
 * @arg graphIx    : subgraph index
 * @arg layoutInfo : layoutInfo object
 *
 * @return         : object of the form {count: X, graph: Y}, where:
 *                   X is the number of ancesters (max: 2) found in
 *                   graphIx (and it's subgraphs),
 *                   Y is the graph index of the lowest graph containing
 *                   all X nodes
 */


      var findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {
        const graph = layoutInfo.graphSet[graphIx]; // If both nodes belongs to graphIx

        if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {
          return {
            count: 2,
            graph: graphIx
          };
        } // Make recursive calls for all subgraphs


        let c = 0;

        for (let i = 0; i < graph.length; i++) {
          const nodeId = graph[i];
          const nodeIx = layoutInfo.idToIndex[nodeId];
          const children = layoutInfo.layoutNodes[nodeIx].children; // If the node has no child, skip it

          if (0 === children.length) {
            continue;
          }

          const childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
          const result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);

          if (0 === result.count) {
      // Neither node1 nor node2 are present in this subgraph
            continue;
          } else if (1 === result.count) {
      // One of (node1, node2) is present in this subgraph
            c++;

            if (2 === c) {
        // We've already found both nodes, no need to keep searching
              break;
            }
          } else {
      // Both nodes are present in this subgraph
            return result;
          }
        }

        return {
          count: c,
          graph: graphIx
        };
      };
/**
 * @brief: printsLayoutInfo into js console
 *         Only used for debbuging
 */


      if (false) { var printLayoutInfo; }
/**
 * @brief : Randomizes the position of all nodes
 */


      var randomizePositions = function randomizePositions(layoutInfo, cy) {
        const width = layoutInfo.clientWidth;
        const height = layoutInfo.clientHeight;

        for (let i = 0; i < layoutInfo.nodeSize; i++) {
          const n = layoutInfo.layoutNodes[i]; // No need to randomize compound nodes or locked nodes

          if (0 === n.children.length && !n.isLocked) {
            n.positionX = Math.random() * width;
            n.positionY = Math.random() * height;
          }
        }
      };

      var getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {
        const bb = layoutInfo.boundingBox;
        const coseBB = {
          x1: Infinity,
          x2: -Infinity,
          y1: Infinity,
          y2: -Infinity
        };

        if (options.boundingBox) {
          nodes.forEach(function (node) {
            const lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];
            coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);
            coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);
            coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);
            coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);
          });
          coseBB.w = coseBB.x2 - coseBB.x1;
          coseBB.h = coseBB.y2 - coseBB.y1;
        }

        return function (ele, i) {
          const lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];

          if (options.boundingBox) {
      // then add extra bounding box constraint
            const pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
            const pctY = (lnode.positionY - coseBB.y1) / coseBB.h;
            return {
              x: bb.x1 + pctX * bb.w,
              y: bb.y1 + pctY * bb.h
            };
          } else {
            return {
              x: lnode.positionX,
              y: lnode.positionY
            };
          }
        };
      };
/**
 * @brief          : Updates the positions of nodes in the network
 * @arg layoutInfo : LayoutInfo object
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */


      var refreshPositions = function refreshPositions(layoutInfo, cy, options) {
  // var s = 'Refreshing positions';
  // logDebug(s);
        const layout = options.layout;
        const nodes = options.eles.nodes();
        const getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);
        nodes.positions(getScaledPos); // Trigger layoutReady only on first call

        if (true !== layoutInfo.ready) {
    // s = 'Triggering layoutready';
    // logDebug(s);
          layoutInfo.ready = true;
          layout.one('layoutready', options.ready);
          layout.emit({
            type: 'layoutready',
            layout: this
          });
        }
      };
/**
 * @brief : Logs a debug message in JS console, if DEBUG is ON
 */
// var logDebug = function(text) {
//   if (DEBUG) {
//     console.debug(text);
//   }
// };

/**
 * @brief          : Performs one iteration of the physical simulation
 * @arg layoutInfo : LayoutInfo object already initialized
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */


      var step$1 = function step(layoutInfo, options, _step) {
  // var s = "\n\n###############################";
  // s += "\nSTEP: " + step;
  // s += "\n###############################\n";
  // logDebug(s);
  // Calculate node repulsions
        calculateNodeForces(layoutInfo, options); // Calculate edge forces

        calculateEdgeForces(layoutInfo); // Calculate gravity forces

        calculateGravityForces(layoutInfo, options); // Propagate forces from parent to child

        propagateForces(layoutInfo); // Update positions based on calculated forces

        updatePositions(layoutInfo);
      };
/**
 * @brief : Computes the node repulsion forces
 */


      var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {
  // Go through each of the graphs in graphSet
  // Nodes only repel each other if they belong to the same graph
  // var s = 'calculateNodeForces';
  // logDebug(s);
        for (let i = 0; i < layoutInfo.graphSet.length; i++) {
          const graph = layoutInfo.graphSet[i];
          const numNodes = graph.length; // s = "Set: " + graph.toString();
    // logDebug(s);
    // Now get all the pairs of nodes
    // Only get each pair once, (A, B) = (B, A)

          for (let j = 0; j < numNodes; j++) {
            const node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];

            for (let k = j + 1; k < numNodes; k++) {
              const node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];
              nodeRepulsion(node1, node2, layoutInfo, options);
            }
          }
        }
      };

      const randomDistance = function randomDistance(max) {
        return -max + 2 * max * Math.random();
      };
/**
 * @brief : Compute the node repulsion forces between a pair of nodes
 */


      var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {
  // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;
        const cmptId1 = node1.cmptId;
        const cmptId2 = node2.cmptId;

        if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {
          return;
        } // Get direction of line connecting both node centers


        let directionX = node2.positionX - node1.positionX;
        let directionY = node2.positionY - node1.positionY;
        const maxRandDist = 1; // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;
  // If both centers are the same, apply a random force

        if (0 === directionX && 0 === directionY) {
          directionX = randomDistance(maxRandDist);
          directionY = randomDistance(maxRandDist);
        }

        const overlap = nodesOverlap(node1, node2, directionX, directionY);

        if (overlap > 0) {
    // s += "\nNodes DO overlap.";
    // s += "\nOverlap: " + overlap;
    // If nodes overlap, repulsion force is proportional
    // to the overlap
          var force = options.nodeOverlap * overlap; // Compute the module and components of the force vector

          var distance = Math.sqrt(directionX * directionX + directionY * directionY); // s += "\nDistance: " + distance;

          var forceX = force * directionX / distance;
          var forceY = force * directionY / distance;
        } else {
    // s += "\nNodes do NOT overlap.";
    // If there's no overlap, force is inversely proportional
    // to squared distance
    // Get clipping points for both nodes
          const point1 = findClippingPoint(node1, directionX, directionY);
          const point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY); // Use clipping points to compute distance

          const distanceX = point2.x - point1.x;
          const distanceY = point2.y - point1.y;
          const distanceSqr = distanceX * distanceX + distanceY * distanceY;
          var distance = Math.sqrt(distanceSqr); // s += "\nDistance: " + distance;
    // Compute the module and components of the force vector

          var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;
          var forceX = force * distanceX / distance;
          var forceY = force * distanceY / distance;
        } // Apply force


        if (!node1.isLocked) {
          node1.offsetX -= forceX;
          node1.offsetY -= forceY;
        }

        if (!node2.isLocked) {
          node2.offsetX += forceX;
          node2.offsetY += forceY;
        } // s += "\nForceX: " + forceX + " ForceY: " + forceY;
  // logDebug(s);


        return;
      };
/**
 * @brief  : Determines whether two nodes overlap or not
 * @return : Amount of overlapping (0 => no overlap)
 */


      var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {
        if (dX > 0) {
          var overlapX = node1.maxX - node2.minX;
        } else {
          var overlapX = node2.maxX - node1.minX;
        }

        if (dY > 0) {
          var overlapY = node1.maxY - node2.minY;
        } else {
          var overlapY = node2.maxY - node1.minY;
        }

        if (overlapX >= 0 && overlapY >= 0) {
          return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
        } else {
          return 0;
        }
      };
/**
 * @brief : Finds the point in which an edge (direction dX, dY) intersects
 *          the rectangular bounding box of it's source/target node
 */


      var findClippingPoint = function findClippingPoint(node, dX, dY) {
  // Shorcuts
        const X = node.positionX;
        const Y = node.positionY;
        const H = node.height || 1;
        const W = node.width || 1;
        const dirSlope = dY / dX;
        const nodeSlope = H / W; // var s = 'Computing clipping point of node ' + node.id +
  //   " . Height:  " + H + ", Width: " + W +
  //   "\nDirection " + dX + ", " + dY;
  //
  // Compute intersection

        const res = {}; // Case: Vertical direction (up)

        if (0 === dX && 0 < dY) {
          res.x = X; // s += "\nUp direction";

          res.y = Y + H / 2;
          return res;
        } // Case: Vertical direction (down)


        if (0 === dX && 0 > dY) {
          res.x = X;
          res.y = Y + H / 2; // s += "\nDown direction";

          return res;
        } // Case: Intersects the right border


        if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
          res.x = X + W / 2;
          res.y = Y + W * dY / 2 / dX; // s += "\nRightborder";

          return res;
        } // Case: Intersects the left border


        if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
          res.x = X - W / 2;
          res.y = Y - W * dY / 2 / dX; // s += "\nLeftborder";

          return res;
        } // Case: Intersects the top border


        if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
          res.x = X + H * dX / 2 / dY;
          res.y = Y + H / 2; // s += "\nTop border";

          return res;
        } // Case: Intersects the bottom border


        if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
          res.x = X - H * dX / 2 / dY;
          res.y = Y - H / 2; // s += "\nBottom border";

          return res;
        } // s += "\nClipping point found at " + res.x + ", " + res.y;
  // logDebug(s);


        return res;
      };
/**
 * @brief : Calculates all edge forces
 */


      var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {
  // Iterate over all edges
        for (let i = 0; i < layoutInfo.edgeSize; i++) {
    // Get edge, source & target nodes
          const edge = layoutInfo.layoutEdges[i];
          const sourceIx = layoutInfo.idToIndex[edge.sourceId];
          const source = layoutInfo.layoutNodes[sourceIx];
          const targetIx = layoutInfo.idToIndex[edge.targetId];
          const target = layoutInfo.layoutNodes[targetIx]; // Get direction of line connecting both node centers

          const directionX = target.positionX - source.positionX;
          const directionY = target.positionY - source.positionY; // If both centers are the same, do nothing.
    // A random force has already been applied as node repulsion

          if (0 === directionX && 0 === directionY) {
            continue;
          } // Get clipping points for both nodes


          const point1 = findClippingPoint(source, directionX, directionY);
          const point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);
          const lx = point2.x - point1.x;
          const ly = point2.y - point1.y;
          const l = Math.sqrt(lx * lx + ly * ly);
          const force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;

          if (0 !== l) {
            var forceX = force * lx / l;
            var forceY = force * ly / l;
          } else {
            var forceX = 0;
            var forceY = 0;
          } // Add this force to target and source nodes


          if (!source.isLocked) {
            source.offsetX += forceX;
            source.offsetY += forceY;
          }

          if (!target.isLocked) {
            target.offsetX -= forceX;
            target.offsetY -= forceY;
          } // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
    // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
    // logDebug(s);

        }
      };
/**
 * @brief : Computes gravity forces for all nodes
 */


      var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {
        const distThreshold = 1; // var s = 'calculateGravityForces';
  // logDebug(s);

        for (let i = 0; i < layoutInfo.graphSet.length; i++) {
          const graph = layoutInfo.graphSet[i];
          const numNodes = graph.length; // s = "Set: " + graph.toString();
    // logDebug(s);
    // Compute graph center

          if (0 === i) {
            var centerX = layoutInfo.clientHeight / 2;
            var centerY = layoutInfo.clientWidth / 2;
          } else {
      // Get Parent node for this graph, and use its position as center
            const temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
            const parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
            var centerX = parent.positionX;
            var centerY = parent.positionY;
          } // s = "Center found at: " + centerX + ", " + centerY;
    // logDebug(s);
    // Apply force to all nodes in graph


          for (let j = 0; j < numNodes; j++) {
            const node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]]; // s = "Node: " + node.id;

            if (node.isLocked) {
              continue;
            }

            const dx = centerX - node.positionX;
            const dy = centerY - node.positionY;
            const d = Math.sqrt(dx * dx + dy * dy);

            if (d > distThreshold) {
              const fx = options.gravity * dx / d;
              const fy = options.gravity * dy / d;
              node.offsetX += fx;
              node.offsetY += fy; // s += ": Applied force: " + fx + ", " + fy;
            } // s += ": skypped since it's too close to center";
        // logDebug(s);

          }
        }
      };
/**
 * @brief          : This function propagates the existing offsets from
 *                   parent nodes to its descendents.
 * @arg layoutInfo : layoutInfo Object
 * @arg cy         : cytoscape Object
 * @arg options    : Layout options
 */


      var propagateForces = function propagateForces(layoutInfo, options) {
  // Inline implementation of a queue, used for traversing the graph in BFS order
        const queue = [];
        let start = 0; // Points to the start the queue

        let end = -1; // Points to the end of the queue
  // logDebug('propagateForces');
  // Start by visiting the nodes in the root graph

        queue.push.apply(queue, layoutInfo.graphSet[0]);
        end += layoutInfo.graphSet[0].length; // Traverse the graph, level by level,

        while (start <= end) {
    // Get the node to visit and remove it from queue
          const nodeId = queue[start++];
          const nodeIndex = layoutInfo.idToIndex[nodeId];
          const node = layoutInfo.layoutNodes[nodeIndex];
          const children = node.children; // We only need to process the node if it's compound

          if (0 < children.length && !node.isLocked) {
            const offX = node.offsetX;
            const offY = node.offsetY; // var s = "Propagating offset from parent node : " + node.id +
      //   ". OffsetX: " + offX + ". OffsetY: " + offY;
      // s += "\n Children: " + children.toString();
      // logDebug(s);

            for (let i = 0; i < children.length; i++) {
              const childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]]; // Propagate offset

              childNode.offsetX += offX;
              childNode.offsetY += offY; // Add children to queue to be visited

              queue[++end] = children[i];
            } // Reset parent offsets


            node.offsetX = 0;
            node.offsetY = 0;
          }
        }
      };
/**
 * @brief : Updates the layout model positions, based on
 *          the accumulated forces
 */


      var updatePositions = function updatePositions(layoutInfo, options) {
  // var s = 'Updating positions';
  // logDebug(s);
  // Reset boundaries for compound nodes
        for (var i = 0; i < layoutInfo.nodeSize; i++) {
          var n = layoutInfo.layoutNodes[i];

          if (0 < n.children.length) {
      // logDebug("Resetting boundaries of compound node: " + n.id);
            n.maxX = undefined;
            n.minX = undefined;
            n.maxY = undefined;
            n.minY = undefined;
          }
        }

        for (var i = 0; i < layoutInfo.nodeSize; i++) {
          var n = layoutInfo.layoutNodes[i];

          if (0 < n.children.length || n.isLocked) {
      // No need to set compound or locked node position
      // logDebug("Skipping position update of node: " + n.id);
            continue;
          } // s = "Node: " + n.id + " Previous position: (" +
    // n.positionX + ", " + n.positionY + ").";
    // Limit displacement in order to improve stability


          const tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
          n.positionX += tempForce.x;
          n.positionY += tempForce.y;
          n.offsetX = 0;
          n.offsetY = 0;
          n.minX = n.positionX - n.width;
          n.maxX = n.positionX + n.width;
          n.minY = n.positionY - n.height;
          n.maxY = n.positionY + n.height; // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
    // logDebug(s);
    // Update ancestry boudaries

          updateAncestryBoundaries(n, layoutInfo);
        } // Update size, position of compund nodes


        for (var i = 0; i < layoutInfo.nodeSize; i++) {
          var n = layoutInfo.layoutNodes[i];

          if (0 < n.children.length && !n.isLocked) {
            n.positionX = (n.maxX + n.minX) / 2;
            n.positionY = (n.maxY + n.minY) / 2;
            n.width = n.maxX - n.minX;
            n.height = n.maxY - n.minY; // s = "Updating position, size of compound node " + n.id;
      // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
      // s += "\nWidth: " + n.width + ", Height: " + n.height;
      // logDebug(s);
          }
        }
      };
/**
 * @brief : Limits a force (forceX, forceY) to be not
 *          greater (in modulo) than max.
 8          Preserves force direction.
  */


      var limitForce = function limitForce(forceX, forceY, max) {
  // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
        const force = Math.sqrt(forceX * forceX + forceY * forceY);

        if (force > max) {
          var res = {
            x: max * forceX / force,
            y: max * forceY / force
          };
        } else {
          var res = {
            x: forceX,
            y: forceY
          };
        } // s += ".\nResult: (" + res.x + ", " + res.y + ")";
  // logDebug(s);


        return res;
      };
/**
 * @brief : Function used for keeping track of compound node
 *          sizes, since they should bound all their subnodes.
 */


      var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {
  // var s = "Propagating new position/size of node " + node.id;
        const parentId = node.parentId;

        if (null == parentId) {
    // If there's no parent, we are done
    // s += ". No parent node.";
    // logDebug(s);
          return;
        } // Get Parent Node


        const p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
        let flag = false; // MaxX

        if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
          p.maxX = node.maxX + p.padRight;
          flag = true; // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
        } // MinX


        if (null == p.minX || node.minX - p.padLeft < p.minX) {
          p.minX = node.minX - p.padLeft;
          flag = true; // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
        } // MaxY


        if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
          p.maxY = node.maxY + p.padBottom;
          flag = true; // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
        } // MinY


        if (null == p.minY || node.minY - p.padTop < p.minY) {
          p.minY = node.minY - p.padTop;
          flag = true; // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
        } // If updated boundaries, propagate changes upward


        if (flag) {
    // logDebug(s);
          return updateAncestryBoundaries(p, layoutInfo);
        } // s += ". No changes in boundaries/position of parent node " + p.id;
  // logDebug(s);


        return;
      };

      var separateComponents = function separateComponents(layoutInfo, options) {
        const nodes = layoutInfo.layoutNodes;
        const components = [];

        for (var i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          const cid = node.cmptId;
          const component = components[cid] = components[cid] || [];
          component.push(node);
        }

        let totalA = 0;

        for (var i = 0; i < components.length; i++) {
          var c = components[i];

          if (!c) {
            continue;
          }

          c.x1 = Infinity;
          c.x2 = -Infinity;
          c.y1 = Infinity;
          c.y2 = -Infinity;

          for (var j = 0; j < c.length; j++) {
            var n = c[j];
            c.x1 = Math.min(c.x1, n.positionX - n.width / 2);
            c.x2 = Math.max(c.x2, n.positionX + n.width / 2);
            c.y1 = Math.min(c.y1, n.positionY - n.height / 2);
            c.y2 = Math.max(c.y2, n.positionY + n.height / 2);
          }

          c.w = c.x2 - c.x1;
          c.h = c.y2 - c.y1;
          totalA += c.w * c.h;
        }

        components.sort(function (c1, c2) {
          return c2.w * c2.h - c1.w * c1.h;
        });
        let x = 0;
        let y = 0;
        let usedW = 0;
        let rowH = 0;
        const maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;

        for (var i = 0; i < components.length; i++) {
          var c = components[i];

          if (!c) {
            continue;
          }

          for (var j = 0; j < c.length; j++) {
            var n = c[j];

            if (!n.isLocked) {
              n.positionX += x - c.x1;
              n.positionY += y - c.y1;
            }
          }

          x += c.w + options.componentSpacing;
          usedW += c.w + options.componentSpacing;
          rowH = Math.max(rowH, c.h);

          if (usedW > maxRowW) {
            y += rowH + options.componentSpacing;
            x = 0;
            usedW = 0;
            rowH = 0;
          }
        }
      };

      const defaults$d = {
        fit: true,
  // whether to fit the viewport to the graph
        padding: 30,
  // padding used on fit
        boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
        avoidOverlapPadding: 10,
  // extra spacing around nodes when avoidOverlap: true
        nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
        spacingFactor: undefined,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
        condense: false,
  // uses all available space on false, uses minimal space on true
        rows: undefined,
  // force num of rows in the grid
        cols: undefined,
  // force num of columns in the grid
        position: function position(node) {},
  // returns { row, col } for element
        sort: undefined,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
        animate: false,
  // whether to transition the node positions
        animationDuration: 500,
  // duration of animation in ms if enabled
        animationEasing: undefined,
  // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined,
  // callback on layoutready
        stop: undefined,
  // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts 

      };

      function GridLayout(options) {
        this.options = extend({}, defaults$d, options);
      }

      GridLayout.prototype.run = function () {
        const params = this.options;
        const options = params;
        const cy = params.cy;
        const eles = options.eles;
        let nodes = eles.nodes().not(':parent');

        if (options.sort) {
          nodes = nodes.sort(options.sort);
        }

        const bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0,
          y1: 0,
          w: cy.width(),
          h: cy.height()
        });

        if (bb.h === 0 || bb.w === 0) {
          eles.nodes().layoutPositions(this, options, function (ele) {
            return {
              x: bb.x1,
              y: bb.y1
            };
          });
        } else {
    // width/height * splits^2 = cells where splits is number of times to split width
          const cells = nodes.size();
          const splits = Math.sqrt(cells * bb.h / bb.w);
          let rows = Math.round(splits);
          let cols = Math.round(bb.w / bb.h * splits);

          const small = function small(val) {
            if (val == null) {
              return Math.min(rows, cols);
            } else {
              const min = Math.min(rows, cols);

              if (min == rows) {
                rows = val;
              } else {
                cols = val;
              }
            }
          };

          const large = function large(val) {
            if (val == null) {
              return Math.max(rows, cols);
            } else {
              const max = Math.max(rows, cols);

              if (max == rows) {
                rows = val;
              } else {
                cols = val;
              }
            }
          };

          const oRows = options.rows;
          const oCols = options.cols != null ? options.cols : options.columns; // if rows or columns were set in options, use those values

          if (oRows != null && oCols != null) {
            rows = oRows;
            cols = oCols;
          } else if (oRows != null && oCols == null) {
            rows = oRows;
            cols = Math.ceil(cells / rows);
          } else if (oRows == null && oCols != null) {
            cols = oCols;
            rows = Math.ceil(cells / cols);
          } // otherwise use the automatic values and adjust accordingly
    // if rounding was up, see if we can reduce rows or columns
          else if (cols * rows > cells) {
            const sm = small();
            const lg = large(); // reducing the small side takes away the most cells, so try it first

            if ((sm - 1) * lg >= cells) {
              small(sm - 1);
            } else if ((lg - 1) * sm >= cells) {
              large(lg - 1);
            }
          } else {
        // if rounding was too low, add rows or columns
            while (cols * rows < cells) {
              const _sm = small();

              const _lg = large(); // try to add to larger side first (adds less in multiplication)


              if ((_lg + 1) * _sm >= cells) {
                large(_lg + 1);
              } else {
                small(_sm + 1);
              }
            }
          }

          let cellWidth = bb.w / cols;
          let cellHeight = bb.h / rows;

          if (options.condense) {
            cellWidth = 0;
            cellHeight = 0;
          }

          if (options.avoidOverlap) {
            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              const pos = node._private.position;

              if (pos.x == null || pos.y == null) {
          // for bb
                pos.x = 0;
                pos.y = 0;
              }

              const nbb = node.layoutDimensions(options);
              const p = options.avoidOverlapPadding;
              const w = nbb.w + p;
              const h = nbb.h + p;
              cellWidth = Math.max(cellWidth, w);
              cellHeight = Math.max(cellHeight, h);
            }
          }

          const cellUsed = {}; // e.g. 'c-0-2' => true

          const used = function used(row, col) {
            return cellUsed['c-' + row + '-' + col] ? true : false;
          };

          const use = function use(row, col) {
            cellUsed['c-' + row + '-' + col] = true;
          }; // to keep track of current cell position


          let row = 0;
          let col = 0;

          const moveToNextCell = function moveToNextCell() {
            col++;

            if (col >= cols) {
              col = 0;
              row++;
            }
          }; // get a cache of all the manual positions


          const id2manPos = {};

          for (let _i = 0; _i < nodes.length; _i++) {
            const _node = nodes[_i];
            const rcPos = options.position(_node);

            if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
        // must have at least row or col def'd
              const _pos = {
                row: rcPos.row,
                col: rcPos.col
              };

              if (_pos.col === undefined) {
          // find unused col
                _pos.col = 0;

                while (used(_pos.row, _pos.col)) {
                  _pos.col++;
                }
              } else if (_pos.row === undefined) {
          // find unused row
                _pos.row = 0;

                while (used(_pos.row, _pos.col)) {
                  _pos.row++;
                }
              }

              id2manPos[_node.id()] = _pos;
              use(_pos.row, _pos.col);
            }
          }

          const getPos = function getPos(element, i) {
            let x, y;

            if (element.locked() || element.isParent()) {
              return false;
            } // see if we have a manual position set


            const rcPos = id2manPos[element.id()];

            if (rcPos) {
              x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
              y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;
            } else {
        // otherwise set automatically
              while (used(row, col)) {
                moveToNextCell();
              }

              x = col * cellWidth + cellWidth / 2 + bb.x1;
              y = row * cellHeight + cellHeight / 2 + bb.y1;
              use(row, col);
              moveToNextCell();
            }

            return {
              x: x,
              y: y
            };
          };

          nodes.layoutPositions(this, options, getPos);
        }

        return this; // chaining
      };

      const defaults$e = {
        ready: function ready() {},
  // on layoutready
        stop: function stop() {} // on layoutstop

      }; // constructor
// options : object containing layout options

      function NullLayout(options) {
        this.options = extend({}, defaults$e, options);
      } // runs the layout


      NullLayout.prototype.run = function () {
        const options = this.options;
        const eles = options.eles; // elements to consider in the layout

        const layout = this; // cy is automatically populated for us in the constructor
  // (disable eslint for next line as this serves as example layout code to external developers)
  // eslint-disable-next-line no-unused-vars

        const cy = options.cy;
        layout.emit('layoutstart'); // puts all nodes at (0, 0)
  // n.b. most layouts would use layoutPositions(), instead of positions() and manual events

        eles.nodes().positions(function () {
          return {
            x: 0,
            y: 0
          };
        }); // trigger layoutready when each node has had its position set at least once

        layout.one('layoutready', options.ready);
        layout.emit('layoutready'); // trigger layoutstop when the layout stops (e.g. finishes)

        layout.one('layoutstop', options.stop);
        layout.emit('layoutstop');
        return this; // chaining
      }; // called on continuous layouts to stop them before they finish


      NullLayout.prototype.stop = function () {
        return this; // chaining
      };

      const defaults$f = {
        positions: undefined,
  // map of (node id) => (position obj); or function(node){ return somPos; }
        zoom: undefined,
  // the zoom level to set (prob want fit = false if set)
        pan: undefined,
  // the pan level to set (prob want fit = false if set)
        fit: true,
  // whether to fit to viewport
        padding: 30,
  // padding on fit
        animate: false,
  // whether to transition the node positions
        animationDuration: 500,
  // duration of animation in ms if enabled
        animationEasing: undefined,
  // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined,
  // callback on layoutready
        stop: undefined,
  // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts

      };

      function PresetLayout(options) {
        this.options = extend({}, defaults$f, options);
      }

      PresetLayout.prototype.run = function () {
        const options = this.options;
        const eles = options.eles;
        const nodes = eles.nodes();
        const posIsFn = fn(options.positions);

        function getPosition(node) {
          if (options.positions == null) {
            return copyPosition(node.position());
          }

          if (posIsFn) {
            return options.positions(node);
          }

          const pos = options.positions[node._private.data.id];

          if (pos == null) {
            return null;
          }

          return pos;
        }

        nodes.layoutPositions(this, options, function (node, i) {
          const position = getPosition(node);

          if (node.locked() || position == null) {
            return false;
          }

          return position;
        });
        return this; // chaining
      };

      const defaults$g = {
        fit: true,
  // whether to fit to viewport
        padding: 30,
  // fit padding
        boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
        animate: false,
  // whether to transition the node positions
        animationDuration: 500,
  // duration of animation in ms if enabled
        animationEasing: undefined,
  // easing of animation if enabled
        animateFilter: function animateFilter(node, i) {
          return true;
        },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
        ready: undefined,
  // callback on layoutready
        stop: undefined,
  // callback on layoutstop
        transform: function transform(node, position) {
          return position;
        } // transform a given node position. Useful for changing flow direction in discrete layouts 

      };

      function RandomLayout(options) {
        this.options = extend({}, defaults$g, options);
      }

      RandomLayout.prototype.run = function () {
        const options = this.options;
        const cy = options.cy;
        const eles = options.eles;
        const bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
          x1: 0,
          y1: 0,
          w: cy.width(),
          h: cy.height()
        });

        const getPos = function getPos(node, i) {
          return {
            x: bb.x1 + Math.round(Math.random() * bb.w),
            y: bb.y1 + Math.round(Math.random() * bb.h)
          };
        };

        eles.nodes().layoutPositions(this, options, getPos);
        return this; // chaining
      };

      const layout = [{
        name: 'breadthfirst',
        impl: BreadthFirstLayout
      }, {
        name: 'circle',
        impl: CircleLayout
      }, {
        name: 'concentric',
        impl: ConcentricLayout
      }, {
        name: 'cose',
        impl: CoseLayout
      }, {
        name: 'grid',
        impl: GridLayout
      }, {
        name: 'null',
        impl: NullLayout
      }, {
        name: 'preset',
        impl: PresetLayout
      }, {
        name: 'random',
        impl: RandomLayout
      }];

      function NullRenderer(options) {
        this.options = options;
        this.notifications = 0; // for testing
      }

      const noop$1 = function noop() {};

      const throwImgErr = function throwImgErr() {
        throw new Error('A headless instance can not render images');
      };

      NullRenderer.prototype = {
        recalculateRenderedStyle: noop$1,
        notify: function notify() {
          this.notifications++;
        },
        init: noop$1,
        isHeadless: function isHeadless() {
          return true;
        },
        png: throwImgErr,
        jpg: throwImgErr
      };

      const BRp = {};
      BRp.arrowShapeWidth = 0.3;

      BRp.registerArrowShapes = function () {
        const arrowShapes = this.arrowShapes = {};
        const renderer = this; // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

        const bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {
          const x1 = translation.x - size / 2 - padding;
          const x2 = translation.x + size / 2 + padding;
          const y1 = translation.y - size / 2 - padding;
          const y2 = translation.y + size / 2 + padding;
          const inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;
          return inside;
        };

        const transform = function transform(x, y, size, angle, translation) {
          const xRotated = x * Math.cos(angle) - y * Math.sin(angle);
          const yRotated = x * Math.sin(angle) + y * Math.cos(angle);
          const xScaled = xRotated * size;
          const yScaled = yRotated * size;
          const xTranslated = xScaled + translation.x;
          const yTranslated = yScaled + translation.y;
          return {
            x: xTranslated,
            y: yTranslated
          };
        };

        const transformPoints = function transformPoints(pts, size, angle, translation) {
          const retPts = [];

          for (let i = 0; i < pts.length; i += 2) {
            const x = pts[i];
            const y = pts[i + 1];
            retPts.push(transform(x, y, size, angle, translation));
          }

          return retPts;
        };

        const pointsToArr = function pointsToArr(pts) {
          const ret = [];

          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            ret.push(p.x, p.y);
          }

          return ret;
        };

        const standardGap = function standardGap(edge) {
          return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;
        };

        const defineArrowShape = function defineArrowShape(name, defn) {
          if (string(defn)) {
            defn = arrowShapes[defn];
          }

          arrowShapes[name] = extend({
            name: name,
            points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],
            collide: function collide(x, y, size, angle, translation, padding) {
              const points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
              const inside = pointInsidePolygonPoints(x, y, points);
              return inside;
            },
            roughCollide: bbCollide,
            draw: function draw(context, size, angle, translation) {
              const points = transformPoints(this.points, size, angle, translation);
              renderer.arrowShapeImpl('polygon')(context, points);
            },
            spacing: function spacing(edge) {
              return 0;
            },
            gap: standardGap
          }, defn);
        };

        defineArrowShape('none', {
          collide: falsify,
          roughCollide: falsify,
          draw: noop,
          spacing: zeroify,
          gap: zeroify
        });
        defineArrowShape('triangle', {
          points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
        });
        defineArrowShape('arrow', 'triangle');
        defineArrowShape('triangle-backcurve', {
          points: arrowShapes['triangle'].points,
          controlPoint: [0, -0.15],
          roughCollide: bbCollide,
          draw: function draw(context, size, angle, translation, edgeWidth) {
            const ptsTrans = transformPoints(this.points, size, angle, translation);
            const ctrlPt = this.controlPoint;
            const ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);
            renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);
          },
          gap: function gap(edge) {
            return standardGap(edge) * 0.8;
          }
        });
        defineArrowShape('triangle-tee', {
          points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
          pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],
          collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            const triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
            const teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));
            const inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);
            return inside;
          },
          draw: function draw(context, size, angle, translation, edgeWidth) {
            const triPts = transformPoints(this.points, size, angle, translation);
            const teePts = transformPoints(this.pointsTee, size, angle, translation);
            renderer.arrowShapeImpl(this.name)(context, triPts, teePts);
          }
        });
        defineArrowShape('circle-triangle', {
          radius: 0.15,
          pointsTr: [0, -0.15, 0.15, -0.45, -0.15, -0.45, 0, -0.15],
          collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            const t = translation;
            const circleInside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);
            const triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
            return pointInsidePolygonPoints(x, y, triPts) || circleInside;
          },
          draw: function draw(context, size, angle, translation, edgeWidth) {
            const triPts = transformPoints(this.pointsTr, size, angle, translation);
            renderer.arrowShapeImpl(this.name)(context, triPts, translation.x, translation.y, this.radius * size);
          },
          spacing: function spacing(edge) {
            return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;
          }
        });
        defineArrowShape('triangle-cross', {
          points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
          baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle
            -0.15, -0.4, 0.15, -0.4, // second half of the rectangle
            0.15, -0.4],
          crossLinePts: function crossLinePts(size, edgeWidth) {
      // shift points so that the distance between the cross points matches edge width
            const p = this.baseCrossLinePts.slice();
            const shiftFactor = edgeWidth / size;
            const y0 = 3;
            const y1 = 5;
            p[y0] = p[y0] - shiftFactor;
            p[y1] = p[y1] - shiftFactor;
            return p;
          },
          collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            const triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
            const teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));
            const inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);
            return inside;
          },
          draw: function draw(context, size, angle, translation, edgeWidth) {
            const triPts = transformPoints(this.points, size, angle, translation);
            const crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);
            renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);
          }
        });
        defineArrowShape('vee', {
          points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],
          gap: function gap(edge) {
            return standardGap(edge) * 0.525;
          }
        });
        defineArrowShape('circle', {
          radius: 0.15,
          collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
            const t = translation;
            const inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);
            return inside;
          },
          draw: function draw(context, size, angle, translation, edgeWidth) {
            renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);
          },
          spacing: function spacing(edge) {
            return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;
          }
        });
        defineArrowShape('tee', {
          points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],
          spacing: function spacing(edge) {
            return 1;
          },
          gap: function gap(edge) {
            return 1;
          }
        });
        defineArrowShape('square', {
          points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]
        });
        defineArrowShape('diamond', {
          points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],
          gap: function gap(edge) {
            return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
          }
        });
        defineArrowShape('chevron', {
          points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],
          gap: function gap(edge) {
            return 0.95 * edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
          }
        });
      };

      const BRp$1 = {}; // Project mouse

      BRp$1.projectIntoViewport = function (clientX, clientY) {
        const cy = this.cy;
        const offsets = this.findContainerClientCoords();
        const offsetLeft = offsets[0];
        const offsetTop = offsets[1];
        const scale = offsets[4];
        const pan = cy.pan();
        const zoom = cy.zoom();
        const x = ((clientX - offsetLeft) / scale - pan.x) / zoom;
        const y = ((clientY - offsetTop) / scale - pan.y) / zoom;
        return [x, y];
      };

      BRp$1.findContainerClientCoords = function () {
        if (this.containerBB) {
          return this.containerBB;
        }

        const container = this.container;
        const rect = container.getBoundingClientRect();
        const style = window$1.getComputedStyle(container);

        const styleValue = function styleValue(name) {
          return parseFloat(style.getPropertyValue(name));
        };

        const padding = {
          left: styleValue('padding-left'),
          right: styleValue('padding-right'),
          top: styleValue('padding-top'),
          bottom: styleValue('padding-bottom')
        };
        const border = {
          left: styleValue('border-left-width'),
          right: styleValue('border-right-width'),
          top: styleValue('border-top-width'),
          bottom: styleValue('border-bottom-width')
        };
        const clientWidth = container.clientWidth;
        const clientHeight = container.clientHeight;
        const paddingHor = padding.left + padding.right;
        const paddingVer = padding.top + padding.bottom;
        const borderHor = border.left + border.right;
        const scale = rect.width / (clientWidth + borderHor);
        const unscaledW = clientWidth - paddingHor;
        const unscaledH = clientHeight - paddingVer;
        const left = rect.left + padding.left + border.left;
        const top = rect.top + padding.top + border.top;
        return this.containerBB = [left, top, unscaledW, unscaledH, scale];
      };

      BRp$1.invalidateContainerClientCoordsCache = function () {
        this.containerBB = null;
      };

      BRp$1.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {
        return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];
      };

      BRp$1.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {
        const self = this;
        const r = this;
        let eles = r.getCachedZSortedEles();
        const near = []; // 1 node max, 1 edge max

        const zoom = r.cy.zoom();
        const hasCompounds = r.cy.hasCompoundNodes();
        const edgeThreshold = (isTouch ? 24 : 8) / zoom;
        const nodeThreshold = (isTouch ? 8 : 2) / zoom;
        const labelThreshold = (isTouch ? 8 : 2) / zoom;
        let minSqDist = Infinity;
        let nearEdge;
        let nearNode;

        if (interactiveElementsOnly) {
          eles = eles.interactive;
        }

        function addEle(ele, sqDist) {
          if (ele.isNode()) {
            if (nearNode) {
              return; // can't replace node
            } else {
              nearNode = ele;
              near.push(ele);
            }
          }

          if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {
            if (nearEdge) {
        // then replace existing edge
        // can replace only if same z-index
              if (nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value && nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value) {
                for (let i = 0; i < near.length; i++) {
                  if (near[i].isEdge()) {
                    near[i] = ele;
                    nearEdge = ele;
                    minSqDist = sqDist != null ? sqDist : minSqDist;
                    break;
                  }
                }
              }
            } else {
              near.push(ele);
              nearEdge = ele;
              minSqDist = sqDist != null ? sqDist : minSqDist;
            }
          }
        }

        function checkNode(node) {
          const width = node.outerWidth() + 2 * nodeThreshold;
          const height = node.outerHeight() + 2 * nodeThreshold;
          const hw = width / 2;
          const hh = height / 2;
          const pos = node.position();

          if (pos.x - hw <= x && x <= pos.x + hw // bb check x
    && pos.y - hh <= y && y <= pos.y + hh // bb check y
          ) {
            const shape = r.nodeShapes[self.getNodeShape(node)];

            if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {
              addEle(node, 0);
              return true;
            }
          }
        }

        function checkEdge(edge) {
          const _p = edge._private;
          const rs = _p.rscratch;
          const styleWidth = edge.pstyle('width').pfValue;
          const scale = edge.pstyle('arrow-scale').value;
          const width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre

          const widthSq = width * width;
          const width2 = width * 2;
          var src = _p.source;
          var tgt = _p.target;
          let sqDist;

          if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {
            var pts = rs.allpts;

            for (var i = 0; i + 3 < pts.length; i += 2) {
              if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {
                addEle(edge, sqDist);
                return true;
              }
            }
          } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
            var pts = rs.allpts;

            for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
              if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {
                addEle(edge, sqDist);
                return true;
              }
            }
          } // if we're close to the edge but didn't hit it, maybe we hit its arrows


          var src = src || _p.source;
          var tgt = tgt || _p.target;
          const arSize = self.getArrowWidth(styleWidth, scale);
          const arrows = [{
            name: 'source',
            x: rs.arrowStartX,
            y: rs.arrowStartY,
            angle: rs.srcArrowAngle
          }, {
            name: 'target',
            x: rs.arrowEndX,
            y: rs.arrowEndY,
            angle: rs.tgtArrowAngle
          }, {
            name: 'mid-source',
            x: rs.midX,
            y: rs.midY,
            angle: rs.midsrcArrowAngle
          }, {
            name: 'mid-target',
            x: rs.midX,
            y: rs.midY,
            angle: rs.midtgtArrowAngle
          }];

          for (var i = 0; i < arrows.length; i++) {
            const ar = arrows[i];
            const shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];
            const edgeWidth = edge.pstyle('width').pfValue;

            if (shape.roughCollide(x, y, arSize, ar.angle, {
              x: ar.x,
              y: ar.y
            }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {
              x: ar.x,
              y: ar.y
            }, edgeWidth, edgeThreshold)) {
              addEle(edge);
              return true;
            }
          } // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)


          if (hasCompounds && near.length > 0) {
            checkNode(src);
            checkNode(tgt);
          }
        }

        function preprop(obj, name, pre) {
          return getPrefixedProperty(obj, name, pre);
        }

        function checkLabel(ele, prefix) {
          const _p = ele._private;
          const th = labelThreshold;
          let prefixDash;

          if (prefix) {
            prefixDash = prefix + '-';
          } else {
            prefixDash = '';
          }

          ele.boundingBox();
          const bb = _p.labelBounds[prefix || 'main'];
          const text = ele.pstyle(prefixDash + 'label').value;
          const eventsEnabled = ele.pstyle('text-events').strValue === 'yes';

          if (!eventsEnabled || !text) {
            return;
          }

          const lx = preprop(_p.rscratch, 'labelX', prefix);
          const ly = preprop(_p.rscratch, 'labelY', prefix);
          const theta = preprop(_p.rscratch, 'labelAngle', prefix);
          const ox = ele.pstyle(prefixDash + 'text-margin-x').pfValue;
          const oy = ele.pstyle(prefixDash + 'text-margin-y').pfValue;
          const lx1 = bb.x1 - th - ox; // (-ox, -oy) as bb already includes margin

          const lx2 = bb.x2 + th - ox; // and rotation is about (lx, ly)

          const ly1 = bb.y1 - th - oy;
          const ly2 = bb.y2 + th - oy;

          if (theta) {
            const cos = Math.cos(theta);
            const sin = Math.sin(theta);

            const rotate = function rotate(x, y) {
              x = x - lx;
              y = y - ly;
              return {
                x: x * cos - y * sin + lx,
                y: x * sin + y * cos + ly
              };
            };

            const px1y1 = rotate(lx1, ly1);
            const px1y2 = rotate(lx1, ly2);
            const px2y1 = rotate(lx2, ly1);
            const px2y2 = rotate(lx2, ly2);
            const points = [// with the margin added after the rotation is applied
              px1y1.x + ox, px1y1.y + oy, px2y1.x + ox, px2y1.y + oy, px2y2.x + ox, px2y2.y + oy, px1y2.x + ox, px1y2.y + oy];

            if (pointInsidePolygonPoints(x, y, points)) {
              addEle(ele);
              return true;
            }
          } else {
      // do a cheaper bb check
            if (inBoundingBox(bb, x, y)) {
              addEle(ele);
              return true;
            }
          }
        }

        for (let i = eles.length - 1; i >= 0; i--) {
    // reverse order for precedence
          const ele = eles[i];

          if (ele.isNode()) {
            checkNode(ele) || checkLabel(ele);
          } else {
      // then edge
            checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');
          }
        }

        return near;
      }; // 'Give me everything from this box'


      BRp$1.getAllInBox = function (x1, y1, x2, y2) {
        const eles = this.getCachedZSortedEles().interactive;
        const box = [];
        const x1c = Math.min(x1, x2);
        const x2c = Math.max(x1, x2);
        const y1c = Math.min(y1, y2);
        const y2c = Math.max(y1, y2);
        x1 = x1c;
        x2 = x2c;
        y1 = y1c;
        y2 = y2c;
        const boxBb = makeBoundingBox({
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        });

        for (let e = 0; e < eles.length; e++) {
          const ele = eles[e];

          if (ele.isNode()) {
            const node = ele;
            const nodeBb = node.boundingBox({
              includeNodes: true,
              includeEdges: false,
              includeLabels: false
            });

            if (boundingBoxesIntersect(boxBb, nodeBb) && !boundingBoxInBoundingBox(nodeBb, boxBb)) {
              box.push(node);
            }
          } else {
            const edge = ele;
            const _p = edge._private;
            const rs = _p.rscratch;

            if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {
              continue;
            }

            if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {
              continue;
            }

            if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {
              const pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
              let allInside = true;

              for (let i = 0; i < pts.length; i++) {
                if (!pointInBoundingBox(boxBb, pts[i])) {
                  allInside = false;
                  break;
                }
              }

              if (allInside) {
                box.push(edge);
              }
            } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {
              box.push(edge);
            }
          }
        }

        return box;
      };

      const BRp$2 = {};

      BRp$2.calculateArrowAngles = function (edge) {
        const rs = edge._private.rscratch;
        const isHaystack = rs.edgeType === 'haystack';
        const isBezier = rs.edgeType === 'bezier';
        const isMultibezier = rs.edgeType === 'multibezier';
        const isSegments = rs.edgeType === 'segments';
        const isCompound = rs.edgeType === 'compound';
        const isSelf = rs.edgeType === 'self'; // Displacement gives direction for arrowhead orientation

        let dispX, dispY;
        var startX, startY, endX, endY, midX, midY;

        if (isHaystack) {
          startX = rs.haystackPts[0];
          startY = rs.haystackPts[1];
          endX = rs.haystackPts[2];
          endY = rs.haystackPts[3];
        } else {
          startX = rs.arrowStartX;
          startY = rs.arrowStartY;
          endX = rs.arrowEndX;
          endY = rs.arrowEndY;
        }

        midX = rs.midX;
        midY = rs.midY; // source
  //

        if (isSegments) {
          dispX = startX - rs.segpts[0];
          dispY = startY - rs.segpts[1];
        } else if (isMultibezier || isCompound || isSelf || isBezier) {
          var pts = rs.allpts;
          var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);
          var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);
          dispX = startX - bX;
          dispY = startY - bY;
        } else {
          dispX = startX - midX;
          dispY = startY - midY;
        }

        rs.srcArrowAngle = getAngleFromDisp(dispX, dispY); // mid target
  //

        var midX = rs.midX;
        var midY = rs.midY;

        if (isHaystack) {
          midX = (startX + endX) / 2;
          midY = (startY + endY) / 2;
        }

        dispX = endX - startX;
        dispY = endY - startY;

        if (isSegments) {
          var pts = rs.allpts;

          if (pts.length / 2 % 2 === 0) {
            var i2 = pts.length / 2;
            var i1 = i2 - 2;
            dispX = pts[i2] - pts[i1];
            dispY = pts[i2 + 1] - pts[i1 + 1];
          } else {
            var i2 = pts.length / 2 - 1;
            var i1 = i2 - 2;
            var i3 = i2 + 2;
            dispX = pts[i2] - pts[i1];
            dispY = pts[i2 + 1] - pts[i1 + 1];
          }
        } else if (isMultibezier || isCompound || isSelf) {
          var pts = rs.allpts;
          const cpts = rs.ctrlpts;
          let bp0x, bp0y;
          let bp1x, bp1y;

          if (cpts.length / 2 % 2 === 0) {
            var p0 = pts.length / 2 - 1; // startpt

            var ic = p0 + 2;
            var p1 = ic + 2;
            bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);
            bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);
            bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);
            bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);
          } else {
            var ic = pts.length / 2 - 1; // ctrpt

            var p0 = ic - 2; // startpt

            var p1 = ic + 2; // endpt

            bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);
            bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);
            bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);
            bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);
          }

          dispX = bp1x - bp0x;
          dispY = bp1y - bp0y;
        }

        rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);
        rs.midDispX = dispX;
        rs.midDispY = dispY; // mid source
  //

        dispX *= -1;
        dispY *= -1;

        if (isSegments) {
          var pts = rs.allpts;

          if (pts.length / 2 % 2 === 0) ; else {
            var i2 = pts.length / 2 - 1;
            var i3 = i2 + 2;
            dispX = -(pts[i3] - pts[i2]);
            dispY = -(pts[i3 + 1] - pts[i2 + 1]);
          }
        }

        rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY); // target
  //

        if (isSegments) {
          dispX = endX - rs.segpts[rs.segpts.length - 2];
          dispY = endY - rs.segpts[rs.segpts.length - 1];
        } else if (isMultibezier || isCompound || isSelf || isBezier) {
          var pts = rs.allpts;
          const l = pts.length;
          var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);
          var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);
          dispX = endX - bX;
          dispY = endY - bY;
        } else {
          dispX = endX - midX;
          dispY = endY - midY;
        }

        rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);
      };

      BRp$2.getArrowWidth = BRp$2.getArrowHeight = function (edgeWidth, scale) {
        const cache = this.arrowWidthCache = this.arrowWidthCache || {};
        let cachedVal = cache[edgeWidth + ', ' + scale];

        if (cachedVal) {
          return cachedVal;
        }

        cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;
        cache[edgeWidth + ', ' + scale] = cachedVal;
        return cachedVal;
      };

      const BRp$3 = {};

      BRp$3.findHaystackPoints = function (edges) {
        for (let i = 0; i < edges.length; i++) {
          const edge = edges[i];
          const _p = edge._private;
          const rs = _p.rscratch;

          if (!rs.haystack) {
            let angle = Math.random() * 2 * Math.PI;
            rs.source = {
              x: Math.cos(angle),
              y: Math.sin(angle)
            };
            angle = Math.random() * 2 * Math.PI;
            rs.target = {
              x: Math.cos(angle),
              y: Math.sin(angle)
            };
          }

          const src = _p.source;
          const tgt = _p.target;
          const srcPos = src.position();
          const tgtPos = tgt.position();
          const srcW = src.width();
          const tgtW = tgt.width();
          const srcH = src.height();
          const tgtH = tgt.height();
          const radius = edge.pstyle('haystack-radius').value;
          const halfRadius = radius / 2; // b/c have to half width/height

          rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];
          rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
          rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2; // always override as haystack in case set to different type previously

          rs.edgeType = 'haystack';
          rs.haystack = true;
          this.storeEdgeProjections(edge);
          this.calculateArrowAngles(edge);
          this.recalculateEdgeLabelProjections(edge);
          this.calculateLabelAngles(edge);
        }
      };

      BRp$3.findSegmentsPoints = function (edge, pairInfo) {
  // Segments (multiple straight lines)
        const rs = edge._private.rscratch;
        const posPts = pairInfo.posPts,
          intersectionPts = pairInfo.intersectionPts,
          vectorNormInverse = pairInfo.vectorNormInverse;
        const edgeDistances = edge.pstyle('edge-distances').value;
        const segmentWs = edge.pstyle('segment-weights');
        const segmentDs = edge.pstyle('segment-distances');
        const segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);
        rs.edgeType = 'segments';
        rs.segpts = [];

        for (let s = 0; s < segmentsN; s++) {
          const w = segmentWs.pfValue[s];
          const d = segmentDs.pfValue[s];
          const w1 = 1 - w;
          const w2 = w;
          const midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;
          const adjustedMidpt = {
            x: midptPts.x1 * w1 + midptPts.x2 * w2,
            y: midptPts.y1 * w1 + midptPts.y2 * w2
          };
          rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);
        }
      };

      BRp$3.findLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {
  // Self-edge
        const rs = edge._private.rscratch;
        const dirCounts = pairInfo.dirCounts,
          srcPos = pairInfo.srcPos;
        const ctrlptDists = edge.pstyle('control-point-distances');
        const ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
        const loopDir = edge.pstyle('loop-direction').pfValue;
        const loopSwp = edge.pstyle('loop-sweep').pfValue;
        const stepSize = edge.pstyle('control-point-step-size').pfValue;
        rs.edgeType = 'self';
        let j = i;
        let loopDist = stepSize;

        if (edgeIsUnbundled) {
          j = 0;
          loopDist = ctrlptDist;
        }

        const loopAngle = loopDir - Math.PI / 2;
        const outAngle = loopAngle - loopSwp / 2;
        const inAngle = loopAngle + loopSwp / 2; // increase by step size for overlapping loops, keyed on direction and sweep values

        const dc = String(loopDir + '_' + loopSwp);
        j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];
        rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];
      };

      BRp$3.findCompoundLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {
  // Compound edge
        const rs = edge._private.rscratch;
        rs.edgeType = 'compound';
        const srcPos = pairInfo.srcPos,
          tgtPos = pairInfo.tgtPos,
          srcW = pairInfo.srcW,
          srcH = pairInfo.srcH,
          tgtW = pairInfo.tgtW,
          tgtH = pairInfo.tgtH;
        const stepSize = edge.pstyle('control-point-step-size').pfValue;
        const ctrlptDists = edge.pstyle('control-point-distances');
        const ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
        let j = i;
        let loopDist = stepSize;

        if (edgeIsUnbundled) {
          j = 0;
          loopDist = ctrlptDist;
        }

        const loopW = 50;
        const loopaPos = {
          x: srcPos.x - srcW / 2,
          y: srcPos.y - srcH / 2
        };
        const loopbPos = {
          x: tgtPos.x - tgtW / 2,
          y: tgtPos.y - tgtH / 2
        };
        const loopPos = {
          x: Math.min(loopaPos.x, loopbPos.x),
          y: Math.min(loopaPos.y, loopbPos.y)
        }; // avoids cases with impossible beziers

        const minCompoundStretch = 0.5;
        const compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));
        const compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));
        rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];
      };

      BRp$3.findStraightEdgePoints = function (edge) {
  // Straight edge within bundle
        edge._private.rscratch.edgeType = 'straight';
      };

      BRp$3.findBezierPoints = function (edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {
        const rs = edge._private.rscratch;
        const vectorNormInverse = pairInfo.vectorNormInverse,
          posPts = pairInfo.posPts,
          intersectionPts = pairInfo.intersectionPts;
        const edgeDistances = edge.pstyle('edge-distances').value;
        const stepSize = edge.pstyle('control-point-step-size').pfValue;
        const ctrlptDists = edge.pstyle('control-point-distances');
        const ctrlptWs = edge.pstyle('control-point-weights');
        const bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;
        let ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
        let ctrlptWeight = ctrlptWs.value[0]; // (Multi)bezier

        const multi = edgeIsUnbundled;
        rs.edgeType = multi ? 'multibezier' : 'bezier';
        rs.ctrlpts = [];

        for (let b = 0; b < bezierN; b++) {
          const normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);
          let manctrlptDist = void 0;
          const sign = signum(normctrlptDist);

          if (multi) {
            ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size

            ctrlptWeight = ctrlptWs.value[b];
          }

          if (edgeIsUnbundled) {
      // multi or single unbundled
            manctrlptDist = ctrlptDist;
          } else {
            manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
          }

          const distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;
          const w1 = 1 - ctrlptWeight;
          const w2 = ctrlptWeight;
          const midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;
          const adjustedMidpt = {
            x: midptPts.x1 * w1 + midptPts.x2 * w2,
            y: midptPts.y1 * w1 + midptPts.y2 * w2
          };
          rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);
        }
      };

      BRp$3.findTaxiPoints = function (edge, pairInfo) {
  // Taxicab geometry with two turns maximum
        const rs = edge._private.rscratch;
        rs.edgeType = 'segments';
        const VERTICAL = 'vertical';
        const HORIZONTAL = 'horizontal';
        const LEFTWARD = 'leftward';
        const RIGHTWARD = 'rightward';
        const DOWNWARD = 'downward';
        const UPWARD = 'upward';
        const AUTO = 'auto';
        const posPts = pairInfo.posPts,
          srcW = pairInfo.srcW,
          srcH = pairInfo.srcH,
          tgtW = pairInfo.tgtW,
          tgtH = pairInfo.tgtH;
        const edgeDistances = edge.pstyle('edge-distances').value;
        const dIncludesNodeBody = edgeDistances !== 'node-position';
        let taxiDir = edge.pstyle('taxi-direction').value;
        const rawTaxiDir = taxiDir; // unprocessed value

        const taxiTurn = edge.pstyle('taxi-turn');
        const turnIsPercent = taxiTurn.units === '%';
        const taxiTurnPfVal = taxiTurn.pfValue;
        const turnIsNegative = taxiTurnPfVal < 0; // i.e. from target side

        const minD = edge.pstyle('taxi-turn-min-distance').pfValue;
        const dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;
        const dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;
        const pdx = posPts.x2 - posPts.x1;
        const pdy = posPts.y2 - posPts.y1; // take away the effective w/h from the magnitude of the delta value

        const subDWH = function subDWH(dxy, dwh) {
          if (dxy > 0) {
            return Math.max(dxy - dwh, 0);
          } else {
            return Math.min(dxy + dwh, 0);
          }
        };

        const dx = subDWH(pdx, dw);
        const dy = subDWH(pdy, dh);
        let isExplicitDir = false;

        if (rawTaxiDir === AUTO) {
          taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;
        } else if (rawTaxiDir === UPWARD || rawTaxiDir === DOWNWARD) {
          taxiDir = VERTICAL;
          isExplicitDir = true;
        } else if (rawTaxiDir === LEFTWARD || rawTaxiDir === RIGHTWARD) {
          taxiDir = HORIZONTAL;
          isExplicitDir = true;
        }

        const isVert = taxiDir === VERTICAL;
        let l = isVert ? dy : dx;
        const pl = isVert ? pdy : pdx;
        let sgnL = signum(pl);
        let forcedDir = false;

        if (!(isExplicitDir && (turnIsPercent || turnIsNegative)) // forcing in this case would cause weird growing in the opposite direction
  && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {
          sgnL *= -1;
          l = sgnL * Math.abs(l);
          forcedDir = true;
        }

        let d;

        if (turnIsPercent) {
          const p = taxiTurnPfVal < 0 ? 1 + taxiTurnPfVal : taxiTurnPfVal;
          d = p * l;
        } else {
          const k = taxiTurnPfVal < 0 ? l : 0;
          d = k + taxiTurnPfVal * sgnL;
        }

        const getIsTooClose = function getIsTooClose(d) {
          return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);
        };

        const isTooCloseSrc = getIsTooClose(d);
        const isTooCloseTgt = getIsTooClose(Math.abs(l) - Math.abs(d));
        const isTooClose = isTooCloseSrc || isTooCloseTgt;

        if (isTooClose && !forcedDir) {
    // non-ideal routing
          if (isVert) {
      // vertical fallbacks
            const lShapeInsideSrc = Math.abs(pl) <= srcH / 2;
            const lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;

            if (lShapeInsideSrc) {
        // horizontal Z-shape (direction not respected)
              const x = (posPts.x1 + posPts.x2) / 2;
              const y1 = posPts.y1,
                y2 = posPts.y2;
              rs.segpts = [x, y1, x, y2];
            } else if (lShapeInsideTgt) {
        // vertical Z-shape (distance not respected)
              const y = (posPts.y1 + posPts.y2) / 2;
              const x1 = posPts.x1,
                x2 = posPts.x2;
              rs.segpts = [x1, y, x2, y];
            } else {
        // L-shape fallback (turn distance not respected, but works well with tree siblings)
              rs.segpts = [posPts.x1, posPts.y2];
            }
          } else {
      // horizontal fallbacks
            const _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;

            const _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;

            if (_lShapeInsideSrc) {
        // vertical Z-shape (direction not respected)
              const _y = (posPts.y1 + posPts.y2) / 2;

              const _x = posPts.x1,
                _x2 = posPts.x2;
              rs.segpts = [_x, _y, _x2, _y];
            } else if (_lShapeInsideTgt) {
        // horizontal Z-shape (turn distance not respected)
              const _x3 = (posPts.x1 + posPts.x2) / 2;

              const _y2 = posPts.y1,
                _y3 = posPts.y2;
              rs.segpts = [_x3, _y2, _x3, _y3];
            } else {
        // L-shape (turn distance not respected, but works well for tree siblings)
              rs.segpts = [posPts.x2, posPts.y1];
            }
          }
        } else {
    // ideal routing
          if (isVert) {
            const _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);

            const _x4 = posPts.x1,
              _x5 = posPts.x2;
            rs.segpts = [_x4, _y4, _x5, _y4];
          } else {
      // horizontal
            const _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);

            const _y5 = posPts.y1,
              _y6 = posPts.y2;
            rs.segpts = [_x6, _y5, _x6, _y6];
          }
        }
      };

      BRp$3.tryToCorrectInvalidPoints = function (edge, pairInfo) {
        const rs = edge._private.rscratch; // can only correct beziers for now...

        if (rs.edgeType === 'bezier') {
          const srcPos = pairInfo.srcPos,
            tgtPos = pairInfo.tgtPos,
            srcW = pairInfo.srcW,
            srcH = pairInfo.srcH,
            tgtW = pairInfo.tgtW,
            tgtH = pairInfo.tgtH,
            srcShape = pairInfo.srcShape,
            tgtShape = pairInfo.tgtShape;
          const badStart = !number(rs.startX) || !number(rs.startY);
          const badAStart = !number(rs.arrowStartX) || !number(rs.arrowStartY);
          const badEnd = !number(rs.endX) || !number(rs.endY);
          const badAEnd = !number(rs.arrowEndX) || !number(rs.arrowEndY);
          const minCpADistFactor = 3;
          const arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
          const minCpADist = minCpADistFactor * arrowW;
          const startACpDist = dist({
            x: rs.ctrlpts[0],
            y: rs.ctrlpts[1]
          }, {
            x: rs.startX,
            y: rs.startY
          });
          const closeStartACp = startACpDist < minCpADist;
          const endACpDist = dist({
            x: rs.ctrlpts[0],
            y: rs.ctrlpts[1]
          }, {
            x: rs.endX,
            y: rs.endY
          });
          const closeEndACp = endACpDist < minCpADist;
          let overlapping = false;

          if (badStart || badAStart || closeStartACp) {
            overlapping = true; // project control point along line from src centre to outside the src shape
      // (otherwise intersection will yield nothing)

            const cpD = {
        // delta
              x: rs.ctrlpts[0] - srcPos.x,
              y: rs.ctrlpts[1] - srcPos.y
            };
            const cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line

            const cpM = {
        // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            const radius = Math.max(srcW, srcH);
            const cpProj = {
        // *2 radius guarantees outside shape
              x: rs.ctrlpts[0] + cpM.x * 2 * radius,
              y: rs.ctrlpts[1] + cpM.y * 2 * radius
            };
            const srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);

            if (closeStartACp) {
              rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
              rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
            } else {
              rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
              rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
            }
          }

          if (badEnd || badAEnd || closeEndACp) {
            overlapping = true; // project control point along line from tgt centre to outside the tgt shape
      // (otherwise intersection will yield nothing)

            const _cpD = {
        // delta
              x: rs.ctrlpts[0] - tgtPos.x,
              y: rs.ctrlpts[1] - tgtPos.y
            };

            const _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line


            const _cpM = {
        // normalised delta
              x: _cpD.x / _cpL,
              y: _cpD.y / _cpL
            };

            const _radius = Math.max(srcW, srcH);

            const _cpProj = {
        // *2 radius guarantees outside shape
              x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,
              y: rs.ctrlpts[1] + _cpM.y * 2 * _radius
            };
            const tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0);

            if (closeEndACp) {
              rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);
              rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);
            } else {
              rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;
              rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;
            }
          }

          if (overlapping) {
      // recalc endpts
            this.findEndpoints(edge);
          }
        }
      };

      BRp$3.storeAllpts = function (edge) {
        const rs = edge._private.rscratch;

        if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
          rs.allpts = [];
          rs.allpts.push(rs.startX, rs.startY);

          for (let b = 0; b + 1 < rs.ctrlpts.length; b += 2) {
      // ctrl pt itself
            rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]); // the midpt between ctrlpts as intermediate destination pts

            if (b + 3 < rs.ctrlpts.length) {
              rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);
            }
          }

          rs.allpts.push(rs.endX, rs.endY);
          let m, mt;

          if (rs.ctrlpts.length / 2 % 2 === 0) {
            m = rs.allpts.length / 2 - 1;
            rs.midX = rs.allpts[m];
            rs.midY = rs.allpts[m + 1];
          } else {
            m = rs.allpts.length / 2 - 3;
            mt = 0.5;
            rs.midX = qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);
            rs.midY = qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);
          }
        } else if (rs.edgeType === 'straight') {
    // need to calc these after endpts
          rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY]; // default midpt for labels etc

          rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;
          rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;
        } else if (rs.edgeType === 'segments') {
          rs.allpts = [];
          rs.allpts.push(rs.startX, rs.startY);
          rs.allpts.push.apply(rs.allpts, rs.segpts);
          rs.allpts.push(rs.endX, rs.endY);

          if (rs.segpts.length % 4 === 0) {
            const i2 = rs.segpts.length / 2;
            const i1 = i2 - 2;
            rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;
            rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;
          } else {
            const _i = rs.segpts.length / 2 - 1;

            rs.midX = rs.segpts[_i];
            rs.midY = rs.segpts[_i + 1];
          }
        }
      };

      BRp$3.checkForInvalidEdgeWarning = function (edge) {
        const rs = edge[0]._private.rscratch;

        if (rs.nodesOverlap || number(rs.startX) && number(rs.startY) && number(rs.endX) && number(rs.endY)) {
          rs.loggedErr = false;
        } else {
          if (!rs.loggedErr) {
            rs.loggedErr = true;
            warn('Edge `' + edge.id() + '` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.');
          }
        }
      };

      BRp$3.findEdgeControlPoints = function (edges) {
        const _this = this;

        if (!edges || edges.length === 0) {
          return;
        }

        const r = this;
        const cy = r.cy;
        const hasCompounds = cy.hasCompoundNodes();
        const hashTable = {
          map: new Map$1(),
          get: function get(pairId) {
            const map2 = this.map.get(pairId[0]);

            if (map2 != null) {
              return map2.get(pairId[1]);
            } else {
              return null;
            }
          },
          set: function set(pairId, val) {
            let map2 = this.map.get(pairId[0]);

            if (map2 == null) {
              map2 = new Map$1();
              this.map.set(pairId[0], map2);
            }

            map2.set(pairId[1], val);
          }
        };
        const pairIds = [];
        const haystackEdges = []; // create a table of edge (src, tgt) => list of edges between them

        for (let i = 0; i < edges.length; i++) {
          const edge = edges[i];
          const _p = edge._private;
          const curveStyle = edge.pstyle('curve-style').value; // ignore edges who are not to be displayed
    // they shouldn't take up space

          if (edge.removed() || !edge.takesUpSpace()) {
            continue;
          }

          if (curveStyle === 'haystack') {
            haystackEdges.push(edge);
            continue;
          }

          const edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'straight' || curveStyle === 'taxi';
          const edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';
          const src = _p.source;
          const tgt = _p.target;
          const srcIndex = src.poolIndex();
          const tgtIndex = tgt.poolIndex();
          const pairId = [srcIndex, tgtIndex].sort();
          let tableEntry = hashTable.get(pairId);

          if (tableEntry == null) {
            tableEntry = {
              eles: []
            };
            hashTable.set(pairId, tableEntry);
            pairIds.push(pairId);
          }

          tableEntry.eles.push(edge);

          if (edgeIsUnbundled) {
            tableEntry.hasUnbundled = true;
          }

          if (edgeIsBezier) {
            tableEntry.hasBezier = true;
          }
        } // for each pair (src, tgt), create the ctrl pts
  // Nested for loop is OK; total number of iterations for both loops = edgeCount


        const _loop = function _loop(p) {
          const pairId = pairIds[p];
          const pairInfo = hashTable.get(pairId);
          let swappedpairInfo = void 0;

          if (!pairInfo.hasUnbundled) {
            const pllEdges = pairInfo.eles[0].parallelEdges().filter(function (e) {
              return e.isBundledBezier();
            });
            clearArray(pairInfo.eles);
            pllEdges.forEach(function (edge) {
              return pairInfo.eles.push(edge);
            }); // for each pair id, the edges should be sorted by index

            pairInfo.eles.sort(function (edge1, edge2) {
              return edge1.poolIndex() - edge2.poolIndex();
            });
          }

          const firstEdge = pairInfo.eles[0];
          let src = firstEdge.source();
          let tgt = firstEdge.target(); // make sure src/tgt distinction is consistent w.r.t. pairId

          if (src.poolIndex() > tgt.poolIndex()) {
            const temp = src;
            src = tgt;
            tgt = temp;
          }

          const srcPos = pairInfo.srcPos = src.position();
          const tgtPos = pairInfo.tgtPos = tgt.position();
          const srcW = pairInfo.srcW = src.outerWidth();
          const srcH = pairInfo.srcH = src.outerHeight();
          const tgtW = pairInfo.tgtW = tgt.outerWidth();
          const tgtH = pairInfo.tgtH = tgt.outerHeight();

          const srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];

          const tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];

          pairInfo.dirCounts = {
            'north': 0,
            'west': 0,
            'south': 0,
            'east': 0,
            'northwest': 0,
            'southwest': 0,
            'northeast': 0,
            'southeast': 0
          };

          for (let _i2 = 0; _i2 < pairInfo.eles.length; _i2++) {
            const _edge = pairInfo.eles[_i2];
            const rs = _edge[0]._private.rscratch;

            const _curveStyle = _edge.pstyle('curve-style').value;

            const _edgeIsUnbundled = _curveStyle === 'unbundled-bezier' || _curveStyle === 'segments' || _curveStyle === 'taxi'; // whether the normalised pair order is the reverse of the edge's src-tgt order


            const edgeIsSwapped = !src.same(_edge.source());

            if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {
              pairInfo.calculatedIntersection = true; // pt outside src shape to calc distance/displacement from src to tgt

              const srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);
              const srcIntn = pairInfo.srcIntn = srcOutside; // pt outside tgt shape to calc distance/displacement from src to tgt

              const tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);
              const tgtIntn = pairInfo.tgtIntn = tgtOutside;
              const intersectionPts = pairInfo.intersectionPts = {
                x1: srcOutside[0],
                x2: tgtOutside[0],
                y1: srcOutside[1],
                y2: tgtOutside[1]
              };
              const posPts = pairInfo.posPts = {
                x1: srcPos.x,
                x2: tgtPos.x,
                y1: srcPos.y,
                y2: tgtPos.y
              };
              const dy = tgtOutside[1] - srcOutside[1];
              const dx = tgtOutside[0] - srcOutside[0];
              const l = Math.sqrt(dx * dx + dy * dy);
              const vector = pairInfo.vector = {
                x: dx,
                y: dy
              };
              const vectorNorm = pairInfo.vectorNorm = {
                x: vector.x / l,
                y: vector.y / l
              };
              const vectorNormInverse = {
                x: -vectorNorm.y,
                y: vectorNorm.x
              }; // if node shapes overlap, then no ctrl pts to draw

              pairInfo.nodesOverlap = !number(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y);
              pairInfo.vectorNormInverse = vectorNormInverse;
              swappedpairInfo = {
                nodesOverlap: pairInfo.nodesOverlap,
                dirCounts: pairInfo.dirCounts,
                calculatedIntersection: true,
                hasBezier: pairInfo.hasBezier,
                hasUnbundled: pairInfo.hasUnbundled,
                eles: pairInfo.eles,
                srcPos: tgtPos,
                tgtPos: srcPos,
                srcW: tgtW,
                srcH: tgtH,
                tgtW: srcW,
                tgtH: srcH,
                srcIntn: tgtIntn,
                tgtIntn: srcIntn,
                srcShape: tgtShape,
                tgtShape: srcShape,
                posPts: {
                  x1: posPts.x2,
                  y1: posPts.y2,
                  x2: posPts.x1,
                  y2: posPts.y1
                },
                intersectionPts: {
                  x1: intersectionPts.x2,
                  y1: intersectionPts.y2,
                  x2: intersectionPts.x1,
                  y2: intersectionPts.y1
                },
                vector: {
                  x: -vector.x,
                  y: -vector.y
                },
                vectorNorm: {
                  x: -vectorNorm.x,
                  y: -vectorNorm.y
                },
                vectorNormInverse: {
                  x: -vectorNormInverse.x,
                  y: -vectorNormInverse.y
                }
              };
            }

            const passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;
            rs.nodesOverlap = passedPairInfo.nodesOverlap;
            rs.srcIntn = passedPairInfo.srcIntn;
            rs.tgtIntn = passedPairInfo.tgtIntn;

            if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) {
              _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
            } else if (src === tgt) {
              _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
            } else if (_curveStyle === 'segments') {
              _this.findSegmentsPoints(_edge, passedPairInfo);
            } else if (_curveStyle === 'taxi') {
              _this.findTaxiPoints(_edge, passedPairInfo);
            } else if (_curveStyle === 'straight' || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {
              _this.findStraightEdgePoints(_edge);
            } else {
              _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);
            }

            _this.findEndpoints(_edge);

            _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);

            _this.checkForInvalidEdgeWarning(_edge);

            _this.storeAllpts(_edge);

            _this.storeEdgeProjections(_edge);

            _this.calculateArrowAngles(_edge);

            _this.recalculateEdgeLabelProjections(_edge);

            _this.calculateLabelAngles(_edge);
          } // for pair edges

        };

        for (let p = 0; p < pairIds.length; p++) {
          _loop(p);
        } // for pair ids
  // haystacks avoid the expense of pairInfo stuff (intersections etc.)


        this.findHaystackPoints(haystackEdges);
      };

      function getPts(pts) {
        const retPts = [];

        if (pts == null) {
          return;
        }

        for (let i = 0; i < pts.length; i += 2) {
          const x = pts[i];
          const y = pts[i + 1];
          retPts.push({
            x: x,
            y: y
          });
        }

        return retPts;
      }

      BRp$3.getSegmentPoints = function (edge) {
        const rs = edge[0]._private.rscratch;
        const type = rs.edgeType;

        if (type === 'segments') {
          this.recalculateRenderedStyle(edge);
          return getPts(rs.segpts);
        }
      };

      BRp$3.getControlPoints = function (edge) {
        const rs = edge[0]._private.rscratch;
        const type = rs.edgeType;

        if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {
          this.recalculateRenderedStyle(edge);
          return getPts(rs.ctrlpts);
        }
      };

      BRp$3.getEdgeMidpoint = function (edge) {
        const rs = edge[0]._private.rscratch;
        this.recalculateRenderedStyle(edge);
        return {
          x: rs.midX,
          y: rs.midY
        };
      };

      const BRp$4 = {};

      BRp$4.manualEndptToPx = function (node, prop) {
        const r = this;
        const npos = node.position();
        const w = node.outerWidth();
        const h = node.outerHeight();

        if (prop.value.length === 2) {
          const p = [prop.pfValue[0], prop.pfValue[1]];

          if (prop.units[0] === '%') {
            p[0] = p[0] * w;
          }

          if (prop.units[1] === '%') {
            p[1] = p[1] * h;
          }

          p[0] += npos.x;
          p[1] += npos.y;
          return p;
        } else {
          let angle = prop.pfValue[0];
          angle = -Math.PI / 2 + angle; // start at 12 o'clock

          const l = 2 * Math.max(w, h);
          const _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];
          return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);
        }
      };

      BRp$4.findEndpoints = function (edge) {
        const r = this;
        let intersect;
        const source = edge.source()[0];
        const target = edge.target()[0];
        const srcPos = source.position();
        const tgtPos = target.position();
        const tgtArShape = edge.pstyle('target-arrow-shape').value;
        const srcArShape = edge.pstyle('source-arrow-shape').value;
        const tgtDist = edge.pstyle('target-distance-from-node').pfValue;
        const srcDist = edge.pstyle('source-distance-from-node').pfValue;
        const curveStyle = edge.pstyle('curve-style').value;
        const rs = edge._private.rscratch;
        const et = rs.edgeType;
        const taxi = curveStyle === 'taxi';
        const self = et === 'self' || et === 'compound';
        const bezier = et === 'bezier' || et === 'multibezier' || self;
        const multi = et !== 'bezier';
        const lines = et === 'straight' || et === 'segments';
        const segments = et === 'segments';
        const hasEndpts = bezier || multi || lines;
        const overrideEndpts = self || taxi;
        const srcManEndpt = edge.pstyle('source-endpoint');
        const srcManEndptVal = overrideEndpts ? 'outside-to-node' : srcManEndpt.value;
        const tgtManEndpt = edge.pstyle('target-endpoint');
        const tgtManEndptVal = overrideEndpts ? 'outside-to-node' : tgtManEndpt.value;
        rs.srcManEndpt = srcManEndpt;
        rs.tgtManEndpt = tgtManEndpt;
        let p1; // last known point of edge on target side

        let p2; // last known point of edge on source side

        let p1_i; // point to intersect with target shape

        let p2_i; // point to intersect with source shape

        if (bezier) {
          const cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];
          const cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;
          p1 = cpEnd;
          p2 = cpStart;
        } else if (lines) {
          const srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);
          const tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);
          p1 = tgtArrowFromPt;
          p2 = srcArrowFromPt;
        }

        if (tgtManEndptVal === 'inside-to-node') {
          intersect = [tgtPos.x, tgtPos.y];
        } else if (tgtManEndpt.units) {
          intersect = this.manualEndptToPx(target, tgtManEndpt);
        } else if (tgtManEndptVal === 'outside-to-line') {
          intersect = rs.tgtIntn; // use cached value from ctrlpt calc
        } else {
          if (tgtManEndptVal === 'outside-to-node' || tgtManEndptVal === 'outside-to-node-or-label') {
            p1_i = p1;
          } else if (tgtManEndptVal === 'outside-to-line' || tgtManEndptVal === 'outside-to-line-or-label') {
            p1_i = [srcPos.x, srcPos.y];
          }

          intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);

          if (tgtManEndptVal === 'outside-to-node-or-label' || tgtManEndptVal === 'outside-to-line-or-label') {
            const trs = target._private.rscratch;
            const lw = trs.labelWidth;
            const lh = trs.labelHeight;
            let lx = trs.labelX;
            let ly = trs.labelY;
            const lw2 = lw / 2;
            const lh2 = lh / 2;
            const va = target.pstyle('text-valign').value;

            if (va === 'top') {
              ly -= lh2;
            } else if (va === 'bottom') {
              ly += lh2;
            }

            const ha = target.pstyle('text-halign').value;

            if (ha === 'left') {
              lx -= lw2;
            } else if (ha === 'right') {
              lx += lw2;
            }

            const labelIntersect = polygonIntersectLine(p1_i[0], p1_i[1], [lx - lw2, ly - lh2, lx + lw2, ly - lh2, lx + lw2, ly + lh2, lx - lw2, ly + lh2], tgtPos.x, tgtPos.y);

            if (labelIntersect.length > 0) {
              const refPt = srcPos;
              const intSqdist = sqdist(refPt, array2point(intersect));
              const labIntSqdist = sqdist(refPt, array2point(labelIntersect));
              let minSqDist = intSqdist;

              if (labIntSqdist < intSqdist) {
                intersect = labelIntersect;
                minSqDist = labIntSqdist;
              }

              if (labelIntersect.length > 2) {
                const labInt2SqDist = sqdist(refPt, {
                  x: labelIntersect[2],
                  y: labelIntersect[3]
                });

                if (labInt2SqDist < minSqDist) {
                  intersect = [labelIntersect[2], labelIntersect[3]];
                }
              }
            }
          }
        }

        const arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);
        const edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);
        rs.endX = edgeEnd[0];
        rs.endY = edgeEnd[1];
        rs.arrowEndX = arrowEnd[0];
        rs.arrowEndY = arrowEnd[1];

        if (srcManEndptVal === 'inside-to-node') {
          intersect = [srcPos.x, srcPos.y];
        } else if (srcManEndpt.units) {
          intersect = this.manualEndptToPx(source, srcManEndpt);
        } else if (srcManEndptVal === 'outside-to-line') {
          intersect = rs.srcIntn; // use cached value from ctrlpt calc
        } else {
          if (srcManEndptVal === 'outside-to-node' || srcManEndptVal === 'outside-to-node-or-label') {
            p2_i = p2;
          } else if (srcManEndptVal === 'outside-to-line' || srcManEndptVal === 'outside-to-line-or-label') {
            p2_i = [tgtPos.x, tgtPos.y];
          }

          intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);

          if (srcManEndptVal === 'outside-to-node-or-label' || srcManEndptVal === 'outside-to-line-or-label') {
            const srs = source._private.rscratch;
            const _lw = srs.labelWidth;
            const _lh = srs.labelHeight;
            let _lx = srs.labelX;
            let _ly = srs.labelY;

            const _lw2 = _lw / 2;

            const _lh2 = _lh / 2;

            const _va = source.pstyle('text-valign').value;

            if (_va === 'top') {
              _ly -= _lh2;
            } else if (_va === 'bottom') {
              _ly += _lh2;
            }

            const _ha = source.pstyle('text-halign').value;

            if (_ha === 'left') {
              _lx -= _lw2;
            } else if (_ha === 'right') {
              _lx += _lw2;
            }

            const _labelIntersect = polygonIntersectLine(p2_i[0], p2_i[1], [_lx - _lw2, _ly - _lh2, _lx + _lw2, _ly - _lh2, _lx + _lw2, _ly + _lh2, _lx - _lw2, _ly + _lh2], srcPos.x, srcPos.y);

            if (_labelIntersect.length > 0) {
              const _refPt = tgtPos;

              const _intSqdist = sqdist(_refPt, array2point(intersect));

              const _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));

              let _minSqDist = _intSqdist;

              if (_labIntSqdist < _intSqdist) {
                intersect = [_labelIntersect[0], _labelIntersect[1]];
                _minSqDist = _labIntSqdist;
              }

              if (_labelIntersect.length > 2) {
                const _labInt2SqDist = sqdist(_refPt, {
                  x: _labelIntersect[2],
                  y: _labelIntersect[3]
                });

                if (_labInt2SqDist < _minSqDist) {
                  intersect = [_labelIntersect[2], _labelIntersect[3]];
                }
              }
            }
          }
        }

        const arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);
        const edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);
        rs.startX = edgeStart[0];
        rs.startY = edgeStart[1];
        rs.arrowStartX = arrowStart[0];
        rs.arrowStartY = arrowStart[1];

        if (hasEndpts) {
          if (!number(rs.startX) || !number(rs.startY) || !number(rs.endX) || !number(rs.endY)) {
            rs.badLine = true;
          } else {
            rs.badLine = false;
          }
        }
      };

      BRp$4.getSourceEndpoint = function (edge) {
        const rs = edge[0]._private.rscratch;
        this.recalculateRenderedStyle(edge);

        switch (rs.edgeType) {
          case 'haystack':
            return {
              x: rs.haystackPts[0],
              y: rs.haystackPts[1]
            };

          default:
            return {
              x: rs.arrowStartX,
              y: rs.arrowStartY
            };
        }
      };

      BRp$4.getTargetEndpoint = function (edge) {
        const rs = edge[0]._private.rscratch;
        this.recalculateRenderedStyle(edge);

        switch (rs.edgeType) {
          case 'haystack':
            return {
              x: rs.haystackPts[2],
              y: rs.haystackPts[3]
            };

          default:
            return {
              x: rs.arrowEndX,
              y: rs.arrowEndY
            };
        }
      };

      const BRp$5 = {};

      function pushBezierPts(r, edge, pts) {
        const qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {
          return qbezierAt(p1, p2, p3, t);
        };

        const _p = edge._private;
        const bpts = _p.rstyle.bezierPts;

        for (let i = 0; i < r.bezierProjPcts.length; i++) {
          const p = r.bezierProjPcts[i];
          bpts.push({
            x: qbezierAt$1(pts[0], pts[2], pts[4], p),
            y: qbezierAt$1(pts[1], pts[3], pts[5], p)
          });
        }
      }

      BRp$5.storeEdgeProjections = function (edge) {
        const _p = edge._private;
        const rs = _p.rscratch;
        const et = rs.edgeType; // clear the cached points state

        _p.rstyle.bezierPts = null;
        _p.rstyle.linePts = null;
        _p.rstyle.haystackPts = null;

        if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {
          _p.rstyle.bezierPts = [];

          for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
            pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));
          }
        } else if (et === 'segments') {
          const lpts = _p.rstyle.linePts = [];

          for (var i = 0; i + 1 < rs.allpts.length; i += 2) {
            lpts.push({
              x: rs.allpts[i],
              y: rs.allpts[i + 1]
            });
          }
        } else if (et === 'haystack') {
          const hpts = rs.haystackPts;
          _p.rstyle.haystackPts = [{
            x: hpts[0],
            y: hpts[1]
          }, {
            x: hpts[2],
            y: hpts[3]
          }];
        }

        _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
      };

      BRp$5.recalculateEdgeProjections = function (edges) {
        this.findEdgeControlPoints(edges);
      };

/* global document */

      const BRp$6 = {};

      BRp$6.recalculateNodeLabelProjection = function (node) {
        const content = node.pstyle('label').strValue;

        if (emptyString(content)) {
          return;
        }

        let textX, textY;
        const _p = node._private;
        const nodeWidth = node.width();
        const nodeHeight = node.height();
        const padding = node.padding();
        const nodePos = node.position();
        const textHalign = node.pstyle('text-halign').strValue;
        const textValign = node.pstyle('text-valign').strValue;
        const rs = _p.rscratch;
        const rstyle = _p.rstyle;

        switch (textHalign) {
          case 'left':
            textX = nodePos.x - nodeWidth / 2 - padding;
            break;

          case 'right':
            textX = nodePos.x + nodeWidth / 2 + padding;
            break;

          default:
      // e.g. center
            textX = nodePos.x;
        }

        switch (textValign) {
          case 'top':
            textY = nodePos.y - nodeHeight / 2 - padding;
            break;

          case 'bottom':
            textY = nodePos.y + nodeHeight / 2 + padding;
            break;

          default:
      // e.g. middle
            textY = nodePos.y;
        }

        rs.labelX = textX;
        rs.labelY = textY;
        rstyle.labelX = textX;
        rstyle.labelY = textY;
        this.calculateLabelAngles(node);
        this.applyLabelDimensions(node);
      };

      const lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {
        let angle = Math.atan(dy / dx);

        if (dx === 0 && angle < 0) {
          angle = angle * -1;
        }

        return angle;
      };

      const lineAngle = function lineAngle(p0, p1) {
        const dx = p1.x - p0.x;
        const dy = p1.y - p0.y;
        return lineAngleFromDelta(dx, dy);
      };

      const bezierAngle = function bezierAngle(p0, p1, p2, t) {
        const t0 = bound(0, t - 0.001, 1);
        const t1 = bound(0, t + 0.001, 1);
        const lp0 = qbezierPtAt(p0, p1, p2, t0);
        const lp1 = qbezierPtAt(p0, p1, p2, t1);
        return lineAngle(lp0, lp1);
      };

      BRp$6.recalculateEdgeLabelProjections = function (edge) {
        let p;
        const _p = edge._private;
        const rs = _p.rscratch;
        const r = this;
        const content = {
          mid: edge.pstyle('label').strValue,
          source: edge.pstyle('source-label').strValue,
          target: edge.pstyle('target-label').strValue
        };

        if (content.mid || content.source || content.target) ; else {
          return; // no labels => no calcs
        } // add center point to style so bounding box calculations can use it
  //


        p = {
          x: rs.midX,
          y: rs.midY
        };

        const setRs = function setRs(propName, prefix, value) {
          setPrefixedProperty(_p.rscratch, propName, prefix, value);
          setPrefixedProperty(_p.rstyle, propName, prefix, value);
        };

        setRs('labelX', null, p.x);
        setRs('labelY', null, p.y);
        const midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);
        setRs('labelAutoAngle', null, midAngle);

        const createControlPointInfo = function createControlPointInfo() {
          if (createControlPointInfo.cache) {
            return createControlPointInfo.cache;
          } // use cache so only 1x per edge


          const ctrlpts = []; // store each ctrlpt info init

          for (let i = 0; i + 5 < rs.allpts.length; i += 4) {
            const p0 = {
              x: rs.allpts[i],
              y: rs.allpts[i + 1]
            };
            const p1 = {
              x: rs.allpts[i + 2],
              y: rs.allpts[i + 3]
            }; // ctrlpt

            const p2 = {
              x: rs.allpts[i + 4],
              y: rs.allpts[i + 5]
            };
            ctrlpts.push({
              p0: p0,
              p1: p1,
              p2: p2,
              startDist: 0,
              length: 0,
              segments: []
            });
          }

          const bpts = _p.rstyle.bezierPts;
          const nProjs = r.bezierProjPcts.length;

          function addSegment(cp, p0, p1, t0, t1) {
            const length = dist(p0, p1);
            const prevSegment = cp.segments[cp.segments.length - 1];
            const segment = {
              p0: p0,
              p1: p1,
              t0: t0,
              t1: t1,
              startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
              length: length
            };
            cp.segments.push(segment);
            cp.length += length;
          } // update each ctrlpt with segment info


          for (let _i = 0; _i < ctrlpts.length; _i++) {
            const cp = ctrlpts[_i];
            const prevCp = ctrlpts[_i - 1];

            if (prevCp) {
              cp.startDist = prevCp.startDist + prevCp.length;
            }

            addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first

            for (let j = 0; j < nProjs - 1; j++) {
              addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);
            }

            addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last
          }

          return createControlPointInfo.cache = ctrlpts;
        };

        const calculateEndProjection = function calculateEndProjection(prefix) {
          let angle;
          const isSrc = prefix === 'source';

          if (!content[prefix]) {
            return;
          }

          const offset = edge.pstyle(prefix + '-text-offset').pfValue;

          switch (rs.edgeType) {
            case 'self':
            case 'compound':
            case 'bezier':
            case 'multibezier':
            {
              const cps = createControlPointInfo();
              let selected;
              let startDist = 0;
              let totalDist = 0; // find the segment we're on

              for (let i = 0; i < cps.length; i++) {
                const _cp = cps[isSrc ? i : cps.length - 1 - i];

                for (let j = 0; j < _cp.segments.length; j++) {
                  const _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];
                  const lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;
                  startDist = totalDist;
                  totalDist += _seg.length;

                  if (totalDist >= offset || lastSeg) {
                    selected = {
                      cp: _cp,
                      segment: _seg
                    };
                    break;
                  }
                }

                if (selected) {
                  break;
                }
              }

              const cp = selected.cp;
              const seg = selected.segment;
              const tSegment = (offset - startDist) / seg.length;
              const segDt = seg.t1 - seg.t0;
              let t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;
              t = bound(0, t, 1);
              p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);
              angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);
              break;
            }

            case 'straight':
            case 'segments':
            case 'haystack':
            {
              let d = 0,
                di,
                d0;
              let p0, p1;
              const l = rs.allpts.length;

              for (let _i2 = 0; _i2 + 3 < l; _i2 += 2) {
                if (isSrc) {
                  p0 = {
                    x: rs.allpts[_i2],
                    y: rs.allpts[_i2 + 1]
                  };
                  p1 = {
                    x: rs.allpts[_i2 + 2],
                    y: rs.allpts[_i2 + 3]
                  };
                } else {
                  p0 = {
                    x: rs.allpts[l - 2 - _i2],
                    y: rs.allpts[l - 1 - _i2]
                  };
                  p1 = {
                    x: rs.allpts[l - 4 - _i2],
                    y: rs.allpts[l - 3 - _i2]
                  };
                }

                di = dist(p0, p1);
                d0 = d;
                d += di;

                if (d >= offset) {
                  break;
                }
              }

              const pD = offset - d0;

              let _t = pD / di;

              _t = bound(0, _t, 1);
              p = lineAt(p0, p1, _t);
              angle = lineAngle(p0, p1);
              break;
            }
          }

          setRs('labelX', prefix, p.x);
          setRs('labelY', prefix, p.y);
          setRs('labelAutoAngle', prefix, angle);
        };

        calculateEndProjection('source');
        calculateEndProjection('target');
        this.applyLabelDimensions(edge);
      };

      BRp$6.applyLabelDimensions = function (ele) {
        this.applyPrefixedLabelDimensions(ele);

        if (ele.isEdge()) {
          this.applyPrefixedLabelDimensions(ele, 'source');
          this.applyPrefixedLabelDimensions(ele, 'target');
        }
      };

      BRp$6.applyPrefixedLabelDimensions = function (ele, prefix) {
        const _p = ele._private;
        const text = this.getLabelText(ele, prefix);
        const labelDims = this.calculateLabelDimensions(ele, text);
        const lineHeight = ele.pstyle('line-height').pfValue;
        const textWrap = ele.pstyle('text-wrap').strValue;
        const lines = getPrefixedProperty(_p.rscratch, 'labelWrapCachedLines', prefix) || [];
        const numLines = textWrap !== 'wrap' ? 1 : Math.max(lines.length, 1);
        const normPerLineHeight = labelDims.height / numLines;
        const labelLineHeight = normPerLineHeight * lineHeight;
        const width = labelDims.width;
        const height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;
        setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, width);
        setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, width);
        setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, height);
        setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, height);
        setPrefixedProperty(_p.rscratch, 'labelLineHeight', prefix, labelLineHeight);
      };

      BRp$6.getLabelText = function (ele, prefix) {
        const _p = ele._private;
        const pfd = prefix ? prefix + '-' : '';
        let text = ele.pstyle(pfd + 'label').strValue;
        const textTransform = ele.pstyle('text-transform').value;

        const rscratch = function rscratch(propName, value) {
          if (value) {
            setPrefixedProperty(_p.rscratch, propName, prefix, value);
            return value;
          } else {
            return getPrefixedProperty(_p.rscratch, propName, prefix);
          }
        }; // for empty text, skip all processing


        if (!text) {
          return '';
        }

        if (textTransform == 'none') ; else if (textTransform == 'uppercase') {
          text = text.toUpperCase();
        } else if (textTransform == 'lowercase') {
          text = text.toLowerCase();
        }

        const wrapStyle = ele.pstyle('text-wrap').value;

        if (wrapStyle === 'wrap') {
          const labelKey = rscratch('labelKey'); // save recalc if the label is the same as before

          if (labelKey != null && rscratch('labelWrapKey') === labelKey) {
            return rscratch('labelWrapCachedText');
          }

          const zwsp = "\u200B";
          const lines = text.split('\n');
          const maxW = ele.pstyle('text-max-width').pfValue;
          const overflow = ele.pstyle('text-overflow-wrap').value;
          const overflowAny = overflow === 'anywhere';
          const wrappedLines = [];
          const wordsRegex = /[\s\u200b]+/;
          const wordSeparator = overflowAny ? '' : ' ';

          for (let l = 0; l < lines.length; l++) {
            let line = lines[l];
            const lineDims = this.calculateLabelDimensions(ele, line);
            const lineW = lineDims.width;

            if (overflowAny) {
              const processedLine = line.split('').join(zwsp);
              line = processedLine;
            }

            if (lineW > maxW) {
        // line is too long
              const words = line.split(wordsRegex);
              let subline = '';

              for (let w = 0; w < words.length; w++) {
                const word = words[w];
                const testLine = subline.length === 0 ? word : subline + wordSeparator + word;
                const testDims = this.calculateLabelDimensions(ele, testLine);
                const testW = testDims.width;

                if (testW <= maxW) {
            // word fits on current line
                  subline += word + wordSeparator;
                } else {
            // word starts new line
                  if (subline) {
                    wrappedLines.push(subline);
                  }

                  subline = word + wordSeparator;
                }
              } // if there's remaining text, put it in a wrapped line


              if (!subline.match(/^[\s\u200b]+$/)) {
                wrappedLines.push(subline);
              }
            } else {
        // line is already short enough
              wrappedLines.push(line);
            }
          } // for


          rscratch('labelWrapCachedLines', wrappedLines);
          text = rscratch('labelWrapCachedText', wrappedLines.join('\n'));
          rscratch('labelWrapKey', labelKey);
        } else if (wrapStyle === 'ellipsis') {
          const _maxW = ele.pstyle('text-max-width').pfValue;
          let ellipsized = '';
          const ellipsis = "\u2026";
          let incLastCh = false;

          if (this.calculateLabelDimensions(ele, text).width < _maxW) {
      // the label already fits
            return text;
          }

          for (let i = 0; i < text.length; i++) {
            const widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;

            if (widthWithNextCh > _maxW) {
              break;
            }

            ellipsized += text[i];

            if (i === text.length - 1) {
              incLastCh = true;
            }
          }

          if (!incLastCh) {
            ellipsized += ellipsis;
          }

          return ellipsized;
        } // if ellipsize


        return text;
      };

      BRp$6.getLabelJustification = function (ele) {
        const justification = ele.pstyle('text-justification').strValue;
        const textHalign = ele.pstyle('text-halign').strValue;

        if (justification === 'auto') {
          if (ele.isNode()) {
            switch (textHalign) {
              case 'left':
                return 'right';

              case 'right':
                return 'left';

              default:
                return 'center';
            }
          } else {
            return 'center';
          }
        } else {
          return justification;
        }
      };

      BRp$6.calculateLabelDimensions = function (ele, text) {
        const r = this;
        const cacheKey = hashString(text, ele._private.labelDimsKey);
        const cache = r.labelDimCache || (r.labelDimCache = []);
        const existingVal = cache[cacheKey];

        if (existingVal != null) {
          return existingVal;
        }

        const padding = 0; // add padding around text dims, as the measurement isn't that accurate

        const fStyle = ele.pstyle('font-style').strValue;
        const size = ele.pstyle('font-size').pfValue;
        const family = ele.pstyle('font-family').strValue;
        const weight = ele.pstyle('font-weight').strValue;
        let canvas = this.labelCalcCanvas;
        let c2d = this.labelCalcCanvasContext;

        if (!canvas) {
          canvas = this.labelCalcCanvas = document.createElement('canvas');
          c2d = this.labelCalcCanvasContext = canvas.getContext('2d');
          const ds = canvas.style;
          ds.position = 'absolute';
          ds.left = '-9999px';
          ds.top = '-9999px';
          ds.zIndex = '-1';
          ds.visibility = 'hidden';
          ds.pointerEvents = 'none';
        }

        c2d.font = "".concat(fStyle, " ").concat(weight, " ").concat(size, "px ").concat(family);
        let width = 0;
        let height = 0;
        const lines = text.split('\n');

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const metrics = c2d.measureText(line);
          const w = Math.ceil(metrics.width);
          const h = size;
          width = Math.max(w, width);
          height += h;
        }

        width += padding;
        height += padding;
        return cache[cacheKey] = {
          width: width,
          height: height
        };
      };

      BRp$6.calculateLabelAngle = function (ele, prefix) {
        const _p = ele._private;
        const rs = _p.rscratch;
        const isEdge = ele.isEdge();
        const prefixDash = prefix ? prefix + '-' : '';
        const rot = ele.pstyle(prefixDash + 'text-rotation');
        const rotStr = rot.strValue;

        if (rotStr === 'none') {
          return 0;
        } else if (isEdge && rotStr === 'autorotate') {
          return rs.labelAutoAngle;
        } else if (rotStr === 'autorotate') {
          return 0;
        } else {
          return rot.pfValue;
        }
      };

      BRp$6.calculateLabelAngles = function (ele) {
        const r = this;
        const isEdge = ele.isEdge();
        const _p = ele._private;
        const rs = _p.rscratch;
        rs.labelAngle = r.calculateLabelAngle(ele);

        if (isEdge) {
          rs.sourceLabelAngle = r.calculateLabelAngle(ele, 'source');
          rs.targetLabelAngle = r.calculateLabelAngle(ele, 'target');
        }
      };

      const BRp$7 = {};
      const TOO_SMALL_CUT_RECT = 28;
      let warnedCutRect = false;

      BRp$7.getNodeShape = function (node) {
        const r = this;
        const shape = node.pstyle('shape').value;

        if (shape === 'cutrectangle' && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {
          if (!warnedCutRect) {
            warn('The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead');
            warnedCutRect = true;
          }

          return 'rectangle';
        }

        if (node.isParent()) {
          if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'round-rectangle' || shape === 'cutrectangle' || shape === 'cut-rectangle' || shape === 'barrel') {
            return shape;
          } else {
            return 'rectangle';
          }
        }

        if (shape === 'polygon') {
          const points = node.pstyle('shape-polygon-points').value;
          return r.nodeShapes.makePolygon(points).name;
        }

        return shape;
      };

      const BRp$8 = {};

      BRp$8.registerCalculationListeners = function () {
        const cy = this.cy;
        let elesToUpdate = cy.collection();
        const r = this;

        const enqueue = function enqueue(eles) {
          const dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          elesToUpdate.merge(eles);

          if (dirtyStyleCaches) {
            for (let i = 0; i < eles.length; i++) {
              const ele = eles[i];
              const _p = ele._private;
              const rstyle = _p.rstyle;
              rstyle.clean = false;
              rstyle.cleanConnected = false;
            }
          }
        };

        r.binder(cy).on('bounds.* dirty.*', function onDirtyBounds(e) {
          const ele = e.target;
          enqueue(ele);
        }).on('style.* background.*', function onDirtyStyle(e) {
          const ele = e.target;
          enqueue(ele, false);
        });

        const updateEleCalcs = function updateEleCalcs(willDraw) {
          if (willDraw) {
            const fns = r.onUpdateEleCalcsFns; // because we need to have up-to-date style (e.g. stylesheet mappers)
      // before calculating rendered style (and pstyle might not be called yet)

            elesToUpdate.cleanStyle();

            for (let i = 0; i < elesToUpdate.length; i++) {
              const ele = elesToUpdate[i];
              const rstyle = ele._private.rstyle;

              if (ele.isNode() && !rstyle.cleanConnected) {
                enqueue(ele.connectedEdges());
                rstyle.cleanConnected = true;
              }
            }

            if (fns) {
              for (let _i = 0; _i < fns.length; _i++) {
                const fn = fns[_i];
                fn(willDraw, elesToUpdate);
              }
            }

            r.recalculateRenderedStyle(elesToUpdate);
            elesToUpdate = cy.collection();
          }
        };

        r.flushRenderedStyleQueue = function () {
          updateEleCalcs(true);
        };

        r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);
      };

      BRp$8.onUpdateEleCalcs = function (fn) {
        const fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];
        fns.push(fn);
      };

      BRp$8.recalculateRenderedStyle = function (eles, useCache) {
        const isCleanConnected = function isCleanConnected(ele) {
          return ele._private.rstyle.cleanConnected;
        };

        const edges = [];
        const nodes = []; // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()

        if (this.destroyed) {
          return;
        } // use cache by default for perf


        if (useCache === undefined) {
          useCache = true;
        }

        for (let i = 0; i < eles.length; i++) {
          const ele = eles[i];
          const _p = ele._private;
          const rstyle = _p.rstyle; // an edge may be implicitly dirty b/c of one of its connected nodes
    // (and a request for recalc may come in between frames)

          if (ele.isEdge() && (!isCleanConnected(ele.source()) || !isCleanConnected(ele.target()))) {
            rstyle.clean = false;
          } // only update if dirty and in graph


          if (useCache && rstyle.clean || ele.removed()) {
            continue;
          } // only update if not display: none


          if (ele.pstyle('display').value === 'none') {
            continue;
          }

          if (_p.group === 'nodes') {
            nodes.push(ele);
          } else {
      // edges
            edges.push(ele);
          }

          rstyle.clean = true;
        } // update node data from projections


        for (let _i2 = 0; _i2 < nodes.length; _i2++) {
          const _ele = nodes[_i2];
          const _p2 = _ele._private;
          const _rstyle = _p2.rstyle;

          const pos = _ele.position();

          this.recalculateNodeLabelProjection(_ele);
          _rstyle.nodeX = pos.x;
          _rstyle.nodeY = pos.y;
          _rstyle.nodeW = _ele.pstyle('width').pfValue;
          _rstyle.nodeH = _ele.pstyle('height').pfValue;
        }

        this.recalculateEdgeProjections(edges); // update edge data from projections

        for (let _i3 = 0; _i3 < edges.length; _i3++) {
          const _ele2 = edges[_i3];
          const _p3 = _ele2._private;
          const _rstyle2 = _p3.rstyle;
          const rs = _p3.rscratch; // update rstyle positions

          _rstyle2.srcX = rs.arrowStartX;
          _rstyle2.srcY = rs.arrowStartY;
          _rstyle2.tgtX = rs.arrowEndX;
          _rstyle2.tgtY = rs.arrowEndY;
          _rstyle2.midX = rs.midX;
          _rstyle2.midY = rs.midY;
          _rstyle2.labelAngle = rs.labelAngle;
          _rstyle2.sourceLabelAngle = rs.sourceLabelAngle;
          _rstyle2.targetLabelAngle = rs.targetLabelAngle;
        }
      };

      const BRp$9 = {};

      BRp$9.updateCachedGrabbedEles = function () {
        const eles = this.cachedZSortedEles;

        if (!eles) {
    // just let this be recalculated on the next z sort tick
          return;
        }

        eles.drag = [];
        eles.nondrag = [];
        const grabTargets = [];

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          const rs = ele._private.rscratch;

          if (ele.grabbed() && !ele.isParent()) {
            grabTargets.push(ele);
          } else if (rs.inDragLayer) {
            eles.drag.push(ele);
          } else {
            eles.nondrag.push(ele);
          }
        } // put the grab target nodes last so it's on top of its neighbourhood


        for (var i = 0; i < grabTargets.length; i++) {
          var ele = grabTargets[i];
          eles.drag.push(ele);
        }
      };

      BRp$9.invalidateCachedZSortedEles = function () {
        this.cachedZSortedEles = null;
      };

      BRp$9.getCachedZSortedEles = function (forceRecalc) {
        if (forceRecalc || !this.cachedZSortedEles) {
          var eles = this.cy.mutableElements().toArray();
          eles.sort(zIndexSort);
          eles.interactive = eles.filter(function (ele) {
            return ele.interactive();
          });
          this.cachedZSortedEles = eles;
          this.updateCachedGrabbedEles();
        } else {
          eles = this.cachedZSortedEles;
        }

        return eles;
      };

      const BRp$a = {};
      [BRp$1, BRp$2, BRp$3, BRp$4, BRp$5, BRp$6, BRp$7, BRp$8, BRp$9].forEach(function (props) {
        extend(BRp$a, props);
      });

      const BRp$b = {};

      BRp$b.getCachedImage = function (url, crossOrigin, onLoad) {
        const r = this;
        const imageCache = r.imageCache = r.imageCache || {};
        let cache = imageCache[url];

        if (cache) {
          if (!cache.image.complete) {
            cache.image.addEventListener('load', onLoad);
          }

          return cache.image;
        } else {
          cache = imageCache[url] = imageCache[url] || {};
          const image = cache.image = new Image(); // eslint-disable-line no-undef

          image.addEventListener('load', onLoad);
          image.addEventListener('error', function () {
            image.error = true;
          }); // #1582 safari doesn't load data uris with crossOrigin properly
    // https://bugs.webkit.org/show_bug.cgi?id=123978

          const dataUriPrefix = 'data:';
          const isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;

          if (!isDataUri) {
            image.crossOrigin = crossOrigin; // prevent tainted canvas
          }

          image.src = url;
          return image;
        }
      };

      const BRp$c = {};
/* global document, window, ResizeObserver, MutationObserver */

      BRp$c.registerBinding = function (target, event, handler, useCapture) {
  // eslint-disable-line no-unused-vars
        const args = Array.prototype.slice.apply(arguments, [1]); // copy

        const b = this.binder(target);
        return b.on.apply(b, args);
      };

      BRp$c.binder = function (tgt) {
        const r = this;
        const tgtIsDom = tgt === window || tgt === document || tgt === document.body || domElement(tgt);

        if (r.supportsPassiveEvents == null) {
    // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
          let supportsPassive = false;

          try {
            const opts = Object.defineProperty({}, 'passive', {
              get: function get() {
                supportsPassive = true;
                return true;
              }
            });
            window.addEventListener('test', null, opts);
          } catch (err) {// not supported
          }

          r.supportsPassiveEvents = supportsPassive;
        }

        const on = function on(event, handler, useCapture) {
          const args = Array.prototype.slice.call(arguments);

          if (tgtIsDom && r.supportsPassiveEvents) {
      // replace useCapture w/ opts obj
            args[2] = {
              capture: useCapture != null ? useCapture : false,
              passive: false,
              once: false
            };
          }

          r.bindings.push({
            target: tgt,
            args: args
          });
          (tgt.addEventListener || tgt.on).apply(tgt, args);
          return this;
        };

        return {
          on: on,
          addEventListener: on,
          addListener: on,
          bind: on
        };
      };

      BRp$c.nodeIsDraggable = function (node) {
        return node && node.isNode() && !node.locked() && node.grabbable();
      };

      BRp$c.nodeIsGrabbable = function (node) {
        return this.nodeIsDraggable(node) && node.interactive();
      };

      BRp$c.load = function () {
        const r = this;

        const isSelected = function isSelected(ele) {
          return ele.selected();
        };

        const triggerEvents = function triggerEvents(target, names, e, position) {
          if (target == null) {
            target = r.cy;
          }

          for (let i = 0; i < names.length; i++) {
            const name = names[i];
            target.emit({
              originalEvent: e,
              type: name,
              position: position
            });
          }
        };

        const isMultSelKeyDown = function isMultSelKeyDown(e) {
          return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
        };

        const allowPanningPassthrough = function allowPanningPassthrough(down, downs) {
          let allowPassthrough = true;

          if (r.cy.hasCompoundNodes() && down && down.pannable()) {
      // a grabbable compound node below the ele => no passthrough panning
            for (let i = 0; downs && i < downs.length; i++) {
              var down = downs[i]; //if any parent node in event hierarchy isn't pannable, reject passthrough

              if (down.isNode() && down.isParent() && !down.pannable()) {
                allowPassthrough = false;
                break;
              }
            }
          } else {
            allowPassthrough = true;
          }

          return allowPassthrough;
        };

        const setGrabbed = function setGrabbed(ele) {
          ele[0]._private.grabbed = true;
        };

        const setFreed = function setFreed(ele) {
          ele[0]._private.grabbed = false;
        };

        const setInDragLayer = function setInDragLayer(ele) {
          ele[0]._private.rscratch.inDragLayer = true;
        };

        const setOutDragLayer = function setOutDragLayer(ele) {
          ele[0]._private.rscratch.inDragLayer = false;
        };

        const setGrabTarget = function setGrabTarget(ele) {
          ele[0]._private.rscratch.isGrabTarget = true;
        };

        const removeGrabTarget = function removeGrabTarget(ele) {
          ele[0]._private.rscratch.isGrabTarget = false;
        };

        const addToDragList = function addToDragList(ele, opts) {
          const list = opts.addToList;
          const listHasEle = list.has(ele);

          if (!listHasEle) {
            list.merge(ele);
            setGrabbed(ele);
          }
        }; // helper function to determine which child nodes and inner edges
  // of a compound node to be dragged as well as the grabbed and selected nodes


        const addDescendantsToDrag = function addDescendantsToDrag(node, opts) {
          if (!node.cy().hasCompoundNodes()) {
            return;
          }

          if (opts.inDragLayer == null && opts.addToList == null) {
            return;
          } // nothing to do


          const innerNodes = node.descendants();

          if (opts.inDragLayer) {
            innerNodes.forEach(setInDragLayer);
            innerNodes.connectedEdges().forEach(setInDragLayer);
          }

          if (opts.addToList) {
            opts.addToList.unmerge(innerNodes);
          }
        }; // adds the given nodes and its neighbourhood to the drag layer


        const addNodesToDrag = function addNodesToDrag(nodes, opts) {
          opts = opts || {};
          const hasCompoundNodes = nodes.cy().hasCompoundNodes();

          if (opts.inDragLayer) {
            nodes.forEach(setInDragLayer);
            nodes.neighborhood().stdFilter(function (ele) {
              return !hasCompoundNodes || ele.isEdge();
            }).forEach(setInDragLayer);
          }

          if (opts.addToList) {
            nodes.forEach(function (ele) {
              addToDragList(ele, opts);
            });
          }

          addDescendantsToDrag(nodes, opts); // always add to drag
    // also add nodes and edges related to the topmost ancestor

          updateAncestorsInDragLayer(nodes, {
            inDragLayer: opts.inDragLayer
          });
          r.updateCachedGrabbedEles();
        };

        const addNodeToDrag = addNodesToDrag;

        const freeDraggedElements = function freeDraggedElements(grabbedEles) {
          if (!grabbedEles) {
            return;
          } // just go over all elements rather than doing a bunch of (possibly expensive) traversals


          r.getCachedZSortedEles().forEach(function (ele) {
            setFreed(ele);
            setOutDragLayer(ele);
            removeGrabTarget(ele);
          });
          r.updateCachedGrabbedEles();
        }; // helper function to determine which ancestor nodes and edges should go
  // to the drag layer (or should be removed from drag layer).


        var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {
          if (opts.inDragLayer == null && opts.addToList == null) {
            return;
          } // nothing to do


          if (!node.cy().hasCompoundNodes()) {
            return;
          } // find top-level parent


          const parent = node.ancestors().orphans(); // no parent node: no nodes to add to the drag layer

          if (parent.same(node)) {
            return;
          }

          const nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());
          const edges = nodes.connectedEdges();

          if (opts.inDragLayer) {
            edges.forEach(setInDragLayer);
            nodes.forEach(setInDragLayer);
          }

          if (opts.addToList) {
            nodes.forEach(function (ele) {
              addToDragList(ele, opts);
            });
          }
        };

        const blurActiveDomElement = function blurActiveDomElement() {
          if (document.activeElement != null && document.activeElement.blur != null) {
            document.activeElement.blur();
          }
        };

        const haveMutationsApi = typeof MutationObserver !== 'undefined';
        const haveResizeObserverApi = typeof ResizeObserver !== 'undefined'; // watch for when the cy container is removed from the dom

        if (haveMutationsApi) {
          r.removeObserver = new MutationObserver(function (mutns) {
      // eslint-disable-line no-undef
            for (let i = 0; i < mutns.length; i++) {
              const mutn = mutns[i];
              const rNodes = mutn.removedNodes;

              if (rNodes) {
                for (let j = 0; j < rNodes.length; j++) {
                  const rNode = rNodes[j];

                  if (rNode === r.container) {
                    r.destroy();
                    break;
                  }
                }
              }
            }
          });

          if (r.container.parentNode) {
            r.removeObserver.observe(r.container.parentNode, {
              childList: true
            });
          }
        } else {
          r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {
      // eslint-disable-line no-unused-vars
            r.destroy();
          });
        }

        const onResize = util(function () {
          r.cy.resize();
        }, 100);

        if (haveMutationsApi) {
          r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef

          r.styleObserver.observe(r.container, {
            attributes: true
          });
        } // auto resize


        r.registerBinding(window, 'resize', onResize); // eslint-disable-line no-undef

        if (haveResizeObserverApi) {
          r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef

          r.resizeObserver.observe(r.container);
        }

        const forEachUp = function forEachUp(domEle, fn) {
          while (domEle != null) {
            fn(domEle);
            domEle = domEle.parentNode;
          }
        };

        const invalidateCoords = function invalidateCoords() {
          r.invalidateContainerClientCoordsCache();
        };

        forEachUp(r.container, function (domEle) {
          r.registerBinding(domEle, 'transitionend', invalidateCoords);
          r.registerBinding(domEle, 'animationend', invalidateCoords);
          r.registerBinding(domEle, 'scroll', invalidateCoords);
        }); // stop right click menu from appearing on cy

        r.registerBinding(r.container, 'contextmenu', function (e) {
          e.preventDefault();
        });

        const inBoxSelection = function inBoxSelection() {
          return r.selection[4] !== 0;
        };

        const eventInContainer = function eventInContainer(e) {
    // save cycles if mouse events aren't to be captured
          const containerPageCoords = r.findContainerClientCoords();
          const x = containerPageCoords[0];
          const y = containerPageCoords[1];
          const width = containerPageCoords[2];
          const height = containerPageCoords[3];
          const positions = e.touches ? e.touches : [e];
          let atLeastOnePosInside = false;

          for (let i = 0; i < positions.length; i++) {
            const p = positions[i];

            if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {
              atLeastOnePosInside = true;
              break;
            }
          }

          if (!atLeastOnePosInside) {
            return false;
          }

          const container = r.container;
          const target = e.target;
          let tParent = target.parentNode;
          let containerIsTarget = false;

          while (tParent) {
            if (tParent === container) {
              containerIsTarget = true;
              break;
            }

            tParent = tParent.parentNode;
          }

          if (!containerIsTarget) {
            return false;
          } // if target is outisde cy container, then this event is not for us


          return true;
        }; // Primary key


        r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {
          if (!eventInContainer(e)) {
            return;
          }

          e.preventDefault();
          blurActiveDomElement();
          r.hoverData.capture = true;
          r.hoverData.which = e.which;
          const cy = r.cy;
          const gpos = [e.clientX, e.clientY];
          const pos = r.projectIntoViewport(gpos[0], gpos[1]);
          const select = r.selection;
          const nears = r.findNearestElements(pos[0], pos[1], true, false);
          const near = nears[0];
          let draggedElements = r.dragData.possibleDragElements;
          r.hoverData.mdownPos = pos;
          r.hoverData.mdownGPos = gpos;

          const checkForTaphold = function checkForTaphold() {
            r.hoverData.tapholdCancelled = false;
            clearTimeout(r.hoverData.tapholdTimeout);
            r.hoverData.tapholdTimeout = setTimeout(function () {
              if (r.hoverData.tapholdCancelled) {
                return;
              } else {
                const ele = r.hoverData.down;

                if (ele) {
                  ele.emit({
                    originalEvent: e,
                    type: 'taphold',
                    position: {
                      x: pos[0],
                      y: pos[1]
                    }
                  });
                } else {
                  cy.emit({
                    originalEvent: e,
                    type: 'taphold',
                    position: {
                      x: pos[0],
                      y: pos[1]
                    }
                  });
                }
              }
            }, r.tapholdDuration);
          }; // Right click button


          if (e.which == 3) {
            r.hoverData.cxtStarted = true;
            const cxtEvt = {
              originalEvent: e,
              type: 'cxttapstart',
              position: {
                x: pos[0],
                y: pos[1]
              }
            };

            if (near) {
              near.activate();
              near.emit(cxtEvt);
              r.hoverData.down = near;
            } else {
              cy.emit(cxtEvt);
            }

            r.hoverData.downTime = new Date().getTime();
            r.hoverData.cxtDragged = false; // Primary button
          } else if (e.which == 1) {
            if (near) {
              near.activate();
            } // Element dragging


            {
        // If something is under the cursor and it is draggable, prepare to grab it
              if (near != null) {
                if (r.nodeIsGrabbable(near)) {
                  const makeEvent = function makeEvent(type) {
                    return {
                      originalEvent: e,
                      type: type,
                      position: {
                        x: pos[0],
                        y: pos[1]
                      }
                    };
                  };

                  const triggerGrab = function triggerGrab(ele) {
                    ele.emit(makeEvent('grab'));
                  };

                  setGrabTarget(near);

                  if (!near.selected()) {
                    draggedElements = r.dragData.possibleDragElements = cy.collection();
                    addNodeToDrag(near, {
                      addToList: draggedElements
                    });
                    near.emit(makeEvent('grabon')).emit(makeEvent('grab'));
                  } else {
                    draggedElements = r.dragData.possibleDragElements = cy.collection();
                    const selectedNodes = cy.$(function (ele) {
                      return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);
                    });
                    addNodesToDrag(selectedNodes, {
                      addToList: draggedElements
                    });
                    near.emit(makeEvent('grabon'));
                    selectedNodes.forEach(triggerGrab);
                  }

                  r.redrawHint('eles', true);
                  r.redrawHint('drag', true);
                }
              }

              r.hoverData.down = near;
              r.hoverData.downs = nears;
              r.hoverData.downTime = new Date().getTime();
            }
            triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {
              x: pos[0],
              y: pos[1]
            });

            if (near == null) {
              select[4] = 1;
              r.data.bgActivePosistion = {
                x: pos[0],
                y: pos[1]
              };
              r.redrawHint('select', true);
              r.redraw();
            } else if (near.pannable()) {
              select[4] = 1; // for future pan
            }

            checkForTaphold();
          } // Initialize selection box coordinates


          select[0] = select[2] = pos[0];
          select[1] = select[3] = pos[1];
        }, false);
        r.registerBinding(window, 'mousemove', function mousemoveHandler(e) {
    // eslint-disable-line no-undef
          const capture = r.hoverData.capture;

          if (!capture && !eventInContainer(e)) {
            return;
          }

          let preventDefault = false;
          const cy = r.cy;
          const zoom = cy.zoom();
          const gpos = [e.clientX, e.clientY];
          let pos = r.projectIntoViewport(gpos[0], gpos[1]);
          const mdownPos = r.hoverData.mdownPos;
          const mdownGPos = r.hoverData.mdownGPos;
          const select = r.selection;
          let near = null;

          if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {
            near = r.findNearestElement(pos[0], pos[1], true, false);
          }

          const last = r.hoverData.last;
          const down = r.hoverData.down;
          const disp = [pos[0] - select[2], pos[1] - select[3]];
          const draggedElements = r.dragData.possibleDragElements;
          let isOverThresholdDrag;

          if (mdownGPos) {
            const dx = gpos[0] - mdownGPos[0];
            const dx2 = dx * dx;
            const dy = gpos[1] - mdownGPos[1];
            const dy2 = dy * dy;
            const dist2 = dx2 + dy2;
            r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;
          }

          const multSelKeyDown = isMultSelKeyDown(e);

          if (isOverThresholdDrag) {
            r.hoverData.tapholdCancelled = true;
          }

          const updateDragDelta = function updateDragDelta() {
            const dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

            if (dragDelta.length === 0) {
              dragDelta.push(disp[0]);
              dragDelta.push(disp[1]);
            } else {
              dragDelta[0] += disp[0];
              dragDelta[1] += disp[1];
            }
          };

          preventDefault = true;
          triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {
            x: pos[0],
            y: pos[1]
          });

          const goIntoBoxMode = function goIntoBoxMode() {
            r.data.bgActivePosistion = undefined;

            if (!r.hoverData.selecting) {
              cy.emit({
                originalEvent: e,
                type: 'boxstart',
                position: {
                  x: pos[0],
                  y: pos[1]
                }
              });
            }

            select[4] = 1;
            r.hoverData.selecting = true;
            r.redrawHint('select', true);
            r.redraw();
          }; // trigger context drag if rmouse down


          if (r.hoverData.which === 3) {
      // but only if over threshold
            if (isOverThresholdDrag) {
              const cxtEvt = {
                originalEvent: e,
                type: 'cxtdrag',
                position: {
                  x: pos[0],
                  y: pos[1]
                }
              };

              if (down) {
                down.emit(cxtEvt);
              } else {
                cy.emit(cxtEvt);
              }

              r.hoverData.cxtDragged = true;

              if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {
                if (r.hoverData.cxtOver) {
                  r.hoverData.cxtOver.emit({
                    originalEvent: e,
                    type: 'cxtdragout',
                    position: {
                      x: pos[0],
                      y: pos[1]
                    }
                  });
                }

                r.hoverData.cxtOver = near;

                if (near) {
                  near.emit({
                    originalEvent: e,
                    type: 'cxtdragover',
                    position: {
                      x: pos[0],
                      y: pos[1]
                    }
                  });
                }
              }
            } // Check if we are drag panning the entire graph

          } else if (r.hoverData.dragging) {
            preventDefault = true;

            if (cy.panningEnabled() && cy.userPanningEnabled()) {
              let deltaP;

              if (r.hoverData.justStartedPan) {
                const mdPos = r.hoverData.mdownPos;
                deltaP = {
                  x: (pos[0] - mdPos[0]) * zoom,
                  y: (pos[1] - mdPos[1]) * zoom
                };
                r.hoverData.justStartedPan = false;
              } else {
                deltaP = {
                  x: disp[0] * zoom,
                  y: disp[1] * zoom
                };
              }

              cy.panBy(deltaP);
              r.hoverData.dragged = true;
            } // Needs reproject due to pan changing viewport


            pos = r.projectIntoViewport(e.clientX, e.clientY); // Checks primary button down & out of time & mouse not moved much
          } else if (select[4] == 1 && (down == null || down.pannable())) {
            if (isOverThresholdDrag) {
              if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {
                goIntoBoxMode();
              } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {
                const allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);

                if (allowPassthrough) {
                  r.hoverData.dragging = true;
                  r.hoverData.justStartedPan = true;
                  select[4] = 0;
                  r.data.bgActivePosistion = array2point(mdownPos);
                  r.redrawHint('select', true);
                  r.redraw();
                }
              }

              if (down && down.pannable() && down.active()) {
                down.unactivate();
              }
            }
          } else {
            if (down && down.pannable() && down.active()) {
              down.unactivate();
            }

            if ((!down || !down.grabbed()) && near != last) {
              if (last) {
                triggerEvents(last, ['mouseout', 'tapdragout'], e, {
                  x: pos[0],
                  y: pos[1]
                });
              }

              if (near) {
                triggerEvents(near, ['mouseover', 'tapdragover'], e, {
                  x: pos[0],
                  y: pos[1]
                });
              }

              r.hoverData.last = near;
            }

            if (down) {
              if (isOverThresholdDrag) {
          // then we can take action
                if (cy.boxSelectionEnabled() && multSelKeyDown) {
            // then selection overrides
                  if (down && down.grabbed()) {
                    freeDraggedElements(draggedElements);
                    down.emit('freeon');
                    draggedElements.emit('free');

                    if (r.dragData.didDrag) {
                      down.emit('dragfreeon');
                      draggedElements.emit('dragfree');
                    }
                  }

                  goIntoBoxMode();
                } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {
            // drag node
                  const justStartedDrag = !r.dragData.didDrag;

                  if (justStartedDrag) {
                    r.redrawHint('eles', true);
                  }

                  r.dragData.didDrag = true; // indicate that we actually did drag the node

                  const toTrigger = cy.collection(); // now, add the elements to the drag layer if not done already

                  if (!r.hoverData.draggingEles) {
                    addNodesToDrag(draggedElements, {
                      inDragLayer: true
                    });
                  }

                  const totalShift = {
                    x: 0,
                    y: 0
                  };

                  if (number(disp[0]) && number(disp[1])) {
                    totalShift.x += disp[0];
                    totalShift.y += disp[1];

                    if (justStartedDrag) {
                      const dragDelta = r.hoverData.dragDelta;

                      if (dragDelta && number(dragDelta[0]) && number(dragDelta[1])) {
                        totalShift.x += dragDelta[0];
                        totalShift.y += dragDelta[1];
                      }
                    }
                  }

                  for (let i = 0; i < draggedElements.length; i++) {
                    const dEle = draggedElements[i];

                    if (r.nodeIsDraggable(dEle) && dEle.grabbed()) {
                      toTrigger.push(dEle);
                    }
                  }

                  r.hoverData.draggingEles = true;
                  toTrigger.silentShift(totalShift).emit('position drag');
                  r.redrawHint('drag', true);
                  r.redraw();
                }
              } else {
          // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
                updateDragDelta();
              }
            } // prevent the dragging from triggering text selection on the page


            preventDefault = true;
          }

          select[2] = pos[0];
          select[3] = pos[1];

          if (preventDefault) {
            if (e.stopPropagation) e.stopPropagation();
            if (e.preventDefault) e.preventDefault();
            return false;
          }
        }, false);
        r.registerBinding(window, 'mouseup', function mouseupHandler(e) {
    // eslint-disable-line no-undef
          const capture = r.hoverData.capture;

          if (!capture) {
            return;
          }

          r.hoverData.capture = false;
          const cy = r.cy;
          const pos = r.projectIntoViewport(e.clientX, e.clientY);
          const select = r.selection;
          const near = r.findNearestElement(pos[0], pos[1], true, false);
          let draggedElements = r.dragData.possibleDragElements;
          const down = r.hoverData.down;
          const multSelKeyDown = isMultSelKeyDown(e);

          if (r.data.bgActivePosistion) {
            r.redrawHint('select', true);
            r.redraw();
          }

          r.hoverData.tapholdCancelled = true;
          r.data.bgActivePosistion = undefined; // not active bg now

          if (down) {
            down.unactivate();
          }

          if (r.hoverData.which === 3) {
            const cxtEvt = {
              originalEvent: e,
              type: 'cxttapend',
              position: {
                x: pos[0],
                y: pos[1]
              }
            };

            if (down) {
              down.emit(cxtEvt);
            } else {
              cy.emit(cxtEvt);
            }

            if (!r.hoverData.cxtDragged) {
              const cxtTap = {
                originalEvent: e,
                type: 'cxttap',
                position: {
                  x: pos[0],
                  y: pos[1]
                }
              };

              if (down) {
                down.emit(cxtTap);
              } else {
                cy.emit(cxtTap);
              }
            }

            r.hoverData.cxtDragged = false;
            r.hoverData.which = null;
          } else if (r.hoverData.which === 1) {
            triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {
              x: pos[0],
              y: pos[1]
            });

            if (!r.dragData.didDrag // didn't move a node around
      && !r.hoverData.dragged // didn't pan
      && !r.hoverData.selecting // not box selection
      && !r.hoverData.isOverThresholdDrag // didn't move too much
            ) {
              triggerEvents(down, ['click', 'tap', 'vclick'], e, {
                x: pos[0],
                y: pos[1]
              });
            } // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something


            if (down == null && // not mousedown on node
      !r.dragData.didDrag // didn't move the node around
      && !r.hoverData.selecting // not box selection
      && !r.hoverData.dragged // didn't pan
      && !isMultSelKeyDown(e)) {
              cy.$(isSelected).unselect(['tapunselect']);

              if (draggedElements.length > 0) {
                r.redrawHint('eles', true);
              }

              r.dragData.possibleDragElements = draggedElements = cy.collection();
            } // Single selection


            if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {
              if (near != null && near._private.selectable) {
                if (r.hoverData.dragging) ; else if (cy.selectionType() === 'additive' || multSelKeyDown) {
                  if (near.selected()) {
                    near.unselect(['tapunselect']);
                  } else {
                    near.select(['tapselect']);
                  }
                } else {
                  if (!multSelKeyDown) {
                    cy.$(isSelected).unmerge(near).unselect(['tapunselect']);
                    near.select(['tapselect']);
                  }
                }

                r.redrawHint('eles', true);
              }
            }

            if (r.hoverData.selecting) {
              const box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));
              r.redrawHint('select', true);

              if (box.length > 0) {
                r.redrawHint('eles', true);
              }

              cy.emit({
                type: 'boxend',
                originalEvent: e,
                position: {
                  x: pos[0],
                  y: pos[1]
                }
              });

              const eleWouldBeSelected = function eleWouldBeSelected(ele) {
                return ele.selectable() && !ele.selected();
              };

              if (cy.selectionType() === 'additive') {
                box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
              } else {
                if (!multSelKeyDown) {
                  cy.$(isSelected).unmerge(box).unselect();
                }

                box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
              } // always need redraw in case eles unselectable


              r.redraw();
            } // Cancel drag pan


            if (r.hoverData.dragging) {
              r.hoverData.dragging = false;
              r.redrawHint('select', true);
              r.redrawHint('eles', true);
              r.redraw();
            }

            if (!select[4]) {
              r.redrawHint('drag', true);
              r.redrawHint('eles', true);
              const downWasGrabbed = down && down.grabbed();
              freeDraggedElements(draggedElements);

              if (downWasGrabbed) {
                down.emit('freeon');
                draggedElements.emit('free');

                if (r.dragData.didDrag) {
                  down.emit('dragfreeon');
                  draggedElements.emit('dragfree');
                }
              }
            }
          } // else not right mouse


          select[4] = 0;
          r.hoverData.down = null;
          r.hoverData.cxtStarted = false;
          r.hoverData.draggingEles = false;
          r.hoverData.selecting = false;
          r.hoverData.isOverThresholdDrag = false;
          r.dragData.didDrag = false;
          r.hoverData.dragged = false;
          r.hoverData.dragDelta = [];
          r.hoverData.mdownPos = null;
          r.hoverData.mdownGPos = null;
        }, false);

        const wheelHandler = function wheelHandler(e) {
          if (r.scrollingPage) {
            return;
          } // while scrolling, ignore wheel-to-zoom


          const cy = r.cy;
          const zoom = cy.zoom();
          const pan = cy.pan();
          const pos = r.projectIntoViewport(e.clientX, e.clientY);
          const rpos = [pos[0] * zoom + pan.x, pos[1] * zoom + pan.y];

          if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {
      // if pan dragging or cxt dragging, wheel movements make no zoom
            e.preventDefault();
            return;
          }

          if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {
            e.preventDefault();
            r.data.wheelZooming = true;
            clearTimeout(r.data.wheelTimeout);
            r.data.wheelTimeout = setTimeout(function () {
              r.data.wheelZooming = false;
              r.redrawHint('eles', true);
              r.redraw();
            }, 150);
            let diff;

            if (e.deltaY != null) {
              diff = e.deltaY / -250;
            } else if (e.wheelDeltaY != null) {
              diff = e.wheelDeltaY / 1000;
            } else {
              diff = e.wheelDelta / 1000;
            }

            diff = diff * r.wheelSensitivity;
            const needsWheelFix = e.deltaMode === 1;

            if (needsWheelFix) {
        // fixes slow wheel events on ff/linux and ff/windows
              diff *= 33;
            }

            let newZoom = cy.zoom() * Math.pow(10, diff);

            if (e.type === 'gesturechange') {
              newZoom = r.gestureStartZoom * e.scale;
            }

            cy.zoom({
              level: newZoom,
              renderedPosition: {
                x: rpos[0],
                y: rpos[1]
              }
            });
          }
        }; // Functions to help with whether mouse wheel should trigger zooming
  // --


        r.registerBinding(r.container, 'wheel', wheelHandler, true); // disable nonstandard wheel events
  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

        r.registerBinding(window, 'scroll', function scrollHandler(e) {
    // eslint-disable-line no-unused-vars
          r.scrollingPage = true;
          clearTimeout(r.scrollingPageTimeout);
          r.scrollingPageTimeout = setTimeout(function () {
            r.scrollingPage = false;
          }, 250);
        }, true); // desktop safari pinch to zoom start

        r.registerBinding(r.container, 'gesturestart', function gestureStartHandler(e) {
          r.gestureStartZoom = r.cy.zoom();

          if (!r.hasTouchStarted) {
      // don't affect touch devices like iphone
            e.preventDefault();
          }
        }, true);
        r.registerBinding(r.container, 'gesturechange', function (e) {
          if (!r.hasTouchStarted) {
      // don't affect touch devices like iphone
            wheelHandler(e);
          }
        }, true); // Functions to help with handling mouseout/mouseover on the Cytoscape container
  // Handle mouseout on Cytoscape container

        r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {
          const pos = r.projectIntoViewport(e.clientX, e.clientY);
          r.cy.emit({
            originalEvent: e,
            type: 'mouseout',
            position: {
              x: pos[0],
              y: pos[1]
            }
          });
        }, false);
        r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {
          const pos = r.projectIntoViewport(e.clientX, e.clientY);
          r.cy.emit({
            originalEvent: e,
            type: 'mouseover',
            position: {
              x: pos[0],
              y: pos[1]
            }
          });
        }, false);
        let f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom

        let distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom

        let center1, modelCenter1; // center point on start pinch to zoom

        let offsetLeft, offsetTop;
        let containerWidth, containerHeight;
        let twoFingersStartInside;

        const distance = function distance(x1, y1, x2, y2) {
          return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        };

        const distanceSq = function distanceSq(x1, y1, x2, y2) {
          return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
        };

        let touchstartHandler;
        r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {
          r.hasTouchStarted = true;

          if (!eventInContainer(e)) {
            return;
          }

          blurActiveDomElement();
          r.touchData.capture = true;
          r.data.bgActivePosistion = undefined;
          const cy = r.cy;
          const now = r.touchData.now;
          const earlier = r.touchData.earlier;

          if (e.touches[0]) {
            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
            now[0] = pos[0];
            now[1] = pos[1];
          }

          if (e.touches[1]) {
            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
            now[2] = pos[0];
            now[3] = pos[1];
          }

          if (e.touches[2]) {
            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
            now[4] = pos[0];
            now[5] = pos[1];
          } // record starting points for pinch-to-zoom


          if (e.touches[1]) {
            r.touchData.singleTouchMoved = true;
            freeDraggedElements(r.dragData.touchDragEles);
            const offsets = r.findContainerClientCoords();
            offsetLeft = offsets[0];
            offsetTop = offsets[1];
            containerWidth = offsets[2];
            containerHeight = offsets[3];
            f1x1 = e.touches[0].clientX - offsetLeft;
            f1y1 = e.touches[0].clientY - offsetTop;
            f2x1 = e.touches[1].clientX - offsetLeft;
            f2y1 = e.touches[1].clientY - offsetTop;
            twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;
            const pan = cy.pan();
            const zoom = cy.zoom();
            distance1 = distance(f1x1, f1y1, f2x1, f2y1);
            distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);
            center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];
            modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom]; // consider context tap

            const cxtDistThreshold = 200;
            const cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;

            if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {
              const near1 = r.findNearestElement(now[0], now[1], true, true);
              const near2 = r.findNearestElement(now[2], now[3], true, true);

              if (near1 && near1.isNode()) {
                near1.activate().emit({
                  originalEvent: e,
                  type: 'cxttapstart',
                  position: {
                    x: now[0],
                    y: now[1]
                  }
                });
                r.touchData.start = near1;
              } else if (near2 && near2.isNode()) {
                near2.activate().emit({
                  originalEvent: e,
                  type: 'cxttapstart',
                  position: {
                    x: now[0],
                    y: now[1]
                  }
                });
                r.touchData.start = near2;
              } else {
                cy.emit({
                  originalEvent: e,
                  type: 'cxttapstart',
                  position: {
                    x: now[0],
                    y: now[1]
                  }
                });
              }

              if (r.touchData.start) {
                r.touchData.start._private.grabbed = false;
              }

              r.touchData.cxt = true;
              r.touchData.cxtDragged = false;
              r.data.bgActivePosistion = undefined;
              r.redraw();
              return;
            }
          }

          if (e.touches[2]) {
      // ignore
      // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)
            if (cy.boxSelectionEnabled()) {
              e.preventDefault();
            }
          } else if (e.touches[1]) ; else if (e.touches[0]) {
            const nears = r.findNearestElements(now[0], now[1], true, true);
            const near = nears[0];

            if (near != null) {
              near.activate();
              r.touchData.start = near;
              r.touchData.starts = nears;

              if (r.nodeIsGrabbable(near)) {
                const draggedEles = r.dragData.touchDragEles = cy.collection();
                let selectedNodes = null;
                r.redrawHint('eles', true);
                r.redrawHint('drag', true);

                if (near.selected()) {
            // reset drag elements, since near will be added again
                  selectedNodes = cy.$(function (ele) {
                    return ele.selected() && r.nodeIsGrabbable(ele);
                  });
                  addNodesToDrag(selectedNodes, {
                    addToList: draggedEles
                  });
                } else {
                  addNodeToDrag(near, {
                    addToList: draggedEles
                  });
                }

                setGrabTarget(near);

                const makeEvent = function makeEvent(type) {
                  return {
                    originalEvent: e,
                    type: type,
                    position: {
                      x: now[0],
                      y: now[1]
                    }
                  };
                };

                near.emit(makeEvent('grabon'));

                if (selectedNodes) {
                  selectedNodes.forEach(function (n) {
                    n.emit(makeEvent('grab'));
                  });
                } else {
                  near.emit(makeEvent('grab'));
                }
              }
            }

            triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {
              x: now[0],
              y: now[1]
            });

            if (near == null) {
              r.data.bgActivePosistion = {
                x: pos[0],
                y: pos[1]
              };
              r.redrawHint('select', true);
              r.redraw();
            } // Tap, taphold
      // -----


            r.touchData.singleTouchMoved = false;
            r.touchData.singleTouchStartTime = +new Date();
            clearTimeout(r.touchData.tapholdTimeout);
            r.touchData.tapholdTimeout = setTimeout(function () {
              if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect
        && !r.touchData.selecting // box selection shouldn't allow taphold through
              ) {
                triggerEvents(r.touchData.start, ['taphold'], e, {
                  x: now[0],
                  y: now[1]
                });
              }
            }, r.tapholdDuration);
          }

          if (e.touches.length >= 1) {
            const sPos = r.touchData.startPosition = [];

            for (let i = 0; i < now.length; i++) {
              sPos[i] = earlier[i] = now[i];
            }

            const touch0 = e.touches[0];
            r.touchData.startGPosition = [touch0.clientX, touch0.clientY];
          }
        }, false);
        let touchmoveHandler;
        r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {
    // eslint-disable-line no-undef
          const capture = r.touchData.capture;

          if (!capture && !eventInContainer(e)) {
            return;
          }

          const select = r.selection;
          const cy = r.cy;
          const now = r.touchData.now;
          const earlier = r.touchData.earlier;
          const zoom = cy.zoom();

          if (e.touches[0]) {
            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
            now[0] = pos[0];
            now[1] = pos[1];
          }

          if (e.touches[1]) {
            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
            now[2] = pos[0];
            now[3] = pos[1];
          }

          if (e.touches[2]) {
            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
            now[4] = pos[0];
            now[5] = pos[1];
          }

          const startGPos = r.touchData.startGPosition;
          let isOverThresholdDrag;

          if (capture && e.touches[0] && startGPos) {
            var disp = [];

            for (var j = 0; j < now.length; j++) {
              disp[j] = now[j] - earlier[j];
            }

            var dx = e.touches[0].clientX - startGPos[0];
            const dx2 = dx * dx;
            var dy = e.touches[0].clientY - startGPos[1];
            const dy2 = dy * dy;
            const dist2 = dx2 + dy2;
            isOverThresholdDrag = dist2 >= r.touchTapThreshold2;
          } // context swipe cancelling


          if (capture && r.touchData.cxt) {
            e.preventDefault();
            var f1x2 = e.touches[0].clientX - offsetLeft,
              f1y2 = e.touches[0].clientY - offsetTop;
            var f2x2 = e.touches[1].clientX - offsetLeft,
              f2y2 = e.touches[1].clientY - offsetTop; // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );

            const distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);
            const factorSq = distance2Sq / distance1Sq;
            const distThreshold = 150;
            const distThresholdSq = distThreshold * distThreshold;
            const factorThreshold = 1.5;
            const factorThresholdSq = factorThreshold * factorThreshold; // cancel ctx gestures if the distance b/t the fingers increases

            if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {
              r.touchData.cxt = false;
              r.data.bgActivePosistion = undefined;
              r.redrawHint('select', true);
              var cxtEvt = {
                originalEvent: e,
                type: 'cxttapend',
                position: {
                  x: now[0],
                  y: now[1]
                }
              };

              if (r.touchData.start) {
                r.touchData.start.unactivate().emit(cxtEvt);
                r.touchData.start = null;
              } else {
                cy.emit(cxtEvt);
              }
            }
          } // context swipe


          if (capture && r.touchData.cxt) {
            var cxtEvt = {
              originalEvent: e,
              type: 'cxtdrag',
              position: {
                x: now[0],
                y: now[1]
              }
            };
            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);

            if (r.touchData.start) {
              r.touchData.start.emit(cxtEvt);
            } else {
              cy.emit(cxtEvt);
            }

            if (r.touchData.start) {
              r.touchData.start._private.grabbed = false;
            }

            r.touchData.cxtDragged = true;
            var near = r.findNearestElement(now[0], now[1], true, true);

            if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {
              if (r.touchData.cxtOver) {
                r.touchData.cxtOver.emit({
                  originalEvent: e,
                  type: 'cxtdragout',
                  position: {
                    x: now[0],
                    y: now[1]
                  }
                });
              }

              r.touchData.cxtOver = near;

              if (near) {
                near.emit({
                  originalEvent: e,
                  type: 'cxtdragover',
                  position: {
                    x: now[0],
                    y: now[1]
                  }
                });
              }
            } // box selection

          } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {
            e.preventDefault();
            r.data.bgActivePosistion = undefined;
            this.lastThreeTouch = +new Date();

            if (!r.touchData.selecting) {
              cy.emit({
                originalEvent: e,
                type: 'boxstart',
                position: {
                  x: now[0],
                  y: now[1]
                }
              });
            }

            r.touchData.selecting = true;
            r.touchData.didSelect = true;
            select[4] = 1;

            if (!select || select.length === 0 || select[0] === undefined) {
              select[0] = (now[0] + now[2] + now[4]) / 3;
              select[1] = (now[1] + now[3] + now[5]) / 3;
              select[2] = (now[0] + now[2] + now[4]) / 3 + 1;
              select[3] = (now[1] + now[3] + now[5]) / 3 + 1;
            } else {
              select[2] = (now[0] + now[2] + now[4]) / 3;
              select[3] = (now[1] + now[3] + now[5]) / 3;
            }

            r.redrawHint('select', true);
            r.redraw(); // pinch to zoom
          } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom
    && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {
      // two fingers => pinch to zoom
            e.preventDefault();
            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);
            var draggedEles = r.dragData.touchDragEles;

            if (draggedEles) {
              r.redrawHint('drag', true);

              for (var i = 0; i < draggedEles.length; i++) {
                const de_p = draggedEles[i]._private;
                de_p.grabbed = false;
                de_p.rscratch.inDragLayer = false;
              }
            }

            const _start = r.touchData.start; // (x2, y2) for fingers 1 and 2

            var f1x2 = e.touches[0].clientX - offsetLeft,
              f1y2 = e.touches[0].clientY - offsetTop;
            var f2x2 = e.touches[1].clientX - offsetLeft,
              f2y2 = e.touches[1].clientY - offsetTop;
            const distance2 = distance(f1x2, f1y2, f2x2, f2y2); // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );

            const factor = distance2 / distance1;

            if (twoFingersStartInside) {
        // delta finger1
              const df1x = f1x2 - f1x1;
              const df1y = f1y2 - f1y1; // delta finger 2

              const df2x = f2x2 - f2x1;
              const df2y = f2y2 - f2y1; // translation is the normalised vector of the two fingers movement
        // i.e. so pinching cancels out and moving together pans

              const tx = (df1x + df2x) / 2;
              const ty = (df1y + df2y) / 2; // now calculate the zoom

              const zoom1 = cy.zoom();
              const zoom2 = zoom1 * factor;
              const pan1 = cy.pan(); // the model center point converted to the current rendered pos

              const ctrx = modelCenter1[0] * zoom1 + pan1.x;
              const ctry = modelCenter1[1] * zoom1 + pan1.y;
              const pan2 = {
                x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
                y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry
              }; // remove dragged eles

              if (_start && _start.active()) {
                var draggedEles = r.dragData.touchDragEles;
                freeDraggedElements(draggedEles);
                r.redrawHint('drag', true);
                r.redrawHint('eles', true);

                _start.unactivate().emit('freeon');

                draggedEles.emit('free');

                if (r.dragData.didDrag) {
                  _start.emit('dragfreeon');

                  draggedEles.emit('dragfree');
                }
              }

              cy.viewport({
                zoom: zoom2,
                pan: pan2,
                cancelOnFailedZoom: true
              });
              distance1 = distance2;
              f1x1 = f1x2;
              f1y1 = f1y2;
              f2x1 = f2x2;
              f2y1 = f2y2;
              r.pinching = true;
            } // Re-project


            if (e.touches[0]) {
              var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
              now[0] = pos[0];
              now[1] = pos[1];
            }

            if (e.touches[1]) {
              var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
              now[2] = pos[0];
              now[3] = pos[1];
            }

            if (e.touches[2]) {
              var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
              now[4] = pos[0];
              now[5] = pos[1];
            }
          } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning
          ) {
            const start = r.touchData.start;
            const last = r.touchData.last;
            var near;

            if (!r.hoverData.draggingEles && !r.swipePanning) {
              near = r.findNearestElement(now[0], now[1], true, true);
            }

            if (capture && start != null) {
              e.preventDefault();
            } // dragging nodes


            if (capture && start != null && r.nodeIsDraggable(start)) {
              if (isOverThresholdDrag) {
            // then dragging can happen
                var draggedEles = r.dragData.touchDragEles;
                const justStartedDrag = !r.dragData.didDrag;

                if (justStartedDrag) {
                  addNodesToDrag(draggedEles, {
                    inDragLayer: true
                  });
                }

                r.dragData.didDrag = true;
                const totalShift = {
                  x: 0,
                  y: 0
                };

                if (number(disp[0]) && number(disp[1])) {
                  totalShift.x += disp[0];
                  totalShift.y += disp[1];

                  if (justStartedDrag) {
                    r.redrawHint('eles', true);
                    var dragDelta = r.touchData.dragDelta;

                    if (dragDelta && number(dragDelta[0]) && number(dragDelta[1])) {
                      totalShift.x += dragDelta[0];
                      totalShift.y += dragDelta[1];
                    }
                  }
                }

                r.hoverData.draggingEles = true;
                draggedEles.silentShift(totalShift).emit('position drag');
                r.redrawHint('drag', true);

                if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {
                  r.redrawHint('eles', true);
                }

                r.redraw();
              } else {
            // otherise keep track of drag delta for later
                var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

                if (dragDelta.length === 0) {
                  dragDelta.push(disp[0]);
                  dragDelta.push(disp[1]);
                } else {
                  dragDelta[0] += disp[0];
                  dragDelta[1] += disp[1];
                }
              }
            } // touchmove


            {
              triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {
                x: now[0],
                y: now[1]
              });

              if ((!start || !start.grabbed()) && near != last) {
                if (last) {
                  last.emit({
                    originalEvent: e,
                    type: 'tapdragout',
                    position: {
                      x: now[0],
                      y: now[1]
                    }
                  });
                }

                if (near) {
                  near.emit({
                    originalEvent: e,
                    type: 'tapdragover',
                    position: {
                      x: now[0],
                      y: now[1]
                    }
                  });
                }
              }

              r.touchData.last = near;
            } // check to cancel taphold

            if (capture) {
              for (var i = 0; i < now.length; i++) {
                if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {
                  r.touchData.singleTouchMoved = true;
                }
              }
            } // panning


            if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {
              const allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);

              if (allowPassthrough) {
                e.preventDefault();

                if (!r.data.bgActivePosistion) {
                  r.data.bgActivePosistion = array2point(r.touchData.startPosition);
                }

                if (r.swipePanning) {
                  cy.panBy({
                    x: disp[0] * zoom,
                    y: disp[1] * zoom
                  });
                } else if (isOverThresholdDrag) {
                  r.swipePanning = true;
                  cy.panBy({
                    x: dx * zoom,
                    y: dy * zoom
                  });

                  if (start) {
                    start.unactivate();
                    r.redrawHint('select', true);
                    r.touchData.start = null;
                  }
                }
              } // Re-project


              var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
              now[0] = pos[0];
              now[1] = pos[1];
            }
          }

          for (var j = 0; j < now.length; j++) {
            earlier[j] = now[j];
          } // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning


          if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {
            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);
            r.redraw();
          }
        }, false);
        let touchcancelHandler;
        r.registerBinding(window, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {
    // eslint-disable-line no-unused-vars
          const start = r.touchData.start;
          r.touchData.capture = false;

          if (start) {
            start.unactivate();
          }
        });
        let touchendHandler;
        r.registerBinding(window, 'touchend', touchendHandler = function touchendHandler(e) {
    // eslint-disable-line no-unused-vars
          const start = r.touchData.start;
          const capture = r.touchData.capture;

          if (capture) {
            if (e.touches.length === 0) {
              r.touchData.capture = false;
            }

            e.preventDefault();
          } else {
            return;
          }

          const select = r.selection;
          r.swipePanning = false;
          r.hoverData.draggingEles = false;
          const cy = r.cy;
          const zoom = cy.zoom();
          const now = r.touchData.now;
          const earlier = r.touchData.earlier;

          if (e.touches[0]) {
            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
            now[0] = pos[0];
            now[1] = pos[1];
          }

          if (e.touches[1]) {
            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
            now[2] = pos[0];
            now[3] = pos[1];
          }

          if (e.touches[2]) {
            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
            now[4] = pos[0];
            now[5] = pos[1];
          }

          if (start) {
            start.unactivate();
          }

          let ctxTapend;

          if (r.touchData.cxt) {
            ctxTapend = {
              originalEvent: e,
              type: 'cxttapend',
              position: {
                x: now[0],
                y: now[1]
              }
            };

            if (start) {
              start.emit(ctxTapend);
            } else {
              cy.emit(ctxTapend);
            }

            if (!r.touchData.cxtDragged) {
              const ctxTap = {
                originalEvent: e,
                type: 'cxttap',
                position: {
                  x: now[0],
                  y: now[1]
                }
              };

              if (start) {
                start.emit(ctxTap);
              } else {
                cy.emit(ctxTap);
              }
            }

            if (r.touchData.start) {
              r.touchData.start._private.grabbed = false;
            }

            r.touchData.cxt = false;
            r.touchData.start = null;
            r.redraw();
            return;
          } // no more box selection if we don't have three fingers


          if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {
            r.touchData.selecting = false;
            const box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));
            select[0] = undefined;
            select[1] = undefined;
            select[2] = undefined;
            select[3] = undefined;
            select[4] = 0;
            r.redrawHint('select', true);
            cy.emit({
              type: 'boxend',
              originalEvent: e,
              position: {
                x: now[0],
                y: now[1]
              }
            });

            const eleWouldBeSelected = function eleWouldBeSelected(ele) {
              return ele.selectable() && !ele.selected();
            };

            box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');

            if (box.nonempty()) {
              r.redrawHint('eles', true);
            }

            r.redraw();
          }

          if (start != null) {
            start.unactivate();
          }

          if (e.touches[2]) {
            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);
          } else if (e.touches[1]) ; else if (e.touches[0]) ; else if (!e.touches[0]) {
            r.data.bgActivePosistion = undefined;
            r.redrawHint('select', true);
            const draggedEles = r.dragData.touchDragEles;

            if (start != null) {
              const startWasGrabbed = start._private.grabbed;
              freeDraggedElements(draggedEles);
              r.redrawHint('drag', true);
              r.redrawHint('eles', true);

              if (startWasGrabbed) {
                start.emit('freeon');
                draggedEles.emit('free');

                if (r.dragData.didDrag) {
                  start.emit('dragfreeon');
                  draggedEles.emit('dragfree');
                }
              }

              triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
                x: now[0],
                y: now[1]
              });
              start.unactivate();
              r.touchData.start = null;
            } else {
              const near = r.findNearestElement(now[0], now[1], true, true);
              triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
                x: now[0],
                y: now[1]
              });
            }

            const dx = r.touchData.startPosition[0] - now[0];
            const dx2 = dx * dx;
            const dy = r.touchData.startPosition[1] - now[1];
            const dy2 = dy * dy;
            const dist2 = dx2 + dy2;
            const rdist2 = dist2 * zoom * zoom; // Tap event, roughly same as mouse click event for touch

            if (!r.touchData.singleTouchMoved) {
              if (!start) {
                cy.$(':selected').unselect(['tapunselect']);
              }

              triggerEvents(start, ['tap', 'vclick'], e, {
                x: now[0],
                y: now[1]
              });
            } // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance


            if (start != null && !r.dragData.didDrag // didn't drag nodes around
      && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection
            ) {
              if (cy.selectionType() === 'single') {
                cy.$(isSelected).unmerge(start).unselect(['tapunselect']);
                start.select(['tapselect']);
              } else {
                if (start.selected()) {
                  start.unselect(['tapunselect']);
                } else {
                  start.select(['tapselect']);
                }
              }

              r.redrawHint('eles', true);
            }

            r.touchData.singleTouchMoved = true;
          }

          for (let j = 0; j < now.length; j++) {
            earlier[j] = now[j];
          }

          r.dragData.didDrag = false; // reset for next touchstart

          if (e.touches.length === 0) {
            r.touchData.dragDelta = [];
            r.touchData.startPosition = null;
            r.touchData.startGPosition = null;
            r.touchData.didSelect = false;
          }

          if (e.touches.length < 2) {
            if (e.touches.length === 1) {
        // the old start global pos'n may not be the same finger that remains
              r.touchData.startGPosition = [e.touches[0].clientX, e.touches[0].clientY];
            }

            r.pinching = false;
            r.redrawHint('eles', true);
            r.redraw();
          } //r.redraw();

        }, false); // fallback compatibility layer for ms pointer events

        if (typeof TouchEvent === 'undefined') {
          const pointers = [];

          const makeTouch = function makeTouch(e) {
            return {
              clientX: e.clientX,
              clientY: e.clientY,
              force: 1,
              identifier: e.pointerId,
              pageX: e.pageX,
              pageY: e.pageY,
              radiusX: e.width / 2,
              radiusY: e.height / 2,
              screenX: e.screenX,
              screenY: e.screenY,
              target: e.target
            };
          };

          const makePointer = function makePointer(e) {
            return {
              event: e,
              touch: makeTouch(e)
            };
          };

          const addPointer = function addPointer(e) {
            pointers.push(makePointer(e));
          };

          const removePointer = function removePointer(e) {
            for (let i = 0; i < pointers.length; i++) {
              const p = pointers[i];

              if (p.event.pointerId === e.pointerId) {
                pointers.splice(i, 1);
                return;
              }
            }
          };

          const updatePointer = function updatePointer(e) {
            const p = pointers.filter(function (p) {
              return p.event.pointerId === e.pointerId;
            })[0];
            p.event = e;
            p.touch = makeTouch(e);
          };

          const addTouchesToEvent = function addTouchesToEvent(e) {
            e.touches = pointers.map(function (p) {
              return p.touch;
            });
          };

          const pointerIsMouse = function pointerIsMouse(e) {
            return e.pointerType === 'mouse' || e.pointerType === 4;
          };

          r.registerBinding(r.container, 'pointerdown', function (e) {
            if (pointerIsMouse(e)) {
              return;
            } // mouse already handled


            e.preventDefault();
            addPointer(e);
            addTouchesToEvent(e);
            touchstartHandler(e);
          });
          r.registerBinding(r.container, 'pointerup', function (e) {
            if (pointerIsMouse(e)) {
              return;
            } // mouse already handled


            removePointer(e);
            addTouchesToEvent(e);
            touchendHandler(e);
          });
          r.registerBinding(r.container, 'pointercancel', function (e) {
            if (pointerIsMouse(e)) {
              return;
            } // mouse already handled


            removePointer(e);
            addTouchesToEvent(e);
            touchcancelHandler(e);
          });
          r.registerBinding(r.container, 'pointermove', function (e) {
            if (pointerIsMouse(e)) {
              return;
            } // mouse already handled


            e.preventDefault();
            updatePointer(e);
            addTouchesToEvent(e);
            touchmoveHandler(e);
          });
        }
      };

      const BRp$d = {};

      BRp$d.generatePolygon = function (name, points) {
        return this.nodeShapes[name] = {
          renderer: this,
          name: name,
          points: points,
          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);
          },
          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);
          },
          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);
          }
        };
      };

      BRp$d.generateEllipse = function () {
        return this.nodeShapes['ellipse'] = {
          renderer: this,
          name: 'ellipse',
          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },
          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);
          },
          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            return checkInEllipse(x, y, width, height, centerX, centerY, padding);
          }
        };
      };

      BRp$d.generateRoundPolygon = function (name, points) {
  // Pre-compute control points
  // Since these points depend on the radius length (which in turns depend on the width/height of the node) we will only pre-compute
  // the unit vectors.
  // For simplicity the layout will be:
  // [ p0, UnitVectorP0P1, p1, UniVectorP1P2, ..., pn, UnitVectorPnP0 ]
        const allPoints = new Array(points.length * 2);

        for (let i = 0; i < points.length / 2; i++) {
          const sourceIndex = i * 2;
          let destIndex = void 0;

          if (i < points.length / 2 - 1) {
            destIndex = (i + 1) * 2;
          } else {
            destIndex = 0;
          }

          allPoints[i * 4] = points[sourceIndex];
          allPoints[i * 4 + 1] = points[sourceIndex + 1];
          const xDest = points[destIndex] - points[sourceIndex];
          const yDest = points[destIndex + 1] - points[sourceIndex + 1];
          const norm = Math.sqrt(xDest * xDest + yDest * yDest);
          allPoints[i * 4 + 2] = xDest / norm;
          allPoints[i * 4 + 3] = yDest / norm;
        }

        return this.nodeShapes[name] = {
          renderer: this,
          name: name,
          points: allPoints,
          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl('round-polygon', context, centerX, centerY, width, height, this.points);
          },
          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height);
          },
          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height);
          }
        };
      };

      BRp$d.generateRoundRectangle = function () {
        return this.nodeShapes['round-rectangle'] = this.nodeShapes['roundrectangle'] = {
          renderer: this,
          name: 'round-rectangle',
          points: generateUnitNgonPointsFitToSquare(4, 0),
          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },
          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
          },
          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            const cornerRadius = getRoundRectangleRadius(width, height);
            const diam = cornerRadius * 2; // Check hBox

            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
              return true;
            } // Check vBox


            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
              return true;
            } // Check top left quarter circle


            if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {
              return true;
            } // Check top right quarter circle


            if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {
              return true;
            } // Check bottom right quarter circle


            if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
              return true;
            } // Check bottom left quarter circle


            if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
              return true;
            }

            return false;
          }
        };
      };

      BRp$d.generateCutRectangle = function () {
        return this.nodeShapes['cut-rectangle'] = this.nodeShapes['cutrectangle'] = {
          renderer: this,
          name: 'cut-rectangle',
          cornerLength: getCutRectangleCornerLength(),
          points: generateUnitNgonPointsFitToSquare(4, 0),
          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },
          generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {
            const cl = this.cornerLength;
            const hh = height / 2;
            const hw = width / 2;
            const xBegin = centerX - hw;
            const xEnd = centerX + hw;
            const yBegin = centerY - hh;
            const yEnd = centerY + hh; // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]

            return {
              topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],
              topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],
              bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],
              bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]
            };
          },
          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            const cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);
            const pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);
            return polygonIntersectLine(x, y, pts, nodeX, nodeY);
          },
          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      // Check hBox
            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {
              return true;
            } // Check vBox


            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {
              return true;
            }

            const cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);
            return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);
          }
        };
      };

      BRp$d.generateBarrel = function () {
        return this.nodeShapes['barrel'] = {
          renderer: this,
          name: 'barrel',
          points: generateUnitNgonPointsFitToSquare(4, 0),
          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },
          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      // use two fixed t values for the bezier curve approximation
            const t0 = 0.15;
            const t1 = 0.5;
            const t2 = 0.85;
            const bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);

            const approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {
        // approximate curve pts based on the two t values
              const m0 = qbezierPtAt({
                x: pts[0],
                y: pts[1]
              }, {
                x: pts[2],
                y: pts[3]
              }, {
                x: pts[4],
                y: pts[5]
              }, t0);
              const m1 = qbezierPtAt({
                x: pts[0],
                y: pts[1]
              }, {
                x: pts[2],
                y: pts[3]
              }, {
                x: pts[4],
                y: pts[5]
              }, t1);
              const m2 = qbezierPtAt({
                x: pts[0],
                y: pts[1]
              }, {
                x: pts[2],
                y: pts[3]
              }, {
                x: pts[4],
                y: pts[5]
              }, t2);
              return [pts[0], pts[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts[4], pts[5]];
            };

            const pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));
            return polygonIntersectLine(x, y, pts, nodeX, nodeY);
          },
          generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {
            const hh = height / 2;
            const hw = width / 2;
            const xBegin = centerX - hw;
            const xEnd = centerX + hw;
            const yBegin = centerY - hh;
            const yEnd = centerY + hh;
            const curveConstants = getBarrelCurveConstants(width, height);
            const hOffset = curveConstants.heightOffset;
            const wOffset = curveConstants.widthOffset;
            const ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width; // points are in clockwise order, inner (imaginary) control pt on [4, 5]

            const pts = {
              topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],
              topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],
              bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],
              bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]
            };
            pts.topLeft.isTop = true;
            pts.topRight.isTop = true;
            pts.bottomLeft.isBottom = true;
            pts.bottomRight.isBottom = true;
            return pts;
          },
          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            const curveConstants = getBarrelCurveConstants(width, height);
            const hOffset = curveConstants.heightOffset;
            const wOffset = curveConstants.widthOffset; // Check hBox

            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {
              return true;
            } // Check vBox


            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {
              return true;
            }

            const barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);

            const getCurveT = function getCurveT(x, y, curvePts) {
              const x0 = curvePts[4];
              const x1 = curvePts[2];
              const x2 = curvePts[0];
              const y0 = curvePts[5]; // var y1 = curvePts[ 3 ];

              const y2 = curvePts[1];
              const xMin = Math.min(x0, x2);
              const xMax = Math.max(x0, x2);
              const yMin = Math.min(y0, y2);
              const yMax = Math.max(y0, y2);

              if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {
                const coeff = bezierPtsToQuadCoeff(x0, x1, x2);
                const roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);
                const validRoots = roots.filter(function (r) {
                  return 0 <= r && r <= 1;
                });

                if (validRoots.length > 0) {
                  return validRoots[0];
                }
              }

              return null;
            };

            const curveRegions = Object.keys(barrelCurvePts);

            for (let i = 0; i < curveRegions.length; i++) {
              const corner = curveRegions[i];
              const cornerPts = barrelCurvePts[corner];
              const t = getCurveT(x, y, cornerPts);

              if (t == null) {
                continue;
              }

              const y0 = cornerPts[5];
              const y1 = cornerPts[3];
              const y2 = cornerPts[1];
              const bezY = qbezierAt(y0, y1, y2, t);

              if (cornerPts.isTop && bezY <= y) {
                return true;
              }

              if (cornerPts.isBottom && y <= bezY) {
                return true;
              }
            }

            return false;
          }
        };
      };

      BRp$d.generateBottomRoundrectangle = function () {
        return this.nodeShapes['bottom-round-rectangle'] = this.nodeShapes['bottomroundrectangle'] = {
          renderer: this,
          name: 'bottom-round-rectangle',
          points: generateUnitNgonPointsFitToSquare(4, 0),
          draw: function draw(context, centerX, centerY, width, height) {
            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
          },
          intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
            const topStartX = nodeX - (width / 2 + padding);
            const topStartY = nodeY - (height / 2 + padding);
            const topEndY = topStartY;
            const topEndX = nodeX + (width / 2 + padding);
            const topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

            if (topIntersections.length > 0) {
              return topIntersections;
            }

            return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
          },
          checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
            const cornerRadius = getRoundRectangleRadius(width, height);
            const diam = 2 * cornerRadius; // Check hBox

            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
              return true;
            } // Check vBox


            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
              return true;
            } // check non-rounded top side


            const outerWidth = width / 2 + 2 * padding;
            const outerHeight = height / 2 + 2 * padding;
            const points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];

            if (pointInsidePolygonPoints(x, y, points)) {
              return true;
            } // Check bottom right quarter circle


            if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
              return true;
            } // Check bottom left quarter circle


            if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
              return true;
            }

            return false;
          }
        };
      };

      BRp$d.registerNodeShapes = function () {
        const nodeShapes = this.nodeShapes = {};
        const renderer = this;
        this.generateEllipse();
        this.generatePolygon('triangle', generateUnitNgonPointsFitToSquare(3, 0));
        this.generateRoundPolygon('round-triangle', generateUnitNgonPointsFitToSquare(3, 0));
        this.generatePolygon('rectangle', generateUnitNgonPointsFitToSquare(4, 0));
        nodeShapes['square'] = nodeShapes['rectangle'];
        this.generateRoundRectangle();
        this.generateCutRectangle();
        this.generateBarrel();
        this.generateBottomRoundrectangle();
        {
          const diamondPoints = [0, 1, 1, 0, 0, -1, -1, 0];
          this.generatePolygon('diamond', diamondPoints);
          this.generateRoundPolygon('round-diamond', diamondPoints);
        }
        this.generatePolygon('pentagon', generateUnitNgonPointsFitToSquare(5, 0));
        this.generateRoundPolygon('round-pentagon', generateUnitNgonPointsFitToSquare(5, 0));
        this.generatePolygon('hexagon', generateUnitNgonPointsFitToSquare(6, 0));
        this.generateRoundPolygon('round-hexagon', generateUnitNgonPointsFitToSquare(6, 0));
        this.generatePolygon('heptagon', generateUnitNgonPointsFitToSquare(7, 0));
        this.generateRoundPolygon('round-heptagon', generateUnitNgonPointsFitToSquare(7, 0));
        this.generatePolygon('octagon', generateUnitNgonPointsFitToSquare(8, 0));
        this.generateRoundPolygon('round-octagon', generateUnitNgonPointsFitToSquare(8, 0));
        let star5Points = new Array(20);
        {
          const outerPoints = generateUnitNgonPoints(5, 0);
          const innerPoints = generateUnitNgonPoints(5, Math.PI / 5); // Outer radius is 1; inner radius of star is smaller

          let innerRadius = 0.5 * (3 - Math.sqrt(5));
          innerRadius *= 1.57;

          for (var i = 0; i < innerPoints.length / 2; i++) {
            innerPoints[i * 2] *= innerRadius;
            innerPoints[i * 2 + 1] *= innerRadius;
          }

          for (var i = 0; i < 20 / 4; i++) {
            star5Points[i * 4] = outerPoints[i * 2];
            star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];
            star5Points[i * 4 + 2] = innerPoints[i * 2];
            star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];
          }
        }
        star5Points = fitPolygonToSquare(star5Points);
        this.generatePolygon('star', star5Points);
        this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);
        this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);
        this.nodeShapes['concavehexagon'] = this.generatePolygon('concave-hexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);
        {
          const tagPoints = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];
          this.generatePolygon('tag', tagPoints);
          this.generateRoundPolygon('round-tag', tagPoints);
        }

        nodeShapes.makePolygon = function (points) {
    // use caching on user-specified polygons so they are as fast as native shapes
          const key = points.join('$');
          const name = 'polygon-' + key;
          let shape;

          if (shape = this[name]) {
      // got cached shape
            return shape;
          } // create and cache new shape


          return renderer.generatePolygon(name, points);
        };
      };

      const BRp$e = {};

      BRp$e.timeToRender = function () {
        return this.redrawTotalTime / this.redrawCount;
      };

      BRp$e.redraw = function (options) {
        options = options || staticEmptyObject();
        const r = this;

        if (r.averageRedrawTime === undefined) {
          r.averageRedrawTime = 0;
        }

        if (r.lastRedrawTime === undefined) {
          r.lastRedrawTime = 0;
        }

        if (r.lastDrawTime === undefined) {
          r.lastDrawTime = 0;
        }

        r.requestedFrame = true;
        r.renderOptions = options;
      };

      BRp$e.beforeRender = function (fn, priority) {
  // the renderer can't add tick callbacks when destroyed
        if (this.destroyed) {
          return;
        }

        if (priority == null) {
          error('Priority is not optional for beforeRender');
        }

        const cbs = this.beforeRenderCallbacks;
        cbs.push({
          fn: fn,
          priority: priority
        }); // higher priority callbacks executed first

        cbs.sort(function (a, b) {
          return b.priority - a.priority;
        });
      };

      const beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {
        const cbs = r.beforeRenderCallbacks;

        for (let i = 0; i < cbs.length; i++) {
          cbs[i].fn(willDraw, startTime);
        }
      };

      BRp$e.startRenderLoop = function () {
        const r = this;
        const cy = r.cy;

        if (r.renderLoopStarted) {
          return;
        } else {
          r.renderLoopStarted = true;
        }

        const renderFn = function renderFn(requestTime) {
          if (r.destroyed) {
            return;
          }

          if (cy.batching()) ; else if (r.requestedFrame && !r.skipFrame) {
            beforeRenderCallbacks(r, true, requestTime);
            const startTime = performanceNow();
            r.render(r.renderOptions);
            const endTime = r.lastDrawTime = performanceNow();

            if (r.averageRedrawTime === undefined) {
              r.averageRedrawTime = endTime - startTime;
            }

            if (r.redrawCount === undefined) {
              r.redrawCount = 0;
            }

            r.redrawCount++;

            if (r.redrawTotalTime === undefined) {
              r.redrawTotalTime = 0;
            }

            const duration = endTime - startTime;
            r.redrawTotalTime += duration;
            r.lastRedrawTime = duration; // use a weighted average with a bias from the previous average so we don't spike so easily

            r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;
            r.requestedFrame = false;
          } else {
            beforeRenderCallbacks(r, false, requestTime);
          }

          r.skipFrame = false;
          requestAnimationFrame(renderFn);
        };

        requestAnimationFrame(renderFn);
      };

      const BaseRenderer = function BaseRenderer(options) {
        this.init(options);
      };

      const BR = BaseRenderer;
      const BRp$f = BR.prototype;
      BRp$f.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];

      BRp$f.init = function (options) {
        const r = this;
        r.options = options;
        r.cy = options.cy;
        const ctr = r.container = options.cy.container(); // prepend a stylesheet in the head such that

        if (window$1) {
          const document = window$1.document;
          const head = document.head;
          const stylesheetId = '__________cytoscape_stylesheet';
          const className = '__________cytoscape_container';
          const stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;

          if (ctr.className.indexOf(className) < 0) {
            ctr.className = (ctr.className || '') + ' ' + className;
          }

          if (!stylesheetAlreadyExists) {
            const stylesheet = document.createElement('style');
            stylesheet.id = stylesheetId;
            stylesheet.innerHTML = '.' + className + ' { position: relative; }';
            head.insertBefore(stylesheet, head.children[0]); // first so lowest priority
          }

          const computedStyle = window$1.getComputedStyle(ctr);
          const position = computedStyle.getPropertyValue('position');

          if (position === 'static') {
            warn('A Cytoscape container has style position:static and so can not use UI extensions properly');
          }
        }

        r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag

        r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95]; //--Pointer-related data

        r.hoverData = {
          down: null,
          last: null,
          downTime: null,
          triggerMode: null,
          dragging: false,
          initialPan: [null, null],
          capture: false
        };
        r.dragData = {
          possibleDragElements: []
        };
        r.touchData = {
          start: null,
          capture: false,
    // These 3 fields related to tap, taphold events
          startPosition: [null, null, null, null, null, null],
          singleTouchStartTime: null,
          singleTouchMoved: true,
          now: [null, null, null, null, null, null],
          earlier: [null, null, null, null, null, null]
        };
        r.redraws = 0;
        r.showFps = options.showFps;
        r.debug = options.debug;
        r.hideEdgesOnViewport = options.hideEdgesOnViewport;
        r.textureOnViewport = options.textureOnViewport;
        r.wheelSensitivity = options.wheelSensitivity;
        r.motionBlurEnabled = options.motionBlur; // on by default

        r.forcedPixelRatio = number(options.pixelRatio) ? options.pixelRatio : null;
        r.motionBlur = options.motionBlur; // for initial kick off

        r.motionBlurOpacity = options.motionBlurOpacity;
        r.motionBlurTransparency = 1 - r.motionBlurOpacity;
        r.motionBlurPxRatio = 1;
        r.mbPxRBlurry = 1; //0.8;

        r.minMbLowQualFrames = 4;
        r.fullQualityMb = false;
        r.clearedForMotionBlur = [];
        r.desktopTapThreshold = options.desktopTapThreshold;
        r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
        r.touchTapThreshold = options.touchTapThreshold;
        r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
        r.tapholdDuration = 500;
        r.bindings = [];
        r.beforeRenderCallbacks = [];
        r.beforeRenderPriorities = {
    // higher priority execs before lower one
          animations: 400,
          eleCalcs: 300,
          eleTxrDeq: 200,
          lyrTxrDeq: 150,
          lyrTxrSkip: 100
        };
        r.registerNodeShapes();
        r.registerArrowShapes();
        r.registerCalculationListeners();
      };

      BRp$f.notify = function (eventName, eles) {
        const r = this;
        const cy = r.cy; // the renderer can't be notified after it's destroyed

        if (this.destroyed) {
          return;
        }

        if (eventName === 'init') {
          r.load();
          return;
        }

        if (eventName === 'destroy') {
          r.destroy();
          return;
        }

        if (eventName === 'add' || eventName === 'remove' || eventName === 'move' && cy.hasCompoundNodes() || eventName === 'load' || eventName === 'zorder' || eventName === 'mount') {
          r.invalidateCachedZSortedEles();
        }

        if (eventName === 'viewport') {
          r.redrawHint('select', true);
        }

        if (eventName === 'load' || eventName === 'resize' || eventName === 'mount') {
          r.invalidateContainerClientCoordsCache();
          r.matchCanvasSize(r.container);
        }

        r.redrawHint('eles', true);
        r.redrawHint('drag', true);
        this.startRenderLoop();
        this.redraw();
      };

      BRp$f.destroy = function () {
        const r = this;
        r.destroyed = true;
        r.cy.stopAnimationLoop();

        for (let i = 0; i < r.bindings.length; i++) {
          const binding = r.bindings[i];
          const b = binding;
          const tgt = b.target;
          (tgt.off || tgt.removeEventListener).apply(tgt, b.args);
        }

        r.bindings = [];
        r.beforeRenderCallbacks = [];
        r.onUpdateEleCalcsFns = [];

        if (r.removeObserver) {
          r.removeObserver.disconnect();
        }

        if (r.styleObserver) {
          r.styleObserver.disconnect();
        }

        if (r.resizeObserver) {
          r.resizeObserver.disconnect();
        }

        if (r.labelCalcDiv) {
          try {
            document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef
          } catch (e) {// ie10 issue #1014
          }
        }
      };

      BRp$f.isHeadless = function () {
        return false;
      };

      [BRp, BRp$a, BRp$b, BRp$c, BRp$d, BRp$e].forEach(function (props) {
        extend(BRp$f, props);
      });

      const fullFpsTime = 1000 / 60; // assume 60 frames per second

      const defs = {
        setupDequeueing: function setupDequeueing(opts) {
          return function setupDequeueingImpl() {
            const self = this;
            const r = this.renderer;

            if (self.dequeueingSetup) {
              return;
            } else {
              self.dequeueingSetup = true;
            }

            const queueRedraw = util(function () {
              r.redrawHint('eles', true);
              r.redrawHint('drag', true);
              r.redraw();
            }, opts.deqRedrawThreshold);

            const dequeue = function dequeue(willDraw, frameStartTime) {
              const startTime = performanceNow();
              const avgRenderTime = r.averageRedrawTime;
              const renderTime = r.lastRedrawTime;
              const deqd = [];
              const extent = r.cy.extent();
              const pixelRatio = r.getPixelRatio(); // if we aren't in a tick that causes a draw, then the rendered style
        // queue won't automatically be flushed before dequeueing starts

              if (!willDraw) {
                r.flushRenderedStyleQueue();
              }

              while (true) {
          // eslint-disable-line no-constant-condition
                const now = performanceNow();
                const duration = now - startTime;
                const frameDuration = now - frameStartTime;

                if (renderTime < fullFpsTime) {
            // if we're rendering faster than the ideal fps, then do dequeueing
            // during all of the remaining frame time
                  const timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);

                  if (frameDuration >= opts.deqFastCost * timeAvailable) {
                    break;
                  }
                } else {
                  if (willDraw) {
                    if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {
                      break;
                    }
                  } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {
                    break;
                  }
                }

                const thisDeqd = opts.deq(self, pixelRatio, extent);

                if (thisDeqd.length > 0) {
                  for (let i = 0; i < thisDeqd.length; i++) {
                    deqd.push(thisDeqd[i]);
                  }
                } else {
                  break;
                }
              } // callbacks on dequeue


              if (deqd.length > 0) {
                opts.onDeqd(self, deqd);

                if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {
                  queueRedraw();
                }
              }
            };

            const priority = opts.priority || noop;
            r.beforeRender(dequeue, priority(self));
          };
        }
      };

// Uses keys so elements may share the same cache.

      const ElementTextureCacheLookup =
/*#__PURE__*/
function () {
  function ElementTextureCacheLookup(getKey) {
    const doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;

    _classCallCheck(this, ElementTextureCacheLookup);

    this.idsByKey = new Map$1();
    this.keyForId = new Map$1();
    this.cachesByLvl = new Map$1();
    this.lvls = [];
    this.getKey = getKey;
    this.doesEleInvalidateKey = doesEleInvalidateKey;
  }

  _createClass(ElementTextureCacheLookup, [{
    key: "getIdsFor",
    value: function getIdsFor(key) {
      if (key == null) {
        error("Can not get id list for null key");
      }

      const idsByKey = this.idsByKey;
      let ids = this.idsByKey.get(key);

      if (!ids) {
        ids = new Set$1();
        idsByKey.set(key, ids);
      }

      return ids;
    }
  }, {
    key: "addIdForKey",
    value: function addIdForKey(key, id) {
      if (key != null) {
        this.getIdsFor(key).add(id);
      }
    }
  }, {
    key: "deleteIdForKey",
    value: function deleteIdForKey(key, id) {
      if (key != null) {
        this.getIdsFor(key)["delete"](id);
      }
    }
  }, {
    key: "getNumberOfIdsForKey",
    value: function getNumberOfIdsForKey(key) {
      if (key == null) {
        return 0;
      } else {
        return this.getIdsFor(key).size;
      }
    }
  }, {
    key: "updateKeyMappingFor",
    value: function updateKeyMappingFor(ele) {
      const id = ele.id();
      const prevKey = this.keyForId.get(id);
      const currKey = this.getKey(ele);
      this.deleteIdForKey(prevKey, id);
      this.addIdForKey(currKey, id);
      this.keyForId.set(id, currKey);
    }
  }, {
    key: "deleteKeyMappingFor",
    value: function deleteKeyMappingFor(ele) {
      const id = ele.id();
      const prevKey = this.keyForId.get(id);
      this.deleteIdForKey(prevKey, id);
      this.keyForId["delete"](id);
    }
  }, {
    key: "keyHasChangedFor",
    value: function keyHasChangedFor(ele) {
      const id = ele.id();
      const prevKey = this.keyForId.get(id);
      const newKey = this.getKey(ele);
      return prevKey !== newKey;
    }
  }, {
    key: "isInvalid",
    value: function isInvalid(ele) {
      return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);
    }
  }, {
    key: "getCachesAt",
    value: function getCachesAt(lvl) {
      const cachesByLvl = this.cachesByLvl,
        lvls = this.lvls;
      let caches = cachesByLvl.get(lvl);

      if (!caches) {
        caches = new Map$1();
        cachesByLvl.set(lvl, caches);
        lvls.push(lvl);
      }

      return caches;
    }
  }, {
    key: "getCache",
    value: function getCache(key, lvl) {
      return this.getCachesAt(lvl).get(key);
    }
  }, {
    key: "get",
    value: function get(ele, lvl) {
      const key = this.getKey(ele);
      const cache = this.getCache(key, lvl); // getting for an element may need to add to the id list b/c eles can share keys

      if (cache != null) {
        this.updateKeyMappingFor(ele);
      }

      return cache;
    }
  }, {
    key: "getForCachedKey",
    value: function getForCachedKey(ele, lvl) {
      const key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key

      const cache = this.getCache(key, lvl);
      return cache;
    }
  }, {
    key: "hasCache",
    value: function hasCache(key, lvl) {
      return this.getCachesAt(lvl).has(key);
    }
  }, {
    key: "has",
    value: function has(ele, lvl) {
      const key = this.getKey(ele);
      return this.hasCache(key, lvl);
    }
  }, {
    key: "setCache",
    value: function setCache(key, lvl, cache) {
      cache.key = key;
      this.getCachesAt(lvl).set(key, cache);
    }
  }, {
    key: "set",
    value: function set(ele, lvl, cache) {
      const key = this.getKey(ele);
      this.setCache(key, lvl, cache);
      this.updateKeyMappingFor(ele);
    }
  }, {
    key: "deleteCache",
    value: function deleteCache(key, lvl) {
      this.getCachesAt(lvl)["delete"](key);
    }
  }, {
    key: "delete",
    value: function _delete(ele, lvl) {
      const key = this.getKey(ele);
      this.deleteCache(key, lvl);
    }
  }, {
    key: "invalidateKey",
    value: function invalidateKey(key) {
      const _this = this;

      this.lvls.forEach(function (lvl) {
        return _this.deleteCache(key, lvl);
      });
    } // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)

  }, {
    key: "invalidate",
    value: function invalidate(ele) {
      const id = ele.id();
      const key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)

      this.deleteKeyMappingFor(ele);
      const entireKeyInvalidated = this.doesEleInvalidateKey(ele);

      if (entireKeyInvalidated) {
        // clear mapping for current key
        this.invalidateKey(key);
      }

      return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;
    }
  }]);

  return ElementTextureCacheLookup;
}();

      const minTxrH = 25; // the size of the texture cache for small height eles (special case)

      const txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up

      const minLvl = -4; // when scaling smaller than that we don't need to re-render

      const maxLvl = 3; // when larger than this scale just render directly (caching is not helpful)

      const maxZoom = 7.99; // beyond this zoom level, layered textures are not used

      const eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps

      const defTxrWidth = 1024; // default/minimum texture width

      const maxTxrW = 1024; // the maximum width of a texture

      const maxTxrH = 1024; // the maximum height of a texture

      const minUtility = 0.2; // if usage of texture is less than this, it is retired

      const maxFullness = 0.8; // fullness of texture after which queue removal is checked

      const maxFullnessChecks = 10; // dequeued after this many checks

      const deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame

      const deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time

      const deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing

      const deqFastCost = 0.9; // % of frame time to be used when >60fps

      const deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile

      const maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch

      const getTxrReasons = {
        dequeue: 'dequeue',
        downscale: 'downscale',
        highQuality: 'highQuality'
      };
      const initDefaults = defaults({
        getKey: null,
        doesEleInvalidateKey: falsify,
        drawElement: null,
        getBoundingBox: null,
        getRotationPoint: null,
        getRotationOffset: null,
        isVisible: trueify,
        allowEdgeTxrCaching: true,
        allowParentTxrCaching: true
      });

      const ElementTextureCache = function ElementTextureCache(renderer, initOptions) {
        const self = this;
        self.renderer = renderer;
        self.onDequeues = [];
        const opts = initDefaults(initOptions);
        extend(self, opts);
        self.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);
        self.setupDequeueing();
      };

      const ETCp = ElementTextureCache.prototype;
      ETCp.reasons = getTxrReasons; // the list of textures in which new subtextures for elements can be placed

      ETCp.getTextureQueue = function (txrH) {
        const self = this;
        self.eleImgCaches = self.eleImgCaches || {};
        return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];
      }; // the list of usused textures which can be recycled (in use in texture queue)


      ETCp.getRetiredTextureQueue = function (txrH) {
        const self = this;
        const rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};
        const rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];
        return rtxtrQ;
      }; // queue of element draw requests at different scale levels


      ETCp.getElementQueue = function () {
        const self = this;
        const q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function (a, b) {
          return b.reqs - a.reqs;
        });
        return q;
      }; // queue of element draw requests at different scale levels (element id lookup)


      ETCp.getElementKeyToQueue = function () {
        const self = this;
        const k2q = self.eleKeyToCacheQueue = self.eleKeyToCacheQueue || {};
        return k2q;
      };

      ETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {
        const self = this;
        const r = this.renderer;
        const zoom = r.cy.zoom();
        const lookup = this.lookup;

        if (!bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed()) {
          return null;
        }

        if (!self.allowEdgeTxrCaching && ele.isEdge() || !self.allowParentTxrCaching && ele.isParent()) {
          return null;
        }

        if (lvl == null) {
          lvl = Math.ceil(log2(zoom * pxRatio));
        }

        if (lvl < minLvl) {
          lvl = minLvl;
        } else if (zoom >= maxZoom || lvl > maxLvl) {
          return null;
        }

        const scale = Math.pow(2, lvl);
        const eleScaledH = bb.h * scale;
        const eleScaledW = bb.w * scale;
        const scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);

        if (!this.isVisible(ele, scaledLabelShown)) {
          return null;
        }

        let eleCache = lookup.get(ele, lvl); // if this get was on an unused/invalidated cache, then restore the texture usage metric

        if (eleCache && eleCache.invalidated) {
          eleCache.invalidated = false;
          eleCache.texture.invalidatedWidth -= eleCache.width;
        }

        if (eleCache) {
          return eleCache;
        }

        let txrH; // which texture height this ele belongs to

        if (eleScaledH <= minTxrH) {
          txrH = minTxrH;
        } else if (eleScaledH <= txrStepH) {
          txrH = txrStepH;
        } else {
          txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;
        }

        if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {
          return null; // caching large elements is not efficient
        }

        const txrQ = self.getTextureQueue(txrH); // first try the second last one in case it has space at the end

        let txr = txrQ[txrQ.length - 2];

        const addNewTxr = function addNewTxr() {
          return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);
        }; // try the last one if there is no second last one


        if (!txr) {
          txr = txrQ[txrQ.length - 1];
        } // if the last one doesn't exist, we need a first one


        if (!txr) {
          txr = addNewTxr();
        } // if there's no room in the current texture, we need a new one


        if (txr.width - txr.usedWidth < eleScaledW) {
          txr = addNewTxr();
        }

        const scalableFrom = function scalableFrom(otherCache) {
          return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
        };

        const deqing = reason && reason === getTxrReasons.dequeue;
        const highQualityReq = reason && reason === getTxrReasons.highQuality;
        const downscaleReq = reason && reason === getTxrReasons.downscale;
        let higherCache; // the nearest cache with a higher level

        for (let l = lvl + 1; l <= maxLvl; l++) {
          const c = lookup.get(ele, l);

          if (c) {
            higherCache = c;
            break;
          }
        }

        let oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;

        const downscale = function downscale() {
          txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);
        }; // reset ele area in texture


        txr.context.setTransform(1, 0, 0, 1, 0, 0);
        txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);

        if (scalableFrom(oneUpCache)) {
    // then we can relatively cheaply rescale the existing image w/o rerendering
          downscale();
        } else if (scalableFrom(higherCache)) {
    // then use the higher cache for now and queue the next level down
    // to cheaply scale towards the smaller level
          if (highQualityReq) {
            for (let _l = higherCache.level; _l > lvl; _l--) {
              oneUpCache = self.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);
            }

            downscale();
          } else {
            self.queueElement(ele, higherCache.level - 1);
            return higherCache;
          }
        } else {
          let lowerCache; // the nearest cache with a lower level

          if (!deqing && !highQualityReq && !downscaleReq) {
            for (let _l2 = lvl - 1; _l2 >= minLvl; _l2--) {
              const _c = lookup.get(ele, _l2);

              if (_c) {
                lowerCache = _c;
                break;
              }
            }
          }

          if (scalableFrom(lowerCache)) {
      // then use the lower quality cache for now and queue the better one for later
            self.queueElement(ele, lvl);
            return lowerCache;
          }

          txr.context.translate(txr.usedWidth, 0);
          txr.context.scale(scale, scale);
          this.drawElement(txr.context, ele, bb, scaledLabelShown, false);
          txr.context.scale(1 / scale, 1 / scale);
          txr.context.translate(-txr.usedWidth, 0);
        }

        eleCache = {
          x: txr.usedWidth,
          texture: txr,
          level: lvl,
          scale: scale,
          width: eleScaledW,
          height: eleScaledH,
          scaledLabelShown: scaledLabelShown
        };
        txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);
        txr.eleCaches.push(eleCache);
        lookup.set(ele, lvl, eleCache);
        self.checkTextureFullness(txr);
        return eleCache;
      };

      ETCp.invalidateElements = function (eles) {
        for (let i = 0; i < eles.length; i++) {
          this.invalidateElement(eles[i]);
        }
      };

      ETCp.invalidateElement = function (ele) {
        const self = this;
        const lookup = self.lookup;
        const caches = [];
        const invalid = lookup.isInvalid(ele);

        if (!invalid) {
          return; // override the invalidation request if the element key has not changed
        }

        for (let lvl = minLvl; lvl <= maxLvl; lvl++) {
          const cache = lookup.getForCachedKey(ele, lvl);

          if (cache) {
            caches.push(cache);
          }
        }

        const noOtherElesUseCache = lookup.invalidate(ele);

        if (noOtherElesUseCache) {
          for (let i = 0; i < caches.length; i++) {
            const _cache = caches[i];
            const txr = _cache.texture; // remove space from the texture it belongs to

            txr.invalidatedWidth += _cache.width; // mark the cache as invalidated

            _cache.invalidated = true; // retire the texture if its utility is low

            self.checkTextureUtility(txr);
          }
        } // remove from queue since the old req was for the old state


        self.removeFromQueue(ele);
      };

      ETCp.checkTextureUtility = function (txr) {
  // invalidate all entries in the cache if the cache size is small
        if (txr.invalidatedWidth >= minUtility * txr.width) {
          this.retireTexture(txr);
        }
      };

      ETCp.checkTextureFullness = function (txr) {
  // if texture has been mostly filled and passed over several times, remove
  // it from the queue so we don't need to waste time looking at it to put new things
        const self = this;
        const txrQ = self.getTextureQueue(txr.height);

        if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {
          removeFromArray(txrQ, txr);
        } else {
          txr.fullnessChecks++;
        }
      };

      ETCp.retireTexture = function (txr) {
        const self = this;
        const txrH = txr.height;
        const txrQ = self.getTextureQueue(txrH);
        const lookup = this.lookup; // retire the texture from the active / searchable queue:

        removeFromArray(txrQ, txr);
        txr.retired = true; // remove the refs from the eles to the caches:

        const eleCaches = txr.eleCaches;

        for (let i = 0; i < eleCaches.length; i++) {
          const eleCache = eleCaches[i];
          lookup.deleteCache(eleCache.key, eleCache.level);
        }

        clearArray(eleCaches); // add the texture to a retired queue so it can be recycled in future:

        const rtxtrQ = self.getRetiredTextureQueue(txrH);
        rtxtrQ.push(txr);
      };

      ETCp.addTexture = function (txrH, minW) {
        const self = this;
        const txrQ = self.getTextureQueue(txrH);
        const txr = {};
        txrQ.push(txr);
        txr.eleCaches = [];
        txr.height = txrH;
        txr.width = Math.max(defTxrWidth, minW);
        txr.usedWidth = 0;
        txr.invalidatedWidth = 0;
        txr.fullnessChecks = 0;
        txr.canvas = self.renderer.makeOffscreenCanvas(txr.width, txr.height);
        txr.context = txr.canvas.getContext('2d');
        return txr;
      };

      ETCp.recycleTexture = function (txrH, minW) {
        const self = this;
        const txrQ = self.getTextureQueue(txrH);
        const rtxtrQ = self.getRetiredTextureQueue(txrH);

        for (let i = 0; i < rtxtrQ.length; i++) {
          const txr = rtxtrQ[i];

          if (txr.width >= minW) {
            txr.retired = false;
            txr.usedWidth = 0;
            txr.invalidatedWidth = 0;
            txr.fullnessChecks = 0;
            clearArray(txr.eleCaches);
            txr.context.setTransform(1, 0, 0, 1, 0, 0);
            txr.context.clearRect(0, 0, txr.width, txr.height);
            removeFromArray(rtxtrQ, txr);
            txrQ.push(txr);
            return txr;
          }
        }
      };

      ETCp.queueElement = function (ele, lvl) {
        const self = this;
        const q = self.getElementQueue();
        const k2q = self.getElementKeyToQueue();
        const key = this.getKey(ele);
        const existingReq = k2q[key];

        if (existingReq) {
    // use the max lvl b/c in between lvls are cheap to make
          existingReq.level = Math.max(existingReq.level, lvl);
          existingReq.eles.merge(ele);
          existingReq.reqs++;
          q.updateItem(existingReq);
        } else {
          const req = {
            eles: ele.spawn().merge(ele),
            level: lvl,
            reqs: 1,
            key: key
          };
          q.push(req);
          k2q[key] = req;
        }
      };

      ETCp.dequeue = function (pxRatio
/*, extent*/
      ) {
        const self = this;
        const q = self.getElementQueue();
        const k2q = self.getElementKeyToQueue();
        const dequeued = [];
        const lookup = self.lookup;

        for (let i = 0; i < maxDeqSize; i++) {
          if (q.size() > 0) {
            const req = q.pop();
            const key = req.key;
            const ele = req.eles[0]; // all eles have the same key

            const cacheExists = lookup.hasCache(ele, req.level); // clear out the key to req lookup

            k2q[key] = null; // dequeueing isn't necessary with an existing cache

            if (cacheExists) {
              continue;
            }

            dequeued.push(req);
            const bb = self.getBoundingBox(ele);
            self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);
          } else {
            break;
          }
        }

        return dequeued;
      };

      ETCp.removeFromQueue = function (ele) {
        const self = this;
        const q = self.getElementQueue();
        const k2q = self.getElementKeyToQueue();
        const key = this.getKey(ele);
        const req = k2q[key];

        if (req != null) {
          if (req.eles.length === 1) {
      // remove if last ele in the req
      // bring to front of queue
            req.reqs = MAX_INT;
            q.updateItem(req);
            q.pop(); // remove from queue

            k2q[key] = null; // remove from lookup map
          } else {
      // otherwise just remove ele from req
            req.eles.unmerge(ele);
          }
        }
      };

      ETCp.onDequeue = function (fn) {
        this.onDequeues.push(fn);
      };

      ETCp.offDequeue = function (fn) {
        removeFromArray(this.onDequeues, fn);
      };

      ETCp.setupDequeueing = defs.setupDequeueing({
        deqRedrawThreshold: deqRedrawThreshold,
        deqCost: deqCost,
        deqAvgCost: deqAvgCost,
        deqNoDrawCost: deqNoDrawCost,
        deqFastCost: deqFastCost,
        deq: function deq(self, pxRatio, extent) {
          return self.dequeue(pxRatio, extent);
        },
        onDeqd: function onDeqd(self, deqd) {
          for (let i = 0; i < self.onDequeues.length; i++) {
            const fn = self.onDequeues[i];
            fn(deqd);
          }
        },
        shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {
          for (let i = 0; i < deqd.length; i++) {
            const eles = deqd[i].eles;

            for (let j = 0; j < eles.length; j++) {
              const bb = eles[j].boundingBox();

              if (boundingBoxesIntersect(bb, extent)) {
                return true;
              }
            }
          }

          return false;
        },
        priority: function priority(self) {
          return self.renderer.beforeRenderPriorities.eleTxrDeq;
        }
      });

      const defNumLayers = 1; // default number of layers to use

      const minLvl$1 = -4; // when scaling smaller than that we don't need to re-render

      const maxLvl$1 = 2; // when larger than this scale just render directly (caching is not helpful)

      const maxZoom$1 = 3.99; // beyond this zoom level, layered textures are not used

      const deqRedrawThreshold$1 = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile

      const refineEleDebounceTime = 50; // time to debounce sharper ele texture updates

      const deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame

      const deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time

      const deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing

      const deqFastCost$1 = 0.9; // % of frame time to be used when >60fps

      const maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch

      const invalidThreshold = 250; // time threshold for disabling b/c of invalidations

      const maxLayerArea = 4000 * 4000; // layers can't be bigger than this

      const useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)
// var log = function(){ console.log.apply( console, arguments ); };

      const LayeredTextureCache = function LayeredTextureCache(renderer) {
        const self = this;
        const r = self.renderer = renderer;
        const cy = r.cy;
        self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]

        self.firstGet = true;
        self.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;
        self.skipping = false;
        self.eleTxrDeqs = cy.collection();
        self.scheduleElementRefinement = util(function () {
          self.refineElementTextures(self.eleTxrDeqs);
          self.eleTxrDeqs.unmerge(self.eleTxrDeqs);
        }, refineEleDebounceTime);
        r.beforeRender(function (willDraw, now) {
          if (now - self.lastInvalidationTime <= invalidThreshold) {
            self.skipping = true;
          } else {
            self.skipping = false;
          }
        }, r.beforeRenderPriorities.lyrTxrSkip);

        const qSort = function qSort(a, b) {
          return b.reqs - a.reqs;
        };

        self.layersQueue = new Heap(qSort);
        self.setupDequeueing();
      };

      const LTCp = LayeredTextureCache.prototype;
      let layerIdPool = 0;
      const MAX_INT$1 = Math.pow(2, 53) - 1;

      LTCp.makeLayer = function (bb, lvl) {
        const scale = Math.pow(2, lvl);
        const w = Math.ceil(bb.w * scale);
        const h = Math.ceil(bb.h * scale);
        const canvas = this.renderer.makeOffscreenCanvas(w, h);
        const layer = {
          id: layerIdPool = ++layerIdPool % MAX_INT$1,
          bb: bb,
          level: lvl,
          width: w,
          height: h,
          canvas: canvas,
          context: canvas.getContext('2d'),
          eles: [],
          elesQueue: [],
          reqs: 0
        }; // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);

        const cxt = layer.context;
        const dx = -layer.bb.x1;
        const dy = -layer.bb.y1; // do the transform on creation to save cycles (it's the same for all eles)

        cxt.scale(scale, scale);
        cxt.translate(dx, dy);
        return layer;
      };

      LTCp.getLayers = function (eles, pxRatio, lvl) {
        const self = this;
        const r = self.renderer;
        const cy = r.cy;
        const zoom = cy.zoom();
        const firstGet = self.firstGet;
        self.firstGet = false; // log('--\nget layers with %s eles', eles.length);
  //log eles.map(function(ele){ return ele.id() }) );

        if (lvl == null) {
          lvl = Math.ceil(log2(zoom * pxRatio));

          if (lvl < minLvl$1) {
            lvl = minLvl$1;
          } else if (zoom >= maxZoom$1 || lvl > maxLvl$1) {
            return null;
          }
        }

        self.validateLayersElesOrdering(lvl, eles);
        const layersByLvl = self.layersByLevel;
        const scale = Math.pow(2, lvl);
        const layers = layersByLvl[lvl] = layersByLvl[lvl] || [];
        let bb;
        const lvlComplete = self.levelIsComplete(lvl, eles);
        let tmpLayers;

        const checkTempLevels = function checkTempLevels() {
          const canUseAsTmpLvl = function canUseAsTmpLvl(l) {
            self.validateLayersElesOrdering(l, eles);

            if (self.levelIsComplete(l, eles)) {
              tmpLayers = layersByLvl[l];
              return true;
            }
          };

          const checkLvls = function checkLvls(dir) {
            if (tmpLayers) {
              return;
            }

            for (let l = lvl + dir; minLvl$1 <= l && l <= maxLvl$1; l += dir) {
              if (canUseAsTmpLvl(l)) {
                break;
              }
            }
          };

          checkLvls(+1);
          checkLvls(-1); // remove the invalid layers; they will be replaced as needed later in this function

          for (let i = layers.length - 1; i >= 0; i--) {
            const layer = layers[i];

            if (layer.invalid) {
              removeFromArray(layers, layer);
            }
          }
        };

        if (!lvlComplete) {
    // if the current level is incomplete, then use the closest, best quality layerset temporarily
    // and later queue the current layerset so we can get the proper quality level soon
          checkTempLevels();
        } else {
    // log('level complete, using existing layers\n--');
          return layers;
        }

        const getBb = function getBb() {
          if (!bb) {
            bb = makeBoundingBox();

            for (let i = 0; i < eles.length; i++) {
              updateBoundingBox(bb, eles[i].boundingBox());
            }
          }

          return bb;
        };

        const makeLayer = function makeLayer(opts) {
          opts = opts || {};
          const after = opts.after;
          getBb();
          const area = bb.w * scale * (bb.h * scale);

          if (area > maxLayerArea) {
            return null;
          }

          const layer = self.makeLayer(bb, lvl);

          if (after != null) {
            const index = layers.indexOf(after) + 1;
            layers.splice(index, 0, layer);
          } else if (opts.insert === undefined || opts.insert) {
      // no after specified => first layer made so put at start
            layers.unshift(layer);
          } // if( tmpLayers ){
    //self.queueLayer( layer );
    // }


          return layer;
        };

        if (self.skipping && !firstGet) {
    // log('skip layers');
          return null;
        } // log('do layers');


        let layer = null;
        const maxElesPerLayer = eles.length / defNumLayers;
        const allowLazyQueueing =  !firstGet;

        for (let i = 0; i < eles.length; i++) {
          const ele = eles[i];
          const rs = ele._private.rscratch;
          const caches = rs.imgLayerCaches = rs.imgLayerCaches || {}; // log('look at ele', ele.id());

          const existingLayer = caches[lvl];

          if (existingLayer) {
      // reuse layer for later eles
      // log('reuse layer for', ele.id());
            layer = existingLayer;
            continue;
          }

          if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {
      // log('make new layer for ele %s', ele.id());
            layer = makeLayer({
              insert: true,
              after: layer
            }); // if now layer can be built then we can't use layers at this level

            if (!layer) {
              return null;
            } // log('new layer with id %s', layer.id);

          }

          if (tmpLayers || allowLazyQueueing) {
      // log('queue ele %s in layer %s', ele.id(), layer.id);
            self.queueLayer(layer, ele);
          } else {
      // log('draw ele %s in layer %s', ele.id(), layer.id);
            self.drawEleInLayer(layer, ele, lvl, pxRatio);
          }

          layer.eles.push(ele);
          caches[lvl] = layer;
        } // log('--');


        if (tmpLayers) {
    // then we only queued the current layerset and can't draw it yet
          return tmpLayers;
        }

        if (allowLazyQueueing) {
    // log('lazy queue level', lvl);
          return null;
        }

        return layers;
      }; // a layer may want to use an ele cache of a higher level to avoid blurriness
// so the layer level might not equal the ele level


      LTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {
        return lvl;
      };

      LTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {
        const self = this;
        const r = this.renderer;
        const context = layer.context;
        const bb = ele.boundingBox();

        if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
          return;
        }

        lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);

        {
          r.setImgSmoothing(context, false);
        }

        {
          r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);
        }

        {
          r.setImgSmoothing(context, true);
        }
      };

      LTCp.levelIsComplete = function (lvl, eles) {
        const self = this;
        const layers = self.layersByLevel[lvl];

        if (!layers || layers.length === 0) {
          return false;
        }

        let numElesInLayers = 0;

        for (let i = 0; i < layers.length; i++) {
          const layer = layers[i]; // if there are any eles needed to be drawn yet, the level is not complete

          if (layer.reqs > 0) {
            return false;
          } // if the layer is invalid, the level is not complete


          if (layer.invalid) {
            return false;
          }

          numElesInLayers += layer.eles.length;
        } // we should have exactly the number of eles passed in to be complete


        if (numElesInLayers !== eles.length) {
          return false;
        }

        return true;
      };

      LTCp.validateLayersElesOrdering = function (lvl, eles) {
        const layers = this.layersByLevel[lvl];

        if (!layers) {
          return;
        } // if in a layer the eles are not in the same order, then the layer is invalid
  // (i.e. there is an ele in between the eles in the layer)


        for (let i = 0; i < layers.length; i++) {
          const layer = layers[i];
          let offset = -1; // find the offset

          for (var j = 0; j < eles.length; j++) {
            if (layer.eles[0] === eles[j]) {
              offset = j;
              break;
            }
          }

          if (offset < 0) {
      // then the layer has nonexistant elements and is invalid
            this.invalidateLayer(layer);
            continue;
          } // the eles in the layer must be in the same continuous order, else the layer is invalid


          const o = offset;

          for (var j = 0; j < layer.eles.length; j++) {
            if (layer.eles[j] !== eles[o + j]) {
        // log('invalidate based on ordering', layer.id);
              this.invalidateLayer(layer);
              break;
            }
          }
        }
      };

      LTCp.updateElementsInLayers = function (eles, update) {
        const self = this;
        const isEles = element(eles[0]); // collect udpated elements (cascaded from the layers) and update each
  // layer itself along the way

        for (let i = 0; i < eles.length; i++) {
          const req = isEles ? null : eles[i];
          const ele = isEles ? eles[i] : eles[i].ele;
          const rs = ele._private.rscratch;
          const caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

          for (let l = minLvl$1; l <= maxLvl$1; l++) {
            const layer = caches[l];

            if (!layer) {
              continue;
            } // if update is a request from the ele cache, then it affects only
      // the matching level


            if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {
              continue;
            }

            update(layer, ele, req);
          }
        }
      };

      LTCp.haveLayers = function () {
        const self = this;
        let haveLayers = false;

        for (let l = minLvl$1; l <= maxLvl$1; l++) {
          const layers = self.layersByLevel[l];

          if (layers && layers.length > 0) {
            haveLayers = true;
            break;
          }
        }

        return haveLayers;
      };

      LTCp.invalidateElements = function (eles) {
        const self = this;

        if (eles.length === 0) {
          return;
        }

        self.lastInvalidationTime = performanceNow(); // log('update invalidate layer time from eles');

        if (eles.length === 0 || !self.haveLayers()) {
          return;
        }

        self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {
          self.invalidateLayer(layer);
        });
      };

      LTCp.invalidateLayer = function (layer) {
  // log('update invalidate layer time');
        this.lastInvalidationTime = performanceNow();

        if (layer.invalid) {
          return;
        } // save cycles


        const lvl = layer.level;
        const eles = layer.eles;
        const layers = this.layersByLevel[lvl]; // log('invalidate layer', layer.id );

        removeFromArray(layers, layer); // layer.eles = [];

        layer.elesQueue = [];
        layer.invalid = true;

        if (layer.replacement) {
          layer.replacement.invalid = true;
        }

        for (let i = 0; i < eles.length; i++) {
          const caches = eles[i]._private.rscratch.imgLayerCaches;

          if (caches) {
            caches[lvl] = null;
          }
        }
      };

      LTCp.refineElementTextures = function (eles) {
        const self = this; // log('refine', eles.length);

        self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {
          let rLyr = layer.replacement;

          if (!rLyr) {
            rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);
            rLyr.replaces = layer;
            rLyr.eles = layer.eles; // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);
          }

          if (!rLyr.reqs) {
            for (let i = 0; i < rLyr.eles.length; i++) {
              self.queueLayer(rLyr, rLyr.eles[i]);
            } // log('queue replacement layer refinement', rLyr.id);

          }
        });
      };

      LTCp.enqueueElementRefinement = function (ele) {

        this.eleTxrDeqs.merge(ele);
        this.scheduleElementRefinement();
      };

      LTCp.queueLayer = function (layer, ele) {
        const self = this;
        const q = self.layersQueue;
        const elesQ = layer.elesQueue;
        const hasId = elesQ.hasId = elesQ.hasId || {}; // if a layer is going to be replaced, queuing is a waste of time

        if (layer.replacement) {
          return;
        }

        if (ele) {
          if (hasId[ele.id()]) {
            return;
          }

          elesQ.push(ele);
          hasId[ele.id()] = true;
        }

        if (layer.reqs) {
          layer.reqs++;
          q.updateItem(layer);
        } else {
          layer.reqs = 1;
          q.push(layer);
        }
      };

      LTCp.dequeue = function (pxRatio) {
        const self = this;
        const q = self.layersQueue;
        const deqd = [];
        let eleDeqs = 0;

        while (eleDeqs < maxDeqSize$1) {
          if (q.size() === 0) {
            break;
          }

          const layer = q.peek(); // if a layer has been or will be replaced, then don't waste time with it

          if (layer.replacement) {
      // log('layer %s in queue skipped b/c it already has a replacement', layer.id);
            q.pop();
            continue;
          } // if this is a replacement layer that has been superceded, then forget it


          if (layer.replaces && layer !== layer.replaces.replacement) {
      // log('layer is no longer the most uptodate replacement; dequeued', layer.id)
            q.pop();
            continue;
          }

          if (layer.invalid) {
      // log('replacement layer %s is invalid; dequeued', layer.id);
            q.pop();
            continue;
          }

          const ele = layer.elesQueue.shift();

          if (ele) {
      // log('dequeue layer %s', layer.id);
            self.drawEleInLayer(layer, ele, layer.level, pxRatio);
            eleDeqs++;
          }

          if (deqd.length === 0) {
      // we need only one entry in deqd to queue redrawing etc
            deqd.push(true);
          } // if the layer has all its eles done, then remove from the queue


          if (layer.elesQueue.length === 0) {
            q.pop();
            layer.reqs = 0; // log('dequeue of layer %s complete', layer.id);
      // when a replacement layer is dequeued, it replaces the old layer in the level

            if (layer.replaces) {
              self.applyLayerReplacement(layer);
            }

            self.requestRedraw();
          }
        }

        return deqd;
      };

      LTCp.applyLayerReplacement = function (layer) {
        const self = this;
        const layersInLevel = self.layersByLevel[layer.level];
        const replaced = layer.replaces;
        const index = layersInLevel.indexOf(replaced); // if the replaced layer is not in the active list for the level, then replacing
  // refs would be a mistake (i.e. overwriting the true active layer)

        if (index < 0 || replaced.invalid) {
    // log('replacement layer would have no effect', layer.id);
          return;
        }

        layersInLevel[index] = layer; // replace level ref
  // replace refs in eles

        for (let i = 0; i < layer.eles.length; i++) {
          const _p = layer.eles[i]._private;
          const cache = _p.imgLayerCaches = _p.imgLayerCaches || {};

          if (cache) {
            cache[layer.level] = layer;
          }
        } // log('apply replacement layer %s over %s', layer.id, replaced.id);


        self.requestRedraw();
      };

      LTCp.requestRedraw = util(function () {
        const r = this.renderer;
        r.redrawHint('eles', true);
        r.redrawHint('drag', true);
        r.redraw();
      }, 100);
      LTCp.setupDequeueing = defs.setupDequeueing({
        deqRedrawThreshold: deqRedrawThreshold$1,
        deqCost: deqCost$1,
        deqAvgCost: deqAvgCost$1,
        deqNoDrawCost: deqNoDrawCost$1,
        deqFastCost: deqFastCost$1,
        deq: function deq(self, pxRatio) {
          return self.dequeue(pxRatio);
        },
        onDeqd: noop,
        shouldRedraw: trueify,
        priority: function priority(self) {
          return self.renderer.beforeRenderPriorities.lyrTxrDeq;
        }
      });

      const CRp = {};
      let impl;

      function polygon(context, points) {
        for (let i = 0; i < points.length; i++) {
          const pt = points[i];
          context.lineTo(pt.x, pt.y);
        }
      }

      function triangleBackcurve(context, points, controlPoint) {
        let firstPt;

        for (let i = 0; i < points.length; i++) {
          const pt = points[i];

          if (i === 0) {
            firstPt = pt;
          }

          context.lineTo(pt.x, pt.y);
        }

        context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);
      }

      function triangleTee(context, trianglePoints, teePoints) {
        if (context.beginPath) {
          context.beginPath();
        }

        const triPts = trianglePoints;

        for (var i = 0; i < triPts.length; i++) {
          var pt = triPts[i];
          context.lineTo(pt.x, pt.y);
        }

        const teePts = teePoints;
        const firstTeePt = teePoints[0];
        context.moveTo(firstTeePt.x, firstTeePt.y);

        for (var i = 1; i < teePts.length; i++) {
          var pt = teePts[i];
          context.lineTo(pt.x, pt.y);
        }

        if (context.closePath) {
          context.closePath();
        }
      }

      function circleTriangle(context, trianglePoints, rx, ry, r) {
        if (context.beginPath) {
          context.beginPath();
        }

        context.arc(rx, ry, r, 0, Math.PI * 2, false);
        const triPts = trianglePoints;
        const firstTrPt = triPts[0];
        context.moveTo(firstTrPt.x, firstTrPt.y);

        for (let i = 0; i < triPts.length; i++) {
          const pt = triPts[i];
          context.lineTo(pt.x, pt.y);
        }

        if (context.closePath) {
          context.closePath();
        }
      }

      function circle(context, rx, ry, r) {
        context.arc(rx, ry, r, 0, Math.PI * 2, false);
      }

      CRp.arrowShapeImpl = function (name) {
        return (impl || (impl = {
          'polygon': polygon,
          'triangle-backcurve': triangleBackcurve,
          'triangle-tee': triangleTee,
          'circle-triangle': circleTriangle,
          'triangle-cross': triangleTee,
          'circle': circle
        }))[name];
      };

      const CRp$1 = {};

      CRp$1.drawElement = function (context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {
        const r = this;

        if (ele.isNode()) {
          r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
        } else {
          r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
        }
      };

      CRp$1.drawElementOverlay = function (context, ele) {
        const r = this;

        if (ele.isNode()) {
          r.drawNodeOverlay(context, ele);
        } else {
          r.drawEdgeOverlay(context, ele);
        }
      };

      CRp$1.drawCachedElementPortion = function (context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {
        const r = this;
        const bb = eleTxrCache.getBoundingBox(ele);

        if (bb.w === 0 || bb.h === 0) {
          return;
        } // ignore zero size case


        const eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);

        if (eleCache != null) {
          const opacity = getOpacity(r, ele);

          if (opacity === 0) {
            return;
          }

          const theta = getRotation(r, ele);
          const x1 = bb.x1,
            y1 = bb.y1,
            w = bb.w,
            h = bb.h;
          let x, y, sx, sy, smooth;

          if (theta !== 0) {
            const rotPt = eleTxrCache.getRotationPoint(ele);
            sx = rotPt.x;
            sy = rotPt.y;
            context.translate(sx, sy);
            context.rotate(theta);
            smooth = r.getImgSmoothing(context);

            if (!smooth) {
              r.setImgSmoothing(context, true);
            }

            const off = eleTxrCache.getRotationOffset(ele);
            x = off.x;
            y = off.y;
          } else {
            x = x1;
            y = y1;
          }

          let oldGlobalAlpha;

          if (opacity !== 1) {
            oldGlobalAlpha = context.globalAlpha;
            context.globalAlpha = oldGlobalAlpha * opacity;
          }

          context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);

          if (opacity !== 1) {
            context.globalAlpha = oldGlobalAlpha;
          }

          if (theta !== 0) {
            context.rotate(-theta);
            context.translate(-sx, -sy);

            if (!smooth) {
              r.setImgSmoothing(context, false);
            }
          }
        } else {
          eleTxrCache.drawElement(context, ele); // direct draw fallback
        }
      };

      const getZeroRotation = function getZeroRotation() {
        return 0;
      };

      const getLabelRotation = function getLabelRotation(r, ele) {
        return r.getTextAngle(ele, null);
      };

      const getSourceLabelRotation = function getSourceLabelRotation(r, ele) {
        return r.getTextAngle(ele, 'source');
      };

      const getTargetLabelRotation = function getTargetLabelRotation(r, ele) {
        return r.getTextAngle(ele, 'target');
      };

      const getOpacity = function getOpacity(r, ele) {
        return ele.effectiveOpacity();
      };

      const getTextOpacity = function getTextOpacity(e, ele) {
        return ele.pstyle('text-opacity').pfValue * ele.effectiveOpacity();
      };

      CRp$1.drawCachedElement = function (context, ele, pxRatio, extent, lvl, requestHighQuality) {
        const r = this;
        const _r$data = r.data,
          eleTxrCache = _r$data.eleTxrCache,
          lblTxrCache = _r$data.lblTxrCache,
          slbTxrCache = _r$data.slbTxrCache,
          tlbTxrCache = _r$data.tlbTxrCache;
        const bb = ele.boundingBox();
        const reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;

        if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
          return;
        }

        if (!extent || boundingBoxesIntersect(bb, extent)) {
          const isEdge = ele.isEdge();

          const badLine = ele.element()._private.rscratch.badLine;

          r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);

          if (!isEdge || !badLine) {
            r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);
          }

          if (isEdge && !badLine) {
            r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);
            r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);
          }

          r.drawElementOverlay(context, ele);
        }
      };

      CRp$1.drawElements = function (context, eles) {
        const r = this;

        for (let i = 0; i < eles.length; i++) {
          const ele = eles[i];
          r.drawElement(context, ele);
        }
      };

      CRp$1.drawCachedElements = function (context, eles, pxRatio, extent) {
        const r = this;

        for (let i = 0; i < eles.length; i++) {
          const ele = eles[i];
          r.drawCachedElement(context, ele, pxRatio, extent);
        }
      };

      CRp$1.drawCachedNodes = function (context, eles, pxRatio, extent) {
        const r = this;

        for (let i = 0; i < eles.length; i++) {
          const ele = eles[i];

          if (!ele.isNode()) {
            continue;
          }

          r.drawCachedElement(context, ele, pxRatio, extent);
        }
      };

      CRp$1.drawLayeredElements = function (context, eles, pxRatio, extent) {
        const r = this;
        const layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);

        if (layers) {
          for (let i = 0; i < layers.length; i++) {
            const layer = layers[i];
            const bb = layer.bb;

            if (bb.w === 0 || bb.h === 0) {
              continue;
            }

            context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);
          }
        } else {
    // fall back on plain caching if no layers
          r.drawCachedElements(context, eles, pxRatio, extent);
        }
      };

/* global Path2D */
      const CRp$2 = {};

      CRp$2.drawEdge = function (context, edge, shiftToOriginWithBb) {
        const drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        const shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
        const r = this;
        const rs = edge._private.rscratch;

        if (shouldDrawOpacity && !edge.visible()) {
          return;
        } // if bezier ctrl pts can not be calculated, then die


        if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {
    // isNaN in case edge is impossible and browser bugs (e.g. safari)
          return;
        }

        let bb;

        if (shiftToOriginWithBb) {
          bb = shiftToOriginWithBb;
          context.translate(-bb.x1, -bb.y1);
        }

        const opacity = shouldDrawOpacity ? edge.pstyle('opacity').value : 1;
        const lineOpacity = shouldDrawOpacity ? edge.pstyle('line-opacity').value : 1;
        const lineStyle = edge.pstyle('line-style').value;
        const edgeWidth = edge.pstyle('width').pfValue;
        const lineCap = edge.pstyle('line-cap').value;
        const effectiveLineOpacity = opacity * lineOpacity; // separate arrow opacity would require arrow-opacity property

        const effectiveArrowOpacity = opacity * lineOpacity;

        const drawLine = function drawLine() {
          const strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;
          context.lineWidth = edgeWidth;
          context.lineCap = lineCap;
          r.eleStrokeStyle(context, edge, strokeOpacity);
          r.drawEdgePath(edge, context, rs.allpts, lineStyle);
          context.lineCap = 'butt'; // reset for other drawing functions
        };

        const drawOverlay = function drawOverlay() {
          if (!shouldDrawOverlay) {
            return;
          }

          r.drawEdgeOverlay(context, edge);
        };

        const drawArrows = function drawArrows() {
          const arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveArrowOpacity;
          r.drawArrowheads(context, edge, arrowOpacity);
        };

        const drawText = function drawText() {
          r.drawElementText(context, edge, null, drawLabel);
        };

        context.lineJoin = 'round';
        const ghost = edge.pstyle('ghost').value === 'yes';

        if (ghost) {
          const gx = edge.pstyle('ghost-offset-x').pfValue;
          const gy = edge.pstyle('ghost-offset-y').pfValue;
          const ghostOpacity = edge.pstyle('ghost-opacity').value;
          const effectiveGhostOpacity = effectiveLineOpacity * ghostOpacity;
          context.translate(gx, gy);
          drawLine(effectiveGhostOpacity);
          drawArrows(effectiveGhostOpacity);
          context.translate(-gx, -gy);
        }

        drawLine();
        drawArrows();
        drawOverlay();
        drawText();

        if (shiftToOriginWithBb) {
          context.translate(bb.x1, bb.y1);
        }
      };

      CRp$2.drawEdgeOverlay = function (context, edge) {
        if (!edge.visible()) {
          return;
        }

        const overlayOpacity = edge.pstyle('overlay-opacity').value;

        if (overlayOpacity === 0) {
          return;
        }

        const r = this;
        const usePaths = r.usePaths();
        const rs = edge._private.rscratch;
        const overlayPadding = edge.pstyle('overlay-padding').pfValue;
        const overlayWidth = 2 * overlayPadding;
        const overlayColor = edge.pstyle('overlay-color').value;
        context.lineWidth = overlayWidth;

        if (rs.edgeType === 'self' && !usePaths) {
          context.lineCap = 'butt';
        } else {
          context.lineCap = 'round';
        }

        r.colorStrokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
        r.drawEdgePath(edge, context, rs.allpts, 'solid');
      };

      CRp$2.drawEdgePath = function (edge, context, pts, type) {
        const rs = edge._private.rscratch;
        const canvasCxt = context;
        let path;
        let pathCacheHit = false;
        const usePaths = this.usePaths();
        const lineDashPattern = edge.pstyle('line-dash-pattern').pfValue;
        const lineDashOffset = edge.pstyle('line-dash-offset').pfValue;

        if (usePaths) {
          const pathCacheKey = pts.join('$');
          const keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;

          if (keyMatches) {
            path = context = rs.pathCache;
            pathCacheHit = true;
          } else {
            path = context = new Path2D();
            rs.pathCacheKey = pathCacheKey;
            rs.pathCache = path;
          }
        }

        if (canvasCxt.setLineDash) {
    // for very outofdate browsers
          switch (type) {
            case 'dotted':
              canvasCxt.setLineDash([1, 1]);
              break;

            case 'dashed':
              canvasCxt.setLineDash(lineDashPattern);
              canvasCxt.lineDashOffset = lineDashOffset;
              break;

            case 'solid':
              canvasCxt.setLineDash([]);
              break;
          }
        }

        if (!pathCacheHit && !rs.badLine) {
          if (context.beginPath) {
            context.beginPath();
          }

          context.moveTo(pts[0], pts[1]);

          switch (rs.edgeType) {
            case 'bezier':
            case 'self':
            case 'compound':
            case 'multibezier':
              for (let i = 2; i + 3 < pts.length; i += 4) {
                context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);
              }

              break;

            case 'straight':
            case 'segments':
            case 'haystack':
              for (let _i = 2; _i + 1 < pts.length; _i += 2) {
                context.lineTo(pts[_i], pts[_i + 1]);
              }

              break;
          }
        }

        context = canvasCxt;

        if (usePaths) {
          context.stroke(path);
        } else {
          context.stroke();
        } // reset any line dashes


        if (context.setLineDash) {
    // for very outofdate browsers
          context.setLineDash([]);
        }
      };

      CRp$2.drawArrowheads = function (context, edge, opacity) {
        const rs = edge._private.rscratch;
        const isHaystack = rs.edgeType === 'haystack';

        if (!isHaystack) {
          this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);
        }

        this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);
        this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);

        if (!isHaystack) {
          this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);
        }
      };

      CRp$2.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {
        if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {
          return;
        }

        const self = this;
        const arrowShape = edge.pstyle(prefix + '-arrow-shape').value;

        if (arrowShape === 'none') {
          return;
        }

        const arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';
        const arrowFill = edge.pstyle(prefix + '-arrow-fill').value;
        const edgeWidth = edge.pstyle('width').pfValue;
        const edgeOpacity = edge.pstyle('opacity').value;

        if (opacity === undefined) {
          opacity = edgeOpacity;
        }

        const gco = context.globalCompositeOperation;

        if (opacity !== 1 || arrowFill === 'hollow') {
    // then extra clear is needed
          context.globalCompositeOperation = 'destination-out';
          self.colorFillStyle(context, 255, 255, 255, 1);
          self.colorStrokeStyle(context, 255, 255, 255, 1);
          self.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);
          context.globalCompositeOperation = gco;
        } // otherwise, the opaque arrow clears it for free :)


        const color = edge.pstyle(prefix + '-arrow-color').value;
        self.colorFillStyle(context, color[0], color[1], color[2], opacity);
        self.colorStrokeStyle(context, color[0], color[1], color[2], opacity);
        self.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, x, y, angle);
      };

      CRp$2.drawArrowShape = function (edge, context, fill, edgeWidth, shape, x, y, angle) {
        const r = this;
        const usePaths = this.usePaths() && shape !== 'triangle-cross';
        let pathCacheHit = false;
        let path;
        const canvasContext = context;
        const translation = {
          x: x,
          y: y
        };
        const scale = edge.pstyle('arrow-scale').value;
        const size = this.getArrowWidth(edgeWidth, scale);
        const shapeImpl = r.arrowShapes[shape];

        if (usePaths) {
          const cache = r.arrowPathCache = r.arrowPathCache || [];
          const key = hashString(shape);
          const cachedPath = cache[key];

          if (cachedPath != null) {
            path = context = cachedPath;
            pathCacheHit = true;
          } else {
            path = context = new Path2D();
            cache[key] = path;
          }
        }

        if (!pathCacheHit) {
          if (context.beginPath) {
            context.beginPath();
          }

          if (usePaths) {
      // store in the path cache with values easily manipulated later
            shapeImpl.draw(context, 1, 0, {
              x: 0,
              y: 0
            }, 1);
          } else {
            shapeImpl.draw(context, size, angle, translation, edgeWidth);
          }

          if (context.closePath) {
            context.closePath();
          }
        }

        context = canvasContext;

        if (usePaths) {
    // set transform to arrow position/orientation
          context.translate(x, y);
          context.rotate(angle);
          context.scale(size, size);
        }

        if (fill === 'filled' || fill === 'both') {
          if (usePaths) {
            context.fill(path);
          } else {
            context.fill();
          }
        }

        if (fill === 'hollow' || fill === 'both') {
          context.lineWidth = (shapeImpl.matchEdgeWidth ? edgeWidth : 1) / (usePaths ? size : 1);
          context.lineJoin = 'miter';

          if (usePaths) {
            context.stroke(path);
          } else {
            context.stroke();
          }
        }

        if (usePaths) {
    // reset transform by applying inverse
          context.scale(1 / size, 1 / size);
          context.rotate(-angle);
          context.translate(-x, -y);
        }
      };

      const CRp$3 = {};

      CRp$3.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {
  // detect problematic cases for old browsers with bad images (cheaper than try-catch)
        if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {
          return;
        }

        context.drawImage(img, ix, iy, iw, ih, x, y, w, h);
      };

      CRp$3.drawInscribedImage = function (context, img, node, index, nodeOpacity) {
        const r = this;
        const pos = node.position();
        let nodeX = pos.x;
        let nodeY = pos.y;
        const styleObj = node.cy().style();
        const getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);
        const fit = getIndexedStyle(node, 'background-fit', 'value', index);
        const repeat = getIndexedStyle(node, 'background-repeat', 'value', index);
        const nodeW = node.width();
        const nodeH = node.height();
        const paddingX2 = node.padding() * 2;
        const nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
        const nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
        const rs = node._private.rscratch;
        const clip = getIndexedStyle(node, 'background-clip', 'value', index);
        const shouldClip = clip === 'node';
        const imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;
        const smooth = getIndexedStyle(node, 'background-image-smoothing', 'value', index);
        let imgW = img.width || img.cachedW;
        let imgH = img.height || img.cachedH; // workaround for broken browsers like ie

        if (null == imgW || null == imgH) {
          document.body.appendChild(img); // eslint-disable-line no-undef

          imgW = img.cachedW = img.width || img.offsetWidth;
          imgH = img.cachedH = img.height || img.offsetHeight;
          document.body.removeChild(img); // eslint-disable-line no-undef
        }

        let w = imgW;
        let h = imgH;

        if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {
          if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {
            w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;
          } else {
            w = getIndexedStyle(node, 'background-width', 'pfValue', index);
          }
        }

        if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {
          if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {
            h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;
          } else {
            h = getIndexedStyle(node, 'background-height', 'pfValue', index);
          }
        }

        if (w === 0 || h === 0) {
          return; // no point in drawing empty image (and chrome is broken in this case)
        }

        if (fit === 'contain') {
          var scale = Math.min(nodeTW / w, nodeTH / h);
          w *= scale;
          h *= scale;
        } else if (fit === 'cover') {
          var scale = Math.max(nodeTW / w, nodeTH / h);
          w *= scale;
          h *= scale;
        }

        let x = nodeX - nodeTW / 2; // left

        const posXUnits = getIndexedStyle(node, 'background-position-x', 'units', index);
        const posXPfVal = getIndexedStyle(node, 'background-position-x', 'pfValue', index);

        if (posXUnits === '%') {
          x += (nodeTW - w) * posXPfVal;
        } else {
          x += posXPfVal;
        }

        const offXUnits = getIndexedStyle(node, 'background-offset-x', 'units', index);
        const offXPfVal = getIndexedStyle(node, 'background-offset-x', 'pfValue', index);

        if (offXUnits === '%') {
          x += (nodeTW - w) * offXPfVal;
        } else {
          x += offXPfVal;
        }

        let y = nodeY - nodeTH / 2; // top

        const posYUnits = getIndexedStyle(node, 'background-position-y', 'units', index);
        const posYPfVal = getIndexedStyle(node, 'background-position-y', 'pfValue', index);

        if (posYUnits === '%') {
          y += (nodeTH - h) * posYPfVal;
        } else {
          y += posYPfVal;
        }

        const offYUnits = getIndexedStyle(node, 'background-offset-y', 'units', index);
        const offYPfVal = getIndexedStyle(node, 'background-offset-y', 'pfValue', index);

        if (offYUnits === '%') {
          y += (nodeTH - h) * offYPfVal;
        } else {
          y += offYPfVal;
        }

        if (rs.pathCache) {
          x -= nodeX;
          y -= nodeY;
          nodeX = 0;
          nodeY = 0;
        }

        const gAlpha = context.globalAlpha;
        context.globalAlpha = imgOpacity;
        const smoothingEnabled = r.getImgSmoothing(context);
        let isSmoothingSwitched = false;

        if (smooth === 'no' && smoothingEnabled) {
          r.setImgSmoothing(context, false);
          isSmoothingSwitched = true;
        } else if (smooth === 'yes' && !smoothingEnabled) {
          r.setImgSmoothing(context, true);
          isSmoothingSwitched = true;
        }

        if (repeat === 'no-repeat') {
          if (shouldClip) {
            context.save();

            if (rs.pathCache) {
              context.clip(rs.pathCache);
            } else {
              r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);
              context.clip();
            }
          }

          r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);

          if (shouldClip) {
            context.restore();
          }
        } else {
          const pattern = context.createPattern(img, repeat);
          context.fillStyle = pattern;
          r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);
          context.translate(x, y);
          context.fill();
          context.translate(-x, -y);
        }

        context.globalAlpha = gAlpha;

        if (isSmoothingSwitched) {
          r.setImgSmoothing(context, smoothingEnabled);
        }
      };

      const CRp$4 = {};

      CRp$4.eleTextBiggerThanMin = function (ele, scale) {
        if (!scale) {
          const zoom = ele.cy().zoom();
          const pxRatio = this.getPixelRatio();
          const lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level

          scale = Math.pow(2, lvl);
        }

        const computedSize = ele.pstyle('font-size').pfValue * scale;
        const minSize = ele.pstyle('min-zoomed-font-size').pfValue;

        if (computedSize < minSize) {
          return false;
        }

        return true;
      };

      CRp$4.drawElementText = function (context, ele, shiftToOriginWithBb, force, prefix) {
        const useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
        const r = this;

        if (force == null) {
          if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) {
            return;
          }
        } else if (force === false) {
          return;
        }

        if (ele.isNode()) {
          const label = ele.pstyle('label');

          if (!label || !label.value) {
            return;
          }

          const justification = r.getLabelJustification(ele);
          context.textAlign = justification;
          context.textBaseline = 'bottom';
        } else {
          const badLine = ele.element()._private.rscratch.badLine;

          const _label = ele.pstyle('label');

          const srcLabel = ele.pstyle('source-label');
          const tgtLabel = ele.pstyle('target-label');

          if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {
            return;
          }

          context.textAlign = 'center';
          context.textBaseline = 'bottom';
        }

        const applyRotation = !shiftToOriginWithBb;
        let bb;

        if (shiftToOriginWithBb) {
          bb = shiftToOriginWithBb;
          context.translate(-bb.x1, -bb.y1);
        }

        if (prefix == null) {
          r.drawText(context, ele, null, applyRotation, useEleOpacity);

          if (ele.isEdge()) {
            r.drawText(context, ele, 'source', applyRotation, useEleOpacity);
            r.drawText(context, ele, 'target', applyRotation, useEleOpacity);
          }
        } else {
          r.drawText(context, ele, prefix, applyRotation, useEleOpacity);
        }

        if (shiftToOriginWithBb) {
          context.translate(bb.x1, bb.y1);
        }
      };

      CRp$4.getFontCache = function (context) {
        let cache;
        this.fontCaches = this.fontCaches || [];

        for (let i = 0; i < this.fontCaches.length; i++) {
          cache = this.fontCaches[i];

          if (cache.context === context) {
            return cache;
          }
        }

        cache = {
          context: context
        };
        this.fontCaches.push(cache);
        return cache;
      }; // set up canvas context with font
// returns transformed text string


      CRp$4.setupTextStyle = function (context, ele) {
        const useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  // Font style
        const labelStyle = ele.pstyle('font-style').strValue;
        const labelSize = ele.pstyle('font-size').pfValue + 'px';
        const labelFamily = ele.pstyle('font-family').strValue;
        const labelWeight = ele.pstyle('font-weight').strValue;
        const opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle('text-opacity').value : 1;
        const outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;
        const color = ele.pstyle('color').value;
        const outlineColor = ele.pstyle('text-outline-color').value;
        context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;
        context.lineJoin = 'round'; // so text outlines aren't jagged

        this.colorFillStyle(context, color[0], color[1], color[2], opacity);
        this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);
      }; // TODO ensure re-used


      function roundRect(ctx, x, y, width, height) {
        const radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
      }

      CRp$4.getTextAngle = function (ele, prefix) {
        let theta;
        const _p = ele._private;
        const rscratch = _p.rscratch;
        const pdash = prefix ? prefix + '-' : '';
        const rotation = ele.pstyle(pdash + 'text-rotation');
        const textAngle = getPrefixedProperty(rscratch, 'labelAngle', prefix);

        if (rotation.strValue === 'autorotate') {
          theta = ele.isEdge() ? textAngle : 0;
        } else if (rotation.strValue === 'none') {
          theta = 0;
        } else {
          theta = rotation.pfValue;
        }

        return theta;
      };

      CRp$4.drawText = function (context, ele, prefix) {
        const applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        const _p = ele._private;
        const rscratch = _p.rscratch;
        const parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;

        if (useEleOpacity && (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0)) {
          return;
        } // use 'main' as an alias for the main label (i.e. null prefix)


        if (prefix === 'main') {
          prefix = null;
        }

        let textX = getPrefixedProperty(rscratch, 'labelX', prefix);
        let textY = getPrefixedProperty(rscratch, 'labelY', prefix);
        let orgTextX, orgTextY; // used for rotation

        const text = this.getLabelText(ele, prefix);

        if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {
          this.setupTextStyle(context, ele, useEleOpacity);
          const pdash = prefix ? prefix + '-' : '';
          const textW = getPrefixedProperty(rscratch, 'labelWidth', prefix);
          const textH = getPrefixedProperty(rscratch, 'labelHeight', prefix);
          const marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;
          const marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;
          const isEdge = ele.isEdge();
          let halign = ele.pstyle('text-halign').value;
          let valign = ele.pstyle('text-valign').value;

          if (isEdge) {
            halign = 'center';
            valign = 'center';
          }

          textX += marginX;
          textY += marginY;
          let theta;

          if (!applyRotation) {
            theta = 0;
          } else {
            theta = this.getTextAngle(ele, prefix);
          }

          if (theta !== 0) {
            orgTextX = textX;
            orgTextY = textY;
            context.translate(orgTextX, orgTextY);
            context.rotate(theta);
            textX = 0;
            textY = 0;
          }

          switch (valign) {
            case 'top':
              break;

            case 'center':
              textY += textH / 2;
              break;

            case 'bottom':
              textY += textH;
              break;
          }

          const backgroundOpacity = ele.pstyle('text-background-opacity').value;
          const borderOpacity = ele.pstyle('text-border-opacity').value;
          const textBorderWidth = ele.pstyle('text-border-width').pfValue;
          const backgroundPadding = ele.pstyle('text-background-padding').pfValue;

          if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {
            let bgX = textX - backgroundPadding;

            switch (halign) {
              case 'left':
                bgX -= textW;
                break;

              case 'center':
                bgX -= textW / 2;
                break;
            }

            const bgY = textY - textH - backgroundPadding;
            const bgW = textW + 2 * backgroundPadding;
            const bgH = textH + 2 * backgroundPadding;

            if (backgroundOpacity > 0) {
              const textFill = context.fillStyle;
              const textBackgroundColor = ele.pstyle('text-background-color').value;
              context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
              const styleShape = ele.pstyle('text-background-shape').strValue;

              if (styleShape.indexOf('round') === 0) {
                roundRect(context, bgX, bgY, bgW, bgH, 2);
              } else {
                context.fillRect(bgX, bgY, bgW, bgH);
              }

              context.fillStyle = textFill;
            }

            if (textBorderWidth > 0 && borderOpacity > 0) {
              const textStroke = context.strokeStyle;
              const textLineWidth = context.lineWidth;
              const textBorderColor = ele.pstyle('text-border-color').value;
              const textBorderStyle = ele.pstyle('text-border-style').value;
              context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
              context.lineWidth = textBorderWidth;

              if (context.setLineDash) {
          // for very outofdate browsers
                switch (textBorderStyle) {
                  case 'dotted':
                    context.setLineDash([1, 1]);
                    break;

                  case 'dashed':
                    context.setLineDash([4, 2]);
                    break;

                  case 'double':
                    context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders

                    context.setLineDash([]);
                    break;

                  case 'solid':
                    context.setLineDash([]);
                    break;
                }
              }

              context.strokeRect(bgX, bgY, bgW, bgH);

              if (textBorderStyle === 'double') {
                const whiteWidth = textBorderWidth / 2;
                context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);
              }

              if (context.setLineDash) {
          // for very outofdate browsers
                context.setLineDash([]);
              }

              context.lineWidth = textLineWidth;
              context.strokeStyle = textStroke;
            }
          }

          const lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle

          if (lineWidth > 0) {
            context.lineWidth = lineWidth;
          }

          if (ele.pstyle('text-wrap').value === 'wrap') {
            const lines = getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);
            const lineHeight = getPrefixedProperty(rscratch, 'labelLineHeight', prefix);
            const halfTextW = textW / 2;
            const justification = this.getLabelJustification(ele);

            if (justification === 'auto') ; else if (halign === 'left') {
        // auto justification : right
              if (justification === 'left') {
                textX += -textW;
              } else if (justification === 'center') {
                textX += -halfTextW;
              } // else same as auto

            } else if (halign === 'center') {
        // auto justfication : center
              if (justification === 'left') {
                textX += -halfTextW;
              } else if (justification === 'right') {
                textX += halfTextW;
              } // else same as auto

            } else if (halign === 'right') {
        // auto justification : left
              if (justification === 'center') {
                textX += halfTextW;
              } else if (justification === 'right') {
                textX += textW;
              } // else same as auto

            }

            switch (valign) {
              case 'top':
                textY -= (lines.length - 1) * lineHeight;
                break;

              case 'center':
              case 'bottom':
                textY -= (lines.length - 1) * lineHeight;
                break;
            }

            for (let l = 0; l < lines.length; l++) {
              if (lineWidth > 0) {
                context.strokeText(lines[l], textX, textY);
              }

              context.fillText(lines[l], textX, textY);
              textY += lineHeight;
            }
          } else {
            if (lineWidth > 0) {
              context.strokeText(text, textX, textY);
            }

            context.fillText(text, textX, textY);
          }

          if (theta !== 0) {
            context.rotate(-theta);
            context.translate(-orgTextX, -orgTextY);
          }
        }
      };

/* global Path2D */
      const CRp$5 = {};

      CRp$5.drawNode = function (context, node, shiftToOriginWithBb) {
        const drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        const shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
        const r = this;
        let nodeWidth, nodeHeight;
        const _p = node._private;
        const rs = _p.rscratch;
        const pos = node.position();

        if (!number(pos.x) || !number(pos.y)) {
          return; // can't draw node with undefined position
        }

        if (shouldDrawOpacity && !node.visible()) {
          return;
        }

        const eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;
        const usePaths = r.usePaths();
        let path;
        let pathCacheHit = false;
        const padding = node.padding();
        nodeWidth = node.width() + 2 * padding;
        nodeHeight = node.height() + 2 * padding; //
  // setup shift

        let bb;

        if (shiftToOriginWithBb) {
          bb = shiftToOriginWithBb;
          context.translate(-bb.x1, -bb.y1);
        } //
  // load bg image


        const bgImgProp = node.pstyle('background-image');
        const urls = bgImgProp.value;
        const urlDefined = new Array(urls.length);
        const image = new Array(urls.length);
        let numImages = 0;

        for (let i = 0; i < urls.length; i++) {
          const url = urls[i];
          const defd = urlDefined[i] = url != null && url !== 'none';

          if (defd) {
            const bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);
            numImages++; // get image, and if not loaded then ask to redraw when later loaded

            image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {
              _p.backgroundTimestamp = Date.now();
              node.emitAndNotify('background');
            });
          }
        } //
  // setup styles


        const darkness = node.pstyle('background-blacken').value;
        const borderWidth = node.pstyle('border-width').pfValue;
        const bgOpacity = node.pstyle('background-opacity').value * eleOpacity;
        const borderColor = node.pstyle('border-color').value;
        const borderStyle = node.pstyle('border-style').value;
        const borderOpacity = node.pstyle('border-opacity').value * eleOpacity;
        context.lineJoin = 'miter'; // so borders are square with the node shape

        const setupShapeColor = function setupShapeColor() {
          const bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;
          r.eleFillStyle(context, node, bgOpy);
        };

        const setupBorderColor = function setupBorderColor() {
          const bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;
          r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);
        }; //
  // setup shape


        const styleShape = node.pstyle('shape').strValue;
        const shapePts = node.pstyle('shape-polygon-points').pfValue;

        if (usePaths) {
          context.translate(pos.x, pos.y);
          const pathCache = r.nodePathCache = r.nodePathCache || [];
          const key = hashStrings(styleShape === 'polygon' ? styleShape + ',' + shapePts.join(',') : styleShape, '' + nodeHeight, '' + nodeWidth);
          const cachedPath = pathCache[key];

          if (cachedPath != null) {
            path = cachedPath;
            pathCacheHit = true;
            rs.pathCache = path;
          } else {
            path = new Path2D();
            pathCache[key] = rs.pathCache = path;
          }
        }

        const drawShape = function drawShape() {
          if (!pathCacheHit) {
            let npos = pos;

            if (usePaths) {
              npos = {
                x: 0,
                y: 0
              };
            }

            r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);
          }

          if (usePaths) {
            context.fill(path);
          } else {
            context.fill();
          }
        };

        const drawImages = function drawImages() {
          const nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;
          const inside = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          const prevBging = _p.backgrounding;
          let totalCompleted = 0;

          for (let _i = 0; _i < image.length; _i++) {
            const bgContainment = node.cy().style().getIndexedStyle(node, 'background-image-containment', 'value', _i);

            if (inside && bgContainment === 'over' || !inside && bgContainment === 'inside') {
              totalCompleted++;
              continue;
            }

            if (urlDefined[_i] && image[_i].complete && !image[_i].error) {
              totalCompleted++;
              r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);
            }
          }

          _p.backgrounding = !(totalCompleted === numImages);

          if (prevBging !== _p.backgrounding) {
      // update style b/c :backgrounding state changed
            node.updateStyle(false);
          }
        };

        const drawPie = function drawPie() {
          const redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          const pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;

          if (r.hasPie(node)) {
            r.drawPie(context, node, pieOpacity); // redraw/restore path if steps after pie need it

            if (redrawShape) {
              if (!usePaths) {
                r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);
              }
            }
          }
        };

        const darken = function darken() {
          const darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;
          const opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;
          const c = darkness > 0 ? 0 : 255;

          if (darkness !== 0) {
            r.colorFillStyle(context, c, c, c, opacity);

            if (usePaths) {
              context.fill(path);
            } else {
              context.fill();
            }
          }
        };

        const drawBorder = function drawBorder() {
          if (borderWidth > 0) {
            context.lineWidth = borderWidth;
            context.lineCap = 'butt';

            if (context.setLineDash) {
        // for very outofdate browsers
              switch (borderStyle) {
                case 'dotted':
                  context.setLineDash([1, 1]);
                  break;

                case 'dashed':
                  context.setLineDash([4, 2]);
                  break;

                case 'solid':
                case 'double':
                  context.setLineDash([]);
                  break;
              }
            }

            if (usePaths) {
              context.stroke(path);
            } else {
              context.stroke();
            }

            if (borderStyle === 'double') {
              context.lineWidth = borderWidth / 3;
              const gco = context.globalCompositeOperation;
              context.globalCompositeOperation = 'destination-out';

              if (usePaths) {
                context.stroke(path);
              } else {
                context.stroke();
              }

              context.globalCompositeOperation = gco;
            } // reset in case we changed the border style


            if (context.setLineDash) {
        // for very outofdate browsers
              context.setLineDash([]);
            }
          }
        };

        const drawOverlay = function drawOverlay() {
          if (shouldDrawOverlay) {
            r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);
          }
        };

        const drawText = function drawText() {
          r.drawElementText(context, node, null, drawLabel);
        };

        const ghost = node.pstyle('ghost').value === 'yes';

        if (ghost) {
          const gx = node.pstyle('ghost-offset-x').pfValue;
          const gy = node.pstyle('ghost-offset-y').pfValue;
          const ghostOpacity = node.pstyle('ghost-opacity').value;
          const effGhostOpacity = ghostOpacity * eleOpacity;
          context.translate(gx, gy);
          setupShapeColor(ghostOpacity * bgOpacity);
          drawShape();
          drawImages(effGhostOpacity, true);
          setupBorderColor(ghostOpacity * borderOpacity);
          drawBorder();
          drawPie(darkness !== 0 || borderWidth !== 0);
          drawImages(effGhostOpacity, false);
          darken(effGhostOpacity);
          context.translate(-gx, -gy);
        }

        setupShapeColor();
        drawShape();
        drawImages(eleOpacity, true);
        setupBorderColor();
        drawBorder();
        drawPie(darkness !== 0 || borderWidth !== 0);
        drawImages(eleOpacity, false);
        darken();

        if (usePaths) {
          context.translate(-pos.x, -pos.y);
        }

        drawText();
        drawOverlay(); //
  // clean up shift

        if (shiftToOriginWithBb) {
          context.translate(bb.x1, bb.y1);
        }
      };

      CRp$5.drawNodeOverlay = function (context, node, pos, nodeWidth, nodeHeight) {
        const r = this;

        if (!node.visible()) {
          return;
        }

        const overlayPadding = node.pstyle('overlay-padding').pfValue;
        const overlayOpacity = node.pstyle('overlay-opacity').value;
        const overlayColor = node.pstyle('overlay-color').value;

        if (overlayOpacity > 0) {
          pos = pos || node.position();

          if (nodeWidth == null || nodeHeight == null) {
            const padding = node.padding();
            nodeWidth = node.width() + 2 * padding;
            nodeHeight = node.height() + 2 * padding;
          }

          r.colorFillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
          r.nodeShapes['roundrectangle'].draw(context, pos.x, pos.y, nodeWidth + overlayPadding * 2, nodeHeight + overlayPadding * 2);
          context.fill();
        }
      }; // does the node have at least one pie piece?


      CRp$5.hasPie = function (node) {
        node = node[0]; // ensure ele ref

        return node._private.hasPie;
      };

      CRp$5.drawPie = function (context, node, nodeOpacity, pos) {
        node = node[0]; // ensure ele ref

        pos = pos || node.position();
        const cyStyle = node.cy().style();
        const pieSize = node.pstyle('pie-size');
        let x = pos.x;
        let y = pos.y;
        const nodeW = node.width();
        const nodeH = node.height();
        let radius = Math.min(nodeW, nodeH) / 2; // must fit in node

        let lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]

        const usePaths = this.usePaths();

        if (usePaths) {
          x = 0;
          y = 0;
        }

        if (pieSize.units === '%') {
          radius = radius * pieSize.pfValue;
        } else if (pieSize.pfValue !== undefined) {
          radius = pieSize.pfValue / 2;
        }

        for (let i = 1; i <= cyStyle.pieBackgroundN; i++) {
    // 1..N
          const size = node.pstyle('pie-' + i + '-background-size').value;
          const color = node.pstyle('pie-' + i + '-background-color').value;
          const opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;
          let percent = size / 100; // map integer range [0, 100] to [0, 1]
    // percent can't push beyond 1

          if (percent + lastPercent > 1) {
            percent = 1 - lastPercent;
          }

          const angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise

          const angleDelta = 2 * Math.PI * percent;
          const angleEnd = angleStart + angleDelta; // ignore if
    // - zero size
    // - we're already beyond the full circle
    // - adding the current slice would go beyond the full circle

          if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {
            continue;
          }

          context.beginPath();
          context.moveTo(x, y);
          context.arc(x, y, radius, angleStart, angleEnd);
          context.closePath();
          this.colorFillStyle(context, color[0], color[1], color[2], opacity);
          context.fill();
          lastPercent += percent;
        }
      };

      const CRp$6 = {};
      const motionBlurDelay = 100; // var isFirefox = typeof InstallTrigger !== 'undefined';

      CRp$6.getPixelRatio = function () {
        const context = this.data.contexts[0];

        if (this.forcedPixelRatio != null) {
          return this.forcedPixelRatio;
        }

        const backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
        return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef
      };

      CRp$6.paintCache = function (context) {
        const caches = this.paintCaches = this.paintCaches || [];
        let needToCreateCache = true;
        let cache;

        for (let i = 0; i < caches.length; i++) {
          cache = caches[i];

          if (cache.context === context) {
            needToCreateCache = false;
            break;
          }
        }

        if (needToCreateCache) {
          cache = {
            context: context
          };
          caches.push(cache);
        }

        return cache;
      };

      CRp$6.createGradientStyleFor = function (context, shapeStyleName, ele, fill, opacity) {
        let gradientStyle;
        const usePaths = this.usePaths();
        const colors = ele.pstyle(shapeStyleName + '-gradient-stop-colors').value,
          positions = ele.pstyle(shapeStyleName + '-gradient-stop-positions').pfValue;

        if (fill === 'radial-gradient') {
          if (ele.isEdge()) {
            const start = ele.sourceEndpoint(),
              end = ele.targetEndpoint(),
              mid = ele.midpoint();
            const d1 = dist(start, mid);
            const d2 = dist(end, mid);
            gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));
          } else {
            const pos = usePaths ? {
                x: 0,
                y: 0
              } : ele.position(),
              width = ele.paddedWidth(),
              height = ele.paddedHeight();
            gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));
          }
        } else {
          if (ele.isEdge()) {
            const _start = ele.sourceEndpoint(),
              _end = ele.targetEndpoint();

            gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);
          } else {
            const _pos = usePaths ? {
                x: 0,
                y: 0
              } : ele.position(),
              _width = ele.paddedWidth(),
              _height = ele.paddedHeight(),
              halfWidth = _width / 2,
              halfHeight = _height / 2;

            const direction = ele.pstyle('background-gradient-direction').value;

            switch (direction) {
              case 'to-bottom':
                gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);
                break;

              case 'to-top':
                gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);
                break;

              case 'to-left':
                gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);
                break;

              case 'to-right':
                gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);
                break;

              case 'to-bottom-right':
              case 'to-right-bottom':
                gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);
                break;

              case 'to-top-right':
              case 'to-right-top':
                gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);
                break;

              case 'to-bottom-left':
              case 'to-left-bottom':
                gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);
                break;

              case 'to-top-left':
              case 'to-left-top':
                gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);
                break;
            }
          }
        }

        if (!gradientStyle) return null; // invalid gradient style

        const hasPositions = positions.length === colors.length;
        const length = colors.length;

        for (let i = 0; i < length; i++) {
          gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), 'rgba(' + colors[i][0] + ',' + colors[i][1] + ',' + colors[i][2] + ',' + opacity + ')');
        }

        return gradientStyle;
      };

      CRp$6.gradientFillStyle = function (context, ele, fill, opacity) {
        const gradientStyle = this.createGradientStyleFor(context, 'background', ele, fill, opacity);
        if (!gradientStyle) return null; // error

        context.fillStyle = gradientStyle;
      };

      CRp$6.colorFillStyle = function (context, r, g, b, a) {
        context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching
  // var cache = this.paintCache(context);
  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  // if( cache.fillStyle !== fillStyle ){
  //   context.fillStyle = cache.fillStyle = fillStyle;
  // }
      };

      CRp$6.eleFillStyle = function (context, ele, opacity) {
        const backgroundFill = ele.pstyle('background-fill').value;

        if (backgroundFill === 'linear-gradient' || backgroundFill === 'radial-gradient') {
          this.gradientFillStyle(context, ele, backgroundFill, opacity);
        } else {
          const backgroundColor = ele.pstyle('background-color').value;
          this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);
        }
      };

      CRp$6.gradientStrokeStyle = function (context, ele, fill, opacity) {
        const gradientStyle = this.createGradientStyleFor(context, 'line', ele, fill, opacity);
        if (!gradientStyle) return null; // error

        context.strokeStyle = gradientStyle;
      };

      CRp$6.colorStrokeStyle = function (context, r, g, b, a) {
        context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching
  // var cache = this.paintCache(context);
  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  // if( cache.strokeStyle !== strokeStyle ){
  //   context.strokeStyle = cache.strokeStyle = strokeStyle;
  // }
      };

      CRp$6.eleStrokeStyle = function (context, ele, opacity) {
        const lineFill = ele.pstyle('line-fill').value;

        if (lineFill === 'linear-gradient' || lineFill === 'radial-gradient') {
          this.gradientStrokeStyle(context, ele, lineFill, opacity);
        } else {
          const lineColor = ele.pstyle('line-color').value;
          this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);
        }
      }; // Resize canvas


      CRp$6.matchCanvasSize = function (container) {
        const r = this;
        const data = r.data;
        const bb = r.findContainerClientCoords();
        const width = bb[2];
        const height = bb[3];
        let pixelRatio = r.getPixelRatio();
        const mbPxRatio = r.motionBlurPxRatio;

        if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {
          pixelRatio = mbPxRatio;
        }

        const canvasWidth = width * pixelRatio;
        const canvasHeight = height * pixelRatio;
        let canvas;

        if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {
          return; // save cycles if same
        }

        r.fontCaches = null; // resizing resets the style

        const canvasContainer = data.canvasContainer;
        canvasContainer.style.width = width + 'px';
        canvasContainer.style.height = height + 'px';

        for (var i = 0; i < r.CANVAS_LAYERS; i++) {
          canvas = data.canvases[i];
          canvas.width = canvasWidth;
          canvas.height = canvasHeight;
          canvas.style.width = width + 'px';
          canvas.style.height = height + 'px';
        }

        for (var i = 0; i < r.BUFFER_COUNT; i++) {
          canvas = data.bufferCanvases[i];
          canvas.width = canvasWidth;
          canvas.height = canvasHeight;
          canvas.style.width = width + 'px';
          canvas.style.height = height + 'px';
        }

        r.textureMult = 1;

        if (pixelRatio <= 1) {
          canvas = data.bufferCanvases[r.TEXTURE_BUFFER];
          r.textureMult = 2;
          canvas.width = canvasWidth * r.textureMult;
          canvas.height = canvasHeight * r.textureMult;
        }

        r.canvasWidth = canvasWidth;
        r.canvasHeight = canvasHeight;
      };

      CRp$6.renderTo = function (cxt, zoom, pan, pxRatio) {
        this.render({
          forcedContext: cxt,
          forcedZoom: zoom,
          forcedPan: pan,
          drawAllLayers: true,
          forcedPxRatio: pxRatio
        });
      };

      CRp$6.render = function (options) {
        options = options || staticEmptyObject();
        const forcedContext = options.forcedContext;
        const drawAllLayers = options.drawAllLayers;
        const drawOnlyNodeLayer = options.drawOnlyNodeLayer;
        const forcedZoom = options.forcedZoom;
        const forcedPan = options.forcedPan;
        const r = this;
        const pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
        const cy = r.cy;
        const data = r.data;
        const needDraw = data.canvasNeedsRedraw;
        const textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
        let motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
        const mbPxRatio = r.motionBlurPxRatio;
        const hasCompoundNodes = cy.hasCompoundNodes();
        const inNodeDragGesture = r.hoverData.draggingEles;
        const inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
        motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
        let motionBlurFadeEffect = motionBlur;

        if (!forcedContext) {
          if (r.prevPxRatio !== pixelRatio) {
            r.invalidateContainerClientCoordsCache();
            r.matchCanvasSize(r.container);
            r.redrawHint('eles', true);
            r.redrawHint('drag', true);
          }

          r.prevPxRatio = pixelRatio;
        }

        if (!forcedContext && r.motionBlurTimeout) {
          clearTimeout(r.motionBlurTimeout);
        }

        if (motionBlur) {
          if (r.mbFrames == null) {
            r.mbFrames = 0;
          }

          r.mbFrames++;

          if (r.mbFrames < 3) {
      // need several frames before even high quality motionblur
            motionBlurFadeEffect = false;
          } // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)


          if (r.mbFrames > r.minMbLowQualFrames) {
      //r.fullQualityMb = false;
            r.motionBlurPxRatio = r.mbPxRBlurry;
          }
        }

        if (r.clearingMotionBlur) {
          r.motionBlurPxRatio = 1;
        } // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
  // because a rogue async texture frame would clear needDraw


        if (r.textureDrawLastFrame && !textureDraw) {
          needDraw[r.NODE] = true;
          needDraw[r.SELECT_BOX] = true;
        }

        const style = cy.style();
        var zoom = cy.zoom();
        let effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
        const pan = cy.pan();
        let effectivePan = {
          x: pan.x,
          y: pan.y
        };
        var vp = {
          zoom: zoom,
          pan: {
            x: pan.x,
            y: pan.y
          }
        };
        const prevVp = r.prevViewport;
        const viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y; // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)

        if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {
          r.motionBlurPxRatio = 1;
        }

        if (forcedPan) {
          effectivePan = forcedPan;
        } // apply pixel ratio


        effectiveZoom *= pixelRatio;
        effectivePan.x *= pixelRatio;
        effectivePan.y *= pixelRatio;
        const eles = r.getCachedZSortedEles();

        function mbclear(context, x, y, w, h) {
          const gco = context.globalCompositeOperation;
          context.globalCompositeOperation = 'destination-out';
          r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);
          context.fillRect(x, y, w, h);
          context.globalCompositeOperation = gco;
        }

        function setContextTransform(context, clear) {
          let ePan, eZoom, w, h;

          if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {
            ePan = {
              x: pan.x * mbPxRatio,
              y: pan.y * mbPxRatio
            };
            eZoom = zoom * mbPxRatio;
            w = r.canvasWidth * mbPxRatio;
            h = r.canvasHeight * mbPxRatio;
          } else {
            ePan = effectivePan;
            eZoom = effectiveZoom;
            w = r.canvasWidth;
            h = r.canvasHeight;
          }

          context.setTransform(1, 0, 0, 1, 0, 0);

          if (clear === 'motionBlur') {
            mbclear(context, 0, 0, w, h);
          } else if (!forcedContext && (clear === undefined || clear)) {
            context.clearRect(0, 0, w, h);
          }

          if (!drawAllLayers) {
            context.translate(ePan.x, ePan.y);
            context.scale(eZoom, eZoom);
          }

          if (forcedPan) {
            context.translate(forcedPan.x, forcedPan.y);
          }

          if (forcedZoom) {
            context.scale(forcedZoom, forcedZoom);
          }
        }

        if (!textureDraw) {
          r.textureDrawLastFrame = false;
        }

        if (textureDraw) {
          r.textureDrawLastFrame = true;

          if (!r.textureCache) {
            r.textureCache = {};
            r.textureCache.bb = cy.mutableElements().boundingBox();
            r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];
            const cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];
            cxt.setTransform(1, 0, 0, 1, 0, 0);
            cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);
            r.render({
              forcedContext: cxt,
              drawOnlyNodeLayer: true,
              forcedPxRatio: pixelRatio * r.textureMult
            });
            var vp = r.textureCache.viewport = {
              zoom: cy.zoom(),
              pan: cy.pan(),
              width: r.canvasWidth,
              height: r.canvasHeight
            };
            vp.mpan = {
              x: (0 - vp.pan.x) / vp.zoom,
              y: (0 - vp.pan.y) / vp.zoom
            };
          }

          needDraw[r.DRAG] = false;
          needDraw[r.NODE] = false;
          var context = data.contexts[r.NODE];
          const texture = r.textureCache.texture;
          var vp = r.textureCache.viewport;
          context.setTransform(1, 0, 0, 1, 0, 0);

          if (motionBlur) {
            mbclear(context, 0, 0, vp.width, vp.height);
          } else {
            context.clearRect(0, 0, vp.width, vp.height);
          }

          const outsideBgColor = style.core('outside-texture-bg-color').value;
          const outsideBgOpacity = style.core('outside-texture-bg-opacity').value;
          r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);
          context.fillRect(0, 0, vp.width, vp.height);
          var zoom = cy.zoom();
          setContextTransform(context, false);
          context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
          context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
        } else if (r.textureOnViewport && !forcedContext) {
    // clear the cache since we don't need it
          r.textureCache = null;
        }

        const extent = cy.extent();
        const vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();
        const hideEdges = r.hideEdgesOnViewport && vpManip;
        const needMbClear = [];
        needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;

        if (needMbClear[r.NODE]) {
          r.clearedForMotionBlur[r.NODE] = true;
        }

        needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;

        if (needMbClear[r.DRAG]) {
          r.clearedForMotionBlur[r.DRAG] = true;
        }

        if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {
          var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;
          var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);
          const clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;
          setContextTransform(context, clear);

          if (hideEdges) {
            r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);
          } else {
            r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);
          }

          if (r.debug) {
            r.drawDebugPoints(context, eles.nondrag);
          }

          if (!drawAllLayers && !motionBlur) {
            needDraw[r.NODE] = false;
          }
        }

        if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {
          var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;
          var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);
          setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);

          if (hideEdges) {
            r.drawCachedNodes(context, eles.drag, pixelRatio, extent);
          } else {
            r.drawCachedElements(context, eles.drag, pixelRatio, extent);
          }

          if (r.debug) {
            r.drawDebugPoints(context, eles.drag);
          }

          if (!drawAllLayers && !motionBlur) {
            needDraw[r.DRAG] = false;
          }
        }

        if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {
          var context = forcedContext || data.contexts[r.SELECT_BOX];
          setContextTransform(context);

          if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {
            var zoom = r.cy.zoom();
            const borderWidth = style.core('selection-box-border-width').value / zoom;
            context.lineWidth = borderWidth;
            context.fillStyle = 'rgba(' + style.core('selection-box-color').value[0] + ',' + style.core('selection-box-color').value[1] + ',' + style.core('selection-box-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';
            context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);

            if (borderWidth > 0) {
              context.strokeStyle = 'rgba(' + style.core('selection-box-border-color').value[0] + ',' + style.core('selection-box-border-color').value[1] + ',' + style.core('selection-box-border-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';
              context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);
            }
          }

          if (data.bgActivePosistion && !r.hoverData.selecting) {
            var zoom = r.cy.zoom();
            const pos = data.bgActivePosistion;
            context.fillStyle = 'rgba(' + style.core('active-bg-color').value[0] + ',' + style.core('active-bg-color').value[1] + ',' + style.core('active-bg-color').value[2] + ',' + style.core('active-bg-opacity').value + ')';
            context.beginPath();
            context.arc(pos.x, pos.y, style.core('active-bg-size').pfValue / zoom, 0, 2 * Math.PI);
            context.fill();
          }

          let timeToRender = r.lastRedrawTime;

          if (r.showFps && timeToRender) {
            timeToRender = Math.round(timeToRender);
            const fps = Math.round(1000 / timeToRender);
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.fillStyle = 'rgba(255, 0, 0, 0.75)';
            context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
            context.lineWidth = 1;
            context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);
            const maxFps = 60;
            context.strokeRect(0, 30, 250, 20);
            context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);
          }

          if (!drawAllLayers) {
            needDraw[r.SELECT_BOX] = false;
          }
        } // motionblur: blit rendered blurry frames


        if (motionBlur && mbPxRatio !== 1) {
          const cxtNode = data.contexts[r.NODE];
          const txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];
          const cxtDrag = data.contexts[r.DRAG];
          const txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];

          const drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {
            cxt.setTransform(1, 0, 0, 1, 0, 0);

            if (needClear || !motionBlurFadeEffect) {
              cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);
            } else {
              mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);
            }

            const pxr = mbPxRatio;
            cxt.drawImage(txt, // img
                          0, 0, // sx, sy
                          r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
                          0, 0, // x, y
                          r.canvasWidth, r.canvasHeight // w, h
            );
          };

          if (needDraw[r.NODE] || needMbClear[r.NODE]) {
            drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);
            needDraw[r.NODE] = false;
          }

          if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {
            drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);
            needDraw[r.DRAG] = false;
          }
        }

        r.prevViewport = vp;

        if (r.clearingMotionBlur) {
          r.clearingMotionBlur = false;
          r.motionBlurCleared = true;
          r.motionBlur = true;
        }

        if (motionBlur) {
          r.motionBlurTimeout = setTimeout(function () {
            r.motionBlurTimeout = null;
            r.clearedForMotionBlur[r.NODE] = false;
            r.clearedForMotionBlur[r.DRAG] = false;
            r.motionBlur = false;
            r.clearingMotionBlur = !textureDraw;
            r.mbFrames = 0;
            needDraw[r.NODE] = true;
            needDraw[r.DRAG] = true;
            r.redraw();
          }, motionBlurDelay);
        }

        if (!forcedContext) {
          cy.emit('render');
        }
      };

      const CRp$7 = {}; // @O Polygon drawing

      CRp$7.drawPolygonPath = function (context, x, y, width, height, points) {
        const halfW = width / 2;
        const halfH = height / 2;

        if (context.beginPath) {
          context.beginPath();
        }

        context.moveTo(x + halfW * points[0], y + halfH * points[1]);

        for (let i = 1; i < points.length / 2; i++) {
          context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);
        }

        context.closePath();
      };

      CRp$7.drawRoundPolygonPath = function (context, x, y, width, height, points) {
        const halfW = width / 2;
        const halfH = height / 2;
        const cornerRadius = getRoundPolygonRadius(width, height);

        if (context.beginPath) {
          context.beginPath();
        }

        for (let _i = 0; _i < points.length / 4; _i++) {
          let sourceUv = void 0,
            destUv = void 0;

          if (_i === 0) {
            sourceUv = points.length - 2;
          } else {
            sourceUv = _i * 4 - 2;
          }

          destUv = _i * 4 + 2;
          const px = x + halfW * points[_i * 4];
          const py = y + halfH * points[_i * 4 + 1];
          const cosTheta = -points[sourceUv] * points[destUv] - points[sourceUv + 1] * points[destUv + 1];
          const offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
          const cp0x = px - offset * points[sourceUv];
          const cp0y = py - offset * points[sourceUv + 1];
          const cp1x = px + offset * points[destUv];
          const cp1y = py + offset * points[destUv + 1];

          if (_i === 0) {
            context.moveTo(cp0x, cp0y);
          } else {
            context.lineTo(cp0x, cp0y);
          }

          context.arcTo(px, py, cp1x, cp1y, cornerRadius);
        }

        context.closePath();
      }; // Round rectangle drawing


      CRp$7.drawRoundRectanglePath = function (context, x, y, width, height) {
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        const cornerRadius = getRoundRectangleRadius(width, height);

        if (context.beginPath) {
          context.beginPath();
        } // Start at top middle


        context.moveTo(x, y - halfHeight); // Arc from middle top to right side

        context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius); // Arc from right side to bottom

        context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius); // Arc from bottom to left side

        context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius); // Arc from left side to topBorder

        context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius); // Join line

        context.lineTo(x, y - halfHeight);
        context.closePath();
      };

      CRp$7.drawBottomRoundRectanglePath = function (context, x, y, width, height) {
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        const cornerRadius = getRoundRectangleRadius(width, height);

        if (context.beginPath) {
          context.beginPath();
        } // Start at top middle


        context.moveTo(x, y - halfHeight);
        context.lineTo(x + halfWidth, y - halfHeight);
        context.lineTo(x + halfWidth, y);
        context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
        context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
        context.lineTo(x - halfWidth, y - halfHeight);
        context.lineTo(x, y - halfHeight);
        context.closePath();
      };

      CRp$7.drawCutRectanglePath = function (context, x, y, width, height) {
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        const cornerLength = getCutRectangleCornerLength();

        if (context.beginPath) {
          context.beginPath();
        }

        context.moveTo(x - halfWidth + cornerLength, y - halfHeight);
        context.lineTo(x + halfWidth - cornerLength, y - halfHeight);
        context.lineTo(x + halfWidth, y - halfHeight + cornerLength);
        context.lineTo(x + halfWidth, y + halfHeight - cornerLength);
        context.lineTo(x + halfWidth - cornerLength, y + halfHeight);
        context.lineTo(x - halfWidth + cornerLength, y + halfHeight);
        context.lineTo(x - halfWidth, y + halfHeight - cornerLength);
        context.lineTo(x - halfWidth, y - halfHeight + cornerLength);
        context.closePath();
      };

      CRp$7.drawBarrelPath = function (context, x, y, width, height) {
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        const xBegin = x - halfWidth;
        const xEnd = x + halfWidth;
        const yBegin = y - halfHeight;
        const yEnd = y + halfHeight;
        const barrelCurveConstants = getBarrelCurveConstants(width, height);
        const wOffset = barrelCurveConstants.widthOffset;
        const hOffset = barrelCurveConstants.heightOffset;
        const ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;

        if (context.beginPath) {
          context.beginPath();
        }

        context.moveTo(xBegin, yBegin + hOffset);
        context.lineTo(xBegin, yEnd - hOffset);
        context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);
        context.lineTo(xEnd - wOffset, yEnd);
        context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);
        context.lineTo(xEnd, yBegin + hOffset);
        context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);
        context.lineTo(xBegin + wOffset, yBegin);
        context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);
        context.closePath();
      };

      const sin0 = Math.sin(0);
      const cos0 = Math.cos(0);
      const sin = {};
      const cos = {};
      const ellipseStepSize = Math.PI / 40;

      for (let i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
        sin[i] = Math.sin(i);
        cos[i] = Math.cos(i);
      }

      CRp$7.drawEllipsePath = function (context, centerX, centerY, width, height) {
        if (context.beginPath) {
          context.beginPath();
        }

        if (context.ellipse) {
          context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);
        } else {
          let xPos, yPos;
          const rw = width / 2;
          const rh = height / 2;

          for (let i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
            xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;
            yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;

            if (i === 0) {
              context.moveTo(xPos, yPos);
            } else {
              context.lineTo(xPos, yPos);
            }
          }
        }

        context.closePath();
      };

/* global atob, ArrayBuffer, Uint8Array, Blob */
      const CRp$8 = {};

      CRp$8.createBuffer = function (w, h) {
        const buffer = document.createElement('canvas'); // eslint-disable-line no-undef

        buffer.width = w;
        buffer.height = h;
        return [buffer, buffer.getContext('2d')];
      };

      CRp$8.bufferCanvasImage = function (options) {
        const cy = this.cy;
        const eles = cy.mutableElements();
        const bb = eles.boundingBox();
        const ctrRect = this.findContainerClientCoords();
        let width = options.full ? Math.ceil(bb.w) : ctrRect[2];
        let height = options.full ? Math.ceil(bb.h) : ctrRect[3];
        const specdMaxDims = number(options.maxWidth) || number(options.maxHeight);
        const pxRatio = this.getPixelRatio();
        let scale = 1;

        if (options.scale !== undefined) {
          width *= options.scale;
          height *= options.scale;
          scale = options.scale;
        } else if (specdMaxDims) {
          let maxScaleW = Infinity;
          let maxScaleH = Infinity;

          if (number(options.maxWidth)) {
            maxScaleW = scale * options.maxWidth / width;
          }

          if (number(options.maxHeight)) {
            maxScaleH = scale * options.maxHeight / height;
          }

          scale = Math.min(maxScaleW, maxScaleH);
          width *= scale;
          height *= scale;
        }

        if (!specdMaxDims) {
          width *= pxRatio;
          height *= pxRatio;
          scale *= pxRatio;
        }

        const buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef

        buffCanvas.width = width;
        buffCanvas.height = height;
        buffCanvas.style.width = width + 'px';
        buffCanvas.style.height = height + 'px';
        const buffCxt = buffCanvas.getContext('2d'); // Rasterize the layers, but only if container has nonzero size

        if (width > 0 && height > 0) {
          buffCxt.clearRect(0, 0, width, height);
          buffCxt.globalCompositeOperation = 'source-over';
          const zsortedEles = this.getCachedZSortedEles();

          if (options.full) {
      // draw the full bounds of the graph
            buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);
            buffCxt.scale(scale, scale);
            this.drawElements(buffCxt, zsortedEles);
            buffCxt.scale(1 / scale, 1 / scale);
            buffCxt.translate(bb.x1 * scale, bb.y1 * scale);
          } else {
      // draw the current view
            const pan = cy.pan();
            const translation = {
              x: pan.x * scale,
              y: pan.y * scale
            };
            scale *= cy.zoom();
            buffCxt.translate(translation.x, translation.y);
            buffCxt.scale(scale, scale);
            this.drawElements(buffCxt, zsortedEles);
            buffCxt.scale(1 / scale, 1 / scale);
            buffCxt.translate(-translation.x, -translation.y);
          } // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs


          if (options.bg) {
            buffCxt.globalCompositeOperation = 'destination-over';
            buffCxt.fillStyle = options.bg;
            buffCxt.rect(0, 0, width, height);
            buffCxt.fill();
          }
        }

        return buffCanvas;
      };

      function b64ToBlob(b64, mimeType) {
        const bytes = atob(b64);
        const buff = new ArrayBuffer(bytes.length);
        const buffUint8 = new Uint8Array(buff);

        for (let i = 0; i < bytes.length; i++) {
          buffUint8[i] = bytes.charCodeAt(i);
        }

        return new Blob([buff], {
          type: mimeType
        });
      }

      function b64UriToB64(b64uri) {
        const i = b64uri.indexOf(',');
        return b64uri.substr(i + 1);
      }

      function output(options, canvas, mimeType) {
        const getB64Uri = function getB64Uri() {
          return canvas.toDataURL(mimeType, options.quality);
        };

        switch (options.output) {
          case 'blob-promise':
            return new Promise$1(function (resolve, reject) {
              try {
                canvas.toBlob(function (blob) {
                  if (blob != null) {
                    resolve(blob);
                  } else {
                    reject(new Error('`canvas.toBlob()` sent a null value in its callback'));
                  }
                }, mimeType, options.quality);
              } catch (err) {
                reject(err);
              }
            });

          case 'blob':
            return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);

          case 'base64':
            return b64UriToB64(getB64Uri());

          case 'base64uri':
          default:
            return getB64Uri();
        }
      }

      CRp$8.png = function (options) {
        return output(options, this.bufferCanvasImage(options), 'image/png');
      };

      CRp$8.jpg = function (options) {
        return output(options, this.bufferCanvasImage(options), 'image/jpeg');
      };

      const CRp$9 = {};

      CRp$9.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {
        switch (name) {
          case 'ellipse':
            return this.drawEllipsePath(context, centerX, centerY, width, height);

          case 'polygon':
            return this.drawPolygonPath(context, centerX, centerY, width, height, points);

          case 'round-polygon':
            return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points);

          case 'roundrectangle':
          case 'round-rectangle':
            return this.drawRoundRectanglePath(context, centerX, centerY, width, height);

          case 'cutrectangle':
          case 'cut-rectangle':
            return this.drawCutRectanglePath(context, centerX, centerY, width, height);

          case 'bottomroundrectangle':
          case 'bottom-round-rectangle':
            return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);

          case 'barrel':
            return this.drawBarrelPath(context, centerX, centerY, width, height);
        }
      };

      const CR = CanvasRenderer;
      const CRp$a = CanvasRenderer.prototype;
      CRp$a.CANVAS_LAYERS = 3; //

      CRp$a.SELECT_BOX = 0;
      CRp$a.DRAG = 1;
      CRp$a.NODE = 2;
      CRp$a.BUFFER_COUNT = 3; //

      CRp$a.TEXTURE_BUFFER = 0;
      CRp$a.MOTIONBLUR_BUFFER_NODE = 1;
      CRp$a.MOTIONBLUR_BUFFER_DRAG = 2;

      function CanvasRenderer(options) {
        const r = this;
        r.data = {
          canvases: new Array(CRp$a.CANVAS_LAYERS),
          contexts: new Array(CRp$a.CANVAS_LAYERS),
          canvasNeedsRedraw: new Array(CRp$a.CANVAS_LAYERS),
          bufferCanvases: new Array(CRp$a.BUFFER_COUNT),
          bufferContexts: new Array(CRp$a.CANVAS_LAYERS)
        };
        const tapHlOffAttr = '-webkit-tap-highlight-color';
        const tapHlOffStyle = 'rgba(0,0,0,0)';
        r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef

        const containerStyle = r.data.canvasContainer.style;
        r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;
        containerStyle.position = 'relative';
        containerStyle.zIndex = '0';
        containerStyle.overflow = 'hidden';
        const container = options.cy.container();
        container.appendChild(r.data.canvasContainer);
        container.style[tapHlOffAttr] = tapHlOffStyle;
        const styleMap = {
          '-webkit-user-select': 'none',
          '-moz-user-select': '-moz-none',
          'user-select': 'none',
          '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',
          'outline-style': 'none'
        };

        if (ms()) {
          styleMap['-ms-touch-action'] = 'none';
          styleMap['touch-action'] = 'none';
        }

        for (var i = 0; i < CRp$a.CANVAS_LAYERS; i++) {
          var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef

          r.data.contexts[i] = canvas.getContext('2d');
          Object.keys(styleMap).forEach(function (k) {
            canvas.style[k] = styleMap[k];
          });
          canvas.style.position = 'absolute';
          canvas.setAttribute('data-id', 'layer' + i);
          canvas.style.zIndex = String(CRp$a.CANVAS_LAYERS - i);
          r.data.canvasContainer.appendChild(canvas);
          r.data.canvasNeedsRedraw[i] = false;
        }

        r.data.topCanvas = r.data.canvases[0];
        r.data.canvases[CRp$a.NODE].setAttribute('data-id', 'layer' + CRp$a.NODE + '-node');
        r.data.canvases[CRp$a.SELECT_BOX].setAttribute('data-id', 'layer' + CRp$a.SELECT_BOX + '-selectbox');
        r.data.canvases[CRp$a.DRAG].setAttribute('data-id', 'layer' + CRp$a.DRAG + '-drag');

        for (var i = 0; i < CRp$a.BUFFER_COUNT; i++) {
          r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef

          r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');
          r.data.bufferCanvases[i].style.position = 'absolute';
          r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
          r.data.bufferCanvases[i].style.zIndex = String(-i - 1);
          r.data.bufferCanvases[i].style.visibility = 'hidden'; //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
        }

        r.pathsEnabled = true;
        const emptyBb = makeBoundingBox();

        const getBoxCenter = function getBoxCenter(bb) {
          return {
            x: (bb.x1 + bb.x2) / 2,
            y: (bb.y1 + bb.y2) / 2
          };
        };

        const getCenterOffset = function getCenterOffset(bb) {
          return {
            x: -bb.w / 2,
            y: -bb.h / 2
          };
        };

        const backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {
          const _p = ele[0]._private;
          const same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;
          return !same;
        };

        const getStyleKey = function getStyleKey(ele) {
          return ele[0]._private.nodeKey;
        };

        const getLabelKey = function getLabelKey(ele) {
          return ele[0]._private.labelStyleKey;
        };

        const getSourceLabelKey = function getSourceLabelKey(ele) {
          return ele[0]._private.sourceLabelStyleKey;
        };

        const getTargetLabelKey = function getTargetLabelKey(ele) {
          return ele[0]._private.targetLabelStyleKey;
        };

        const drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {
          return r.drawElement(context, ele, bb, false, false, useEleOpacity);
        };

        const drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
          return r.drawElementText(context, ele, bb, scaledLabelShown, 'main', useEleOpacity);
        };

        const drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
          return r.drawElementText(context, ele, bb, scaledLabelShown, 'source', useEleOpacity);
        };

        const drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
          return r.drawElementText(context, ele, bb, scaledLabelShown, 'target', useEleOpacity);
        };

        const getElementBox = function getElementBox(ele) {
          ele.boundingBox();
          return ele[0]._private.bodyBounds;
        };

        const getLabelBox = function getLabelBox(ele) {
          ele.boundingBox();
          return ele[0]._private.labelBounds.main || emptyBb;
        };

        const getSourceLabelBox = function getSourceLabelBox(ele) {
          ele.boundingBox();
          return ele[0]._private.labelBounds.source || emptyBb;
        };

        const getTargetLabelBox = function getTargetLabelBox(ele) {
          ele.boundingBox();
          return ele[0]._private.labelBounds.target || emptyBb;
        };

        const isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {
          return scaledLabelShown;
        };

        const getElementRotationPoint = function getElementRotationPoint(ele) {
          return getBoxCenter(getElementBox(ele));
        };

        const addTextMargin = function addTextMargin(prefix, pt, ele) {
          const pre = prefix ? prefix + '-' : '';
          return {
            x: pt.x + ele.pstyle(pre + 'text-margin-x').pfValue,
            y: pt.y + ele.pstyle(pre + 'text-margin-y').pfValue
          };
        };

        const getRsPt = function getRsPt(ele, x, y) {
          const rs = ele[0]._private.rscratch;
          return {
            x: rs[x],
            y: rs[y]
          };
        };

        const getLabelRotationPoint = function getLabelRotationPoint(ele) {
          return addTextMargin('', getRsPt(ele, 'labelX', 'labelY'), ele);
        };

        const getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {
          return addTextMargin('source', getRsPt(ele, 'sourceLabelX', 'sourceLabelY'), ele);
        };

        const getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {
          return addTextMargin('target', getRsPt(ele, 'targetLabelX', 'targetLabelY'), ele);
        };

        const getElementRotationOffset = function getElementRotationOffset(ele) {
          return getCenterOffset(getElementBox(ele));
        };

        const getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {
          return getCenterOffset(getSourceLabelBox(ele));
        };

        const getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {
          return getCenterOffset(getTargetLabelBox(ele));
        };

        const getLabelRotationOffset = function getLabelRotationOffset(ele) {
          const bb = getLabelBox(ele);
          const p = getCenterOffset(getLabelBox(ele));

          if (ele.isNode()) {
            switch (ele.pstyle('text-halign').value) {
              case 'left':
                p.x = -bb.w;
                break;

              case 'right':
                p.x = 0;
                break;
            }

            switch (ele.pstyle('text-valign').value) {
              case 'top':
                p.y = -bb.h;
                break;

              case 'bottom':
                p.y = 0;
                break;
            }
          }

          return p;
        };

        const eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {
          getKey: getStyleKey,
          doesEleInvalidateKey: backgroundTimestampHasChanged,
          drawElement: drawElement,
          getBoundingBox: getElementBox,
          getRotationPoint: getElementRotationPoint,
          getRotationOffset: getElementRotationOffset,
          allowEdgeTxrCaching: false,
          allowParentTxrCaching: false
        });
        const lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {
          getKey: getLabelKey,
          drawElement: drawLabel,
          getBoundingBox: getLabelBox,
          getRotationPoint: getLabelRotationPoint,
          getRotationOffset: getLabelRotationOffset,
          isVisible: isLabelVisibleAtScale
        });
        const slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {
          getKey: getSourceLabelKey,
          drawElement: drawSourceLabel,
          getBoundingBox: getSourceLabelBox,
          getRotationPoint: getSourceLabelRotationPoint,
          getRotationOffset: getSourceLabelRotationOffset,
          isVisible: isLabelVisibleAtScale
        });
        const tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {
          getKey: getTargetLabelKey,
          drawElement: drawTargetLabel,
          getBoundingBox: getTargetLabelBox,
          getRotationPoint: getTargetLabelRotationPoint,
          getRotationOffset: getTargetLabelRotationOffset,
          isVisible: isLabelVisibleAtScale
        });
        const lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);
        r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {
    // each cache should check for sub-key diff to see that the update affects that cache particularly
          eleTxrCache.invalidateElements(eles);
          lblTxrCache.invalidateElements(eles);
          slbTxrCache.invalidateElements(eles);
          tlbTxrCache.invalidateElements(eles); // any change invalidates the layers

          lyrTxrCache.invalidateElements(eles); // update the old bg timestamp so diffs can be done in the ele txr caches

          for (let _i = 0; _i < eles.length; _i++) {
            const _p = eles[_i]._private;
            _p.oldBackgroundTimestamp = _p.backgroundTimestamp;
          }
        });

        const refineInLayers = function refineInLayers(reqs) {
          for (let i = 0; i < reqs.length; i++) {
            lyrTxrCache.enqueueElementRefinement(reqs[i].ele);
          }
        };

        eleTxrCache.onDequeue(refineInLayers);
        lblTxrCache.onDequeue(refineInLayers);
        slbTxrCache.onDequeue(refineInLayers);
        tlbTxrCache.onDequeue(refineInLayers);
      }

      CRp$a.redrawHint = function (group, bool) {
        const r = this;

        switch (group) {
          case 'eles':
            r.data.canvasNeedsRedraw[CRp$a.NODE] = bool;
            break;

          case 'drag':
            r.data.canvasNeedsRedraw[CRp$a.DRAG] = bool;
            break;

          case 'select':
            r.data.canvasNeedsRedraw[CRp$a.SELECT_BOX] = bool;
            break;
        }
      }; // whether to use Path2D caching for drawing


      const pathsImpld = typeof Path2D !== 'undefined';

      CRp$a.path2dEnabled = function (on) {
        if (on === undefined) {
          return this.pathsEnabled;
        }

        this.pathsEnabled = on ? true : false;
      };

      CRp$a.usePaths = function () {
        return pathsImpld && this.pathsEnabled;
      };

      CRp$a.setImgSmoothing = function (context, bool) {
        if (context.imageSmoothingEnabled != null) {
          context.imageSmoothingEnabled = bool;
        } else {
          context.webkitImageSmoothingEnabled = bool;
          context.mozImageSmoothingEnabled = bool;
          context.msImageSmoothingEnabled = bool;
        }
      };

      CRp$a.getImgSmoothing = function (context) {
        if (context.imageSmoothingEnabled != null) {
          return context.imageSmoothingEnabled;
        } else {
          return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;
        }
      };

      CRp$a.makeOffscreenCanvas = function (width, height) {
        let canvas;

        if ((typeof OffscreenCanvas === "undefined" ? "undefined" : _typeof(OffscreenCanvas)) !== ( "undefined" )) {
          canvas = new OffscreenCanvas(width, height);
        } else {
          canvas = document.createElement('canvas'); // eslint-disable-line no-undef

          canvas.width = width;
          canvas.height = height;
        }

        return canvas;
      };

      [CRp, CRp$1, CRp$2, CRp$3, CRp$4, CRp$5, CRp$6, CRp$7, CRp$8, CRp$9].forEach(function (props) {
        extend(CRp$a, props);
      });

      const renderer = [{
        name: 'null',
        impl: NullRenderer
      }, {
        name: 'base',
        impl: BR
      }, {
        name: 'canvas',
        impl: CR
      }];

      const incExts = [{
        type: 'layout',
        extensions: layout
      }, {
        type: 'renderer',
        extensions: renderer
      }];

      const extensions = {}; // registered modules for extensions, indexed by name

      const modules = {};

      function setExtension(type, name, registrant) {
        let ext = registrant;

        const overrideErr = function overrideErr(field) {
          error('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');
        };

        if (type === 'core') {
          if (Core.prototype[name]) {
            return overrideErr(name);
          } else {
            Core.prototype[name] = registrant;
          }
        } else if (type === 'collection') {
          if (Collection.prototype[name]) {
            return overrideErr(name);
          } else {
            Collection.prototype[name] = registrant;
          }
        } else if (type === 'layout') {
    // fill in missing layout functions in the prototype
          const Layout = function Layout(options) {
            this.options = options;
            registrant.call(this, options); // make sure layout has _private for use w/ std apis like .on()

            if (!plainObject(this._private)) {
              this._private = {};
            }

            this._private.cy = options.cy;
            this._private.listeners = [];
            this.createEmitter();
          };

          const layoutProto = Layout.prototype = Object.create(registrant.prototype);
          const optLayoutFns = [];

          for (let i = 0; i < optLayoutFns.length; i++) {
            const fnName = optLayoutFns[i];

            layoutProto[fnName] = layoutProto[fnName] || function () {
              return this;
            };
          } // either .start() or .run() is defined, so autogen the other


          if (layoutProto.start && !layoutProto.run) {
            layoutProto.run = function () {
              this.start();
              return this;
            };
          } else if (!layoutProto.start && layoutProto.run) {
            layoutProto.start = function () {
              this.run();
              return this;
            };
          }

          const regStop = registrant.prototype.stop;

          layoutProto.stop = function () {
            const opts = this.options;

            if (opts && opts.animate) {
              const anis = this.animations;

              if (anis) {
                for (let _i = 0; _i < anis.length; _i++) {
                  anis[_i].stop();
                }
              }
            }

            if (regStop) {
              regStop.call(this);
            } else {
              this.emit('layoutstop');
            }

            return this;
          };

          if (!layoutProto.destroy) {
            layoutProto.destroy = function () {
              return this;
            };
          }

          layoutProto.cy = function () {
            return this._private.cy;
          };

          const getCy = function getCy(layout) {
            return layout._private.cy;
          };

          const emitterOpts = {
            addEventFields: function addEventFields(layout, evt) {
              evt.layout = layout;
              evt.cy = getCy(layout);
              evt.target = layout;
            },
            bubble: function bubble() {
              return true;
            },
            parent: function parent(layout) {
              return getCy(layout);
            }
          };
          extend(layoutProto, {
            createEmitter: function createEmitter() {
              this._private.emitter = new Emitter(emitterOpts, this);
              return this;
            },
            emitter: function emitter() {
              return this._private.emitter;
            },
            on: function on(evt, cb) {
              this.emitter().on(evt, cb);
              return this;
            },
            one: function one(evt, cb) {
              this.emitter().one(evt, cb);
              return this;
            },
            once: function once(evt, cb) {
              this.emitter().one(evt, cb);
              return this;
            },
            removeListener: function removeListener(evt, cb) {
              this.emitter().removeListener(evt, cb);
              return this;
            },
            removeAllListeners: function removeAllListeners() {
              this.emitter().removeAllListeners();
              return this;
            },
            emit: function emit(evt, params) {
              this.emitter().emit(evt, params);
              return this;
            }
          });
          define$3.eventAliasesOn(layoutProto);
          ext = Layout; // replace with our wrapped layout
        } else if (type === 'renderer' && name !== 'null' && name !== 'base') {
    // user registered renderers inherit from base
          const BaseRenderer = getExtension('renderer', 'base');
          const bProto = BaseRenderer.prototype;
          const RegistrantRenderer = registrant;
          const rProto = registrant.prototype;

          const Renderer = function Renderer() {
            BaseRenderer.apply(this, arguments);
            RegistrantRenderer.apply(this, arguments);
          };

          const proto = Renderer.prototype;

          for (const pName in bProto) {
            const pVal = bProto[pName];
            const existsInR = rProto[pName] != null;

            if (existsInR) {
              return overrideErr(pName);
            }

            proto[pName] = pVal; // take impl from base
          }

          for (const _pName in rProto) {
            proto[_pName] = rProto[_pName]; // take impl from registrant
          }

          bProto.clientFunctions.forEach(function (name) {
            proto[name] = proto[name] || function () {
              error('Renderer does not implement `renderer.' + name + '()` on its prototype');
            };
          });
          ext = Renderer;
        }

        return setMap({
          map: extensions,
          keys: [type, name],
          value: ext
        });
      }

      function getExtension(type, name) {
        return getMap({
          map: extensions,
          keys: [type, name]
        });
      }

      function setModule(type, name, moduleType, moduleName, registrant) {
        return setMap({
          map: modules,
          keys: [type, name, moduleType, moduleName],
          value: registrant
        });
      }

      function getModule(type, name, moduleType, moduleName) {
        return getMap({
          map: modules,
          keys: [type, name, moduleType, moduleName]
        });
      }

      const extension = function extension() {
  // e.g. extension('renderer', 'svg')
        if (arguments.length === 2) {
          return getExtension.apply(null, arguments);
        } // e.g. extension('renderer', 'svg', { ... })
        else if (arguments.length === 3) {
          return setExtension.apply(null, arguments);
        } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
        else if (arguments.length === 4) {
          return getModule.apply(null, arguments);
        } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
        else if (arguments.length === 5) {
          return setModule.apply(null, arguments);
        } else {
          error('Invalid extension access syntax');
        }
      }; // allows a core instance to access extensions internally


      Core.prototype.extension = extension; // included extensions

      incExts.forEach(function (group) {
        group.extensions.forEach(function (ext) {
          setExtension(group.type, ext.name, ext.impl);
        });
      });

// (useful for init)

      const Stylesheet = function Stylesheet() {
        if (!(this instanceof Stylesheet)) {
          return new Stylesheet();
        }

        this.length = 0;
      };

      const sheetfn = Stylesheet.prototype;

      sheetfn.instanceString = function () {
        return 'stylesheet';
      }; // just store the selector to be parsed later


      sheetfn.selector = function (selector) {
        const i = this.length++;
        this[i] = {
          selector: selector,
          properties: []
        };
        return this; // chaining
      }; // just store the property to be parsed later


      sheetfn.css = function (name, value) {
        const i = this.length - 1;

        if (string(name)) {
          this[i].properties.push({
            name: name,
            value: value
          });
        } else if (plainObject(name)) {
          const map = name;
          const propNames = Object.keys(map);

          for (let j = 0; j < propNames.length; j++) {
            const key = propNames[j];
            const mapVal = map[key];

            if (mapVal == null) {
              continue;
            }

            const prop = Style.properties[key] || Style.properties[dash2camel(key)];

            if (prop == null) {
              continue;
            }

            const _name = prop.name;
            const _value = mapVal;
            this[i].properties.push({
              name: _name,
              value: _value
            });
          }
        }

        return this; // chaining
      };

      sheetfn.style = sheetfn.css; // generate a real style object from the dummy stylesheet

      sheetfn.generateStyle = function (cy) {
        const style = new Style(cy);
        return this.appendToStyle(style);
      }; // append a dummy stylesheet object on a real style object


      sheetfn.appendToStyle = function (style) {
        for (let i = 0; i < this.length; i++) {
          const context = this[i];
          const selector = context.selector;
          const props = context.properties;
          style.selector(selector); // apply selector

          for (let j = 0; j < props.length; j++) {
            const prop = props[j];
            style.css(prop.name, prop.value); // apply property
          }
        }

        return style;
      };

      const version = "3.18.1";

      const cytoscape = function cytoscape(options) {
  // if no options specified, use default
        if (options === undefined) {
          options = {};
        } // create instance


        if (plainObject(options)) {
          return new Core(options);
        } // allow for registration of extensions
        else if (string(options)) {
          return extension.apply(extension, arguments);
        }
      }; // e.g. cytoscape.use( require('cytoscape-foo'), bar )


      cytoscape.use = function (ext) {
        const args = Array.prototype.slice.call(arguments, 1); // args to pass to ext

        args.unshift(cytoscape); // cytoscape is first arg to ext

        ext.apply(null, args);
        return this;
      };

      cytoscape.warnings = function (bool) {
        return warnings(bool);
      }; // replaced by build system


      cytoscape.version = version; // expose public apis (mostly for extensions)

      cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;

      module.exports = cytoscape;


/***/ }),

/***/ "./node_modules/frontend-collective-react-dnd-scrollzone/lib/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/frontend-collective-react-dnd-scrollzone/lib/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";


      Object.defineProperty(exports, "__esModule", ({
        value: true
      }));
      exports.createHorizontalStrength = createHorizontalStrength;
      exports.createVerticalStrength = createVerticalStrength;
      exports.createScrollingComponent = createScrollingComponent;
      exports["default"] = createScrollingComponentWithConsumer;
      exports.defaultVerticalStrength = exports.defaultHorizontalStrength = void 0;

      const _react = _interopRequireWildcard(__webpack_require__(/*! react */ "react"));

      const _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

      const _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

      const _lodash = _interopRequireDefault(__webpack_require__(/*! lodash.throttle */ "./node_modules/lodash.throttle/index.js"));

      const _raf = _interopRequireDefault(__webpack_require__(/*! raf */ "./node_modules/raf/index.js"));

      const _reactDisplayName = _interopRequireDefault(__webpack_require__(/*! react-display-name */ "./node_modules/react-display-name/lib/getDisplayName.js"));

      const _reactDnd = __webpack_require__(/*! react-dnd */ "react-dnd");

      const _hoistNonReactStatics = _interopRequireDefault(__webpack_require__(/*! hoist-non-react-statics */ "./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"));

      const _util = __webpack_require__(/*! ./util */ "./node_modules/frontend-collective-react-dnd-scrollzone/lib/util.js");

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { const newObj = {}; if (obj != null) { for (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { const desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

      function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

      function _extends() { _extends = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

      function _objectWithoutProperties(source, excluded) { if (source == null) return {}; const target = _objectWithoutPropertiesLoose(source, excluded); let key, i; if (Object.getOwnPropertySymbols) { const sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

      function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; const target = {}; const sourceKeys = Object.keys(source); let key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

      function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

      function _defineProperties(target, props) { for (let i = 0; i < props.length; i++) { const descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

      function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

      function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

      function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

      function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

      function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

      function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

      function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

      const DEFAULT_BUFFER = 150;

      function createHorizontalStrength(_buffer) {
        return function defaultHorizontalStrength(_ref, point) {
          const x = _ref.x,
            w = _ref.w,
            y = _ref.y,
            h = _ref.h;
          const buffer = Math.min(w / 2, _buffer);
          const inRange = point.x >= x && point.x <= x + w;
          const inBox = inRange && point.y >= y && point.y <= y + h;

          if (inBox) {
            if (point.x < x + buffer) {
              return (point.x - x - buffer) / buffer;
            }

            if (point.x > x + w - buffer) {
              return -(x + w - point.x - buffer) / buffer;
            }
          }

          return 0;
        };
      }

      function createVerticalStrength(_buffer) {
        return function defaultVerticalStrength(_ref2, point) {
          const y = _ref2.y,
            h = _ref2.h,
            x = _ref2.x,
            w = _ref2.w;
          const buffer = Math.min(h / 2, _buffer);
          const inRange = point.y >= y && point.y <= y + h;
          const inBox = inRange && point.x >= x && point.x <= x + w;

          if (inBox) {
            if (point.y < y + buffer) {
              return (point.y - y - buffer) / buffer;
            }

            if (point.y > y + h - buffer) {
              return -(y + h - point.y - buffer) / buffer;
            }
          }

          return 0;
        };
      }

      const defaultHorizontalStrength = createHorizontalStrength(DEFAULT_BUFFER);
      exports.defaultHorizontalStrength = defaultHorizontalStrength;
      const defaultVerticalStrength = createVerticalStrength(DEFAULT_BUFFER);
      exports.defaultVerticalStrength = defaultVerticalStrength;

      function createScrollingComponent(WrappedComponent) {
        const ScrollingComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(ScrollingComponent, _Component);

    // Update scaleX and scaleY every 100ms or so
    // and start scrolling if necessary
    function ScrollingComponent(props, ctx) {
      let _this;

      _classCallCheck(this, ScrollingComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ScrollingComponent).call(this, props, ctx));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "updateScrolling", (0, _lodash.default)(function (evt) {
        const _this$container$getBo = _this.container.getBoundingClientRect(),
          x = _this$container$getBo.left,
          y = _this$container$getBo.top,
          w = _this$container$getBo.width,
          h = _this$container$getBo.height;

        const box = {
          x: x,
          y: y,
          w: w,
          h: h
        };
        const coords = (0, _util.getCoords)(evt); // calculate strength

        const _this$props = _this.props,
          horizontalStrength = _this$props.horizontalStrength,
          verticalStrength = _this$props.verticalStrength;
        _this.scaleX = horizontalStrength(box, coords);
        _this.scaleY = verticalStrength(box, coords); // start scrolling if we need to

        if (!_this.frame && (_this.scaleX || _this.scaleY)) {
          _this.startScrolling();
        }
      }, 100, {
        trailing: false
      }));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleEvent", function (evt) {
        if (_this.dragging && !_this.attached) {
          _this.attach();

          _this.updateScrolling(evt);
        }
      });

      _this.wrappedInstance = _react.default.createRef();
      _this.scaleX = 0;
      _this.scaleY = 0;
      _this.frame = null;
      _this.attached = false;
      _this.dragging = false;
      return _this;
    }

    _createClass(ScrollingComponent, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        const _this2 = this;

        // eslint-disable-next-line react/no-find-dom-node
        this.container = (0, _reactDom.findDOMNode)(this.wrappedInstance.current);

        if (this.container && typeof this.container.addEventListener === 'function') {
          this.container.addEventListener('dragover', this.handleEvent);
        } // touchmove events don't seem to work across siblings, so we unfortunately
        // have to attach the listeners to the body


        window.document.body.addEventListener('touchmove', this.handleEvent);
        const dragDropManager = this.props.dragDropManager;
        this.clearMonitorSubscription = dragDropManager.getMonitor().subscribeToStateChange(function () {
          return _this2.handleMonitorChange();
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.container && typeof this.container.removeEventListener === 'function') {
          this.container.removeEventListener('dragover', this.handleEvent);
        }

        window.document.body.removeEventListener('touchmove', this.handleEvent);
        this.clearMonitorSubscription();
        this.stopScrolling();
      }
    }, {
      key: "handleMonitorChange",
      value: function handleMonitorChange() {
        const dragDropManager = this.props.dragDropManager;
        const isDragging = dragDropManager.getMonitor().isDragging();

        if (!this.dragging && isDragging) {
          this.dragging = true;
        } else if (this.dragging && !isDragging) {
          this.dragging = false;
          this.stopScrolling();
        }
      }
    }, {
      key: "attach",
      value: function attach() {
        this.attached = true;
        window.document.body.addEventListener('dragover', this.updateScrolling);
        window.document.body.addEventListener('touchmove', this.updateScrolling);
      }
    }, {
      key: "detach",
      value: function detach() {
        this.attached = false;
        window.document.body.removeEventListener('dragover', this.updateScrolling);
        window.document.body.removeEventListener('touchmove', this.updateScrolling);
      }
    }, {
      key: "startScrolling",
      value: function startScrolling() {
        const _this3 = this;

        let i = 0;

        const tick = function tick() {
          const scaleX = _this3.scaleX,
            scaleY = _this3.scaleY,
            container = _this3.container;
          const _this3$props = _this3.props,
            strengthMultiplier = _this3$props.strengthMultiplier,
            onScrollChange = _this3$props.onScrollChange; // stop scrolling if there's nothing to do

          if (strengthMultiplier === 0 || scaleX + scaleY === 0) {
            _this3.stopScrolling();

            return;
          } // there's a bug in safari where it seems like we can't get
          // mousemove events from a container that also emits a scroll
          // event that same frame. So we double the strengthMultiplier and only adjust
          // the scroll position at 30fps


          i += 1;

          if (i % 2) {
            const scrollLeft = container.scrollLeft,
              scrollTop = container.scrollTop,
              scrollWidth = container.scrollWidth,
              scrollHeight = container.scrollHeight,
              clientWidth = container.clientWidth,
              clientHeight = container.clientHeight;
            const newLeft = scaleX ? container.scrollLeft = (0, _util.intBetween)(0, scrollWidth - clientWidth, scrollLeft + scaleX * strengthMultiplier) : scrollLeft;
            const newTop = scaleY ? container.scrollTop = (0, _util.intBetween)(0, scrollHeight - clientHeight, scrollTop + scaleY * strengthMultiplier) : scrollTop;
            onScrollChange(newLeft, newTop);
          }

          _this3.frame = (0, _raf.default)(tick);
        };

        tick();
      }
    }, {
      key: "stopScrolling",
      value: function stopScrolling() {
        this.detach();
        this.scaleX = 0;
        this.scaleY = 0;

        if (this.frame) {
          _raf.default.cancel(this.frame);

          this.frame = null;
        }
      }
    }, {
      key: "render",
      value: function render() {
        const _this$props2 = this.props,
          strengthMultiplier = _this$props2.strengthMultiplier,
          verticalStrength = _this$props2.verticalStrength,
          horizontalStrength = _this$props2.horizontalStrength,
          onScrollChange = _this$props2.onScrollChange,
          props = _objectWithoutProperties(_this$props2, ["strengthMultiplier", "verticalStrength", "horizontalStrength", "onScrollChange"]);

        return _react.default.createElement(WrappedComponent, _extends({
          ref: this.wrappedInstance
        }, props));
      }
    }]);

    return ScrollingComponent;
  }(_react.Component);

        _defineProperty(ScrollingComponent, "displayName", "Scrolling(".concat((0, _reactDisplayName.default)(WrappedComponent), ")"));

        _defineProperty(ScrollingComponent, "propTypes", {
    // eslint-disable-next-line react/forbid-prop-types
          dragDropManager: _propTypes.default.object.isRequired,
          onScrollChange: _propTypes.default.func,
          verticalStrength: _propTypes.default.func,
          horizontalStrength: _propTypes.default.func,
          strengthMultiplier: _propTypes.default.number
        });

        _defineProperty(ScrollingComponent, "defaultProps", {
          onScrollChange: _util.noop,
          verticalStrength: defaultVerticalStrength,
          horizontalStrength: defaultHorizontalStrength,
          strengthMultiplier: 30
        });

        return (0, _hoistNonReactStatics.default)(ScrollingComponent, WrappedComponent);
      }

      function createScrollingComponentWithConsumer(WrappedComponent) {
        const ScrollingComponent = createScrollingComponent(WrappedComponent);
        return function (props) {
          return _react.default.createElement(_reactDnd.DragDropContextConsumer, null, function (_ref3) {
            const dragDropManager = _ref3.dragDropManager;
            return dragDropManager === undefined ? null : _react.default.createElement(ScrollingComponent, _extends({}, props, {
              dragDropManager: dragDropManager
            }));
          });
        };
      }

/***/ }),

/***/ "./node_modules/frontend-collective-react-dnd-scrollzone/lib/util.js":
/*!***************************************************************************!*\
  !*** ./node_modules/frontend-collective-react-dnd-scrollzone/lib/util.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";


      Object.defineProperty(exports, "__esModule", ({
        value: true
      }));
      exports.noop = noop;
      exports.intBetween = intBetween;
      exports.getCoords = getCoords;

      function noop() {}

      function intBetween(min, max, val) {
        return Math.floor(Math.min(max, Math.max(min, val)));
      }

      function getCoords(evt) {
        if (evt.type === 'touchmove') {
          return {
            x: evt.changedTouches[0].clientX,
            y: evt.changedTouches[0].clientY
          };
        }

        return {
          x: evt.clientX,
          y: evt.clientY
        };
      }

/***/ }),

/***/ "./node_modules/heap/index.js":
/*!************************************!*\
  !*** ./node_modules/heap/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      module.exports = __webpack_require__(/*! ./lib/heap */ "./node_modules/heap/lib/heap.js");


/***/ }),

/***/ "./node_modules/heap/lib/heap.js":
/*!***************************************!*\
  !*** ./node_modules/heap/lib/heap.js ***!
  \***************************************/
/***/ (function(module, exports) {

      let __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.8.0
      (function() {
        let Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

        floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

        defaultCmp = function(x, y) {
          if (x < y) {
            return -1;
          }
          if (x > y) {
            return 1;
          }
          return 0;
        };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

        insort = function(a, x, lo, hi, cmp) {
          let mid;
          if (lo == null) {
            lo = 0;
          }
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (lo < 0) {
            throw new Error('lo must be non-negative');
          }
          if (hi == null) {
            hi = a.length;
          }
          while (lo < hi) {
            mid = floor((lo + hi) / 2);
            if (cmp(x, a[mid]) < 0) {
              hi = mid;
            } else {
              lo = mid + 1;
            }
          }
          return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
        };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

        heappush = function(array, item, cmp) {
          if (cmp == null) {
            cmp = defaultCmp;
          }
          array.push(item);
          return _siftdown(array, 0, array.length - 1, cmp);
        };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

        heappop = function(array, cmp) {
          let lastelt, returnitem;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          lastelt = array.pop();
          if (array.length) {
            returnitem = array[0];
            array[0] = lastelt;
            _siftup(array, 0, cmp);
          } else {
            returnitem = lastelt;
          }
          return returnitem;
        };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

        heapreplace = function(array, item, cmp) {
          let returnitem;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          returnitem = array[0];
          array[0] = item;
          _siftup(array, 0, cmp);
          return returnitem;
        };


  /*
  Fast version of a heappush followed by a heappop.
   */

        heappushpop = function(array, item, cmp) {
          let _ref;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (array.length && cmp(array[0], item) < 0) {
            _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
            _siftup(array, 0, cmp);
          }
          return item;
        };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

        heapify = function(array, cmp) {
          let i, _i, _j, _len, _ref, _ref1, _results, _results1;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          _ref1 = (function() {
            _results1 = [];
            for (let _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
            return _results1;
          }).apply(this).reverse();
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            i = _ref1[_i];
            _results.push(_siftup(array, i, cmp));
          }
          return _results;
        };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

        updateItem = function(array, item, cmp) {
          let pos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          pos = array.indexOf(item);
          if (pos === -1) {
            return;
          }
          _siftdown(array, 0, pos, cmp);
          return _siftup(array, pos, cmp);
        };


  /*
  Find the n largest elements in a dataset.
   */

        nlargest = function(array, n, cmp) {
          let elem, result, _i, _len, _ref;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          result = array.slice(0, n);
          if (!result.length) {
            return result;
          }
          heapify(result, cmp);
          _ref = array.slice(n);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            elem = _ref[_i];
            heappushpop(result, elem, cmp);
          }
          return result.sort(cmp).reverse();
        };


  /*
  Find the n smallest elements in a dataset.
   */

        nsmallest = function(array, n, cmp) {
          let elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (n * 10 <= array.length) {
            result = array.slice(0, n).sort(cmp);
            if (!result.length) {
              return result;
            }
            los = result[result.length - 1];
            _ref = array.slice(n);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              elem = _ref[_i];
              if (cmp(elem, los) < 0) {
                insort(result, elem, 0, null, cmp);
                result.pop();
                los = result[result.length - 1];
              }
            }
            return result;
          }
          heapify(array, cmp);
          _results = [];
          for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            _results.push(heappop(array, cmp));
          }
          return _results;
        };

        _siftdown = function(array, startpos, pos, cmp) {
          let newitem, parent, parentpos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          newitem = array[pos];
          while (pos > startpos) {
            parentpos = (pos - 1) >> 1;
            parent = array[parentpos];
            if (cmp(newitem, parent) < 0) {
              array[pos] = parent;
              pos = parentpos;
              continue;
            }
            break;
          }
          return array[pos] = newitem;
        };

        _siftup = function(array, pos, cmp) {
          let childpos, endpos, newitem, rightpos, startpos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          endpos = array.length;
          startpos = pos;
          newitem = array[pos];
          childpos = 2 * pos + 1;
          while (childpos < endpos) {
            rightpos = childpos + 1;
            if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
              childpos = rightpos;
            }
            array[pos] = array[childpos];
            pos = childpos;
            childpos = 2 * pos + 1;
          }
          array[pos] = newitem;
          return _siftdown(array, startpos, pos, cmp);
        };

        Heap = (function() {
          Heap.push = heappush;

          Heap.pop = heappop;

          Heap.replace = heapreplace;

          Heap.pushpop = heappushpop;

          Heap.heapify = heapify;

          Heap.updateItem = updateItem;

          Heap.nlargest = nlargest;

          Heap.nsmallest = nsmallest;

          function Heap(cmp) {
            this.cmp = cmp != null ? cmp : defaultCmp;
            this.nodes = [];
          }

          Heap.prototype.push = function(x) {
            return heappush(this.nodes, x, this.cmp);
          };

          Heap.prototype.pop = function() {
            return heappop(this.nodes, this.cmp);
          };

          Heap.prototype.peek = function() {
            return this.nodes[0];
          };

          Heap.prototype.contains = function(x) {
            return this.nodes.indexOf(x) !== -1;
          };

          Heap.prototype.replace = function(x) {
            return heapreplace(this.nodes, x, this.cmp);
          };

          Heap.prototype.pushpop = function(x) {
            return heappushpop(this.nodes, x, this.cmp);
          };

          Heap.prototype.heapify = function() {
            return heapify(this.nodes, this.cmp);
          };

          Heap.prototype.updateItem = function(x) {
            return updateItem(this.nodes, x, this.cmp);
          };

          Heap.prototype.clear = function() {
            return this.nodes = [];
          };

          Heap.prototype.empty = function() {
            return this.nodes.length === 0;
          };

          Heap.prototype.size = function() {
            return this.nodes.length;
          };

          Heap.prototype.clone = function() {
            let heap;
            heap = new Heap();
            heap.nodes = this.nodes.slice(0);
            return heap;
          };

          Heap.prototype.toArray = function() {
            return this.nodes.slice(0);
          };

          Heap.prototype.insert = Heap.prototype.push;

          Heap.prototype.top = Heap.prototype.peek;

          Heap.prototype.front = Heap.prototype.peek;

          Heap.prototype.has = Heap.prototype.contains;

          Heap.prototype.copy = Heap.prototype.clone;

          return Heap;

        })();

        (function(root, factory) {
          if (true) {
            return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
            __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
              (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else {}
        })(this, function() {
          return Heap;
        });

      }).call(this);


/***/ }),

/***/ "./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const reactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
      const REACT_STATICS = {
        childContextTypes: true,
        contextType: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromError: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
      };
      const KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
      };
      const FORWARD_REF_STATICS = {
        '$$typeof': true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
      };
      const MEMO_STATICS = {
        '$$typeof': true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
      };
      const TYPE_STATICS = {};
      TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
      TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

      function getStatics(component) {
  // React v16.11 and below
        if (reactIs.isMemo(component)) {
          return MEMO_STATICS;
        } // React v16.12 and above


        return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
      }

      const defineProperty = Object.defineProperty;
      const getOwnPropertyNames = Object.getOwnPropertyNames;
      const getOwnPropertySymbols = Object.getOwnPropertySymbols;
      const getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      const getPrototypeOf = Object.getPrototypeOf;
      const objectPrototype = Object.prototype;
      function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
          if (objectPrototype) {
            const inheritedComponent = getPrototypeOf(sourceComponent);

            if (inheritedComponent && inheritedComponent !== objectPrototype) {
              hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
          }

          let keys = getOwnPropertyNames(sourceComponent);

          if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
          }

          const targetStatics = getStatics(targetComponent);
          const sourceStatics = getStatics(sourceComponent);

          for (let i = 0; i < keys.length; ++i) {
            const key = keys[i];

            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
              const descriptor = getOwnPropertyDescriptor(sourceComponent, key);

              try {
          // Avoid failures from read-only properties
                defineProperty(targetComponent, key, descriptor);
              } catch (e) {}
            }
          }
        }

        return targetComponent;
      }

      module.exports = hoistNonReactStatics;


/***/ }),

/***/ "./node_modules/layout-base/layout-base.js":
/*!*************************************************!*\
  !*** ./node_modules/layout-base/layout-base.js ***!
  \*************************************************/
/***/ (function(module) {

      (function webpackUniversalModuleDefinition(root, factory) {
        if(true)
          module.exports = factory();
        else {}
      })(this, function() {
        return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	const installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_543__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		const module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_543__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_543__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_543__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__nested_webpack_require_543__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_543__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_543__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_543__.n = function(module) {
/******/ 		const getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_543__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_543__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_543__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_543__(__nested_webpack_require_543__.s = 26);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

            "use strict";


            function LayoutConstants() {}

/**
 * Layout Quality: 0:draft, 1:default, 2:proof
 */
            LayoutConstants.QUALITY = 1;

/**
 * Default parameters
 */
            LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;
            LayoutConstants.DEFAULT_INCREMENTAL = false;
            LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;
            LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;
            LayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;
            LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;

// -----------------------------------------------------------------------------
// Section: General other constants
// -----------------------------------------------------------------------------
/*
 * Margins of a graph to be applied on bouding rectangle of its contents. We
 * assume margins on all four sides to be uniform.
 */
            LayoutConstants.DEFAULT_GRAPH_MARGIN = 15;

/*
 * Whether to consider labels in node dimensions or not
 */
            LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;

/*
 * Default dimension of a non-compound node.
 */
            LayoutConstants.SIMPLE_NODE_SIZE = 40;

/*
 * Default dimension of a non-compound node.
 */
            LayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;

/*
 * Empty compound node size. When a compound node is empty, its both
 * dimensions should be of this value.
 */
            LayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;

/*
 * Minimum length that an edge should take during layout
 */
            LayoutConstants.MIN_EDGE_LENGTH = 1;

/*
 * World boundaries that layout operates on
 */
            LayoutConstants.WORLD_BOUNDARY = 1000000;

/*
 * World boundaries that random positioning can be performed with
 */
            LayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;

/*
 * Coordinates of the world center
 */
            LayoutConstants.WORLD_CENTER_X = 1200;
            LayoutConstants.WORLD_CENTER_Y = 900;

            module.exports = LayoutConstants;

/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_4947__) {

            "use strict";


            const LGraphObject = __nested_webpack_require_4947__(2);
            const IGeometry = __nested_webpack_require_4947__(8);
            const IMath = __nested_webpack_require_4947__(9);

            function LEdge(source, target, vEdge) {
              LGraphObject.call(this, vEdge);

              this.isOverlapingSourceAndTarget = false;
              this.vGraphObject = vEdge;
              this.bendpoints = [];
              this.source = source;
              this.target = target;
            }

            LEdge.prototype = Object.create(LGraphObject.prototype);

            for (const prop in LGraphObject) {
              LEdge[prop] = LGraphObject[prop];
            }

            LEdge.prototype.getSource = function () {
              return this.source;
            };

            LEdge.prototype.getTarget = function () {
              return this.target;
            };

            LEdge.prototype.isInterGraph = function () {
              return this.isInterGraph;
            };

            LEdge.prototype.getLength = function () {
              return this.length;
            };

            LEdge.prototype.isOverlapingSourceAndTarget = function () {
              return this.isOverlapingSourceAndTarget;
            };

            LEdge.prototype.getBendpoints = function () {
              return this.bendpoints;
            };

            LEdge.prototype.getLca = function () {
              return this.lca;
            };

            LEdge.prototype.getSourceInLca = function () {
              return this.sourceInLca;
            };

            LEdge.prototype.getTargetInLca = function () {
              return this.targetInLca;
            };

            LEdge.prototype.getOtherEnd = function (node) {
              if (this.source === node) {
                return this.target;
              } else if (this.target === node) {
                return this.source;
              } else {
                throw "Node is not incident with this edge";
              }
            };

            LEdge.prototype.getOtherEndInGraph = function (node, graph) {
              let otherEnd = this.getOtherEnd(node);
              const root = graph.getGraphManager().getRoot();

              while (true) {
                if (otherEnd.getOwner() == graph) {
                  return otherEnd;
                }

                if (otherEnd.getOwner() == root) {
                  break;
                }

                otherEnd = otherEnd.getOwner().getParent();
              }

              return null;
            };

            LEdge.prototype.updateLength = function () {
              const clipPointCoordinates = new Array(4);

              this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);

              if (!this.isOverlapingSourceAndTarget) {
                this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];
                this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];

                if (Math.abs(this.lengthX) < 1.0) {
                  this.lengthX = IMath.sign(this.lengthX);
                }

                if (Math.abs(this.lengthY) < 1.0) {
                  this.lengthY = IMath.sign(this.lengthY);
                }

                this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);
              }
            };

            LEdge.prototype.updateLengthSimple = function () {
              this.lengthX = this.target.getCenterX() - this.source.getCenterX();
              this.lengthY = this.target.getCenterY() - this.source.getCenterY();

              if (Math.abs(this.lengthX) < 1.0) {
                this.lengthX = IMath.sign(this.lengthX);
              }

              if (Math.abs(this.lengthY) < 1.0) {
                this.lengthY = IMath.sign(this.lengthY);
              }

              this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);
            };

            module.exports = LEdge;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

            "use strict";


            function LGraphObject(vGraphObject) {
              this.vGraphObject = vGraphObject;
            }

            module.exports = LGraphObject;

/***/ }),
/* 3 */
/***/ (function(module, exports, __nested_webpack_require_8167__) {

            "use strict";


            const LGraphObject = __nested_webpack_require_8167__(2);
            const Integer = __nested_webpack_require_8167__(10);
            const RectangleD = __nested_webpack_require_8167__(13);
            const LayoutConstants = __nested_webpack_require_8167__(0);
            const RandomSeed = __nested_webpack_require_8167__(16);
            const PointD = __nested_webpack_require_8167__(4);

            function LNode(gm, loc, size, vNode) {
  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)
              if (size == null && vNode == null) {
                vNode = loc;
              }

              LGraphObject.call(this, vNode);

  //Alternative constructor 2 : LNode(Layout layout, Object vNode)
              if (gm.graphManager != null) gm = gm.graphManager;

              this.estimatedSize = Integer.MIN_VALUE;
              this.inclusionTreeDepth = Integer.MAX_VALUE;
              this.vGraphObject = vNode;
              this.edges = [];
              this.graphManager = gm;

              if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();
            }

            LNode.prototype = Object.create(LGraphObject.prototype);
            for (const prop in LGraphObject) {
              LNode[prop] = LGraphObject[prop];
            }

            LNode.prototype.getEdges = function () {
              return this.edges;
            };

            LNode.prototype.getChild = function () {
              return this.child;
            };

            LNode.prototype.getOwner = function () {
  //  if (this.owner != null) {
  //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {
  //      throw "assert failed";
  //    }
  //  }

              return this.owner;
            };

            LNode.prototype.getWidth = function () {
              return this.rect.width;
            };

            LNode.prototype.setWidth = function (width) {
              this.rect.width = width;
            };

            LNode.prototype.getHeight = function () {
              return this.rect.height;
            };

            LNode.prototype.setHeight = function (height) {
              this.rect.height = height;
            };

            LNode.prototype.getCenterX = function () {
              return this.rect.x + this.rect.width / 2;
            };

            LNode.prototype.getCenterY = function () {
              return this.rect.y + this.rect.height / 2;
            };

            LNode.prototype.getCenter = function () {
              return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);
            };

            LNode.prototype.getLocation = function () {
              return new PointD(this.rect.x, this.rect.y);
            };

            LNode.prototype.getRect = function () {
              return this.rect;
            };

            LNode.prototype.getDiagonal = function () {
              return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);
            };

/**
 * This method returns half the diagonal length of this node.
 */
            LNode.prototype.getHalfTheDiagonal = function () {
              return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;
            };

            LNode.prototype.setRect = function (upperLeft, dimension) {
              this.rect.x = upperLeft.x;
              this.rect.y = upperLeft.y;
              this.rect.width = dimension.width;
              this.rect.height = dimension.height;
            };

            LNode.prototype.setCenter = function (cx, cy) {
              this.rect.x = cx - this.rect.width / 2;
              this.rect.y = cy - this.rect.height / 2;
            };

            LNode.prototype.setLocation = function (x, y) {
              this.rect.x = x;
              this.rect.y = y;
            };

            LNode.prototype.moveBy = function (dx, dy) {
              this.rect.x += dx;
              this.rect.y += dy;
            };

            LNode.prototype.getEdgeListToNode = function (to) {
              const edgeList = [];
              let edge;
              const self = this;

              self.edges.forEach(function (edge) {

                if (edge.target == to) {
                  if (edge.source != self) throw "Incorrect edge source!";

                  edgeList.push(edge);
                }
              });

              return edgeList;
            };

            LNode.prototype.getEdgesBetween = function (other) {
              const edgeList = [];
              let edge;

              const self = this;
              self.edges.forEach(function (edge) {

                if (!(edge.source == self || edge.target == self)) throw "Incorrect edge source and/or target";

                if (edge.target == other || edge.source == other) {
                  edgeList.push(edge);
                }
              });

              return edgeList;
            };

            LNode.prototype.getNeighborsList = function () {
              const neighbors = new Set();

              const self = this;
              self.edges.forEach(function (edge) {

                if (edge.source == self) {
                  neighbors.add(edge.target);
                } else {
                  if (edge.target != self) {
                    throw "Incorrect incidency!";
                  }

                  neighbors.add(edge.source);
                }
              });

              return neighbors;
            };

            LNode.prototype.withChildren = function () {
              const withNeighborsList = new Set();
              let childNode;
              let children;

              withNeighborsList.add(this);

              if (this.child != null) {
                const nodes = this.child.getNodes();
                for (let i = 0; i < nodes.length; i++) {
                  childNode = nodes[i];
                  children = childNode.withChildren();
                  children.forEach(function (node) {
                    withNeighborsList.add(node);
                  });
                }
              }

              return withNeighborsList;
            };

            LNode.prototype.getNoOfChildren = function () {
              let noOfChildren = 0;
              let childNode;

              if (this.child == null) {
                noOfChildren = 1;
              } else {
                const nodes = this.child.getNodes();
                for (let i = 0; i < nodes.length; i++) {
                  childNode = nodes[i];

                  noOfChildren += childNode.getNoOfChildren();
                }
              }

              if (noOfChildren == 0) {
                noOfChildren = 1;
              }
              return noOfChildren;
            };

            LNode.prototype.getEstimatedSize = function () {
              if (this.estimatedSize == Integer.MIN_VALUE) {
                throw "assert failed";
              }
              return this.estimatedSize;
            };

            LNode.prototype.calcEstimatedSize = function () {
              if (this.child == null) {
                return this.estimatedSize = (this.rect.width + this.rect.height) / 2;
              } else {
                this.estimatedSize = this.child.calcEstimatedSize();
                this.rect.width = this.estimatedSize;
                this.rect.height = this.estimatedSize;

                return this.estimatedSize;
              }
            };

            LNode.prototype.scatter = function () {
              let randomCenterX;
              let randomCenterY;

              const minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;
              const maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;
              randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;

              const minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;
              const maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;
              randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;

              this.rect.x = randomCenterX;
              this.rect.y = randomCenterY;
            };

            LNode.prototype.updateBounds = function () {
              if (this.getChild() == null) {
                throw "assert failed";
              }
              if (this.getChild().getNodes().length != 0) {
    // wrap the children nodes by re-arranging the boundaries
                const childGraph = this.getChild();
                childGraph.updateBounds(true);

                this.rect.x = childGraph.getLeft();
                this.rect.y = childGraph.getTop();

                this.setWidth(childGraph.getRight() - childGraph.getLeft());
                this.setHeight(childGraph.getBottom() - childGraph.getTop());

    // Update compound bounds considering its label properties    
                if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {

                  const width = childGraph.getRight() - childGraph.getLeft();
                  const height = childGraph.getBottom() - childGraph.getTop();

                  if (this.labelWidth > width) {
                    this.rect.x -= (this.labelWidth - width) / 2;
                    this.setWidth(this.labelWidth);
                  }

                  if (this.labelHeight > height) {
                    if (this.labelPos == "center") {
                      this.rect.y -= (this.labelHeight - height) / 2;
                    } else if (this.labelPos == "top") {
                      this.rect.y -= this.labelHeight - height;
                    }
                    this.setHeight(this.labelHeight);
                  }
                }
              }
            };

            LNode.prototype.getInclusionTreeDepth = function () {
              if (this.inclusionTreeDepth == Integer.MAX_VALUE) {
                throw "assert failed";
              }
              return this.inclusionTreeDepth;
            };

            LNode.prototype.transform = function (trans) {
              let left = this.rect.x;

              if (left > LayoutConstants.WORLD_BOUNDARY) {
                left = LayoutConstants.WORLD_BOUNDARY;
              } else if (left < -LayoutConstants.WORLD_BOUNDARY) {
                left = -LayoutConstants.WORLD_BOUNDARY;
              }

              let top = this.rect.y;

              if (top > LayoutConstants.WORLD_BOUNDARY) {
                top = LayoutConstants.WORLD_BOUNDARY;
              } else if (top < -LayoutConstants.WORLD_BOUNDARY) {
                top = -LayoutConstants.WORLD_BOUNDARY;
              }

              const leftTop = new PointD(left, top);
              const vLeftTop = trans.inverseTransformPoint(leftTop);

              this.setLocation(vLeftTop.x, vLeftTop.y);
            };

            LNode.prototype.getLeft = function () {
              return this.rect.x;
            };

            LNode.prototype.getRight = function () {
              return this.rect.x + this.rect.width;
            };

            LNode.prototype.getTop = function () {
              return this.rect.y;
            };

            LNode.prototype.getBottom = function () {
              return this.rect.y + this.rect.height;
            };

            LNode.prototype.getParent = function () {
              if (this.owner == null) {
                return null;
              }

              return this.owner.getParent();
            };

            module.exports = LNode;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

            "use strict";


            function PointD(x, y) {
              if (x == null && y == null) {
                this.x = 0;
                this.y = 0;
              } else {
                this.x = x;
                this.y = y;
              }
            }

            PointD.prototype.getX = function () {
              return this.x;
            };

            PointD.prototype.getY = function () {
              return this.y;
            };

            PointD.prototype.setX = function (x) {
              this.x = x;
            };

            PointD.prototype.setY = function (y) {
              this.y = y;
            };

            PointD.prototype.getDifference = function (pt) {
              return new DimensionD(this.x - pt.x, this.y - pt.y);
            };

            PointD.prototype.getCopy = function () {
              return new PointD(this.x, this.y);
            };

            PointD.prototype.translate = function (dim) {
              this.x += dim.width;
              this.y += dim.height;
              return this;
            };

            module.exports = PointD;

/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_17549__) {

            "use strict";


            const LGraphObject = __nested_webpack_require_17549__(2);
            const Integer = __nested_webpack_require_17549__(10);
            const LayoutConstants = __nested_webpack_require_17549__(0);
            const LGraphManager = __nested_webpack_require_17549__(6);
            const LNode = __nested_webpack_require_17549__(3);
            const LEdge = __nested_webpack_require_17549__(1);
            const RectangleD = __nested_webpack_require_17549__(13);
            const Point = __nested_webpack_require_17549__(12);
            const LinkedList = __nested_webpack_require_17549__(11);

            function LGraph(parent, obj2, vGraph) {
              LGraphObject.call(this, vGraph);
              this.estimatedSize = Integer.MIN_VALUE;
              this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;
              this.edges = [];
              this.nodes = [];
              this.isConnected = false;
              this.parent = parent;

              if (obj2 != null && obj2 instanceof LGraphManager) {
                this.graphManager = obj2;
              } else if (obj2 != null && obj2 instanceof Layout) {
                this.graphManager = obj2.graphManager;
              }
            }

            LGraph.prototype = Object.create(LGraphObject.prototype);
            for (const prop in LGraphObject) {
              LGraph[prop] = LGraphObject[prop];
            }

            LGraph.prototype.getNodes = function () {
              return this.nodes;
            };

            LGraph.prototype.getEdges = function () {
              return this.edges;
            };

            LGraph.prototype.getGraphManager = function () {
              return this.graphManager;
            };

            LGraph.prototype.getParent = function () {
              return this.parent;
            };

            LGraph.prototype.getLeft = function () {
              return this.left;
            };

            LGraph.prototype.getRight = function () {
              return this.right;
            };

            LGraph.prototype.getTop = function () {
              return this.top;
            };

            LGraph.prototype.getBottom = function () {
              return this.bottom;
            };

            LGraph.prototype.isConnected = function () {
              return this.isConnected;
            };

            LGraph.prototype.add = function (obj1, sourceNode, targetNode) {
              if (sourceNode == null && targetNode == null) {
                const newNode = obj1;
                if (this.graphManager == null) {
                  throw "Graph has no graph mgr!";
                }
                if (this.getNodes().indexOf(newNode) > -1) {
                  throw "Node already in graph!";
                }
                newNode.owner = this;
                this.getNodes().push(newNode);

                return newNode;
              } else {
                const newEdge = obj1;
                if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {
                  throw "Source or target not in graph!";
                }

                if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {
                  throw "Both owners must be this graph!";
                }

                if (sourceNode.owner != targetNode.owner) {
                  return null;
                }

    // set source and target
                newEdge.source = sourceNode;
                newEdge.target = targetNode;

    // set as intra-graph edge
                newEdge.isInterGraph = false;

    // add to graph edge list
                this.getEdges().push(newEdge);

    // add to incidency lists
                sourceNode.edges.push(newEdge);

                if (targetNode != sourceNode) {
                  targetNode.edges.push(newEdge);
                }

                return newEdge;
              }
            };

            LGraph.prototype.remove = function (obj) {
              const node = obj;
              if (obj instanceof LNode) {
                if (node == null) {
                  throw "Node is null!";
                }
                if (!(node.owner != null && node.owner == this)) {
                  throw "Owner graph is invalid!";
                }
                if (this.graphManager == null) {
                  throw "Owner graph manager is invalid!";
                }
    // remove incident edges first (make a copy to do it safely)
                const edgesToBeRemoved = node.edges.slice();
                var edge;
                const s = edgesToBeRemoved.length;
                for (let i = 0; i < s; i++) {
                  edge = edgesToBeRemoved[i];

                  if (edge.isInterGraph) {
                    this.graphManager.remove(edge);
                  } else {
                    edge.source.owner.remove(edge);
                  }
                }

    // now the node itself
                var index = this.nodes.indexOf(node);
                if (index == -1) {
                  throw "Node not in owner node list!";
                }

                this.nodes.splice(index, 1);
              } else if (obj instanceof LEdge) {
                var edge = obj;
                if (edge == null) {
                  throw "Edge is null!";
                }
                if (!(edge.source != null && edge.target != null)) {
                  throw "Source and/or target is null!";
                }
                if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {
                  throw "Source and/or target owner is invalid!";
                }

                const sourceIndex = edge.source.edges.indexOf(edge);
                const targetIndex = edge.target.edges.indexOf(edge);
                if (!(sourceIndex > -1 && targetIndex > -1)) {
                  throw "Source and/or target doesn't know this edge!";
                }

                edge.source.edges.splice(sourceIndex, 1);

                if (edge.target != edge.source) {
                  edge.target.edges.splice(targetIndex, 1);
                }

                var index = edge.source.owner.getEdges().indexOf(edge);
                if (index == -1) {
                  throw "Not in owner's edge list!";
                }

                edge.source.owner.getEdges().splice(index, 1);
              }
            };

            LGraph.prototype.updateLeftTop = function () {
              let top = Integer.MAX_VALUE;
              let left = Integer.MAX_VALUE;
              let nodeTop;
              let nodeLeft;
              let margin;

              const nodes = this.getNodes();
              const s = nodes.length;

              for (let i = 0; i < s; i++) {
                const lNode = nodes[i];
                nodeTop = lNode.getTop();
                nodeLeft = lNode.getLeft();

                if (top > nodeTop) {
                  top = nodeTop;
                }

                if (left > nodeLeft) {
                  left = nodeLeft;
                }
              }

  // Do we have any nodes in this graph?
              if (top == Integer.MAX_VALUE) {
                return null;
              }

              if (nodes[0].getParent().paddingLeft != undefined) {
                margin = nodes[0].getParent().paddingLeft;
              } else {
                margin = this.margin;
              }

              this.left = left - margin;
              this.top = top - margin;

  // Apply the margins and return the result
              return new Point(this.left, this.top);
            };

            LGraph.prototype.updateBounds = function (recursive) {
  // calculate bounds
              let left = Integer.MAX_VALUE;
              let right = -Integer.MAX_VALUE;
              let top = Integer.MAX_VALUE;
              let bottom = -Integer.MAX_VALUE;
              let nodeLeft;
              let nodeRight;
              let nodeTop;
              let nodeBottom;
              let margin;

              const nodes = this.nodes;
              const s = nodes.length;
              for (let i = 0; i < s; i++) {
                const lNode = nodes[i];

                if (recursive && lNode.child != null) {
                  lNode.updateBounds();
                }
                nodeLeft = lNode.getLeft();
                nodeRight = lNode.getRight();
                nodeTop = lNode.getTop();
                nodeBottom = lNode.getBottom();

                if (left > nodeLeft) {
                  left = nodeLeft;
                }

                if (right < nodeRight) {
                  right = nodeRight;
                }

                if (top > nodeTop) {
                  top = nodeTop;
                }

                if (bottom < nodeBottom) {
                  bottom = nodeBottom;
                }
              }

              const boundingRect = new RectangleD(left, top, right - left, bottom - top);
              if (left == Integer.MAX_VALUE) {
                this.left = this.parent.getLeft();
                this.right = this.parent.getRight();
                this.top = this.parent.getTop();
                this.bottom = this.parent.getBottom();
              }

              if (nodes[0].getParent().paddingLeft != undefined) {
                margin = nodes[0].getParent().paddingLeft;
              } else {
                margin = this.margin;
              }

              this.left = boundingRect.x - margin;
              this.right = boundingRect.x + boundingRect.width + margin;
              this.top = boundingRect.y - margin;
              this.bottom = boundingRect.y + boundingRect.height + margin;
            };

            LGraph.calculateBounds = function (nodes) {
              let left = Integer.MAX_VALUE;
              let right = -Integer.MAX_VALUE;
              let top = Integer.MAX_VALUE;
              let bottom = -Integer.MAX_VALUE;
              let nodeLeft;
              let nodeRight;
              let nodeTop;
              let nodeBottom;

              const s = nodes.length;

              for (let i = 0; i < s; i++) {
                const lNode = nodes[i];
                nodeLeft = lNode.getLeft();
                nodeRight = lNode.getRight();
                nodeTop = lNode.getTop();
                nodeBottom = lNode.getBottom();

                if (left > nodeLeft) {
                  left = nodeLeft;
                }

                if (right < nodeRight) {
                  right = nodeRight;
                }

                if (top > nodeTop) {
                  top = nodeTop;
                }

                if (bottom < nodeBottom) {
                  bottom = nodeBottom;
                }
              }

              const boundingRect = new RectangleD(left, top, right - left, bottom - top);

              return boundingRect;
            };

            LGraph.prototype.getInclusionTreeDepth = function () {
              if (this == this.graphManager.getRoot()) {
                return 1;
              } else {
                return this.parent.getInclusionTreeDepth();
              }
            };

            LGraph.prototype.getEstimatedSize = function () {
              if (this.estimatedSize == Integer.MIN_VALUE) {
                throw "assert failed";
              }
              return this.estimatedSize;
            };

            LGraph.prototype.calcEstimatedSize = function () {
              let size = 0;
              const nodes = this.nodes;
              const s = nodes.length;

              for (let i = 0; i < s; i++) {
                const lNode = nodes[i];
                size += lNode.calcEstimatedSize();
              }

              if (size == 0) {
                this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;
              } else {
                this.estimatedSize = size / Math.sqrt(this.nodes.length);
              }

              return this.estimatedSize;
            };

            LGraph.prototype.updateConnected = function () {
              const self = this;
              if (this.nodes.length == 0) {
                this.isConnected = true;
                return;
              }

              const queue = new LinkedList();
              const visited = new Set();
              let currentNode = this.nodes[0];
              let neighborEdges;
              let currentNeighbor;
              const childrenOfNode = currentNode.withChildren();
              childrenOfNode.forEach(function (node) {
                queue.push(node);
                visited.add(node);
              });

              while (queue.length !== 0) {
                currentNode = queue.shift();

    // Traverse all neighbors of this node
                neighborEdges = currentNode.getEdges();
                const size = neighborEdges.length;
                for (let i = 0; i < size; i++) {
                  const neighborEdge = neighborEdges[i];
                  currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);

      // Add unvisited neighbors to the list to visit
                  if (currentNeighbor != null && !visited.has(currentNeighbor)) {
                    const childrenOfNeighbor = currentNeighbor.withChildren();

                    childrenOfNeighbor.forEach(function (node) {
                      queue.push(node);
                      visited.add(node);
                    });
                  }
                }
              }

              this.isConnected = false;

              if (visited.size >= this.nodes.length) {
                let noOfVisitedInThisGraph = 0;

                visited.forEach(function (visitedNode) {
                  if (visitedNode.owner == self) {
                    noOfVisitedInThisGraph++;
                  }
                });

                if (noOfVisitedInThisGraph == this.nodes.length) {
                  this.isConnected = true;
                }
              }
            };

            module.exports = LGraph;

/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_27617__) {

            "use strict";


            let LGraph;
            const LEdge = __nested_webpack_require_27617__(1);

            function LGraphManager(layout) {
              LGraph = __nested_webpack_require_27617__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.
              this.layout = layout;

              this.graphs = [];
              this.edges = [];
            }

            LGraphManager.prototype.addRoot = function () {
              const ngraph = this.layout.newGraph();
              const nnode = this.layout.newNode(null);
              const root = this.add(ngraph, nnode);
              this.setRootGraph(root);
              return this.rootGraph;
            };

            LGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {
  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge
              if (newEdge == null && sourceNode == null && targetNode == null) {
                if (newGraph == null) {
                  throw "Graph is null!";
                }
                if (parentNode == null) {
                  throw "Parent node is null!";
                }
                if (this.graphs.indexOf(newGraph) > -1) {
                  throw "Graph already in this graph mgr!";
                }

                this.graphs.push(newGraph);

                if (newGraph.parent != null) {
                  throw "Already has a parent!";
                }
                if (parentNode.child != null) {
                  throw "Already has a child!";
                }

                newGraph.parent = parentNode;
                parentNode.child = newGraph;

                return newGraph;
              } else {
    //change the order of the parameters
                targetNode = newEdge;
                sourceNode = parentNode;
                newEdge = newGraph;
                const sourceGraph = sourceNode.getOwner();
                const targetGraph = targetNode.getOwner();

                if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {
                  throw "Source not in this graph mgr!";
                }
                if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {
                  throw "Target not in this graph mgr!";
                }

                if (sourceGraph == targetGraph) {
                  newEdge.isInterGraph = false;
                  return sourceGraph.add(newEdge, sourceNode, targetNode);
                } else {
                  newEdge.isInterGraph = true;

      // set source and target
                  newEdge.source = sourceNode;
                  newEdge.target = targetNode;

      // add edge to inter-graph edge list
                  if (this.edges.indexOf(newEdge) > -1) {
                    throw "Edge already in inter-graph edge list!";
                  }

                  this.edges.push(newEdge);

      // add edge to source and target incidency lists
                  if (!(newEdge.source != null && newEdge.target != null)) {
                    throw "Edge source and/or target is null!";
                  }

                  if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {
                    throw "Edge already in source and/or target incidency list!";
                  }

                  newEdge.source.edges.push(newEdge);
                  newEdge.target.edges.push(newEdge);

                  return newEdge;
                }
              }
            };

            LGraphManager.prototype.remove = function (lObj) {
              if (lObj instanceof LGraph) {
                const graph = lObj;
                if (graph.getGraphManager() != this) {
                  throw "Graph not in this graph mgr";
                }
                if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {
                  throw "Invalid parent node!";
                }

    // first the edges (make a copy to do it safely)
                let edgesToBeRemoved = [];

                edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());

                var edge;
                let s = edgesToBeRemoved.length;
                for (var i = 0; i < s; i++) {
                  edge = edgesToBeRemoved[i];
                  graph.remove(edge);
                }

    // then the nodes (make a copy to do it safely)
                let nodesToBeRemoved = [];

                nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());

                let node;
                s = nodesToBeRemoved.length;
                for (var i = 0; i < s; i++) {
                  node = nodesToBeRemoved[i];
                  graph.remove(node);
                }

    // check if graph is the root
                if (graph == this.rootGraph) {
                  this.setRootGraph(null);
                }

    // now remove the graph itself
                var index = this.graphs.indexOf(graph);
                this.graphs.splice(index, 1);

    // also reset the parent of the graph
                graph.parent = null;
              } else if (lObj instanceof LEdge) {
                edge = lObj;
                if (edge == null) {
                  throw "Edge is null!";
                }
                if (!edge.isInterGraph) {
                  throw "Not an inter-graph edge!";
                }
                if (!(edge.source != null && edge.target != null)) {
                  throw "Source and/or target is null!";
                }

    // remove edge from source and target nodes' incidency lists

                if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {
                  throw "Source and/or target doesn't know this edge!";
                }

                var index = edge.source.edges.indexOf(edge);
                edge.source.edges.splice(index, 1);
                index = edge.target.edges.indexOf(edge);
                edge.target.edges.splice(index, 1);

    // remove edge from owner graph manager's inter-graph edge list

                if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {
                  throw "Edge owner graph or owner graph manager is null!";
                }
                if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {
                  throw "Not in owner graph manager's edge list!";
                }

                var index = edge.source.owner.getGraphManager().edges.indexOf(edge);
                edge.source.owner.getGraphManager().edges.splice(index, 1);
              }
            };

            LGraphManager.prototype.updateBounds = function () {
              this.rootGraph.updateBounds(true);
            };

            LGraphManager.prototype.getGraphs = function () {
              return this.graphs;
            };

            LGraphManager.prototype.getAllNodes = function () {
              if (this.allNodes == null) {
                let nodeList = [];
                const graphs = this.getGraphs();
                const s = graphs.length;
                for (let i = 0; i < s; i++) {
                  nodeList = nodeList.concat(graphs[i].getNodes());
                }
                this.allNodes = nodeList;
              }
              return this.allNodes;
            };

            LGraphManager.prototype.resetAllNodes = function () {
              this.allNodes = null;
            };

            LGraphManager.prototype.resetAllEdges = function () {
              this.allEdges = null;
            };

            LGraphManager.prototype.resetAllNodesToApplyGravitation = function () {
              this.allNodesToApplyGravitation = null;
            };

            LGraphManager.prototype.getAllEdges = function () {
              if (this.allEdges == null) {
                let edgeList = [];
                const graphs = this.getGraphs();
                const s = graphs.length;
                for (let i = 0; i < graphs.length; i++) {
                  edgeList = edgeList.concat(graphs[i].getEdges());
                }

                edgeList = edgeList.concat(this.edges);

                this.allEdges = edgeList;
              }
              return this.allEdges;
            };

            LGraphManager.prototype.getAllNodesToApplyGravitation = function () {
              return this.allNodesToApplyGravitation;
            };

            LGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {
              if (this.allNodesToApplyGravitation != null) {
                throw "assert failed";
              }

              this.allNodesToApplyGravitation = nodeList;
            };

            LGraphManager.prototype.getRoot = function () {
              return this.rootGraph;
            };

            LGraphManager.prototype.setRootGraph = function (graph) {
              if (graph.getGraphManager() != this) {
                throw "Root not in this graph mgr!";
              }

              this.rootGraph = graph;
  // root graph must have a root node associated with it for convenience
              if (graph.parent == null) {
                graph.parent = this.layout.newNode("Root node");
              }
            };

            LGraphManager.prototype.getLayout = function () {
              return this.layout;
            };

            LGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {
              if (!(firstNode != null && secondNode != null)) {
                throw "assert failed";
              }

              if (firstNode == secondNode) {
                return true;
              }
  // Is second node an ancestor of the first one?
              let ownerGraph = firstNode.getOwner();
              let parentNode;

              do {
                parentNode = ownerGraph.getParent();

                if (parentNode == null) {
                  break;
                }

                if (parentNode == secondNode) {
                  return true;
                }

                ownerGraph = parentNode.getOwner();
                if (ownerGraph == null) {
                  break;
                }
              } while (true);
  // Is first node an ancestor of the second one?
              ownerGraph = secondNode.getOwner();

              do {
                parentNode = ownerGraph.getParent();

                if (parentNode == null) {
                  break;
                }

                if (parentNode == firstNode) {
                  return true;
                }

                ownerGraph = parentNode.getOwner();
                if (ownerGraph == null) {
                  break;
                }
              } while (true);

              return false;
            };

            LGraphManager.prototype.calcLowestCommonAncestors = function () {
              let edge;
              let sourceNode;
              let targetNode;
              let sourceAncestorGraph;
              let targetAncestorGraph;

              const edges = this.getAllEdges();
              const s = edges.length;
              for (let i = 0; i < s; i++) {
                edge = edges[i];

                sourceNode = edge.source;
                targetNode = edge.target;
                edge.lca = null;
                edge.sourceInLca = sourceNode;
                edge.targetInLca = targetNode;

                if (sourceNode == targetNode) {
                  edge.lca = sourceNode.getOwner();
                  continue;
                }

                sourceAncestorGraph = sourceNode.getOwner();

                while (edge.lca == null) {
                  edge.targetInLca = targetNode;
                  targetAncestorGraph = targetNode.getOwner();

                  while (edge.lca == null) {
                    if (targetAncestorGraph == sourceAncestorGraph) {
                      edge.lca = targetAncestorGraph;
                      break;
                    }

                    if (targetAncestorGraph == this.rootGraph) {
                      break;
                    }

                    if (edge.lca != null) {
                      throw "assert failed";
                    }
                    edge.targetInLca = targetAncestorGraph.getParent();
                    targetAncestorGraph = edge.targetInLca.getOwner();
                  }

                  if (sourceAncestorGraph == this.rootGraph) {
                    break;
                  }

                  if (edge.lca == null) {
                    edge.sourceInLca = sourceAncestorGraph.getParent();
                    sourceAncestorGraph = edge.sourceInLca.getOwner();
                  }
                }

                if (edge.lca == null) {
                  throw "assert failed";
                }
              }
            };

            LGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {
              if (firstNode == secondNode) {
                return firstNode.getOwner();
              }
              let firstOwnerGraph = firstNode.getOwner();

              do {
                if (firstOwnerGraph == null) {
                  break;
                }
                let secondOwnerGraph = secondNode.getOwner();

                do {
                  if (secondOwnerGraph == null) {
                    break;
                  }

                  if (secondOwnerGraph == firstOwnerGraph) {
                    return secondOwnerGraph;
                  }
                  secondOwnerGraph = secondOwnerGraph.getParent().getOwner();
                } while (true);

                firstOwnerGraph = firstOwnerGraph.getParent().getOwner();
              } while (true);

              return firstOwnerGraph;
            };

            LGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {
              if (graph == null && depth == null) {
                graph = this.rootGraph;
                depth = 1;
              }
              let node;

              const nodes = graph.getNodes();
              const s = nodes.length;
              for (let i = 0; i < s; i++) {
                node = nodes[i];
                node.inclusionTreeDepth = depth;

                if (node.child != null) {
                  this.calcInclusionTreeDepths(node.child, depth + 1);
                }
              }
            };

            LGraphManager.prototype.includesInvalidEdge = function () {
              let edge;

              const s = this.edges.length;
              for (let i = 0; i < s; i++) {
                edge = this.edges[i];

                if (this.isOneAncestorOfOther(edge.source, edge.target)) {
                  return true;
                }
              }
              return false;
            };

            module.exports = LGraphManager;

/***/ }),
/* 7 */
/***/ (function(module, exports, __nested_webpack_require_38707__) {

            "use strict";


            const LayoutConstants = __nested_webpack_require_38707__(0);

            function FDLayoutConstants() {}

//FDLayoutConstants inherits static props in LayoutConstants
            for (const prop in LayoutConstants) {
              FDLayoutConstants[prop] = LayoutConstants[prop];
            }

            FDLayoutConstants.MAX_ITERATIONS = 2500;

            FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;
            FDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;
            FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;
            FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;
            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;
            FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;
            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;
            FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;
            FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;
            FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;
            FDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;
            FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;
            FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;
            FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;
            FDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;
            FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;
            FDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;
            FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;
            FDLayoutConstants.MIN_EDGE_LENGTH = 1;
            FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;

            module.exports = FDLayoutConstants;

/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_40298__) {

            "use strict";


/**
 * This class maintains a list of static geometry related utility methods.
 *
 *
 * Copyright: i-Vis Research Group, Bilkent University, 2007 - present
 */

            const Point = __nested_webpack_require_40298__(12);

            function IGeometry() {}

/**
 * This method calculates *half* the amount in x and y directions of the two
 * input rectangles needed to separate them keeping their respective
 * positioning, and returns the result in the input array. An input
 * separation buffer added to the amount in both directions. We assume that
 * the two rectangles do intersect.
 */
            IGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {
              if (!rectA.intersects(rectB)) {
                throw "assert failed";
              }

              const directions = new Array(2);

              this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);

              overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);
              overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);

  // update the overlapping amounts for the following cases:
              if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {
    /* Case x.1:
    *
    * rectA
    * 	|                       |
    * 	|        _________      |
    * 	|        |       |      |
    * 	|________|_______|______|
    * 			 |       |
    *           |       |
    *        rectB
    */
                overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());
              } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {
    /* Case x.2:
    *
    * rectB
    * 	|                       |
    * 	|        _________      |
    * 	|        |       |      |
    * 	|________|_______|______|
    * 			 |       |
    *           |       |
    *        rectA
    */
                overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());
              }
              if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {
    /* Case y.1:
     *          ________ rectA
     *         |
     *         |
     *   ______|____  rectB
     *         |    |
     *         |    |
     *   ______|____|
     *         |
     *         |
     *         |________
     *
     */
                overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());
              } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {
    /* Case y.2:
    *          ________ rectB
    *         |
    *         |
    *   ______|____  rectA
    *         |    |
    *         |    |
    *   ______|____|
    *         |
    *         |
    *         |________
    *
    */
                overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());
              }

  // find slope of the line passes two centers
              let slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));
  // if centers are overlapped
              if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {
    // assume the slope is 1 (45 degree)
                slope = 1.0;
              }

              let moveByY = slope * overlapAmount[0];
              let moveByX = overlapAmount[1] / slope;
              if (overlapAmount[0] < moveByX) {
                moveByX = overlapAmount[0];
              } else {
                moveByY = overlapAmount[1];
              }
  // return half the amount so that if each rectangle is moved by these
  // amounts in opposite directions, overlap will be resolved
              overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);
              overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);
            };

/**
 * This method decides the separation direction of overlapping nodes
 *
 * if directions[0] = -1, then rectA goes left
 * if directions[0] = 1,  then rectA goes right
 * if directions[1] = -1, then rectA goes up
 * if directions[1] = 1,  then rectA goes down
 */
            IGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {
              if (rectA.getCenterX() < rectB.getCenterX()) {
                directions[0] = -1;
              } else {
                directions[0] = 1;
              }

              if (rectA.getCenterY() < rectB.getCenterY()) {
                directions[1] = -1;
              } else {
                directions[1] = 1;
              }
            };

/**
 * This method calculates the intersection (clipping) points of the two
 * input rectangles with line segment defined by the centers of these two
 * rectangles. The clipping points are saved in the input double array and
 * whether or not the two rectangles overlap is returned.
 */
            IGeometry.getIntersection2 = function (rectA, rectB, result) {
  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB
              const p1x = rectA.getCenterX();
              const p1y = rectA.getCenterY();
              const p2x = rectB.getCenterX();
              const p2y = rectB.getCenterY();

  //if two rectangles intersect, then clipping points are centers
              if (rectA.intersects(rectB)) {
                result[0] = p1x;
                result[1] = p1y;
                result[2] = p2x;
                result[3] = p2y;
                return true;
              }
  //variables for rectA
              const topLeftAx = rectA.getX();
              const topLeftAy = rectA.getY();
              const topRightAx = rectA.getRight();
              const bottomLeftAx = rectA.getX();
              const bottomLeftAy = rectA.getBottom();
              const bottomRightAx = rectA.getRight();
              const halfWidthA = rectA.getWidthHalf();
              const halfHeightA = rectA.getHeightHalf();
  //variables for rectB
              const topLeftBx = rectB.getX();
              const topLeftBy = rectB.getY();
              const topRightBx = rectB.getRight();
              const bottomLeftBx = rectB.getX();
              const bottomLeftBy = rectB.getBottom();
              const bottomRightBx = rectB.getRight();
              const halfWidthB = rectB.getWidthHalf();
              const halfHeightB = rectB.getHeightHalf();

  //flag whether clipping points are found
              let clipPointAFound = false;
              let clipPointBFound = false;

  // line is vertical
              if (p1x === p2x) {
                if (p1y > p2y) {
                  result[0] = p1x;
                  result[1] = topLeftAy;
                  result[2] = p2x;
                  result[3] = bottomLeftBy;
                  return false;
                } else if (p1y < p2y) {
                  result[0] = p1x;
                  result[1] = bottomLeftAy;
                  result[2] = p2x;
                  result[3] = topLeftBy;
                  return false;
                } else {
      //not line, return null;
                }
              }
  // line is horizontal
              else if (p1y === p2y) {
                if (p1x > p2x) {
                  result[0] = topLeftAx;
                  result[1] = p1y;
                  result[2] = topRightBx;
                  result[3] = p2y;
                  return false;
                } else if (p1x < p2x) {
                  result[0] = topRightAx;
                  result[1] = p1y;
                  result[2] = topLeftBx;
                  result[3] = p2y;
                  return false;
                } else {
        //not valid line, return null;
                }
              } else {
      //slopes of rectA's and rectB's diagonals
                const slopeA = rectA.height / rectA.width;
                const slopeB = rectB.height / rectB.width;

      //slope of line between center of rectA and center of rectB
                const slopePrime = (p2y - p1y) / (p2x - p1x);
                let cardinalDirectionA = void 0;
                let cardinalDirectionB = void 0;
                let tempPointAx = void 0;
                let tempPointAy = void 0;
                let tempPointBx = void 0;
                let tempPointBy = void 0;

      //determine whether clipping point is the corner of nodeA
                if (-slopeA === slopePrime) {
                  if (p1x > p2x) {
                    result[0] = bottomLeftAx;
                    result[1] = bottomLeftAy;
                    clipPointAFound = true;
                  } else {
                    result[0] = topRightAx;
                    result[1] = topLeftAy;
                    clipPointAFound = true;
                  }
                } else if (slopeA === slopePrime) {
                  if (p1x > p2x) {
                    result[0] = topLeftAx;
                    result[1] = topLeftAy;
                    clipPointAFound = true;
                  } else {
                    result[0] = bottomRightAx;
                    result[1] = bottomLeftAy;
                    clipPointAFound = true;
                  }
                }

      //determine whether clipping point is the corner of nodeB
                if (-slopeB === slopePrime) {
                  if (p2x > p1x) {
                    result[2] = bottomLeftBx;
                    result[3] = bottomLeftBy;
                    clipPointBFound = true;
                  } else {
                    result[2] = topRightBx;
                    result[3] = topLeftBy;
                    clipPointBFound = true;
                  }
                } else if (slopeB === slopePrime) {
                  if (p2x > p1x) {
                    result[2] = topLeftBx;
                    result[3] = topLeftBy;
                    clipPointBFound = true;
                  } else {
                    result[2] = bottomRightBx;
                    result[3] = bottomLeftBy;
                    clipPointBFound = true;
                  }
                }

      //if both clipping points are corners
                if (clipPointAFound && clipPointBFound) {
                  return false;
                }

      //determine Cardinal Direction of rectangles
                if (p1x > p2x) {
                  if (p1y > p2y) {
                    cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);
                    cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);
                  } else {
                    cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);
                    cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);
                  }
                } else {
                  if (p1y > p2y) {
                    cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);
                    cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);
                  } else {
                    cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);
                    cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);
                  }
                }
      //calculate clipping Point if it is not found before
                if (!clipPointAFound) {
                  switch (cardinalDirectionA) {
                    case 1:
                      tempPointAy = topLeftAy;
                      tempPointAx = p1x + -halfHeightA / slopePrime;
                      result[0] = tempPointAx;
                      result[1] = tempPointAy;
                      break;
                    case 2:
                      tempPointAx = bottomRightAx;
                      tempPointAy = p1y + halfWidthA * slopePrime;
                      result[0] = tempPointAx;
                      result[1] = tempPointAy;
                      break;
                    case 3:
                      tempPointAy = bottomLeftAy;
                      tempPointAx = p1x + halfHeightA / slopePrime;
                      result[0] = tempPointAx;
                      result[1] = tempPointAy;
                      break;
                    case 4:
                      tempPointAx = bottomLeftAx;
                      tempPointAy = p1y + -halfWidthA * slopePrime;
                      result[0] = tempPointAx;
                      result[1] = tempPointAy;
                      break;
                  }
                }
                if (!clipPointBFound) {
                  switch (cardinalDirectionB) {
                    case 1:
                      tempPointBy = topLeftBy;
                      tempPointBx = p2x + -halfHeightB / slopePrime;
                      result[2] = tempPointBx;
                      result[3] = tempPointBy;
                      break;
                    case 2:
                      tempPointBx = bottomRightBx;
                      tempPointBy = p2y + halfWidthB * slopePrime;
                      result[2] = tempPointBx;
                      result[3] = tempPointBy;
                      break;
                    case 3:
                      tempPointBy = bottomLeftBy;
                      tempPointBx = p2x + halfHeightB / slopePrime;
                      result[2] = tempPointBx;
                      result[3] = tempPointBy;
                      break;
                    case 4:
                      tempPointBx = bottomLeftBx;
                      tempPointBy = p2y + -halfWidthB * slopePrime;
                      result[2] = tempPointBx;
                      result[3] = tempPointBy;
                      break;
                  }
                }
              }
              return false;
            };

/**
 * This method returns in which cardinal direction does input point stays
 * 1: North
 * 2: East
 * 3: South
 * 4: West
 */
            IGeometry.getCardinalDirection = function (slope, slopePrime, line) {
              if (slope > slopePrime) {
                return line;
              } else {
                return 1 + line % 4;
              }
            };

/**
 * This method calculates the intersection of the two lines defined by
 * point pairs (s1,s2) and (f1,f2).
 */
            IGeometry.getIntersection = function (s1, s2, f1, f2) {
              if (f2 == null) {
                return this.getIntersection2(s1, s2, f1);
              }

              const x1 = s1.x;
              const y1 = s1.y;
              const x2 = s2.x;
              const y2 = s2.y;
              const x3 = f1.x;
              const y3 = f1.y;
              const x4 = f2.x;
              const y4 = f2.y;
              let x = void 0,
                y = void 0; // intersection point
              let a1 = void 0,
                a2 = void 0,
                b1 = void 0,
                b2 = void 0,
                c1 = void 0,
                c2 = void 0; // coefficients of line eqns.
              let denom = void 0;

              a1 = y2 - y1;
              b1 = x1 - x2;
              c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }

              a2 = y4 - y3;
              b2 = x3 - x4;
              c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }

              denom = a1 * b2 - a2 * b1;

              if (denom === 0) {
                return null;
              }

              x = (b1 * c2 - b2 * c1) / denom;
              y = (a2 * c1 - a1 * c2) / denom;

              return new Point(x, y);
            };

/**
 * This method finds and returns the angle of the vector from the + x-axis
 * in clockwise direction (compatible w/ Java coordinate system!).
 */
            IGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {
              let C_angle = void 0;

              if (Cx !== Nx) {
                C_angle = Math.atan((Ny - Cy) / (Nx - Cx));

                if (Nx < Cx) {
                  C_angle += Math.PI;
                } else if (Ny < Cy) {
                  C_angle += this.TWO_PI;
                }
              } else if (Ny < Cy) {
                C_angle = this.ONE_AND_HALF_PI; // 270 degrees
              } else {
                C_angle = this.HALF_PI; // 90 degrees
              }

              return C_angle;
            };

/**
 * This method checks whether the given two line segments (one with point
 * p1 and p2, the other with point p3 and p4) intersect at a point other
 * than these points.
 */
            IGeometry.doIntersect = function (p1, p2, p3, p4) {
              const a = p1.x;
              const b = p1.y;
              const c = p2.x;
              const d = p2.y;
              const p = p3.x;
              const q = p3.y;
              const r = p4.x;
              const s = p4.y;
              const det = (c - a) * (s - q) - (r - p) * (d - b);

              if (det === 0) {
                return false;
              } else {
                const lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
                const gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
                return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;
              }
            };

// -----------------------------------------------------------------------------
// Section: Class Constants
// -----------------------------------------------------------------------------
/**
 * Some useful pre-calculated constants
 */
            IGeometry.HALF_PI = 0.5 * Math.PI;
            IGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;
            IGeometry.TWO_PI = 2.0 * Math.PI;
            IGeometry.THREE_PI = 3.0 * Math.PI;

            module.exports = IGeometry;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

            "use strict";


            function IMath() {}

/**
 * This method returns the sign of the input value.
 */
            IMath.sign = function (value) {
              if (value > 0) {
                return 1;
              } else if (value < 0) {
                return -1;
              } else {
                return 0;
              }
            };

            IMath.floor = function (value) {
              return value < 0 ? Math.ceil(value) : Math.floor(value);
            };

            IMath.ceil = function (value) {
              return value < 0 ? Math.floor(value) : Math.ceil(value);
            };

            module.exports = IMath;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

            "use strict";


            function Integer() {}

            Integer.MAX_VALUE = 2147483647;
            Integer.MIN_VALUE = -2147483648;

            module.exports = Integer;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

            "use strict";


            const _createClass = function () { function defineProperties(target, props) { for (let i = 0; i < props.length; i++) { const descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            const nodeFrom = function nodeFrom(value) {
              return { value: value, next: null, prev: null };
            };

            const add = function add(prev, node, next, list) {
              if (prev !== null) {
                prev.next = node;
              } else {
                list.head = node;
              }

              if (next !== null) {
                next.prev = node;
              } else {
                list.tail = node;
              }

              node.prev = prev;
              node.next = next;

              list.length++;

              return node;
            };

            const _remove = function _remove(node, list) {
              const prev = node.prev,
                next = node.next;


              if (prev !== null) {
                prev.next = next;
              } else {
                list.head = next;
              }

              if (next !== null) {
                next.prev = prev;
              } else {
                list.tail = prev;
              }

              node.prev = node.next = null;

              list.length--;

              return node;
            };

            const LinkedList = function () {
              function LinkedList(vals) {
                const _this = this;

                _classCallCheck(this, LinkedList);

                this.length = 0;
                this.head = null;
                this.tail = null;

                if (vals != null) {
                  vals.forEach(function (v) {
                    return _this.push(v);
                  });
                }
              }

              _createClass(LinkedList, [{
                key: "size",
                value: function size() {
                  return this.length;
                }
              }, {
                key: "insertBefore",
                value: function insertBefore(val, otherNode) {
                  return add(otherNode.prev, nodeFrom(val), otherNode, this);
                }
              }, {
                key: "insertAfter",
                value: function insertAfter(val, otherNode) {
                  return add(otherNode, nodeFrom(val), otherNode.next, this);
                }
              }, {
                key: "insertNodeBefore",
                value: function insertNodeBefore(newNode, otherNode) {
                  return add(otherNode.prev, newNode, otherNode, this);
                }
              }, {
                key: "insertNodeAfter",
                value: function insertNodeAfter(newNode, otherNode) {
                  return add(otherNode, newNode, otherNode.next, this);
                }
              }, {
                key: "push",
                value: function push(val) {
                  return add(this.tail, nodeFrom(val), null, this);
                }
              }, {
                key: "unshift",
                value: function unshift(val) {
                  return add(null, nodeFrom(val), this.head, this);
                }
              }, {
                key: "remove",
                value: function remove(node) {
                  return _remove(node, this);
                }
              }, {
                key: "pop",
                value: function pop() {
                  return _remove(this.tail, this).value;
                }
              }, {
                key: "popNode",
                value: function popNode() {
                  return _remove(this.tail, this);
                }
              }, {
                key: "shift",
                value: function shift() {
                  return _remove(this.head, this).value;
                }
              }, {
                key: "shiftNode",
                value: function shiftNode() {
                  return _remove(this.head, this);
                }
              }, {
                key: "get_object_at",
                value: function get_object_at(index) {
                  if (index <= this.length()) {
                    let i = 1;
                    let current = this.head;
                    while (i < index) {
                      current = current.next;
                      i++;
                    }
                    return current.value;
                  }
                }
              }, {
                key: "set_object_at",
                value: function set_object_at(index, value) {
                  if (index <= this.length()) {
                    let i = 1;
                    let current = this.head;
                    while (i < index) {
                      current = current.next;
                      i++;
                    }
                    current.value = value;
                  }
                }
              }]);

              return LinkedList;
            }();

            module.exports = LinkedList;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

            "use strict";


/*
 *This class is the javascript implementation of the Point.java class in jdk
 */
            function Point(x, y, p) {
              this.x = null;
              this.y = null;
              if (x == null && y == null && p == null) {
                this.x = 0;
                this.y = 0;
              } else if (typeof x == 'number' && typeof y == 'number' && p == null) {
                this.x = x;
                this.y = y;
              } else if (x.constructor.name == 'Point' && y == null && p == null) {
                p = x;
                this.x = p.x;
                this.y = p.y;
              }
            }

            Point.prototype.getX = function () {
              return this.x;
            };

            Point.prototype.getY = function () {
              return this.y;
            };

            Point.prototype.getLocation = function () {
              return new Point(this.x, this.y);
            };

            Point.prototype.setLocation = function (x, y, p) {
              if (x.constructor.name == 'Point' && y == null && p == null) {
                p = x;
                this.setLocation(p.x, p.y);
              } else if (typeof x == 'number' && typeof y == 'number' && p == null) {
    //if both parameters are integer just move (x,y) location
                if (parseInt(x) == x && parseInt(y) == y) {
                  this.move(x, y);
                } else {
                  this.x = Math.floor(x + 0.5);
                  this.y = Math.floor(y + 0.5);
                }
              }
            };

            Point.prototype.move = function (x, y) {
              this.x = x;
              this.y = y;
            };

            Point.prototype.translate = function (dx, dy) {
              this.x += dx;
              this.y += dy;
            };

            Point.prototype.equals = function (obj) {
              if (obj.constructor.name == "Point") {
                const pt = obj;
                return this.x == pt.x && this.y == pt.y;
              }
              return this == obj;
            };

            Point.prototype.toString = function () {
              return new Point().constructor.name + "[x=" + this.x + ",y=" + this.y + "]";
            };

            module.exports = Point;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

            "use strict";


            function RectangleD(x, y, width, height) {
              this.x = 0;
              this.y = 0;
              this.width = 0;
              this.height = 0;

              if (x != null && y != null && width != null && height != null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
              }
            }

            RectangleD.prototype.getX = function () {
              return this.x;
            };

            RectangleD.prototype.setX = function (x) {
              this.x = x;
            };

            RectangleD.prototype.getY = function () {
              return this.y;
            };

            RectangleD.prototype.setY = function (y) {
              this.y = y;
            };

            RectangleD.prototype.getWidth = function () {
              return this.width;
            };

            RectangleD.prototype.setWidth = function (width) {
              this.width = width;
            };

            RectangleD.prototype.getHeight = function () {
              return this.height;
            };

            RectangleD.prototype.setHeight = function (height) {
              this.height = height;
            };

            RectangleD.prototype.getRight = function () {
              return this.x + this.width;
            };

            RectangleD.prototype.getBottom = function () {
              return this.y + this.height;
            };

            RectangleD.prototype.intersects = function (a) {
              if (this.getRight() < a.x) {
                return false;
              }

              if (this.getBottom() < a.y) {
                return false;
              }

              if (a.getRight() < this.x) {
                return false;
              }

              if (a.getBottom() < this.y) {
                return false;
              }

              return true;
            };

            RectangleD.prototype.getCenterX = function () {
              return this.x + this.width / 2;
            };

            RectangleD.prototype.getMinX = function () {
              return this.getX();
            };

            RectangleD.prototype.getMaxX = function () {
              return this.getX() + this.width;
            };

            RectangleD.prototype.getCenterY = function () {
              return this.y + this.height / 2;
            };

            RectangleD.prototype.getMinY = function () {
              return this.getY();
            };

            RectangleD.prototype.getMaxY = function () {
              return this.getY() + this.height;
            };

            RectangleD.prototype.getWidthHalf = function () {
              return this.width / 2;
            };

            RectangleD.prototype.getHeightHalf = function () {
              return this.height / 2;
            };

            module.exports = RectangleD;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

            "use strict";


            const _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

            function UniqueIDGeneretor() {}

            UniqueIDGeneretor.lastID = 0;

            UniqueIDGeneretor.createID = function (obj) {
              if (UniqueIDGeneretor.isPrimitive(obj)) {
                return obj;
              }
              if (obj.uniqueID != null) {
                return obj.uniqueID;
              }
              obj.uniqueID = UniqueIDGeneretor.getString();
              UniqueIDGeneretor.lastID++;
              return obj.uniqueID;
            };

            UniqueIDGeneretor.getString = function (id) {
              if (id == null) id = UniqueIDGeneretor.lastID;
              return "Object#" + id + "";
            };

            UniqueIDGeneretor.isPrimitive = function (arg) {
              const type = typeof arg === "undefined" ? "undefined" : _typeof(arg);
              return arg == null || type != "object" && type != "function";
            };

            module.exports = UniqueIDGeneretor;

/***/ }),
/* 15 */
/***/ (function(module, exports, __nested_webpack_require_64072__) {

            "use strict";


            function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

            const LayoutConstants = __nested_webpack_require_64072__(0);
            const LGraphManager = __nested_webpack_require_64072__(6);
            const LNode = __nested_webpack_require_64072__(3);
            const LEdge = __nested_webpack_require_64072__(1);
            const LGraph = __nested_webpack_require_64072__(5);
            const PointD = __nested_webpack_require_64072__(4);
            const Transform = __nested_webpack_require_64072__(17);
            const Emitter = __nested_webpack_require_64072__(27);

            function Layout(isRemoteUse) {
              Emitter.call(this);

  //Layout Quality: 0:draft, 1:default, 2:proof
              this.layoutQuality = LayoutConstants.QUALITY;
  //Whether layout should create bendpoints as needed or not
              this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;
  //Whether layout should be incremental or not
              this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;
  //Whether we animate from before to after layout node positions
              this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;
  //Whether we animate the layout process or not
              this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;
  //Number iterations that should be done between two successive animations
              this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;
  /**
   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When
   * they are, both spring and repulsion forces between two leaf nodes can be
   * calculated without the expensive clipping point calculations, resulting
   * in major speed-up.
   */
              this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;
  /**
   * This is used for creation of bendpoints by using dummy nodes and edges.
   * Maps an LEdge to its dummy bendpoint path.
   */
              this.edgeToDummyNodes = new Map();
              this.graphManager = new LGraphManager(this);
              this.isLayoutFinished = false;
              this.isSubLayout = false;
              this.isRemoteUse = false;

              if (isRemoteUse != null) {
                this.isRemoteUse = isRemoteUse;
              }
            }

            Layout.RANDOM_SEED = 1;

            Layout.prototype = Object.create(Emitter.prototype);

            Layout.prototype.getGraphManager = function () {
              return this.graphManager;
            };

            Layout.prototype.getAllNodes = function () {
              return this.graphManager.getAllNodes();
            };

            Layout.prototype.getAllEdges = function () {
              return this.graphManager.getAllEdges();
            };

            Layout.prototype.getAllNodesToApplyGravitation = function () {
              return this.graphManager.getAllNodesToApplyGravitation();
            };

            Layout.prototype.newGraphManager = function () {
              const gm = new LGraphManager(this);
              this.graphManager = gm;
              return gm;
            };

            Layout.prototype.newGraph = function (vGraph) {
              return new LGraph(null, this.graphManager, vGraph);
            };

            Layout.prototype.newNode = function (vNode) {
              return new LNode(this.graphManager, vNode);
            };

            Layout.prototype.newEdge = function (vEdge) {
              return new LEdge(null, null, vEdge);
            };

            Layout.prototype.checkLayoutSuccess = function () {
              return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();
            };

            Layout.prototype.runLayout = function () {
              this.isLayoutFinished = false;

              if (this.tilingPreLayout) {
                this.tilingPreLayout();
              }

              this.initParameters();
              let isLayoutSuccessfull;

              if (this.checkLayoutSuccess()) {
                isLayoutSuccessfull = false;
              } else {
                isLayoutSuccessfull = this.layout();
              }

              if (LayoutConstants.ANIMATE === 'during') {
    // If this is a 'during' layout animation. Layout is not finished yet. 
    // We need to perform these in index.js when layout is really finished.
                return false;
              }

              if (isLayoutSuccessfull) {
                if (!this.isSubLayout) {
                  this.doPostLayout();
                }
              }

              if (this.tilingPostLayout) {
                this.tilingPostLayout();
              }

              this.isLayoutFinished = true;

              return isLayoutSuccessfull;
            };

/**
 * This method performs the operations required after layout.
 */
            Layout.prototype.doPostLayout = function () {
  //assert !isSubLayout : "Should not be called on sub-layout!";
  // Propagate geometric changes to v-level objects
              if (!this.incremental) {
                this.transform();
              }
              this.update();
            };

/**
 * This method updates the geometry of the target graph according to
 * calculated layout.
 */
            Layout.prototype.update2 = function () {
  // update bend points
              if (this.createBendsAsNeeded) {
                this.createBendpointsFromDummyNodes();

    // reset all edges, since the topology has changed
                this.graphManager.resetAllEdges();
              }

  // perform edge, node and root updates if layout is not called
  // remotely
              if (!this.isRemoteUse) {
    // update all edges
                let edge;
                const allEdges = this.graphManager.getAllEdges();
                for (var i = 0; i < allEdges.length; i++) {
                  edge = allEdges[i];
      //      this.update(edge);
                }

    // recursively update nodes
                let node;
                const nodes = this.graphManager.getRoot().getNodes();
                for (var i = 0; i < nodes.length; i++) {
                  node = nodes[i];
      //      this.update(node);
                }

    // update root graph
                this.update(this.graphManager.getRoot());
              }
            };

            Layout.prototype.update = function (obj) {
              if (obj == null) {
                this.update2();
              } else if (obj instanceof LNode) {
                const node = obj;
                if (node.getChild() != null) {
      // since node is compound, recursively update child nodes
                  const nodes = node.getChild().getNodes();
                  for (let i = 0; i < nodes.length; i++) {
                    update(nodes[i]);
                  }
                }

    // if the l-level node is associated with a v-level graph object,
    // then it is assumed that the v-level node implements the
    // interface Updatable.
                if (node.vGraphObject != null) {
      // cast to Updatable without any type check
                  const vNode = node.vGraphObject;

      // call the update method of the interface
                  vNode.update(node);
                }
              } else if (obj instanceof LEdge) {
                const edge = obj;
    // if the l-level edge is associated with a v-level graph object,
    // then it is assumed that the v-level edge implements the
    // interface Updatable.

                if (edge.vGraphObject != null) {
      // cast to Updatable without any type check
                  const vEdge = edge.vGraphObject;

      // call the update method of the interface
                  vEdge.update(edge);
                }
              } else if (obj instanceof LGraph) {
                const graph = obj;
    // if the l-level graph is associated with a v-level graph object,
    // then it is assumed that the v-level object implements the
    // interface Updatable.

                if (graph.vGraphObject != null) {
      // cast to Updatable without any type check
                  const vGraph = graph.vGraphObject;

      // call the update method of the interface
                  vGraph.update(graph);
                }
              }
            };

/**
 * This method is used to set all layout parameters to default values
 * determined at compile time.
 */
            Layout.prototype.initParameters = function () {
              if (!this.isSubLayout) {
                this.layoutQuality = LayoutConstants.QUALITY;
                this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;
                this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;
                this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;
                this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;
                this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;
                this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;
              }

              if (this.animationDuringLayout) {
                this.animationOnLayout = false;
              }
            };

            Layout.prototype.transform = function (newLeftTop) {
              if (newLeftTop == undefined) {
                this.transform(new PointD(0, 0));
              } else {
    // create a transformation object (from Eclipse to layout). When an
    // inverse transform is applied, we get upper-left coordinate of the
    // drawing or the root graph at given input coordinate (some margins
    // already included in calculation of left-top).

                const trans = new Transform();
                const leftTop = this.graphManager.getRoot().updateLeftTop();

                if (leftTop != null) {
                  trans.setWorldOrgX(newLeftTop.x);
                  trans.setWorldOrgY(newLeftTop.y);

                  trans.setDeviceOrgX(leftTop.x);
                  trans.setDeviceOrgY(leftTop.y);

                  const nodes = this.getAllNodes();
                  let node;

                  for (let i = 0; i < nodes.length; i++) {
                    node = nodes[i];
                    node.transform(trans);
                  }
                }
              }
            };

            Layout.prototype.positionNodesRandomly = function (graph) {

              if (graph == undefined) {
    //assert !this.incremental;
                this.positionNodesRandomly(this.getGraphManager().getRoot());
                this.getGraphManager().getRoot().updateBounds(true);
              } else {
                let lNode;
                let childGraph;

                const nodes = graph.getNodes();
                for (let i = 0; i < nodes.length; i++) {
                  lNode = nodes[i];
                  childGraph = lNode.getChild();

                  if (childGraph == null) {
                    lNode.scatter();
                  } else if (childGraph.getNodes().length == 0) {
                    lNode.scatter();
                  } else {
                    this.positionNodesRandomly(childGraph);
                    lNode.updateBounds();
                  }
                }
              }
            };

/**
 * This method returns a list of trees where each tree is represented as a
 * list of l-nodes. The method returns a list of size 0 when:
 * - The graph is not flat or
 * - One of the component(s) of the graph is not a tree.
 */
            Layout.prototype.getFlatForest = function () {
              let flatForest = [];
              let isForest = true;

  // Quick reference for all nodes in the graph manager associated with
  // this layout. The list should not be changed.
              const allNodes = this.graphManager.getRoot().getNodes();

  // First be sure that the graph is flat
              let isFlat = true;

              for (var i = 0; i < allNodes.length; i++) {
                if (allNodes[i].getChild() != null) {
                  isFlat = false;
                }
              }

  // Return empty forest if the graph is not flat.
              if (!isFlat) {
                return flatForest;
              }

  // Run BFS for each component of the graph.

              let visited = new Set();
              const toBeVisited = [];
              let parents = new Map();
              let unProcessedNodes = [];

              unProcessedNodes = unProcessedNodes.concat(allNodes);

  // Each iteration of this loop finds a component of the graph and
  // decides whether it is a tree or not. If it is a tree, adds it to the
  // forest and continued with the next component.

              while (unProcessedNodes.length > 0 && isForest) {
                toBeVisited.push(unProcessedNodes[0]);

    // Start the BFS. Each iteration of this loop visits a node in a
    // BFS manner.
                while (toBeVisited.length > 0 && isForest) {
      //pool operation
                  const currentNode = toBeVisited[0];
                  toBeVisited.splice(0, 1);
                  visited.add(currentNode);

      // Traverse all neighbors of this node
                  const neighborEdges = currentNode.getEdges();

                  for (var i = 0; i < neighborEdges.length; i++) {
                    const currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);

        // If BFS is not growing from this neighbor.
                    if (parents.get(currentNode) != currentNeighbor) {
          // We haven't previously visited this neighbor.
                      if (!visited.has(currentNeighbor)) {
                        toBeVisited.push(currentNeighbor);
                        parents.set(currentNeighbor, currentNode);
                      }
          // Since we have previously visited this neighbor and
          // this neighbor is not parent of currentNode, given
          // graph contains a component that is not tree, hence
          // it is not a forest.
                      else {
                        isForest = false;
                        break;
                      }
                    }
                  }
                }

    // The graph contains a component that is not a tree. Empty
    // previously found trees. The method will end.
                if (!isForest) {
                  flatForest = [];
                }
    // Save currently visited nodes as a tree in our forest. Reset
    // visited and parents lists. Continue with the next component of
    // the graph, if any.
                else {
                  const temp = [].concat(_toConsumableArray(visited));
                  flatForest.push(temp);
        //flatForest = flatForest.concat(temp);
        //unProcessedNodes.removeAll(visited);
                  for (var i = 0; i < temp.length; i++) {
                    const value = temp[i];
                    const index = unProcessedNodes.indexOf(value);
                    if (index > -1) {
                      unProcessedNodes.splice(index, 1);
                    }
                  }
                  visited = new Set();
                  parents = new Map();
                }
              }

              return flatForest;
            };

/**
 * This method creates dummy nodes (an l-level node with minimal dimensions)
 * for the given edge (one per bendpoint). The existing l-level structure
 * is updated accordingly.
 */
            Layout.prototype.createDummyNodesForBendpoints = function (edge) {
              const dummyNodes = [];
              let prev = edge.source;

              const graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);

              for (let i = 0; i < edge.bendpoints.length; i++) {
    // create new dummy node
                const dummyNode = this.newNode(null);
                dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));

                graph.add(dummyNode);

    // create new dummy edge between prev and dummy node
                var dummyEdge = this.newEdge(null);
                this.graphManager.add(dummyEdge, prev, dummyNode);

                dummyNodes.add(dummyNode);
                prev = dummyNode;
              }

              var dummyEdge = this.newEdge(null);
              this.graphManager.add(dummyEdge, prev, edge.target);

              this.edgeToDummyNodes.set(edge, dummyNodes);

  // remove real edge from graph manager if it is inter-graph
              if (edge.isInterGraph()) {
                this.graphManager.remove(edge);
              }
  // else, remove the edge from the current graph
              else {
                graph.remove(edge);
              }

              return dummyNodes;
            };

/**
 * This method creates bendpoints for edges from the dummy nodes
 * at l-level.
 */
            Layout.prototype.createBendpointsFromDummyNodes = function () {
              let edges = [];
              edges = edges.concat(this.graphManager.getAllEdges());
              edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);

              for (let k = 0; k < edges.length; k++) {
                const lEdge = edges[k];

                if (lEdge.bendpoints.length > 0) {
                  const path = this.edgeToDummyNodes.get(lEdge);

                  for (let i = 0; i < path.length; i++) {
                    const dummyNode = path[i];
                    const p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());

        // update bendpoint's location according to dummy node
                    const ebp = lEdge.bendpoints.get(i);
                    ebp.x = p.x;
                    ebp.y = p.y;

        // remove the dummy node, dummy edges incident with this
        // dummy node is also removed (within the remove method)
                    dummyNode.getOwner().remove(dummyNode);
                  }

      // add the real edge to graph
                  this.graphManager.add(lEdge, lEdge.source, lEdge.target);
                }
              }
            };

            Layout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {
              if (minDiv != undefined && maxMul != undefined) {
                let value = defaultValue;

                if (sliderValue <= 50) {
                  const minValue = defaultValue / minDiv;
                  value -= (defaultValue - minValue) / 50 * (50 - sliderValue);
                } else {
                  const maxValue = defaultValue * maxMul;
                  value += (maxValue - defaultValue) / 50 * (sliderValue - 50);
                }

                return value;
              } else {
                let a, b;

                if (sliderValue <= 50) {
                  a = 9.0 * defaultValue / 500.0;
                  b = defaultValue / 10.0;
                } else {
                  a = 9.0 * defaultValue / 50.0;
                  b = -8 * defaultValue;
                }

                return a * sliderValue + b;
              }
            };

/**
 * This method finds and returns the center of the given nodes, assuming
 * that the given nodes form a tree in themselves.
 */
            Layout.findCenterOfTree = function (nodes) {
              let list = [];
              list = list.concat(nodes);

              let removedNodes = [];
              const remainingDegrees = new Map();
              let foundCenter = false;
              let centerNode = null;

              if (list.length == 1 || list.length == 2) {
                foundCenter = true;
                centerNode = list[0];
              }

              for (var i = 0; i < list.length; i++) {
                var node = list[i];
                const degree = node.getNeighborsList().size;
                remainingDegrees.set(node, node.getNeighborsList().size);

                if (degree == 1) {
                  removedNodes.push(node);
                }
              }

              let tempList = [];
              tempList = tempList.concat(removedNodes);

              while (!foundCenter) {
                let tempList2 = [];
                tempList2 = tempList2.concat(tempList);
                tempList = [];

                for (var i = 0; i < list.length; i++) {
                  var node = list[i];

                  const index = list.indexOf(node);
                  if (index >= 0) {
                    list.splice(index, 1);
                  }

                  const neighbours = node.getNeighborsList();

                  neighbours.forEach(function (neighbour) {
                    if (removedNodes.indexOf(neighbour) < 0) {
                      const otherDegree = remainingDegrees.get(neighbour);
                      const newDegree = otherDegree - 1;

                      if (newDegree == 1) {
                        tempList.push(neighbour);
                      }

                      remainingDegrees.set(neighbour, newDegree);
                    }
                  });
                }

                removedNodes = removedNodes.concat(tempList);

                if (list.length == 1 || list.length == 2) {
                  foundCenter = true;
                  centerNode = list[0];
                }
              }

              return centerNode;
            };

/**
 * During the coarsening process, this layout may be referenced by two graph managers
 * this setter function grants access to change the currently being used graph manager
 */
            Layout.prototype.setGraphManager = function (gm) {
              this.graphManager = gm;
            };

            module.exports = Layout;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

            "use strict";


            function RandomSeed() {}
// adapted from: https://stackoverflow.com/a/19303725
            RandomSeed.seed = 1;
            RandomSeed.x = 0;

            RandomSeed.nextDouble = function () {
              RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;
              return RandomSeed.x - Math.floor(RandomSeed.x);
            };

            module.exports = RandomSeed;

/***/ }),
/* 17 */
/***/ (function(module, exports, __nested_webpack_require_81860__) {

            "use strict";


            const PointD = __nested_webpack_require_81860__(4);

            function Transform(x, y) {
              this.lworldOrgX = 0.0;
              this.lworldOrgY = 0.0;
              this.ldeviceOrgX = 0.0;
              this.ldeviceOrgY = 0.0;
              this.lworldExtX = 1.0;
              this.lworldExtY = 1.0;
              this.ldeviceExtX = 1.0;
              this.ldeviceExtY = 1.0;
            }

            Transform.prototype.getWorldOrgX = function () {
              return this.lworldOrgX;
            };

            Transform.prototype.setWorldOrgX = function (wox) {
              this.lworldOrgX = wox;
            };

            Transform.prototype.getWorldOrgY = function () {
              return this.lworldOrgY;
            };

            Transform.prototype.setWorldOrgY = function (woy) {
              this.lworldOrgY = woy;
            };

            Transform.prototype.getWorldExtX = function () {
              return this.lworldExtX;
            };

            Transform.prototype.setWorldExtX = function (wex) {
              this.lworldExtX = wex;
            };

            Transform.prototype.getWorldExtY = function () {
              return this.lworldExtY;
            };

            Transform.prototype.setWorldExtY = function (wey) {
              this.lworldExtY = wey;
            };

/* Device related */

            Transform.prototype.getDeviceOrgX = function () {
              return this.ldeviceOrgX;
            };

            Transform.prototype.setDeviceOrgX = function (dox) {
              this.ldeviceOrgX = dox;
            };

            Transform.prototype.getDeviceOrgY = function () {
              return this.ldeviceOrgY;
            };

            Transform.prototype.setDeviceOrgY = function (doy) {
              this.ldeviceOrgY = doy;
            };

            Transform.prototype.getDeviceExtX = function () {
              return this.ldeviceExtX;
            };

            Transform.prototype.setDeviceExtX = function (dex) {
              this.ldeviceExtX = dex;
            };

            Transform.prototype.getDeviceExtY = function () {
              return this.ldeviceExtY;
            };

            Transform.prototype.setDeviceExtY = function (dey) {
              this.ldeviceExtY = dey;
            };

            Transform.prototype.transformX = function (x) {
              let xDevice = 0.0;
              const worldExtX = this.lworldExtX;
              if (worldExtX != 0.0) {
                xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;
              }

              return xDevice;
            };

            Transform.prototype.transformY = function (y) {
              let yDevice = 0.0;
              const worldExtY = this.lworldExtY;
              if (worldExtY != 0.0) {
                yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;
              }

              return yDevice;
            };

            Transform.prototype.inverseTransformX = function (x) {
              let xWorld = 0.0;
              const deviceExtX = this.ldeviceExtX;
              if (deviceExtX != 0.0) {
                xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;
              }

              return xWorld;
            };

            Transform.prototype.inverseTransformY = function (y) {
              let yWorld = 0.0;
              const deviceExtY = this.ldeviceExtY;
              if (deviceExtY != 0.0) {
                yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;
              }
              return yWorld;
            };

            Transform.prototype.inverseTransformPoint = function (inPoint) {
              const outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));
              return outPoint;
            };

            module.exports = Transform;

/***/ }),
/* 18 */
/***/ (function(module, exports, __nested_webpack_require_84747__) {

            "use strict";


            function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

            const Layout = __nested_webpack_require_84747__(15);
            const FDLayoutConstants = __nested_webpack_require_84747__(7);
            const LayoutConstants = __nested_webpack_require_84747__(0);
            const IGeometry = __nested_webpack_require_84747__(8);
            const IMath = __nested_webpack_require_84747__(9);

            function FDLayout() {
              Layout.call(this);

              this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;
              this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;
              this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;
              this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;
              this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;
              this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;
              this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;
              this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;
              this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;
              this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;
              this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;
              this.totalDisplacement = 0.0;
              this.oldTotalDisplacement = 0.0;
              this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;
            }

            FDLayout.prototype = Object.create(Layout.prototype);

            for (const prop in Layout) {
              FDLayout[prop] = Layout[prop];
            }

            FDLayout.prototype.initParameters = function () {
              Layout.prototype.initParameters.call(this, arguments);

              this.totalIterations = 0;
              this.notAnimatedIterations = 0;

              this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;

              this.grid = [];
            };

            FDLayout.prototype.calcIdealEdgeLengths = function () {
              let edge;
              let lcaDepth;
              let source;
              let target;
              let sizeOfSourceInLca;
              let sizeOfTargetInLca;

              const allEdges = this.getGraphManager().getAllEdges();
              for (let i = 0; i < allEdges.length; i++) {
                edge = allEdges[i];

                edge.idealLength = this.idealEdgeLength;

                if (edge.isInterGraph) {
                  source = edge.getSource();
                  target = edge.getTarget();

                  sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();
                  sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();

                  if (this.useSmartIdealEdgeLengthCalculation) {
                    edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;
                  }

                  lcaDepth = edge.getLca().getInclusionTreeDepth();

                  edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);
                }
              }
            };

            FDLayout.prototype.initSpringEmbedder = function () {

              const s = this.getAllNodes().length;
              if (this.incremental) {
                if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {
                  this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));
                }
                this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;
              } else {
                if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {
                  this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));
                } else {
                  this.coolingFactor = 1.0;
                }
                this.initialCoolingFactor = this.coolingFactor;
                this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;
              }

              this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);

              this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;

              this.repulsionRange = this.calcRepulsionRange();
            };

            FDLayout.prototype.calcSpringForces = function () {
              const lEdges = this.getAllEdges();
              let edge;

              for (let i = 0; i < lEdges.length; i++) {
                edge = lEdges[i];

                this.calcSpringForce(edge, edge.idealLength);
              }
            };

            FDLayout.prototype.calcRepulsionForces = function () {
              const gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
              const forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

              let i, j;
              let nodeA, nodeB;
              const lNodes = this.getAllNodes();
              let processedNodeSet;

              if (this.useFRGridVariant) {
                if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {
                  this.updateGrid();
                }

                processedNodeSet = new Set();

    // calculate repulsion forces between each nodes and its surrounding
                for (i = 0; i < lNodes.length; i++) {
                  nodeA = lNodes[i];
                  this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);
                  processedNodeSet.add(nodeA);
                }
              } else {
                for (i = 0; i < lNodes.length; i++) {
                  nodeA = lNodes[i];

                  for (j = i + 1; j < lNodes.length; j++) {
                    nodeB = lNodes[j];

        // If both nodes are not members of the same graph, skip.
                    if (nodeA.getOwner() != nodeB.getOwner()) {
                      continue;
                    }

                    this.calcRepulsionForce(nodeA, nodeB);
                  }
                }
              }
            };

            FDLayout.prototype.calcGravitationalForces = function () {
              let node;
              const lNodes = this.getAllNodesToApplyGravitation();

              for (let i = 0; i < lNodes.length; i++) {
                node = lNodes[i];
                this.calcGravitationalForce(node);
              }
            };

            FDLayout.prototype.moveNodes = function () {
              const lNodes = this.getAllNodes();
              let node;

              for (let i = 0; i < lNodes.length; i++) {
                node = lNodes[i];
                node.move();
              }
            };

            FDLayout.prototype.calcSpringForce = function (edge, idealLength) {
              const sourceNode = edge.getSource();
              const targetNode = edge.getTarget();

              let length;
              let springForce;
              let springForceX;
              let springForceY;

  // Update edge length
              if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {
                edge.updateLengthSimple();
              } else {
                edge.updateLength();

                if (edge.isOverlapingSourceAndTarget) {
                  return;
                }
              }

              length = edge.getLength();

              if (length == 0) return;

  // Calculate spring forces
              springForce = this.springConstant * (length - idealLength);

  // Project force onto x and y axes
              springForceX = springForce * (edge.lengthX / length);
              springForceY = springForce * (edge.lengthY / length);

  // Apply forces on the end nodes
              sourceNode.springForceX += springForceX;
              sourceNode.springForceY += springForceY;
              targetNode.springForceX -= springForceX;
              targetNode.springForceY -= springForceY;
            };

            FDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {
              const rectA = nodeA.getRect();
              const rectB = nodeB.getRect();
              const overlapAmount = new Array(2);
              const clipPoints = new Array(4);
              let distanceX;
              let distanceY;
              let distanceSquared;
              let distance;
              let repulsionForce;
              let repulsionForceX;
              let repulsionForceY;

              if (rectA.intersects(rectB)) // two nodes overlap
              {
      // calculate separation amount in x and y directions
                IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);

                repulsionForceX = 2 * overlapAmount[0];
                repulsionForceY = 2 * overlapAmount[1];

                const childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);

      // Apply forces on the two nodes
                nodeA.repulsionForceX -= childrenConstant * repulsionForceX;
                nodeA.repulsionForceY -= childrenConstant * repulsionForceY;
                nodeB.repulsionForceX += childrenConstant * repulsionForceX;
                nodeB.repulsionForceY += childrenConstant * repulsionForceY;
              } else // no overlap
              {
      // calculate distance

                if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers
                {
                  distanceX = rectB.getCenterX() - rectA.getCenterX();
                  distanceY = rectB.getCenterY() - rectA.getCenterY();
                } else // use clipping points
                {
                  IGeometry.getIntersection(rectA, rectB, clipPoints);

                  distanceX = clipPoints[2] - clipPoints[0];
                  distanceY = clipPoints[3] - clipPoints[1];
                }

      // No repulsion range. FR grid variant should take care of this.
                if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {
                  distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;
                }

                if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {
                  distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;
                }

                distanceSquared = distanceX * distanceX + distanceY * distanceY;
                distance = Math.sqrt(distanceSquared);

                repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;

      // Project force onto x and y axes
                repulsionForceX = repulsionForce * distanceX / distance;
                repulsionForceY = repulsionForce * distanceY / distance;

      // Apply forces on the two nodes    
                nodeA.repulsionForceX -= repulsionForceX;
                nodeA.repulsionForceY -= repulsionForceY;
                nodeB.repulsionForceX += repulsionForceX;
                nodeB.repulsionForceY += repulsionForceY;
              }
            };

            FDLayout.prototype.calcGravitationalForce = function (node) {
              let ownerGraph;
              let ownerCenterX;
              let ownerCenterY;
              let distanceX;
              let distanceY;
              let absDistanceX;
              let absDistanceY;
              let estimatedSize;
              ownerGraph = node.getOwner();

              ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;
              ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;
              distanceX = node.getCenterX() - ownerCenterX;
              distanceY = node.getCenterY() - ownerCenterY;
              absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;
              absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;

              if (node.getOwner() == this.graphManager.getRoot()) // in the root graph
              {
                estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;

                if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {
                  node.gravitationForceX = -this.gravityConstant * distanceX;
                  node.gravitationForceY = -this.gravityConstant * distanceY;
                }
              } else // inside a compound
              {
                estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;

                if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {
                  node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;
                  node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;
                }
              }
            };

            FDLayout.prototype.isConverged = function () {
              let converged;
              let oscilating = false;

              if (this.totalIterations > this.maxIterations / 3) {
                oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;
              }

              converged = this.totalDisplacement < this.totalDisplacementThreshold;

              this.oldTotalDisplacement = this.totalDisplacement;

              return converged || oscilating;
            };

            FDLayout.prototype.animate = function () {
              if (this.animationDuringLayout && !this.isSubLayout) {
                if (this.notAnimatedIterations == this.animationPeriod) {
                  this.update();
                  this.notAnimatedIterations = 0;
                } else {
                  this.notAnimatedIterations++;
                }
              }
            };

//This method calculates the number of children (weight) for all nodes
            FDLayout.prototype.calcNoOfChildrenForAllNodes = function () {
              let node;
              const allNodes = this.graphManager.getAllNodes();

              for (let i = 0; i < allNodes.length; i++) {
                node = allNodes[i];
                node.noOfChildren = node.getNoOfChildren();
              }
            };

// -----------------------------------------------------------------------------
// Section: FR-Grid Variant Repulsion Force Calculation
// -----------------------------------------------------------------------------

            FDLayout.prototype.calcGrid = function (graph) {

              let sizeX = 0;
              let sizeY = 0;

              sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));
              sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));

              const grid = new Array(sizeX);

              for (var i = 0; i < sizeX; i++) {
                grid[i] = new Array(sizeY);
              }

              for (var i = 0; i < sizeX; i++) {
                for (let j = 0; j < sizeY; j++) {
                  grid[i][j] = [];
                }
              }

              return grid;
            };

            FDLayout.prototype.addNodeToGrid = function (v, left, top) {

              let startX = 0;
              let finishX = 0;
              let startY = 0;
              let finishY = 0;

              startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));
              finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));
              startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));
              finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));

              for (let i = startX; i <= finishX; i++) {
                for (let j = startY; j <= finishY; j++) {
                  this.grid[i][j].push(v);
                  v.setGridCoordinates(startX, finishX, startY, finishY);
                }
              }
            };

            FDLayout.prototype.updateGrid = function () {
              let i;
              let nodeA;
              const lNodes = this.getAllNodes();

              this.grid = this.calcGrid(this.graphManager.getRoot());

  // put all nodes to proper grid cells
              for (i = 0; i < lNodes.length; i++) {
                nodeA = lNodes[i];
                this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());
              }
            };

            FDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {

              if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {
                const surrounding = new Set();
                nodeA.surrounding = [];
                let nodeB;
                const grid = this.grid;

                for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {
                  for (let j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {
                    if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {
                      for (let k = 0; k < grid[i][j].length; k++) {
                        nodeB = grid[i][j][k];

            // If both nodes are not members of the same graph, 
            // or both nodes are the same, skip.
                        if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {
                          continue;
                        }

            // check if the repulsion force between
            // nodeA and nodeB has already been calculated
                        if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {
                          const distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);
                          const distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);

              // if the distance between nodeA and nodeB 
              // is less then calculation range
                          if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {
                //then add nodeB to surrounding of nodeA
                            surrounding.add(nodeB);
                          }
                        }
                      }
                    }
                  }
                }

                nodeA.surrounding = [].concat(_toConsumableArray(surrounding));
              }
              for (i = 0; i < nodeA.surrounding.length; i++) {
                this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);
              }
            };

            FDLayout.prototype.calcRepulsionRange = function () {
              return 0.0;
            };

            module.exports = FDLayout;

/***/ }),
/* 19 */
/***/ (function(module, exports, __nested_webpack_require_100902__) {

            "use strict";


            const LEdge = __nested_webpack_require_100902__(1);
            const FDLayoutConstants = __nested_webpack_require_100902__(7);

            function FDLayoutEdge(source, target, vEdge) {
              LEdge.call(this, source, target, vEdge);
              this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;
            }

            FDLayoutEdge.prototype = Object.create(LEdge.prototype);

            for (const prop in LEdge) {
              FDLayoutEdge[prop] = LEdge[prop];
            }

            module.exports = FDLayoutEdge;

/***/ }),
/* 20 */
/***/ (function(module, exports, __nested_webpack_require_101387__) {

            "use strict";


            const LNode = __nested_webpack_require_101387__(3);

            function FDLayoutNode(gm, loc, size, vNode) {
  // alternative constructor is handled inside LNode
              LNode.call(this, gm, loc, size, vNode);
  //Spring, repulsion and gravitational forces acting on this node
              this.springForceX = 0;
              this.springForceY = 0;
              this.repulsionForceX = 0;
              this.repulsionForceY = 0;
              this.gravitationForceX = 0;
              this.gravitationForceY = 0;
  //Amount by which this node is to be moved in this iteration
              this.displacementX = 0;
              this.displacementY = 0;

  //Start and finish grid coordinates that this node is fallen into
              this.startX = 0;
              this.finishX = 0;
              this.startY = 0;
              this.finishY = 0;

  //Geometric neighbors of this node
              this.surrounding = [];
            }

            FDLayoutNode.prototype = Object.create(LNode.prototype);

            for (const prop in LNode) {
              FDLayoutNode[prop] = LNode[prop];
            }

            FDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {
              this.startX = _startX;
              this.finishX = _finishX;
              this.startY = _startY;
              this.finishY = _finishY;
            };

            module.exports = FDLayoutNode;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

            "use strict";


            function DimensionD(width, height) {
              this.width = 0;
              this.height = 0;
              if (width !== null && height !== null) {
                this.height = height;
                this.width = width;
              }
            }

            DimensionD.prototype.getWidth = function () {
              return this.width;
            };

            DimensionD.prototype.setWidth = function (width) {
              this.width = width;
            };

            DimensionD.prototype.getHeight = function () {
              return this.height;
            };

            DimensionD.prototype.setHeight = function (height) {
              this.height = height;
            };

            module.exports = DimensionD;

/***/ }),
/* 22 */
/***/ (function(module, exports, __nested_webpack_require_103173__) {

            "use strict";


            const UniqueIDGeneretor = __nested_webpack_require_103173__(14);

            function HashMap() {
              this.map = {};
              this.keys = [];
            }

            HashMap.prototype.put = function (key, value) {
              const theId = UniqueIDGeneretor.createID(key);
              if (!this.contains(theId)) {
                this.map[theId] = value;
                this.keys.push(key);
              }
            };

            HashMap.prototype.contains = function (key) {
              const theId = UniqueIDGeneretor.createID(key);
              return this.map[key] != null;
            };

            HashMap.prototype.get = function (key) {
              const theId = UniqueIDGeneretor.createID(key);
              return this.map[theId];
            };

            HashMap.prototype.keySet = function () {
              return this.keys;
            };

            module.exports = HashMap;

/***/ }),
/* 23 */
/***/ (function(module, exports, __nested_webpack_require_103901__) {

            "use strict";


            const UniqueIDGeneretor = __nested_webpack_require_103901__(14);

            function HashSet() {
              this.set = {};
            }
            

            HashSet.prototype.add = function (obj) {
              const theId = UniqueIDGeneretor.createID(obj);
              if (!this.contains(theId)) this.set[theId] = obj;
            };

            HashSet.prototype.remove = function (obj) {
              delete this.set[UniqueIDGeneretor.createID(obj)];
            };

            HashSet.prototype.clear = function () {
              this.set = {};
            };

            HashSet.prototype.contains = function (obj) {
              return this.set[UniqueIDGeneretor.createID(obj)] == obj;
            };

            HashSet.prototype.isEmpty = function () {
              return this.size() === 0;
            };

            HashSet.prototype.size = function () {
              return Object.keys(this.set).length;
            };

//concats this.set to the given list
            HashSet.prototype.addAllTo = function (list) {
              const keys = Object.keys(this.set);
              const length = keys.length;
              for (let i = 0; i < length; i++) {
                list.push(this.set[keys[i]]);
              }
            };

            HashSet.prototype.size = function () {
              return Object.keys(this.set).length;
            };

            HashSet.prototype.addAll = function (list) {
              const s = list.length;
              for (let i = 0; i < s; i++) {
                const v = list[i];
                this.add(v);
              }
            };

            module.exports = HashSet;

/***/ }),
/* 24 */
/***/ (function(module, exports, __nested_webpack_require_105138__) {

            "use strict";


            const _createClass = function () { function defineProperties(target, props) { for (let i = 0; i < props.length; i++) { const descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A classic Quicksort algorithm with Hoare's partition
 * - Works also on LinkedList objects
 *
 * Copyright: i-Vis Research Group, Bilkent University, 2007 - present
 */

            const LinkedList = __nested_webpack_require_105138__(11);

            const Quicksort = function () {
              function Quicksort(A, compareFunction) {
                _classCallCheck(this, Quicksort);

                if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;

                let length = void 0;
                if (A instanceof LinkedList) length = A.size();else length = A.length;

                this._quicksort(A, 0, length - 1);
              }

              _createClass(Quicksort, [{
                key: '_quicksort',
                value: function _quicksort(A, p, r) {
                  if (p < r) {
                    const q = this._partition(A, p, r);
                    this._quicksort(A, p, q);
                    this._quicksort(A, q + 1, r);
                  }
                }
              }, {
                key: '_partition',
                value: function _partition(A, p, r) {
                  const x = this._get(A, p);
                  let i = p;
                  let j = r;
                  while (true) {
                    while (this.compareFunction(x, this._get(A, j))) {
                      j--;
                    }while (this.compareFunction(this._get(A, i), x)) {
                      i++;
                    }if (i < j) {
                      this._swap(A, i, j);
                      i++;
                      j--;
                    } else return j;
                  }
                }
              }, {
                key: '_get',
                value: function _get(object, index) {
                  if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];
                }
              }, {
                key: '_set',
                value: function _set(object, index, value) {
                  if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;
                }
              }, {
                key: '_swap',
                value: function _swap(A, i, j) {
                  const temp = this._get(A, i);
                  this._set(A, i, this._get(A, j));
                  this._set(A, j, temp);
                }
              }, {
                key: '_defaultCompareFunction',
                value: function _defaultCompareFunction(a, b) {
                  return b > a;
                }
              }]);

              return Quicksort;
            }();

            module.exports = Quicksort;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

            "use strict";


            const _createClass = function () { function defineProperties(target, props) { for (let i = 0; i < props.length; i++) { const descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string
 *   sequences by S.B.Needleman and C.D.Wunsch (1970).
 *
 *   Aside from the inputs, you can assign the scores for,
 *   - Match: The two characters at the current index are same.
 *   - Mismatch: The two characters at the current index are different.
 *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.
 */

            const NeedlemanWunsch = function () {
              function NeedlemanWunsch(sequence1, sequence2) {
                const match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
                const mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
                const gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;

                _classCallCheck(this, NeedlemanWunsch);

                this.sequence1 = sequence1;
                this.sequence2 = sequence2;
                this.match_score = match_score;
                this.mismatch_penalty = mismatch_penalty;
                this.gap_penalty = gap_penalty;

        // Just the remove redundancy
                this.iMax = sequence1.length + 1;
                this.jMax = sequence2.length + 1;

        // Grid matrix of scores
                this.grid = new Array(this.iMax);
                for (let i = 0; i < this.iMax; i++) {
                  this.grid[i] = new Array(this.jMax);

                  for (let j = 0; j < this.jMax; j++) {
                    this.grid[i][j] = 0;
                  }
                }

        // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)
                this.tracebackGrid = new Array(this.iMax);
                for (let _i = 0; _i < this.iMax; _i++) {
                  this.tracebackGrid[_i] = new Array(this.jMax);

                  for (let _j = 0; _j < this.jMax; _j++) {
                    this.tracebackGrid[_i][_j] = [null, null, null];
                  }
                }

        // The aligned sequences (return multiple possibilities)
                this.alignments = [];

        // Final alignment score
                this.score = -1;

        // Calculate scores and tracebacks
                this.computeGrids();
              }

              _createClass(NeedlemanWunsch, [{
                key: "getScore",
                value: function getScore() {
                  return this.score;
                }
              }, {
                key: "getAlignments",
                value: function getAlignments() {
                  return this.alignments;
                }

        // Main dynamic programming procedure

              }, {
                key: "computeGrids",
                value: function computeGrids() {
            // Fill in the first row
                  for (let j = 1; j < this.jMax; j++) {
                    this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;
                    this.tracebackGrid[0][j] = [false, false, true];
                  }

            // Fill in the first column
                  for (let i = 1; i < this.iMax; i++) {
                    this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;
                    this.tracebackGrid[i][0] = [false, true, false];
                  }

            // Fill the rest of the grid
                  for (let _i2 = 1; _i2 < this.iMax; _i2++) {
                    for (let _j2 = 1; _j2 < this.jMax; _j2++) {
                    // Find the max score(s) among [`Diag`, `Up`, `Left`]
                      let diag = void 0;
                      if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;

                      const up = this.grid[_i2 - 1][_j2] + this.gap_penalty;
                      const left = this.grid[_i2][_j2 - 1] + this.gap_penalty;

                    // If there exists multiple max values, capture them for multiple paths
                      const maxOf = [diag, up, left];
                      const indices = this.arrayAllMaxIndexes(maxOf);

                    // Update Grids
                      this.grid[_i2][_j2] = maxOf[indices[0]];
                      this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];
                    }
                  }

            // Update alignment score
                  this.score = this.grid[this.iMax - 1][this.jMax - 1];
                }

        // Gets all possible valid sequence combinations

              }, {
                key: "alignmentTraceback",
                value: function alignmentTraceback() {
                  const inProcessAlignments = [];

                  inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],
                    seq1: "",
                    seq2: ""
                  });

                  while (inProcessAlignments[0]) {
                    const current = inProcessAlignments[0];
                    const directions = this.tracebackGrid[current.pos[0]][current.pos[1]];

                    if (directions[0]) {
                      inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],
                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,
                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2
                      });
                    }
                    if (directions[1]) {
                      inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],
                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,
                        seq2: '-' + current.seq2
                      });
                    }
                    if (directions[2]) {
                      inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],
                        seq1: '-' + current.seq1,
                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2
                      });
                    }

                    if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,
                      sequence2: current.seq2
                    });

                    inProcessAlignments.shift();
                  }

                  return this.alignments;
                }

        // Helper Functions

              }, {
                key: "getAllIndexes",
                value: function getAllIndexes(arr, val) {
                  let indexes = [],
                    i = -1;
                  while ((i = arr.indexOf(val, i + 1)) !== -1) {
                    indexes.push(i);
                  }
                  return indexes;
                }
              }, {
                key: "arrayAllMaxIndexes",
                value: function arrayAllMaxIndexes(array) {
                  return this.getAllIndexes(array, Math.max.apply(null, array));
                }
              }]);

              return NeedlemanWunsch;
            }();

            module.exports = NeedlemanWunsch;

/***/ }),
/* 26 */
/***/ (function(module, exports, __nested_webpack_require_115611__) {

            "use strict";


            const layoutBase = function layoutBase() {
              return;
            };

            layoutBase.FDLayout = __nested_webpack_require_115611__(18);
            layoutBase.FDLayoutConstants = __nested_webpack_require_115611__(7);
            layoutBase.FDLayoutEdge = __nested_webpack_require_115611__(19);
            layoutBase.FDLayoutNode = __nested_webpack_require_115611__(20);
            layoutBase.DimensionD = __nested_webpack_require_115611__(21);
            layoutBase.HashMap = __nested_webpack_require_115611__(22);
            layoutBase.HashSet = __nested_webpack_require_115611__(23);
            layoutBase.IGeometry = __nested_webpack_require_115611__(8);
            layoutBase.IMath = __nested_webpack_require_115611__(9);
            layoutBase.Integer = __nested_webpack_require_115611__(10);
            layoutBase.Point = __nested_webpack_require_115611__(12);
            layoutBase.PointD = __nested_webpack_require_115611__(4);
            layoutBase.RandomSeed = __nested_webpack_require_115611__(16);
            layoutBase.RectangleD = __nested_webpack_require_115611__(13);
            layoutBase.Transform = __nested_webpack_require_115611__(17);
            layoutBase.UniqueIDGeneretor = __nested_webpack_require_115611__(14);
            layoutBase.Quicksort = __nested_webpack_require_115611__(24);
            layoutBase.LinkedList = __nested_webpack_require_115611__(11);
            layoutBase.LGraphObject = __nested_webpack_require_115611__(2);
            layoutBase.LGraph = __nested_webpack_require_115611__(5);
            layoutBase.LEdge = __nested_webpack_require_115611__(1);
            layoutBase.LGraphManager = __nested_webpack_require_115611__(6);
            layoutBase.LNode = __nested_webpack_require_115611__(3);
            layoutBase.Layout = __nested_webpack_require_115611__(15);
            layoutBase.LayoutConstants = __nested_webpack_require_115611__(0);
            layoutBase.NeedlemanWunsch = __nested_webpack_require_115611__(25);

            module.exports = layoutBase;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

            "use strict";


            function Emitter() {
              this.listeners = [];
            }

            const p = Emitter.prototype;

            p.addListener = function (event, callback) {
              this.listeners.push({
                event: event,
                callback: callback
              });
            };

            p.removeListener = function (event, callback) {
              for (let i = this.listeners.length; i >= 0; i--) {
                const l = this.listeners[i];

                if (l.event === event && l.callback === callback) {
                  this.listeners.splice(i, 1);
                }
              }
            };

            p.emit = function (event, data) {
              for (let i = 0; i < this.listeners.length; i++) {
                const l = this.listeners[i];

                if (event === l.event) {
                  l.callback(data);
                }
              }
            };

            module.exports = Emitter;

/***/ })
/******/ ]);
      });

/***/ }),

/***/ "./node_modules/lodash.debounce/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.debounce/index.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
      const FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
      const NAN = 0 / 0;

/** `Object#toString` result references. */
      const symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
      const reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
      const reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
      const reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
      const reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
      const freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
      const freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
      const freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
      const root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
      const objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
      const objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
      const nativeMax = Math.max,
        nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
      const now = function() {
        return root.Date.now();
      };

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
      function debounce(func, wait, options) {
        let lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = 'maxWait' in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
          const args = lastArgs,
            thisArg = lastThis;

          lastArgs = lastThis = undefined;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }

        function leadingEdge(time) {
    // Reset any `maxWait` timer.
          lastInvokeTime = time;
    // Start the timer for the trailing edge.
          timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
          return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
          const timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            result = wait - timeSinceLastCall;

          return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
        }

        function shouldInvoke(time) {
          const timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
          return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
        }

        function timerExpired() {
          const time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
    // Restart the timer.
          timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
          timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined;
          return result;
        }

        function cancel() {
          if (timerId !== undefined) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined;
        }

        function flush() {
          return timerId === undefined ? result : trailingEdge(now());
        }

        function debounced() {
          const time = now(),
            isInvoking = shouldInvoke(time);

          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;

          if (isInvoking) {
            if (timerId === undefined) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
        // Handle invocations in a tight loop.
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
      function isObject(value) {
        const type = typeof value;
        return !!value && (type == 'object' || type == 'function');
      }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
      function isObjectLike(value) {
        return !!value && typeof value == 'object';
      }

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
      function isSymbol(value) {
        return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
      }

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
      function toNumber(value) {
        if (typeof value == 'number') {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          const other = typeof value.valueOf == 'function' ? value.valueOf() : value;
          value = isObject(other) ? (other + '') : other;
        }
        if (typeof value != 'string') {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, '');
        const isBinary = reIsBinary.test(value);
        return (isBinary || reIsOctal.test(value))
          ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
          : (reIsBadHex.test(value) ? NAN : +value);
      }

      module.exports = debounce;


/***/ }),

/***/ "./node_modules/lodash.isequal/index.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash.isequal/index.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
      const LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
      const HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for value comparisons. */
      const COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;

/** Used as references for various `Number` constants. */
      const MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
      const argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        asyncTag = '[object AsyncFunction]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        nullTag = '[object Null]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        proxyTag = '[object Proxy]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        undefinedTag = '[object Undefined]',
        weakMapTag = '[object WeakMap]';

      const arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
      const reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
      const reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
      const reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
      const typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
      const freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
      const freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
      const root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
      const freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
      const freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
      const moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
      const freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
      const nodeUtil = (function() {
        try {
          return freeProcess && freeProcess.binding && freeProcess.binding('util');
        } catch (e) {}
      }());

/* Node.js helper references. */
      const nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
      function arrayFilter(array, predicate) {
        let index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

        while (++index < length) {
          const value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
      function arrayPush(array, values) {
        let index = -1,
          length = values.length,
          offset = array.length;

        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
      function arraySome(array, predicate) {
        let index = -1,
          length = array == null ? 0 : array.length;

        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
      function baseTimes(n, iteratee) {
        let index = -1,
          result = Array(n);

        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
      function cacheHas(cache, key) {
        return cache.has(key);
      }

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
      function getValue(object, key) {
        return object == null ? undefined : object[key];
      }

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
      function mapToArray(map) {
        let index = -1,
          result = Array(map.size);

        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
      function setToArray(set) {
        let index = -1,
          result = Array(set.size);

        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }

/** Used for built-in method references. */
      const arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
      const coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
      const funcToString = funcProto.toString;

/** Used to check objects for own properties. */
      const hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
      const maskSrcKey = (function() {
        const uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
        return uid ? ('Symbol(src)_1.' + uid) : '';
      }());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
      const nativeObjectToString = objectProto.toString;

/** Used to detect if a method is native. */
      const reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
      );

/** Built-in value references. */
      const Buffer = moduleExports ? root.Buffer : undefined,
        Symbol = root.Symbol,
        Uint8Array = root.Uint8Array,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
      const nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
      const DataView = getNative(root, 'DataView'),
        Map = getNative(root, 'Map'),
        Promise = getNative(root, 'Promise'),
        Set = getNative(root, 'Set'),
        WeakMap = getNative(root, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
      const dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
      const symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
      function Hash(entries) {
        let index = -1,
          length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
          const entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
      function hashDelete(key) {
        const result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
      function hashGet(key) {
        const data = this.__data__;
        if (nativeCreate) {
          const result = data[key];
          return result === HASH_UNDEFINED ? undefined : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined;
      }

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
      function hashHas(key) {
        const data = this.__data__;
        return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
      }

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
      function hashSet(key, value) {
        const data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
        return this;
      }

// Add methods to `Hash`.
      Hash.prototype.clear = hashClear;
      Hash.prototype['delete'] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
      function ListCache(entries) {
        let index = -1,
          length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
          const entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
      function listCacheDelete(key) {
        const data = this.__data__,
          index = assocIndexOf(data, key);

        if (index < 0) {
          return false;
        }
        const lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
      function listCacheGet(key) {
        const data = this.__data__,
          index = assocIndexOf(data, key);

        return index < 0 ? undefined : data[index][1];
      }

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
      function listCacheSet(key, value) {
        const data = this.__data__,
          index = assocIndexOf(data, key);

        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }

// Add methods to `ListCache`.
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype['delete'] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
      function MapCache(entries) {
        let index = -1,
          length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
          const entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          'hash': new Hash,
          'map': new (Map || ListCache),
          'string': new Hash
        };
      }

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
      function mapCacheDelete(key) {
        const result = getMapData(this, key)['delete'](key);
        this.size -= result ? 1 : 0;
        return result;
      }

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
      function mapCacheSet(key, value) {
        const data = getMapData(this, key),
          size = data.size;

        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }

// Add methods to `MapCache`.
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype['delete'] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
      function SetCache(values) {
        let index = -1,
          length = values == null ? 0 : values.length;

        this.__data__ = new MapCache;
        while (++index < length) {
          this.add(values[index]);
        }
      }

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
      function setCacheHas(value) {
        return this.__data__.has(value);
      }

// Add methods to `SetCache`.
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
      function Stack(entries) {
        const data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
      function stackClear() {
        this.__data__ = new ListCache;
        this.size = 0;
      }

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
      function stackDelete(key) {
        const data = this.__data__,
          result = data['delete'](key);

        this.size = data.size;
        return result;
      }

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
      function stackGet(key) {
        return this.__data__.get(key);
      }

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
      function stackHas(key) {
        return this.__data__.has(key);
      }

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
      function stackSet(key, value) {
        let data = this.__data__;
        if (data instanceof ListCache) {
          const pairs = data.__data__;
          if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }

// Add methods to `Stack`.
      Stack.prototype.clear = stackClear;
      Stack.prototype['delete'] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
      function arrayLikeKeys(value, inherited) {
        const isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

        for (const key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
          key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
            result.push(key);
          }
        }
        return result;
      }

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
      function assocIndexOf(array, key) {
        let length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        const result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined ? undefinedTag : nullTag;
        }
        return (symToStringTag && symToStringTag in Object(value))
          ? getRawTag(value)
          : objectToString(value);
      }

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        let objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;

        let objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack);
          return (objIsArr || isTypedArray(object))
            ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
            : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          const objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

          if (objIsWrapped || othIsWrapped) {
            const objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        const pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
      function baseIsTypedArray(value) {
        return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        const result = [];
        for (const key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
          }
        }
        return result;
      }

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        const isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
  // Assume cyclic values are equal.
        const stacked = stack.get(array);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        let index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

        stack.set(array, other);
        stack.set(other, array);

  // Ignore non-index properties.
        while (++index < arrLength) {
          var arrValue = array[index],
            othValue = other[index];

          if (customizer) {
            var compared = isPartial
              ? customizer(othValue, arrValue, index, other, array, stack)
              : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
    // Recursively compare arrays (susceptible to call stack limits).
          if (seen) {
            if (!arraySome(other, function(othValue, othIndex) {
              if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(
            arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
            result = false;
            break;
          }
        }
        stack['delete'](array);
        stack['delete'](other);
        return result;
      }

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;

          case arrayBufferTag:
            if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
              return false;
            }
            return true;

          case boolTag:
          case dateTag:
          case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
            return eq(+object, +other);

          case errorTag:
            return object.name == other.name && object.message == other.message;

          case regexpTag:
          case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
            return object == (other + '');

          case mapTag:
            var convert = mapToArray;

          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);

            if (object.size != other.size && !isPartial) {
              return false;
            }
      // Assume cyclic values are equal.
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack['delete'](object);
            return result;

          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        const isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

        if (objLength != othLength && !isPartial) {
          return false;
        }
        let index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
  // Assume cyclic values are equal.
        const stacked = stack.get(object);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        let result = true;
        stack.set(object, other);
        stack.set(other, object);

        let skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          const objValue = object[key],
            othValue = other[key];

          if (customizer) {
            var compared = isPartial
              ? customizer(othValue, objValue, key, other, object, stack)
              : customizer(objValue, othValue, key, object, other, stack);
          }
    // Recursively compare objects (susceptible to call stack limits).
          if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == 'constructor');
        }
        if (result && !skipCtor) {
          const objCtor = object.constructor,
            othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
          if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack['delete'](object);
        stack['delete'](other);
        return result;
      }

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
      function getMapData(map, key) {
        const data = map.__data__;
        return isKeyable(key)
          ? data[typeof key == 'string' ? 'string' : 'hash']
          : data.map;
      }

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
      function getNative(object, key) {
        const value = getValue(object, key);
        return baseIsNative(value) ? value : undefined;
      }

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
      function getRawTag(value) {
        const isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

        try {
          value[symToStringTag] = undefined;
          var unmasked = true;
        } catch (e) {}

        const result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
      var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
      if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
        getTag = function(value) {
          const result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString: return dataViewTag;
              case mapCtorString: return mapTag;
              case promiseCtorString: return promiseTag;
              case setCtorString: return setTag;
              case weakMapCtorString: return weakMapTag;
            }
          }
          return result;
        };
      }

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
      function isIndex(value, length) {
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
      }

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
      function isKeyable(value) {
        const type = typeof value;
        return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
          ? (value !== '__proto__')
          : (value === null);
      }

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
      function isMasked(func) {
        return !!maskSrcKey && (maskSrcKey in func);
      }

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
      function isPrototype(value) {
        const Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

        return value === proto;
      }

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {}
          try {
            return (func + '');
          } catch (e) {}
        }
        return '';
      }

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
      function eq(value, other) {
        return value === other || (value !== value && other !== other);
      }

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
      var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
      };

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
      var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
      var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
        const tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
      function isLength(value) {
        return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
      function isObject(value) {
        const type = typeof value;
        return value != null && (type == 'object' || type == 'function');
      }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
      function isObjectLike(value) {
        return value != null && typeof value == 'object';
      }

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
      function stubArray() {
        return [];
      }

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
      function stubFalse() {
        return false;
      }

      module.exports = isEqual;


/***/ }),

/***/ "./node_modules/lodash.throttle/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.throttle/index.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
      const FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
      const NAN = 0 / 0;

/** `Object#toString` result references. */
      const symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
      const reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
      const reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
      const reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
      const reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
      const freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
      const freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
      const freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
      const root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
      const objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
      const objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
      const nativeMax = Math.max,
        nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
      const now = function() {
        return root.Date.now();
      };

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
      function debounce(func, wait, options) {
        let lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = 'maxWait' in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
          const args = lastArgs,
            thisArg = lastThis;

          lastArgs = lastThis = undefined;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }

        function leadingEdge(time) {
    // Reset any `maxWait` timer.
          lastInvokeTime = time;
    // Start the timer for the trailing edge.
          timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
          return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
          const timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            result = wait - timeSinceLastCall;

          return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
        }

        function shouldInvoke(time) {
          const timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
          return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
        }

        function timerExpired() {
          const time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
    // Restart the timer.
          timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
          timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined;
          return result;
        }

        function cancel() {
          if (timerId !== undefined) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined;
        }

        function flush() {
          return timerId === undefined ? result : trailingEdge(now());
        }

        function debounced() {
          const time = now(),
            isInvoking = shouldInvoke(time);

          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;

          if (isInvoking) {
            if (timerId === undefined) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
        // Handle invocations in a tight loop.
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
      function throttle(func, wait, options) {
        let leading = true,
          trailing = true;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = 'leading' in options ? !!options.leading : leading;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          'leading': leading,
          'maxWait': wait,
          'trailing': trailing
        });
      }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
      function isObject(value) {
        const type = typeof value;
        return !!value && (type == 'object' || type == 'function');
      }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
      function isObjectLike(value) {
        return !!value && typeof value == 'object';
      }

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
      function isSymbol(value) {
        return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
      }

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
      function toNumber(value) {
        if (typeof value == 'number') {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          const other = typeof value.valueOf == 'function' ? value.valueOf() : value;
          value = isObject(other) ? (other + '') : other;
        }
        if (typeof value != 'string') {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, '');
        const isBinary = reIsBinary.test(value);
        return (isBinary || reIsOctal.test(value))
          ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
          : (reIsBadHex.test(value) ? NAN : +value);
      }

      module.exports = throttle;


/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/***/ ((module) => {

      "use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
      const getOwnPropertySymbols = Object.getOwnPropertySymbols;
      const hasOwnProperty = Object.prototype.hasOwnProperty;
      const propIsEnumerable = Object.prototype.propertyIsEnumerable;

      function toObject(val) {
        if (val === null || val === undefined) {
          throw new TypeError('Object.assign cannot be called with null or undefined');
        }

        return Object(val);
      }

      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
          const test1 = new String('abc');  // eslint-disable-line no-new-wrappers
          test1[5] = 'de';
          if (Object.getOwnPropertyNames(test1)[0] === '5') {
            return false;
          }

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
          const test2 = {};
          for (let i = 0; i < 10; i++) {
            test2['_' + String.fromCharCode(i)] = i;
          }
          const order2 = Object.getOwnPropertyNames(test2).map(function (n) {
            return test2[n];
          });
          if (order2.join('') !== '0123456789') {
            return false;
          }

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
          const test3 = {};
          'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
            return false;
          }

          return true;
        } catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
          return false;
        }
      }

      module.exports = shouldUseNative() ? Object.assign : function (target, source) {
        let from;
        const to = toObject(target);
        let symbols;

        for (let s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);

          for (const key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }

          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (let i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }

        return to;
      };


/***/ }),

/***/ "./node_modules/performance-now/lib/performance-now.js":
/*!*************************************************************!*\
  !*** ./node_modules/performance-now/lib/performance-now.js ***!
  \*************************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.2
      (function() {
        let getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

        if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
          module.exports = function() {
            return performance.now();
          };
        } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
          module.exports = function() {
            return (getNanoSeconds() - nodeLoadTime) / 1e6;
          };
          hrtime = process.hrtime;
          getNanoSeconds = function() {
            let hr;
            hr = hrtime();
            return hr[0] * 1e9 + hr[1];
          };
          moduleLoadTime = getNanoSeconds();
          upTime = process.uptime() * 1e9;
          nodeLoadTime = moduleLoadTime - upTime;
        } else if (Date.now) {
          module.exports = function() {
            return Date.now() - loadTime;
          };
          loadTime = Date.now();
        } else {
          module.exports = function() {
            return new Date().getTime() - loadTime;
          };
          loadTime = new Date().getTime();
        }

      }).call(this);

//# sourceMappingURL=performance-now.js.map


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



      let printWarning = function() {};

      if (true) {
        var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
        var loggedTypeFailures = {};
        var has = Function.call.bind(Object.prototype.hasOwnProperty);

        printWarning = function(text) {
          const message = 'Warning: ' + text;
          if (typeof console !== 'undefined') {
            console.error(message);
          }
          try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
            throw new Error(message);
          } catch (x) {}
        };
      }

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
      function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
        if (true) {
          for (const typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
              try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
                if (typeof typeSpecs[typeSpecName] !== 'function') {
                  const err = Error(
                    (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
                  );
                  err.name = 'Invariant Violation';
                  throw err;
                }
                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
              } catch (ex) {
                error = ex;
              }
              if (error && !(error instanceof Error)) {
                printWarning(
                  (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
                );
              }
              if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
                loggedTypeFailures[error.message] = true;

                const stack = getStack ? getStack() : '';

                printWarning(
                  'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
                );
              }
            }
          }
        }
      }

/**
 * Resets warning cache when testing.
 *
 * @private
 */
      checkPropTypes.resetWarningCache = function() {
        if (true) {
          loggedTypeFailures = {};
        }
      }

      module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



      const ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
      const assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

      const ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
      const checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

      const has = Function.call.bind(Object.prototype.hasOwnProperty);
      let printWarning = function() {};

      if (true) {
        printWarning = function(text) {
          const message = 'Warning: ' + text;
          if (typeof console !== 'undefined') {
            console.error(message);
          }
          try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
            throw new Error(message);
          } catch (x) {}
        };
      }

      function emptyFunctionThatReturnsNull() {
        return null;
      }

      module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
        const ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
        const FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
        function getIteratorFn(maybeIterable) {
          const iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === 'function') {
            return iteratorFn;
          }
        }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

        const ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
        const ReactPropTypes = {
          array: createPrimitiveTypeChecker('array'),
          bool: createPrimitiveTypeChecker('boolean'),
          func: createPrimitiveTypeChecker('function'),
          number: createPrimitiveTypeChecker('number'),
          object: createPrimitiveTypeChecker('object'),
          string: createPrimitiveTypeChecker('string'),
          symbol: createPrimitiveTypeChecker('symbol'),

          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          elementType: createElementTypeTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker,
        };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
        function is(x, y) {
    // SameValue algorithm
          if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
            return x !== 0 || 1 / x === 1 / y;
          } else {
      // Step 6.a: NaN == NaN
            return x !== x && y !== y;
          }
        }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
        function PropTypeError(message) {
          this.message = message;
          this.stack = '';
        }
  // Make `instanceof Error` still work for returned errors.
        PropTypeError.prototype = Error.prototype;

        function createChainableTypeChecker(validate) {
          if (true) {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;

            if (secret !== ReactPropTypesSecret) {
              if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
                const err = new Error(
                  'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
                );
                err.name = 'Invariant Violation';
                throw err;
              } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
                const cacheKey = componentName + ':' + propName;
                if (
                  !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
                ) {
                  printWarning(
                    'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
                  );
                  manualPropTypeCallCache[cacheKey] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
                }
                return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
              }
              return null;
            } else {
              return validate(props, propName, componentName, location, propFullName);
            }
          }

          const chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);

          return chainedCheckType;
        }

        function createPrimitiveTypeChecker(expectedType) {
          function validate(props, propName, componentName, location, propFullName, secret) {
            const propValue = props[propName];
            const propType = getPropType(propValue);
            if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
              const preciseType = getPreciseType(propValue);

              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createAnyTypeChecker() {
          return createChainableTypeChecker(emptyFunctionThatReturnsNull);
        }

        function createArrayOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
              return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
            }
            const propValue = props[propName];
            if (!Array.isArray(propValue)) {
              const propType = getPropType(propValue);
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
            }
            for (let i = 0; i < propValue.length; i++) {
              const error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createElementTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            const propValue = props[propName];
            if (!isValidElement(propValue)) {
              const propType = getPropType(propValue);
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createElementTypeTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            const propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
              const propType = getPropType(propValue);
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createInstanceTypeChecker(expectedClass) {
          function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              const expectedClassName = expectedClass.name || ANONYMOUS;
              const actualClassName = getClassName(props[propName]);
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            if (true) {
              if (arguments.length > 1) {
                printWarning(
                  'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
                );
              } else {
                printWarning('Invalid argument supplied to oneOf, expected an array.');
              }
            }
            return emptyFunctionThatReturnsNull;
          }

          function validate(props, propName, componentName, location, propFullName) {
            const propValue = props[propName];
            for (let i = 0; i < expectedValues.length; i++) {
              if (is(propValue, expectedValues[i])) {
                return null;
              }
            }

            const valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
              const type = getPreciseType(value);
              if (type === 'symbol') {
                return String(value);
              }
              return value;
            });
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
          }
          return createChainableTypeChecker(validate);
        }

        function createObjectOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
              return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
            }
            const propValue = props[propName];
            const propType = getPropType(propValue);
            if (propType !== 'object') {
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
            }
            for (const key in propValue) {
              if (has(propValue, key)) {
                const error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error instanceof Error) {
                  return error;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;
            return emptyFunctionThatReturnsNull;
          }

          for (let i = 0; i < arrayOfTypeCheckers.length; i++) {
            const checker = arrayOfTypeCheckers[i];
            if (typeof checker !== 'function') {
              printWarning(
                'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
              );
              return emptyFunctionThatReturnsNull;
            }
          }

          function validate(props, propName, componentName, location, propFullName) {
            for (let i = 0; i < arrayOfTypeCheckers.length; i++) {
              const checker = arrayOfTypeCheckers[i];
              if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
                return null;
              }
            }

            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
          }
          return createChainableTypeChecker(validate);
        }

        function createNodeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            const propValue = props[propName];
            const propType = getPropType(propValue);
            if (propType !== 'object') {
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
            for (const key in shapeTypes) {
              const checker = shapeTypes[key];
              if (!checker) {
                continue;
              }
              const error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }

        function createStrictShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            const propValue = props[propName];
            const propType = getPropType(propValue);
            if (propType !== 'object') {
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
      // We need to check all keys in case some are required but missing from
      // props.
            const allKeys = assign({}, props[propName], shapeTypes);
            for (const key in allKeys) {
              const checker = shapeTypes[key];
              if (!checker) {
                return new PropTypeError(
                  'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
                );
              }
              const error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }

          return createChainableTypeChecker(validate);
        }

        function isNode(propValue) {
          switch (typeof propValue) {
            case 'number':
            case 'string':
            case 'undefined':
              return true;
            case 'boolean':
              return !propValue;
            case 'object':
              if (Array.isArray(propValue)) {
                return propValue.every(isNode);
              }
              if (propValue === null || isValidElement(propValue)) {
                return true;
              }

              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                const iterator = iteratorFn.call(propValue);
                let step;
                if (iteratorFn !== propValue.entries) {
                  while (!(step = iterator.next()).done) {
                    if (!isNode(step.value)) {
                      return false;
                    }
                  }
                } else {
            // Iterator will provide entry [k,v] tuples rather than values.
                  while (!(step = iterator.next()).done) {
                    const entry = step.value;
                    if (entry) {
                      if (!isNode(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }

              return true;
            default:
              return false;
          }
        }

        function isSymbol(propType, propValue) {
    // Native Symbol.
          if (propType === 'symbol') {
            return true;
          }

    // falsy value can't be a Symbol
          if (!propValue) {
            return false;
          }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
          if (propValue['@@toStringTag'] === 'Symbol') {
            return true;
          }

    // Fallback for non-spec compliant Symbols which are polyfilled.
          if (typeof Symbol === 'function' && propValue instanceof Symbol) {
            return true;
          }

          return false;
        }

  // Equivalent of `typeof` but with special handling for array and regexp.
        function getPropType(propValue) {
          const propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return 'array';
          }
          if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
            return 'object';
          }
          if (isSymbol(propType, propValue)) {
            return 'symbol';
          }
          return propType;
        }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
        function getPreciseType(propValue) {
          if (typeof propValue === 'undefined' || propValue === null) {
            return '' + propValue;
          }
          const propType = getPropType(propValue);
          if (propType === 'object') {
            if (propValue instanceof Date) {
              return 'date';
            } else if (propValue instanceof RegExp) {
              return 'regexp';
            }
          }
          return propType;
        }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
        function getPostfixForTypeWarning(value) {
          const type = getPreciseType(value);
          switch (type) {
            case 'array':
            case 'object':
              return 'an ' + type;
            case 'boolean':
            case 'date':
            case 'regexp':
              return 'a ' + type;
            default:
              return type;
          }
        }

  // Returns class name of the object, if any.
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }

        ReactPropTypes.checkPropTypes = checkPropTypes;
        ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
        ReactPropTypes.PropTypes = ReactPropTypes;

        return ReactPropTypes;
      };


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

      if (true) {
        const ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
        const throwOnDirectAccess = true;
        module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
      } else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ ((module) => {

      "use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



      const ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

      module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/raf/index.js":
/*!***********************************!*\
  !*** ./node_modules/raf/index.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      let now = __webpack_require__(/*! performance-now */ "./node_modules/performance-now/lib/performance-now.js")
        , root = typeof window === 'undefined' ? global : window
        , vendors = ['moz', 'webkit']
        , suffix = 'AnimationFrame'
        , raf = root['request' + suffix]
        , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

      for(let i = 0; !raf && i < vendors.length; i++) {
        raf = root[vendors[i] + 'Request' + suffix]
        caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
      }

// Some versions of FF have rAF but not cAF
      if(!raf || !caf) {
        let last = 0
          , id = 0
          , queue = []
          , frameDuration = 1000 / 60

        raf = function(callback) {
          if(queue.length === 0) {
            const _now = now()
              , next = Math.max(0, frameDuration - (_now - last))
            last = next + _now
            setTimeout(function() {
              const cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
              queue.length = 0
              for(let i = 0; i < cp.length; i++) {
                if(!cp[i].cancelled) {
                  try{
                    cp[i].callback(last)
                  } catch(e) {
                    setTimeout(function() { throw e }, 0)
                  }
                }
              }
            }, Math.round(next))
          }
          queue.push({
            handle: ++id,
            callback: callback,
            cancelled: false
          })
          return id
        }

        caf = function(handle) {
          for(let i = 0; i < queue.length; i++) {
            if(queue[i].handle === handle) {
              queue[i].cancelled = true
            }
          }
        }
      }

      module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
        return raf.call(root, fn)
      }
      module.exports.cancel = function() {
        caf.apply(root, arguments)
      }
      module.exports.polyfill = function(object) {
        if (!object) {
          object = root;
        }
        object.requestAnimationFrame = raf
        object.cancelAnimationFrame = caf
      }


/***/ }),

/***/ "./node_modules/react-display-name/lib/getDisplayName.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-display-name/lib/getDisplayName.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";


      Object.defineProperty(exports, "__esModule", ({
        value: true
      }));
      exports["default"] = getDisplayName;
      function getDisplayName(Component) {
        return Component.displayName || Component.name || (typeof Component === 'string' && Component.length > 0 ? Component : 'Unknown');
      }

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





      if (true) {
        (function() {
          'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
          const hasSymbol = typeof Symbol === 'function' && Symbol.for;
          const REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
          const REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
          const REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
          const REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
          const REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
          const REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
          const REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

          const REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
          const REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
          const REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
          const REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
          const REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
          const REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
          const REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
          const REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
          const REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
          const REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
          const REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

          function isValidElementType(type) {
            return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }

          function typeOf(object) {
            if (typeof object === 'object' && object !== null) {
              const $$typeof = object.$$typeof;

              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;

                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;

                    default:
                      var $$typeofType = type && type.$$typeof;

                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;

                        default:
                          return $$typeof;
                      }

                  }

                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }

            return undefined;
          } // AsyncMode is deprecated along with isAsyncMode

          const AsyncMode = REACT_ASYNC_MODE_TYPE;
          const ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          const ContextConsumer = REACT_CONTEXT_TYPE;
          const ContextProvider = REACT_PROVIDER_TYPE;
          const Element = REACT_ELEMENT_TYPE;
          const ForwardRef = REACT_FORWARD_REF_TYPE;
          const Fragment = REACT_FRAGMENT_TYPE;
          const Lazy = REACT_LAZY_TYPE;
          const Memo = REACT_MEMO_TYPE;
          const Portal = REACT_PORTAL_TYPE;
          const Profiler = REACT_PROFILER_TYPE;
          const StrictMode = REACT_STRICT_MODE_TYPE;
          const Suspense = REACT_SUSPENSE_TYPE;
          let hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

                console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
              }
            }

            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }

          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      if (false) {} else {
        module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
      }


/***/ }),

/***/ "./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   polyfill: () => (/* binding */ polyfill)
/* harmony export */ });
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

      function componentWillMount() {
  // Call this.constructor.gDSFP to support sub-classes.
        const state = this.constructor.getDerivedStateFromProps(this.props, this.state);
        if (state !== null && state !== undefined) {
          this.setState(state);
        }
      }

      function componentWillReceiveProps(nextProps) {
  // Call this.constructor.gDSFP to support sub-classes.
  // Use the setState() updater to ensure state isn't stale in certain edge cases.
        function updater(prevState) {
          const state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
          return state !== null && state !== undefined ? state : null;
        }
  // Binding "this" is important for shallow renderer support.
        this.setState(updater.bind(this));
      }

      function componentWillUpdate(nextProps, nextState) {
        try {
          var prevProps = this.props;
          var prevState = this.state;
          this.props = nextProps;
          this.state = nextState;
          this.__reactInternalSnapshotFlag = true;
          this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
            prevProps,
            prevState
          );
        } finally {
          this.props = prevProps;
          this.state = prevState;
        }
      }

// React may warn about cWM/cWRP/cWU methods being deprecated.
// Add a flag to suppress these warnings for this special case.
      componentWillMount.__suppressDeprecationWarning = true;
      componentWillReceiveProps.__suppressDeprecationWarning = true;
      componentWillUpdate.__suppressDeprecationWarning = true;

      function polyfill(Component) {
        const prototype = Component.prototype;

        if (!prototype || !prototype.isReactComponent) {
          throw new Error('Can only polyfill class components');
        }

        if (
          typeof Component.getDerivedStateFromProps !== 'function' &&
    typeof prototype.getSnapshotBeforeUpdate !== 'function'
        ) {
          return Component;
        }

  // If new component APIs are defined, "unsafe" lifecycles won't be called.
  // Error if any of these lifecycles are present,
  // Because they would work differently between older and newer (16.3+) versions of React.
        let foundWillMountName = null;
        let foundWillReceivePropsName = null;
        let foundWillUpdateName = null;
        if (typeof prototype.componentWillMount === 'function') {
          foundWillMountName = 'componentWillMount';
        } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
          foundWillMountName = 'UNSAFE_componentWillMount';
        }
        if (typeof prototype.componentWillReceiveProps === 'function') {
          foundWillReceivePropsName = 'componentWillReceiveProps';
        } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
          foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
        }
        if (typeof prototype.componentWillUpdate === 'function') {
          foundWillUpdateName = 'componentWillUpdate';
        } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
          foundWillUpdateName = 'UNSAFE_componentWillUpdate';
        }
        if (
          foundWillMountName !== null ||
    foundWillReceivePropsName !== null ||
    foundWillUpdateName !== null
        ) {
          const componentName = Component.displayName || Component.name;
          const newApiName =
      typeof Component.getDerivedStateFromProps === 'function'
        ? 'getDerivedStateFromProps()'
        : 'getSnapshotBeforeUpdate()';

          throw Error(
            'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' +
        componentName +
        ' uses ' +
        newApiName +
        ' but also contains the following legacy lifecycles:' +
        (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') +
        (foundWillReceivePropsName !== null
          ? '\n  ' + foundWillReceivePropsName
          : '') +
        (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') +
        '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' +
        'https://fb.me/react-async-component-lifecycle-hooks'
          );
        }

  // React <= 16.2 does not support static getDerivedStateFromProps.
  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
  // Newer versions of React will ignore these lifecycles if gDSFP exists.
        if (typeof Component.getDerivedStateFromProps === 'function') {
          prototype.componentWillMount = componentWillMount;
          prototype.componentWillReceiveProps = componentWillReceiveProps;
        }

  // React <= 16.2 does not support getSnapshotBeforeUpdate.
  // As a workaround, use cWU to invoke the new lifecycle.
  // Newer versions of React will ignore that lifecycle if gSBU exists.
        if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
          if (typeof prototype.componentDidUpdate !== 'function') {
            throw new Error(
              'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'
            );
          }

          prototype.componentWillUpdate = componentWillUpdate;

          const componentDidUpdate = prototype.componentDidUpdate;

          prototype.componentDidUpdate = function componentDidUpdatePolyfill(
            prevProps,
            prevState,
            maybeSnapshot
          ) {
      // 16.3+ will not execute our will-update method;
      // It will pass a snapshot value to did-update though.
      // Older versions will require our polyfilled will-update value.
      // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
      // Because for <= 15.x versions this might be a "prevContext" object.
      // We also can't just check "__reactInternalSnapshot",
      // Because get-snapshot might return a falsy value.
      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
            const snapshot = this.__reactInternalSnapshotFlag
              ? this.__reactInternalSnapshot
              : maybeSnapshot;

            componentDidUpdate.call(this, prevProps, prevState, snapshot);
          };
        }

        return Component;
      }




/***/ }),

/***/ "./node_modules/react-sortable-tree-theme-file-explorer/dist/main.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-sortable-tree-theme-file-explorer/dist/main.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

      !function(root, factory) {
        true ? module.exports = factory() : 0;
      }("undefined" != typeof self ? self : this, function() {
    /******/
        return function(modules) {
        /******/
        /******/
        // The require function
        /******/
          function __nested_webpack_require_515__(moduleId) {
            /******/
            /******/
            // Check if module is in cache
            /******/
            if (installedModules[moduleId]) /******/
              return installedModules[moduleId].exports;
            /******/
            // Create a new module (and put it into the cache)
            /******/
            const module = installedModules[moduleId] = {
                /******/
              i: moduleId,
                /******/
              l: !1,
                /******/
              exports: {}
            };
            /******/
            /******/
            // Return the exports of the module
            /******/
            /******/
            /******/
            // Execute the module function
            /******/
            /******/
            /******/
            // Flag the module as loaded
            /******/
            return modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_515__), 
            module.l = !0, module.exports;
          }
        // webpackBootstrap
        /******/
        // The module cache
        /******/
          var installedModules = {};
        /******/
        /******/
        // Load entry module and return exports
        /******/
        /******/
        /******/
        /******/
        // expose the modules object (__webpack_modules__)
        /******/
        /******/
        /******/
        // expose the module cache
        /******/
        /******/
        /******/
        // define getter function for harmony exports
        /******/
        /******/
        /******/
        // getDefaultExport function for compatibility with non-harmony modules
        /******/
        /******/
        /******/
        // Object.prototype.hasOwnProperty.call
        /******/
        /******/
        /******/
        // __webpack_public_path__
        /******/
          return __nested_webpack_require_515__.m = modules, __nested_webpack_require_515__.c = installedModules, 
          __nested_webpack_require_515__.d = function(exports, name, getter) {
            /******/
            __nested_webpack_require_515__.o(exports, name) || /******/
            Object.defineProperty(exports, name, {
                /******/
              configurable: !1,
                /******/
              enumerable: !0,
                /******/
              get: getter
            });
          }, __nested_webpack_require_515__.n = function(module) {
            /******/
            const getter = module && module.__esModule ? /******/
              function() {
                return module.default;
              } : /******/
              function() {
                return module;
              };
            /******/
            /******/
            return __nested_webpack_require_515__.d(getter, "a", getter), getter;
          }, __nested_webpack_require_515__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          }, __nested_webpack_require_515__.p = "", __nested_webpack_require_515__(__nested_webpack_require_515__.s = 4);
        }([ /* 0 */
    /***/
          function(module, exports) {
            module.exports = __webpack_require__(/*! react */ "react");
          }, /* 1 */
    /***/
          function(module, exports) {
            module.exports = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
          }, /* 2 */
    /***/
          function(module, exports) {
            function cssWithMappingToString(item, useSourceMap) {
              const content = item[1] || "", cssMapping = item[3];
              if (!cssMapping) return content;
              if (useSourceMap && "function" == typeof btoa) {
                const sourceMapping = toComment(cssMapping);
                return [ content ].concat(cssMapping.sources.map(function(source) {
                  return "/*# sourceURL=" + cssMapping.sourceRoot + source + " */";
                })).concat([ sourceMapping ]).join("\n");
              }
              return [ content ].join("\n");
            }
        // Adapted from convert-source-map (MIT)
            function toComment(sourceMap) {
              return "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
            }
        /*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
        // css base code, injected by the css-loader
            module.exports = function(useSourceMap) {
              const list = [];
            // return the list of modules as css string
            // import a list of modules into the list
              return list.toString = function() {
                return this.map(function(item) {
                  const content = cssWithMappingToString(item, useSourceMap);
                  return item[2] ? "@media " + item[2] + "{" + content + "}" : content;
                }).join("");
              }, list.i = function(modules, mediaQuery) {
                "string" == typeof modules && (modules = [ [ null, modules, "" ] ]);
                for (var alreadyImportedModules = {}, i = 0; i < this.length; i++) {
                  const id = this[i][0];
                  "number" == typeof id && (alreadyImportedModules[id] = !0);
                }
                for (i = 0; i < modules.length; i++) {
                  const item = modules[i];
                    // skip already imported module
                    // this implementation is not 100% perfect for weird media query combinations
                    //  when a module is imported multiple times with different media queries.
                    //  I hope this will never occur (Hey this way we have smaller bundles)
                  "number" == typeof item[0] && alreadyImportedModules[item[0]] || (mediaQuery && !item[2] ? item[2] = mediaQuery : mediaQuery && (item[2] = "(" + item[2] + ") and (" + mediaQuery + ")"), 
                  list.push(item));
                }
              }, list;
            };
          }, /* 3 */
    /***/
          function(module, exports, __nested_webpack_require_6449__) {
            function addStylesToDom(styles, options) {
              for (let i = 0; i < styles.length; i++) {
                const item = styles[i], domStyle = stylesInDom[item.id];
                if (domStyle) {
                  domStyle.refs++;
                  for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j](item.parts[j]);
                  for (;j < item.parts.length; j++) domStyle.parts.push(addStyle(item.parts[j], options));
                } else {
                  for (var parts = [], j = 0; j < item.parts.length; j++) parts.push(addStyle(item.parts[j], options));
                  stylesInDom[item.id] = {
                    id: item.id,
                    refs: 1,
                    parts: parts
                  };
                }
              }
            }
            function listToStyles(list, options) {
              for (var styles = [], newStyles = {}, i = 0; i < list.length; i++) {
                const item = list[i], id = options.base ? item[0] + options.base : item[0], css = item[1], media = item[2], sourceMap = item[3], part = {
                  css: css,
                  media: media,
                  sourceMap: sourceMap
                };
                newStyles[id] ? newStyles[id].parts.push(part) : styles.push(newStyles[id] = {
                  id: id,
                  parts: [ part ]
                });
              }
              return styles;
            }
            function insertStyleElement(options, style) {
              const target = getElement(options.insertInto);
              if (!target) throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
              const lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];
              if ("top" === options.insertAt) lastStyleElementInsertedAtTop ? lastStyleElementInsertedAtTop.nextSibling ? target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling) : target.appendChild(style) : target.insertBefore(style, target.firstChild), 
              stylesInsertedAtTop.push(style); else if ("bottom" === options.insertAt) target.appendChild(style); else {
                if ("object" != typeof options.insertAt || !options.insertAt.before) throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
                const nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
                target.insertBefore(style, nextSibling);
              }
            }
            function removeStyleElement(style) {
              if (null === style.parentNode) return !1;
              style.parentNode.removeChild(style);
              const idx = stylesInsertedAtTop.indexOf(style);
              idx >= 0 && stylesInsertedAtTop.splice(idx, 1);
            }
            function createStyleElement(options) {
              const style = document.createElement("style");
              return options.attrs.type = "text/css", addAttrs(style, options.attrs), insertStyleElement(options, style), 
              style;
            }
            function createLinkElement(options) {
              const link = document.createElement("link");
              return options.attrs.type = "text/css", options.attrs.rel = "stylesheet", addAttrs(link, options.attrs), 
              insertStyleElement(options, link), link;
            }
            function addAttrs(el, attrs) {
              Object.keys(attrs).forEach(function(key) {
                el.setAttribute(key, attrs[key]);
              });
            }
            function addStyle(obj, options) {
              let style, update, remove, result;
            // If a transform function was defined, run it on the css
              if (options.transform && obj.css) {
                if (!(result = options.transform(obj.css))) // If the transform function returns a falsy value, don't add this css.
                // This allows conditional loading of css
                  return function() {};
                // If transform returns a value, use that instead of the original css.
                // This allows running runtime transformations on the css.
                obj.css = result;
              }
              if (options.singleton) {
                const styleIndex = singletonCounter++;
                style = singleton || (singleton = createStyleElement(options)), update = applyToSingletonTag.bind(null, style, styleIndex, !1), 
                remove = applyToSingletonTag.bind(null, style, styleIndex, !0);
              } else obj.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (style = createLinkElement(options), 
              update = updateLink.bind(null, style, options), remove = function() {
                removeStyleElement(style), style.href && URL.revokeObjectURL(style.href);
              }) : (style = createStyleElement(options), update = applyToTag.bind(null, style), 
              remove = function() {
                removeStyleElement(style);
              });
              return update(obj), function(newObj) {
                if (newObj) {
                  if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) return;
                  update(obj = newObj);
                } else remove();
              };
            }
            function applyToSingletonTag(style, index, remove, obj) {
              const css = remove ? "" : obj.css;
              if (style.styleSheet) style.styleSheet.cssText = replaceText(index, css); else {
                const cssNode = document.createTextNode(css), childNodes = style.childNodes;
                childNodes[index] && style.removeChild(childNodes[index]), childNodes.length ? style.insertBefore(cssNode, childNodes[index]) : style.appendChild(cssNode);
              }
            }
            function applyToTag(style, obj) {
              const css = obj.css, media = obj.media;
              if (media && style.setAttribute("media", media), style.styleSheet) style.styleSheet.cssText = css; else {
                for (;style.firstChild; ) style.removeChild(style.firstChild);
                style.appendChild(document.createTextNode(css));
              }
            }
            function updateLink(link, options, obj) {
              let css = obj.css, sourceMap = obj.sourceMap, autoFixUrls = void 0 === options.convertToAbsoluteUrls && sourceMap;
              (options.convertToAbsoluteUrls || autoFixUrls) && (css = fixUrls(css)), sourceMap && (// http://stackoverflow.com/a/26603875
                css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */");
              const blob = new Blob([ css ], {
                  type: "text/css"
                }), oldSrc = link.href;
              link.href = URL.createObjectURL(blob), oldSrc && URL.revokeObjectURL(oldSrc);
            }
        /*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
            var stylesInDom = {}, isOldIE = function(fn) {
                let memo;
                return function() {
                  return void 0 === memo && (memo = fn.apply(this, arguments)), memo;
                };
              }(function() {
            // Test for IE <= 9 as proposed by Browserhacks
            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
            // Tests for existence of standard globals is to allow style-loader
            // to operate correctly into non-standard environments
            // @see https://github.com/webpack-contrib/style-loader/issues/177
                return window && document && document.all && !window.atob;
              }), getElement = function(fn) {
                const memo = {};
                return function(selector) {
                  if (void 0 === memo[selector]) {
                    let styleTarget = fn.call(this, selector);
                    // Special case to return head of iframe instead of iframe itself
                    if (styleTarget instanceof window.HTMLIFrameElement) try {
                        // This will throw an exception if access to iframe is blocked
                        // due to cross-origin restrictions
                      styleTarget = styleTarget.contentDocument.head;
                    } catch (e) {
                      styleTarget = null;
                    }
                    memo[selector] = styleTarget;
                  }
                  return memo[selector];
                };
              }(function(target) {
                return document.querySelector(target);
              }), singleton = null, singletonCounter = 0, stylesInsertedAtTop = [], fixUrls = __nested_webpack_require_6449__(8);
            module.exports = function(list, options) {
              if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document) throw new Error("The style-loader cannot be used in a non-browser environment");
              options = options || {}, options.attrs = "object" == typeof options.attrs ? options.attrs : {}, 
            // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
            // tags it will allow on a page
              options.singleton || (options.singleton = isOldIE()), // By default, add <style> tags to the <head> element
              options.insertInto || (options.insertInto = "head"), // By default, add <style> tags to the bottom of the target
              options.insertAt || (options.insertAt = "bottom");
              const styles = listToStyles(list, options);
              return addStylesToDom(styles, options), function(newList) {
                for (var mayRemove = [], i = 0; i < styles.length; i++) {
                  var item = styles[i], domStyle = stylesInDom[item.id];
                  domStyle.refs--, mayRemove.push(domStyle);
                }
                if (newList) {
                  addStylesToDom(listToStyles(newList, options), options);
                }
                for (var i = 0; i < mayRemove.length; i++) {
                  var domStyle = mayRemove[i];
                  if (0 === domStyle.refs) {
                    for (let j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();
                    delete stylesInDom[domStyle.id];
                  }
                }
              };
            };
            var replaceText = function() {
              const textStore = [];
              return function(index, replacement) {
                return textStore[index] = replacement, textStore.filter(Boolean).join("\n");
              };
            }();
          }, /* 4 */
    /***/
          function(module, exports, __nested_webpack_require_17266__) {
            "use strict";
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                default: obj
              };
            }
            const _nodeContentRenderer = __nested_webpack_require_17266__(5), _nodeContentRenderer2 = _interopRequireDefault(_nodeContentRenderer), _treeNodeRenderer = __nested_webpack_require_17266__(9), _treeNodeRenderer2 = _interopRequireDefault(_treeNodeRenderer);
        // Can override the following:
        //
        // style: PropTypes.shape({}),
        // innerStyle: PropTypes.shape({}),
        // reactVirtualizedListProps: PropTypes.shape({}),
        // scaffoldBlockPxWidth: PropTypes.number,
        // slideRegionSize: PropTypes.number,
        // rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),
        // treeNodeRenderer: PropTypes.func,
        // nodeContentRenderer: PropTypes.func,
        // placeholderRenderer: PropTypes.func,
            module.exports = {
              nodeContentRenderer: _nodeContentRenderer2.default,
              treeNodeRenderer: _treeNodeRenderer2.default,
              scaffoldBlockPxWidth: 25,
              rowHeight: 25,
              slideRegionSize: 50
            };
          }, /* 5 */
    /***/
          function(module, exports, __nested_webpack_require_18521__) {
            "use strict";
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                default: obj
              };
            }
            function _objectWithoutProperties(obj, keys) {
              const target = {};
              for (const i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
              return target;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function _possibleConstructorReturn(self, call) {
              if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !call || "object" != typeof call && "function" != typeof call ? self : call;
            }
            function _inherits(subClass, superClass) {
              if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0
                }
              }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
            }
            function isDescendant(older, younger) {
              return !!older.children && "function" != typeof older.children && older.children.some(function(child) {
                return child === younger || isDescendant(child, younger);
              });
            }
            Object.defineProperty(exports, "__esModule", {
              value: !0
            });
            const _extends = Object.assign || function(target) {
                for (let i = 1; i < arguments.length; i++) {
                  const source = arguments[i];
                  for (const key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
              }, _createClass = function() {
                function defineProperties(target, props) {
                  for (let i = 0; i < props.length; i++) {
                    const descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function(Constructor, protoProps, staticProps) {
                  return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                  Constructor;
                };
              }(), _react = __nested_webpack_require_18521__(0), _react2 = _interopRequireDefault(_react), _propTypes = __nested_webpack_require_18521__(1), _propTypes2 = _interopRequireDefault(_propTypes), _nodeContentRenderer = __nested_webpack_require_18521__(6), _nodeContentRenderer2 = _interopRequireDefault(_nodeContentRenderer), FileThemeNodeContentRenderer = function(_Component) {
                function FileThemeNodeContentRenderer() {
                  return _classCallCheck(this, FileThemeNodeContentRenderer), _possibleConstructorReturn(this, (FileThemeNodeContentRenderer.__proto__ || Object.getPrototypeOf(FileThemeNodeContentRenderer)).apply(this, arguments));
                }
                return _inherits(FileThemeNodeContentRenderer, _Component), _createClass(FileThemeNodeContentRenderer, [ {
                  key: "render",
                  value: function() {
                    const _props = this.props, scaffoldBlockPxWidth = _props.scaffoldBlockPxWidth, toggleChildrenVisibility = _props.toggleChildrenVisibility, connectDragPreview = _props.connectDragPreview, connectDragSource = _props.connectDragSource, isDragging = _props.isDragging, canDrop = _props.canDrop, canDrag = _props.canDrag, node = _props.node, title = _props.title, draggedNode = _props.draggedNode, path = _props.path, treeIndex = _props.treeIndex, isSearchMatch = _props.isSearchMatch, isSearchFocus = _props.isSearchFocus, icons = _props.icons, buttons = _props.buttons, className = _props.className, style = _props.style, didDrop = _props.didDrop, lowerSiblingCounts = _props.lowerSiblingCounts, listIndex = _props.listIndex, swapFrom = _props.swapFrom, swapLength = _props.swapLength, swapDepth = _props.swapDepth, otherProps = (_props.treeId, 
                      _props.isOver, _props.parentNode, _props.rowDirection, _objectWithoutProperties(_props, [ "scaffoldBlockPxWidth", "toggleChildrenVisibility", "connectDragPreview", "connectDragSource", "isDragging", "canDrop", "canDrag", "node", "title", "draggedNode", "path", "treeIndex", "isSearchMatch", "isSearchFocus", "icons", "buttons", "className", "style", "didDrop", "lowerSiblingCounts", "listIndex", "swapFrom", "swapLength", "swapDepth", "treeId", "isOver", "parentNode", "rowDirection" ])), nodeTitle = title || node.title, isDraggedDescendant = draggedNode && isDescendant(draggedNode, node), isLandingPadActive = !didDrop && isDragging, scaffold = [];
                    lowerSiblingCounts.forEach(function(lowerSiblingCount, i) {
                      if (scaffold.push(_react2.default.createElement("div", {
                        key: "pre_" + (1 + i),
                        style: {
                          width: scaffoldBlockPxWidth
                        },
                        className: _nodeContentRenderer2.default.lineBlock
                      })), treeIndex !== listIndex && i === swapDepth) {
                            // This row has been shifted, and is at the depth of
                            // the line pointing to the new destination
                        let highlightLineClass = "";
                            // This block is on the bottom (target) line
                            // This block points at the target block (where the row will go when released)
                        highlightLineClass = listIndex === swapFrom + swapLength - 1 ? _nodeContentRenderer2.default.highlightBottomLeftCorner : treeIndex === swapFrom ? _nodeContentRenderer2.default.highlightTopLeftCorner : _nodeContentRenderer2.default.highlightLineVertical, 
                        scaffold.push(_react2.default.createElement("div", {
                          key: "highlight_" + (1 + i),
                          style: {
                            width: scaffoldBlockPxWidth,
                            left: scaffoldBlockPxWidth * i
                          },
                          className: _nodeContentRenderer2.default.absoluteLineBlock + " " + highlightLineClass
                        }));
                      }
                    });
                    const nodeContent = _react2.default.createElement("div", _extends({
                      style: {
                        height: "100%"
                      }
                    }, otherProps), toggleChildrenVisibility && node.children && node.children.length > 0 && _react2.default.createElement("button", {
                      type: "button",
                      "aria-label": node.expanded ? "Collapse" : "Expand",
                      className: node.expanded ? _nodeContentRenderer2.default.collapseButton : _nodeContentRenderer2.default.expandButton,
                      style: {
                        left: (lowerSiblingCounts.length - .7) * scaffoldBlockPxWidth
                      },
                      onClick: function() {
                        return toggleChildrenVisibility({
                          node: node,
                          path: path,
                          treeIndex: treeIndex
                        });
                      }
                    }), _react2.default.createElement("div", {
                      className: _nodeContentRenderer2.default.rowWrapper + (canDrag ? "" : " " + _nodeContentRenderer2.default.rowWrapperDragDisabled)
                    }, connectDragPreview(_react2.default.createElement("div", {
                      style: {
                        display: "flex"
                      }
                    }, scaffold, _react2.default.createElement("div", {
                      className: _nodeContentRenderer2.default.row + (isLandingPadActive ? " " + _nodeContentRenderer2.default.rowLandingPad : "") + (isLandingPadActive && !canDrop ? " " + _nodeContentRenderer2.default.rowCancelPad : "") + (isSearchMatch ? " " + _nodeContentRenderer2.default.rowSearchMatch : "") + (isSearchFocus ? " " + _nodeContentRenderer2.default.rowSearchFocus : "") + (className ? " " + className : ""),
                      style: _extends({
                        opacity: isDraggedDescendant ? .5 : 1
                      }, style)
                    }, _react2.default.createElement("div", {
                      className: _nodeContentRenderer2.default.rowContents + (canDrag ? "" : " " + _nodeContentRenderer2.default.rowContentsDragDisabled)
                    }, _react2.default.createElement("div", {
                      className: _nodeContentRenderer2.default.rowToolbar
                    }, icons.map(function(icon, index) {
                      return _react2.default.createElement("div", {
                        key: index,
                        className: _nodeContentRenderer2.default.toolbarButton
                      }, icon);
                    })), _react2.default.createElement("div", {
                      className: _nodeContentRenderer2.default.rowLabel
                    }, _react2.default.createElement("span", {
                      className: _nodeContentRenderer2.default.rowTitle
                    }, "function" == typeof nodeTitle ? nodeTitle({
                      node: node,
                      path: path,
                      treeIndex: treeIndex
                    }) : nodeTitle)), _react2.default.createElement("div", {
                      className: _nodeContentRenderer2.default.rowToolbar
                    }, buttons.map(function(btn, index) {
                      return _react2.default.createElement("div", {
                        key: index,
                        className: _nodeContentRenderer2.default.toolbarButton
                      }, btn);
                    }))))))));
                    return canDrag ? connectDragSource(nodeContent, {
                      dropEffect: "copy"
                    }) : nodeContent;
                  }
                } ]), FileThemeNodeContentRenderer;
              }(_react.Component);
            FileThemeNodeContentRenderer.defaultProps = {
              buttons: [],
              canDrag: !1,
              canDrop: !1,
              className: "",
              draggedNode: null,
              icons: [],
              isSearchFocus: !1,
              isSearchMatch: !1,
              parentNode: null,
              style: {},
              swapDepth: null,
              swapFrom: null,
              swapLength: null,
              title: null,
              toggleChildrenVisibility: null
            }, FileThemeNodeContentRenderer.propTypes = {
              buttons: _propTypes2.default.arrayOf(_propTypes2.default.node),
              canDrag: _propTypes2.default.bool,
              className: _propTypes2.default.string,
              icons: _propTypes2.default.arrayOf(_propTypes2.default.node),
              isSearchFocus: _propTypes2.default.bool,
              isSearchMatch: _propTypes2.default.bool,
              listIndex: _propTypes2.default.number.isRequired,
              lowerSiblingCounts: _propTypes2.default.arrayOf(_propTypes2.default.number).isRequired,
              node: _propTypes2.default.shape({}).isRequired,
              path: _propTypes2.default.arrayOf(_propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.number ])).isRequired,
              scaffoldBlockPxWidth: _propTypes2.default.number.isRequired,
              style: _propTypes2.default.shape({}),
              swapDepth: _propTypes2.default.number,
              swapFrom: _propTypes2.default.number,
              swapLength: _propTypes2.default.number,
              title: _propTypes2.default.oneOfType([ _propTypes2.default.func, _propTypes2.default.node ]),
              toggleChildrenVisibility: _propTypes2.default.func,
              treeIndex: _propTypes2.default.number.isRequired,
              treeId: _propTypes2.default.string.isRequired,
              rowDirection: _propTypes2.default.string.isRequired,
            // Drag and drop API functions
            // Drag source
              connectDragPreview: _propTypes2.default.func.isRequired,
              connectDragSource: _propTypes2.default.func.isRequired,
              didDrop: _propTypes2.default.bool.isRequired,
              draggedNode: _propTypes2.default.shape({}),
              isDragging: _propTypes2.default.bool.isRequired,
              parentNode: _propTypes2.default.shape({}),
            // Needed for dndManager
            // Drop target
              canDrop: _propTypes2.default.bool,
              isOver: _propTypes2.default.bool.isRequired
            }, exports.default = FileThemeNodeContentRenderer;
          }, /* 6 */
    /***/
          function(module, exports, __nested_webpack_require_32070__) {
        // style-loader: Adds some css to the DOM by adding a <style> tag
        // load the styles
            let content = __nested_webpack_require_32070__(7);
            "string" == typeof content && (content = [ [ module.i, content, "" ] ]);
        // Prepare cssTransformation
            const options = {
              insertAt: "top",
              hmr: !0
            };
            options.transform = void 0;
        // add the styles to the DOM
            __nested_webpack_require_32070__(3)(content, options);
            content.locals && (module.exports = content.locals);
          }, /* 7 */
    /***/
          function(module, exports, __nested_webpack_require_32681__) {
            exports = module.exports = __nested_webpack_require_32681__(2)(!1), // imports
        // module
            exports.push([ module.i, ".rstcustom__rowWrapper {\n  height: 100%;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  cursor: move; }\n  .rstcustom__rowWrapper:hover {\n    opacity: 0.7; }\n  .rstcustom__rowWrapper:active {\n    opacity: 1; }\n\n.rstcustom__rowWrapperDragDisabled {\n  cursor: default; }\n\n.rstcustom__row {\n  height: 100%;\n  white-space: nowrap;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  position: relative; }\n  .rstcustom__row > * {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box; }\n\n/**\n * The outline of where the element will go if dropped, displayed while dragging\n */\n.rstcustom__rowLandingPad, .rstcustom__rowCancelPad {\n  border: none;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  outline: none; }\n  .rstcustom__rowLandingPad *, .rstcustom__rowCancelPad * {\n    opacity: 0 !important; }\n  .rstcustom__rowLandingPad::before, .rstcustom__rowCancelPad::before {\n    background-color: lightblue;\n    border: 2px dotted black;\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    z-index: -1; }\n\n/**\n * Alternate appearance of the landing pad when the dragged location is invalid\n */\n.rstcustom__rowCancelPad::before {\n  background-color: #e6a8ad; }\n\n/**\n * Nodes matching the search conditions are highlighted\n */\n.rstcustom__rowSearchMatch {\n  -webkit-box-shadow: inset 0 -7px 7px -3px #0080ff;\n          box-shadow: inset 0 -7px 7px -3px #0080ff; }\n\n/**\n * The node that matches the search conditions and is currently focused\n */\n.rstcustom__rowSearchFocus {\n  -webkit-box-shadow: inset 0 -7px 7px -3px #fc6421;\n          box-shadow: inset 0 -7px 7px -3px #fc6421; }\n\n.rstcustom__rowContents, .rstcustom__rowLabel, .rstcustom__rowToolbar, .rstcustom__toolbarButton {\n  display: inline-block;\n  vertical-align: middle; }\n\n.rstcustom__rowContents {\n  position: relative;\n  height: 100%;\n  -webkit-box-flex: 1;\n      -ms-flex: 1 0 auto;\n          flex: 1 0 auto;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-box-pack: justify;\n      -ms-flex-pack: justify;\n          justify-content: space-between; }\n\n.rstcustom__rowLabel {\n  -webkit-box-flex: 0;\n      -ms-flex: 0 1 auto;\n          flex: 0 1 auto;\n  padding-right: 20px; }\n\n.rstcustom__rowToolbar {\n  -webkit-box-flex: 0;\n      -ms-flex: 0 1 auto;\n          flex: 0 1 auto;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex; }\n\n.rstcustom__collapseButton,\n.rstcustom__expandButton {\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  border: none;\n  background: transparent;\n  padding: 0;\n  z-index: 2;\n  position: absolute;\n  top: 45%;\n  width: 30px;\n  height: 30px;\n  -webkit-transform: translate3d(-50%, -50%, 0);\n          transform: translate3d(-50%, -50%, 0);\n  cursor: pointer; }\n  .rstcustom__collapseButton::after,\n  .rstcustom__expandButton::after {\n    content: '';\n    position: absolute;\n    -webkit-transform-origin: 7px 4px;\n        -ms-transform-origin: 7px 4px;\n            transform-origin: 7px 4px;\n    -webkit-transform: translate3d(-50%, -20%, 0);\n            transform: translate3d(-50%, -20%, 0);\n    border: solid transparent 10px;\n    border-left-width: 7px;\n    border-right-width: 7px;\n    border-top-color: gray; }\n  .rstcustom__collapseButton:hover::after,\n  .rstcustom__expandButton:hover::after {\n    border-top-color: black; }\n  .rstcustom__collapseButton:focus,\n  .rstcustom__expandButton:focus {\n    outline: none; }\n    .rstcustom__collapseButton:focus::after,\n    .rstcustom__expandButton:focus::after {\n      -webkit-filter: drop-shadow(0 0 1px #83bef9) drop-shadow(0 0 1px #83bef9) drop-shadow(0 0 1px #83bef9);\n              filter: drop-shadow(0 0 1px #83bef9) drop-shadow(0 0 1px #83bef9) drop-shadow(0 0 1px #83bef9); }\n\n.rstcustom__expandButton::after {\n  -webkit-transform: translate3d(-50%, -20%, 0) rotateZ(-90deg);\n          transform: translate3d(-50%, -20%, 0) rotateZ(-90deg); }\n\n/**\n * Line for under a node with children\n */\n.rstcustom__lineChildren {\n  height: 100%;\n  display: inline-block; }\n\n/* ==========================================================================\n   Scaffold\n\n    Line-overlaid blocks used for showing the tree structure\n   ========================================================================== */\n.rstcustom__lineBlock, .rstcustom__absoluteLineBlock {\n  height: 100%;\n  position: relative;\n  display: inline-block;\n  -webkit-box-flex: 0;\n      -ms-flex: 0 0 auto;\n          flex: 0 0 auto; }\n\n.rstcustom__absoluteLineBlock {\n  position: absolute;\n  top: 0; }\n\n/* Highlight line for pointing to dragged row destination\n   ========================================================================== */\n/**\n * +--+--+\n * |  |  |\n * |  |  |\n * |  |  |\n * +--+--+\n */\n.rstcustom__highlightLineVertical {\n  z-index: 3; }\n  .rstcustom__highlightLineVertical::before {\n    position: absolute;\n    content: '';\n    background-color: #36c2f6;\n    width: 6px;\n    margin-left: -3px;\n    left: 50%;\n    top: 0;\n    height: 100%; }\n\n@-webkit-keyframes rstcustom__arrow-pulse {\n  0% {\n    -webkit-transform: translate(0, 0);\n            transform: translate(0, 0);\n    opacity: 0; }\n  30% {\n    -webkit-transform: translate(0, 300%);\n            transform: translate(0, 300%);\n    opacity: 1; }\n  70% {\n    -webkit-transform: translate(0, 700%);\n            transform: translate(0, 700%);\n    opacity: 1; }\n  100% {\n    -webkit-transform: translate(0, 1000%);\n            transform: translate(0, 1000%);\n    opacity: 0; } }\n\n@keyframes rstcustom__arrow-pulse {\n  0% {\n    -webkit-transform: translate(0, 0);\n            transform: translate(0, 0);\n    opacity: 0; }\n  30% {\n    -webkit-transform: translate(0, 300%);\n            transform: translate(0, 300%);\n    opacity: 1; }\n  70% {\n    -webkit-transform: translate(0, 700%);\n            transform: translate(0, 700%);\n    opacity: 1; }\n  100% {\n    -webkit-transform: translate(0, 1000%);\n            transform: translate(0, 1000%);\n    opacity: 0; } }\n  .rstcustom__highlightLineVertical::after {\n    content: '';\n    position: absolute;\n    height: 0;\n    margin-left: -3px;\n    left: 50%;\n    top: 0;\n    border-left: 3px solid transparent;\n    border-right: 3px solid transparent;\n    border-top: 3px solid white;\n    -webkit-animation: rstcustom__arrow-pulse 1s infinite linear both;\n            animation: rstcustom__arrow-pulse 1s infinite linear both; }\n\n/**\n * +-----+\n * |     |\n * |  +--+\n * |  |  |\n * +--+--+\n */\n.rstcustom__highlightTopLeftCorner::before {\n  z-index: 3;\n  content: '';\n  position: absolute;\n  border-top: solid 6px #36c2f6;\n  border-left: solid 6px #36c2f6;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  height: calc(50% + 3px);\n  top: 50%;\n  margin-top: -3px;\n  right: 0;\n  width: calc(50% + 3px); }\n\n/**\n * +--+--+\n * |  |  |\n * |  |  |\n * |  +->|\n * +-----+\n */\n.rstcustom__highlightBottomLeftCorner {\n  z-index: 3; }\n  .rstcustom__highlightBottomLeftCorner::before {\n    content: '';\n    position: absolute;\n    border-bottom: solid 6px #36c2f6;\n    border-left: solid 6px #36c2f6;\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n    height: calc(100% + 3px);\n    top: 0;\n    right: 7px;\n    width: calc(50% - 4px); }\n  .rstcustom__highlightBottomLeftCorner::after {\n    content: '';\n    position: absolute;\n    height: 0;\n    right: 0;\n    top: 100%;\n    margin-top: -7px;\n    border-top: 7px solid transparent;\n    border-bottom: 7px solid transparent;\n    border-left: 7px solid #36c2f6; }\n", "" ]), 
        // exports
            exports.locals = {
              rowWrapper: "rstcustom__rowWrapper",
              rowWrapperDragDisabled: "rstcustom__rowWrapperDragDisabled",
              row: "rstcustom__row",
              rowLandingPad: "rstcustom__rowLandingPad",
              rowCancelPad: "rstcustom__rowCancelPad",
              rowSearchMatch: "rstcustom__rowSearchMatch",
              rowSearchFocus: "rstcustom__rowSearchFocus",
              rowContents: "rstcustom__rowContents",
              rowLabel: "rstcustom__rowLabel",
              rowToolbar: "rstcustom__rowToolbar",
              toolbarButton: "rstcustom__toolbarButton",
              collapseButton: "rstcustom__collapseButton",
              expandButton: "rstcustom__expandButton",
              lineChildren: "rstcustom__lineChildren",
              lineBlock: "rstcustom__lineBlock",
              absoluteLineBlock: "rstcustom__absoluteLineBlock",
              highlightLineVertical: "rstcustom__highlightLineVertical",
              "arrow-pulse": "rstcustom__arrow-pulse",
              highlightTopLeftCorner: "rstcustom__highlightTopLeftCorner",
              highlightBottomLeftCorner: "rstcustom__highlightBottomLeftCorner"
            };
          }, /* 8 */
    /***/
          function(module, exports) {
        /**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */
            module.exports = function(css) {
            // get current location
              const location = "undefined" != typeof window && window.location;
              if (!location) throw new Error("fixUrls requires window.location");
            // blank or null?
              if (!css || "string" != typeof css) return css;
              const baseUrl = location.protocol + "//" + location.host, currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");
            // send back the fixed css
              return css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
                // strip quotes (if they exist)
                const unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function(o, $1) {
                  return $1;
                }).replace(/^'(.*)'$/, function(o, $1) {
                  return $1;
                });
                // already a full url? no change
                if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) return fullMatch;
                // convert the url to a full url
                let newUrl;
                // send back the fixed url(...)
                //TODO: should we add protocol?
                return newUrl = 0 === unquotedOrigUrl.indexOf("//") ? unquotedOrigUrl : 0 === unquotedOrigUrl.indexOf("/") ? baseUrl + unquotedOrigUrl : currentDir + unquotedOrigUrl.replace(/^\.\//, ""), 
                "url(" + JSON.stringify(newUrl) + ")";
              });
            };
          }, /* 9 */
    /***/
          function(module, exports, __nested_webpack_require_44097__) {
            "use strict";
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {
                default: obj
              };
            }
            function _objectWithoutProperties(obj, keys) {
              const target = {};
              for (const i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
              return target;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function _possibleConstructorReturn(self, call) {
              if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !call || "object" != typeof call && "function" != typeof call ? self : call;
            }
            function _inherits(subClass, superClass) {
              if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0
                }
              }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
            }
            Object.defineProperty(exports, "__esModule", {
              value: !0
            });
            const _extends = Object.assign || function(target) {
                for (let i = 1; i < arguments.length; i++) {
                  const source = arguments[i];
                  for (const key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
              }, _createClass = function() {
                function defineProperties(target, props) {
                  for (let i = 0; i < props.length; i++) {
                    const descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function(Constructor, protoProps, staticProps) {
                  return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                  Constructor;
                };
              }(), _react = __nested_webpack_require_44097__(0), _react2 = _interopRequireDefault(_react), _propTypes = __nested_webpack_require_44097__(1), _propTypes2 = _interopRequireDefault(_propTypes), _treeNodeRenderer = __nested_webpack_require_44097__(10), _treeNodeRenderer2 = _interopRequireDefault(_treeNodeRenderer), FileThemeTreeNodeRenderer = function(_Component) {
                function FileThemeTreeNodeRenderer() {
                  return _classCallCheck(this, FileThemeTreeNodeRenderer), _possibleConstructorReturn(this, (FileThemeTreeNodeRenderer.__proto__ || Object.getPrototypeOf(FileThemeTreeNodeRenderer)).apply(this, arguments));
                }
                return _inherits(FileThemeTreeNodeRenderer, _Component), _createClass(FileThemeTreeNodeRenderer, [ {
                  key: "render",
                  value: function() {
                    const _props = this.props, children = _props.children, listIndex = _props.listIndex, swapFrom = _props.swapFrom, swapLength = _props.swapLength, swapDepth = _props.swapDepth, lowerSiblingCounts = (_props.scaffoldBlockPxWidth, 
                      _props.lowerSiblingCounts), connectDropTarget = _props.connectDropTarget, isOver = _props.isOver, draggedNode = _props.draggedNode, canDrop = _props.canDrop, otherProps = (_props.treeIndex, 
                      _props.treeId, _props.getPrevRow, _props.node, _props.path, _props.rowDirection, 
                      _objectWithoutProperties(_props, [ "children", "listIndex", "swapFrom", "swapLength", "swapDepth", "scaffoldBlockPxWidth", "lowerSiblingCounts", "connectDropTarget", "isOver", "draggedNode", "canDrop", "treeIndex", "treeId", "getPrevRow", "node", "path", "rowDirection" ]));
                    return connectDropTarget(_react2.default.createElement("div", _extends({}, otherProps, {
                      className: _treeNodeRenderer2.default.node
                    }), _react.Children.map(children, function(child) {
                      return (0, _react.cloneElement)(child, {
                        isOver: isOver,
                        canDrop: canDrop,
                        draggedNode: draggedNode,
                        lowerSiblingCounts: lowerSiblingCounts,
                        listIndex: listIndex,
                        swapFrom: swapFrom,
                        swapLength: swapLength,
                        swapDepth: swapDepth
                      });
                    })));
                  }
                } ]), FileThemeTreeNodeRenderer;
              }(_react.Component);
            FileThemeTreeNodeRenderer.defaultProps = {
              swapFrom: null,
              swapDepth: null,
              swapLength: null,
              canDrop: !1,
              draggedNode: null
            }, FileThemeTreeNodeRenderer.propTypes = {
              treeIndex: _propTypes2.default.number.isRequired,
              treeId: _propTypes2.default.string.isRequired,
              swapFrom: _propTypes2.default.number,
              swapDepth: _propTypes2.default.number,
              swapLength: _propTypes2.default.number,
              scaffoldBlockPxWidth: _propTypes2.default.number.isRequired,
              lowerSiblingCounts: _propTypes2.default.arrayOf(_propTypes2.default.number).isRequired,
              listIndex: _propTypes2.default.number.isRequired,
              children: _propTypes2.default.node.isRequired,
            // Drop target
              connectDropTarget: _propTypes2.default.func.isRequired,
              isOver: _propTypes2.default.bool.isRequired,
              canDrop: _propTypes2.default.bool,
              draggedNode: _propTypes2.default.shape({}),
            // used in dndManager
              getPrevRow: _propTypes2.default.func.isRequired,
              node: _propTypes2.default.shape({}).isRequired,
              path: _propTypes2.default.arrayOf(_propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.number ])).isRequired,
              rowDirection: _propTypes2.default.string.isRequired
            }, exports.default = FileThemeTreeNodeRenderer;
          }, /* 10 */
    /***/
          function(module, exports, __nested_webpack_require_50849__) {
        // style-loader: Adds some css to the DOM by adding a <style> tag
        // load the styles
            let content = __nested_webpack_require_50849__(11);
            "string" == typeof content && (content = [ [ module.i, content, "" ] ]);
        // Prepare cssTransformation
            const options = {
              insertAt: "top",
              hmr: !0
            };
            options.transform = void 0;
        // add the styles to the DOM
            __nested_webpack_require_50849__(3)(content, options);
            content.locals && (module.exports = content.locals);
          }, /* 11 */
    /***/
          function(module, exports, __nested_webpack_require_51462__) {
            exports = module.exports = __nested_webpack_require_51462__(2)(!1), // imports
        // module
            exports.push([ module.i, ".rstcustom__node {\n  min-width: 100%;\n  position: relative; }\n", "" ]), 
        // exports
            exports.locals = {
              node: "rstcustom__node"
            };
          } ]);
      });

/***/ }),

/***/ "./node_modules/react-sortable-tree/dist/index.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/react-sortable-tree/dist/index.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SortableTreeWithoutDndContext: () => (/* binding */ SortableTreeWithoutDndContext),
/* harmony export */   addNodeUnderParent: () => (/* binding */ addNodeUnderParent),
/* harmony export */   changeNodeAtPath: () => (/* binding */ changeNodeAtPath),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultGetNodeKey: () => (/* binding */ defaultGetNodeKey),
/* harmony export */   defaultSearchMethod: () => (/* binding */ defaultSearchMethod),
/* harmony export */   find: () => (/* binding */ find),
/* harmony export */   getDepth: () => (/* binding */ getDepth),
/* harmony export */   getDescendantCount: () => (/* binding */ getDescendantCount),
/* harmony export */   getFlatDataFromTree: () => (/* binding */ getFlatDataFromTree),
/* harmony export */   getNodeAtPath: () => (/* binding */ getNodeAtPath),
/* harmony export */   getTreeFromFlatData: () => (/* binding */ getTreeFromFlatData),
/* harmony export */   getVisibleNodeCount: () => (/* binding */ getVisibleNodeCount),
/* harmony export */   getVisibleNodeInfoAtIndex: () => (/* binding */ getVisibleNodeInfoAtIndex),
/* harmony export */   insertNode: () => (/* binding */ insertNode),
/* harmony export */   isDescendant: () => (/* binding */ isDescendant),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   removeNode: () => (/* binding */ removeNode),
/* harmony export */   removeNodeAtPath: () => (/* binding */ removeNodeAtPath),
/* harmony export */   toggleExpandedForAll: () => (/* binding */ toggleExpandedForAll),
/* harmony export */   walk: () => (/* binding */ walk)
/* harmony export */ });
/* harmony import */ const frontend_collective_react_dnd_scrollzone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! frontend-collective-react-dnd-scrollzone */ "./node_modules/frontend-collective-react-dnd-scrollzone/lib/index.js");
/* harmony import */ const lodash_isequal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.isequal */ "./node_modules/lodash.isequal/index.js");
/* harmony import */ const lodash_isequal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isequal__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const react_dnd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dnd */ "react-dnd");
/* harmony import */ const react_dnd__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dnd__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const react_dnd_html5_backend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-dnd-html5-backend */ "react-dnd-html5-backend");
/* harmony import */ const react_dnd_html5_backend__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react_dnd_html5_backend__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const react_virtualized__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-virtualized */ "./node_modules/react-virtualized/dist/es/index.js");
/* harmony import */ const react_dom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ const react_dom__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_7__);









      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function (obj) {
            return typeof obj;
          };
        } else {
          _typeof = function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (let i = 0; i < props.length; i++) {
          const descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      function _extends() {
        _extends = Object.assign || function (target) {
          for (let i = 1; i < arguments.length; i++) {
            const source = arguments[i];

            for (const key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        };

        return _extends.apply(this, arguments);
      }

      function ownKeys(object, enumerableOnly) {
        const keys = Object.keys(object);

        if (Object.getOwnPropertySymbols) {
          let symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly) symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
          keys.push.apply(keys, symbols);
        }

        return keys;
      }

      function _objectSpread2(target) {
        for (let i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};

          if (i % 2) {
            ownKeys(Object(source), true).forEach(function (key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }

        return target;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null) return {};
        const target = {};
        const sourceKeys = Object.keys(source);
        let key, i;

        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          target[key] = source[key];
        }

        return target;
      }

      function _objectWithoutProperties(source, excluded) {
        if (source == null) return {};

        const target = _objectWithoutPropertiesLoose(source, excluded);

        let key, i;

        if (Object.getOwnPropertySymbols) {
          const sourceSymbolKeys = Object.getOwnPropertySymbols(source);

          for (i = 0; i < sourceSymbolKeys.length; i++) {
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
          }
        }

        return target;
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (typeof call === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
      }

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

          return arr2;
        }
      }

      function _iterableToArray(iter) {
        if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
      }

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance");
      }

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

      function componentWillMount() {
  // Call this.constructor.gDSFP to support sub-classes.
        const state = this.constructor.getDerivedStateFromProps(this.props, this.state);
        if (state !== null && state !== undefined) {
          this.setState(state);
        }
      }

      function componentWillReceiveProps(nextProps) {
  // Call this.constructor.gDSFP to support sub-classes.
  // Use the setState() updater to ensure state isn't stale in certain edge cases.
        function updater(prevState) {
          const state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
          return state !== null && state !== undefined ? state : null;
        }
  // Binding "this" is important for shallow renderer support.
        this.setState(updater.bind(this));
      }

      function componentWillUpdate(nextProps, nextState) {
        try {
          var prevProps = this.props;
          var prevState = this.state;
          this.props = nextProps;
          this.state = nextState;
          this.__reactInternalSnapshotFlag = true;
          this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
            prevProps,
            prevState
          );
        } finally {
          this.props = prevProps;
          this.state = prevState;
        }
      }

// React may warn about cWM/cWRP/cWU methods being deprecated.
// Add a flag to suppress these warnings for this special case.
      componentWillMount.__suppressDeprecationWarning = true;
      componentWillReceiveProps.__suppressDeprecationWarning = true;
      componentWillUpdate.__suppressDeprecationWarning = true;

      function polyfill(Component) {
        const prototype = Component.prototype;

        if (!prototype || !prototype.isReactComponent) {
          throw new Error('Can only polyfill class components');
        }

        if (
          typeof Component.getDerivedStateFromProps !== 'function' &&
    typeof prototype.getSnapshotBeforeUpdate !== 'function'
        ) {
          return Component;
        }

  // If new component APIs are defined, "unsafe" lifecycles won't be called.
  // Error if any of these lifecycles are present,
  // Because they would work differently between older and newer (16.3+) versions of React.
        let foundWillMountName = null;
        let foundWillReceivePropsName = null;
        let foundWillUpdateName = null;
        if (typeof prototype.componentWillMount === 'function') {
          foundWillMountName = 'componentWillMount';
        } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
          foundWillMountName = 'UNSAFE_componentWillMount';
        }
        if (typeof prototype.componentWillReceiveProps === 'function') {
          foundWillReceivePropsName = 'componentWillReceiveProps';
        } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
          foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
        }
        if (typeof prototype.componentWillUpdate === 'function') {
          foundWillUpdateName = 'componentWillUpdate';
        } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
          foundWillUpdateName = 'UNSAFE_componentWillUpdate';
        }
        if (
          foundWillMountName !== null ||
    foundWillReceivePropsName !== null ||
    foundWillUpdateName !== null
        ) {
          const componentName = Component.displayName || Component.name;
          const newApiName =
      typeof Component.getDerivedStateFromProps === 'function'
        ? 'getDerivedStateFromProps()'
        : 'getSnapshotBeforeUpdate()';

          throw Error(
            'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' +
        componentName +
        ' uses ' +
        newApiName +
        ' but also contains the following legacy lifecycles:' +
        (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') +
        (foundWillReceivePropsName !== null
          ? '\n  ' + foundWillReceivePropsName
          : '') +
        (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') +
        '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' +
        'https://fb.me/react-async-component-lifecycle-hooks'
          );
        }

  // React <= 16.2 does not support static getDerivedStateFromProps.
  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
  // Newer versions of React will ignore these lifecycles if gDSFP exists.
        if (typeof Component.getDerivedStateFromProps === 'function') {
          prototype.componentWillMount = componentWillMount;
          prototype.componentWillReceiveProps = componentWillReceiveProps;
        }

  // React <= 16.2 does not support getSnapshotBeforeUpdate.
  // As a workaround, use cWU to invoke the new lifecycle.
  // Newer versions of React will ignore that lifecycle if gSBU exists.
        if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
          if (typeof prototype.componentDidUpdate !== 'function') {
            throw new Error(
              'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'
            );
          }

          prototype.componentWillUpdate = componentWillUpdate;

          const componentDidUpdate = prototype.componentDidUpdate;

          prototype.componentDidUpdate = function componentDidUpdatePolyfill(
            prevProps,
            prevState,
            maybeSnapshot
          ) {
      // 16.3+ will not execute our will-update method;
      // It will pass a snapshot value to did-update though.
      // Older versions will require our polyfilled will-update value.
      // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
      // Because for <= 15.x versions this might be a "prevContext" object.
      // We also can't just check "__reactInternalSnapshot",
      // Because get-snapshot might return a falsy value.
      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
            const snapshot = this.__reactInternalSnapshotFlag
              ? this.__reactInternalSnapshot
              : maybeSnapshot;

            componentDidUpdate.call(this, prevProps, prevState, snapshot);
          };
        }

        return Component;
      }

/**
 * Performs a depth-first traversal over all of the node descendants,
 * incrementing currentIndex by 1 for each
 */
      function getNodeDataAtTreeIndexOrNextIndex(_ref) {
        const targetIndex = _ref.targetIndex,
          node = _ref.node,
          currentIndex = _ref.currentIndex,
          getNodeKey = _ref.getNodeKey,
          _ref$path = _ref.path,
          path = _ref$path === void 0 ? [] : _ref$path,
          _ref$lowerSiblingCoun = _ref.lowerSiblingCounts,
          lowerSiblingCounts = _ref$lowerSiblingCoun === void 0 ? [] : _ref$lowerSiblingCoun,
          _ref$ignoreCollapsed = _ref.ignoreCollapsed,
          ignoreCollapsed = _ref$ignoreCollapsed === void 0 ? true : _ref$ignoreCollapsed,
          _ref$isPseudoRoot = _ref.isPseudoRoot,
          isPseudoRoot = _ref$isPseudoRoot === void 0 ? false : _ref$isPseudoRoot;
  // The pseudo-root is not considered in the path
        const selfPath = !isPseudoRoot ? [].concat(_toConsumableArray(path), [getNodeKey({
          node: node,
          treeIndex: currentIndex
        })]) : []; // Return target node when found

        if (currentIndex === targetIndex) {
          return {
            node: node,
            lowerSiblingCounts: lowerSiblingCounts,
            path: selfPath
          };
        } // Add one and continue for nodes with no children or hidden children


        if (!node.children || ignoreCollapsed && node.expanded !== true) {
          return {
            nextIndex: currentIndex + 1
          };
        } // Iterate over each child and their descendants and return the
  // target node if childIndex reaches the targetIndex


        let childIndex = currentIndex + 1;
        const childCount = node.children.length;

        for (let i = 0; i < childCount; i += 1) {
          const result = getNodeDataAtTreeIndexOrNextIndex({
            ignoreCollapsed: ignoreCollapsed,
            getNodeKey: getNodeKey,
            targetIndex: targetIndex,
            node: node.children[i],
            currentIndex: childIndex,
            lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),
            path: selfPath
          });

          if (result.node) {
            return result;
          }

          childIndex = result.nextIndex;
        } // If the target node is not found, return the farthest traversed index


        return {
          nextIndex: childIndex
        };
      }

      function getDescendantCount(_ref2) {
        const node = _ref2.node,
          _ref2$ignoreCollapsed = _ref2.ignoreCollapsed,
          ignoreCollapsed = _ref2$ignoreCollapsed === void 0 ? true : _ref2$ignoreCollapsed;
        return getNodeDataAtTreeIndexOrNextIndex({
          getNodeKey: function getNodeKey() {},
          ignoreCollapsed: ignoreCollapsed,
          node: node,
          currentIndex: 0,
          targetIndex: -1
        }).nextIndex - 1;
      }
/**
 * Walk all descendants of the given node, depth-first
 *
 * @param {Object} args - Function parameters
 * @param {function} args.callback - Function to call on each node
 * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index
 * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`
 * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves
 *                                        as the parent of all the nodes in the tree
 * @param {Object} args.node - A tree node
 * @param {Object=} args.parentNode - The parent node of `node`
 * @param {number} args.currentIndex - The treeIndex of `node`
 * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed
 * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the
 *                                             previous nodes in this path
 *
 * @return {number|false} nextIndex - Index of the next sibling of `node`,
 *                                    or false if the walk should be terminated
 */

      function walkDescendants(_ref3) {
        const callback = _ref3.callback,
          getNodeKey = _ref3.getNodeKey,
          ignoreCollapsed = _ref3.ignoreCollapsed,
          _ref3$isPseudoRoot = _ref3.isPseudoRoot,
          isPseudoRoot = _ref3$isPseudoRoot === void 0 ? false : _ref3$isPseudoRoot,
          node = _ref3.node,
          _ref3$parentNode = _ref3.parentNode,
          parentNode = _ref3$parentNode === void 0 ? null : _ref3$parentNode,
          currentIndex = _ref3.currentIndex,
          _ref3$path = _ref3.path,
          path = _ref3$path === void 0 ? [] : _ref3$path,
          _ref3$lowerSiblingCou = _ref3.lowerSiblingCounts,
          lowerSiblingCounts = _ref3$lowerSiblingCou === void 0 ? [] : _ref3$lowerSiblingCou;
  // The pseudo-root is not considered in the path
        const selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({
          node: node,
          treeIndex: currentIndex
        })]);
        const selfInfo = isPseudoRoot ? null : {
          node: node,
          parentNode: parentNode,
          path: selfPath,
          lowerSiblingCounts: lowerSiblingCounts,
          treeIndex: currentIndex
        };

        if (!isPseudoRoot) {
          const callbackResult = callback(selfInfo); // Cut walk short if the callback returned false

          if (callbackResult === false) {
            return false;
          }
        } // Return self on nodes with no children or hidden children


        if (!node.children || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {
          return currentIndex;
        } // Get all descendants


        let childIndex = currentIndex;
        const childCount = node.children.length;

        if (typeof node.children !== 'function') {
          for (let i = 0; i < childCount; i += 1) {
            childIndex = walkDescendants({
              callback: callback,
              getNodeKey: getNodeKey,
              ignoreCollapsed: ignoreCollapsed,
              node: node.children[i],
              parentNode: isPseudoRoot ? null : node,
              currentIndex: childIndex + 1,
              lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),
              path: selfPath
            }); // Cut walk short if the callback returned false

            if (childIndex === false) {
              return false;
            }
          }
        }

        return childIndex;
      }
/**
 * Perform a change on the given node and all its descendants, traversing the tree depth-first
 *
 * @param {Object} args - Function parameters
 * @param {function} args.callback - Function to call on each node
 * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index
 * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`
 * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves
 *                                        as the parent of all the nodes in the tree
 * @param {Object} args.node - A tree node
 * @param {Object=} args.parentNode - The parent node of `node`
 * @param {number} args.currentIndex - The treeIndex of `node`
 * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed
 * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the
 *                                             previous nodes in this path
 *
 * @return {number|false} nextIndex - Index of the next sibling of `node`,
 *                                    or false if the walk should be terminated
 */


      function mapDescendants(_ref4) {
        const callback = _ref4.callback,
          getNodeKey = _ref4.getNodeKey,
          ignoreCollapsed = _ref4.ignoreCollapsed,
          _ref4$isPseudoRoot = _ref4.isPseudoRoot,
          isPseudoRoot = _ref4$isPseudoRoot === void 0 ? false : _ref4$isPseudoRoot,
          node = _ref4.node,
          _ref4$parentNode = _ref4.parentNode,
          parentNode = _ref4$parentNode === void 0 ? null : _ref4$parentNode,
          currentIndex = _ref4.currentIndex,
          _ref4$path = _ref4.path,
          path = _ref4$path === void 0 ? [] : _ref4$path,
          _ref4$lowerSiblingCou = _ref4.lowerSiblingCounts,
          lowerSiblingCounts = _ref4$lowerSiblingCou === void 0 ? [] : _ref4$lowerSiblingCou;

        const nextNode = _objectSpread2({}, node); // The pseudo-root is not considered in the path


        const selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({
          node: nextNode,
          treeIndex: currentIndex
        })]);
        const selfInfo = {
          node: nextNode,
          parentNode: parentNode,
          path: selfPath,
          lowerSiblingCounts: lowerSiblingCounts,
          treeIndex: currentIndex
        }; // Return self on nodes with no children or hidden children

        if (!nextNode.children || nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot) {
          return {
            treeIndex: currentIndex,
            node: callback(selfInfo)
          };
        } // Get all descendants


        let childIndex = currentIndex;
        const childCount = nextNode.children.length;

        if (typeof nextNode.children !== 'function') {
          nextNode.children = nextNode.children.map(function (child, i) {
            const mapResult = mapDescendants({
              callback: callback,
              getNodeKey: getNodeKey,
              ignoreCollapsed: ignoreCollapsed,
              node: child,
              parentNode: isPseudoRoot ? null : nextNode,
              currentIndex: childIndex + 1,
              lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),
              path: selfPath
            });
            childIndex = mapResult.treeIndex;
            return mapResult.node;
          });
        }

        return {
          node: callback(selfInfo),
          treeIndex: childIndex
        };
      }
/**
 * Count all the visible (expanded) descendants in the tree data.
 *
 * @param {!Object[]} treeData - Tree data
 *
 * @return {number} count
 */


      function getVisibleNodeCount(_ref5) {
        const treeData = _ref5.treeData;

        const traverse = function traverse(node) {
          if (!node.children || node.expanded !== true || typeof node.children === 'function') {
            return 1;
          }

          return 1 + node.children.reduce(function (total, currentNode) {
            return total + traverse(currentNode);
          }, 0);
        };

        return treeData.reduce(function (total, currentNode) {
          return total + traverse(currentNode);
        }, 0);
      }
/**
 * Get the <targetIndex>th visible node in the tree data.
 *
 * @param {!Object[]} treeData - Tree data
 * @param {!number} targetIndex - The index of the node to search for
 * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index
 *
 * @return {{
 *      node: Object,
 *      path: []string|[]number,
 *      lowerSiblingCounts: []number
 *  }|null} node - The node at targetIndex, or null if not found
 */

      function getVisibleNodeInfoAtIndex(_ref6) {
        const treeData = _ref6.treeData,
          targetIndex = _ref6.index,
          getNodeKey = _ref6.getNodeKey;

        if (!treeData || treeData.length < 1) {
          return null;
        } // Call the tree traversal with a pseudo-root node


        const result = getNodeDataAtTreeIndexOrNextIndex({
          targetIndex: targetIndex,
          getNodeKey: getNodeKey,
          node: {
            children: treeData,
            expanded: true
          },
          currentIndex: -1,
          path: [],
          lowerSiblingCounts: [],
          isPseudoRoot: true
        });

        if (result.node) {
          return result;
        }

        return null;
      }
/**
 * Walk descendants depth-first and call a callback on each
 *
 * @param {!Object[]} treeData - Tree data
 * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index
 * @param {function} callback - Function to call on each node
 * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`
 *
 * @return void
 */

      function walk(_ref7) {
        const treeData = _ref7.treeData,
          getNodeKey = _ref7.getNodeKey,
          callback = _ref7.callback,
          _ref7$ignoreCollapsed = _ref7.ignoreCollapsed,
          ignoreCollapsed = _ref7$ignoreCollapsed === void 0 ? true : _ref7$ignoreCollapsed;

        if (!treeData || treeData.length < 1) {
          return;
        }

        walkDescendants({
          callback: callback,
          getNodeKey: getNodeKey,
          ignoreCollapsed: ignoreCollapsed,
          isPseudoRoot: true,
          node: {
            children: treeData
          },
          currentIndex: -1,
          path: [],
          lowerSiblingCounts: []
        });
      }
/**
 * Perform a depth-first transversal of the descendants and
 *  make a change to every node in the tree
 *
 * @param {!Object[]} treeData - Tree data
 * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index
 * @param {function} callback - Function to call on each node
 * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`
 *
 * @return {Object[]} changedTreeData - The changed tree data
 */

      function map(_ref8) {
        const treeData = _ref8.treeData,
          getNodeKey = _ref8.getNodeKey,
          callback = _ref8.callback,
          _ref8$ignoreCollapsed = _ref8.ignoreCollapsed,
          ignoreCollapsed = _ref8$ignoreCollapsed === void 0 ? true : _ref8$ignoreCollapsed;

        if (!treeData || treeData.length < 1) {
          return [];
        }

        return mapDescendants({
          callback: callback,
          getNodeKey: getNodeKey,
          ignoreCollapsed: ignoreCollapsed,
          isPseudoRoot: true,
          node: {
            children: treeData
          },
          currentIndex: -1,
          path: [],
          lowerSiblingCounts: []
        }).node.children;
      }
/**
 * Expand or close every node in the tree
 *
 * @param {!Object[]} treeData - Tree data
 * @param {?boolean} expanded - Whether the node is expanded or not
 *
 * @return {Object[]} changedTreeData - The changed tree data
 */

      function toggleExpandedForAll(_ref9) {
        const treeData = _ref9.treeData,
          _ref9$expanded = _ref9.expanded,
          expanded = _ref9$expanded === void 0 ? true : _ref9$expanded;
        return map({
          treeData: treeData,
          callback: function callback(_ref10) {
            const node = _ref10.node;
            return _objectSpread2(_objectSpread2({}, node), {}, {
              expanded: expanded
            });
          },
          getNodeKey: function getNodeKey(_ref11) {
            const treeIndex = _ref11.treeIndex;
            return treeIndex;
          },
          ignoreCollapsed: false
        });
      }
/**
 * Replaces node at path with object, or callback-defined object
 *
 * @param {!Object[]} treeData
 * @param {number[]|string[]} path - Array of keys leading up to node to be changed
 * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node
 * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index
 * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`
 *
 * @return {Object[]} changedTreeData - The changed tree data
 */

      function changeNodeAtPath(_ref12) {
        const treeData = _ref12.treeData,
          path = _ref12.path,
          newNode = _ref12.newNode,
          getNodeKey = _ref12.getNodeKey,
          _ref12$ignoreCollapse = _ref12.ignoreCollapsed,
          ignoreCollapsed = _ref12$ignoreCollapse === void 0 ? true : _ref12$ignoreCollapse;
        const RESULT_MISS = 'RESULT_MISS';

        const traverse = function traverse(_ref13) {
          const _ref13$isPseudoRoot = _ref13.isPseudoRoot,
            isPseudoRoot = _ref13$isPseudoRoot === void 0 ? false : _ref13$isPseudoRoot,
            node = _ref13.node,
            currentTreeIndex = _ref13.currentTreeIndex,
            pathIndex = _ref13.pathIndex;

          if (!isPseudoRoot && getNodeKey({
            node: node,
            treeIndex: currentTreeIndex
          }) !== path[pathIndex]) {
            return RESULT_MISS;
          }

          if (pathIndex >= path.length - 1) {
      // If this is the final location in the path, return its changed form
            return typeof newNode === 'function' ? newNode({
              node: node,
              treeIndex: currentTreeIndex
            }) : newNode;
          }

          if (!node.children) {
      // If this node is part of the path, but has no children, return the unchanged node
            throw new Error('Path referenced children of node with no children.');
          }

          let nextTreeIndex = currentTreeIndex + 1;

          for (let i = 0; i < node.children.length; i += 1) {
            const _result = traverse({
              node: node.children[i],
              currentTreeIndex: nextTreeIndex,
              pathIndex: pathIndex + 1
            }); // If the result went down the correct path


            if (_result !== RESULT_MISS) {
              if (_result) {
          // If the result was truthy (in this case, an object),
          //  pass it to the next level of recursion up
                return _objectSpread2(_objectSpread2({}, node), {}, {
                  children: [].concat(_toConsumableArray(node.children.slice(0, i)), [_result], _toConsumableArray(node.children.slice(i + 1)))
                });
              } // If the result was falsy (returned from the newNode function), then
        //  delete the node from the array.


              return _objectSpread2(_objectSpread2({}, node), {}, {
                children: [].concat(_toConsumableArray(node.children.slice(0, i)), _toConsumableArray(node.children.slice(i + 1)))
              });
            }

            nextTreeIndex += 1 + getDescendantCount({
              node: node.children[i],
              ignoreCollapsed: ignoreCollapsed
            });
          }

          return RESULT_MISS;
        }; // Use a pseudo-root node in the beginning traversal


        const result = traverse({
          node: {
            children: treeData
          },
          currentTreeIndex: -1,
          pathIndex: -1,
          isPseudoRoot: true
        });

        if (result === RESULT_MISS) {
          throw new Error('No node found at the given path.');
        }

        return result.children;
      }
/**
 * Removes the node at the specified path and returns the resulting treeData.
 *
 * @param {!Object[]} treeData
 * @param {number[]|string[]} path - Array of keys leading up to node to be deleted
 * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index
 * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`
 *
 * @return {Object[]} changedTreeData - The tree data with the node removed
 */

      function removeNodeAtPath(_ref14) {
        const treeData = _ref14.treeData,
          path = _ref14.path,
          getNodeKey = _ref14.getNodeKey,
          _ref14$ignoreCollapse = _ref14.ignoreCollapsed,
          ignoreCollapsed = _ref14$ignoreCollapse === void 0 ? true : _ref14$ignoreCollapse;
        return changeNodeAtPath({
          treeData: treeData,
          path: path,
          getNodeKey: getNodeKey,
          ignoreCollapsed: ignoreCollapsed,
          newNode: null // Delete the node

        });
      }
/**
 * Removes the node at the specified path and returns the resulting treeData.
 *
 * @param {!Object[]} treeData
 * @param {number[]|string[]} path - Array of keys leading up to node to be deleted
 * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index
 * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`
 *
 * @return {Object} result
 * @return {Object[]} result.treeData - The tree data with the node removed
 * @return {Object} result.node - The node that was removed
 * @return {number} result.treeIndex - The previous treeIndex of the removed node
 */

      function removeNode(_ref15) {
        const treeData = _ref15.treeData,
          path = _ref15.path,
          getNodeKey = _ref15.getNodeKey,
          _ref15$ignoreCollapse = _ref15.ignoreCollapsed,
          ignoreCollapsed = _ref15$ignoreCollapse === void 0 ? true : _ref15$ignoreCollapse;
        let removedNode = null;
        let removedTreeIndex = null;
        const nextTreeData = changeNodeAtPath({
          treeData: treeData,
          path: path,
          getNodeKey: getNodeKey,
          ignoreCollapsed: ignoreCollapsed,
          newNode: function newNode(_ref16) {
            const node = _ref16.node,
              treeIndex = _ref16.treeIndex;
      // Store the target node and delete it from the tree
            removedNode = node;
            removedTreeIndex = treeIndex;
            return null;
          }
        });
        return {
          treeData: nextTreeData,
          node: removedNode,
          treeIndex: removedTreeIndex
        };
      }
/**
 * Gets the node at the specified path
 *
 * @param {!Object[]} treeData
 * @param {number[]|string[]} path - Array of keys leading up to node to be deleted
 * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index
 * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`
 *
 * @return {Object|null} nodeInfo - The node info at the given path, or null if not found
 */

      function getNodeAtPath(_ref17) {
        const treeData = _ref17.treeData,
          path = _ref17.path,
          getNodeKey = _ref17.getNodeKey,
          _ref17$ignoreCollapse = _ref17.ignoreCollapsed,
          ignoreCollapsed = _ref17$ignoreCollapse === void 0 ? true : _ref17$ignoreCollapse;
        let foundNodeInfo = null;

        try {
          changeNodeAtPath({
            treeData: treeData,
            path: path,
            getNodeKey: getNodeKey,
            ignoreCollapsed: ignoreCollapsed,
            newNode: function newNode(_ref18) {
              const node = _ref18.node,
                treeIndex = _ref18.treeIndex;
              foundNodeInfo = {
                node: node,
                treeIndex: treeIndex
              };
              return node;
            }
          });
        } catch (err) {// Ignore the error -- the null return will be explanation enough
        }

        return foundNodeInfo;
      }
/**
 * Adds the node to the specified parent and returns the resulting treeData.
 *
 * @param {!Object[]} treeData
 * @param {!Object} newNode - The node to insert
 * @param {number|string} parentKey - The key of the to-be parentNode of the node
 * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index
 * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`
 * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath
 * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree
 *
 * @return {Object} result
 * @return {Object[]} result.treeData - The updated tree data
 * @return {number} result.treeIndex - The tree index at which the node was inserted
 */

      function addNodeUnderParent(_ref19) {
        const treeData = _ref19.treeData,
          newNode = _ref19.newNode,
          _ref19$parentKey = _ref19.parentKey,
          parentKey = _ref19$parentKey === void 0 ? null : _ref19$parentKey,
          getNodeKey = _ref19.getNodeKey,
          _ref19$ignoreCollapse = _ref19.ignoreCollapsed,
          ignoreCollapsed = _ref19$ignoreCollapse === void 0 ? true : _ref19$ignoreCollapse,
          _ref19$expandParent = _ref19.expandParent,
          expandParent = _ref19$expandParent === void 0 ? false : _ref19$expandParent,
          _ref19$addAsFirstChil = _ref19.addAsFirstChild,
          addAsFirstChild = _ref19$addAsFirstChil === void 0 ? false : _ref19$addAsFirstChil;

        if (parentKey === null) {
          return addAsFirstChild ? {
            treeData: [newNode].concat(_toConsumableArray(treeData || [])),
            treeIndex: 0
          } : {
            treeData: [].concat(_toConsumableArray(treeData || []), [newNode]),
            treeIndex: (treeData || []).length
          };
        }

        let insertedTreeIndex = null;
        let hasBeenAdded = false;
        const changedTreeData = map({
          treeData: treeData,
          getNodeKey: getNodeKey,
          ignoreCollapsed: ignoreCollapsed,
          callback: function callback(_ref20) {
            const node = _ref20.node,
              treeIndex = _ref20.treeIndex,
              path = _ref20.path;
            const key = path ? path[path.length - 1] : null; // Return nodes that are not the parent as-is

            if (hasBeenAdded || key !== parentKey) {
              return node;
            }

            hasBeenAdded = true;

            const parentNode = _objectSpread2({}, node);

            if (expandParent) {
              parentNode.expanded = true;
            } // If no children exist yet, just add the single newNode


            if (!parentNode.children) {
              insertedTreeIndex = treeIndex + 1;
              return _objectSpread2(_objectSpread2({}, parentNode), {}, {
                children: [newNode]
              });
            }

            if (typeof parentNode.children === 'function') {
              throw new Error('Cannot add to children defined by a function');
            }

            let nextTreeIndex = treeIndex + 1;

            for (let i = 0; i < parentNode.children.length; i += 1) {
              nextTreeIndex += 1 + getDescendantCount({
                node: parentNode.children[i],
                ignoreCollapsed: ignoreCollapsed
              });
            }

            insertedTreeIndex = nextTreeIndex;
            const children = addAsFirstChild ? [newNode].concat(_toConsumableArray(parentNode.children)) : [].concat(_toConsumableArray(parentNode.children), [newNode]);
            return _objectSpread2(_objectSpread2({}, parentNode), {}, {
              children: children
            });
          }
        });

        if (!hasBeenAdded) {
          throw new Error('No node found with the given key.');
        }

        return {
          treeData: changedTreeData,
          treeIndex: insertedTreeIndex
        };
      }

      function addNodeAtDepthAndIndex(_ref21) {
        const targetDepth = _ref21.targetDepth,
          minimumTreeIndex = _ref21.minimumTreeIndex,
          newNode = _ref21.newNode,
          ignoreCollapsed = _ref21.ignoreCollapsed,
          expandParent = _ref21.expandParent,
          _ref21$isPseudoRoot = _ref21.isPseudoRoot,
          isPseudoRoot = _ref21$isPseudoRoot === void 0 ? false : _ref21$isPseudoRoot,
          isLastChild = _ref21.isLastChild,
          node = _ref21.node,
          currentIndex = _ref21.currentIndex,
          currentDepth = _ref21.currentDepth,
          getNodeKey = _ref21.getNodeKey,
          _ref21$path = _ref21.path,
          path = _ref21$path === void 0 ? [] : _ref21$path;

        const selfPath = function selfPath(n) {
          return isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({
            node: n,
            treeIndex: currentIndex
          })]);
        }; // If the current position is the only possible place to add, add it


        if (currentIndex >= minimumTreeIndex - 1 || isLastChild && !(node.children && node.children.length)) {
          if (typeof node.children === 'function') {
            throw new Error('Cannot add to children defined by a function');
          } else {
            const extraNodeProps = expandParent ? {
              expanded: true
            } : {};

            const _nextNode = _objectSpread2(_objectSpread2(_objectSpread2({}, node), extraNodeProps), {}, {
              children: node.children ? [newNode].concat(_toConsumableArray(node.children)) : [newNode]
            });

            return {
              node: _nextNode,
              nextIndex: currentIndex + 2,
              insertedTreeIndex: currentIndex + 1,
              parentPath: selfPath(_nextNode),
              parentNode: isPseudoRoot ? null : _nextNode
            };
          }
        } // If this is the target depth for the insertion,
  // i.e., where the newNode can be added to the current node's children


        if (currentDepth >= targetDepth - 1) {
    // Skip over nodes with no children or hidden children
          if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {
            return {
              node: node,
              nextIndex: currentIndex + 1
            };
          } // Scan over the children to see if there's a place among them that fulfills
    // the minimumTreeIndex requirement


          let _childIndex = currentIndex + 1;

          let _insertedTreeIndex = null;
          let insertIndex = null;

          for (let i = 0; i < node.children.length; i += 1) {
      // If a valid location is found, mark it as the insertion location and
      // break out of the loop
            if (_childIndex >= minimumTreeIndex) {
              _insertedTreeIndex = _childIndex;
              insertIndex = i;
              break;
            } // Increment the index by the child itself plus the number of descendants it has


            _childIndex += 1 + getDescendantCount({
              node: node.children[i],
              ignoreCollapsed: ignoreCollapsed
            });
          } // If no valid indices to add the node were found


          if (insertIndex === null) {
      // If the last position in this node's children is less than the minimum index
      // and there are more children on the level of this node, return without insertion
            if (_childIndex < minimumTreeIndex && !isLastChild) {
              return {
                node: node,
                nextIndex: _childIndex
              };
            } // Use the last position in the children array to insert the newNode


            _insertedTreeIndex = _childIndex;
            insertIndex = node.children.length;
          } // Insert the newNode at the insertIndex


          const _nextNode2 = _objectSpread2(_objectSpread2({}, node), {}, {
            children: [].concat(_toConsumableArray(node.children.slice(0, insertIndex)), [newNode], _toConsumableArray(node.children.slice(insertIndex)))
          }); // Return node with successful insert result


          return {
            node: _nextNode2,
            nextIndex: _childIndex,
            insertedTreeIndex: _insertedTreeIndex,
            parentPath: selfPath(_nextNode2),
            parentNode: isPseudoRoot ? null : _nextNode2
          };
        } // Skip over nodes with no children or hidden children


        if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {
          return {
            node: node,
            nextIndex: currentIndex + 1
          };
        } // Get all descendants


        let insertedTreeIndex = null;
        let pathFragment = null;
        let parentNode = null;
        let childIndex = currentIndex + 1;
        let newChildren = node.children;

        if (typeof newChildren !== 'function') {
          newChildren = newChildren.map(function (child, i) {
            if (insertedTreeIndex !== null) {
              return child;
            }

            const mapResult = addNodeAtDepthAndIndex({
              targetDepth: targetDepth,
              minimumTreeIndex: minimumTreeIndex,
              newNode: newNode,
              ignoreCollapsed: ignoreCollapsed,
              expandParent: expandParent,
              isLastChild: isLastChild && i === newChildren.length - 1,
              node: child,
              currentIndex: childIndex,
              currentDepth: currentDepth + 1,
              getNodeKey: getNodeKey,
              path: [] // Cannot determine the parent path until the children have been processed

            });

            if ('insertedTreeIndex' in mapResult) {
              insertedTreeIndex = mapResult.insertedTreeIndex;
              parentNode = mapResult.parentNode;
              pathFragment = mapResult.parentPath;
            }

            childIndex = mapResult.nextIndex;
            return mapResult.node;
          });
        }

        const nextNode = _objectSpread2(_objectSpread2({}, node), {}, {
          children: newChildren
        });

        const result = {
          node: nextNode,
          nextIndex: childIndex
        };

        if (insertedTreeIndex !== null) {
          result.insertedTreeIndex = insertedTreeIndex;
          result.parentPath = [].concat(_toConsumableArray(selfPath(nextNode)), _toConsumableArray(pathFragment));
          result.parentNode = parentNode;
        }

        return result;
      }
/**
 * Insert a node into the tree at the given depth, after the minimum index
 *
 * @param {!Object[]} treeData - Tree data
 * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)
 * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at
 * @param {!Object} newNode - The node to insert into the tree
 * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`
 * @param {boolean=} expandParent - If true, expands the parent of the inserted node
 * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index
 *
 * @return {Object} result
 * @return {Object[]} result.treeData - The tree data with the node added
 * @return {number} result.treeIndex - The tree index at which the node was inserted
 * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion
 * @return {Object} result.parentNode - The parent node of the inserted node
 */


      function insertNode(_ref22) {
        const treeData = _ref22.treeData,
          targetDepth = _ref22.depth,
          minimumTreeIndex = _ref22.minimumTreeIndex,
          newNode = _ref22.newNode,
          _ref22$getNodeKey = _ref22.getNodeKey,
          getNodeKey = _ref22$getNodeKey === void 0 ? function () {} : _ref22$getNodeKey,
          _ref22$ignoreCollapse = _ref22.ignoreCollapsed,
          ignoreCollapsed = _ref22$ignoreCollapse === void 0 ? true : _ref22$ignoreCollapse,
          _ref22$expandParent = _ref22.expandParent,
          expandParent = _ref22$expandParent === void 0 ? false : _ref22$expandParent;

        if (!treeData && targetDepth === 0) {
          return {
            treeData: [newNode],
            treeIndex: 0,
            path: [getNodeKey({
              node: newNode,
              treeIndex: 0
            })],
            parentNode: null
          };
        }

        const insertResult = addNodeAtDepthAndIndex({
          targetDepth: targetDepth,
          minimumTreeIndex: minimumTreeIndex,
          newNode: newNode,
          ignoreCollapsed: ignoreCollapsed,
          expandParent: expandParent,
          getNodeKey: getNodeKey,
          isPseudoRoot: true,
          isLastChild: true,
          node: {
            children: treeData
          },
          currentIndex: -1,
          currentDepth: -1
        });

        if (!('insertedTreeIndex' in insertResult)) {
          throw new Error('No suitable position found to insert.');
        }

        const treeIndex = insertResult.insertedTreeIndex;
        return {
          treeData: insertResult.node.children,
          treeIndex: treeIndex,
          path: [].concat(_toConsumableArray(insertResult.parentPath), [getNodeKey({
            node: newNode,
            treeIndex: treeIndex
          })]),
          parentNode: insertResult.parentNode
        };
      }
/**
 * Get tree data flattened.
 *
 * @param {!Object[]} treeData - Tree data
 * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index
 * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`
 *
 * @return {{
 *      node: Object,
 *      path: []string|[]number,
 *      lowerSiblingCounts: []number
 *  }}[] nodes - The node array
 */

      function getFlatDataFromTree(_ref23) {
        const treeData = _ref23.treeData,
          getNodeKey = _ref23.getNodeKey,
          _ref23$ignoreCollapse = _ref23.ignoreCollapsed,
          ignoreCollapsed = _ref23$ignoreCollapse === void 0 ? true : _ref23$ignoreCollapse;

        if (!treeData || treeData.length < 1) {
          return [];
        }

        const flattened = [];
        walk({
          treeData: treeData,
          getNodeKey: getNodeKey,
          ignoreCollapsed: ignoreCollapsed,
          callback: function callback(nodeInfo) {
            flattened.push(nodeInfo);
          }
        });
        return flattened;
      }
/**
 * Generate a tree structure from flat data.
 *
 * @param {!Object[]} flatData
 * @param {!function=} getKey - Function to get the key from the nodeData
 * @param {!function=} getParentKey - Function to get the parent key from the nodeData
 * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.
 *                                  For example, if your nodes have id 1-99, you might use rootKey = 0
 *
 * @return {Object[]} treeData - The flat data represented as a tree
 */

      function getTreeFromFlatData(_ref24) {
        const flatData = _ref24.flatData,
          _ref24$getKey = _ref24.getKey,
          getKey = _ref24$getKey === void 0 ? function (node) {
            return node.id;
          } : _ref24$getKey,
          _ref24$getParentKey = _ref24.getParentKey,
          getParentKey = _ref24$getParentKey === void 0 ? function (node) {
            return node.parentId;
          } : _ref24$getParentKey,
          _ref24$rootKey = _ref24.rootKey,
          rootKey = _ref24$rootKey === void 0 ? '0' : _ref24$rootKey;

        if (!flatData) {
          return [];
        }

        const childrenToParents = {};
        flatData.forEach(function (child) {
          const parentKey = getParentKey(child);

          if (parentKey in childrenToParents) {
            childrenToParents[parentKey].push(child);
          } else {
            childrenToParents[parentKey] = [child];
          }
        });

        if (!(rootKey in childrenToParents)) {
          return [];
        }

        const trav = function trav(parent) {
          const parentKey = getKey(parent);

          if (parentKey in childrenToParents) {
            return _objectSpread2(_objectSpread2({}, parent), {}, {
              children: childrenToParents[parentKey].map(function (child) {
                return trav(child);
              })
            });
          }

          return _objectSpread2({}, parent);
        };

        return childrenToParents[rootKey].map(function (child) {
          return trav(child);
        });
      }
/**
 * Check if a node is a descendant of another node.
 *
 * @param {!Object} older - Potential ancestor of younger node
 * @param {!Object} younger - Potential descendant of older node
 *
 * @return {boolean}
 */

      function isDescendant(older, younger) {
        return !!older.children && typeof older.children !== 'function' && older.children.some(function (child) {
          return child === younger || isDescendant(child, younger);
        });
      }
/**
 * Get the maximum depth of the children (the depth of the root node is 0).
 *
 * @param {!Object} node - Node in the tree
 * @param {?number} depth - The current depth
 *
 * @return {number} maxDepth - The deepest depth in the tree
 */

      function getDepth(node) {
        const depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (!node.children) {
          return depth;
        }

        if (typeof node.children === 'function') {
          return depth + 1;
        }

        return node.children.reduce(function (deepest, child) {
          return Math.max(deepest, getDepth(child, depth + 1));
        }, depth);
      }
/**
 * Find nodes matching a search query in the tree,
 *
 * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index
 * @param {!Object[]} treeData - Tree data
 * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not
 * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not
 * @param {?number} searchFocusOffset - The offset of the match to focus on
 *                                      (e.g., 0 focuses on the first match, 1 on the second)
 * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node
 * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node
 *
 * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s
 * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.
 *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,
 *                               it will be the same as the original tree data.
 */

      function find(_ref25) {
        const getNodeKey = _ref25.getNodeKey,
          treeData = _ref25.treeData,
          searchQuery = _ref25.searchQuery,
          searchMethod = _ref25.searchMethod,
          searchFocusOffset = _ref25.searchFocusOffset,
          _ref25$expandAllMatch = _ref25.expandAllMatchPaths,
          expandAllMatchPaths = _ref25$expandAllMatch === void 0 ? false : _ref25$expandAllMatch,
          _ref25$expandFocusMat = _ref25.expandFocusMatchPaths,
          expandFocusMatchPaths = _ref25$expandFocusMat === void 0 ? true : _ref25$expandFocusMat;
        let matchCount = 0;

        const trav = function trav(_ref26) {
          const _ref26$isPseudoRoot = _ref26.isPseudoRoot,
            isPseudoRoot = _ref26$isPseudoRoot === void 0 ? false : _ref26$isPseudoRoot,
            node = _ref26.node,
            currentIndex = _ref26.currentIndex,
            _ref26$path = _ref26.path,
            path = _ref26$path === void 0 ? [] : _ref26$path;
          let matches = [];
          let isSelfMatch = false;
          let hasFocusMatch = false; // The pseudo-root is not considered in the path

          const selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({
            node: node,
            treeIndex: currentIndex
          })]);
          const extraInfo = isPseudoRoot ? null : {
            path: selfPath,
            treeIndex: currentIndex
          }; // Nodes with with children that aren't lazy

          const hasChildren = node.children && typeof node.children !== 'function' && node.children.length > 0; // Examine the current node to see if it is a match

          if (!isPseudoRoot && searchMethod(_objectSpread2(_objectSpread2({}, extraInfo), {}, {
            node: node,
            searchQuery: searchQuery
          }))) {
            if (matchCount === searchFocusOffset) {
              hasFocusMatch = true;
            } // Keep track of the number of matching nodes, so we know when the searchFocusOffset
      //  is reached


            matchCount += 1; // We cannot add this node to the matches right away, as it may be changed
      //  during the search of the descendants. The entire node is used in
      //  comparisons between nodes inside the `matches` and `treeData` results
      //  of this method (`find`)

            isSelfMatch = true;
          }

          let childIndex = currentIndex;

          const newNode = _objectSpread2({}, node);

          if (hasChildren) {
      // Get all descendants
            newNode.children = newNode.children.map(function (child) {
              const mapResult = trav({
                node: child,
                currentIndex: childIndex + 1,
                path: selfPath
              }); // Ignore hidden nodes by only advancing the index counter to the returned treeIndex
        // if the child is expanded.
        //
        // The child could have been expanded from the start,
        // or expanded due to a matching node being found in its descendants

              if (mapResult.node.expanded) {
                childIndex = mapResult.treeIndex;
              } else {
                childIndex += 1;
              }

              if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {
                matches = [].concat(_toConsumableArray(matches), _toConsumableArray(mapResult.matches));

                if (mapResult.hasFocusMatch) {
                  hasFocusMatch = true;
                } // Expand the current node if it has descendants matching the search
          // and the settings are set to do so.


                if (expandAllMatchPaths && mapResult.matches.length > 0 || (expandAllMatchPaths || expandFocusMatchPaths) && mapResult.hasFocusMatch) {
                  newNode.expanded = true;
                }
              }

              return mapResult.node;
            });
          } // Cannot assign a treeIndex to hidden nodes


          if (!isPseudoRoot && !newNode.expanded) {
            matches = matches.map(function (match) {
              return _objectSpread2(_objectSpread2({}, match), {}, {
                treeIndex: null
              });
            });
          } // Add this node to the matches if it fits the search criteria.
    // This is performed at the last minute so newNode can be sent in its final form.


          if (isSelfMatch) {
            matches = [_objectSpread2(_objectSpread2({}, extraInfo), {}, {
              node: newNode
            })].concat(_toConsumableArray(matches));
          }

          return {
            node: matches.length > 0 ? newNode : node,
            matches: matches,
            hasFocusMatch: hasFocusMatch,
            treeIndex: childIndex
          };
        };

        const result = trav({
          node: {
            children: treeData
          },
          isPseudoRoot: true,
          currentIndex: -1
        });
        return {
          matches: result.matches,
          treeData: result.node.children
        };
      }

// very simple className utility for creating a classname string...
// Falsy arguments are ignored:
//
// const active = true
// const className = classnames(
//    "class1",
//    !active && "class2",
//    active && "class3"
// ); // returns -> class1 class3";
//
      function classnames() {
        for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
          classes[_key] = arguments[_key];
        }

  // Use Boolean constructor as a filter callback
  // Allows for loose type truthy/falsey checks
  // Boolean("") === false;
  // Boolean(false) === false;
  // Boolean(undefined) === false;
  // Boolean(null) === false;
  // Boolean(0) === false;
  // Boolean("classname") === true;
        return classes.filter(Boolean).join(' ');
      }

      function _createSuper(Derived) {
        function isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;

          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }

        return function () {
          let Super = _getPrototypeOf(Derived),
            result;

          if (isNativeReflectConstruct()) {
            const NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      const NodeRendererDefault =
/*#__PURE__*/
function (_Component) {
  _inherits(NodeRendererDefault, _Component);

  const _super = _createSuper(NodeRendererDefault);

  function NodeRendererDefault() {
    _classCallCheck(this, NodeRendererDefault);

    return _super.apply(this, arguments);
  }

  _createClass(NodeRendererDefault, [{
    key: "render",
    value: function render() {
      const _this$props = this.props,
        scaffoldBlockPxWidth = _this$props.scaffoldBlockPxWidth,
        toggleChildrenVisibility = _this$props.toggleChildrenVisibility,
        connectDragPreview = _this$props.connectDragPreview,
        connectDragSource = _this$props.connectDragSource,
        isDragging = _this$props.isDragging,
        canDrop = _this$props.canDrop,
        canDrag = _this$props.canDrag,
        node = _this$props.node,
        title = _this$props.title,
        subtitle = _this$props.subtitle,
        draggedNode = _this$props.draggedNode,
        path = _this$props.path,
        treeIndex = _this$props.treeIndex,
        isSearchMatch = _this$props.isSearchMatch,
        isSearchFocus = _this$props.isSearchFocus,
        buttons = _this$props.buttons,
        className = _this$props.className,
        style = _this$props.style,
        didDrop = _this$props.didDrop,
        treeId = _this$props.treeId,
        isOver = _this$props.isOver,
        parentNode = _this$props.parentNode,
        rowDirection = _this$props.rowDirection,
        otherProps = _objectWithoutProperties(_this$props, ["scaffoldBlockPxWidth", "toggleChildrenVisibility", "connectDragPreview", "connectDragSource", "isDragging", "canDrop", "canDrag", "node", "title", "subtitle", "draggedNode", "path", "treeIndex", "isSearchMatch", "isSearchFocus", "buttons", "className", "style", "didDrop", "treeId", "isOver", "parentNode", "rowDirection"]);

      const nodeTitle = title || node.title;
      const nodeSubtitle = subtitle || node.subtitle;
      const rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null;
      let handle;

      if (canDrag) {
        if (typeof node.children === 'function' && node.expanded) {
          // Show a loading symbol on the handle when the children are expanded
          //  and yet still defined by a function (a callback to fetch the children)
          handle = react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
            className: "rst__loadingHandle"
          }, react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
            className: "rst__loadingCircle"
          }, _toConsumableArray(new Array(12)).map(function (_, index) {
            return react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
              // eslint-disable-next-line react/no-array-index-key
              key: index,
              className: classnames('rst__loadingCirclePoint', rowDirectionClass)
            });
          })));
        } else {
          // Show the handle used to initiate a drag-and-drop
          handle = connectDragSource(react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
            className: "rst__moveHandle"
          }), {
            dropEffect: 'copy'
          });
        }
      }

      const isDraggedDescendant = draggedNode && isDescendant(draggedNode, node);
      const isLandingPadActive = !didDrop && isDragging;
      let buttonStyle = {
        left: -0.5 * scaffoldBlockPxWidth
      };

      if (rowDirection === 'rtl') {
        buttonStyle = {
          right: -0.5 * scaffoldBlockPxWidth
        };
      }

      return react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", _extends({
        style: {
          height: '100%'
        }
      }, otherProps), toggleChildrenVisibility && node.children && (node.children.length > 0 || typeof node.children === 'function') && react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", null, react__WEBPACK_IMPORTED_MODULE_3___default().createElement("button", {
        type: "button",
        "aria-label": node.expanded ? 'Collapse' : 'Expand',
        className: classnames(node.expanded ? 'rst__collapseButton' : 'rst__expandButton', rowDirectionClass),
        style: buttonStyle,
        onClick: function onClick() {
          return toggleChildrenVisibility({
            node: node,
            path: path,
            treeIndex: treeIndex
          });
        }
      }), node.expanded && !isDragging && react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
        style: {
          width: scaffoldBlockPxWidth
        },
        className: classnames('rst__lineChildren', rowDirectionClass)
      })), react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
        className: classnames('rst__rowWrapper', rowDirectionClass)
      }, connectDragPreview(react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
        className: classnames('rst__row', isLandingPadActive && 'rst__rowLandingPad', isLandingPadActive && !canDrop && 'rst__rowCancelPad', isSearchMatch && 'rst__rowSearchMatch', isSearchFocus && 'rst__rowSearchFocus', rowDirectionClass, className),
        style: _objectSpread2({
          opacity: isDraggedDescendant ? 0.5 : 1
        }, style)
      }, handle, react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
        className: classnames('rst__rowContents', !canDrag && 'rst__rowContentsDragDisabled', rowDirectionClass)
      }, react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
        className: classnames('rst__rowLabel', rowDirectionClass)
      }, react__WEBPACK_IMPORTED_MODULE_3___default().createElement("span", {
        className: classnames('rst__rowTitle', node.subtitle && 'rst__rowTitleWithSubtitle')
      }, typeof nodeTitle === 'function' ? nodeTitle({
        node: node,
        path: path,
        treeIndex: treeIndex
      }) : nodeTitle), nodeSubtitle && react__WEBPACK_IMPORTED_MODULE_3___default().createElement("span", {
        className: "rst__rowSubtitle"
      }, typeof nodeSubtitle === 'function' ? nodeSubtitle({
        node: node,
        path: path,
        treeIndex: treeIndex
      }) : nodeSubtitle)), react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
        className: "rst__rowToolbar"
      }, buttons.map(function (btn, index) {
        return react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
          key: index // eslint-disable-line react/no-array-index-key
          ,
          className: "rst__toolbarButton"
        }, btn);
      })))))));
    }
  }]);

  return NodeRendererDefault;
}(react__WEBPACK_IMPORTED_MODULE_3__.Component);

      NodeRendererDefault.defaultProps = {
        isSearchMatch: false,
        isSearchFocus: false,
        canDrag: false,
        toggleChildrenVisibility: null,
        buttons: [],
        className: '',
        style: {},
        parentNode: null,
        draggedNode: null,
        canDrop: false,
        title: null,
        subtitle: null,
        rowDirection: 'ltr'
      };
      NodeRendererDefault.propTypes = {
        node: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}).isRequired,
        title: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().node)]),
        subtitle: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().node)]),
        path: prop_types__WEBPACK_IMPORTED_MODULE_2___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number)])).isRequired,
        treeIndex: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        treeId: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string).isRequired,
        isSearchMatch: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
        isSearchFocus: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
        canDrag: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
        scaffoldBlockPxWidth: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        toggleChildrenVisibility: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
        buttons: prop_types__WEBPACK_IMPORTED_MODULE_2___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_2___default().node)),
        className: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),
        style: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}),
  // Drag and drop API functions
  // Drag source
        connectDragPreview: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func).isRequired,
        connectDragSource: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func).isRequired,
        parentNode: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}),
  // Needed for dndManager
        isDragging: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool).isRequired,
        didDrop: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool).isRequired,
        draggedNode: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}),
  // Drop target
        isOver: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool).isRequired,
        canDrop: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  // rtl support
        rowDirection: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string)
      };

      const PlaceholderRendererDefault = function PlaceholderRendererDefault(_ref) {
        const isOver = _ref.isOver,
          canDrop = _ref.canDrop;
        return react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
          className: classnames('rst__placeholder', canDrop && 'rst__placeholderLandingPad', canDrop && !isOver && 'rst__placeholderCancelPad')
        });
      };

      PlaceholderRendererDefault.defaultProps = {
        isOver: false,
        canDrop: false
      };
      PlaceholderRendererDefault.propTypes = {
        isOver: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
        canDrop: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool)
      };

      function _createSuper$1(Derived) {
        function isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;

          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }

        return function () {
          let Super = _getPrototypeOf(Derived),
            result;

          if (isNativeReflectConstruct()) {
            const NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      const TreeNode =
/*#__PURE__*/
function (_Component) {
  _inherits(TreeNode, _Component);

  const _super = _createSuper$1(TreeNode);

  function TreeNode() {
    _classCallCheck(this, TreeNode);

    return _super.apply(this, arguments);
  }

  _createClass(TreeNode, [{
    key: "render",
    value: function render() {
      const _this$props = this.props,
        children = _this$props.children,
        listIndex = _this$props.listIndex,
        swapFrom = _this$props.swapFrom,
        swapLength = _this$props.swapLength,
        swapDepth = _this$props.swapDepth,
        scaffoldBlockPxWidth = _this$props.scaffoldBlockPxWidth,
        lowerSiblingCounts = _this$props.lowerSiblingCounts,
        connectDropTarget = _this$props.connectDropTarget,
        isOver = _this$props.isOver,
        draggedNode = _this$props.draggedNode,
        canDrop = _this$props.canDrop,
        treeIndex = _this$props.treeIndex,
        treeId = _this$props.treeId,
        getPrevRow = _this$props.getPrevRow,
        node = _this$props.node,
        path = _this$props.path,
        rowDirection = _this$props.rowDirection,
        otherProps = _objectWithoutProperties(_this$props, ["children", "listIndex", "swapFrom", "swapLength", "swapDepth", "scaffoldBlockPxWidth", "lowerSiblingCounts", "connectDropTarget", "isOver", "draggedNode", "canDrop", "treeIndex", "treeId", "getPrevRow", "node", "path", "rowDirection"]);

      const rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null; // Construct the scaffold representing the structure of the tree

      const scaffoldBlockCount = lowerSiblingCounts.length;
      const scaffold = [];
      lowerSiblingCounts.forEach(function (lowerSiblingCount, i) {
        let lineClass = '';

        if (lowerSiblingCount > 0) {
          // At this level in the tree, the nodes had sibling nodes further down
          if (listIndex === 0) {
            // Top-left corner of the tree
            // +-----+
            // |     |
            // |  +--+
            // |  |  |
            // +--+--+
            lineClass = 'rst__lineHalfHorizontalRight rst__lineHalfVerticalBottom';
          } else if (i === scaffoldBlockCount - 1) {
            // Last scaffold block in the row, right before the row content
            // +--+--+
            // |  |  |
            // |  +--+
            // |  |  |
            // +--+--+
            lineClass = 'rst__lineHalfHorizontalRight rst__lineFullVertical';
          } else {
            // Simply connecting the line extending down to the next sibling on this level
            // +--+--+
            // |  |  |
            // |  |  |
            // |  |  |
            // +--+--+
            lineClass = 'rst__lineFullVertical';
          }
        } else if (listIndex === 0) {
          // Top-left corner of the tree, but has no siblings
          // +-----+
          // |     |
          // |  +--+
          // |     |
          // +-----+
          lineClass = 'rst__lineHalfHorizontalRight';
        } else if (i === scaffoldBlockCount - 1) {
          // The last or only node in this level of the tree
          // +--+--+
          // |  |  |
          // |  +--+
          // |     |
          // +-----+
          lineClass = 'rst__lineHalfVerticalTop rst__lineHalfHorizontalRight';
        }

        scaffold.push(react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
          key: "pre_".concat(1 + i),
          style: {
            width: scaffoldBlockPxWidth
          },
          className: classnames('rst__lineBlock', lineClass, rowDirectionClass)
        }));

        if (treeIndex !== listIndex && i === swapDepth) {
          // This row has been shifted, and is at the depth of
          // the line pointing to the new destination
          let highlightLineClass = '';

          if (listIndex === swapFrom + swapLength - 1) {
            // This block is on the bottom (target) line
            // This block points at the target block (where the row will go when released)
            highlightLineClass = 'rst__highlightBottomLeftCorner';
          } else if (treeIndex === swapFrom) {
            // This block is on the top (source) line
            highlightLineClass = 'rst__highlightTopLeftCorner';
          } else {
            // This block is between the bottom and top
            highlightLineClass = 'rst__highlightLineVertical';
          }

          let _style;

          if (rowDirection === 'rtl') {
            _style = {
              width: scaffoldBlockPxWidth,
              right: scaffoldBlockPxWidth * i
            };
          } else {
            // Default ltr
            _style = {
              width: scaffoldBlockPxWidth,
              left: scaffoldBlockPxWidth * i
            };
          }

          scaffold.push(react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
            // eslint-disable-next-line react/no-array-index-key
            key: i,
            style: _style,
            className: classnames('rst__absoluteLineBlock', highlightLineClass, rowDirectionClass)
          }));
        }
      });
      let style;

      if (rowDirection === 'rtl') {
        style = {
          right: scaffoldBlockPxWidth * scaffoldBlockCount
        };
      } else {
        // Default ltr
        style = {
          left: scaffoldBlockPxWidth * scaffoldBlockCount
        };
      }

      return connectDropTarget(react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", _extends({}, otherProps, {
        className: classnames('rst__node', rowDirectionClass)
      }), scaffold, react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
        className: "rst__nodeContent",
        style: style
      }, react__WEBPACK_IMPORTED_MODULE_3__.Children.map(children, function (child) {
        return (0,react__WEBPACK_IMPORTED_MODULE_3__.cloneElement)(child, {
          isOver: isOver,
          canDrop: canDrop,
          draggedNode: draggedNode
        });
      }))));
    }
  }]);

  return TreeNode;
}(react__WEBPACK_IMPORTED_MODULE_3__.Component);

      TreeNode.defaultProps = {
        swapFrom: null,
        swapDepth: null,
        swapLength: null,
        canDrop: false,
        draggedNode: null,
        rowDirection: 'ltr'
      };
      TreeNode.propTypes = {
        treeIndex: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        treeId: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string).isRequired,
        swapFrom: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),
        swapDepth: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),
        swapLength: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),
        scaffoldBlockPxWidth: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        lowerSiblingCounts: prop_types__WEBPACK_IMPORTED_MODULE_2___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_2___default().number)).isRequired,
        listIndex: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        children: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().node).isRequired,
  // Drop target
        connectDropTarget: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func).isRequired,
        isOver: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool).isRequired,
        canDrop: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
        draggedNode: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}),
  // used in dndManager
        getPrevRow: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func).isRequired,
        node: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}).isRequired,
        path: prop_types__WEBPACK_IMPORTED_MODULE_2___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number)])).isRequired,
  // rtl support
        rowDirection: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string)
      };

      function _createSuper$2(Derived) {
        function isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;

          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }

        return function () {
          let Super = _getPrototypeOf(Derived),
            result;

          if (isNativeReflectConstruct()) {
            const NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      const TreePlaceholder =
/*#__PURE__*/
function (_Component) {
  _inherits(TreePlaceholder, _Component);

  const _super = _createSuper$2(TreePlaceholder);

  function TreePlaceholder() {
    _classCallCheck(this, TreePlaceholder);

    return _super.apply(this, arguments);
  }

  _createClass(TreePlaceholder, [{
    key: "render",
    value: function render() {
      const _this$props = this.props,
        children = _this$props.children,
        connectDropTarget = _this$props.connectDropTarget,
        treeId = _this$props.treeId,
        drop = _this$props.drop,
        otherProps = _objectWithoutProperties(_this$props, ["children", "connectDropTarget", "treeId", "drop"]);

      return connectDropTarget(react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", null, react__WEBPACK_IMPORTED_MODULE_3__.Children.map(children, function (child) {
        return (0,react__WEBPACK_IMPORTED_MODULE_3__.cloneElement)(child, _objectSpread2({}, otherProps));
      })));
    }
  }]);

  return TreePlaceholder;
}(react__WEBPACK_IMPORTED_MODULE_3__.Component);

      TreePlaceholder.defaultProps = {
        canDrop: false,
        draggedNode: null
      };
      TreePlaceholder.propTypes = {
        children: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().node).isRequired,
  // Drop target
        connectDropTarget: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func).isRequired,
        isOver: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool).isRequired,
        canDrop: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
        draggedNode: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}),
        treeId: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string).isRequired,
        drop: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func).isRequired
      };

      function defaultGetNodeKey(_ref) {
        const treeIndex = _ref.treeIndex;
        return treeIndex;
      } // Cheap hack to get the text of a react object

      function getReactElementText(parent) {
        if (typeof parent === 'string') {
          return parent;
        }

        if (parent === null || _typeof(parent) !== 'object' || !parent.props || !parent.props.children || typeof parent.props.children !== 'string' && _typeof(parent.props.children) !== 'object') {
          return '';
        }

        if (typeof parent.props.children === 'string') {
          return parent.props.children;
        }

        return parent.props.children.map(function (child) {
          return getReactElementText(child);
        }).join('');
      } // Search for a query string inside a node property


      function stringSearch(key, searchQuery, node, path, treeIndex) {
        if (typeof node[key] === 'function') {
    // Search within text after calling its function to generate the text
          return String(node[key]({
            node: node,
            path: path,
            treeIndex: treeIndex
          })).indexOf(searchQuery) > -1;
        }

        if (_typeof(node[key]) === 'object') {
    // Search within text inside react elements
          return getReactElementText(node[key]).indexOf(searchQuery) > -1;
        } // Search within string


        return node[key] && String(node[key]).indexOf(searchQuery) > -1;
      }

      function defaultSearchMethod(_ref2) {
        const node = _ref2.node,
          path = _ref2.path,
          treeIndex = _ref2.treeIndex,
          searchQuery = _ref2.searchQuery;
        return stringSearch('title', searchQuery, node, path, treeIndex) || stringSearch('subtitle', searchQuery, node, path, treeIndex);
      }

      const memoize = function memoize(f) {
        let savedArgsArray = [];
        let savedKeysArray = [];
        let savedResult = null;
        return function (args) {
          const keysArray = Object.keys(args).sort();
          const argsArray = keysArray.map(function (key) {
            return args[key];
          }); // If the arguments for the last insert operation are different than this time,
    // recalculate the result

          if (argsArray.length !== savedArgsArray.length || argsArray.some(function (arg, index) {
            return arg !== savedArgsArray[index];
          }) || keysArray.some(function (key, index) {
            return key !== savedKeysArray[index];
          })) {
            savedArgsArray = argsArray;
            savedKeysArray = keysArray;
            savedResult = f(args);
          }

          return savedResult;
        };
      };

      const memoizedInsertNode = memoize(insertNode);
      const memoizedGetFlatDataFromTree = memoize(getFlatDataFromTree);
      const memoizedGetDescendantCount = memoize(getDescendantCount);

      const DndManager =
/*#__PURE__*/
function () {
  function DndManager(treeRef) {
    _classCallCheck(this, DndManager);

    this.treeRef = treeRef;
  }

  _createClass(DndManager, [{
    key: "getTargetDepth",
    value: function getTargetDepth(dropTargetProps, monitor, component) {
      let dropTargetDepth = 0;
      const rowAbove = dropTargetProps.getPrevRow();

      if (rowAbove) {
        let path = rowAbove.path;
        const aboveNodeCannotHaveChildren = !this.treeRef.canNodeHaveChildren(rowAbove.node);

        if (aboveNodeCannotHaveChildren) {
          path = path.slice(0, path.length - 1);
        } // Limit the length of the path to the deepest possible


        dropTargetDepth = Math.min(path.length, dropTargetProps.path.length);
      }

      let blocksOffset;
      let dragSourceInitialDepth = (monitor.getItem().path || []).length; // When adding node from external source

      if (monitor.getItem().treeId !== this.treeId) {
        // Ignore the tree depth of the source, if it had any to begin with
        dragSourceInitialDepth = 0;

        if (component) {
          const relativePosition = (0,react_dom__WEBPACK_IMPORTED_MODULE_7__.findDOMNode)(component).getBoundingClientRect(); // eslint-disable-line react/no-find-dom-node

          const leftShift = monitor.getSourceClientOffset().x - relativePosition.left;
          blocksOffset = Math.round(leftShift / dropTargetProps.scaffoldBlockPxWidth);
        } else {
          blocksOffset = dropTargetProps.path.length;
        }
      } else {
        // handle row direction support
        const direction = dropTargetProps.rowDirection === 'rtl' ? -1 : 1;
        blocksOffset = Math.round(direction * monitor.getDifferenceFromInitialOffset().x / dropTargetProps.scaffoldBlockPxWidth);
      }

      let targetDepth = Math.min(dropTargetDepth, Math.max(0, dragSourceInitialDepth + blocksOffset - 1)); // If a maxDepth is defined, constrain the target depth

      if (typeof this.maxDepth !== 'undefined' && this.maxDepth !== null) {
        const draggedNode = monitor.getItem().node;
        const draggedChildDepth = getDepth(draggedNode);
        targetDepth = Math.max(0, Math.min(targetDepth, this.maxDepth - draggedChildDepth - 1));
      }

      return targetDepth;
    }
  }, {
    key: "canDrop",
    value: function canDrop(dropTargetProps, monitor) {
      if (!monitor.isOver()) {
        return false;
      }

      const rowAbove = dropTargetProps.getPrevRow();
      const abovePath = rowAbove ? rowAbove.path : [];
      const aboveNode = rowAbove ? rowAbove.node : {};
      const targetDepth = this.getTargetDepth(dropTargetProps, monitor, null); // Cannot drop if we're adding to the children of the row above and
      //  the row above is a function

      if (targetDepth >= abovePath.length && typeof aboveNode.children === 'function') {
        return false;
      }

      if (typeof this.customCanDrop === 'function') {
        const _monitor$getItem = monitor.getItem(),
          node = _monitor$getItem.node;

        const addedResult = memoizedInsertNode({
          treeData: this.treeData,
          newNode: node,
          depth: targetDepth,
          getNodeKey: this.getNodeKey,
          minimumTreeIndex: dropTargetProps.listIndex,
          expandParent: true
        });
        return this.customCanDrop({
          node: node,
          prevPath: monitor.getItem().path,
          prevParent: monitor.getItem().parentNode,
          prevTreeIndex: monitor.getItem().treeIndex,
          // Equals -1 when dragged from external tree
          nextPath: addedResult.path,
          nextParent: addedResult.parentNode,
          nextTreeIndex: addedResult.treeIndex
        });
      }

      return true;
    }
  }, {
    key: "wrapSource",
    value: function wrapSource(el) {
      const _this = this;

      const nodeDragSource = {
        beginDrag: function beginDrag(props) {
          _this.startDrag(props);

          return {
            node: props.node,
            parentNode: props.parentNode,
            path: props.path,
            treeIndex: props.treeIndex,
            treeId: props.treeId
          };
        },
        endDrag: function endDrag(props, monitor) {
          _this.endDrag(monitor.getDropResult());
        },
        isDragging: function isDragging(props, monitor) {
          const dropTargetNode = monitor.getItem().node;
          const draggedNode = props.node;
          return draggedNode === dropTargetNode;
        }
      };

      function nodeDragSourcePropInjection(connect, monitor) {
        return {
          connectDragSource: connect.dragSource(),
          connectDragPreview: connect.dragPreview(),
          isDragging: monitor.isDragging(),
          didDrop: monitor.didDrop()
        };
      }

      return (0,react_dnd__WEBPACK_IMPORTED_MODULE_4__.DragSource)(this.dndType, nodeDragSource, nodeDragSourcePropInjection)(el);
    }
  }, {
    key: "wrapTarget",
    value: function wrapTarget(el) {
      const _this2 = this;

      const nodeDropTarget = {
        drop: function drop(dropTargetProps, monitor, component) {
          const result = {
            node: monitor.getItem().node,
            path: monitor.getItem().path,
            treeIndex: monitor.getItem().treeIndex,
            treeId: _this2.treeId,
            minimumTreeIndex: dropTargetProps.treeIndex,
            depth: _this2.getTargetDepth(dropTargetProps, monitor, component)
          };

          _this2.drop(result);

          return result;
        },
        hover: function hover(dropTargetProps, monitor, component) {
          const targetDepth = _this2.getTargetDepth(dropTargetProps, monitor, component);

          const draggedNode = monitor.getItem().node;
          const needsRedraw = // Redraw if hovered above different nodes
          dropTargetProps.node !== draggedNode || // Or hovered above the same node but at a different depth
          targetDepth !== dropTargetProps.path.length - 1;

          if (!needsRedraw) {
            return;
          } // throttle `dragHover` work to available animation frames


          cancelAnimationFrame(_this2.rafId);
          _this2.rafId = requestAnimationFrame(function () {
            _this2.dragHover({
              node: draggedNode,
              path: monitor.getItem().path,
              minimumTreeIndex: dropTargetProps.listIndex,
              depth: targetDepth
            });
          });
        },
        canDrop: this.canDrop.bind(this)
      };

      function nodeDropTargetPropInjection(connect, monitor) {
        const dragged = monitor.getItem();
        return {
          connectDropTarget: connect.dropTarget(),
          isOver: monitor.isOver(),
          canDrop: monitor.canDrop(),
          draggedNode: dragged ? dragged.node : null
        };
      }

      return (0,react_dnd__WEBPACK_IMPORTED_MODULE_4__.DropTarget)(this.dndType, nodeDropTarget, nodeDropTargetPropInjection)(el);
    }
  }, {
    key: "wrapPlaceholder",
    value: function wrapPlaceholder(el) {
      const _this3 = this;

      const placeholderDropTarget = {
        drop: function drop(dropTargetProps, monitor) {
          const _monitor$getItem2 = monitor.getItem(),
            node = _monitor$getItem2.node,
            path = _monitor$getItem2.path,
            treeIndex = _monitor$getItem2.treeIndex;

          const result = {
            node: node,
            path: path,
            treeIndex: treeIndex,
            treeId: _this3.treeId,
            minimumTreeIndex: 0,
            depth: 0
          };

          _this3.drop(result);

          return result;
        }
      };

      function placeholderPropInjection(connect, monitor) {
        const dragged = monitor.getItem();
        return {
          connectDropTarget: connect.dropTarget(),
          isOver: monitor.isOver(),
          canDrop: monitor.canDrop(),
          draggedNode: dragged ? dragged.node : null
        };
      }

      return (0,react_dnd__WEBPACK_IMPORTED_MODULE_4__.DropTarget)(this.dndType, placeholderDropTarget, placeholderPropInjection)(el);
    }
  }, {
    key: "startDrag",
    get: function get() {
      return this.treeRef.startDrag;
    }
  }, {
    key: "dragHover",
    get: function get() {
      return this.treeRef.dragHover;
    }
  }, {
    key: "endDrag",
    get: function get() {
      return this.treeRef.endDrag;
    }
  }, {
    key: "drop",
    get: function get() {
      return this.treeRef.drop;
    }
  }, {
    key: "treeId",
    get: function get() {
      return this.treeRef.treeId;
    }
  }, {
    key: "dndType",
    get: function get() {
      return this.treeRef.dndType;
    }
  }, {
    key: "treeData",
    get: function get() {
      return this.treeRef.state.draggingTreeData || this.treeRef.props.treeData;
    }
  }, {
    key: "getNodeKey",
    get: function get() {
      return this.treeRef.props.getNodeKey;
    }
  }, {
    key: "customCanDrop",
    get: function get() {
      return this.treeRef.props.canDrop;
    }
  }, {
    key: "maxDepth",
    get: function get() {
      return this.treeRef.props.maxDepth;
    }
  }]);

  return DndManager;
}();

/* eslint-disable import/prefer-default-export */
      function slideRows(rows, fromIndex, toIndex) {
        const count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        const rowsWithoutMoved = [].concat(_toConsumableArray(rows.slice(0, fromIndex)), _toConsumableArray(rows.slice(fromIndex + count)));
        return [].concat(_toConsumableArray(rowsWithoutMoved.slice(0, toIndex)), _toConsumableArray(rows.slice(fromIndex, fromIndex + count)), _toConsumableArray(rowsWithoutMoved.slice(toIndex)));
      }

      function _createSuper$3(Derived) {
        function isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;

          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }

        return function () {
          let Super = _getPrototypeOf(Derived),
            result;

          if (isNativeReflectConstruct()) {
            const NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }
      let treeIdCounter = 1;

      const mergeTheme = function mergeTheme(props) {
        const merged = _objectSpread2(_objectSpread2({}, props), {}, {
          style: _objectSpread2(_objectSpread2({}, props.theme.style), props.style),
          innerStyle: _objectSpread2(_objectSpread2({}, props.theme.innerStyle), props.innerStyle),
          reactVirtualizedListProps: _objectSpread2(_objectSpread2({}, props.theme.reactVirtualizedListProps), props.reactVirtualizedListProps)
        });

        const overridableDefaults = {
          nodeContentRenderer: NodeRendererDefault,
          placeholderRenderer: PlaceholderRendererDefault,
          rowHeight: 62,
          scaffoldBlockPxWidth: 44,
          slideRegionSize: 100,
          treeNodeRenderer: TreeNode
        };
        Object.keys(overridableDefaults).forEach(function (propKey) {
    // If prop has been specified, do not change it
    // If prop is specified in theme, use the theme setting
    // If all else fails, fall back to the default
          if (props[propKey] === null) {
            merged[propKey] = typeof props.theme[propKey] !== 'undefined' ? props.theme[propKey] : overridableDefaults[propKey];
          }
        });
        return merged;
      };

      const ReactSortableTree =
/*#__PURE__*/
function (_Component) {
  _inherits(ReactSortableTree, _Component);

  const _super = _createSuper$3(ReactSortableTree);

  function ReactSortableTree(props) {
    let _this;

    _classCallCheck(this, ReactSortableTree);

    _this = _super.call(this, props);

    const _mergeTheme = mergeTheme(props),
      dndType = _mergeTheme.dndType,
      nodeContentRenderer = _mergeTheme.nodeContentRenderer,
      treeNodeRenderer = _mergeTheme.treeNodeRenderer,
      isVirtualized = _mergeTheme.isVirtualized,
      slideRegionSize = _mergeTheme.slideRegionSize;

    _this.dndManager = new DndManager(_assertThisInitialized(_this)); // Wrapping classes for use with react-dnd

    _this.treeId = "rst__".concat(treeIdCounter);
    treeIdCounter += 1;
    _this.dndType = dndType || _this.treeId;
    _this.nodeContentRenderer = _this.dndManager.wrapSource(nodeContentRenderer);
    _this.treePlaceholderRenderer = _this.dndManager.wrapPlaceholder(TreePlaceholder);
    _this.treeNodeRenderer = _this.dndManager.wrapTarget(treeNodeRenderer); // Prepare scroll-on-drag options for this list

    if (isVirtualized) {
      _this.scrollZoneVirtualList = (frontend_collective_react_dnd_scrollzone__WEBPACK_IMPORTED_MODULE_0__.createScrollingComponent || frontend_collective_react_dnd_scrollzone__WEBPACK_IMPORTED_MODULE_0__["default"])(react_virtualized__WEBPACK_IMPORTED_MODULE_6__.List);
      _this.vStrength = (0,frontend_collective_react_dnd_scrollzone__WEBPACK_IMPORTED_MODULE_0__.createVerticalStrength)(slideRegionSize);
      _this.hStrength = (0,frontend_collective_react_dnd_scrollzone__WEBPACK_IMPORTED_MODULE_0__.createHorizontalStrength)(slideRegionSize);
    }

    _this.state = {
      draggingTreeData: null,
      draggedNode: null,
      draggedMinimumTreeIndex: null,
      draggedDepth: null,
      searchMatches: [],
      searchFocusTreeIndex: null,
      dragging: false,
      // props that need to be used in gDSFP or static functions will be stored here
      instanceProps: {
        treeData: [],
        ignoreOneTreeUpdate: false,
        searchQuery: null,
        searchFocusOffset: null
      }
    };
    _this.toggleChildrenVisibility = _this.toggleChildrenVisibility.bind(_assertThisInitialized(_this));
    _this.moveNode = _this.moveNode.bind(_assertThisInitialized(_this));
    _this.startDrag = _this.startDrag.bind(_assertThisInitialized(_this));
    _this.dragHover = _this.dragHover.bind(_assertThisInitialized(_this));
    _this.endDrag = _this.endDrag.bind(_assertThisInitialized(_this));
    _this.drop = _this.drop.bind(_assertThisInitialized(_this));
    _this.handleDndMonitorChange = _this.handleDndMonitorChange.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(ReactSortableTree, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      ReactSortableTree.loadLazyChildren(this.props, this.state);
      const stateUpdate = ReactSortableTree.search(this.props, this.state, true, true, false);
      this.setState(stateUpdate); // Hook into react-dnd state changes to detect when the drag ends
      // TODO: This is very brittle, so it needs to be replaced if react-dnd
      // offers a more official way to detect when a drag ends

      this.clearMonitorSubscription = this.props.dragDropManager.getMonitor().subscribeToStateChange(this.handleDndMonitorChange);
    }
  }, {
    key: "componentDidUpdate",
    // listen to dragging
    value: function componentDidUpdate(prevProps, prevState) {
      // if it is not the same then call the onDragStateChanged
      if (this.state.dragging !== prevState.dragging) {
        if (this.props.onDragStateChanged) {
          this.props.onDragStateChanged({
            isDragging: this.state.dragging,
            draggedNode: this.state.draggedNode
          });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clearMonitorSubscription();
    }
  }, {
    key: "getRows",
    value: function getRows(treeData) {
      return memoizedGetFlatDataFromTree({
        ignoreCollapsed: true,
        getNodeKey: this.props.getNodeKey,
        treeData: treeData
      });
    }
  }, {
    key: "handleDndMonitorChange",
    value: function handleDndMonitorChange() {
      const monitor = this.props.dragDropManager.getMonitor(); // If the drag ends and the tree is still in a mid-drag state,
      // it means that the drag was canceled or the dragSource dropped
      // elsewhere, and we should reset the state of this tree

      if (!monitor.isDragging() && this.state.draggingTreeData) {
        this.endDrag();
      }
    }
  }, {
    key: "toggleChildrenVisibility",
    value: function toggleChildrenVisibility(_ref) {
      const targetNode = _ref.node,
        path = _ref.path;
      const instanceProps = this.state.instanceProps;
      const treeData = changeNodeAtPath({
        treeData: instanceProps.treeData,
        path: path,
        newNode: function newNode(_ref2) {
          const node = _ref2.node;
          return _objectSpread2(_objectSpread2({}, node), {}, {
            expanded: !node.expanded
          });
        },
        getNodeKey: this.props.getNodeKey
      });
      this.props.onChange(treeData);
      this.props.onVisibilityToggle({
        treeData: treeData,
        node: targetNode,
        expanded: !targetNode.expanded,
        path: path
      });
    }
  }, {
    key: "moveNode",
    value: function moveNode(_ref3) {
      const node = _ref3.node,
        prevPath = _ref3.path,
        prevTreeIndex = _ref3.treeIndex,
        depth = _ref3.depth,
        minimumTreeIndex = _ref3.minimumTreeIndex;

      const _insertNode = insertNode({
          treeData: this.state.draggingTreeData,
          newNode: node,
          depth: depth,
          minimumTreeIndex: minimumTreeIndex,
          expandParent: true,
          getNodeKey: this.props.getNodeKey
        }),
        treeData = _insertNode.treeData,
        treeIndex = _insertNode.treeIndex,
        path = _insertNode.path,
        nextParentNode = _insertNode.parentNode;

      this.props.onChange(treeData);
      this.props.onMoveNode({
        treeData: treeData,
        node: node,
        treeIndex: treeIndex,
        path: path,
        nextPath: path,
        nextTreeIndex: treeIndex,
        prevPath: prevPath,
        prevTreeIndex: prevTreeIndex,
        nextParentNode: nextParentNode
      });
    } // returns the new state after search

  }, {
    key: "startDrag",
    value: function startDrag(_ref4) {
      const _this2 = this;

      const path = _ref4.path;
      this.setState(function (prevState) {
        const _removeNode = removeNode({
            treeData: prevState.instanceProps.treeData,
            path: path,
            getNodeKey: _this2.props.getNodeKey
          }),
          draggingTreeData = _removeNode.treeData,
          draggedNode = _removeNode.node,
          draggedMinimumTreeIndex = _removeNode.treeIndex;

        return {
          draggingTreeData: draggingTreeData,
          draggedNode: draggedNode,
          draggedDepth: path.length - 1,
          draggedMinimumTreeIndex: draggedMinimumTreeIndex,
          dragging: true
        };
      });
    }
  }, {
    key: "dragHover",
    value: function dragHover(_ref5) {
      const _this3 = this;

      const draggedNode = _ref5.node,
        draggedDepth = _ref5.depth,
        draggedMinimumTreeIndex = _ref5.minimumTreeIndex;

      // Ignore this hover if it is at the same position as the last hover
      if (this.state.draggedDepth === draggedDepth && this.state.draggedMinimumTreeIndex === draggedMinimumTreeIndex) {
        return;
      }

      this.setState(function (_ref6) {
        const draggingTreeData = _ref6.draggingTreeData,
          instanceProps = _ref6.instanceProps;
        // Fall back to the tree data if something is being dragged in from
        //  an external element
        const newDraggingTreeData = draggingTreeData || instanceProps.treeData;
        const addedResult = memoizedInsertNode({
          treeData: newDraggingTreeData,
          newNode: draggedNode,
          depth: draggedDepth,
          minimumTreeIndex: draggedMinimumTreeIndex,
          expandParent: true,
          getNodeKey: _this3.props.getNodeKey
        });

        const rows = _this3.getRows(addedResult.treeData);

        const expandedParentPath = rows[addedResult.treeIndex].path;
        return {
          draggedNode: draggedNode,
          draggedDepth: draggedDepth,
          draggedMinimumTreeIndex: draggedMinimumTreeIndex,
          draggingTreeData: changeNodeAtPath({
            treeData: newDraggingTreeData,
            path: expandedParentPath.slice(0, -1),
            newNode: function newNode(_ref7) {
              const node = _ref7.node;
              return _objectSpread2(_objectSpread2({}, node), {}, {
                expanded: true
              });
            },
            getNodeKey: _this3.props.getNodeKey
          }),
          // reset the scroll focus so it doesn't jump back
          // to a search result while dragging
          searchFocusTreeIndex: null,
          dragging: true
        };
      });
    }
  }, {
    key: "endDrag",
    value: function endDrag(dropResult) {
      const _this4 = this;

      const instanceProps = this.state.instanceProps;

      const resetTree = function resetTree() {
        return _this4.setState({
          draggingTreeData: null,
          draggedNode: null,
          draggedMinimumTreeIndex: null,
          draggedDepth: null,
          dragging: false
        });
      }; // Drop was cancelled


      if (!dropResult) {
        resetTree();
      } else if (dropResult.treeId !== this.treeId) {
        // The node was dropped in an external drop target or tree
        const node = dropResult.node,
          path = dropResult.path,
          treeIndex = dropResult.treeIndex;
        let shouldCopy = this.props.shouldCopyOnOutsideDrop;

        if (typeof shouldCopy === 'function') {
          shouldCopy = shouldCopy({
            node: node,
            prevTreeIndex: treeIndex,
            prevPath: path
          });
        }

        let treeData = this.state.draggingTreeData || instanceProps.treeData; // If copying is enabled, a drop outside leaves behind a copy in the
        //  source tree

        if (shouldCopy) {
          treeData = changeNodeAtPath({
            treeData: instanceProps.treeData,
            // use treeData unaltered by the drag operation
            path: path,
            newNode: function newNode(_ref8) {
              const copyNode = _ref8.node;
              return _objectSpread2({}, copyNode);
            },
            // create a shallow copy of the node
            getNodeKey: this.props.getNodeKey
          });
        }

        this.props.onChange(treeData);
        this.props.onMoveNode({
          treeData: treeData,
          node: node,
          treeIndex: null,
          path: null,
          nextPath: null,
          nextTreeIndex: null,
          prevPath: path,
          prevTreeIndex: treeIndex
        });
      }
    }
  }, {
    key: "drop",
    value: function drop(dropResult) {
      this.moveNode(dropResult);
    }
  }, {
    key: "canNodeHaveChildren",
    value: function canNodeHaveChildren(node) {
      const canNodeHaveChildren = this.props.canNodeHaveChildren;

      if (canNodeHaveChildren) {
        return canNodeHaveChildren(node);
      }

      return true;
    } // Load any children in the tree that are given by a function
    // calls the onChange callback on the new treeData

  }, {
    key: "renderRow",
    value: function renderRow(row, _ref9) {
      const listIndex = _ref9.listIndex,
        style = _ref9.style,
        getPrevRow = _ref9.getPrevRow,
        matchKeys = _ref9.matchKeys,
        swapFrom = _ref9.swapFrom,
        swapDepth = _ref9.swapDepth,
        swapLength = _ref9.swapLength;
      const node = row.node,
        parentNode = row.parentNode,
        path = row.path,
        lowerSiblingCounts = row.lowerSiblingCounts,
        treeIndex = row.treeIndex;

      const _mergeTheme2 = mergeTheme(this.props),
        canDrag = _mergeTheme2.canDrag,
        generateNodeProps = _mergeTheme2.generateNodeProps,
        scaffoldBlockPxWidth = _mergeTheme2.scaffoldBlockPxWidth,
        searchFocusOffset = _mergeTheme2.searchFocusOffset,
        rowDirection = _mergeTheme2.rowDirection;

      const TreeNodeRenderer = this.treeNodeRenderer;
      const NodeContentRenderer = this.nodeContentRenderer;
      const nodeKey = path[path.length - 1];
      const isSearchMatch = nodeKey in matchKeys;
      const isSearchFocus = isSearchMatch && matchKeys[nodeKey] === searchFocusOffset;
      const callbackParams = {
        node: node,
        parentNode: parentNode,
        path: path,
        lowerSiblingCounts: lowerSiblingCounts,
        treeIndex: treeIndex,
        isSearchMatch: isSearchMatch,
        isSearchFocus: isSearchFocus
      };
      const nodeProps = !generateNodeProps ? {} : generateNodeProps(callbackParams);
      const rowCanDrag = typeof canDrag !== 'function' ? canDrag : canDrag(callbackParams);
      const sharedProps = {
        treeIndex: treeIndex,
        scaffoldBlockPxWidth: scaffoldBlockPxWidth,
        node: node,
        path: path,
        treeId: this.treeId,
        rowDirection: rowDirection
      };
      return react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TreeNodeRenderer, _extends({
        style: style,
        key: nodeKey,
        listIndex: listIndex,
        getPrevRow: getPrevRow,
        lowerSiblingCounts: lowerSiblingCounts,
        swapFrom: swapFrom,
        swapLength: swapLength,
        swapDepth: swapDepth
      }, sharedProps), react__WEBPACK_IMPORTED_MODULE_3___default().createElement(NodeContentRenderer, _extends({
        parentNode: parentNode,
        isSearchMatch: isSearchMatch,
        isSearchFocus: isSearchFocus,
        canDrag: rowCanDrag,
        toggleChildrenVisibility: this.toggleChildrenVisibility
      }, sharedProps, nodeProps)));
    }
  }, {
    key: "render",
    value: function render() {
      const _this5 = this;

      const _mergeTheme3 = mergeTheme(this.props),
        dragDropManager = _mergeTheme3.dragDropManager,
        style = _mergeTheme3.style,
        className = _mergeTheme3.className,
        innerStyle = _mergeTheme3.innerStyle,
        rowHeight = _mergeTheme3.rowHeight,
        isVirtualized = _mergeTheme3.isVirtualized,
        placeholderRenderer = _mergeTheme3.placeholderRenderer,
        reactVirtualizedListProps = _mergeTheme3.reactVirtualizedListProps,
        getNodeKey = _mergeTheme3.getNodeKey,
        rowDirection = _mergeTheme3.rowDirection;

      const _this$state = this.state,
        searchMatches = _this$state.searchMatches,
        searchFocusTreeIndex = _this$state.searchFocusTreeIndex,
        draggedNode = _this$state.draggedNode,
        draggedDepth = _this$state.draggedDepth,
        draggedMinimumTreeIndex = _this$state.draggedMinimumTreeIndex,
        instanceProps = _this$state.instanceProps;
      const treeData = this.state.draggingTreeData || instanceProps.treeData;
      const rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null;
      let rows;
      let swapFrom = null;
      let swapLength = null;

      if (draggedNode && draggedMinimumTreeIndex !== null) {
        const addedResult = memoizedInsertNode({
          treeData: treeData,
          newNode: draggedNode,
          depth: draggedDepth,
          minimumTreeIndex: draggedMinimumTreeIndex,
          expandParent: true,
          getNodeKey: getNodeKey
        });
        const swapTo = draggedMinimumTreeIndex;
        swapFrom = addedResult.treeIndex;
        swapLength = 1 + memoizedGetDescendantCount({
          node: draggedNode
        });
        rows = slideRows(this.getRows(addedResult.treeData), swapFrom, swapTo, swapLength);
      } else {
        rows = this.getRows(treeData);
      } // Get indices for rows that match the search conditions


      const matchKeys = {};
      searchMatches.forEach(function (_ref10, i) {
        const path = _ref10.path;
        matchKeys[path[path.length - 1]] = i;
      }); // Seek to the focused search result if there is one specified

      const scrollToInfo = searchFocusTreeIndex !== null ? {
        scrollToIndex: searchFocusTreeIndex
      } : {};
      let containerStyle = style;
      let list;

      if (rows.length < 1) {
        const Placeholder = this.treePlaceholderRenderer;
        const PlaceholderContent = placeholderRenderer;
        list = react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Placeholder, {
          treeId: this.treeId,
          drop: this.drop
        }, react__WEBPACK_IMPORTED_MODULE_3___default().createElement(PlaceholderContent, null));
      } else if (isVirtualized) {
        containerStyle = _objectSpread2({
          height: '100%'
        }, containerStyle);
        const ScrollZoneVirtualList = this.scrollZoneVirtualList; // Render list with react-virtualized

        list = react__WEBPACK_IMPORTED_MODULE_3___default().createElement(react_virtualized__WEBPACK_IMPORTED_MODULE_6__.AutoSizer, null, function (_ref11) {
          const height = _ref11.height,
            width = _ref11.width;
          return react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ScrollZoneVirtualList, _extends({}, scrollToInfo, {
            dragDropManager: dragDropManager,
            verticalStrength: _this5.vStrength,
            horizontalStrength: _this5.hStrength,
            speed: 30,
            scrollToAlignment: "start",
            className: "rst__virtualScrollOverride",
            width: width,
            onScroll: function onScroll(_ref12) {
              const scrollTop = _ref12.scrollTop;
              _this5.scrollTop = scrollTop;
            },
            height: height,
            style: innerStyle,
            rowCount: rows.length,
            estimatedRowSize: typeof rowHeight !== 'function' ? rowHeight : undefined,
            rowHeight: typeof rowHeight !== 'function' ? rowHeight : function (_ref13) {
              const index = _ref13.index;
              return rowHeight({
                index: index,
                treeIndex: index,
                node: rows[index].node,
                path: rows[index].path
              });
            },
            rowRenderer: function rowRenderer(_ref14) {
              const index = _ref14.index,
                rowStyle = _ref14.style;
              return _this5.renderRow(rows[index], {
                listIndex: index,
                style: rowStyle,
                getPrevRow: function getPrevRow() {
                  return rows[index - 1] || null;
                },
                matchKeys: matchKeys,
                swapFrom: swapFrom,
                swapDepth: draggedDepth,
                swapLength: swapLength
              });
            }
          }, reactVirtualizedListProps));
        });
      } else {
        // Render list without react-virtualized
        list = rows.map(function (row, index) {
          return _this5.renderRow(row, {
            listIndex: index,
            style: {
              height: typeof rowHeight !== 'function' ? rowHeight : rowHeight({
                index: index,
                treeIndex: index,
                node: row.node,
                path: row.path
              })
            },
            getPrevRow: function getPrevRow() {
              return rows[index - 1] || null;
            },
            matchKeys: matchKeys,
            swapFrom: swapFrom,
            swapDepth: draggedDepth,
            swapLength: swapLength
          });
        });
      }

      return react__WEBPACK_IMPORTED_MODULE_3___default().createElement("div", {
        className: classnames('rst__tree', className, rowDirectionClass),
        style: containerStyle
      }, list);
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      const instanceProps = prevState.instanceProps;
      const newState = {};
      const isTreeDataEqual = lodash_isequal__WEBPACK_IMPORTED_MODULE_1___default()(instanceProps.treeData, nextProps.treeData); // make sure we have the most recent version of treeData

      instanceProps.treeData = nextProps.treeData;

      if (!isTreeDataEqual) {
        if (instanceProps.ignoreOneTreeUpdate) {
          instanceProps.ignoreOneTreeUpdate = false;
        } else {
          newState.searchFocusTreeIndex = null;
          ReactSortableTree.loadLazyChildren(nextProps, prevState);
          Object.assign(newState, ReactSortableTree.search(nextProps, prevState, false, false, false));
        }

        newState.draggingTreeData = null;
        newState.draggedNode = null;
        newState.draggedMinimumTreeIndex = null;
        newState.draggedDepth = null;
        newState.dragging = false;
      } else if (!lodash_isequal__WEBPACK_IMPORTED_MODULE_1___default()(instanceProps.searchQuery, nextProps.searchQuery)) {
        Object.assign(newState, ReactSortableTree.search(nextProps, prevState, true, true, false));
      } else if (instanceProps.searchFocusOffset !== nextProps.searchFocusOffset) {
        Object.assign(newState, ReactSortableTree.search(nextProps, prevState, true, true, true));
      }

      instanceProps.searchQuery = nextProps.searchQuery;
      instanceProps.searchFocusOffset = nextProps.searchFocusOffset;
      newState.instanceProps = _objectSpread2(_objectSpread2({}, instanceProps), newState.instanceProps);
      return newState;
    }
  }, {
    key: "search",
    value: function search(props, state, seekIndex, expand, singleSearch) {
      const onChange = props.onChange,
        getNodeKey = props.getNodeKey,
        searchFinishCallback = props.searchFinishCallback,
        searchQuery = props.searchQuery,
        searchMethod = props.searchMethod,
        searchFocusOffset = props.searchFocusOffset,
        onlyExpandSearchedNodes = props.onlyExpandSearchedNodes;
      const instanceProps = state.instanceProps; // Skip search if no conditions are specified

      if (!searchQuery && !searchMethod) {
        if (searchFinishCallback) {
          searchFinishCallback([]);
        }

        return {
          searchMatches: []
        };
      }

      const newState = {
        instanceProps: {}
      }; // if onlyExpandSearchedNodes collapse the tree and search

      const _find = find({
          getNodeKey: getNodeKey,
          treeData: onlyExpandSearchedNodes ? toggleExpandedForAll({
            treeData: instanceProps.treeData,
            expanded: false
          }) : instanceProps.treeData,
          searchQuery: searchQuery,
          searchMethod: searchMethod || defaultSearchMethod,
          searchFocusOffset: searchFocusOffset,
          expandAllMatchPaths: expand && !singleSearch,
          expandFocusMatchPaths: !!expand
        }),
        expandedTreeData = _find.treeData,
        searchMatches = _find.matches; // Update the tree with data leaving all paths leading to matching nodes open


      if (expand) {
        newState.instanceProps.ignoreOneTreeUpdate = true; // Prevents infinite loop

        onChange(expandedTreeData);
      }

      if (searchFinishCallback) {
        searchFinishCallback(searchMatches);
      }

      let searchFocusTreeIndex = null;

      if (seekIndex && searchFocusOffset !== null && searchFocusOffset < searchMatches.length) {
        searchFocusTreeIndex = searchMatches[searchFocusOffset].treeIndex;
      }

      newState.searchMatches = searchMatches;
      newState.searchFocusTreeIndex = searchFocusTreeIndex;
      return newState;
    }
  }, {
    key: "loadLazyChildren",
    value: function loadLazyChildren(props, state) {
      const instanceProps = state.instanceProps;
      walk({
        treeData: instanceProps.treeData,
        getNodeKey: props.getNodeKey,
        callback: function callback(_ref15) {
          const node = _ref15.node,
            path = _ref15.path,
            lowerSiblingCounts = _ref15.lowerSiblingCounts,
            treeIndex = _ref15.treeIndex;

          // If the node has children defined by a function, and is either expanded
          //  or set to load even before expansion, run the function.
          if (node.children && typeof node.children === 'function' && (node.expanded || props.loadCollapsedLazyChildren)) {
            // Call the children fetching function
            node.children({
              node: node,
              path: path,
              lowerSiblingCounts: lowerSiblingCounts,
              treeIndex: treeIndex,
              // Provide a helper to append the new data when it is received
              done: function done(childrenArray) {
                return props.onChange(changeNodeAtPath({
                  treeData: instanceProps.treeData,
                  path: path,
                  newNode: function newNode(_ref16) {
                    const oldNode = _ref16.node;
                    return (// Only replace the old node if it's the one we set off to find children
                      //  for in the first place
                      oldNode === node ? _objectSpread2(_objectSpread2({}, oldNode), {}, {
                        children: childrenArray
                      }) : oldNode
                    );
                  },
                  getNodeKey: props.getNodeKey
                }));
              }
            });
          }
        }
      });
    }
  }]);

  return ReactSortableTree;
}(react__WEBPACK_IMPORTED_MODULE_3__.Component);

      ReactSortableTree.propTypes = {
        dragDropManager: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({
          getMonitor: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func)
        }).isRequired,
  // Tree data in the following format:
  // [{title: 'main', subtitle: 'sub'}, { title: 'value2', expanded: true, children: [{ title: 'value3') }] }]
  // `title` is the primary label for the node
  // `subtitle` is a secondary label for the node
  // `expanded` shows children of the node if true, or hides them if false. Defaults to false.
  // `children` is an array of child nodes belonging to the node.
        treeData: prop_types__WEBPACK_IMPORTED_MODULE_2___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_2___default().object)).isRequired,
  // Style applied to the container wrapping the tree (style defaults to {height: '100%'})
        style: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}),
  // Class name for the container wrapping the tree
        className: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),
  // Style applied to the inner, scrollable container (for padding, etc.)
        innerStyle: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}),
  // Used by react-virtualized
  // Either a fixed row height (number) or a function that returns the
  // height of a row given its index: `({ index: number }): number`
        rowHeight: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func)]),
  // Size in px of the region near the edges that initiates scrolling on dragover
        slideRegionSize: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),
  // Custom properties to hand to the react-virtualized list
  // https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md#prop-types
        reactVirtualizedListProps: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}),
  // The width of the blocks containing the lines representing the structure of the tree.
        scaffoldBlockPxWidth: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),
  // Maximum depth nodes can be inserted at. Defaults to infinite.
        maxDepth: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),
  // The method used to search nodes.
  // Defaults to a function that uses the `searchQuery` string to search for nodes with
  // matching `title` or `subtitle` values.
  // NOTE: Changing `searchMethod` will not update the search, but changing the `searchQuery` will.
        searchMethod: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
  // Used by the `searchMethod` to highlight and scroll to matched nodes.
  // Should be a string for the default `searchMethod`, but can be anything when using a custom search.
        searchQuery: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().any),
  // eslint-disable-line react/forbid-prop-types
  // Outline the <`searchFocusOffset`>th node and scroll to it.
        searchFocusOffset: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),
  // Get the nodes that match the search criteria. Used for counting total matches, etc.
        searchFinishCallback: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
  // Generate an object with additional props to be passed to the node renderer.
  // Use this for adding buttons via the `buttons` key,
  // or additional `style` / `className` settings.
        generateNodeProps: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
  // Set to false to disable virtualization.
  // NOTE: Auto-scrolling while dragging, and scrolling to the `searchFocusOffset` will be disabled.
        isVirtualized: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
        treeNodeRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
  // Override the default component for rendering nodes (but keep the scaffolding generator)
  // This is an advanced option for complete customization of the appearance.
  // It is best to copy the component in `node-renderer-default.js` to use as a base, and customize as needed.
        nodeContentRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
  // Override the default component for rendering an empty tree
  // This is an advanced option for complete customization of the appearance.
  // It is best to copy the component in `placeholder-renderer-default.js` to use as a base,
  // and customize as needed.
        placeholderRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
        theme: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({
          style: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}),
          innerStyle: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}),
          reactVirtualizedListProps: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}),
          scaffoldBlockPxWidth: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),
          slideRegionSize: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),
          rowHeight: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func)]),
          treeNodeRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
          nodeContentRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
          placeholderRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func)
        }),
  // Determine the unique key used to identify each node and
  // generate the `path` array passed in callbacks.
  // By default, returns the index in the tree (omitting hidden nodes).
        getNodeKey: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
  // Called whenever tree data changed.
  // Just like with React input elements, you have to update your
  // own component's data to see the changes reflected.
        onChange: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func).isRequired,
  // Called after node move operation.
        onMoveNode: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
  // Determine whether a node can be dragged. Set to false to disable dragging on all nodes.
        canDrag: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool)]),
  // Determine whether a node can be dropped based on its path and parents'.
        canDrop: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
  // Determine whether a node can have children
        canNodeHaveChildren: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
  // When true, or a callback returning true, dropping nodes to react-dnd
  // drop targets outside of this tree will not remove them from this tree
        shouldCopyOnOutsideDrop: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool)]),
  // Called after children nodes collapsed or expanded.
        onVisibilityToggle: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
        dndType: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),
  // Called to track between dropped and dragging
        onDragStateChanged: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),
  // Specify that nodes that do not match search will be collapsed
        onlyExpandSearchedNodes: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  // rtl support
        rowDirection: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string)
      };
      ReactSortableTree.defaultProps = {
        canDrag: true,
        canDrop: null,
        canNodeHaveChildren: function canNodeHaveChildren() {
          return true;
        },
        className: '',
        dndType: null,
        generateNodeProps: null,
        getNodeKey: defaultGetNodeKey,
        innerStyle: {},
        isVirtualized: true,
        maxDepth: null,
        treeNodeRenderer: null,
        nodeContentRenderer: null,
        onMoveNode: function onMoveNode() {},
        onVisibilityToggle: function onVisibilityToggle() {},
        placeholderRenderer: null,
        reactVirtualizedListProps: {},
        rowHeight: null,
        scaffoldBlockPxWidth: null,
        searchFinishCallback: null,
        searchFocusOffset: null,
        searchMethod: null,
        searchQuery: null,
        shouldCopyOnOutsideDrop: false,
        slideRegionSize: null,
        style: {},
        theme: {},
        onDragStateChanged: function onDragStateChanged() {},
        onlyExpandSearchedNodes: false,
        rowDirection: 'ltr'
      };
      polyfill(ReactSortableTree);

      var SortableTreeWithoutDndContext = function SortableTreeWithoutDndContext(props) {
        return react__WEBPACK_IMPORTED_MODULE_3___default().createElement(react_dnd__WEBPACK_IMPORTED_MODULE_4__.DndContext.Consumer, null, function (_ref17) {
          const dragDropManager = _ref17.dragDropManager;
          return dragDropManager === undefined ? null : react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ReactSortableTree, _extends({}, props, {
            dragDropManager: dragDropManager
          }));
        });
      };

      const SortableTree = function SortableTree(props) {
        return react__WEBPACK_IMPORTED_MODULE_3___default().createElement(react_dnd__WEBPACK_IMPORTED_MODULE_4__.DndProvider, {
          backend: react_dnd_html5_backend__WEBPACK_IMPORTED_MODULE_5__.HTML5Backend
        }, react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SortableTreeWithoutDndContext, props));
      }; // Export the tree component without the react-dnd DragDropContext,

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SortableTree);



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/ArrowKeyStepper/ArrowKeyStepper.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/ArrowKeyStepper/ArrowKeyStepper.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ const react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-lifecycles-compat */ "./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js");
/* harmony import */ const _Grid__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Grid */ "./node_modules/react-virtualized/dist/es/Grid/index.js");
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/ArrowKeyStepper/types.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_9__);








      let _class, _temp;

      function ownKeys(object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function _objectSpread(target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



/**
 * This HOC decorates a virtualized component and responds to arrow-key events by scrolling one row or column at a time.
 */

      const ArrowKeyStepper = (_temp = _class =
/*#__PURE__*/
function (_React$PureComponent) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(ArrowKeyStepper, _React$PureComponent);

  function ArrowKeyStepper() {
    let _getPrototypeOf2;

    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, ArrowKeyStepper);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, (_getPrototypeOf2 = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(ArrowKeyStepper)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "state", {
      scrollToColumn: 0,
      scrollToRow: 0,
      instanceProps: {
        prevScrollToColumn: 0,
        prevScrollToRow: 0
      }
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_columnStartIndex", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_columnStopIndex", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_rowStartIndex", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_rowStopIndex", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_onKeyDown", function (event) {
      const _this$props = _this.props,
        columnCount = _this$props.columnCount,
        disabled = _this$props.disabled,
        mode = _this$props.mode,
        rowCount = _this$props.rowCount;

      if (disabled) {
        return;
      }

      const _this$_getScrollState = _this._getScrollState(),
        scrollToColumnPrevious = _this$_getScrollState.scrollToColumn,
        scrollToRowPrevious = _this$_getScrollState.scrollToRow;

      let _this$_getScrollState2 = _this._getScrollState(),
        scrollToColumn = _this$_getScrollState2.scrollToColumn,
        scrollToRow = _this$_getScrollState2.scrollToRow; // The above cases all prevent default event event behavior.
      // This is to keep the grid from scrolling after the snap-to update.


      switch (event.key) {
        case 'ArrowDown':
          scrollToRow = mode === 'cells' ? Math.min(scrollToRow + 1, rowCount - 1) : Math.min(_this._rowStopIndex + 1, rowCount - 1);
          break;

        case 'ArrowLeft':
          scrollToColumn = mode === 'cells' ? Math.max(scrollToColumn - 1, 0) : Math.max(_this._columnStartIndex - 1, 0);
          break;

        case 'ArrowRight':
          scrollToColumn = mode === 'cells' ? Math.min(scrollToColumn + 1, columnCount - 1) : Math.min(_this._columnStopIndex + 1, columnCount - 1);
          break;

        case 'ArrowUp':
          scrollToRow = mode === 'cells' ? Math.max(scrollToRow - 1, 0) : Math.max(_this._rowStartIndex - 1, 0);
          break;
      }

      if (scrollToColumn !== scrollToColumnPrevious || scrollToRow !== scrollToRowPrevious) {
        event.preventDefault();

        _this._updateScrollState({
          scrollToColumn: scrollToColumn,
          scrollToRow: scrollToRow
        });
      }
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_onSectionRendered", function (_ref) {
      const columnStartIndex = _ref.columnStartIndex,
        columnStopIndex = _ref.columnStopIndex,
        rowStartIndex = _ref.rowStartIndex,
        rowStopIndex = _ref.rowStopIndex;
      _this._columnStartIndex = columnStartIndex;
      _this._columnStopIndex = columnStopIndex;
      _this._rowStartIndex = rowStartIndex;
      _this._rowStopIndex = rowStopIndex;
    });

    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(ArrowKeyStepper, [{
    key: "setScrollIndexes",
    value: function setScrollIndexes(_ref2) {
      const scrollToColumn = _ref2.scrollToColumn,
        scrollToRow = _ref2.scrollToRow;
      this.setState({
        scrollToRow: scrollToRow,
        scrollToColumn: scrollToColumn
      });
    }
  }, {
    key: "render",
    value: function render() {
      const _this$props2 = this.props,
        className = _this$props2.className,
        children = _this$props2.children;

      const _this$_getScrollState3 = this._getScrollState(),
        scrollToColumn = _this$_getScrollState3.scrollToColumn,
        scrollToRow = _this$_getScrollState3.scrollToRow;

      return react__WEBPACK_IMPORTED_MODULE_7__.createElement("div", {
        className: className,
        onKeyDown: this._onKeyDown
      }, children({
        onSectionRendered: this._onSectionRendered,
        scrollToColumn: scrollToColumn,
        scrollToRow: scrollToRow
      }));
    }
  }, {
    key: "_getScrollState",
    value: function _getScrollState() {
      return this.props.isControlled ? this.props : this.state;
    }
  }, {
    key: "_updateScrollState",
    value: function _updateScrollState(_ref3) {
      const scrollToColumn = _ref3.scrollToColumn,
        scrollToRow = _ref3.scrollToRow;
      const _this$props3 = this.props,
        isControlled = _this$props3.isControlled,
        onScrollToChange = _this$props3.onScrollToChange;

      if (typeof onScrollToChange === 'function') {
        onScrollToChange({
          scrollToColumn: scrollToColumn,
          scrollToRow: scrollToRow
        });
      }

      if (!isControlled) {
        this.setState({
          scrollToColumn: scrollToColumn,
          scrollToRow: scrollToRow
        });
      }
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.isControlled) {
        return {};
      }

      if (nextProps.scrollToColumn !== prevState.instanceProps.prevScrollToColumn || nextProps.scrollToRow !== prevState.instanceProps.prevScrollToRow) {
        return _objectSpread({}, prevState, {
          scrollToColumn: nextProps.scrollToColumn,
          scrollToRow: nextProps.scrollToRow,
          instanceProps: {
            prevScrollToColumn: nextProps.scrollToColumn,
            prevScrollToRow: nextProps.scrollToRow
          }
        });
      }

      return {};
    }
  }]);

  return ArrowKeyStepper;
}(react__WEBPACK_IMPORTED_MODULE_7__.PureComponent), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_class, "propTypes",  false ? 0 : {
        "children": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().func).isRequired,
        "className": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string),
        "columnCount": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number).isRequired,
        "disabled": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().bool).isRequired,
        "isControlled": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().bool).isRequired,
        "mode": prop_types__WEBPACK_IMPORTED_MODULE_9___default().oneOf(["cells", "edges"]).isRequired,
        "onScrollToChange": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().func),
        "rowCount": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number).isRequired,
        "scrollToColumn": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number).isRequired,
        "scrollToRow": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number).isRequired
      }), _temp);

      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(ArrowKeyStepper, "defaultProps", {
        disabled: false,
        isControlled: false,
        mode: 'edges',
        scrollToColumn: 0,
        scrollToRow: 0
      });

      (0,react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_8__.polyfill)(ArrowKeyStepper);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ArrowKeyStepper);




/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/ArrowKeyStepper/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/ArrowKeyStepper/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrowKeyStepper: () => (/* reexport safe */ _ArrowKeyStepper__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   bpfrpt_proptype_ScrollIndices: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_1__.bpfrpt_proptype_ScrollIndices),
/* harmony export */   "default": () => (/* reexport safe */ _ArrowKeyStepper__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _ArrowKeyStepper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArrowKeyStepper */ "./node_modules/react-virtualized/dist/es/ArrowKeyStepper/ArrowKeyStepper.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/ArrowKeyStepper/types.js");





/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/ArrowKeyStepper/types.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/ArrowKeyStepper/types.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bpfrpt_proptype_ScrollIndices: () => (/* binding */ bpfrpt_proptype_ScrollIndices)
/* harmony export */ });
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
      var bpfrpt_proptype_ScrollIndices =  false ? 0 : {
        "scrollToColumn": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired,
        "scrollToRow": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired
      };



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/AutoSizer/AutoSizer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/AutoSizer/AutoSizer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AutoSizer)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ const _vendor_detectElementResize__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../vendor/detectElementResize */ "./node_modules/react-virtualized/dist/es/vendor/detectElementResize.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_9__);








      let _class, _temp;

      function ownKeys(object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function _objectSpread(target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



      var AutoSizer = (_temp = _class =
/*#__PURE__*/
function (_React$Component) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(AutoSizer, _React$Component);

  function AutoSizer() {
    let _getPrototypeOf2;

    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, AutoSizer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, (_getPrototypeOf2 = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(AutoSizer)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "state", {
      height: _this.props.defaultHeight || 0,
      width: _this.props.defaultWidth || 0
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_parentNode", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_autoSizer", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_window", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_detectElementResize", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_onResize", function () {
      const _this$props = _this.props,
        disableHeight = _this$props.disableHeight,
        disableWidth = _this$props.disableWidth,
        onResize = _this$props.onResize;

      if (_this._parentNode) {
        // Guard against AutoSizer component being removed from the DOM immediately after being added.
        // This can result in invalid style values which can result in NaN values if we don't handle them.
        // See issue #150 for more context.
        const height = _this._parentNode.offsetHeight || 0;
        const width = _this._parentNode.offsetWidth || 0;
        const win = _this._window || window;
        const style = win.getComputedStyle(_this._parentNode) || {};
        const paddingLeft = parseInt(style.paddingLeft, 10) || 0;
        const paddingRight = parseInt(style.paddingRight, 10) || 0;
        const paddingTop = parseInt(style.paddingTop, 10) || 0;
        const paddingBottom = parseInt(style.paddingBottom, 10) || 0;
        const newHeight = height - paddingTop - paddingBottom;
        const newWidth = width - paddingLeft - paddingRight;

        if (!disableHeight && _this.state.height !== newHeight || !disableWidth && _this.state.width !== newWidth) {
          _this.setState({
            height: height - paddingTop - paddingBottom,
            width: width - paddingLeft - paddingRight
          });

          onResize({
            height: height,
            width: width
          });
        }
      }
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_setRef", function (autoSizer) {
      _this._autoSizer = autoSizer;
    });

    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(AutoSizer, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      const nonce = this.props.nonce;

      if (this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement) {
        // Delay access of parentNode until mount.
        // This handles edge-cases where the component has already been unmounted before its ref has been set,
        // As well as libraries like react-lite which have a slightly different lifecycle.
        this._parentNode = this._autoSizer.parentNode;
        this._window = this._autoSizer.parentNode.ownerDocument.defaultView; // Defer requiring resize handler in order to support server-side rendering.
        // See issue #41

        this._detectElementResize = (0,_vendor_detectElementResize__WEBPACK_IMPORTED_MODULE_8__["default"])(nonce, this._window);

        this._detectElementResize.addResizeListener(this._parentNode, this._onResize);

        this._onResize();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._detectElementResize && this._parentNode) {
        this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
      }
    }
  }, {
    key: "render",
    value: function render() {
      const _this$props2 = this.props,
        children = _this$props2.children,
        className = _this$props2.className,
        disableHeight = _this$props2.disableHeight,
        disableWidth = _this$props2.disableWidth,
        style = _this$props2.style;
      const _this$state = this.state,
        height = _this$state.height,
        width = _this$state.width; // Outer div should not force width/height since that may prevent containers from shrinking.
      // Inner component should overflow and use calculated width/height.
      // See issue #68 for more information.

      const outerStyle = {
        overflow: 'visible'
      };
      const childParams = {};

      if (!disableHeight) {
        outerStyle.height = 0;
        childParams.height = height;
      }

      if (!disableWidth) {
        outerStyle.width = 0;
        childParams.width = width;
      }
      /**
       * TODO: Avoid rendering children before the initial measurements have been collected.
       * At best this would just be wasting cycles.
       * Add this check into version 10 though as it could break too many ref callbacks in version 9.
       * Note that if default width/height props were provided this would still work with SSR.
      if (
        height !== 0 &&
        width !== 0
      ) {
        child = children({ height, width })
      }
      */


      return react__WEBPACK_IMPORTED_MODULE_7__.createElement("div", {
        className: className,
        ref: this._setRef,
        style: _objectSpread({}, outerStyle, {}, style)
      }, children(childParams));
    }
  }]);

  return AutoSizer;
}(react__WEBPACK_IMPORTED_MODULE_7__.Component), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_class, "propTypes",  false ? 0 : {
  /** Function responsible for rendering children.*/
        "children": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().func).isRequired,

  /** Optional custom CSS class name to attach to root AutoSizer element.  */
        "className": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string),

  /** Default height to use for initial render; useful for SSR */
        "defaultHeight": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number),

  /** Default width to use for initial render; useful for SSR */
        "defaultWidth": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number),

  /** Disable dynamic :height property */
        "disableHeight": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().bool).isRequired,

  /** Disable dynamic :width property */
        "disableWidth": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().bool).isRequired,

  /** Nonce of the inlined stylesheet for Content Security Policy */
        "nonce": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string),

  /** Callback to be invoked on-resize */
        "onResize": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().func).isRequired,

  /** Optional inline style */
        "style": (prop_types__WEBPACK_IMPORTED_MODULE_9___default().object)
      }), _temp);

      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(AutoSizer, "defaultProps", {
        onResize: function onResize() {},
        disableHeight: false,
        disableWidth: false,
        style: {}
      });




/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/AutoSizer/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/AutoSizer/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutoSizer: () => (/* reexport safe */ _AutoSizer__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "default": () => (/* reexport safe */ _AutoSizer__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _AutoSizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoSizer */ "./node_modules/react-virtualized/dist/es/AutoSizer/AutoSizer.js");



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/CellMeasurer/CellMeasurer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/CellMeasurer/CellMeasurer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CellMeasurer)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ const react_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ const react_dom__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/CellMeasurer/types.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_10__);








      let _class, _temp;




/**
 * Wraps a cell and measures its rendered content.
 * Measurements are stored in a per-cell cache.
 * Cached-content is not be re-measured.
 */
      var CellMeasurer = (_temp = _class =
/*#__PURE__*/
function (_React$PureComponent) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(CellMeasurer, _React$PureComponent);

  function CellMeasurer() {
    let _getPrototypeOf2;

    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, CellMeasurer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, (_getPrototypeOf2 = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(CellMeasurer)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_child", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_measure", function () {
      const _this$props = _this.props,
        cache = _this$props.cache,
        _this$props$columnInd = _this$props.columnIndex,
        columnIndex = _this$props$columnInd === void 0 ? 0 : _this$props$columnInd,
        parent = _this$props.parent,
        _this$props$rowIndex = _this$props.rowIndex,
        rowIndex = _this$props$rowIndex === void 0 ? _this.props.index || 0 : _this$props$rowIndex;

      const _this$_getCellMeasure = _this._getCellMeasurements(),
        height = _this$_getCellMeasure.height,
        width = _this$_getCellMeasure.width;

      if (height !== cache.getHeight(rowIndex, columnIndex) || width !== cache.getWidth(rowIndex, columnIndex)) {
        cache.set(rowIndex, columnIndex, width, height);

        if (parent && typeof parent.recomputeGridSize === 'function') {
          parent.recomputeGridSize({
            columnIndex: columnIndex,
            rowIndex: rowIndex
          });
        }
      }
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_registerChild", function (element) {
      if (element && !(element instanceof Element)) {
        console.warn('CellMeasurer registerChild expects to be passed Element or null');
      }

      _this._child = element;

      if (element) {
        _this._maybeMeasureCell();
      }
    });

    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(CellMeasurer, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this._maybeMeasureCell();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this._maybeMeasureCell();
    }
  }, {
    key: "render",
    value: function render() {
      const children = this.props.children;
      return typeof children === 'function' ? children({
        measure: this._measure,
        registerChild: this._registerChild
      }) : children;
    }
  }, {
    key: "_getCellMeasurements",
    value: function _getCellMeasurements() {
      const cache = this.props.cache;
      const node = this._child || (0,react_dom__WEBPACK_IMPORTED_MODULE_8__.findDOMNode)(this); // TODO Check for a bad combination of fixedWidth and missing numeric width or vice versa with height

      if (node && node.ownerDocument && node.ownerDocument.defaultView && node instanceof node.ownerDocument.defaultView.HTMLElement) {
        const styleWidth = node.style.width;
        const styleHeight = node.style.height; // If we are re-measuring a cell that has already been measured,
        // It will have a hard-coded width/height from the previous measurement.
        // The fact that we are measuring indicates this measurement is probably stale,
        // So explicitly clear it out (eg set to "auto") so we can recalculate.
        // See issue #593 for more info.
        // Even if we are measuring initially- if we're inside of a MultiGrid component,
        // Explicitly clear width/height before measuring to avoid being tainted by another Grid.
        // eg top/left Grid renders before bottom/right Grid
        // Since the CellMeasurerCache is shared between them this taints derived cell size values.

        if (!cache.hasFixedWidth()) {
          node.style.width = 'auto';
        }

        if (!cache.hasFixedHeight()) {
          node.style.height = 'auto';
        }

        const height = Math.ceil(node.offsetHeight);
        const width = Math.ceil(node.offsetWidth); // Reset after measuring to avoid breaking styles; see #660

        if (styleWidth) {
          node.style.width = styleWidth;
        }

        if (styleHeight) {
          node.style.height = styleHeight;
        }

        return {
          height: height,
          width: width
        };
      } else {
        return {
          height: 0,
          width: 0
        };
      }
    }
  }, {
    key: "_maybeMeasureCell",
    value: function _maybeMeasureCell() {
      const _this$props2 = this.props,
        cache = _this$props2.cache,
        _this$props2$columnIn = _this$props2.columnIndex,
        columnIndex = _this$props2$columnIn === void 0 ? 0 : _this$props2$columnIn,
        parent = _this$props2.parent,
        _this$props2$rowIndex = _this$props2.rowIndex,
        rowIndex = _this$props2$rowIndex === void 0 ? this.props.index || 0 : _this$props2$rowIndex;

      if (!cache.has(rowIndex, columnIndex)) {
        const _this$_getCellMeasure2 = this._getCellMeasurements(),
          height = _this$_getCellMeasure2.height,
          width = _this$_getCellMeasure2.width;

        cache.set(rowIndex, columnIndex, width, height); // If size has changed, let Grid know to re-render.

        if (parent && typeof parent.invalidateCellSizeAfterRender === 'function') {
          parent.invalidateCellSizeAfterRender({
            columnIndex: columnIndex,
            rowIndex: rowIndex
          });
        }
      }
    }
  }]);

  return CellMeasurer;
}(react__WEBPACK_IMPORTED_MODULE_7__.PureComponent), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_class, "propTypes",  false ? 0 : {
        "cache": function cache() {
          return (typeof _types__WEBPACK_IMPORTED_MODULE_9__.bpfrpt_proptype_CellMeasureCache === "function" ? _types__WEBPACK_IMPORTED_MODULE_9__.bpfrpt_proptype_CellMeasureCache.isRequired ? _types__WEBPACK_IMPORTED_MODULE_9__.bpfrpt_proptype_CellMeasureCache.isRequired : _types__WEBPACK_IMPORTED_MODULE_9__.bpfrpt_proptype_CellMeasureCache : prop_types__WEBPACK_IMPORTED_MODULE_10___default().shape(_types__WEBPACK_IMPORTED_MODULE_9__.bpfrpt_proptype_CellMeasureCache).isRequired).apply(this, arguments);
        },
        "children": prop_types__WEBPACK_IMPORTED_MODULE_10___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_10___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_10___default().node)]).isRequired,
        "columnIndex": (prop_types__WEBPACK_IMPORTED_MODULE_10___default().number),
        "index": (prop_types__WEBPACK_IMPORTED_MODULE_10___default().number),
        "parent": prop_types__WEBPACK_IMPORTED_MODULE_10___default().shape({
          invalidateCellSizeAfterRender: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func),
          recomputeGridSize: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func)
        }).isRequired,
        "rowIndex": (prop_types__WEBPACK_IMPORTED_MODULE_10___default().number)
      }), _temp); // Used for DEV mode warning check

      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(CellMeasurer, "__internalCellMeasurerFlag", false);



      if (true) {
        CellMeasurer.__internalCellMeasurerFlag = true;
      }




/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/CellMeasurer/CellMeasurerCache.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/CellMeasurer/CellMeasurerCache.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_HEIGHT: () => (/* binding */ DEFAULT_HEIGHT),
/* harmony export */   DEFAULT_WIDTH: () => (/* binding */ DEFAULT_WIDTH),
/* harmony export */   "default": () => (/* binding */ CellMeasurerCache)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/CellMeasurer/types.js");



      var DEFAULT_HEIGHT = 30;
      var DEFAULT_WIDTH = 100; // Enables more intelligent mapping of a given column and row index to an item ID.
// This prevents a cell cache from being invalidated when its parent collection is modified.

/**
 * Caches measurements for a given cell.
 */
      var CellMeasurerCache =
/*#__PURE__*/
function () {
  function CellMeasurerCache() {
    const _this = this;

    const params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, CellMeasurerCache);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_cellHeightCache", {});

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_cellWidthCache", {});

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_columnWidthCache", {});

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_rowHeightCache", {});

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_defaultHeight", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_defaultWidth", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_minHeight", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_minWidth", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_keyMapper", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_hasFixedHeight", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_hasFixedWidth", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_columnCount", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_rowCount", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "columnWidth", function (_ref) {
      const index = _ref.index;

      const key = _this._keyMapper(0, index);

      return _this._columnWidthCache[key] !== undefined ? _this._columnWidthCache[key] : _this._defaultWidth;
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "rowHeight", function (_ref2) {
      const index = _ref2.index;

      const key = _this._keyMapper(index, 0);

      return _this._rowHeightCache[key] !== undefined ? _this._rowHeightCache[key] : _this._defaultHeight;
    });

    const defaultHeight = params.defaultHeight,
      defaultWidth = params.defaultWidth,
      fixedHeight = params.fixedHeight,
      fixedWidth = params.fixedWidth,
      keyMapper = params.keyMapper,
      minHeight = params.minHeight,
      minWidth = params.minWidth;
    this._hasFixedHeight = fixedHeight === true;
    this._hasFixedWidth = fixedWidth === true;
    this._minHeight = minHeight || 0;
    this._minWidth = minWidth || 0;
    this._keyMapper = keyMapper || defaultKeyMapper;
    this._defaultHeight = Math.max(this._minHeight, typeof defaultHeight === 'number' ? defaultHeight : DEFAULT_HEIGHT);
    this._defaultWidth = Math.max(this._minWidth, typeof defaultWidth === 'number' ? defaultWidth : DEFAULT_WIDTH);

    if (true) {
      if (this._hasFixedHeight === false && this._hasFixedWidth === false) {
        console.warn("CellMeasurerCache should only measure a cell's width or height. " + 'You have configured CellMeasurerCache to measure both. ' + 'This will result in poor performance.');
      }

      if (this._hasFixedHeight === false && this._defaultHeight === 0) {
        console.warn('Fixed height CellMeasurerCache should specify a :defaultHeight greater than 0. ' + 'Failing to do so will lead to unnecessary layout and poor performance.');
      }

      if (this._hasFixedWidth === false && this._defaultWidth === 0) {
        console.warn('Fixed width CellMeasurerCache should specify a :defaultWidth greater than 0. ' + 'Failing to do so will lead to unnecessary layout and poor performance.');
      }
    }
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(CellMeasurerCache, [{
    key: "clear",
    value: function clear(rowIndex) {
      const columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      const key = this._keyMapper(rowIndex, columnIndex);

      delete this._cellHeightCache[key];
      delete this._cellWidthCache[key];

      this._updateCachedColumnAndRowSizes(rowIndex, columnIndex);
    }
  }, {
    key: "clearAll",
    value: function clearAll() {
      this._cellHeightCache = {};
      this._cellWidthCache = {};
      this._columnWidthCache = {};
      this._rowHeightCache = {};
      this._rowCount = 0;
      this._columnCount = 0;
    }
  }, {
    key: "hasFixedHeight",
    value: function hasFixedHeight() {
      return this._hasFixedHeight;
    }
  }, {
    key: "hasFixedWidth",
    value: function hasFixedWidth() {
      return this._hasFixedWidth;
    }
  }, {
    key: "getHeight",
    value: function getHeight(rowIndex) {
      const columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (this._hasFixedHeight) {
        return this._defaultHeight;
      } else {
        const _key = this._keyMapper(rowIndex, columnIndex);

        return this._cellHeightCache[_key] !== undefined ? Math.max(this._minHeight, this._cellHeightCache[_key]) : this._defaultHeight;
      }
    }
  }, {
    key: "getWidth",
    value: function getWidth(rowIndex) {
      const columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (this._hasFixedWidth) {
        return this._defaultWidth;
      } else {
        const _key2 = this._keyMapper(rowIndex, columnIndex);

        return this._cellWidthCache[_key2] !== undefined ? Math.max(this._minWidth, this._cellWidthCache[_key2]) : this._defaultWidth;
      }
    }
  }, {
    key: "has",
    value: function has(rowIndex) {
      const columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      const key = this._keyMapper(rowIndex, columnIndex);

      return this._cellHeightCache[key] !== undefined;
    }
  }, {
    key: "set",
    value: function set(rowIndex, columnIndex, width, height) {
      const key = this._keyMapper(rowIndex, columnIndex);

      if (columnIndex >= this._columnCount) {
        this._columnCount = columnIndex + 1;
      }

      if (rowIndex >= this._rowCount) {
        this._rowCount = rowIndex + 1;
      } // Size is cached per cell so we don't have to re-measure if cells are re-ordered.


      this._cellHeightCache[key] = height;
      this._cellWidthCache[key] = width;

      this._updateCachedColumnAndRowSizes(rowIndex, columnIndex);
    }
  }, {
    key: "_updateCachedColumnAndRowSizes",
    value: function _updateCachedColumnAndRowSizes(rowIndex, columnIndex) {
      // :columnWidth and :rowHeight are derived based on all cells in a column/row.
      // Pre-cache these derived values for faster lookup later.
      // Reads are expected to occur more frequently than writes in this case.
      // Only update non-fixed dimensions though to avoid doing unnecessary work.
      if (!this._hasFixedWidth) {
        let columnWidth = 0;

        for (let i = 0; i < this._rowCount; i++) {
          columnWidth = Math.max(columnWidth, this.getWidth(i, columnIndex));
        }

        const columnKey = this._keyMapper(0, columnIndex);

        this._columnWidthCache[columnKey] = columnWidth;
      }

      if (!this._hasFixedHeight) {
        let rowHeight = 0;

        for (let _i = 0; _i < this._columnCount; _i++) {
          rowHeight = Math.max(rowHeight, this.getHeight(rowIndex, _i));
        }

        const rowKey = this._keyMapper(rowIndex, 0);

        this._rowHeightCache[rowKey] = rowHeight;
      }
    }
  }, {
    key: "defaultHeight",
    get: function get() {
      return this._defaultHeight;
    }
  }, {
    key: "defaultWidth",
    get: function get() {
      return this._defaultWidth;
    }
  }]);

  return CellMeasurerCache;
}();



      function defaultKeyMapper(rowIndex, columnIndex) {
        return "".concat(rowIndex, "-").concat(columnIndex);
      }



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/CellMeasurer/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/CellMeasurer/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CellMeasurer: () => (/* reexport safe */ _CellMeasurer__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   CellMeasurerCache: () => (/* reexport safe */ _CellMeasurerCache__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CellMeasurer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CellMeasurer */ "./node_modules/react-virtualized/dist/es/CellMeasurer/CellMeasurer.js");
/* harmony import */ var _CellMeasurerCache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CellMeasurerCache */ "./node_modules/react-virtualized/dist/es/CellMeasurer/CellMeasurerCache.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_CellMeasurer__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/CellMeasurer/types.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/CellMeasurer/types.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bpfrpt_proptype_CellMeasureCache: () => (/* binding */ bpfrpt_proptype_CellMeasureCache)
/* harmony export */ });
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
      var bpfrpt_proptype_CellMeasureCache =  false ? 0 : {
        "hasFixedWidth": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().func).isRequired,
        "hasFixedHeight": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().func).isRequired,
        "has": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().func).isRequired,
        "set": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().func).isRequired,
        "getHeight": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().func).isRequired,
        "getWidth": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().func).isRequired
      };



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Collection/Collection.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Collection/Collection.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Collection)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends/index.js");
/* harmony import */ const _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ const _CollectionView__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./CollectionView */ "./node_modules/react-virtualized/dist/es/Collection/CollectionView.js");
/* harmony import */ const _utils_calculateSizeAndPositionData__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/calculateSizeAndPositionData */ "./node_modules/react-virtualized/dist/es/Collection/utils/calculateSizeAndPositionData.js");
/* harmony import */ const _utils_getUpdatedOffsetForIndex__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utils/getUpdatedOffsetForIndex */ "./node_modules/react-virtualized/dist/es/utils/getUpdatedOffsetForIndex.js");
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/Collection/types.js");














/**
 * Renders scattered or non-linear data.
 * Unlike Grid, which renders checkerboard data, Collection can render arbitrarily positioned- even overlapping- data.
 */
      var Collection =
/*#__PURE__*/
function (_React$PureComponent) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default()(Collection, _React$PureComponent);

  function Collection(props, context) {
    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Collection);

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Collection).call(this, props, context));
    _this._cellMetadata = [];
    _this._lastRenderedCellIndices = []; // Cell cache during scroll (for performance)

    _this._cellCache = [];
    _this._isScrollingChange = _this._isScrollingChange.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this));
    _this._setCollectionViewRef = _this._setCollectionViewRef.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this));
    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Collection, [{
    key: "forceUpdate",
    value: function forceUpdate() {
      if (this._collectionView !== undefined) {
        this._collectionView.forceUpdate();
      }
    }
    /** See Collection#recomputeCellSizesAndPositions */

  }, {
    key: "recomputeCellSizesAndPositions",
    value: function recomputeCellSizesAndPositions() {
      this._cellCache = [];

      this._collectionView.recomputeCellSizesAndPositions();
    }
    /** React lifecycle methods */

  }, {
    key: "render",
    value: function render() {
      const props = _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, this.props);

      return react__WEBPACK_IMPORTED_MODULE_9__.createElement(_CollectionView__WEBPACK_IMPORTED_MODULE_10__["default"], _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
        cellLayoutManager: this,
        isScrollingChange: this._isScrollingChange,
        ref: this._setCollectionViewRef
      }, props));
    }
    /** CellLayoutManager interface */

  }, {
    key: "calculateSizeAndPositionData",
    value: function calculateSizeAndPositionData() {
      const _this$props = this.props,
        cellCount = _this$props.cellCount,
        cellSizeAndPositionGetter = _this$props.cellSizeAndPositionGetter,
        sectionSize = _this$props.sectionSize;

      const data = (0,_utils_calculateSizeAndPositionData__WEBPACK_IMPORTED_MODULE_11__["default"])({
        cellCount: cellCount,
        cellSizeAndPositionGetter: cellSizeAndPositionGetter,
        sectionSize: sectionSize
      });

      this._cellMetadata = data.cellMetadata;
      this._sectionManager = data.sectionManager;
      this._height = data.height;
      this._width = data.width;
    }
    /**
     * Returns the most recently rendered set of cell indices.
     */

  }, {
    key: "getLastRenderedIndices",
    value: function getLastRenderedIndices() {
      return this._lastRenderedCellIndices;
    }
    /**
     * Calculates the minimum amount of change from the current scroll position to ensure the specified cell is (fully) visible.
     */

  }, {
    key: "getScrollPositionForCell",
    value: function getScrollPositionForCell(_ref) {
      let align = _ref.align,
        cellIndex = _ref.cellIndex,
        height = _ref.height,
        scrollLeft = _ref.scrollLeft,
        scrollTop = _ref.scrollTop,
        width = _ref.width;
      const cellCount = this.props.cellCount;

      if (cellIndex >= 0 && cellIndex < cellCount) {
        const cellMetadata = this._cellMetadata[cellIndex];
        scrollLeft = (0,_utils_getUpdatedOffsetForIndex__WEBPACK_IMPORTED_MODULE_12__["default"])({
          align: align,
          cellOffset: cellMetadata.x,
          cellSize: cellMetadata.width,
          containerSize: width,
          currentOffset: scrollLeft,
          targetIndex: cellIndex
        });
        scrollTop = (0,_utils_getUpdatedOffsetForIndex__WEBPACK_IMPORTED_MODULE_12__["default"])({
          align: align,
          cellOffset: cellMetadata.y,
          cellSize: cellMetadata.height,
          containerSize: height,
          currentOffset: scrollTop,
          targetIndex: cellIndex
        });
      }

      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }
  }, {
    key: "getTotalSize",
    value: function getTotalSize() {
      return {
        height: this._height,
        width: this._width
      };
    }
  }, {
    key: "cellRenderers",
    value: function cellRenderers(_ref2) {
      const _this2 = this;

      const height = _ref2.height,
        isScrolling = _ref2.isScrolling,
        width = _ref2.width,
        x = _ref2.x,
        y = _ref2.y;
      const _this$props2 = this.props,
        cellGroupRenderer = _this$props2.cellGroupRenderer,
        cellRenderer = _this$props2.cellRenderer; // Store for later calls to getLastRenderedIndices()

      this._lastRenderedCellIndices = this._sectionManager.getCellIndices({
        height: height,
        width: width,
        x: x,
        y: y
      });
      return cellGroupRenderer({
        cellCache: this._cellCache,
        cellRenderer: cellRenderer,
        cellSizeAndPositionGetter: function cellSizeAndPositionGetter(_ref3) {
          const index = _ref3.index;
          return _this2._sectionManager.getCellMetadata({
            index: index
          });
        },
        indices: this._lastRenderedCellIndices,
        isScrolling: isScrolling
      });
    }
  }, {
    key: "_isScrollingChange",
    value: function _isScrollingChange(isScrolling) {
      if (!isScrolling) {
        this._cellCache = [];
      }
    }
  }, {
    key: "_setCollectionViewRef",
    value: function _setCollectionViewRef(ref) {
      this._collectionView = ref;
    }
  }]);

  return Collection;
}(react__WEBPACK_IMPORTED_MODULE_9__.PureComponent);

      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(Collection, "defaultProps", {
        'aria-label': 'grid',
        cellGroupRenderer: defaultCellGroupRenderer
      });


      Collection.propTypes =  true ? {
        'aria-label': (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),

  /**
   * Number of cells in Collection.
   */
        cellCount: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number).isRequired,

  /**
   * Responsible for rendering a group of cells given their indices.
   * Should implement the following interface: ({
   *   cellSizeAndPositionGetter:Function,
   *   indices: Array<number>,
   *   cellRenderer: Function
   * }): Array<PropTypes.node>
   */
        cellGroupRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func).isRequired,

  /**
   * Responsible for rendering a cell given an row and column index.
   * Should implement the following interface: ({ index: number, key: string, style: object }): PropTypes.element
   */
        cellRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func).isRequired,

  /**
   * Callback responsible for returning size and offset/position information for a given cell (index).
   * ({ index: number }): { height: number, width: number, x: number, y: number }
   */
        cellSizeAndPositionGetter: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func).isRequired,

  /**
   * Optionally override the size of the sections a Collection's cells are split into.
   */
        sectionSize: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number)
      } : 0;

      function defaultCellGroupRenderer(_ref4) {
        const cellCache = _ref4.cellCache,
          cellRenderer = _ref4.cellRenderer,
          cellSizeAndPositionGetter = _ref4.cellSizeAndPositionGetter,
          indices = _ref4.indices,
          isScrolling = _ref4.isScrolling;
        return indices.map(function (index) {
          const cellMetadata = cellSizeAndPositionGetter({
            index: index
          });
          const cellRendererProps = {
            index: index,
            isScrolling: isScrolling,
            key: index,
            style: {
              height: cellMetadata.height,
              left: cellMetadata.x,
              position: 'absolute',
              top: cellMetadata.y,
              width: cellMetadata.width
            }
          }; // Avoid re-creating cells while scrolling.
    // This can lead to the same cell being created many times and can cause performance issues for "heavy" cells.
    // If a scroll is in progress- cache and reuse cells.
    // This cache will be thrown away once scrolling complets.

          if (isScrolling) {
            if (!(index in cellCache)) {
              cellCache[index] = cellRenderer(cellRendererProps);
            }

            return cellCache[index];
          } else {
            return cellRenderer(cellRendererProps);
          }
        }).filter(function (renderedCell) {
          return !!renderedCell;
        });
      }




/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Collection/CollectionView.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Collection/CollectionView.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const clsx__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ const react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-lifecycles-compat */ "./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js");
/* harmony import */ const _utils_createCallbackMemoizer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/createCallbackMemoizer */ "./node_modules/react-virtualized/dist/es/utils/createCallbackMemoizer.js");
/* harmony import */ const dom_helpers_scrollbarSize__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! dom-helpers/scrollbarSize */ "./node_modules/react-virtualized/node_modules/dom-helpers/esm/scrollbarSize.js");








      function ownKeys(object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function _objectSpread(target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






 // @TODO Merge Collection and CollectionView

/**
 * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.
 * This improves performance and makes scrolling smoother.
 */

      const IS_SCROLLING_TIMEOUT = 150;
/**
 * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.
 * This prevents Grid from interrupting mouse-wheel animations (see issue #2).
 */

      const SCROLL_POSITION_CHANGE_REASONS = {
        OBSERVED: 'observed',
        REQUESTED: 'requested'
      };
/**
 * Monitors changes in properties (eg. cellCount) and state (eg. scroll offsets) to determine when rendering needs to occur.
 * This component does not render any visible content itself; it defers to the specified :cellLayoutManager.
 */

      const CollectionView =
/*#__PURE__*/
function (_React$PureComponent) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(CollectionView, _React$PureComponent);

  // Invokes callbacks only when their values have changed.
  function CollectionView() {
    let _getPrototypeOf2;

    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, CollectionView);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, (_getPrototypeOf2 = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(CollectionView)).call.apply(_getPrototypeOf2, [this].concat(args))); // If this component is being rendered server-side, getScrollbarSize() will return undefined.
    // We handle this case in componentDidMount()

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "state", {
      isScrolling: false,
      scrollLeft: 0,
      scrollTop: 0
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_calculateSizeAndPositionDataOnNextUpdate", false);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_onSectionRenderedMemoizer", (0,_utils_createCallbackMemoizer__WEBPACK_IMPORTED_MODULE_11__["default"])());

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_onScrollMemoizer", (0,_utils_createCallbackMemoizer__WEBPACK_IMPORTED_MODULE_11__["default"])(false));

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_invokeOnSectionRenderedHelper", function () {
      const _this$props = _this.props,
        cellLayoutManager = _this$props.cellLayoutManager,
        onSectionRendered = _this$props.onSectionRendered;

      _this._onSectionRenderedMemoizer({
        callback: onSectionRendered,
        indices: {
          indices: cellLayoutManager.getLastRenderedIndices()
        }
      });
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_setScrollingContainerRef", function (ref) {
      _this._scrollingContainer = ref;
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_updateScrollPositionForScrollToCell", function () {
      const _this$props2 = _this.props,
        cellLayoutManager = _this$props2.cellLayoutManager,
        height = _this$props2.height,
        scrollToAlignment = _this$props2.scrollToAlignment,
        scrollToCell = _this$props2.scrollToCell,
        width = _this$props2.width;
      const _this$state = _this.state,
        scrollLeft = _this$state.scrollLeft,
        scrollTop = _this$state.scrollTop;

      if (scrollToCell >= 0) {
        const scrollPosition = cellLayoutManager.getScrollPositionForCell({
          align: scrollToAlignment,
          cellIndex: scrollToCell,
          height: height,
          scrollLeft: scrollLeft,
          scrollTop: scrollTop,
          width: width
        });

        if (scrollPosition.scrollLeft !== scrollLeft || scrollPosition.scrollTop !== scrollTop) {
          _this._setScrollPosition(scrollPosition);
        }
      }
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_onScroll", function (event) {
      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.
      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.
      // See issue #404 for more information.
      if (event.target !== _this._scrollingContainer) {
        return;
      } // Prevent pointer events from interrupting a smooth scroll


      _this._enablePointerEventsAfterDelay(); // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,
      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.
      // This causes a series of rapid renders that is slow for long lists.
      // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.


      const _this$props3 = _this.props,
        cellLayoutManager = _this$props3.cellLayoutManager,
        height = _this$props3.height,
        isScrollingChange = _this$props3.isScrollingChange,
        width = _this$props3.width;
      const scrollbarSize = _this._scrollbarSize;

      const _cellLayoutManager$ge = cellLayoutManager.getTotalSize(),
        totalHeight = _cellLayoutManager$ge.height,
        totalWidth = _cellLayoutManager$ge.width;

      const scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft));
      const scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop)); // Certain devices (like Apple touchpad) rapid-fire duplicate events.
      // Don't force a re-render if this is the case.
      // The mouse may move faster then the animation frame does.
      // Use requestAnimationFrame to avoid over-updating.

      if (_this.state.scrollLeft !== scrollLeft || _this.state.scrollTop !== scrollTop) {
        // Browsers with cancelable scroll events (eg. Firefox) interrupt scrolling animations if scrollTop/scrollLeft is set.
        // Other browsers (eg. Safari) don't scroll as well without the help under certain conditions (DOM or style changes during scrolling).
        // All things considered, this seems to be the best current work around that I'm aware of.
        // For more information see https://github.com/bvaughn/react-virtualized/pull/124
        const scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS.OBSERVED : SCROLL_POSITION_CHANGE_REASONS.REQUESTED; // Synchronously set :isScrolling the first time (since _setNextState will reschedule its animation frame each time it's called)

        if (!_this.state.isScrolling) {
          isScrollingChange(true);
        }

        _this.setState({
          isScrolling: true,
          scrollLeft: scrollLeft,
          scrollPositionChangeReason: scrollPositionChangeReason,
          scrollTop: scrollTop
        });
      }

      _this._invokeOnScrollMemoizer({
        scrollLeft: scrollLeft,
        scrollTop: scrollTop,
        totalWidth: totalWidth,
        totalHeight: totalHeight
      });
    });

    _this._scrollbarSize = (0,dom_helpers_scrollbarSize__WEBPACK_IMPORTED_MODULE_12__["default"])();

    if (_this._scrollbarSize === undefined) {
      _this._scrollbarSizeMeasured = false;
      _this._scrollbarSize = 0;
    } else {
      _this._scrollbarSizeMeasured = true;
    }

    return _this;
  }
  /**
   * Forced recompute of cell sizes and positions.
   * This function should be called if cell sizes have changed but nothing else has.
   * Since cell positions are calculated by callbacks, the collection view has no way of detecting when the underlying data has changed.
   */


  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(CollectionView, [{
    key: "recomputeCellSizesAndPositions",
    value: function recomputeCellSizesAndPositions() {
      this._calculateSizeAndPositionDataOnNextUpdate = true;
      this.forceUpdate();
    }
    /* ---------------------------- Component lifecycle methods ---------------------------- */

    /**
     * @private
     * This method updates scrollLeft/scrollTop in state for the following conditions:
     * 1) Empty content (0 rows or columns)
     * 2) New scroll props overriding the current state
     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid
     */

  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      const _this$props4 = this.props,
        cellLayoutManager = _this$props4.cellLayoutManager,
        scrollLeft = _this$props4.scrollLeft,
        scrollToCell = _this$props4.scrollToCell,
        scrollTop = _this$props4.scrollTop; // If this component was first rendered server-side, scrollbar size will be undefined.
      // In that event we need to remeasure.

      if (!this._scrollbarSizeMeasured) {
        this._scrollbarSize = (0,dom_helpers_scrollbarSize__WEBPACK_IMPORTED_MODULE_12__["default"])();
        this._scrollbarSizeMeasured = true;
        this.setState({});
      }

      if (scrollToCell >= 0) {
        this._updateScrollPositionForScrollToCell();
      } else if (scrollLeft >= 0 || scrollTop >= 0) {
        this._setScrollPosition({
          scrollLeft: scrollLeft,
          scrollTop: scrollTop
        });
      } // Update onSectionRendered callback.


      this._invokeOnSectionRenderedHelper();

      const _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(),
        totalHeight = _cellLayoutManager$ge2.height,
        totalWidth = _cellLayoutManager$ge2.width; // Initialize onScroll callback.


      this._invokeOnScrollMemoizer({
        scrollLeft: scrollLeft || 0,
        scrollTop: scrollTop || 0,
        totalHeight: totalHeight,
        totalWidth: totalWidth
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      const _this$props5 = this.props,
        height = _this$props5.height,
        scrollToAlignment = _this$props5.scrollToAlignment,
        scrollToCell = _this$props5.scrollToCell,
        width = _this$props5.width;
      const _this$state2 = this.state,
        scrollLeft = _this$state2.scrollLeft,
        scrollPositionChangeReason = _this$state2.scrollPositionChangeReason,
        scrollTop = _this$state2.scrollTop; // Make sure requested changes to :scrollLeft or :scrollTop get applied.
      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,
      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).
      // So we only set these when we require an adjustment of the scroll position.
      // See issue #2 for more information.

      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {
        if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {
          this._scrollingContainer.scrollLeft = scrollLeft;
        }

        if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {
          this._scrollingContainer.scrollTop = scrollTop;
        }
      } // Update scroll offsets if the current :scrollToCell values requires it


      if (height !== prevProps.height || scrollToAlignment !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {
        this._updateScrollPositionForScrollToCell();
      } // Update onRowsRendered callback if start/stop indices have changed


      this._invokeOnSectionRenderedHelper();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._disablePointerEventsTimeoutId) {
        clearTimeout(this._disablePointerEventsTimeoutId);
      }
    }
  }, {
    key: "render",
    value: function render() {
      const _this$props6 = this.props,
        autoHeight = _this$props6.autoHeight,
        cellCount = _this$props6.cellCount,
        cellLayoutManager = _this$props6.cellLayoutManager,
        className = _this$props6.className,
        height = _this$props6.height,
        horizontalOverscanSize = _this$props6.horizontalOverscanSize,
        id = _this$props6.id,
        noContentRenderer = _this$props6.noContentRenderer,
        style = _this$props6.style,
        verticalOverscanSize = _this$props6.verticalOverscanSize,
        width = _this$props6.width;
      const _this$state3 = this.state,
        isScrolling = _this$state3.isScrolling,
        scrollLeft = _this$state3.scrollLeft,
        scrollTop = _this$state3.scrollTop; // Memoization reset

      if (this._lastRenderedCellCount !== cellCount || this._lastRenderedCellLayoutManager !== cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {
        this._lastRenderedCellCount = cellCount;
        this._lastRenderedCellLayoutManager = cellLayoutManager;
        this._calculateSizeAndPositionDataOnNextUpdate = false;
        cellLayoutManager.calculateSizeAndPositionData();
      }

      const _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(),
        totalHeight = _cellLayoutManager$ge3.height,
        totalWidth = _cellLayoutManager$ge3.width; // Safely expand the rendered area by the specified overscan amount


      const left = Math.max(0, scrollLeft - horizontalOverscanSize);
      const top = Math.max(0, scrollTop - verticalOverscanSize);
      const right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);
      const bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);
      const childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({
        height: bottom - top,
        isScrolling: isScrolling,
        width: right - left,
        x: left,
        y: top
      }) : [];
      const collectionStyle = {
        boxSizing: 'border-box',
        direction: 'ltr',
        height: autoHeight ? 'auto' : height,
        position: 'relative',
        WebkitOverflowScrolling: 'touch',
        width: width,
        willChange: 'transform'
      }; // Force browser to hide scrollbars when we know they aren't necessary.
      // Otherwise once scrollbars appear they may not disappear again.
      // For more info see issue #116

      const verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;
      const horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0; // Also explicitly init styles to 'auto' if scrollbars are required.
      // This works around an obscure edge case where external CSS styles have not yet been loaded,
      // But an initial scroll index of offset is set as an external prop.
      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.
      // This was originally reported via clauderic/react-infinite-calendar/issues/23

      collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';
      collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';
      return react__WEBPACK_IMPORTED_MODULE_9__.createElement("div", {
        ref: this._setScrollingContainerRef,
        "aria-label": this.props['aria-label'],
        className: (0,clsx__WEBPACK_IMPORTED_MODULE_7__["default"])('ReactVirtualized__Collection', className),
        id: id,
        onScroll: this._onScroll,
        role: "grid",
        style: _objectSpread({}, collectionStyle, {}, style),
        tabIndex: 0
      }, cellCount > 0 && react__WEBPACK_IMPORTED_MODULE_9__.createElement("div", {
        className: "ReactVirtualized__Collection__innerScrollContainer",
        style: {
          height: totalHeight,
          maxHeight: totalHeight,
          maxWidth: totalWidth,
          overflow: 'hidden',
          pointerEvents: isScrolling ? 'none' : '',
          width: totalWidth
        }
      }, childrenToDisplay), cellCount === 0 && noContentRenderer());
    }
    /* ---------------------------- Helper methods ---------------------------- */

    /**
     * Sets an :isScrolling flag for a small window of time.
     * This flag is used to disable pointer events on the scrollable portion of the Collection.
     * This prevents jerky/stuttery mouse-wheel scrolling.
     */

  }, {
    key: "_enablePointerEventsAfterDelay",
    value: function _enablePointerEventsAfterDelay() {
      const _this2 = this;

      if (this._disablePointerEventsTimeoutId) {
        clearTimeout(this._disablePointerEventsTimeoutId);
      }

      this._disablePointerEventsTimeoutId = setTimeout(function () {
        const isScrollingChange = _this2.props.isScrollingChange;
        isScrollingChange(false);
        _this2._disablePointerEventsTimeoutId = null;

        _this2.setState({
          isScrolling: false
        });
      }, IS_SCROLLING_TIMEOUT);
    }
  }, {
    key: "_invokeOnScrollMemoizer",
    value: function _invokeOnScrollMemoizer(_ref) {
      const _this3 = this;

      const scrollLeft = _ref.scrollLeft,
        scrollTop = _ref.scrollTop,
        totalHeight = _ref.totalHeight,
        totalWidth = _ref.totalWidth;

      this._onScrollMemoizer({
        callback: function callback(_ref2) {
          const scrollLeft = _ref2.scrollLeft,
            scrollTop = _ref2.scrollTop;
          const _this3$props = _this3.props,
            height = _this3$props.height,
            onScroll = _this3$props.onScroll,
            width = _this3$props.width;
          onScroll({
            clientHeight: height,
            clientWidth: width,
            scrollHeight: totalHeight,
            scrollLeft: scrollLeft,
            scrollTop: scrollTop,
            scrollWidth: totalWidth
          });
        },
        indices: {
          scrollLeft: scrollLeft,
          scrollTop: scrollTop
        }
      });
    }
  }, {
    key: "_setScrollPosition",
    value: function _setScrollPosition(_ref3) {
      const scrollLeft = _ref3.scrollLeft,
        scrollTop = _ref3.scrollTop;
      const newState = {
        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED
      };

      if (scrollLeft >= 0) {
        newState.scrollLeft = scrollLeft;
      }

      if (scrollTop >= 0) {
        newState.scrollTop = scrollTop;
      }

      if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {
        this.setState(newState);
      }
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.cellCount === 0 && (prevState.scrollLeft !== 0 || prevState.scrollTop !== 0)) {
        return {
          scrollLeft: 0,
          scrollTop: 0,
          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED
        };
      } else if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {
        return {
          scrollLeft: nextProps.scrollLeft != null ? nextProps.scrollLeft : prevState.scrollLeft,
          scrollTop: nextProps.scrollTop != null ? nextProps.scrollTop : prevState.scrollTop,
          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED
        };
      }

      return null;
    }
  }]);

  return CollectionView;
}(react__WEBPACK_IMPORTED_MODULE_9__.PureComponent);

      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(CollectionView, "defaultProps", {
        'aria-label': 'grid',
        horizontalOverscanSize: 0,
        noContentRenderer: function noContentRenderer() {
          return null;
        },
        onScroll: function onScroll() {
          return null;
        },
        onSectionRendered: function onSectionRendered() {
          return null;
        },
        scrollToAlignment: 'auto',
        scrollToCell: -1,
        style: {},
        verticalOverscanSize: 0
      });

      CollectionView.propTypes =  true ? {
        'aria-label': (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),

  /**
   * Removes fixed height from the scrollingContainer so that the total height
   * of rows can stretch the window. Intended for use with WindowScroller
   */
        autoHeight: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool),

  /**
   * Number of cells in collection.
   */
        cellCount: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number).isRequired,

  /**
   * Calculates cell sizes and positions and manages rendering the appropriate cells given a specified window.
   */
        cellLayoutManager: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object).isRequired,

  /**
   * Optional custom CSS class name to attach to root Collection element.
   */
        className: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),

  /**
   * Height of Collection; this property determines the number of visible (vs virtualized) rows.
   */
        height: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number).isRequired,

  /**
   * Optional custom id to attach to root Collection element.
   */
        id: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),

  /**
   * Enables the `Collection` to horiontally "overscan" its content similar to how `Grid` does.
   * This can reduce flicker around the edges when a user scrolls quickly.
   */
        horizontalOverscanSize: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number).isRequired,
        isScrollingChange: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func),

  /**
   * Optional renderer to be used in place of rows when either :rowCount or :cellCount is 0.
   */
        noContentRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func).isRequired,

  /**
   * Callback invoked whenever the scroll offset changes within the inner scrollable region.
   * This callback can be used to sync scrolling between lists, tables, or grids.
   * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void
   */
        onScroll: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func).isRequired,

  /**
   * Callback invoked with information about the section of the Collection that was just rendered.
   * This callback is passed a named :indices parameter which is an Array of the most recently rendered section indices.
   */
        onSectionRendered: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func).isRequired,

  /**
   * Horizontal offset.
   */
        scrollLeft: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),

  /**
   * Controls scroll-to-cell behavior of the Grid.
   * The default ("auto") scrolls the least amount possible to ensure that the specified cell is fully visible.
   * Use "start" to align cells to the top/left of the Grid and "end" to align bottom/right.
   */
        scrollToAlignment: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOf(['auto', 'end', 'start', 'center']).isRequired,

  /**
   * Cell index to ensure visible (by forcefully scrolling if necessary).
   */
        scrollToCell: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number).isRequired,

  /**
   * Vertical offset.
   */
        scrollTop: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),

  /**
   * Optional custom inline style to attach to root Collection element.
   */
        style: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object),

  /**
   * Enables the `Collection` to vertically "overscan" its content similar to how `Grid` does.
   * This can reduce flicker around the edges when a user scrolls quickly.
   */
        verticalOverscanSize: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number).isRequired,

  /**
   * Width of Collection; this property determines the number of visible (vs virtualized) columns.
   */
        width: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number).isRequired
      } : 0;
      (0,react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_10__.polyfill)(CollectionView);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CollectionView);

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Collection/Section.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Collection/Section.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Section)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/Collection/types.js");



/**
 * A section of the Window.
 * Window Sections are used to group nearby cells.
 * This enables us to more quickly determine which cells to display in a given region of the Window.
 * Sections have a fixed size and contain 0 to many cells (tracked by their indices).
 */
      var Section =
/*#__PURE__*/
function () {
  function Section(_ref) {
    const height = _ref.height,
      width = _ref.width,
      x = _ref.x,
      y = _ref.y;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, Section);

    this.height = height;
    this.width = width;
    this.x = x;
    this.y = y;
    this._indexMap = {};
    this._indices = [];
  }
  /** Add a cell to this section. */


  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(Section, [{
    key: "addCellIndex",
    value: function addCellIndex(_ref2) {
      const index = _ref2.index;

      if (!this._indexMap[index]) {
        this._indexMap[index] = true;

        this._indices.push(index);
      }
    }
    /** Get all cell indices that have been added to this section. */

  }, {
    key: "getCellIndices",
    value: function getCellIndices() {
      return this._indices;
    }
    /** Intended for debugger/test purposes only */

  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this.x, ",").concat(this.y, " ").concat(this.width, "x").concat(this.height);
    }
  }]);

  return Section;
}();





/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Collection/SectionManager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Collection/SectionManager.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SectionManager)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _Section__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Section */ "./node_modules/react-virtualized/dist/es/Collection/Section.js");
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/Collection/types.js");



/**
 * Window Sections are used to group nearby cells.
 * This enables us to more quickly determine which cells to display in a given region of the Window.
 * 
 */

      const SECTION_SIZE = 100;

/**
 * Contains 0 to many Sections.
 * Grows (and adds Sections) dynamically as cells are registered.
 * Automatically adds cells to the appropriate Section(s).
 */
      var SectionManager =
/*#__PURE__*/
function () {
  function SectionManager() {
    const sectionSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SECTION_SIZE;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, SectionManager);

    this._sectionSize = sectionSize;
    this._cellMetadata = [];
    this._sections = {};
  }
  /**
   * Gets all cell indices contained in the specified region.
   * A region may encompass 1 or more Sections.
   */


  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(SectionManager, [{
    key: "getCellIndices",
    value: function getCellIndices(_ref) {
      const height = _ref.height,
        width = _ref.width,
        x = _ref.x,
        y = _ref.y;
      const indices = {};
      this.getSections({
        height: height,
        width: width,
        x: x,
        y: y
      }).forEach(function (section) {
        return section.getCellIndices().forEach(function (index) {
          indices[index] = index;
        });
      }); // Object keys are strings; this function returns numbers

      return Object.keys(indices).map(function (index) {
        return indices[index];
      });
    }
    /** Get size and position information for the cell specified. */

  }, {
    key: "getCellMetadata",
    value: function getCellMetadata(_ref2) {
      const index = _ref2.index;
      return this._cellMetadata[index];
    }
    /** Get all Sections overlapping the specified region. */

  }, {
    key: "getSections",
    value: function getSections(_ref3) {
      const height = _ref3.height,
        width = _ref3.width,
        x = _ref3.x,
        y = _ref3.y;
      const sectionXStart = Math.floor(x / this._sectionSize);
      const sectionXStop = Math.floor((x + width - 1) / this._sectionSize);
      const sectionYStart = Math.floor(y / this._sectionSize);
      const sectionYStop = Math.floor((y + height - 1) / this._sectionSize);
      const sections = [];

      for (let sectionX = sectionXStart; sectionX <= sectionXStop; sectionX++) {
        for (let sectionY = sectionYStart; sectionY <= sectionYStop; sectionY++) {
          const key = "".concat(sectionX, ".").concat(sectionY);

          if (!this._sections[key]) {
            this._sections[key] = new _Section__WEBPACK_IMPORTED_MODULE_2__["default"]({
              height: this._sectionSize,
              width: this._sectionSize,
              x: sectionX * this._sectionSize,
              y: sectionY * this._sectionSize
            });
          }

          sections.push(this._sections[key]);
        }
      }

      return sections;
    }
    /** Total number of Sections based on the currently registered cells. */

  }, {
    key: "getTotalSectionCount",
    value: function getTotalSectionCount() {
      return Object.keys(this._sections).length;
    }
    /** Intended for debugger/test purposes only */

  }, {
    key: "toString",
    value: function toString() {
      const _this = this;

      return Object.keys(this._sections).map(function (index) {
        return _this._sections[index].toString();
      });
    }
    /** Adds a cell to the appropriate Sections and registers it metadata for later retrievable. */

  }, {
    key: "registerCell",
    value: function registerCell(_ref4) {
      const cellMetadatum = _ref4.cellMetadatum,
        index = _ref4.index;
      this._cellMetadata[index] = cellMetadatum;
      this.getSections(cellMetadatum).forEach(function (section) {
        return section.addCellIndex({
          index: index
        });
      });
    }
  }]);

  return SectionManager;
}();





/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Collection/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Collection/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Collection: () => (/* reexport safe */ _Collection__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Collection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Collection */ "./node_modules/react-virtualized/dist/es/Collection/Collection.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Collection__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Collection/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Collection/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bpfrpt_proptype_Index: () => (/* binding */ bpfrpt_proptype_Index),
/* harmony export */   bpfrpt_proptype_PositionInfo: () => (/* binding */ bpfrpt_proptype_PositionInfo),
/* harmony export */   bpfrpt_proptype_ScrollPosition: () => (/* binding */ bpfrpt_proptype_ScrollPosition),
/* harmony export */   bpfrpt_proptype_SizeAndPositionInfo: () => (/* binding */ bpfrpt_proptype_SizeAndPositionInfo),
/* harmony export */   bpfrpt_proptype_SizeInfo: () => (/* binding */ bpfrpt_proptype_SizeInfo)
/* harmony export */ });
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
      var bpfrpt_proptype_Index =  false ? 0 : {
        "index": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired
      };
      var bpfrpt_proptype_PositionInfo =  false ? 0 : {
        "x": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired,
        "y": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired
      };
      var bpfrpt_proptype_ScrollPosition =  false ? 0 : {
        "scrollLeft": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired,
        "scrollTop": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired
      };
      var bpfrpt_proptype_SizeAndPositionInfo =  false ? 0 : {
        "height": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired,
        "width": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired,
        "x": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired,
        "y": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired
      };
      var bpfrpt_proptype_SizeInfo =  false ? 0 : {
        "height": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired,
        "width": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired
      };







/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Collection/utils/calculateSizeAndPositionData.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Collection/utils/calculateSizeAndPositionData.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ calculateSizeAndPositionData)
/* harmony export */ });
/* harmony import */ const _SectionManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../SectionManager */ "./node_modules/react-virtualized/dist/es/Collection/SectionManager.js");

      function calculateSizeAndPositionData(_ref) {
        const cellCount = _ref.cellCount,
          cellSizeAndPositionGetter = _ref.cellSizeAndPositionGetter,
          sectionSize = _ref.sectionSize;
        const cellMetadata = [];
        const sectionManager = new _SectionManager__WEBPACK_IMPORTED_MODULE_0__["default"](sectionSize);
        let height = 0;
        let width = 0;

        for (let index = 0; index < cellCount; index++) {
          const cellMetadatum = cellSizeAndPositionGetter({
            index: index
          });

          if (cellMetadatum.height == null || isNaN(cellMetadatum.height) || cellMetadatum.width == null || isNaN(cellMetadatum.width) || cellMetadatum.x == null || isNaN(cellMetadatum.x) || cellMetadatum.y == null || isNaN(cellMetadatum.y)) {
            throw Error("Invalid metadata returned for cell ".concat(index, ":\n        x:").concat(cellMetadatum.x, ", y:").concat(cellMetadatum.y, ", width:").concat(cellMetadatum.width, ", height:").concat(cellMetadatum.height));
          }

          height = Math.max(height, cellMetadatum.y + cellMetadatum.height);
          width = Math.max(width, cellMetadatum.x + cellMetadatum.width);
          cellMetadata[index] = cellMetadatum;
          sectionManager.registerCell({
            cellMetadatum: cellMetadatum,
            index: index
          });
        }

        return {
          cellMetadata: cellMetadata,
          height: height,
          sectionManager: sectionManager,
          width: width
        };
      }

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/ColumnSizer/ColumnSizer.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/ColumnSizer/ColumnSizer.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ColumnSizer)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);








/**
 * High-order component that auto-calculates column-widths for `Grid` cells.
 */

      var ColumnSizer =
/*#__PURE__*/
function (_React$PureComponent) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(ColumnSizer, _React$PureComponent);

  function ColumnSizer(props, context) {
    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, ColumnSizer);

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(ColumnSizer).call(this, props, context));
    _this._registerChild = _this._registerChild.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this));
    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(ColumnSizer, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      const _this$props = this.props,
        columnMaxWidth = _this$props.columnMaxWidth,
        columnMinWidth = _this$props.columnMinWidth,
        columnCount = _this$props.columnCount,
        width = _this$props.width;

      if (columnMaxWidth !== prevProps.columnMaxWidth || columnMinWidth !== prevProps.columnMinWidth || columnCount !== prevProps.columnCount || width !== prevProps.width) {
        if (this._registeredChild) {
          this._registeredChild.recomputeGridSize();
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      const _this$props2 = this.props,
        children = _this$props2.children,
        columnMaxWidth = _this$props2.columnMaxWidth,
        columnMinWidth = _this$props2.columnMinWidth,
        columnCount = _this$props2.columnCount,
        width = _this$props2.width;
      const safeColumnMinWidth = columnMinWidth || 1;
      const safeColumnMaxWidth = columnMaxWidth ? Math.min(columnMaxWidth, width) : width;
      let columnWidth = width / columnCount;
      columnWidth = Math.max(safeColumnMinWidth, columnWidth);
      columnWidth = Math.min(safeColumnMaxWidth, columnWidth);
      columnWidth = Math.floor(columnWidth);
      const adjustedWidth = Math.min(width, columnWidth * columnCount);
      return children({
        adjustedWidth: adjustedWidth,
        columnWidth: columnWidth,
        getColumnWidth: function getColumnWidth() {
          return columnWidth;
        },
        registerChild: this._registerChild
      });
    }
  }, {
    key: "_registerChild",
    value: function _registerChild(child) {
      if (child && typeof child.recomputeGridSize !== 'function') {
        throw Error('Unexpected child type registered; only Grid/MultiGrid children are supported.');
      }

      this._registeredChild = child;

      if (this._registeredChild) {
        this._registeredChild.recomputeGridSize();
      }
    }
  }]);

  return ColumnSizer;
}(react__WEBPACK_IMPORTED_MODULE_7__.PureComponent);


      ColumnSizer.propTypes =  true ? {
  /**
   * Function responsible for rendering a virtualized Grid.
   * This function should implement the following signature:
   * ({ adjustedWidth, getColumnWidth, registerChild }) => PropTypes.element
   *
   * The specified :getColumnWidth function should be passed to the Grid's :columnWidth property.
   * The :registerChild should be passed to the Grid's :ref property.
   * The :adjustedWidth property is optional; it reflects the lesser of the overall width or the width of all columns.
   */
        children: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().func).isRequired,

  /** Optional maximum allowed column width */
        columnMaxWidth: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().number),

  /** Optional minimum allowed column width */
        columnMinWidth: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().number),

  /** Number of columns in Grid or Table child */
        columnCount: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().number).isRequired,

  /** Width of Grid or Table child */
        width: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().number).isRequired
      } : 0;

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/ColumnSizer/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/ColumnSizer/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColumnSizer: () => (/* reexport safe */ _ColumnSizer__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ColumnSizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColumnSizer */ "./node_modules/react-virtualized/dist/es/ColumnSizer/ColumnSizer.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_ColumnSizer__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Grid/Grid.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Grid/Grid.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_SCROLLING_RESET_TIME_INTERVAL: () => (/* binding */ DEFAULT_SCROLLING_RESET_TIME_INTERVAL),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends/index.js");
/* harmony import */ const _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ const clsx__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ const _utils_calculateSizeAndPositionDataAndUpdateScrollOffset__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/calculateSizeAndPositionDataAndUpdateScrollOffset */ "./node_modules/react-virtualized/dist/es/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js");
/* harmony import */ const _utils_ScalingCellSizeAndPositionManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/ScalingCellSizeAndPositionManager */ "./node_modules/react-virtualized/dist/es/Grid/utils/ScalingCellSizeAndPositionManager.js");
/* harmony import */ const _utils_createCallbackMemoizer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utils/createCallbackMemoizer */ "./node_modules/react-virtualized/dist/es/utils/createCallbackMemoizer.js");
/* harmony import */ const _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./defaultOverscanIndicesGetter */ "./node_modules/react-virtualized/dist/es/Grid/defaultOverscanIndicesGetter.js");
/* harmony import */ const _utils_updateScrollIndexHelper__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/updateScrollIndexHelper */ "./node_modules/react-virtualized/dist/es/Grid/utils/updateScrollIndexHelper.js");
/* harmony import */ const _defaultCellRangeRenderer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./defaultCellRangeRenderer */ "./node_modules/react-virtualized/dist/es/Grid/defaultCellRangeRenderer.js");
/* harmony import */ const dom_helpers_scrollbarSize__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! dom-helpers/scrollbarSize */ "./node_modules/react-virtualized/node_modules/dom-helpers/esm/scrollbarSize.js");
/* harmony import */ const react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! react-lifecycles-compat */ "./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js");
/* harmony import */ const _utils_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../utils/requestAnimationTimeout */ "./node_modules/react-virtualized/dist/es/utils/requestAnimationTimeout.js");
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/Grid/types.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_19__);









      let _class, _temp;

      function ownKeys(object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function _objectSpread(target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }












/**
 * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.
 * This improves performance and makes scrolling smoother.
 */

      var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;
/**
 * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.
 * This prevents Grid from interrupting mouse-wheel animations (see issue #2).
 */

      const SCROLL_POSITION_CHANGE_REASONS = {
        OBSERVED: 'observed',
        REQUESTED: 'requested'
      };

      const renderNull = function renderNull() {
        return null;
      };

/**
 * Renders tabular data with virtualization along the vertical and horizontal axes.
 * Row heights and column widths must be known ahead of time and specified as properties.
 */
      const Grid = (_temp = _class =
/*#__PURE__*/
function (_React$PureComponent) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default()(Grid, _React$PureComponent);

  // Invokes onSectionRendered callback only when start/stop row or column indices change
  function Grid(props) {
    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Grid);

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Grid).call(this, props));

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_onGridRenderedMemoizer", (0,_utils_createCallbackMemoizer__WEBPACK_IMPORTED_MODULE_12__["default"])());

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_onScrollMemoizer", (0,_utils_createCallbackMemoizer__WEBPACK_IMPORTED_MODULE_12__["default"])(false));

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_deferredInvalidateColumnIndex", null);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_deferredInvalidateRowIndex", null);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_recomputeScrollLeftFlag", false);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_recomputeScrollTopFlag", false);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_horizontalScrollBarSize", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_verticalScrollBarSize", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_scrollbarPresenceChanged", false);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_scrollingContainer", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_childrenToDisplay", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_columnStartIndex", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_columnStopIndex", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_rowStartIndex", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_rowStopIndex", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_renderedColumnStartIndex", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_renderedColumnStopIndex", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_renderedRowStartIndex", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_renderedRowStopIndex", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_initialScrollTop", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_initialScrollLeft", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_disablePointerEventsTimeoutId", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_styleCache", {});

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_cellCache", {});

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_debounceScrollEndedCallback", function () {
      _this._disablePointerEventsTimeoutId = null; // isScrolling is used to determine if we reset styleCache

      _this.setState({
        isScrolling: false,
        needToResetStyleCache: false
      });
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_invokeOnGridRenderedHelper", function () {
      const onSectionRendered = _this.props.onSectionRendered;

      _this._onGridRenderedMemoizer({
        callback: onSectionRendered,
        indices: {
          columnOverscanStartIndex: _this._columnStartIndex,
          columnOverscanStopIndex: _this._columnStopIndex,
          columnStartIndex: _this._renderedColumnStartIndex,
          columnStopIndex: _this._renderedColumnStopIndex,
          rowOverscanStartIndex: _this._rowStartIndex,
          rowOverscanStopIndex: _this._rowStopIndex,
          rowStartIndex: _this._renderedRowStartIndex,
          rowStopIndex: _this._renderedRowStopIndex
        }
      });
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_setScrollingContainerRef", function (ref) {
      _this._scrollingContainer = ref;
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_onScroll", function (event) {
      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.
      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.
      // See issue #404 for more information.
      if (event.target === _this._scrollingContainer) {
        _this.handleScrollEvent(event.target);
      }
    });

    const columnSizeAndPositionManager = new _utils_ScalingCellSizeAndPositionManager__WEBPACK_IMPORTED_MODULE_11__["default"]({
      cellCount: props.columnCount,
      cellSizeGetter: function cellSizeGetter(params) {
        return Grid._wrapSizeGetter(props.columnWidth)(params);
      },
      estimatedCellSize: Grid._getEstimatedColumnSize(props)
    });
    const rowSizeAndPositionManager = new _utils_ScalingCellSizeAndPositionManager__WEBPACK_IMPORTED_MODULE_11__["default"]({
      cellCount: props.rowCount,
      cellSizeGetter: function cellSizeGetter(params) {
        return Grid._wrapSizeGetter(props.rowHeight)(params);
      },
      estimatedCellSize: Grid._getEstimatedRowSize(props)
    });
    _this.state = {
      instanceProps: {
        columnSizeAndPositionManager: columnSizeAndPositionManager,
        rowSizeAndPositionManager: rowSizeAndPositionManager,
        prevColumnWidth: props.columnWidth,
        prevRowHeight: props.rowHeight,
        prevColumnCount: props.columnCount,
        prevRowCount: props.rowCount,
        prevIsScrolling: props.isScrolling === true,
        prevScrollToColumn: props.scrollToColumn,
        prevScrollToRow: props.scrollToRow,
        scrollbarSize: 0,
        scrollbarSizeMeasured: false
      },
      isScrolling: false,
      scrollDirectionHorizontal: _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__.SCROLL_DIRECTION_FORWARD,
      scrollDirectionVertical: _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__.SCROLL_DIRECTION_FORWARD,
      scrollLeft: 0,
      scrollTop: 0,
      scrollPositionChangeReason: null,
      needToResetStyleCache: false
    };

    if (props.scrollToRow > 0) {
      _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);
    }

    if (props.scrollToColumn > 0) {
      _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);
    }

    return _this;
  }
  /**
   * Gets offsets for a given cell and alignment.
   */


  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Grid, [{
    key: "getOffsetForCell",
    value: function getOffsetForCell() {
      const _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$alignment = _ref.alignment,
        alignment = _ref$alignment === void 0 ? this.props.scrollToAlignment : _ref$alignment,
        _ref$columnIndex = _ref.columnIndex,
        columnIndex = _ref$columnIndex === void 0 ? this.props.scrollToColumn : _ref$columnIndex,
        _ref$rowIndex = _ref.rowIndex,
        rowIndex = _ref$rowIndex === void 0 ? this.props.scrollToRow : _ref$rowIndex;

      const offsetProps = _objectSpread({}, this.props, {
        scrollToAlignment: alignment,
        scrollToColumn: columnIndex,
        scrollToRow: rowIndex
      });

      return {
        scrollLeft: this._getCalculatedScrollLeft(offsetProps),
        scrollTop: this._getCalculatedScrollTop(offsetProps)
      };
    }
    /**
     * Gets estimated total rows' height.
     */

  }, {
    key: "getTotalRowsHeight",
    value: function getTotalRowsHeight() {
      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();
    }
    /**
     * Gets estimated total columns' width.
     */

  }, {
    key: "getTotalColumnsWidth",
    value: function getTotalColumnsWidth() {
      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();
    }
    /**
     * This method handles a scroll event originating from an external scroll control.
     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.
     */

  }, {
    key: "handleScrollEvent",
    value: function handleScrollEvent(_ref2) {
      const _ref2$scrollLeft = _ref2.scrollLeft,
        scrollLeftParam = _ref2$scrollLeft === void 0 ? 0 : _ref2$scrollLeft,
        _ref2$scrollTop = _ref2.scrollTop,
        scrollTopParam = _ref2$scrollTop === void 0 ? 0 : _ref2$scrollTop;

      // On iOS, we can arrive at negative offsets by swiping past the start.
      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.
      if (scrollTopParam < 0) {
        return;
      } // Prevent pointer events from interrupting a smooth scroll


      this._debounceScrollEnded();

      const _this$props = this.props,
        autoHeight = _this$props.autoHeight,
        autoWidth = _this$props.autoWidth,
        height = _this$props.height,
        width = _this$props.width;
      const instanceProps = this.state.instanceProps; // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,
      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.
      // This causes a series of rapid renders that is slow for long lists.
      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.

      const scrollbarSize = instanceProps.scrollbarSize;
      const totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();
      const totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();
      const scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);
      const scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam); // Certain devices (like Apple touchpad) rapid-fire duplicate events.
      // Don't force a re-render if this is the case.
      // The mouse may move faster then the animation frame does.
      // Use requestAnimationFrame to avoid over-updating.

      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {
        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.
        // Don't change direction for an axis unless scroll offset has changed.
        const scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;
        const scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;
        const newState = {
          isScrolling: true,
          scrollDirectionHorizontal: scrollDirectionHorizontal,
          scrollDirectionVertical: scrollDirectionVertical,
          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED
        };

        if (!autoHeight) {
          newState.scrollTop = scrollTop;
        }

        if (!autoWidth) {
          newState.scrollLeft = scrollLeft;
        }

        newState.needToResetStyleCache = false;
        this.setState(newState);
      }

      this._invokeOnScrollMemoizer({
        scrollLeft: scrollLeft,
        scrollTop: scrollTop,
        totalColumnsWidth: totalColumnsWidth,
        totalRowsHeight: totalRowsHeight
      });
    }
    /**
     * Invalidate Grid size and recompute visible cells.
     * This is a deferred wrapper for recomputeGridSize().
     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.
     * This method is intended for advanced use-cases like CellMeasurer.
     */
    // @TODO (bvaughn) Add automated test coverage for this.

  }, {
    key: "invalidateCellSizeAfterRender",
    value: function invalidateCellSizeAfterRender(_ref3) {
      const columnIndex = _ref3.columnIndex,
        rowIndex = _ref3.rowIndex;
      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;
      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;
    }
    /**
     * Pre-measure all columns and rows in a Grid.
     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.
     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).
     */

  }, {
    key: "measureAllCells",
    value: function measureAllCells() {
      const _this$props2 = this.props,
        columnCount = _this$props2.columnCount,
        rowCount = _this$props2.rowCount;
      const instanceProps = this.state.instanceProps;
      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);
      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);
    }
    /**
     * Forced recompute of row heights and column widths.
     * This function should be called if dynamic column or row sizes have changed but nothing else has.
     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.
     */

  }, {
    key: "recomputeGridSize",
    value: function recomputeGridSize() {
      const _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref4$columnIndex = _ref4.columnIndex,
        columnIndex = _ref4$columnIndex === void 0 ? 0 : _ref4$columnIndex,
        _ref4$rowIndex = _ref4.rowIndex,
        rowIndex = _ref4$rowIndex === void 0 ? 0 : _ref4$rowIndex;

      const _this$props3 = this.props,
        scrollToColumn = _this$props3.scrollToColumn,
        scrollToRow = _this$props3.scrollToRow;
      const instanceProps = this.state.instanceProps;
      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);
      instanceProps.rowSizeAndPositionManager.resetCell(rowIndex); // Cell sizes may be determined by a function property.
      // In this case the cDU handler can't know if they changed.
      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.

      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__.SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);
      this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__.SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow); // Clear cell cache in case we are scrolling;
      // Invalid row heights likely mean invalid cached content as well.

      this._styleCache = {};
      this._cellCache = {};
      this.forceUpdate();
    }
    /**
     * Ensure column and row are visible.
     */

  }, {
    key: "scrollToCell",
    value: function scrollToCell(_ref5) {
      const columnIndex = _ref5.columnIndex,
        rowIndex = _ref5.rowIndex;
      const columnCount = this.props.columnCount;
      const props = this.props; // Don't adjust scroll offset for single-column grids (eg List, Table).
      // This can cause a funky scroll offset because of the vertical scrollbar width.

      if (columnCount > 1 && columnIndex !== undefined) {
        this._updateScrollLeftForScrollToColumn(_objectSpread({}, props, {
          scrollToColumn: columnIndex
        }));
      }

      if (rowIndex !== undefined) {
        this._updateScrollTopForScrollToRow(_objectSpread({}, props, {
          scrollToRow: rowIndex
        }));
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      const _this$props4 = this.props,
        getScrollbarSize = _this$props4.getScrollbarSize,
        height = _this$props4.height,
        scrollLeft = _this$props4.scrollLeft,
        scrollToColumn = _this$props4.scrollToColumn,
        scrollTop = _this$props4.scrollTop,
        scrollToRow = _this$props4.scrollToRow,
        width = _this$props4.width;
      const instanceProps = this.state.instanceProps; // Reset initial offsets to be ignored in browser

      this._initialScrollTop = 0;
      this._initialScrollLeft = 0; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.
      // We must do this at the start of the method as we may calculate and update scroll position below.

      this._handleInvalidatedGridSize(); // If this component was first rendered server-side, scrollbar size will be undefined.
      // In that event we need to remeasure.


      if (!instanceProps.scrollbarSizeMeasured) {
        this.setState(function (prevState) {
          const stateUpdate = _objectSpread({}, prevState, {
            needToResetStyleCache: false
          });

          stateUpdate.instanceProps.scrollbarSize = getScrollbarSize();
          stateUpdate.instanceProps.scrollbarSizeMeasured = true;
          return stateUpdate;
        });
      }

      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {
        const stateUpdate = Grid._getScrollToPositionStateUpdate({
          prevState: this.state,
          scrollLeft: scrollLeft,
          scrollTop: scrollTop
        });

        if (stateUpdate) {
          stateUpdate.needToResetStyleCache = false;
          this.setState(stateUpdate);
        }
      } // refs don't work in `react-test-renderer`


      if (this._scrollingContainer) {
        // setting the ref's scrollLeft and scrollTop.
        // Somehow in MultiGrid the main grid doesn't trigger a update on mount.
        if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {
          this._scrollingContainer.scrollLeft = this.state.scrollLeft;
        }

        if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {
          this._scrollingContainer.scrollTop = this.state.scrollTop;
        }
      } // Don't update scroll offset if the size is 0; we don't render any cells in this case.
      // Setting a state may cause us to later thing we've updated the offce when we haven't.


      const sizeIsBiggerThanZero = height > 0 && width > 0;

      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {
        this._updateScrollLeftForScrollToColumn();
      }

      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {
        this._updateScrollTopForScrollToRow();
      } // Update onRowsRendered callback


      this._invokeOnGridRenderedHelper(); // Initialize onScroll callback


      this._invokeOnScrollMemoizer({
        scrollLeft: scrollLeft || 0,
        scrollTop: scrollTop || 0,
        totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),
        totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()
      });

      this._maybeCallOnScrollbarPresenceChange();
    }
    /**
     * @private
     * This method updates scrollLeft/scrollTop in state for the following conditions:
     * 1) New scroll-to-cell props have been set
     */

  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      const _this2 = this;

      const _this$props5 = this.props,
        autoHeight = _this$props5.autoHeight,
        autoWidth = _this$props5.autoWidth,
        columnCount = _this$props5.columnCount,
        height = _this$props5.height,
        rowCount = _this$props5.rowCount,
        scrollToAlignment = _this$props5.scrollToAlignment,
        scrollToColumn = _this$props5.scrollToColumn,
        scrollToRow = _this$props5.scrollToRow,
        width = _this$props5.width;
      const _this$state = this.state,
        scrollLeft = _this$state.scrollLeft,
        scrollPositionChangeReason = _this$state.scrollPositionChangeReason,
        scrollTop = _this$state.scrollTop,
        instanceProps = _this$state.instanceProps; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.
      // We must do this at the start of the method as we may calculate and update scroll position below.

      this._handleInvalidatedGridSize(); // Handle edge case where column or row count has only just increased over 0.
      // In this case we may have to restore a previously-specified scroll offset.
      // For more info see bvaughn/react-virtualized/issues/218


      const columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0; // Make sure requested changes to :scrollLeft or :scrollTop get applied.
      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,
      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).
      // So we only set these when we require an adjustment of the scroll position.
      // See issue #2 for more information.

      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {
        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).
        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.
        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {
          this._scrollingContainer.scrollLeft = scrollLeft;
        }

        if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {
          this._scrollingContainer.scrollTop = scrollTop;
        }
      } // Special case where the previous size was 0:
      // In this case we don't show any windowed cells at all.
      // So we should always recalculate offset afterwards.


      const sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0; // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it
      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?

      if (this._recomputeScrollLeftFlag) {
        this._recomputeScrollLeftFlag = false;

        this._updateScrollLeftForScrollToColumn(this.props);
      } else {
        (0,_utils_updateScrollIndexHelper__WEBPACK_IMPORTED_MODULE_14__["default"])({
          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,
          previousCellsCount: prevProps.columnCount,
          previousCellSize: prevProps.columnWidth,
          previousScrollToAlignment: prevProps.scrollToAlignment,
          previousScrollToIndex: prevProps.scrollToColumn,
          previousSize: prevProps.width,
          scrollOffset: scrollLeft,
          scrollToAlignment: scrollToAlignment,
          scrollToIndex: scrollToColumn,
          size: width,
          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,
          updateScrollIndexCallback: function updateScrollIndexCallback() {
            return _this2._updateScrollLeftForScrollToColumn(_this2.props);
          }
        });
      }

      if (this._recomputeScrollTopFlag) {
        this._recomputeScrollTopFlag = false;

        this._updateScrollTopForScrollToRow(this.props);
      } else {
        (0,_utils_updateScrollIndexHelper__WEBPACK_IMPORTED_MODULE_14__["default"])({
          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,
          previousCellsCount: prevProps.rowCount,
          previousCellSize: prevProps.rowHeight,
          previousScrollToAlignment: prevProps.scrollToAlignment,
          previousScrollToIndex: prevProps.scrollToRow,
          previousSize: prevProps.height,
          scrollOffset: scrollTop,
          scrollToAlignment: scrollToAlignment,
          scrollToIndex: scrollToRow,
          size: height,
          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,
          updateScrollIndexCallback: function updateScrollIndexCallback() {
            return _this2._updateScrollTopForScrollToRow(_this2.props);
          }
        });
      } // Update onRowsRendered callback if start/stop indices have changed


      this._invokeOnGridRenderedHelper(); // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners


      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {
        const totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();
        const totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();

        this._invokeOnScrollMemoizer({
          scrollLeft: scrollLeft,
          scrollTop: scrollTop,
          totalColumnsWidth: totalColumnsWidth,
          totalRowsHeight: totalRowsHeight
        });
      }

      this._maybeCallOnScrollbarPresenceChange();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._disablePointerEventsTimeoutId) {
        (0,_utils_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_18__.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);
      }
    }
    /**
     * This method updates scrollLeft/scrollTop in state for the following conditions:
     * 1) Empty content (0 rows or columns)
     * 2) New scroll props overriding the current state
     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid
     */

  }, {
    key: "render",
    value: function render() {
      const _this$props6 = this.props,
        autoContainerWidth = _this$props6.autoContainerWidth,
        autoHeight = _this$props6.autoHeight,
        autoWidth = _this$props6.autoWidth,
        className = _this$props6.className,
        containerProps = _this$props6.containerProps,
        containerRole = _this$props6.containerRole,
        containerStyle = _this$props6.containerStyle,
        height = _this$props6.height,
        id = _this$props6.id,
        noContentRenderer = _this$props6.noContentRenderer,
        role = _this$props6.role,
        style = _this$props6.style,
        tabIndex = _this$props6.tabIndex,
        width = _this$props6.width;
      const _this$state2 = this.state,
        instanceProps = _this$state2.instanceProps,
        needToResetStyleCache = _this$state2.needToResetStyleCache;

      const isScrolling = this._isScrolling();

      const gridStyle = {
        boxSizing: 'border-box',
        direction: 'ltr',
        height: autoHeight ? 'auto' : height,
        position: 'relative',
        width: autoWidth ? 'auto' : width,
        WebkitOverflowScrolling: 'touch',
        willChange: 'transform'
      };

      if (needToResetStyleCache) {
        this._styleCache = {};
      } // calculate _styleCache here
      // if state.isScrolling (not from _isScrolling) then reset


      if (!this.state.isScrolling) {
        this._resetStyleCache();
      } // calculate children to render here


      this._calculateChildrenToRender(this.props, this.state);

      const totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();
      const totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(); // Force browser to hide scrollbars when we know they aren't necessary.
      // Otherwise once scrollbars appear they may not disappear again.
      // For more info see issue #116

      const verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;
      const horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;

      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {
        this._horizontalScrollBarSize = horizontalScrollBarSize;
        this._verticalScrollBarSize = verticalScrollBarSize;
        this._scrollbarPresenceChanged = true;
      } // Also explicitly init styles to 'auto' if scrollbars are required.
      // This works around an obscure edge case where external CSS styles have not yet been loaded,
      // But an initial scroll index of offset is set as an external prop.
      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.
      // This was originally reported via clauderic/react-infinite-calendar/issues/23


      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';
      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';
      const childrenToDisplay = this._childrenToDisplay;
      const showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;
      return react__WEBPACK_IMPORTED_MODULE_8__.createElement("div", _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
        ref: this._setScrollingContainerRef
      }, containerProps, {
        "aria-label": this.props['aria-label'],
        "aria-readonly": this.props['aria-readonly'],
        className: (0,clsx__WEBPACK_IMPORTED_MODULE_9__["default"])('ReactVirtualized__Grid', className),
        id: id,
        onScroll: this._onScroll,
        role: role,
        style: _objectSpread({}, gridStyle, {}, style),
        tabIndex: tabIndex
      }), childrenToDisplay.length > 0 && react__WEBPACK_IMPORTED_MODULE_8__.createElement("div", {
        className: "ReactVirtualized__Grid__innerScrollContainer",
        role: containerRole,
        style: _objectSpread({
          width: autoContainerWidth ? 'auto' : totalColumnsWidth,
          height: totalRowsHeight,
          maxWidth: totalColumnsWidth,
          maxHeight: totalRowsHeight,
          overflow: 'hidden',
          pointerEvents: isScrolling ? 'none' : '',
          position: 'relative'
        }, containerStyle)
      }, childrenToDisplay), showNoContentRenderer && noContentRenderer());
    }
    /* ---------------------------- Helper methods ---------------------------- */

  }, {
    key: "_calculateChildrenToRender",
    value: function _calculateChildrenToRender() {
      const props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      const state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
      const cellRenderer = props.cellRenderer,
        cellRangeRenderer = props.cellRangeRenderer,
        columnCount = props.columnCount,
        deferredMeasurementCache = props.deferredMeasurementCache,
        height = props.height,
        overscanColumnCount = props.overscanColumnCount,
        overscanIndicesGetter = props.overscanIndicesGetter,
        overscanRowCount = props.overscanRowCount,
        rowCount = props.rowCount,
        width = props.width,
        isScrollingOptOut = props.isScrollingOptOut;
      const scrollDirectionHorizontal = state.scrollDirectionHorizontal,
        scrollDirectionVertical = state.scrollDirectionVertical,
        instanceProps = state.instanceProps;
      const scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;
      const scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;

      const isScrolling = this._isScrolling(props, state);

      this._childrenToDisplay = []; // Render only enough columns and rows to cover the visible area of the grid.

      if (height > 0 && width > 0) {
        const visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({
          containerSize: width,
          offset: scrollLeft
        });
        const visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({
          containerSize: height,
          offset: scrollTop
        });
        const horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({
          containerSize: width,
          offset: scrollLeft
        });
        const verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({
          containerSize: height,
          offset: scrollTop
        }); // Store for _invokeOnGridRenderedHelper()

        this._renderedColumnStartIndex = visibleColumnIndices.start;
        this._renderedColumnStopIndex = visibleColumnIndices.stop;
        this._renderedRowStartIndex = visibleRowIndices.start;
        this._renderedRowStopIndex = visibleRowIndices.stop;
        const overscanColumnIndices = overscanIndicesGetter({
          direction: 'horizontal',
          cellCount: columnCount,
          overscanCellsCount: overscanColumnCount,
          scrollDirection: scrollDirectionHorizontal,
          startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,
          stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1
        });
        const overscanRowIndices = overscanIndicesGetter({
          direction: 'vertical',
          cellCount: rowCount,
          overscanCellsCount: overscanRowCount,
          scrollDirection: scrollDirectionVertical,
          startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,
          stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1
        }); // Store for _invokeOnGridRenderedHelper()

        let columnStartIndex = overscanColumnIndices.overscanStartIndex;
        let columnStopIndex = overscanColumnIndices.overscanStopIndex;
        let rowStartIndex = overscanRowIndices.overscanStartIndex;
        let rowStopIndex = overscanRowIndices.overscanStopIndex; // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.

        if (deferredMeasurementCache) {
          // If rows have a dynamic height, scan the rows we are about to render.
          // If any have not yet been measured, then we need to render all columns initially,
          // Because the height of the row is equal to the tallest cell within that row,
          // (And so we can't know the height without measuring all column-cells first).
          if (!deferredMeasurementCache.hasFixedHeight()) {
            for (let rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {
              if (!deferredMeasurementCache.has(rowIndex, 0)) {
                columnStartIndex = 0;
                columnStopIndex = columnCount - 1;
                break;
              }
            }
          } // If columns have a dynamic width, scan the columns we are about to render.
          // If any have not yet been measured, then we need to render all rows initially,
          // Because the width of the column is equal to the widest cell within that column,
          // (And so we can't know the width without measuring all row-cells first).


          if (!deferredMeasurementCache.hasFixedWidth()) {
            for (let columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
              if (!deferredMeasurementCache.has(0, columnIndex)) {
                rowStartIndex = 0;
                rowStopIndex = rowCount - 1;
                break;
              }
            }
          }
        }

        this._childrenToDisplay = cellRangeRenderer({
          cellCache: this._cellCache,
          cellRenderer: cellRenderer,
          columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,
          columnStartIndex: columnStartIndex,
          columnStopIndex: columnStopIndex,
          deferredMeasurementCache: deferredMeasurementCache,
          horizontalOffsetAdjustment: horizontalOffsetAdjustment,
          isScrolling: isScrolling,
          isScrollingOptOut: isScrollingOptOut,
          parent: this,
          rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,
          rowStartIndex: rowStartIndex,
          rowStopIndex: rowStopIndex,
          scrollLeft: scrollLeft,
          scrollTop: scrollTop,
          styleCache: this._styleCache,
          verticalOffsetAdjustment: verticalOffsetAdjustment,
          visibleColumnIndices: visibleColumnIndices,
          visibleRowIndices: visibleRowIndices
        }); // update the indices

        this._columnStartIndex = columnStartIndex;
        this._columnStopIndex = columnStopIndex;
        this._rowStartIndex = rowStartIndex;
        this._rowStopIndex = rowStopIndex;
      }
    }
    /**
     * Sets an :isScrolling flag for a small window of time.
     * This flag is used to disable pointer events on the scrollable portion of the Grid.
     * This prevents jerky/stuttery mouse-wheel scrolling.
     */

  }, {
    key: "_debounceScrollEnded",
    value: function _debounceScrollEnded() {
      const scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;

      if (this._disablePointerEventsTimeoutId) {
        (0,_utils_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_18__.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);
      }

      this._disablePointerEventsTimeoutId = (0,_utils_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_18__.requestAnimationTimeout)(this._debounceScrollEndedCallback, scrollingResetTimeInterval);
    }
  }, {
    key: "_handleInvalidatedGridSize",

    /**
     * Check for batched CellMeasurer size invalidations.
     * This will occur the first time one or more previously unmeasured cells are rendered.
     */
    value: function _handleInvalidatedGridSize() {
      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {
        const columnIndex = this._deferredInvalidateColumnIndex;
        const rowIndex = this._deferredInvalidateRowIndex;
        this._deferredInvalidateColumnIndex = null;
        this._deferredInvalidateRowIndex = null;
        this.recomputeGridSize({
          columnIndex: columnIndex,
          rowIndex: rowIndex
        });
      }
    }
  }, {
    key: "_invokeOnScrollMemoizer",
    value: function _invokeOnScrollMemoizer(_ref6) {
      const _this3 = this;

      const scrollLeft = _ref6.scrollLeft,
        scrollTop = _ref6.scrollTop,
        totalColumnsWidth = _ref6.totalColumnsWidth,
        totalRowsHeight = _ref6.totalRowsHeight;

      this._onScrollMemoizer({
        callback: function callback(_ref7) {
          const scrollLeft = _ref7.scrollLeft,
            scrollTop = _ref7.scrollTop;
          const _this3$props = _this3.props,
            height = _this3$props.height,
            onScroll = _this3$props.onScroll,
            width = _this3$props.width;
          onScroll({
            clientHeight: height,
            clientWidth: width,
            scrollHeight: totalRowsHeight,
            scrollLeft: scrollLeft,
            scrollTop: scrollTop,
            scrollWidth: totalColumnsWidth
          });
        },
        indices: {
          scrollLeft: scrollLeft,
          scrollTop: scrollTop
        }
      });
    }
  }, {
    key: "_isScrolling",
    value: function _isScrolling() {
      const props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      const state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
      // If isScrolling is defined in props, use it to override the value in state
      // This is a performance optimization for WindowScroller + Grid
      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);
    }
  }, {
    key: "_maybeCallOnScrollbarPresenceChange",
    value: function _maybeCallOnScrollbarPresenceChange() {
      if (this._scrollbarPresenceChanged) {
        const onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;
        this._scrollbarPresenceChanged = false;
        onScrollbarPresenceChange({
          horizontal: this._horizontalScrollBarSize > 0,
          size: this.state.instanceProps.scrollbarSize,
          vertical: this._verticalScrollBarSize > 0
        });
      }
    }
  }, {
    key: "scrollToPosition",

    /**
     * Scroll to the specified offset(s).
     * Useful for animating position changes.
     */
    value: function scrollToPosition(_ref8) {
      const scrollLeft = _ref8.scrollLeft,
        scrollTop = _ref8.scrollTop;

      const stateUpdate = Grid._getScrollToPositionStateUpdate({
        prevState: this.state,
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      });

      if (stateUpdate) {
        stateUpdate.needToResetStyleCache = false;
        this.setState(stateUpdate);
      }
    }
  }, {
    key: "_getCalculatedScrollLeft",
    value: function _getCalculatedScrollLeft() {
      const props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      const state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
      return Grid._getCalculatedScrollLeft(props, state);
    }
  }, {
    key: "_updateScrollLeftForScrollToColumn",
    value: function _updateScrollLeftForScrollToColumn() {
      const props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      const state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;

      const stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);

      if (stateUpdate) {
        stateUpdate.needToResetStyleCache = false;
        this.setState(stateUpdate);
      }
    }
  }, {
    key: "_getCalculatedScrollTop",
    value: function _getCalculatedScrollTop() {
      const props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      const state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
      return Grid._getCalculatedScrollTop(props, state);
    }
  }, {
    key: "_resetStyleCache",
    value: function _resetStyleCache() {
      const styleCache = this._styleCache;
      const cellCache = this._cellCache;
      const isScrollingOptOut = this.props.isScrollingOptOut; // Reset cell and style caches once scrolling stops.
      // This makes Grid simpler to use (since cells commonly change).
      // And it keeps the caches from growing too large.
      // Performance is most sensitive when a user is scrolling.
      // Don't clear visible cells from cellCache if isScrollingOptOut is specified.
      // This keeps the cellCache to a resonable size.

      this._cellCache = {};
      this._styleCache = {}; // Copy over the visible cell styles so avoid unnecessary re-render.

      for (let rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {
        for (let columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {
          const key = "".concat(rowIndex, "-").concat(columnIndex);
          this._styleCache[key] = styleCache[key];

          if (isScrollingOptOut) {
            this._cellCache[key] = cellCache[key];
          }
        }
      }
    }
  }, {
    key: "_updateScrollTopForScrollToRow",
    value: function _updateScrollTopForScrollToRow() {
      const props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      const state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;

      const stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);

      if (stateUpdate) {
        stateUpdate.needToResetStyleCache = false;
        this.setState(stateUpdate);
      }
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      const newState = {};

      if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {
        newState.scrollLeft = 0;
        newState.scrollTop = 0; // only use scroll{Left,Top} from props if scrollTo{Column,Row} isn't specified
        // scrollTo{Column,Row} should override scroll{Left,Top}
      } else if (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) {
        Object.assign(newState, Grid._getScrollToPositionStateUpdate({
          prevState: prevState,
          scrollLeft: nextProps.scrollLeft,
          scrollTop: nextProps.scrollTop
        }));
      }

      const instanceProps = prevState.instanceProps; // Initially we should not clearStyleCache

      newState.needToResetStyleCache = false;

      if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {
        // Reset cache. set it to {} in render
        newState.needToResetStyleCache = true;
      }

      instanceProps.columnSizeAndPositionManager.configure({
        cellCount: nextProps.columnCount,
        estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),
        cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)
      });
      instanceProps.rowSizeAndPositionManager.configure({
        cellCount: nextProps.rowCount,
        estimatedCellSize: Grid._getEstimatedRowSize(nextProps),
        cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)
      });

      if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {
        instanceProps.prevColumnCount = 0;
        instanceProps.prevRowCount = 0;
      } // If scrolling is controlled outside this component, clear cache when scrolling stops


      if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {
        Object.assign(newState, {
          isScrolling: false
        });
      }

      let maybeStateA;
      let maybeStateB;
      (0,_utils_calculateSizeAndPositionDataAndUpdateScrollOffset__WEBPACK_IMPORTED_MODULE_10__["default"])({
        cellCount: instanceProps.prevColumnCount,
        cellSize: typeof instanceProps.prevColumnWidth === 'number' ? instanceProps.prevColumnWidth : null,
        computeMetadataCallback: function computeMetadataCallback() {
          return instanceProps.columnSizeAndPositionManager.resetCell(0);
        },
        computeMetadataCallbackProps: nextProps,
        nextCellsCount: nextProps.columnCount,
        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,
        nextScrollToIndex: nextProps.scrollToColumn,
        scrollToIndex: instanceProps.prevScrollToColumn,
        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {
          maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);
        }
      });
      (0,_utils_calculateSizeAndPositionDataAndUpdateScrollOffset__WEBPACK_IMPORTED_MODULE_10__["default"])({
        cellCount: instanceProps.prevRowCount,
        cellSize: typeof instanceProps.prevRowHeight === 'number' ? instanceProps.prevRowHeight : null,
        computeMetadataCallback: function computeMetadataCallback() {
          return instanceProps.rowSizeAndPositionManager.resetCell(0);
        },
        computeMetadataCallbackProps: nextProps,
        nextCellsCount: nextProps.rowCount,
        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,
        nextScrollToIndex: nextProps.scrollToRow,
        scrollToIndex: instanceProps.prevScrollToRow,
        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {
          maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);
        }
      });
      instanceProps.prevColumnCount = nextProps.columnCount;
      instanceProps.prevColumnWidth = nextProps.columnWidth;
      instanceProps.prevIsScrolling = nextProps.isScrolling === true;
      instanceProps.prevRowCount = nextProps.rowCount;
      instanceProps.prevRowHeight = nextProps.rowHeight;
      instanceProps.prevScrollToColumn = nextProps.scrollToColumn;
      instanceProps.prevScrollToRow = nextProps.scrollToRow; // getting scrollBarSize (moved from componentWillMount)

      instanceProps.scrollbarSize = nextProps.getScrollbarSize();

      if (instanceProps.scrollbarSize === undefined) {
        instanceProps.scrollbarSizeMeasured = false;
        instanceProps.scrollbarSize = 0;
      } else {
        instanceProps.scrollbarSizeMeasured = true;
      }

      newState.instanceProps = instanceProps;
      return _objectSpread({}, newState, {}, maybeStateA, {}, maybeStateB);
    }
  }, {
    key: "_getEstimatedColumnSize",
    value: function _getEstimatedColumnSize(props) {
      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;
    }
  }, {
    key: "_getEstimatedRowSize",
    value: function _getEstimatedRowSize(props) {
      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;
    }
  }, {
    key: "_getScrollToPositionStateUpdate",

    /**
     * Get the updated state after scrolling to
     * scrollLeft and scrollTop
     */
    value: function _getScrollToPositionStateUpdate(_ref9) {
      const prevState = _ref9.prevState,
        scrollLeft = _ref9.scrollLeft,
        scrollTop = _ref9.scrollTop;
      const newState = {
        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED
      };

      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {
        newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__.SCROLL_DIRECTION_BACKWARD;
        newState.scrollLeft = scrollLeft;
      }

      if (typeof scrollTop === 'number' && scrollTop >= 0) {
        newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__.SCROLL_DIRECTION_BACKWARD;
        newState.scrollTop = scrollTop;
      }

      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {
        return newState;
      }

      return {};
    }
  }, {
    key: "_wrapSizeGetter",
    value: function _wrapSizeGetter(value) {
      return typeof value === 'function' ? value : function () {
        return value;
      };
    }
  }, {
    key: "_getCalculatedScrollLeft",
    value: function _getCalculatedScrollLeft(nextProps, prevState) {
      const columnCount = nextProps.columnCount,
        height = nextProps.height,
        scrollToAlignment = nextProps.scrollToAlignment,
        scrollToColumn = nextProps.scrollToColumn,
        width = nextProps.width;
      const scrollLeft = prevState.scrollLeft,
        instanceProps = prevState.instanceProps;

      if (columnCount > 0) {
        const finalColumn = columnCount - 1;
        const targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);
        const totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();
        const scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;
        return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({
          align: scrollToAlignment,
          containerSize: width - scrollBarSize,
          currentOffset: scrollLeft,
          targetIndex: targetIndex
        });
      }

      return 0;
    }
  }, {
    key: "_getScrollLeftForScrollToColumnStateUpdate",
    value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {
      const scrollLeft = prevState.scrollLeft;

      const calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);

      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {
        return Grid._getScrollToPositionStateUpdate({
          prevState: prevState,
          scrollLeft: calculatedScrollLeft,
          scrollTop: -1
        });
      }

      return {};
    }
  }, {
    key: "_getCalculatedScrollTop",
    value: function _getCalculatedScrollTop(nextProps, prevState) {
      const height = nextProps.height,
        rowCount = nextProps.rowCount,
        scrollToAlignment = nextProps.scrollToAlignment,
        scrollToRow = nextProps.scrollToRow,
        width = nextProps.width;
      const scrollTop = prevState.scrollTop,
        instanceProps = prevState.instanceProps;

      if (rowCount > 0) {
        const finalRow = rowCount - 1;
        const targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);
        const totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();
        const scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;
        return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({
          align: scrollToAlignment,
          containerSize: height - scrollBarSize,
          currentOffset: scrollTop,
          targetIndex: targetIndex
        });
      }

      return 0;
    }
  }, {
    key: "_getScrollTopForScrollToRowStateUpdate",
    value: function _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {
      const scrollTop = prevState.scrollTop;

      const calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);

      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {
        return Grid._getScrollToPositionStateUpdate({
          prevState: prevState,
          scrollLeft: -1,
          scrollTop: calculatedScrollTop
        });
      }

      return {};
    }
  }]);

  return Grid;
}(react__WEBPACK_IMPORTED_MODULE_8__.PureComponent), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_class, "propTypes",  false ? 0 : {
        "aria-label": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().string).isRequired,
        "aria-readonly": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().bool),

  /**
   * Set the width of the inner scrollable container to 'auto'.
   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.
   */
        "autoContainerWidth": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().bool).isRequired,

  /**
   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.
   * Intended for use with WindowScroller
   */
        "autoHeight": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().bool).isRequired,

  /**
   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.
   * Intended for use with WindowScroller
   */
        "autoWidth": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().bool).isRequired,

  /** Responsible for rendering a cell given an row and column index.  */
        "cellRenderer": function cellRenderer() {
          return (typeof _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellRenderer === "function" ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellRenderer.isRequired ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellRenderer.isRequired : _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellRenderer : prop_types__WEBPACK_IMPORTED_MODULE_19___default().shape(_types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);
        },

  /** Responsible for rendering a group of cells given their index ranges.  */
        "cellRangeRenderer": function cellRangeRenderer() {
          return (typeof _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellRangeRenderer === "function" ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellRangeRenderer.isRequired ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellRangeRenderer.isRequired : _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellRangeRenderer : prop_types__WEBPACK_IMPORTED_MODULE_19___default().shape(_types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);
        },

  /** Optional custom CSS class name to attach to root Grid element.  */
        "className": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().string),

  /** Number of columns in grid.  */
        "columnCount": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number).isRequired,

  /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */
        "columnWidth": function columnWidth() {
          return (typeof _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellSize === "function" ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellSize.isRequired ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellSize.isRequired : _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellSize : prop_types__WEBPACK_IMPORTED_MODULE_19___default().shape(_types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);
        },

  /** Unfiltered props for the Grid container. */
        "containerProps": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().object),

  /** ARIA role for the cell-container.  */
        "containerRole": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().string).isRequired,

  /** Optional inline style applied to inner cell-container */
        "containerStyle": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().object).isRequired,

  /**
   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.
   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.
   */
        "deferredMeasurementCache": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().object),

  /**
   * Used to estimate the total width of a Grid before all of its columns have actually been measured.
   * The estimated total width is adjusted as columns are rendered.
   */
        "estimatedColumnSize": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number).isRequired,

  /**
   * Used to estimate the total height of a Grid before all of its rows have actually been measured.
   * The estimated total height is adjusted as rows are rendered.
   */
        "estimatedRowSize": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number).isRequired,

  /** Exposed for testing purposes only.  */
        "getScrollbarSize": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().func).isRequired,

  /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */
        "height": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number).isRequired,

  /** Optional custom id to attach to root Grid element.  */
        "id": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().string),

  /**
   * Override internal is-scrolling state tracking.
   * This property is primarily intended for use with the WindowScroller component.
   */
        "isScrolling": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().bool),

  /**
   * Opt-out of isScrolling param passed to cellRangeRenderer.
   * To avoid the extra render when scroll stops.
   */
        "isScrollingOptOut": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().bool).isRequired,

  /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */
        "noContentRenderer": function noContentRenderer() {
          return (typeof _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_NoContentRenderer === "function" ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_NoContentRenderer.isRequired ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_NoContentRenderer.isRequired : _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_NoContentRenderer : prop_types__WEBPACK_IMPORTED_MODULE_19___default().shape(_types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);
        },

  /**
   * Callback invoked whenever the scroll offset changes within the inner scrollable region.
   * This callback can be used to sync scrolling between lists, tables, or grids.
   */
        "onScroll": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().func).isRequired,

  /**
   * Called whenever a horizontal or vertical scrollbar is added or removed.
   * This prop is not intended for end-user use;
   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.
   */
        "onScrollbarPresenceChange": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().func).isRequired,

  /** Callback invoked with information about the section of the Grid that was just rendered.  */
        "onSectionRendered": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().func).isRequired,

  /**
   * Number of columns to render before/after the visible section of the grid.
   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.
   */
        "overscanColumnCount": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number).isRequired,

  /**
   * Calculates the number of cells to overscan before and after a specified range.
   * This function ensures that overscanning doesn't exceed the available cells.
   */
        "overscanIndicesGetter": function overscanIndicesGetter() {
          return (typeof _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_OverscanIndicesGetter === "function" ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_OverscanIndicesGetter.isRequired ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_OverscanIndicesGetter.isRequired : _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_OverscanIndicesGetter : prop_types__WEBPACK_IMPORTED_MODULE_19___default().shape(_types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);
        },

  /**
   * Number of rows to render above/below the visible section of the grid.
   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.
   */
        "overscanRowCount": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number).isRequired,

  /** ARIA role for the grid element.  */
        "role": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().string).isRequired,

  /**
   * Either a fixed row height (number) or a function that returns the height of a row given its index.
   * Should implement the following interface: ({ index: number }): number
   */
        "rowHeight": function rowHeight() {
          return (typeof _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellSize === "function" ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellSize.isRequired ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellSize.isRequired : _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellSize : prop_types__WEBPACK_IMPORTED_MODULE_19___default().shape(_types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);
        },

  /** Number of rows in grid.  */
        "rowCount": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number).isRequired,

  /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */
        "scrollingResetTimeInterval": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number).isRequired,

  /** Horizontal offset. */
        "scrollLeft": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number),

  /**
   * Controls scroll-to-cell behavior of the Grid.
   * The default ("auto") scrolls the least amount possible to ensure that the specified cell is fully visible.
   * Use "start" to align cells to the top/left of the Grid and "end" to align bottom/right.
   */
        "scrollToAlignment": function scrollToAlignment() {
          return (typeof _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_Alignment === "function" ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_Alignment.isRequired ? _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_Alignment.isRequired : _types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_Alignment : prop_types__WEBPACK_IMPORTED_MODULE_19___default().shape(_types__WEBPACK_IMPORTED_MODULE_20__.bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);
        },

  /** Column index to ensure visible (by forcefully scrolling if necessary) */
        "scrollToColumn": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number).isRequired,

  /** Vertical offset. */
        "scrollTop": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number),

  /** Row index to ensure visible (by forcefully scrolling if necessary) */
        "scrollToRow": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number).isRequired,

  /** Optional inline style */
        "style": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().object).isRequired,

  /** Tab index for focus */
        "tabIndex": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number),

  /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */
        "width": (prop_types__WEBPACK_IMPORTED_MODULE_19___default().number).isRequired
      }), _temp);

      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(Grid, "defaultProps", {
        'aria-label': 'grid',
        'aria-readonly': true,
        autoContainerWidth: false,
        autoHeight: false,
        autoWidth: false,
        cellRangeRenderer: _defaultCellRangeRenderer__WEBPACK_IMPORTED_MODULE_15__["default"],
        containerRole: 'rowgroup',
        containerStyle: {},
        estimatedColumnSize: 100,
        estimatedRowSize: 30,
        getScrollbarSize: dom_helpers_scrollbarSize__WEBPACK_IMPORTED_MODULE_16__["default"],
        noContentRenderer: renderNull,
        onScroll: function onScroll() {},
        onScrollbarPresenceChange: function onScrollbarPresenceChange() {},
        onSectionRendered: function onSectionRendered() {},
        overscanColumnCount: 0,
        overscanIndicesGetter: _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_13__["default"],
        overscanRowCount: 10,
        role: 'grid',
        scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,
        scrollToAlignment: 'auto',
        scrollToColumn: -1,
        scrollToRow: -1,
        style: {},
        tabIndex: 0,
        isScrollingOptOut: false
      });

      (0,react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_17__.polyfill)(Grid);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Grid);
















/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Grid/accessibilityOverscanIndicesGetter.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Grid/accessibilityOverscanIndicesGetter.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SCROLL_DIRECTION_BACKWARD: () => (/* binding */ SCROLL_DIRECTION_BACKWARD),
/* harmony export */   SCROLL_DIRECTION_FORWARD: () => (/* binding */ SCROLL_DIRECTION_FORWARD),
/* harmony export */   SCROLL_DIRECTION_HORIZONTAL: () => (/* binding */ SCROLL_DIRECTION_HORIZONTAL),
/* harmony export */   SCROLL_DIRECTION_VERTICAL: () => (/* binding */ SCROLL_DIRECTION_VERTICAL),
/* harmony export */   "default": () => (/* binding */ defaultOverscanIndicesGetter)
/* harmony export */ });
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/Grid/types.js");
      var SCROLL_DIRECTION_BACKWARD = -1;
      var SCROLL_DIRECTION_FORWARD = 1;
      var SCROLL_DIRECTION_HORIZONTAL = 'horizontal';
      var SCROLL_DIRECTION_VERTICAL = 'vertical';
/**
 * Calculates the number of cells to overscan before and after a specified range.
 * This function ensures that overscanning doesn't exceed the available cells.
 */

      function defaultOverscanIndicesGetter(_ref) {
        let cellCount = _ref.cellCount,
          overscanCellsCount = _ref.overscanCellsCount,
          scrollDirection = _ref.scrollDirection,
          startIndex = _ref.startIndex,
          stopIndex = _ref.stopIndex;
  // Make sure we render at least 1 cell extra before and after (except near boundaries)
  // This is necessary in order to support keyboard navigation (TAB/SHIFT+TAB) in some cases
  // For more info see issues #625
        overscanCellsCount = Math.max(1, overscanCellsCount);

        if (scrollDirection === SCROLL_DIRECTION_FORWARD) {
          return {
            overscanStartIndex: Math.max(0, startIndex - 1),
            overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
          };
        } else {
          return {
            overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
            overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)
          };
        }
      }



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Grid/defaultCellRangeRenderer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Grid/defaultCellRangeRenderer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultCellRangeRenderer)
/* harmony export */ });
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/Grid/types.js");
/**
 * Default implementation of cellRangeRenderer used by Grid.
 * This renderer supports cell-caching while the user is scrolling.
 */
      function defaultCellRangeRenderer(_ref) {
        const cellCache = _ref.cellCache,
          cellRenderer = _ref.cellRenderer,
          columnSizeAndPositionManager = _ref.columnSizeAndPositionManager,
          columnStartIndex = _ref.columnStartIndex,
          columnStopIndex = _ref.columnStopIndex,
          deferredMeasurementCache = _ref.deferredMeasurementCache,
          horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment,
          isScrolling = _ref.isScrolling,
          isScrollingOptOut = _ref.isScrollingOptOut,
          parent = _ref.parent,
          rowSizeAndPositionManager = _ref.rowSizeAndPositionManager,
          rowStartIndex = _ref.rowStartIndex,
          rowStopIndex = _ref.rowStopIndex,
          styleCache = _ref.styleCache,
          verticalOffsetAdjustment = _ref.verticalOffsetAdjustment,
          visibleColumnIndices = _ref.visibleColumnIndices,
          visibleRowIndices = _ref.visibleRowIndices;
        const renderedCells = []; // Browsers have native size limits for elements (eg Chrome 33M pixels, IE 1.5M pixes).
  // User cannot scroll beyond these size limitations.
  // In order to work around this, ScalingCellSizeAndPositionManager compresses offsets.
  // We should never cache styles for compressed offsets though as this can lead to bugs.
  // See issue #576 for more.

        const areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted();
        const canCacheStyle = !isScrolling && !areOffsetsAdjusted;

        for (let rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {
          const rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);

          for (let columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
            const columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex);
            const isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;
            const key = "".concat(rowIndex, "-").concat(columnIndex);
            let style = void 0; // Cache style objects so shallow-compare doesn't re-render unnecessarily.

            if (canCacheStyle && styleCache[key]) {
              style = styleCache[key];
            } else {
        // In deferred mode, cells will be initially rendered before we know their size.
        // Don't interfere with CellMeasurer's measurements by setting an invalid size.
              if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {
          // Position not-yet-measured cells at top/left 0,0,
          // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.
          // Positioning them further to the right/bottom influences their measured size.
                style = {
                  height: 'auto',
                  left: 0,
                  position: 'absolute',
                  top: 0,
                  width: 'auto'
                };
              } else {
                style = {
                  height: rowDatum.size,
                  left: columnDatum.offset + horizontalOffsetAdjustment,
                  position: 'absolute',
                  top: rowDatum.offset + verticalOffsetAdjustment,
                  width: columnDatum.size
                };
                styleCache[key] = style;
              }
            }

            const cellRendererParams = {
              columnIndex: columnIndex,
              isScrolling: isScrolling,
              isVisible: isVisible,
              key: key,
              parent: parent,
              rowIndex: rowIndex,
              style: style
            };
            let renderedCell = void 0; // Avoid re-creating cells while scrolling.
      // This can lead to the same cell being created many times and can cause performance issues for "heavy" cells.
      // If a scroll is in progress- cache and reuse cells.
      // This cache will be thrown away once scrolling completes.
      // However if we are scaling scroll positions and sizes, we should also avoid caching.
      // This is because the offset changes slightly as scroll position changes and caching leads to stale values.
      // For more info refer to issue #395
      //
      // If isScrollingOptOut is specified, we always cache cells.
      // For more info refer to issue #1028

            if ((isScrollingOptOut || isScrolling) && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {
              if (!cellCache[key]) {
                cellCache[key] = cellRenderer(cellRendererParams);
              }

              renderedCell = cellCache[key]; // If the user is no longer scrolling, don't cache cells.
        // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.
            } else {
              renderedCell = cellRenderer(cellRendererParams);
            }

            if (renderedCell == null || renderedCell === false) {
              continue;
            }

            if (true) {
              warnAboutMissingStyle(parent, renderedCell);
            }

            renderedCells.push(renderedCell);
          }
        }

        return renderedCells;
      }

      function warnAboutMissingStyle(parent, renderedCell) {
        if (true) {
          if (renderedCell) {
      // If the direct child is a CellMeasurer, then we should check its child
      // See issue #611
            if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {
              renderedCell = renderedCell.props.children;
            }

            if (renderedCell && renderedCell.props && renderedCell.props.style === undefined && parent.__warnedAboutMissingStyle !== true) {
              parent.__warnedAboutMissingStyle = true;
              console.warn('Rendered cell should include style property for positioning.');
            }
          }
        }
      }



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Grid/defaultOverscanIndicesGetter.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Grid/defaultOverscanIndicesGetter.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SCROLL_DIRECTION_BACKWARD: () => (/* binding */ SCROLL_DIRECTION_BACKWARD),
/* harmony export */   SCROLL_DIRECTION_FORWARD: () => (/* binding */ SCROLL_DIRECTION_FORWARD),
/* harmony export */   SCROLL_DIRECTION_HORIZONTAL: () => (/* binding */ SCROLL_DIRECTION_HORIZONTAL),
/* harmony export */   SCROLL_DIRECTION_VERTICAL: () => (/* binding */ SCROLL_DIRECTION_VERTICAL),
/* harmony export */   "default": () => (/* binding */ defaultOverscanIndicesGetter)
/* harmony export */ });
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/Grid/types.js");
      var SCROLL_DIRECTION_BACKWARD = -1;
      var SCROLL_DIRECTION_FORWARD = 1;
      var SCROLL_DIRECTION_HORIZONTAL = 'horizontal';
      var SCROLL_DIRECTION_VERTICAL = 'vertical';
/**
 * Calculates the number of cells to overscan before and after a specified range.
 * This function ensures that overscanning doesn't exceed the available cells.
 */

      function defaultOverscanIndicesGetter(_ref) {
        const cellCount = _ref.cellCount,
          overscanCellsCount = _ref.overscanCellsCount,
          scrollDirection = _ref.scrollDirection,
          startIndex = _ref.startIndex,
          stopIndex = _ref.stopIndex;

        if (scrollDirection === SCROLL_DIRECTION_FORWARD) {
          return {
            overscanStartIndex: Math.max(0, startIndex),
            overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
          };
        } else {
          return {
            overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
            overscanStopIndex: Math.min(cellCount - 1, stopIndex)
          };
        }
      }



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Grid/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Grid/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Grid: () => (/* reexport safe */ _Grid__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   accessibilityOverscanIndicesGetter: () => (/* reexport safe */ _accessibilityOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   bpfrpt_proptype_Alignment: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_4__.bpfrpt_proptype_Alignment),
/* harmony export */   bpfrpt_proptype_CellPosition: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_4__.bpfrpt_proptype_CellPosition),
/* harmony export */   bpfrpt_proptype_CellRendererParams: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_4__.bpfrpt_proptype_CellRendererParams),
/* harmony export */   bpfrpt_proptype_CellSize: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_4__.bpfrpt_proptype_CellSize),
/* harmony export */   bpfrpt_proptype_NoContentRenderer: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_4__.bpfrpt_proptype_NoContentRenderer),
/* harmony export */   bpfrpt_proptype_OverscanIndicesGetter: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_4__.bpfrpt_proptype_OverscanIndicesGetter),
/* harmony export */   bpfrpt_proptype_RenderedSection: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_4__.bpfrpt_proptype_RenderedSection),
/* harmony export */   bpfrpt_proptype_Scroll: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_4__.bpfrpt_proptype_Scroll),
/* harmony export */   "default": () => (/* reexport safe */ _Grid__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   defaultCellRangeRenderer: () => (/* reexport safe */ _defaultCellRangeRenderer__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   defaultOverscanIndicesGetter: () => (/* reexport safe */ _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_3__["default"])
/* harmony export */ });
/* harmony import */ var _Grid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Grid */ "./node_modules/react-virtualized/dist/es/Grid/Grid.js");
/* harmony import */ var _accessibilityOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./accessibilityOverscanIndicesGetter */ "./node_modules/react-virtualized/dist/es/Grid/accessibilityOverscanIndicesGetter.js");
/* harmony import */ var _defaultCellRangeRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaultCellRangeRenderer */ "./node_modules/react-virtualized/dist/es/Grid/defaultCellRangeRenderer.js");
/* harmony import */ var _defaultOverscanIndicesGetter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaultOverscanIndicesGetter */ "./node_modules/react-virtualized/dist/es/Grid/defaultOverscanIndicesGetter.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/Grid/types.js");






















/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Grid/types.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Grid/types.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bpfrpt_proptype_Alignment: () => (/* binding */ bpfrpt_proptype_Alignment),
/* harmony export */   bpfrpt_proptype_CellCache: () => (/* binding */ bpfrpt_proptype_CellCache),
/* harmony export */   bpfrpt_proptype_CellPosition: () => (/* binding */ bpfrpt_proptype_CellPosition),
/* harmony export */   bpfrpt_proptype_CellRangeRenderer: () => (/* binding */ bpfrpt_proptype_CellRangeRenderer),
/* harmony export */   bpfrpt_proptype_CellRangeRendererParams: () => (/* binding */ bpfrpt_proptype_CellRangeRendererParams),
/* harmony export */   bpfrpt_proptype_CellRenderer: () => (/* binding */ bpfrpt_proptype_CellRenderer),
/* harmony export */   bpfrpt_proptype_CellRendererParams: () => (/* binding */ bpfrpt_proptype_CellRendererParams),
/* harmony export */   bpfrpt_proptype_CellSize: () => (/* binding */ bpfrpt_proptype_CellSize),
/* harmony export */   bpfrpt_proptype_CellSizeGetter: () => (/* binding */ bpfrpt_proptype_CellSizeGetter),
/* harmony export */   bpfrpt_proptype_NoContentRenderer: () => (/* binding */ bpfrpt_proptype_NoContentRenderer),
/* harmony export */   bpfrpt_proptype_OverscanIndices: () => (/* binding */ bpfrpt_proptype_OverscanIndices),
/* harmony export */   bpfrpt_proptype_OverscanIndicesGetter: () => (/* binding */ bpfrpt_proptype_OverscanIndicesGetter),
/* harmony export */   bpfrpt_proptype_OverscanIndicesGetterParams: () => (/* binding */ bpfrpt_proptype_OverscanIndicesGetterParams),
/* harmony export */   bpfrpt_proptype_RenderedSection: () => (/* binding */ bpfrpt_proptype_RenderedSection),
/* harmony export */   bpfrpt_proptype_Scroll: () => (/* binding */ bpfrpt_proptype_Scroll),
/* harmony export */   bpfrpt_proptype_ScrollbarPresenceChange: () => (/* binding */ bpfrpt_proptype_ScrollbarPresenceChange),
/* harmony export */   bpfrpt_proptype_StyleCache: () => (/* binding */ bpfrpt_proptype_StyleCache),
/* harmony export */   bpfrpt_proptype_VisibleCellRange: () => (/* binding */ bpfrpt_proptype_VisibleCellRange)
/* harmony export */ });
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _utils_ScalingCellSizeAndPositionManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/ScalingCellSizeAndPositionManager */ "./node_modules/react-virtualized/dist/es/Grid/utils/ScalingCellSizeAndPositionManager.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);


      var bpfrpt_proptype_CellPosition =  false ? 0 : {
        "columnIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "rowIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired
      };
      var bpfrpt_proptype_CellRendererParams =  false ? 0 : {
        "columnIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "isScrolling": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool).isRequired,
        "isVisible": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool).isRequired,
        "key": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string).isRequired,
        "parent": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object).isRequired,
        "rowIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "style": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object).isRequired
      };
      var bpfrpt_proptype_CellRenderer =  false ? 0 : (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func);
      var bpfrpt_proptype_CellCache =  false ? 0 : prop_types__WEBPACK_IMPORTED_MODULE_2___default().objectOf((prop_types__WEBPACK_IMPORTED_MODULE_2___default().node).isRequired);
      var bpfrpt_proptype_StyleCache =  false ? 0 : prop_types__WEBPACK_IMPORTED_MODULE_2___default().objectOf((prop_types__WEBPACK_IMPORTED_MODULE_2___default().object).isRequired);
      var bpfrpt_proptype_CellRangeRendererParams =  false ? 0 : {
        "cellCache": prop_types__WEBPACK_IMPORTED_MODULE_2___default().objectOf((prop_types__WEBPACK_IMPORTED_MODULE_2___default().node).isRequired).isRequired,
        "cellRenderer": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func).isRequired,
        "columnSizeAndPositionManager": function columnSizeAndPositionManager() {
          return (typeof _utils_ScalingCellSizeAndPositionManager__WEBPACK_IMPORTED_MODULE_1__["default"] === "function" ? prop_types__WEBPACK_IMPORTED_MODULE_2___default().instanceOf(_utils_ScalingCellSizeAndPositionManager__WEBPACK_IMPORTED_MODULE_1__["default"]).isRequired : (prop_types__WEBPACK_IMPORTED_MODULE_2___default().any).isRequired).apply(this, arguments);
        },
        "columnStartIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "columnStopIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "deferredMeasurementCache": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object),
        "horizontalOffsetAdjustment": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "isScrolling": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool).isRequired,
        "isScrollingOptOut": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool).isRequired,
        "parent": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object).isRequired,
        "rowSizeAndPositionManager": function rowSizeAndPositionManager() {
          return (typeof _utils_ScalingCellSizeAndPositionManager__WEBPACK_IMPORTED_MODULE_1__["default"] === "function" ? prop_types__WEBPACK_IMPORTED_MODULE_2___default().instanceOf(_utils_ScalingCellSizeAndPositionManager__WEBPACK_IMPORTED_MODULE_1__["default"]).isRequired : (prop_types__WEBPACK_IMPORTED_MODULE_2___default().any).isRequired).apply(this, arguments);
        },
        "rowStartIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "rowStopIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "scrollLeft": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "scrollTop": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "styleCache": prop_types__WEBPACK_IMPORTED_MODULE_2___default().objectOf((prop_types__WEBPACK_IMPORTED_MODULE_2___default().object).isRequired).isRequired,
        "verticalOffsetAdjustment": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "visibleColumnIndices": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object).isRequired,
        "visibleRowIndices": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object).isRequired
      };
      var bpfrpt_proptype_CellRangeRenderer =  false ? 0 : (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func);
      var bpfrpt_proptype_CellSizeGetter =  false ? 0 : (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func);
      var bpfrpt_proptype_CellSize =  false ? 0 : prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number)]);
      var bpfrpt_proptype_NoContentRenderer =  false ? 0 : (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func);
      var bpfrpt_proptype_Scroll =  false ? 0 : {
        "clientHeight": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "clientWidth": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "scrollHeight": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "scrollLeft": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "scrollTop": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "scrollWidth": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired
      };
      var bpfrpt_proptype_ScrollbarPresenceChange =  false ? 0 : {
        "horizontal": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool).isRequired,
        "vertical": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool).isRequired,
        "size": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired
      };
      var bpfrpt_proptype_RenderedSection =  false ? 0 : {
        "columnOverscanStartIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "columnOverscanStopIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "columnStartIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "columnStopIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "rowOverscanStartIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "rowOverscanStopIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "rowStartIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "rowStopIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired
      };
      var bpfrpt_proptype_OverscanIndicesGetterParams =  false ? 0 : {
  // One of SCROLL_DIRECTION_HORIZONTAL or SCROLL_DIRECTION_VERTICAL
        "direction": prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOf(["horizontal", "vertical"]).isRequired,
  // One of SCROLL_DIRECTION_BACKWARD or SCROLL_DIRECTION_FORWARD
        "scrollDirection": prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOf([-1, 1]).isRequired,
  // Number of rows or columns in the current axis
        "cellCount": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
  // Maximum number of cells to over-render in either direction
        "overscanCellsCount": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
  // Begin of range of visible cells
        "startIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
  // End of range of visible cells
        "stopIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired
      };
      var bpfrpt_proptype_OverscanIndices =  false ? 0 : {
        "overscanStartIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired,
        "overscanStopIndex": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number).isRequired
      };
      var bpfrpt_proptype_OverscanIndicesGetter =  false ? 0 : (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func);
      var bpfrpt_proptype_Alignment =  false ? 0 : prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOf(["auto", "end", "start", "center"]);
      var bpfrpt_proptype_VisibleCellRange =  false ? 0 : {
        "start": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),
        "stop": (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number)
      };




















/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Grid/utils/CellSizeAndPositionManager.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Grid/utils/CellSizeAndPositionManager.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CellSizeAndPositionManager)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types */ "./node_modules/react-virtualized/dist/es/Grid/types.js");




/**
 * Just-in-time calculates and caches size and position information for a collection of cells.
 */
      var CellSizeAndPositionManager =
/*#__PURE__*/
function () {
  // Cache of size and position data for cells, mapped by cell index.
  // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex
  // Measurements for cells up to this index can be trusted; cells afterward should be estimated.
  // Used in deferred mode to track which cells have been queued for measurement.
  function CellSizeAndPositionManager(_ref) {
    const cellCount = _ref.cellCount,
      cellSizeGetter = _ref.cellSizeGetter,
      estimatedCellSize = _ref.estimatedCellSize;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, CellSizeAndPositionManager);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_cellSizeAndPositionData", {});

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_lastMeasuredIndex", -1);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_lastBatchedIndex", -1);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_cellCount", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_cellSizeGetter", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_estimatedCellSize", void 0);

    this._cellSizeGetter = cellSizeGetter;
    this._cellCount = cellCount;
    this._estimatedCellSize = estimatedCellSize;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(CellSizeAndPositionManager, [{
    key: "areOffsetsAdjusted",
    value: function areOffsetsAdjusted() {
      return false;
    }
  }, {
    key: "configure",
    value: function configure(_ref2) {
      const cellCount = _ref2.cellCount,
        estimatedCellSize = _ref2.estimatedCellSize,
        cellSizeGetter = _ref2.cellSizeGetter;
      this._cellCount = cellCount;
      this._estimatedCellSize = estimatedCellSize;
      this._cellSizeGetter = cellSizeGetter;
    }
  }, {
    key: "getCellCount",
    value: function getCellCount() {
      return this._cellCount;
    }
  }, {
    key: "getEstimatedCellSize",
    value: function getEstimatedCellSize() {
      return this._estimatedCellSize;
    }
  }, {
    key: "getLastMeasuredIndex",
    value: function getLastMeasuredIndex() {
      return this._lastMeasuredIndex;
    }
  }, {
    key: "getOffsetAdjustment",
    value: function getOffsetAdjustment() {
      return 0;
    }
    /**
     * This method returns the size and position for the cell at the specified index.
     * It just-in-time calculates (or used cached values) for cells leading up to the index.
     */

  }, {
    key: "getSizeAndPositionOfCell",
    value: function getSizeAndPositionOfCell(index) {
      if (index < 0 || index >= this._cellCount) {
        throw Error("Requested index ".concat(index, " is outside of range 0..").concat(this._cellCount));
      }

      if (index > this._lastMeasuredIndex) {
        const lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
        let offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;

        for (let i = this._lastMeasuredIndex + 1; i <= index; i++) {
          const size = this._cellSizeGetter({
            index: i
          }); // undefined or NaN probably means a logic error in the size getter.
          // null means we're using CellMeasurer and haven't yet measured a given index.


          if (size === undefined || isNaN(size)) {
            throw Error("Invalid size returned for cell ".concat(i, " of value ").concat(size));
          } else if (size === null) {
            this._cellSizeAndPositionData[i] = {
              offset: offset,
              size: 0
            };
            this._lastBatchedIndex = index;
          } else {
            this._cellSizeAndPositionData[i] = {
              offset: offset,
              size: size
            };
            offset += size;
            this._lastMeasuredIndex = index;
          }
        }
      }

      return this._cellSizeAndPositionData[index];
    }
  }, {
    key: "getSizeAndPositionOfLastMeasuredCell",
    value: function getSizeAndPositionOfLastMeasuredCell() {
      return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {
        offset: 0,
        size: 0
      };
    }
    /**
     * Total size of all cells being measured.
     * This value will be completely estimated initially.
     * As cells are measured, the estimate will be updated.
     */

  }, {
    key: "getTotalSize",
    value: function getTotalSize() {
      const lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
      const totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;
      const numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1;
      const totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;
      return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;
    }
    /**
     * Determines a new offset that ensures a certain cell is visible, given the current offset.
     * If the cell is already visible then the current offset will be returned.
     * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.
     *
     * @param align Desired alignment within container; one of "auto" (default), "start", or "end"
     * @param containerSize Size (width or height) of the container viewport
     * @param currentOffset Container's current (x or y) offset
     * @param totalSize Total size (width or height) of all cells
     * @return Offset to use to ensure the specified cell is visible
     */

  }, {
    key: "getUpdatedOffsetForIndex",
    value: function getUpdatedOffsetForIndex(_ref3) {
      const _ref3$align = _ref3.align,
        align = _ref3$align === void 0 ? 'auto' : _ref3$align,
        containerSize = _ref3.containerSize,
        currentOffset = _ref3.currentOffset,
        targetIndex = _ref3.targetIndex;

      if (containerSize <= 0) {
        return 0;
      }

      const datum = this.getSizeAndPositionOfCell(targetIndex);
      const maxOffset = datum.offset;
      const minOffset = maxOffset - containerSize + datum.size;
      let idealOffset;

      switch (align) {
        case 'start':
          idealOffset = maxOffset;
          break;

        case 'end':
          idealOffset = minOffset;
          break;

        case 'center':
          idealOffset = maxOffset - (containerSize - datum.size) / 2;
          break;

        default:
          idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));
          break;
      }

      const totalSize = this.getTotalSize();
      return Math.max(0, Math.min(totalSize - containerSize, idealOffset));
    }
  }, {
    key: "getVisibleCellRange",
    value: function getVisibleCellRange(params) {
      let containerSize = params.containerSize,
        offset = params.offset;
      const totalSize = this.getTotalSize();

      if (totalSize === 0) {
        return {};
      }

      const maxOffset = offset + containerSize;

      const start = this._findNearestCell(offset);

      const datum = this.getSizeAndPositionOfCell(start);
      offset = datum.offset + datum.size;
      let stop = start;

      while (offset < maxOffset && stop < this._cellCount - 1) {
        stop++;
        offset += this.getSizeAndPositionOfCell(stop).size;
      }

      return {
        start: start,
        stop: stop
      };
    }
    /**
     * Clear all cached values for cells after the specified index.
     * This method should be called for any cell that has changed its size.
     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.
     */

  }, {
    key: "resetCell",
    value: function resetCell(index) {
      this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);
    }
  }, {
    key: "_binarySearch",
    value: function _binarySearch(high, low, offset) {
      while (low <= high) {
        const middle = low + Math.floor((high - low) / 2);
        const currentOffset = this.getSizeAndPositionOfCell(middle).offset;

        if (currentOffset === offset) {
          return middle;
        } else if (currentOffset < offset) {
          low = middle + 1;
        } else if (currentOffset > offset) {
          high = middle - 1;
        }
      }

      if (low > 0) {
        return low - 1;
      } else {
        return 0;
      }
    }
  }, {
    key: "_exponentialSearch",
    value: function _exponentialSearch(index, offset) {
      let interval = 1;

      while (index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset) {
        index += interval;
        interval *= 2;
      }

      return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);
    }
    /**
     * Searches for the cell (index) nearest the specified offset.
     *
     * If no exact match is found the next lowest cell index will be returned.
     * This allows partially visible cells (with offsets just before/above the fold) to be visible.
     */

  }, {
    key: "_findNearestCell",
    value: function _findNearestCell(offset) {
      if (isNaN(offset)) {
        throw Error("Invalid offset ".concat(offset, " specified"));
      } // Our search algorithms find the nearest match at or below the specified offset.
      // So make sure the offset is at least 0 or no match will be found.


      offset = Math.max(0, offset);
      const lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
      const lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);

      if (lastMeasuredCellSizeAndPosition.offset >= offset) {
        // If we've already measured cells within this range just use a binary search as it's faster.
        return this._binarySearch(lastMeasuredIndex, 0, offset);
      } else {
        // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.
        // The exponential search avoids pre-computing sizes for the full set of cells as a binary search would.
        // The overall complexity for this approach is O(log n).
        return this._exponentialSearch(lastMeasuredIndex, offset);
      }
    }
  }]);

  return CellSizeAndPositionManager;
}();






/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Grid/utils/ScalingCellSizeAndPositionManager.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Grid/utils/ScalingCellSizeAndPositionManager.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ScalingCellSizeAndPositionManager)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/objectWithoutProperties/index.js");
/* harmony import */ const _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _CellSizeAndPositionManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CellSizeAndPositionManager */ "./node_modules/react-virtualized/dist/es/Grid/utils/CellSizeAndPositionManager.js");
/* harmony import */ const _maxElementSize_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./maxElementSize.js */ "./node_modules/react-virtualized/dist/es/Grid/utils/maxElementSize.js");
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../types */ "./node_modules/react-virtualized/dist/es/Grid/types.js");







/**
 * Extends CellSizeAndPositionManager and adds scaling behavior for lists that are too large to fit within a browser's native limits.
 */
      var ScalingCellSizeAndPositionManager =
/*#__PURE__*/
function () {
  function ScalingCellSizeAndPositionManager(_ref) {
    const _ref$maxScrollSize = _ref.maxScrollSize,
      maxScrollSize = _ref$maxScrollSize === void 0 ? (0,_maxElementSize_js__WEBPACK_IMPORTED_MODULE_5__.getMaxElementSize)() : _ref$maxScrollSize,
      params = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default()(_ref, ["maxScrollSize"]);

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, ScalingCellSizeAndPositionManager);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "_cellSizeAndPositionManager", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "_maxScrollSize", void 0);

    // Favor composition over inheritance to simplify IE10 support
    this._cellSizeAndPositionManager = new _CellSizeAndPositionManager__WEBPACK_IMPORTED_MODULE_4__["default"](params);
    this._maxScrollSize = maxScrollSize;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(ScalingCellSizeAndPositionManager, [{
    key: "areOffsetsAdjusted",
    value: function areOffsetsAdjusted() {
      return this._cellSizeAndPositionManager.getTotalSize() > this._maxScrollSize;
    }
  }, {
    key: "configure",
    value: function configure(params) {
      this._cellSizeAndPositionManager.configure(params);
    }
  }, {
    key: "getCellCount",
    value: function getCellCount() {
      return this._cellSizeAndPositionManager.getCellCount();
    }
  }, {
    key: "getEstimatedCellSize",
    value: function getEstimatedCellSize() {
      return this._cellSizeAndPositionManager.getEstimatedCellSize();
    }
  }, {
    key: "getLastMeasuredIndex",
    value: function getLastMeasuredIndex() {
      return this._cellSizeAndPositionManager.getLastMeasuredIndex();
    }
    /**
     * Number of pixels a cell at the given position (offset) should be shifted in order to fit within the scaled container.
     * The offset passed to this function is scaled (safe) as well.
     */

  }, {
    key: "getOffsetAdjustment",
    value: function getOffsetAdjustment(_ref2) {
      const containerSize = _ref2.containerSize,
        offset = _ref2.offset;

      const totalSize = this._cellSizeAndPositionManager.getTotalSize();

      const safeTotalSize = this.getTotalSize();

      const offsetPercentage = this._getOffsetPercentage({
        containerSize: containerSize,
        offset: offset,
        totalSize: safeTotalSize
      });

      return Math.round(offsetPercentage * (safeTotalSize - totalSize));
    }
  }, {
    key: "getSizeAndPositionOfCell",
    value: function getSizeAndPositionOfCell(index) {
      return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(index);
    }
  }, {
    key: "getSizeAndPositionOfLastMeasuredCell",
    value: function getSizeAndPositionOfLastMeasuredCell() {
      return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell();
    }
    /** See CellSizeAndPositionManager#getTotalSize */

  }, {
    key: "getTotalSize",
    value: function getTotalSize() {
      return Math.min(this._maxScrollSize, this._cellSizeAndPositionManager.getTotalSize());
    }
    /** See CellSizeAndPositionManager#getUpdatedOffsetForIndex */

  }, {
    key: "getUpdatedOffsetForIndex",
    value: function getUpdatedOffsetForIndex(_ref3) {
      let _ref3$align = _ref3.align,
        align = _ref3$align === void 0 ? 'auto' : _ref3$align,
        containerSize = _ref3.containerSize,
        currentOffset = _ref3.currentOffset,
        targetIndex = _ref3.targetIndex;
      currentOffset = this._safeOffsetToOffset({
        containerSize: containerSize,
        offset: currentOffset
      });

      const offset = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({
        align: align,
        containerSize: containerSize,
        currentOffset: currentOffset,
        targetIndex: targetIndex
      });

      return this._offsetToSafeOffset({
        containerSize: containerSize,
        offset: offset
      });
    }
    /** See CellSizeAndPositionManager#getVisibleCellRange */

  }, {
    key: "getVisibleCellRange",
    value: function getVisibleCellRange(_ref4) {
      let containerSize = _ref4.containerSize,
        offset = _ref4.offset;
      offset = this._safeOffsetToOffset({
        containerSize: containerSize,
        offset: offset
      });
      return this._cellSizeAndPositionManager.getVisibleCellRange({
        containerSize: containerSize,
        offset: offset
      });
    }
  }, {
    key: "resetCell",
    value: function resetCell(index) {
      this._cellSizeAndPositionManager.resetCell(index);
    }
  }, {
    key: "_getOffsetPercentage",
    value: function _getOffsetPercentage(_ref5) {
      const containerSize = _ref5.containerSize,
        offset = _ref5.offset,
        totalSize = _ref5.totalSize;
      return totalSize <= containerSize ? 0 : offset / (totalSize - containerSize);
    }
  }, {
    key: "_offsetToSafeOffset",
    value: function _offsetToSafeOffset(_ref6) {
      const containerSize = _ref6.containerSize,
        offset = _ref6.offset;

      const totalSize = this._cellSizeAndPositionManager.getTotalSize();

      const safeTotalSize = this.getTotalSize();

      if (totalSize === safeTotalSize) {
        return offset;
      } else {
        const offsetPercentage = this._getOffsetPercentage({
          containerSize: containerSize,
          offset: offset,
          totalSize: totalSize
        });

        return Math.round(offsetPercentage * (safeTotalSize - containerSize));
      }
    }
  }, {
    key: "_safeOffsetToOffset",
    value: function _safeOffsetToOffset(_ref7) {
      const containerSize = _ref7.containerSize,
        offset = _ref7.offset;

      const totalSize = this._cellSizeAndPositionManager.getTotalSize();

      const safeTotalSize = this.getTotalSize();

      if (totalSize === safeTotalSize) {
        return offset;
      } else {
        const offsetPercentage = this._getOffsetPercentage({
          containerSize: containerSize,
          offset: offset,
          totalSize: safeTotalSize
        });

        return Math.round(offsetPercentage * (totalSize - containerSize));
      }
    }
  }]);

  return ScalingCellSizeAndPositionManager;
}();






/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ calculateSizeAndPositionDataAndUpdateScrollOffset)
/* harmony export */ });
/**
 * Helper method that determines when to recalculate row or column metadata.
 */
      function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {
        const cellCount = _ref.cellCount,
          cellSize = _ref.cellSize,
          computeMetadataCallback = _ref.computeMetadataCallback,
          computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,
          nextCellsCount = _ref.nextCellsCount,
          nextCellSize = _ref.nextCellSize,
          nextScrollToIndex = _ref.nextScrollToIndex,
          scrollToIndex = _ref.scrollToIndex,
          updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;

  // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.
  // In that event users should use the manual recompute methods to inform of changes.
        if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {
          computeMetadataCallback(computeMetadataCallbackProps); // Updated cell metadata may have hidden the previous scrolled-to item.
    // In this case we should also update the scrollTop to ensure it stays visible.

          if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {
            updateScrollOffsetForScrollToIndex();
          }
        }
      }

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Grid/utils/maxElementSize.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Grid/utils/maxElementSize.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getMaxElementSize: () => (/* binding */ getMaxElementSize)
/* harmony export */ });
      const DEFAULT_MAX_ELEMENT_SIZE = 1500000;
      const CHROME_MAX_ELEMENT_SIZE = 1.67771e7;

      const isBrowser = function isBrowser() {
        return typeof window !== 'undefined';
      };

      const isChrome = function isChrome() {
        return !!window.chrome;
      };

      var getMaxElementSize = function getMaxElementSize() {
        if (isBrowser()) {
          if (isChrome()) {
            return CHROME_MAX_ELEMENT_SIZE;
          }
        }

        return DEFAULT_MAX_ELEMENT_SIZE;
      };

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Grid/utils/updateScrollIndexHelper.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Grid/utils/updateScrollIndexHelper.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateScrollIndexHelper)
/* harmony export */ });
/* harmony import */ const _ScalingCellSizeAndPositionManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ScalingCellSizeAndPositionManager.js */ "./node_modules/react-virtualized/dist/es/Grid/utils/ScalingCellSizeAndPositionManager.js");
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types */ "./node_modules/react-virtualized/dist/es/Grid/types.js");

/**
 * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.
 * This function also ensures that the scroll ofset isn't past the last column/row of cells.
 */

      function updateScrollIndexHelper(_ref) {
        const cellSize = _ref.cellSize,
          cellSizeAndPositionManager = _ref.cellSizeAndPositionManager,
          previousCellsCount = _ref.previousCellsCount,
          previousCellSize = _ref.previousCellSize,
          previousScrollToAlignment = _ref.previousScrollToAlignment,
          previousScrollToIndex = _ref.previousScrollToIndex,
          previousSize = _ref.previousSize,
          scrollOffset = _ref.scrollOffset,
          scrollToAlignment = _ref.scrollToAlignment,
          scrollToIndex = _ref.scrollToIndex,
          size = _ref.size,
          sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero,
          updateScrollIndexCallback = _ref.updateScrollIndexCallback;
        const cellCount = cellSizeAndPositionManager.getCellCount();
        const hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;
        const sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize; // If we have a new scroll target OR if height/row-height has changed,
  // We should ensure that the scroll target is visible.

        if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {
          updateScrollIndexCallback(scrollToIndex); // If we don't have a selected item but list size or number of children have decreased,
    // Make sure we aren't scrolled too far past the current content.
        } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {
    // We need to ensure that the current scroll offset is still within the collection's range.
    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.
    // Just check to make sure we're still okay.
    // Only adjust the scroll position if we've scrolled below the last set of rows.
          if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {
            updateScrollIndexCallback(cellCount - 1);
          }
        }
      }



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/InfiniteLoader/InfiniteLoader.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/InfiniteLoader/InfiniteLoader.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ InfiniteLoader),
/* harmony export */   forceUpdateReactVirtualizedComponent: () => (/* binding */ forceUpdateReactVirtualizedComponent),
/* harmony export */   isRangeVisible: () => (/* binding */ isRangeVisible),
/* harmony export */   scanForUnloadedRanges: () => (/* binding */ scanForUnloadedRanges)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray/index.js");
/* harmony import */ const _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ const _utils_createCallbackMemoizer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/createCallbackMemoizer */ "./node_modules/react-virtualized/dist/es/utils/createCallbackMemoizer.js");











/**
 * Higher-order component that manages lazy-loading for "infinite" data.
 * This component decorates a virtual component and just-in-time prefetches rows as a user scrolls.
 * It is intended as a convenience component; fork it if you'd like finer-grained control over data-loading.
 */

      var InfiniteLoader =
/*#__PURE__*/
function (_React$PureComponent) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default()(InfiniteLoader, _React$PureComponent);

  function InfiniteLoader(props, context) {
    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, InfiniteLoader);

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(InfiniteLoader).call(this, props, context));
    _this._loadMoreRowsMemoizer = (0,_utils_createCallbackMemoizer__WEBPACK_IMPORTED_MODULE_10__["default"])();
    _this._onRowsRendered = _this._onRowsRendered.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this));
    _this._registerChild = _this._registerChild.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this));
    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(InfiniteLoader, [{
    key: "resetLoadMoreRowsCache",
    value: function resetLoadMoreRowsCache(autoReload) {
      this._loadMoreRowsMemoizer = (0,_utils_createCallbackMemoizer__WEBPACK_IMPORTED_MODULE_10__["default"])();

      if (autoReload) {
        this._doStuff(this._lastRenderedStartIndex, this._lastRenderedStopIndex);
      }
    }
  }, {
    key: "render",
    value: function render() {
      const children = this.props.children;
      return children({
        onRowsRendered: this._onRowsRendered,
        registerChild: this._registerChild
      });
    }
  }, {
    key: "_loadUnloadedRanges",
    value: function _loadUnloadedRanges(unloadedRanges) {
      const _this2 = this;

      const loadMoreRows = this.props.loadMoreRows;
      unloadedRanges.forEach(function (unloadedRange) {
        const promise = loadMoreRows(unloadedRange);

        if (promise) {
          promise.then(function () {
            // Refresh the visible rows if any of them have just been loaded.
            // Otherwise they will remain in their unloaded visual state.
            if (isRangeVisible({
              lastRenderedStartIndex: _this2._lastRenderedStartIndex,
              lastRenderedStopIndex: _this2._lastRenderedStopIndex,
              startIndex: unloadedRange.startIndex,
              stopIndex: unloadedRange.stopIndex
            })) {
              if (_this2._registeredChild) {
                forceUpdateReactVirtualizedComponent(_this2._registeredChild, _this2._lastRenderedStartIndex);
              }
            }
          });
        }
      });
    }
  }, {
    key: "_onRowsRendered",
    value: function _onRowsRendered(_ref) {
      const startIndex = _ref.startIndex,
        stopIndex = _ref.stopIndex;
      this._lastRenderedStartIndex = startIndex;
      this._lastRenderedStopIndex = stopIndex;

      this._doStuff(startIndex, stopIndex);
    }
  }, {
    key: "_doStuff",
    value: function _doStuff(startIndex, stopIndex) {
      let _ref2,
        _this3 = this;

      const _this$props = this.props,
        isRowLoaded = _this$props.isRowLoaded,
        minimumBatchSize = _this$props.minimumBatchSize,
        rowCount = _this$props.rowCount,
        threshold = _this$props.threshold;
      const unloadedRanges = scanForUnloadedRanges({
        isRowLoaded: isRowLoaded,
        minimumBatchSize: minimumBatchSize,
        rowCount: rowCount,
        startIndex: Math.max(0, startIndex - threshold),
        stopIndex: Math.min(rowCount - 1, stopIndex + threshold)
      }); // For memoize comparison

      const squashedUnloadedRanges = (_ref2 = []).concat.apply(_ref2, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(unloadedRanges.map(function (_ref3) {
        const startIndex = _ref3.startIndex,
          stopIndex = _ref3.stopIndex;
        return [startIndex, stopIndex];
      })));

      this._loadMoreRowsMemoizer({
        callback: function callback() {
          _this3._loadUnloadedRanges(unloadedRanges);
        },
        indices: {
          squashedUnloadedRanges: squashedUnloadedRanges
        }
      });
    }
  }, {
    key: "_registerChild",
    value: function _registerChild(registeredChild) {
      this._registeredChild = registeredChild;
    }
  }]);

  return InfiniteLoader;
}(react__WEBPACK_IMPORTED_MODULE_8__.PureComponent);
/**
 * Determines if the specified start/stop range is visible based on the most recently rendered range.
 */


      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(InfiniteLoader, "defaultProps", {
        minimumBatchSize: 10,
        rowCount: 0,
        threshold: 15
      });


      InfiniteLoader.propTypes =  true ? {
  /**
   * Function responsible for rendering a virtualized component.
   * This function should implement the following signature:
   * ({ onRowsRendered, registerChild }) => PropTypes.element
   *
   * The specified :onRowsRendered function should be passed through to the child's :onRowsRendered property.
   * The :registerChild callback should be set as the virtualized component's :ref.
   */
        children: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().func).isRequired,

  /**
   * Function responsible for tracking the loaded state of each row.
   * It should implement the following signature: ({ index: number }): boolean
   */
        isRowLoaded: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().func).isRequired,

  /**
   * Callback to be invoked when more rows must be loaded.
   * It should implement the following signature: ({ startIndex, stopIndex }): Promise
   * The returned Promise should be resolved once row data has finished loading.
   * It will be used to determine when to refresh the list with the newly-loaded data.
   * This callback may be called multiple times in reaction to a single scroll event.
   */
        loadMoreRows: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().func).isRequired,

  /**
   * Minimum number of rows to be loaded at a time.
   * This property can be used to batch requests to reduce HTTP requests.
   */
        minimumBatchSize: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number).isRequired,

  /**
   * Number of rows in list; can be arbitrary high number if actual number is unknown.
   */
        rowCount: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number).isRequired,

  /**
   * Threshold at which to pre-fetch data.
   * A threshold X means that data will start loading when a user scrolls within X rows.
   * This value defaults to 15.
   */
        threshold: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number).isRequired
      } : 0;
      function isRangeVisible(_ref4) {
        const lastRenderedStartIndex = _ref4.lastRenderedStartIndex,
          lastRenderedStopIndex = _ref4.lastRenderedStopIndex,
          startIndex = _ref4.startIndex,
          stopIndex = _ref4.stopIndex;
        return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);
      }
/**
 * Returns all of the ranges within a larger range that contain unloaded rows.
 */

      function scanForUnloadedRanges(_ref5) {
        const isRowLoaded = _ref5.isRowLoaded,
          minimumBatchSize = _ref5.minimumBatchSize,
          rowCount = _ref5.rowCount,
          startIndex = _ref5.startIndex,
          stopIndex = _ref5.stopIndex;
        const unloadedRanges = [];
        let rangeStartIndex = null;
        let rangeStopIndex = null;

        for (let index = startIndex; index <= stopIndex; index++) {
          const loaded = isRowLoaded({
            index: index
          });

          if (!loaded) {
            rangeStopIndex = index;

            if (rangeStartIndex === null) {
              rangeStartIndex = index;
            }
          } else if (rangeStopIndex !== null) {
            unloadedRanges.push({
              startIndex: rangeStartIndex,
              stopIndex: rangeStopIndex
            });
            rangeStartIndex = rangeStopIndex = null;
          }
        } // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.
  // Scan forward to try filling our :minimumBatchSize.


        if (rangeStopIndex !== null) {
          const potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), rowCount - 1);

          for (let _index = rangeStopIndex + 1; _index <= potentialStopIndex; _index++) {
            if (!isRowLoaded({
              index: _index
            })) {
              rangeStopIndex = _index;
            } else {
              break;
            }
          }

          unloadedRanges.push({
            startIndex: rangeStartIndex,
            stopIndex: rangeStopIndex
          });
        } // Check to see if our first range ended prematurely.
  // In this case we should scan backwards to try filling our :minimumBatchSize.


        if (unloadedRanges.length) {
          const firstUnloadedRange = unloadedRanges[0];

          while (firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize && firstUnloadedRange.startIndex > 0) {
            const _index2 = firstUnloadedRange.startIndex - 1;

            if (!isRowLoaded({
              index: _index2
            })) {
              firstUnloadedRange.startIndex = _index2;
            } else {
              break;
            }
          }
        }

        return unloadedRanges;
      }
/**
 * Since RV components use shallowCompare we need to force a render (even though props haven't changed).
 * However InfiniteLoader may wrap a Grid or it may wrap a Table or List.
 * In the first case the built-in React forceUpdate() method is sufficient to force a re-render,
 * But in the latter cases we need to use the RV-specific forceUpdateGrid() method.
 * Else the inner Grid will not be re-rendered and visuals may be stale.
 *
 * Additionally, while a Grid is scrolling the cells can be cached,
 * So it's important to invalidate that cache by recalculating sizes
 * before forcing a rerender.
 */

      function forceUpdateReactVirtualizedComponent(component) {
        const currentIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        const recomputeSize = typeof component.recomputeGridSize === 'function' ? component.recomputeGridSize : component.recomputeRowHeights;

        if (recomputeSize) {
          recomputeSize.call(component, currentIndex);
        } else {
          component.forceUpdate();
        }
      }

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/InfiniteLoader/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/InfiniteLoader/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InfiniteLoader: () => (/* reexport safe */ _InfiniteLoader__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _InfiniteLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InfiniteLoader */ "./node_modules/react-virtualized/dist/es/InfiniteLoader/InfiniteLoader.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_InfiniteLoader__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/List/List.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/List/List.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ List)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends/index.js");
/* harmony import */ const _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ const _Grid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Grid */ "./node_modules/react-virtualized/dist/es/Grid/index.js");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ const clsx__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/List/types.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_11__);









      let _class, _temp;




/**
 * It is inefficient to create and manage a large list of DOM elements within a scrolling container
 * if only a few of those elements are visible. The primary purpose of this component is to improve
 * performance by only rendering the DOM nodes that a user is able to see based on their current
 * scroll position.
 *
 * This component renders a virtualized list of elements with either fixed or dynamic heights.
 */

      var List = (_temp = _class =
/*#__PURE__*/
function (_React$PureComponent) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default()(List, _React$PureComponent);

  function List() {
    let _getPrototypeOf2;

    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, List);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, (_getPrototypeOf2 = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(List)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "Grid", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_cellRenderer", function (_ref) {
      const parent = _ref.parent,
        rowIndex = _ref.rowIndex,
        style = _ref.style,
        isScrolling = _ref.isScrolling,
        isVisible = _ref.isVisible,
        key = _ref.key;
      const rowRenderer = _this.props.rowRenderer; // TRICKY The style object is sometimes cached by Grid.
      // This prevents new style objects from bypassing shallowCompare().
      // However as of React 16, style props are auto-frozen (at least in dev mode)
      // Check to make sure we can still modify the style before proceeding.
      // https://github.com/facebook/react/commit/977357765b44af8ff0cfea327866861073095c12#commitcomment-20648713

      const widthDescriptor = Object.getOwnPropertyDescriptor(style, 'width');

      if (widthDescriptor && widthDescriptor.writable) {
        // By default, List cells should be 100% width.
        // This prevents them from flowing under a scrollbar (if present).
        style.width = '100%';
      }

      return rowRenderer({
        index: rowIndex,
        style: style,
        isScrolling: isScrolling,
        isVisible: isVisible,
        key: key,
        parent: parent
      });
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_setRef", function (ref) {
      _this.Grid = ref;
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_onScroll", function (_ref2) {
      const clientHeight = _ref2.clientHeight,
        scrollHeight = _ref2.scrollHeight,
        scrollTop = _ref2.scrollTop;
      const onScroll = _this.props.onScroll;
      onScroll({
        clientHeight: clientHeight,
        scrollHeight: scrollHeight,
        scrollTop: scrollTop
      });
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this), "_onSectionRendered", function (_ref3) {
      const rowOverscanStartIndex = _ref3.rowOverscanStartIndex,
        rowOverscanStopIndex = _ref3.rowOverscanStopIndex,
        rowStartIndex = _ref3.rowStartIndex,
        rowStopIndex = _ref3.rowStopIndex;
      const onRowsRendered = _this.props.onRowsRendered;
      onRowsRendered({
        overscanStartIndex: rowOverscanStartIndex,
        overscanStopIndex: rowOverscanStopIndex,
        startIndex: rowStartIndex,
        stopIndex: rowStopIndex
      });
    });

    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(List, [{
    key: "forceUpdateGrid",
    value: function forceUpdateGrid() {
      if (this.Grid) {
        this.Grid.forceUpdate();
      }
    }
    /** See Grid#getOffsetForCell */

  }, {
    key: "getOffsetForRow",
    value: function getOffsetForRow(_ref4) {
      const alignment = _ref4.alignment,
        index = _ref4.index;

      if (this.Grid) {
        const _this$Grid$getOffsetF = this.Grid.getOffsetForCell({
            alignment: alignment,
            rowIndex: index,
            columnIndex: 0
          }),
          scrollTop = _this$Grid$getOffsetF.scrollTop;

        return scrollTop;
      }

      return 0;
    }
    /** CellMeasurer compatibility */

  }, {
    key: "invalidateCellSizeAfterRender",
    value: function invalidateCellSizeAfterRender(_ref5) {
      const columnIndex = _ref5.columnIndex,
        rowIndex = _ref5.rowIndex;

      if (this.Grid) {
        this.Grid.invalidateCellSizeAfterRender({
          rowIndex: rowIndex,
          columnIndex: columnIndex
        });
      }
    }
    /** See Grid#measureAllCells */

  }, {
    key: "measureAllRows",
    value: function measureAllRows() {
      if (this.Grid) {
        this.Grid.measureAllCells();
      }
    }
    /** CellMeasurer compatibility */

  }, {
    key: "recomputeGridSize",
    value: function recomputeGridSize() {
      const _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref6$columnIndex = _ref6.columnIndex,
        columnIndex = _ref6$columnIndex === void 0 ? 0 : _ref6$columnIndex,
        _ref6$rowIndex = _ref6.rowIndex,
        rowIndex = _ref6$rowIndex === void 0 ? 0 : _ref6$rowIndex;

      if (this.Grid) {
        this.Grid.recomputeGridSize({
          rowIndex: rowIndex,
          columnIndex: columnIndex
        });
      }
    }
    /** See Grid#recomputeGridSize */

  }, {
    key: "recomputeRowHeights",
    value: function recomputeRowHeights() {
      const index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.Grid) {
        this.Grid.recomputeGridSize({
          rowIndex: index,
          columnIndex: 0
        });
      }
    }
    /** See Grid#scrollToPosition */

  }, {
    key: "scrollToPosition",
    value: function scrollToPosition() {
      const scrollTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.Grid) {
        this.Grid.scrollToPosition({
          scrollTop: scrollTop
        });
      }
    }
    /** See Grid#scrollToCell */

  }, {
    key: "scrollToRow",
    value: function scrollToRow() {
      const index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.Grid) {
        this.Grid.scrollToCell({
          columnIndex: 0,
          rowIndex: index
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      const _this$props = this.props,
        className = _this$props.className,
        noRowsRenderer = _this$props.noRowsRenderer,
        scrollToIndex = _this$props.scrollToIndex,
        width = _this$props.width;
      const classNames = (0,clsx__WEBPACK_IMPORTED_MODULE_10__["default"])('ReactVirtualized__List', className);
      return react__WEBPACK_IMPORTED_MODULE_9__.createElement(_Grid__WEBPACK_IMPORTED_MODULE_8__["default"], _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, this.props, {
        autoContainerWidth: true,
        cellRenderer: this._cellRenderer,
        className: classNames,
        columnWidth: width,
        columnCount: 1,
        noContentRenderer: noRowsRenderer,
        onScroll: this._onScroll,
        onSectionRendered: this._onSectionRendered,
        ref: this._setRef,
        scrollToRow: scrollToIndex
      }));
    }
  }]);

  return List;
}(react__WEBPACK_IMPORTED_MODULE_9__.PureComponent), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(_class, "propTypes",  false ? 0 : {
        "aria-label": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().string),

  /**
   * Removes fixed height from the scrollingContainer so that the total height
   * of rows can stretch the window. Intended for use with WindowScroller
   */
        "autoHeight": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().bool).isRequired,

  /** Optional CSS class name */
        "className": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().string),

  /**
   * Used to estimate the total height of a List before all of its rows have actually been measured.
   * The estimated total height is adjusted as rows are rendered.
   */
        "estimatedRowSize": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().number).isRequired,

  /** Height constraint for list (determines how many actual rows are rendered) */
        "height": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().number).isRequired,

  /** Optional renderer to be used in place of rows when rowCount is 0 */
        "noRowsRenderer": function noRowsRenderer() {
          return (typeof _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_NoContentRenderer === "function" ? _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_NoContentRenderer.isRequired ? _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_NoContentRenderer.isRequired : _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_NoContentRenderer : prop_types__WEBPACK_IMPORTED_MODULE_11___default().shape(_Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);
        },

  /** Callback invoked with information about the slice of rows that were just rendered.  */
        "onRowsRendered": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().func).isRequired,

  /**
   * Callback invoked whenever the scroll offset changes within the inner scrollable region.
   * This callback can be used to sync scrolling between lists, tables, or grids.
   */
        "onScroll": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().func).isRequired,

  /** See Grid#overscanIndicesGetter */
        "overscanIndicesGetter": function overscanIndicesGetter() {
          return (typeof _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_OverscanIndicesGetter === "function" ? _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_OverscanIndicesGetter.isRequired ? _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_OverscanIndicesGetter.isRequired : _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_OverscanIndicesGetter : prop_types__WEBPACK_IMPORTED_MODULE_11___default().shape(_Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);
        },

  /**
   * Number of rows to render above/below the visible bounds of the list.
   * These rows can help for smoother scrolling on touch devices.
   */
        "overscanRowCount": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().number).isRequired,

  /** Either a fixed row height (number) or a function that returns the height of a row given its index.  */
        "rowHeight": function rowHeight() {
          return (typeof _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_CellSize === "function" ? _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_CellSize.isRequired ? _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_CellSize.isRequired : _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_CellSize : prop_types__WEBPACK_IMPORTED_MODULE_11___default().shape(_Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);
        },

  /** Responsible for rendering a row given an index; ({ index: number }): node */
        "rowRenderer": function rowRenderer() {
          return (typeof _types__WEBPACK_IMPORTED_MODULE_12__.bpfrpt_proptype_RowRenderer === "function" ? _types__WEBPACK_IMPORTED_MODULE_12__.bpfrpt_proptype_RowRenderer.isRequired ? _types__WEBPACK_IMPORTED_MODULE_12__.bpfrpt_proptype_RowRenderer.isRequired : _types__WEBPACK_IMPORTED_MODULE_12__.bpfrpt_proptype_RowRenderer : prop_types__WEBPACK_IMPORTED_MODULE_11___default().shape(_types__WEBPACK_IMPORTED_MODULE_12__.bpfrpt_proptype_RowRenderer).isRequired).apply(this, arguments);
        },

  /** Number of rows in list. */
        "rowCount": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().number).isRequired,

  /** See Grid#scrollToAlignment */
        "scrollToAlignment": function scrollToAlignment() {
          return (typeof _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_Alignment === "function" ? _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_Alignment.isRequired ? _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_Alignment.isRequired : _Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_Alignment : prop_types__WEBPACK_IMPORTED_MODULE_11___default().shape(_Grid__WEBPACK_IMPORTED_MODULE_8__.bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);
        },

  /** Row index to ensure visible (by forcefully scrolling if necessary) */
        "scrollToIndex": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().number).isRequired,

  /** Vertical offset. */
        "scrollTop": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().number),

  /** Optional inline style */
        "style": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().object).isRequired,

  /** Tab index for focus */
        "tabIndex": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().number),

  /** Width of list */
        "width": (prop_types__WEBPACK_IMPORTED_MODULE_11___default().number).isRequired
      }), _temp);

      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(List, "defaultProps", {
        autoHeight: false,
        estimatedRowSize: 30,
        onScroll: function onScroll() {},
        noRowsRenderer: function noRowsRenderer() {
          return null;
        },
        onRowsRendered: function onRowsRendered() {},
        overscanIndicesGetter: _Grid__WEBPACK_IMPORTED_MODULE_8__.accessibilityOverscanIndicesGetter,
        overscanRowCount: 10,
        scrollToAlignment: 'auto',
        scrollToIndex: -1,
        style: {}
      });















/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/List/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/List/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   List: () => (/* reexport safe */ _List__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   bpfrpt_proptype_RowRendererParams: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_1__.bpfrpt_proptype_RowRendererParams),
/* harmony export */   "default": () => (/* reexport safe */ _List__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./List */ "./node_modules/react-virtualized/dist/es/List/List.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/List/types.js");





/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/List/types.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/List/types.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bpfrpt_proptype_RenderedRows: () => (/* binding */ bpfrpt_proptype_RenderedRows),
/* harmony export */   bpfrpt_proptype_RowRenderer: () => (/* binding */ bpfrpt_proptype_RowRenderer),
/* harmony export */   bpfrpt_proptype_RowRendererParams: () => (/* binding */ bpfrpt_proptype_RowRendererParams),
/* harmony export */   bpfrpt_proptype_Scroll: () => (/* binding */ bpfrpt_proptype_Scroll)
/* harmony export */ });
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);

      var bpfrpt_proptype_RowRendererParams =  false ? 0 : {
        "index": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number).isRequired,
        "isScrolling": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool).isRequired,
        "isVisible": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool).isRequired,
        "key": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string).isRequired,
        "parent": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object).isRequired,
        "style": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object).isRequired
      };
      var bpfrpt_proptype_RowRenderer =  false ? 0 : (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func);
      var bpfrpt_proptype_RenderedRows =  false ? 0 : {
        "overscanStartIndex": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number).isRequired,
        "overscanStopIndex": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number).isRequired,
        "startIndex": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number).isRequired,
        "stopIndex": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number).isRequired
      };
      var bpfrpt_proptype_Scroll =  false ? 0 : {
        "clientHeight": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number).isRequired,
        "scrollHeight": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number).isRequired,
        "scrollTop": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number).isRequired
      };






/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Masonry/Masonry.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Masonry/Masonry.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_SCROLLING_RESET_TIME_INTERVAL: () => (/* binding */ DEFAULT_SCROLLING_RESET_TIME_INTERVAL),
/* harmony export */   bpfrpt_proptype_CellMeasurerCache: () => (/* binding */ bpfrpt_proptype_CellMeasurerCache),
/* harmony export */   bpfrpt_proptype_Positioner: () => (/* binding */ bpfrpt_proptype_Positioner),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const clsx__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ const react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-lifecycles-compat */ "./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js");
/* harmony import */ const _PositionCache__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PositionCache */ "./node_modules/react-virtualized/dist/es/Masonry/PositionCache.js");
/* harmony import */ const _utils_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/requestAnimationTimeout */ "./node_modules/react-virtualized/dist/es/utils/requestAnimationTimeout.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_12__);








      let _class, _temp;

      function ownKeys(object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function _objectSpread(target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






      const emptyObject = {};
/**
 * Specifies the number of miliseconds during which to disable pointer events while a scroll is in progress.
 * This improves performance and makes scrolling smoother.
 */

      var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;
/**
 * This component efficiently displays arbitrarily positioned cells using windowing techniques.
 * Cell position is determined by an injected `cellPositioner` property.
 * Windowing is vertical; this component does not support horizontal scrolling.
 *
 * Rendering occurs in two phases:
 * 1) First pass uses estimated cell sizes (provided by the cache) to determine how many cells to measure in a batch.
 *    Batch size is chosen using a fast, naive layout algorithm that stacks images in order until the viewport has been filled.
 *    After measurement is complete (componentDidMount or componentDidUpdate) this component evaluates positioned cells
 *    in order to determine if another measurement pass is required (eg if actual cell sizes were less than estimated sizes).
 *    All measurements are permanently cached (keyed by `keyMapper`) for performance purposes.
 * 2) Second pass uses the external `cellPositioner` to layout cells.
 *    At this time the positioner has access to cached size measurements for all cells.
 *    The positions it returns are cached by Masonry for fast access later.
 *    Phase one is repeated if the user scrolls beyond the current layout's bounds.
 *    If the layout is invalidated due to eg a resize, cached positions can be cleared using `recomputeCellPositions()`.
 *
 * Animation constraints:
 *   Simple animations are supported (eg translate/slide into place on initial reveal).
 *   More complex animations are not (eg flying from one position to another on resize).
 *
 * Layout constraints:
 *   This component supports multi-column layout.
 *   The height of each item may vary.
 *   The width of each item must not exceed the width of the column it is "in".
 *   The left position of all items within a column must align.
 *   (Items may not span multiple columns.)
 */

      const Masonry = (_temp = _class =
/*#__PURE__*/
function (_React$PureComponent) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Masonry, _React$PureComponent);

  function Masonry() {
    let _getPrototypeOf2;

    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, Masonry);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, (_getPrototypeOf2 = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Masonry)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "state", {
      isScrolling: false,
      scrollTop: 0
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_debounceResetIsScrollingId", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_invalidateOnUpdateStartIndex", null);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_invalidateOnUpdateStopIndex", null);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_positionCache", new _PositionCache__WEBPACK_IMPORTED_MODULE_10__["default"]());

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_startIndex", null);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_startIndexMemoized", null);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_stopIndex", null);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_stopIndexMemoized", null);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_debounceResetIsScrollingCallback", function () {
      _this.setState({
        isScrolling: false
      });
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_setScrollingContainerRef", function (ref) {
      _this._scrollingContainer = ref;
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_onScroll", function (event) {
      const height = _this.props.height;
      const eventScrollTop = event.currentTarget.scrollTop; // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,
      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.
      // This causes a series of rapid renders that is slow for long lists.
      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.

      const scrollTop = Math.min(Math.max(0, _this._getEstimatedTotalHeight() - height), eventScrollTop); // On iOS, we can arrive at negative offsets by swiping past the start or end.
      // Avoid re-rendering in this case as it can cause problems; see #532 for more.

      if (eventScrollTop !== scrollTop) {
        return;
      } // Prevent pointer events from interrupting a smooth scroll


      _this._debounceResetIsScrolling(); // Certain devices (like Apple touchpad) rapid-fire duplicate events.
      // Don't force a re-render if this is the case.
      // The mouse may move faster then the animation frame does.
      // Use requestAnimationFrame to avoid over-updating.


      if (_this.state.scrollTop !== scrollTop) {
        _this.setState({
          isScrolling: true,
          scrollTop: scrollTop
        });
      }
    });

    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(Masonry, [{
    key: "clearCellPositions",
    value: function clearCellPositions() {
      this._positionCache = new _PositionCache__WEBPACK_IMPORTED_MODULE_10__["default"]();
      this.forceUpdate();
    } // HACK This method signature was intended for Grid

  }, {
    key: "invalidateCellSizeAfterRender",
    value: function invalidateCellSizeAfterRender(_ref) {
      const index = _ref.rowIndex;

      if (this._invalidateOnUpdateStartIndex === null) {
        this._invalidateOnUpdateStartIndex = index;
        this._invalidateOnUpdateStopIndex = index;
      } else {
        this._invalidateOnUpdateStartIndex = Math.min(this._invalidateOnUpdateStartIndex, index);
        this._invalidateOnUpdateStopIndex = Math.max(this._invalidateOnUpdateStopIndex, index);
      }
    }
  }, {
    key: "recomputeCellPositions",
    value: function recomputeCellPositions() {
      const stopIndex = this._positionCache.count - 1;
      this._positionCache = new _PositionCache__WEBPACK_IMPORTED_MODULE_10__["default"]();

      this._populatePositionCache(0, stopIndex);

      this.forceUpdate();
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this._checkInvalidateOnUpdate();

      this._invokeOnScrollCallback();

      this._invokeOnCellsRenderedCallback();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      this._checkInvalidateOnUpdate();

      this._invokeOnScrollCallback();

      this._invokeOnCellsRenderedCallback();

      if (this.props.scrollTop !== prevProps.scrollTop) {
        this._debounceResetIsScrolling();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._debounceResetIsScrollingId) {
        (0,_utils_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_11__.cancelAnimationTimeout)(this._debounceResetIsScrollingId);
      }
    }
  }, {
    key: "render",
    value: function render() {
      const _this2 = this;

      const _this$props = this.props,
        autoHeight = _this$props.autoHeight,
        cellCount = _this$props.cellCount,
        cellMeasurerCache = _this$props.cellMeasurerCache,
        cellRenderer = _this$props.cellRenderer,
        className = _this$props.className,
        height = _this$props.height,
        id = _this$props.id,
        keyMapper = _this$props.keyMapper,
        overscanByPixels = _this$props.overscanByPixels,
        role = _this$props.role,
        style = _this$props.style,
        tabIndex = _this$props.tabIndex,
        width = _this$props.width,
        rowDirection = _this$props.rowDirection;
      const _this$state = this.state,
        isScrolling = _this$state.isScrolling,
        scrollTop = _this$state.scrollTop;
      const children = [];

      const estimateTotalHeight = this._getEstimatedTotalHeight();

      const shortestColumnSize = this._positionCache.shortestColumnSize;
      const measuredCellCount = this._positionCache.count;
      let startIndex = 0;
      let stopIndex;

      this._positionCache.range(Math.max(0, scrollTop - overscanByPixels), height + overscanByPixels * 2, function (index, left, top) {
        let _style;

        if (typeof stopIndex === 'undefined') {
          startIndex = index;
          stopIndex = index;
        } else {
          startIndex = Math.min(startIndex, index);
          stopIndex = Math.max(stopIndex, index);
        }

        children.push(cellRenderer({
          index: index,
          isScrolling: isScrolling,
          key: keyMapper(index),
          parent: _this2,
          style: (_style = {
            height: cellMeasurerCache.getHeight(index)
          }, _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_style, rowDirection === 'ltr' ? 'left' : 'right', left), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_style, "position", 'absolute'), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_style, "top", top), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_style, "width", cellMeasurerCache.getWidth(index)), _style)
        }));
      }); // We need to measure additional cells for this layout


      if (shortestColumnSize < scrollTop + height + overscanByPixels && measuredCellCount < cellCount) {
        const batchSize = Math.min(cellCount - measuredCellCount, Math.ceil((scrollTop + height + overscanByPixels - shortestColumnSize) / cellMeasurerCache.defaultHeight * width / cellMeasurerCache.defaultWidth));

        for (let _index = measuredCellCount; _index < measuredCellCount + batchSize; _index++) {
          stopIndex = _index;
          children.push(cellRenderer({
            index: _index,
            isScrolling: isScrolling,
            key: keyMapper(_index),
            parent: this,
            style: {
              width: cellMeasurerCache.getWidth(_index)
            }
          }));
        }
      }

      this._startIndex = startIndex;
      this._stopIndex = stopIndex;
      return react__WEBPACK_IMPORTED_MODULE_8__.createElement("div", {
        ref: this._setScrollingContainerRef,
        "aria-label": this.props['aria-label'],
        className: (0,clsx__WEBPACK_IMPORTED_MODULE_7__["default"])('ReactVirtualized__Masonry', className),
        id: id,
        onScroll: this._onScroll,
        role: role,
        style: _objectSpread({
          boxSizing: 'border-box',
          direction: 'ltr',
          height: autoHeight ? 'auto' : height,
          overflowX: 'hidden',
          overflowY: estimateTotalHeight < height ? 'hidden' : 'auto',
          position: 'relative',
          width: width,
          WebkitOverflowScrolling: 'touch',
          willChange: 'transform'
        }, style),
        tabIndex: tabIndex
      }, react__WEBPACK_IMPORTED_MODULE_8__.createElement("div", {
        className: "ReactVirtualized__Masonry__innerScrollContainer",
        style: {
          width: '100%',
          height: estimateTotalHeight,
          maxWidth: '100%',
          maxHeight: estimateTotalHeight,
          overflow: 'hidden',
          pointerEvents: isScrolling ? 'none' : '',
          position: 'relative'
        }
      }, children));
    }
  }, {
    key: "_checkInvalidateOnUpdate",
    value: function _checkInvalidateOnUpdate() {
      if (typeof this._invalidateOnUpdateStartIndex === 'number') {
        const startIndex = this._invalidateOnUpdateStartIndex;
        const stopIndex = this._invalidateOnUpdateStopIndex;
        this._invalidateOnUpdateStartIndex = null;
        this._invalidateOnUpdateStopIndex = null; // Query external layout logic for position of newly-measured cells

        this._populatePositionCache(startIndex, stopIndex);

        this.forceUpdate();
      }
    }
  }, {
    key: "_debounceResetIsScrolling",
    value: function _debounceResetIsScrolling() {
      const scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;

      if (this._debounceResetIsScrollingId) {
        (0,_utils_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_11__.cancelAnimationTimeout)(this._debounceResetIsScrollingId);
      }

      this._debounceResetIsScrollingId = (0,_utils_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_11__.requestAnimationTimeout)(this._debounceResetIsScrollingCallback, scrollingResetTimeInterval);
    }
  }, {
    key: "_getEstimatedTotalHeight",
    value: function _getEstimatedTotalHeight() {
      const _this$props2 = this.props,
        cellCount = _this$props2.cellCount,
        cellMeasurerCache = _this$props2.cellMeasurerCache,
        width = _this$props2.width;
      const estimatedColumnCount = Math.max(1, Math.floor(width / cellMeasurerCache.defaultWidth));
      return this._positionCache.estimateTotalHeight(cellCount, estimatedColumnCount, cellMeasurerCache.defaultHeight);
    }
  }, {
    key: "_invokeOnScrollCallback",
    value: function _invokeOnScrollCallback() {
      const _this$props3 = this.props,
        height = _this$props3.height,
        onScroll = _this$props3.onScroll;
      const scrollTop = this.state.scrollTop;

      if (this._onScrollMemoized !== scrollTop) {
        onScroll({
          clientHeight: height,
          scrollHeight: this._getEstimatedTotalHeight(),
          scrollTop: scrollTop
        });
        this._onScrollMemoized = scrollTop;
      }
    }
  }, {
    key: "_invokeOnCellsRenderedCallback",
    value: function _invokeOnCellsRenderedCallback() {
      if (this._startIndexMemoized !== this._startIndex || this._stopIndexMemoized !== this._stopIndex) {
        const onCellsRendered = this.props.onCellsRendered;
        onCellsRendered({
          startIndex: this._startIndex,
          stopIndex: this._stopIndex
        });
        this._startIndexMemoized = this._startIndex;
        this._stopIndexMemoized = this._stopIndex;
      }
    }
  }, {
    key: "_populatePositionCache",
    value: function _populatePositionCache(startIndex, stopIndex) {
      const _this$props4 = this.props,
        cellMeasurerCache = _this$props4.cellMeasurerCache,
        cellPositioner = _this$props4.cellPositioner;

      for (let _index2 = startIndex; _index2 <= stopIndex; _index2++) {
        const _cellPositioner = cellPositioner(_index2),
          left = _cellPositioner.left,
          top = _cellPositioner.top;

        this._positionCache.setPosition(_index2, left, top, cellMeasurerCache.getHeight(_index2));
      }
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.scrollTop !== undefined && prevState.scrollTop !== nextProps.scrollTop) {
        return {
          isScrolling: true,
          scrollTop: nextProps.scrollTop
        };
      }

      return null;
    }
  }]);

  return Masonry;
}(react__WEBPACK_IMPORTED_MODULE_8__.PureComponent), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_class, "propTypes",  false ? 0 : {
        "autoHeight": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().bool).isRequired,
        "cellCount": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().number).isRequired,
        "cellMeasurerCache": function cellMeasurerCache() {
          return (typeof CellMeasurerCache === "function" ? prop_types__WEBPACK_IMPORTED_MODULE_12___default().instanceOf(CellMeasurerCache).isRequired : (prop_types__WEBPACK_IMPORTED_MODULE_12___default().any).isRequired).apply(this, arguments);
        },
        "cellPositioner": function cellPositioner() {
          return (typeof Positioner === "function" ? prop_types__WEBPACK_IMPORTED_MODULE_12___default().instanceOf(Positioner).isRequired : (prop_types__WEBPACK_IMPORTED_MODULE_12___default().any).isRequired).apply(this, arguments);
        },
        "cellRenderer": function cellRenderer() {
          return (typeof CellRenderer === "function" ? prop_types__WEBPACK_IMPORTED_MODULE_12___default().instanceOf(CellRenderer).isRequired : (prop_types__WEBPACK_IMPORTED_MODULE_12___default().any).isRequired).apply(this, arguments);
        },
        "className": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().string),
        "height": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().number).isRequired,
        "id": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().string),
        "keyMapper": function keyMapper() {
          return (typeof KeyMapper === "function" ? prop_types__WEBPACK_IMPORTED_MODULE_12___default().instanceOf(KeyMapper).isRequired : (prop_types__WEBPACK_IMPORTED_MODULE_12___default().any).isRequired).apply(this, arguments);
        },
        "onCellsRendered": function onCellsRendered() {
          return (typeof OnCellsRenderedCallback === "function" ? prop_types__WEBPACK_IMPORTED_MODULE_12___default().instanceOf(OnCellsRenderedCallback) : (prop_types__WEBPACK_IMPORTED_MODULE_12___default().any)).apply(this, arguments);
        },
        "onScroll": function onScroll() {
          return (typeof OnScrollCallback === "function" ? prop_types__WEBPACK_IMPORTED_MODULE_12___default().instanceOf(OnScrollCallback) : (prop_types__WEBPACK_IMPORTED_MODULE_12___default().any)).apply(this, arguments);
        },
        "overscanByPixels": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().number).isRequired,
        "role": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().string).isRequired,
        "scrollingResetTimeInterval": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().number).isRequired,
        "style": function style(props, propName, componentName) {
          if (!Object.prototype.hasOwnProperty.call(props, propName)) {
            throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
          }
        },
        "tabIndex": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().number).isRequired,
        "width": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().number).isRequired,
        "rowDirection": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().string).isRequired,
        "scrollTop": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().number)
      }), _temp);

      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(Masonry, "defaultProps", {
        autoHeight: false,
        keyMapper: identity,
        onCellsRendered: noop,
        onScroll: noop,
        overscanByPixels: 20,
        role: 'grid',
        scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,
        style: emptyObject,
        tabIndex: 0,
        rowDirection: 'ltr'
      });

      function identity(value) {
        return value;
      }

      function noop() {}

      var bpfrpt_proptype_CellMeasurerCache =  false ? 0 : {
        "defaultHeight": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().number).isRequired,
        "defaultWidth": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().number).isRequired,
        "getHeight": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().func).isRequired,
        "getWidth": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().func).isRequired
      };
      (0,react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_9__.polyfill)(Masonry);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Masonry);
      var bpfrpt_proptype_Positioner =  false ? 0 : (prop_types__WEBPACK_IMPORTED_MODULE_12___default().func);





/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Masonry/PositionCache.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Masonry/PositionCache.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PositionCache)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray/index.js");
/* harmony import */ const _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _vendor_intervalTree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../vendor/intervalTree */ "./node_modules/react-virtualized/dist/es/vendor/intervalTree.js");






// Position cache requirements:
//   O(log(n)) lookup of cells to render for a given viewport size
//   O(1) lookup of shortest measured column (so we know when to enter phase 1)
      var PositionCache =
/*#__PURE__*/
function () {
  function PositionCache() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, PositionCache);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "_columnSizeMap", {});

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "_intervalTree", (0,_vendor_intervalTree__WEBPACK_IMPORTED_MODULE_4__["default"])());

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "_leftMap", {});
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(PositionCache, [{
    key: "estimateTotalHeight",
    value: function estimateTotalHeight(cellCount, columnCount, defaultCellHeight) {
      const unmeasuredCellCount = cellCount - this.count;
      return this.tallestColumnSize + Math.ceil(unmeasuredCellCount / columnCount) * defaultCellHeight;
    } // Render all cells visible within the viewport range defined.

  }, {
    key: "range",
    value: function range(scrollTop, clientHeight, renderCallback) {
      const _this = this;

      this._intervalTree.queryInterval(scrollTop, scrollTop + clientHeight, function (_ref) {
        const _ref2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref, 3),
          top = _ref2[0],
          _ = _ref2[1],
          index = _ref2[2];

        return renderCallback(index, _this._leftMap[index], top);
      });
    }
  }, {
    key: "setPosition",
    value: function setPosition(index, left, top, height) {
      this._intervalTree.insert([top, top + height, index]);

      this._leftMap[index] = left;
      const columnSizeMap = this._columnSizeMap;
      const columnHeight = columnSizeMap[left];

      if (columnHeight === undefined) {
        columnSizeMap[left] = top + height;
      } else {
        columnSizeMap[left] = Math.max(columnHeight, top + height);
      }
    }
  }, {
    key: "count",
    get: function get() {
      return this._intervalTree.count;
    }
  }, {
    key: "shortestColumnSize",
    get: function get() {
      const columnSizeMap = this._columnSizeMap;
      let size = 0;

      for (const i in columnSizeMap) {
        const height = columnSizeMap[i];
        size = size === 0 ? height : Math.min(size, height);
      }

      return size;
    }
  }, {
    key: "tallestColumnSize",
    get: function get() {
      const columnSizeMap = this._columnSizeMap;
      let size = 0;

      for (const i in columnSizeMap) {
        const height = columnSizeMap[i];
        size = Math.max(size, height);
      }

      return size;
    }
  }]);

  return PositionCache;
}();



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Masonry/createCellPositioner.js":
/*!********************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Masonry/createCellPositioner.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createCellPositioner)
/* harmony export */ });
/* harmony import */ const _Masonry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Masonry */ "./node_modules/react-virtualized/dist/es/Masonry/Masonry.js");
      function createCellPositioner(_ref) {
        let cellMeasurerCache = _ref.cellMeasurerCache,
          columnCount = _ref.columnCount,
          columnWidth = _ref.columnWidth,
          _ref$spacer = _ref.spacer,
          spacer = _ref$spacer === void 0 ? 0 : _ref$spacer;
        let columnHeights;
        initOrResetDerivedValues();

        function cellPositioner(index) {
    // Find the shortest column and use it.
          let columnIndex = 0;

          for (let i = 1; i < columnHeights.length; i++) {
            if (columnHeights[i] < columnHeights[columnIndex]) {
              columnIndex = i;
            }
          }

          const left = columnIndex * (columnWidth + spacer);
          const top = columnHeights[columnIndex] || 0;
          columnHeights[columnIndex] = top + cellMeasurerCache.getHeight(index) + spacer;
          return {
            left: left,
            top: top
          };
        }

        function initOrResetDerivedValues() {
    // Track the height of each column.
    // Layout algorithm below always inserts into the shortest column.
          columnHeights = [];

          for (let i = 0; i < columnCount; i++) {
            columnHeights[i] = 0;
          }
        }

        function reset(params) {
          columnCount = params.columnCount;
          columnWidth = params.columnWidth;
          spacer = params.spacer;
          initOrResetDerivedValues();
        }

        cellPositioner.reset = reset;
        return cellPositioner;
      }



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Masonry/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Masonry/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Masonry: () => (/* reexport safe */ _Masonry__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   createCellPositioner: () => (/* reexport safe */ _createCellPositioner__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createCellPositioner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createCellPositioner */ "./node_modules/react-virtualized/dist/es/Masonry/createCellPositioner.js");
/* harmony import */ var _Masonry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Masonry */ "./node_modules/react-virtualized/dist/es/Masonry/Masonry.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Masonry__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/MultiGrid/CellMeasurerCacheDecorator.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/MultiGrid/CellMeasurerCacheDecorator.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CellMeasurerCacheDecorator)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _CellMeasurer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CellMeasurer */ "./node_modules/react-virtualized/dist/es/CellMeasurer/index.js");





/**
 * Caches measurements for a given cell.
 */
      var CellMeasurerCacheDecorator =
/*#__PURE__*/
function () {
  function CellMeasurerCacheDecorator() {
    const _this = this;

    const params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, CellMeasurerCacheDecorator);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_cellMeasurerCache", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_columnIndexOffset", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "_rowIndexOffset", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "columnWidth", function (_ref) {
      const index = _ref.index;

      _this._cellMeasurerCache.columnWidth({
        index: index + _this._columnIndexOffset
      });
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "rowHeight", function (_ref2) {
      const index = _ref2.index;

      _this._cellMeasurerCache.rowHeight({
        index: index + _this._rowIndexOffset
      });
    });

    const cellMeasurerCache = params.cellMeasurerCache,
      _params$columnIndexOf = params.columnIndexOffset,
      columnIndexOffset = _params$columnIndexOf === void 0 ? 0 : _params$columnIndexOf,
      _params$rowIndexOffse = params.rowIndexOffset,
      rowIndexOffset = _params$rowIndexOffse === void 0 ? 0 : _params$rowIndexOffse;
    this._cellMeasurerCache = cellMeasurerCache;
    this._columnIndexOffset = columnIndexOffset;
    this._rowIndexOffset = rowIndexOffset;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(CellMeasurerCacheDecorator, [{
    key: "clear",
    value: function clear(rowIndex, columnIndex) {
      this._cellMeasurerCache.clear(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
    }
  }, {
    key: "clearAll",
    value: function clearAll() {
      this._cellMeasurerCache.clearAll();
    }
  }, {
    key: "hasFixedHeight",
    value: function hasFixedHeight() {
      return this._cellMeasurerCache.hasFixedHeight();
    }
  }, {
    key: "hasFixedWidth",
    value: function hasFixedWidth() {
      return this._cellMeasurerCache.hasFixedWidth();
    }
  }, {
    key: "getHeight",
    value: function getHeight(rowIndex) {
      const columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this._cellMeasurerCache.getHeight(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
    }
  }, {
    key: "getWidth",
    value: function getWidth(rowIndex) {
      const columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this._cellMeasurerCache.getWidth(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
    }
  }, {
    key: "has",
    value: function has(rowIndex) {
      const columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this._cellMeasurerCache.has(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
    }
  }, {
    key: "set",
    value: function set(rowIndex, columnIndex, width, height) {
      this._cellMeasurerCache.set(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset, width, height);
    }
  }, {
    key: "defaultHeight",
    get: function get() {
      return this._cellMeasurerCache.defaultHeight;
    }
  }, {
    key: "defaultWidth",
    get: function get() {
      return this._cellMeasurerCache.defaultWidth;
    }
  }]);

  return CellMeasurerCacheDecorator;
}();



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/MultiGrid/MultiGrid.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/MultiGrid/MultiGrid.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends/index.js");
/* harmony import */ const _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/objectWithoutProperties/index.js");
/* harmony import */ const _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ const react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-lifecycles-compat */ "./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js");
/* harmony import */ const _CellMeasurerCacheDecorator__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./CellMeasurerCacheDecorator */ "./node_modules/react-virtualized/dist/es/MultiGrid/CellMeasurerCacheDecorator.js");
/* harmony import */ const _Grid__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../Grid */ "./node_modules/react-virtualized/dist/es/Grid/index.js");










      function ownKeys(object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function _objectSpread(target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






      const SCROLLBAR_SIZE_BUFFER = 20;
/**
 * Renders 1, 2, or 4 Grids depending on configuration.
 * A main (body) Grid will always be rendered.
 * Optionally, 1-2 Grids for sticky header rows will also be rendered.
 * If no sticky columns, only 1 sticky header Grid will be rendered.
 * If sticky columns, 2 sticky header Grids will be rendered.
 */

      const MultiGrid =
/*#__PURE__*/
function (_React$PureComponent) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_7___default()(MultiGrid, _React$PureComponent);

  function MultiGrid(props, context) {
    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default()(this, MultiGrid);

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(MultiGrid).call(this, props, context));

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "state", {
      scrollLeft: 0,
      scrollTop: 0,
      scrollbarSize: 0,
      showHorizontalScrollbar: false,
      showVerticalScrollbar: false
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_deferredInvalidateColumnIndex", null);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_deferredInvalidateRowIndex", null);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_bottomLeftGridRef", function (ref) {
      _this._bottomLeftGrid = ref;
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_bottomRightGridRef", function (ref) {
      _this._bottomRightGrid = ref;
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_cellRendererBottomLeftGrid", function (_ref) {
      const rowIndex = _ref.rowIndex,
        rest = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1___default()(_ref, ["rowIndex"]);

      const _this$props = _this.props,
        cellRenderer = _this$props.cellRenderer,
        fixedRowCount = _this$props.fixedRowCount,
        rowCount = _this$props.rowCount;

      if (rowIndex === rowCount - fixedRowCount) {
        return react__WEBPACK_IMPORTED_MODULE_10__.createElement("div", {
          key: rest.key,
          style: _objectSpread({}, rest.style, {
            height: SCROLLBAR_SIZE_BUFFER
          })
        });
      } else {
        return cellRenderer(_objectSpread({}, rest, {
          parent: _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this),
          rowIndex: rowIndex + fixedRowCount
        }));
      }
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_cellRendererBottomRightGrid", function (_ref2) {
      const columnIndex = _ref2.columnIndex,
        rowIndex = _ref2.rowIndex,
        rest = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1___default()(_ref2, ["columnIndex", "rowIndex"]);

      const _this$props2 = _this.props,
        cellRenderer = _this$props2.cellRenderer,
        fixedColumnCount = _this$props2.fixedColumnCount,
        fixedRowCount = _this$props2.fixedRowCount;
      return cellRenderer(_objectSpread({}, rest, {
        columnIndex: columnIndex + fixedColumnCount,
        parent: _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this),
        rowIndex: rowIndex + fixedRowCount
      }));
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_cellRendererTopRightGrid", function (_ref3) {
      const columnIndex = _ref3.columnIndex,
        rest = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1___default()(_ref3, ["columnIndex"]);

      const _this$props3 = _this.props,
        cellRenderer = _this$props3.cellRenderer,
        columnCount = _this$props3.columnCount,
        fixedColumnCount = _this$props3.fixedColumnCount;

      if (columnIndex === columnCount - fixedColumnCount) {
        return react__WEBPACK_IMPORTED_MODULE_10__.createElement("div", {
          key: rest.key,
          style: _objectSpread({}, rest.style, {
            width: SCROLLBAR_SIZE_BUFFER
          })
        });
      } else {
        return cellRenderer(_objectSpread({}, rest, {
          columnIndex: columnIndex + fixedColumnCount,
          parent: _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this)
        }));
      }
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_columnWidthRightGrid", function (_ref4) {
      const index = _ref4.index;
      const _this$props4 = _this.props,
        columnCount = _this$props4.columnCount,
        fixedColumnCount = _this$props4.fixedColumnCount,
        columnWidth = _this$props4.columnWidth;
      const _this$state = _this.state,
        scrollbarSize = _this$state.scrollbarSize,
        showHorizontalScrollbar = _this$state.showHorizontalScrollbar; // An extra cell is added to the count
      // This gives the smaller Grid extra room for offset,
      // In case the main (bottom right) Grid has a scrollbar
      // If no scrollbar, the extra space is overflow:hidden anyway

      if (showHorizontalScrollbar && index === columnCount - fixedColumnCount) {
        return scrollbarSize;
      }

      return typeof columnWidth === 'function' ? columnWidth({
        index: index + fixedColumnCount
      }) : columnWidth;
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_onScroll", function (scrollInfo) {
      const scrollLeft = scrollInfo.scrollLeft,
        scrollTop = scrollInfo.scrollTop;

      _this.setState({
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      });

      const onScroll = _this.props.onScroll;

      if (onScroll) {
        onScroll(scrollInfo);
      }
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_onScrollbarPresenceChange", function (_ref5) {
      const horizontal = _ref5.horizontal,
        size = _ref5.size,
        vertical = _ref5.vertical;
      const _this$state2 = _this.state,
        showHorizontalScrollbar = _this$state2.showHorizontalScrollbar,
        showVerticalScrollbar = _this$state2.showVerticalScrollbar;

      if (horizontal !== showHorizontalScrollbar || vertical !== showVerticalScrollbar) {
        _this.setState({
          scrollbarSize: size,
          showHorizontalScrollbar: horizontal,
          showVerticalScrollbar: vertical
        });

        const onScrollbarPresenceChange = _this.props.onScrollbarPresenceChange;

        if (typeof onScrollbarPresenceChange === 'function') {
          onScrollbarPresenceChange({
            horizontal: horizontal,
            size: size,
            vertical: vertical
          });
        }
      }
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_onScrollLeft", function (scrollInfo) {
      const scrollLeft = scrollInfo.scrollLeft;

      _this._onScroll({
        scrollLeft: scrollLeft,
        scrollTop: _this.state.scrollTop
      });
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_onScrollTop", function (scrollInfo) {
      const scrollTop = scrollInfo.scrollTop;

      _this._onScroll({
        scrollTop: scrollTop,
        scrollLeft: _this.state.scrollLeft
      });
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_rowHeightBottomGrid", function (_ref6) {
      const index = _ref6.index;
      const _this$props5 = _this.props,
        fixedRowCount = _this$props5.fixedRowCount,
        rowCount = _this$props5.rowCount,
        rowHeight = _this$props5.rowHeight;
      const _this$state3 = _this.state,
        scrollbarSize = _this$state3.scrollbarSize,
        showVerticalScrollbar = _this$state3.showVerticalScrollbar; // An extra cell is added to the count
      // This gives the smaller Grid extra room for offset,
      // In case the main (bottom right) Grid has a scrollbar
      // If no scrollbar, the extra space is overflow:hidden anyway

      if (showVerticalScrollbar && index === rowCount - fixedRowCount) {
        return scrollbarSize;
      }

      return typeof rowHeight === 'function' ? rowHeight({
        index: index + fixedRowCount
      }) : rowHeight;
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_topLeftGridRef", function (ref) {
      _this._topLeftGrid = ref;
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6___default()(_this), "_topRightGridRef", function (ref) {
      _this._topRightGrid = ref;
    });

    const deferredMeasurementCache = props.deferredMeasurementCache,
      _fixedColumnCount = props.fixedColumnCount,
      _fixedRowCount = props.fixedRowCount;

    _this._maybeCalculateCachedStyles(true);

    if (deferredMeasurementCache) {
      _this._deferredMeasurementCacheBottomLeftGrid = _fixedRowCount > 0 ? new _CellMeasurerCacheDecorator__WEBPACK_IMPORTED_MODULE_12__["default"]({
        cellMeasurerCache: deferredMeasurementCache,
        columnIndexOffset: 0,
        rowIndexOffset: _fixedRowCount
      }) : deferredMeasurementCache;
      _this._deferredMeasurementCacheBottomRightGrid = _fixedColumnCount > 0 || _fixedRowCount > 0 ? new _CellMeasurerCacheDecorator__WEBPACK_IMPORTED_MODULE_12__["default"]({
        cellMeasurerCache: deferredMeasurementCache,
        columnIndexOffset: _fixedColumnCount,
        rowIndexOffset: _fixedRowCount
      }) : deferredMeasurementCache;
      _this._deferredMeasurementCacheTopRightGrid = _fixedColumnCount > 0 ? new _CellMeasurerCacheDecorator__WEBPACK_IMPORTED_MODULE_12__["default"]({
        cellMeasurerCache: deferredMeasurementCache,
        columnIndexOffset: _fixedColumnCount,
        rowIndexOffset: 0
      }) : deferredMeasurementCache;
    }

    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default()(MultiGrid, [{
    key: "forceUpdateGrids",
    value: function forceUpdateGrids() {
      this._bottomLeftGrid && this._bottomLeftGrid.forceUpdate();
      this._bottomRightGrid && this._bottomRightGrid.forceUpdate();
      this._topLeftGrid && this._topLeftGrid.forceUpdate();
      this._topRightGrid && this._topRightGrid.forceUpdate();
    }
    /** See Grid#invalidateCellSizeAfterRender */

  }, {
    key: "invalidateCellSizeAfterRender",
    value: function invalidateCellSizeAfterRender() {
      const _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref7$columnIndex = _ref7.columnIndex,
        columnIndex = _ref7$columnIndex === void 0 ? 0 : _ref7$columnIndex,
        _ref7$rowIndex = _ref7.rowIndex,
        rowIndex = _ref7$rowIndex === void 0 ? 0 : _ref7$rowIndex;

      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;
      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;
    }
    /** See Grid#measureAllCells */

  }, {
    key: "measureAllCells",
    value: function measureAllCells() {
      this._bottomLeftGrid && this._bottomLeftGrid.measureAllCells();
      this._bottomRightGrid && this._bottomRightGrid.measureAllCells();
      this._topLeftGrid && this._topLeftGrid.measureAllCells();
      this._topRightGrid && this._topRightGrid.measureAllCells();
    }
    /** See Grid#recomputeGridSize */

  }, {
    key: "recomputeGridSize",
    value: function recomputeGridSize() {
      const _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref8$columnIndex = _ref8.columnIndex,
        columnIndex = _ref8$columnIndex === void 0 ? 0 : _ref8$columnIndex,
        _ref8$rowIndex = _ref8.rowIndex,
        rowIndex = _ref8$rowIndex === void 0 ? 0 : _ref8$rowIndex;

      const _this$props6 = this.props,
        fixedColumnCount = _this$props6.fixedColumnCount,
        fixedRowCount = _this$props6.fixedRowCount;
      const adjustedColumnIndex = Math.max(0, columnIndex - fixedColumnCount);
      const adjustedRowIndex = Math.max(0, rowIndex - fixedRowCount);
      this._bottomLeftGrid && this._bottomLeftGrid.recomputeGridSize({
        columnIndex: columnIndex,
        rowIndex: adjustedRowIndex
      });
      this._bottomRightGrid && this._bottomRightGrid.recomputeGridSize({
        columnIndex: adjustedColumnIndex,
        rowIndex: adjustedRowIndex
      });
      this._topLeftGrid && this._topLeftGrid.recomputeGridSize({
        columnIndex: columnIndex,
        rowIndex: rowIndex
      });
      this._topRightGrid && this._topRightGrid.recomputeGridSize({
        columnIndex: adjustedColumnIndex,
        rowIndex: rowIndex
      });
      this._leftGridWidth = null;
      this._topGridHeight = null;

      this._maybeCalculateCachedStyles(true);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      const _this$props7 = this.props,
        scrollLeft = _this$props7.scrollLeft,
        scrollTop = _this$props7.scrollTop;

      if (scrollLeft > 0 || scrollTop > 0) {
        const newState = {};

        if (scrollLeft > 0) {
          newState.scrollLeft = scrollLeft;
        }

        if (scrollTop > 0) {
          newState.scrollTop = scrollTop;
        }

        this.setState(newState);
      }

      this._handleInvalidatedGridSize();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this._handleInvalidatedGridSize();
    }
  }, {
    key: "render",
    value: function render() {
      const _this$props8 = this.props,
        onScroll = _this$props8.onScroll,
        onSectionRendered = _this$props8.onSectionRendered,
        onScrollbarPresenceChange = _this$props8.onScrollbarPresenceChange,
        scrollLeftProp = _this$props8.scrollLeft,
        scrollToColumn = _this$props8.scrollToColumn,
        scrollTopProp = _this$props8.scrollTop,
        scrollToRow = _this$props8.scrollToRow,
        rest = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1___default()(_this$props8, ["onScroll", "onSectionRendered", "onScrollbarPresenceChange", "scrollLeft", "scrollToColumn", "scrollTop", "scrollToRow"]);

      this._prepareForRender(); // Don't render any of our Grids if there are no cells.
      // This mirrors what Grid does,
      // And prevents us from recording inaccurage measurements when used with CellMeasurer.


      if (this.props.width === 0 || this.props.height === 0) {
        return null;
      } // scrollTop and scrollLeft props are explicitly filtered out and ignored


      const _this$state4 = this.state,
        scrollLeft = _this$state4.scrollLeft,
        scrollTop = _this$state4.scrollTop;
      return react__WEBPACK_IMPORTED_MODULE_10__.createElement("div", {
        style: this._containerOuterStyle
      }, react__WEBPACK_IMPORTED_MODULE_10__.createElement("div", {
        style: this._containerTopStyle
      }, this._renderTopLeftGrid(rest), this._renderTopRightGrid(_objectSpread({}, rest, {
        onScroll: onScroll,
        scrollLeft: scrollLeft
      }))), react__WEBPACK_IMPORTED_MODULE_10__.createElement("div", {
        style: this._containerBottomStyle
      }, this._renderBottomLeftGrid(_objectSpread({}, rest, {
        onScroll: onScroll,
        scrollTop: scrollTop
      })), this._renderBottomRightGrid(_objectSpread({}, rest, {
        onScroll: onScroll,
        onSectionRendered: onSectionRendered,
        scrollLeft: scrollLeft,
        scrollToColumn: scrollToColumn,
        scrollToRow: scrollToRow,
        scrollTop: scrollTop
      }))));
    }
  }, {
    key: "_getBottomGridHeight",
    value: function _getBottomGridHeight(props) {
      const height = props.height;

      const topGridHeight = this._getTopGridHeight(props);

      return height - topGridHeight;
    }
  }, {
    key: "_getLeftGridWidth",
    value: function _getLeftGridWidth(props) {
      const fixedColumnCount = props.fixedColumnCount,
        columnWidth = props.columnWidth;

      if (this._leftGridWidth == null) {
        if (typeof columnWidth === 'function') {
          let leftGridWidth = 0;

          for (let index = 0; index < fixedColumnCount; index++) {
            leftGridWidth += columnWidth({
              index: index
            });
          }

          this._leftGridWidth = leftGridWidth;
        } else {
          this._leftGridWidth = columnWidth * fixedColumnCount;
        }
      }

      return this._leftGridWidth;
    }
  }, {
    key: "_getRightGridWidth",
    value: function _getRightGridWidth(props) {
      const width = props.width;

      const leftGridWidth = this._getLeftGridWidth(props);

      return width - leftGridWidth;
    }
  }, {
    key: "_getTopGridHeight",
    value: function _getTopGridHeight(props) {
      const fixedRowCount = props.fixedRowCount,
        rowHeight = props.rowHeight;

      if (this._topGridHeight == null) {
        if (typeof rowHeight === 'function') {
          let topGridHeight = 0;

          for (let index = 0; index < fixedRowCount; index++) {
            topGridHeight += rowHeight({
              index: index
            });
          }

          this._topGridHeight = topGridHeight;
        } else {
          this._topGridHeight = rowHeight * fixedRowCount;
        }
      }

      return this._topGridHeight;
    }
  }, {
    key: "_handleInvalidatedGridSize",
    value: function _handleInvalidatedGridSize() {
      if (typeof this._deferredInvalidateColumnIndex === 'number') {
        const columnIndex = this._deferredInvalidateColumnIndex;
        const rowIndex = this._deferredInvalidateRowIndex;
        this._deferredInvalidateColumnIndex = null;
        this._deferredInvalidateRowIndex = null;
        this.recomputeGridSize({
          columnIndex: columnIndex,
          rowIndex: rowIndex
        });
        this.forceUpdate();
      }
    }
    /**
     * Avoid recreating inline styles each render; this bypasses Grid's shallowCompare.
     * This method recalculates styles only when specific props change.
     */

  }, {
    key: "_maybeCalculateCachedStyles",
    value: function _maybeCalculateCachedStyles(resetAll) {
      const _this$props9 = this.props,
        columnWidth = _this$props9.columnWidth,
        enableFixedColumnScroll = _this$props9.enableFixedColumnScroll,
        enableFixedRowScroll = _this$props9.enableFixedRowScroll,
        height = _this$props9.height,
        fixedColumnCount = _this$props9.fixedColumnCount,
        fixedRowCount = _this$props9.fixedRowCount,
        rowHeight = _this$props9.rowHeight,
        style = _this$props9.style,
        styleBottomLeftGrid = _this$props9.styleBottomLeftGrid,
        styleBottomRightGrid = _this$props9.styleBottomRightGrid,
        styleTopLeftGrid = _this$props9.styleTopLeftGrid,
        styleTopRightGrid = _this$props9.styleTopRightGrid,
        width = _this$props9.width;
      const sizeChange = resetAll || height !== this._lastRenderedHeight || width !== this._lastRenderedWidth;
      const leftSizeChange = resetAll || columnWidth !== this._lastRenderedColumnWidth || fixedColumnCount !== this._lastRenderedFixedColumnCount;
      const topSizeChange = resetAll || fixedRowCount !== this._lastRenderedFixedRowCount || rowHeight !== this._lastRenderedRowHeight;

      if (resetAll || sizeChange || style !== this._lastRenderedStyle) {
        this._containerOuterStyle = _objectSpread({
          height: height,
          overflow: 'visible',
          // Let :focus outline show through
          width: width
        }, style);
      }

      if (resetAll || sizeChange || topSizeChange) {
        this._containerTopStyle = {
          height: this._getTopGridHeight(this.props),
          position: 'relative',
          width: width
        };
        this._containerBottomStyle = {
          height: height - this._getTopGridHeight(this.props),
          overflow: 'visible',
          // Let :focus outline show through
          position: 'relative',
          width: width
        };
      }

      if (resetAll || styleBottomLeftGrid !== this._lastRenderedStyleBottomLeftGrid) {
        this._bottomLeftGridStyle = _objectSpread({
          left: 0,
          overflowX: 'hidden',
          overflowY: enableFixedColumnScroll ? 'auto' : 'hidden',
          position: 'absolute'
        }, styleBottomLeftGrid);
      }

      if (resetAll || leftSizeChange || styleBottomRightGrid !== this._lastRenderedStyleBottomRightGrid) {
        this._bottomRightGridStyle = _objectSpread({
          left: this._getLeftGridWidth(this.props),
          position: 'absolute'
        }, styleBottomRightGrid);
      }

      if (resetAll || styleTopLeftGrid !== this._lastRenderedStyleTopLeftGrid) {
        this._topLeftGridStyle = _objectSpread({
          left: 0,
          overflowX: 'hidden',
          overflowY: 'hidden',
          position: 'absolute',
          top: 0
        }, styleTopLeftGrid);
      }

      if (resetAll || leftSizeChange || styleTopRightGrid !== this._lastRenderedStyleTopRightGrid) {
        this._topRightGridStyle = _objectSpread({
          left: this._getLeftGridWidth(this.props),
          overflowX: enableFixedRowScroll ? 'auto' : 'hidden',
          overflowY: 'hidden',
          position: 'absolute',
          top: 0
        }, styleTopRightGrid);
      }

      this._lastRenderedColumnWidth = columnWidth;
      this._lastRenderedFixedColumnCount = fixedColumnCount;
      this._lastRenderedFixedRowCount = fixedRowCount;
      this._lastRenderedHeight = height;
      this._lastRenderedRowHeight = rowHeight;
      this._lastRenderedStyle = style;
      this._lastRenderedStyleBottomLeftGrid = styleBottomLeftGrid;
      this._lastRenderedStyleBottomRightGrid = styleBottomRightGrid;
      this._lastRenderedStyleTopLeftGrid = styleTopLeftGrid;
      this._lastRenderedStyleTopRightGrid = styleTopRightGrid;
      this._lastRenderedWidth = width;
    }
  }, {
    key: "_prepareForRender",
    value: function _prepareForRender() {
      if (this._lastRenderedColumnWidth !== this.props.columnWidth || this._lastRenderedFixedColumnCount !== this.props.fixedColumnCount) {
        this._leftGridWidth = null;
      }

      if (this._lastRenderedFixedRowCount !== this.props.fixedRowCount || this._lastRenderedRowHeight !== this.props.rowHeight) {
        this._topGridHeight = null;
      }

      this._maybeCalculateCachedStyles();

      this._lastRenderedColumnWidth = this.props.columnWidth;
      this._lastRenderedFixedColumnCount = this.props.fixedColumnCount;
      this._lastRenderedFixedRowCount = this.props.fixedRowCount;
      this._lastRenderedRowHeight = this.props.rowHeight;
    }
  }, {
    key: "_renderBottomLeftGrid",
    value: function _renderBottomLeftGrid(props) {
      const enableFixedColumnScroll = props.enableFixedColumnScroll,
        fixedColumnCount = props.fixedColumnCount,
        fixedRowCount = props.fixedRowCount,
        rowCount = props.rowCount,
        hideBottomLeftGridScrollbar = props.hideBottomLeftGridScrollbar;
      const showVerticalScrollbar = this.state.showVerticalScrollbar;

      if (!fixedColumnCount) {
        return null;
      }

      const additionalRowCount = showVerticalScrollbar ? 1 : 0,
        height = this._getBottomGridHeight(props),
        width = this._getLeftGridWidth(props),
        scrollbarSize = this.state.showVerticalScrollbar ? this.state.scrollbarSize : 0,
        gridWidth = hideBottomLeftGridScrollbar ? width + scrollbarSize : width;

      const bottomLeftGrid = react__WEBPACK_IMPORTED_MODULE_10__.createElement(_Grid__WEBPACK_IMPORTED_MODULE_13__["default"], _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, props, {
        cellRenderer: this._cellRendererBottomLeftGrid,
        className: this.props.classNameBottomLeftGrid,
        columnCount: fixedColumnCount,
        deferredMeasurementCache: this._deferredMeasurementCacheBottomLeftGrid,
        height: height,
        onScroll: enableFixedColumnScroll ? this._onScrollTop : undefined,
        ref: this._bottomLeftGridRef,
        rowCount: Math.max(0, rowCount - fixedRowCount) + additionalRowCount,
        rowHeight: this._rowHeightBottomGrid,
        style: this._bottomLeftGridStyle,
        tabIndex: null,
        width: gridWidth
      }));

      if (hideBottomLeftGridScrollbar) {
        return react__WEBPACK_IMPORTED_MODULE_10__.createElement("div", {
          className: "BottomLeftGrid_ScrollWrapper",
          style: _objectSpread({}, this._bottomLeftGridStyle, {
            height: height,
            width: width,
            overflowY: 'hidden'
          })
        }, bottomLeftGrid);
      }

      return bottomLeftGrid;
    }
  }, {
    key: "_renderBottomRightGrid",
    value: function _renderBottomRightGrid(props) {
      const columnCount = props.columnCount,
        fixedColumnCount = props.fixedColumnCount,
        fixedRowCount = props.fixedRowCount,
        rowCount = props.rowCount,
        scrollToColumn = props.scrollToColumn,
        scrollToRow = props.scrollToRow;
      return react__WEBPACK_IMPORTED_MODULE_10__.createElement(_Grid__WEBPACK_IMPORTED_MODULE_13__["default"], _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, props, {
        cellRenderer: this._cellRendererBottomRightGrid,
        className: this.props.classNameBottomRightGrid,
        columnCount: Math.max(0, columnCount - fixedColumnCount),
        columnWidth: this._columnWidthRightGrid,
        deferredMeasurementCache: this._deferredMeasurementCacheBottomRightGrid,
        height: this._getBottomGridHeight(props),
        onScroll: this._onScroll,
        onScrollbarPresenceChange: this._onScrollbarPresenceChange,
        ref: this._bottomRightGridRef,
        rowCount: Math.max(0, rowCount - fixedRowCount),
        rowHeight: this._rowHeightBottomGrid,
        scrollToColumn: scrollToColumn - fixedColumnCount,
        scrollToRow: scrollToRow - fixedRowCount,
        style: this._bottomRightGridStyle,
        width: this._getRightGridWidth(props)
      }));
    }
  }, {
    key: "_renderTopLeftGrid",
    value: function _renderTopLeftGrid(props) {
      const fixedColumnCount = props.fixedColumnCount,
        fixedRowCount = props.fixedRowCount;

      if (!fixedColumnCount || !fixedRowCount) {
        return null;
      }

      return react__WEBPACK_IMPORTED_MODULE_10__.createElement(_Grid__WEBPACK_IMPORTED_MODULE_13__["default"], _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, props, {
        className: this.props.classNameTopLeftGrid,
        columnCount: fixedColumnCount,
        height: this._getTopGridHeight(props),
        ref: this._topLeftGridRef,
        rowCount: fixedRowCount,
        style: this._topLeftGridStyle,
        tabIndex: null,
        width: this._getLeftGridWidth(props)
      }));
    }
  }, {
    key: "_renderTopRightGrid",
    value: function _renderTopRightGrid(props) {
      const columnCount = props.columnCount,
        enableFixedRowScroll = props.enableFixedRowScroll,
        fixedColumnCount = props.fixedColumnCount,
        fixedRowCount = props.fixedRowCount,
        scrollLeft = props.scrollLeft,
        hideTopRightGridScrollbar = props.hideTopRightGridScrollbar;
      const _this$state5 = this.state,
        showHorizontalScrollbar = _this$state5.showHorizontalScrollbar,
        scrollbarSize = _this$state5.scrollbarSize;

      if (!fixedRowCount) {
        return null;
      }

      const additionalColumnCount = showHorizontalScrollbar ? 1 : 0,
        height = this._getTopGridHeight(props),
        width = this._getRightGridWidth(props),
        additionalHeight = showHorizontalScrollbar ? scrollbarSize : 0;

      let gridHeight = height,
        style = this._topRightGridStyle;

      if (hideTopRightGridScrollbar) {
        gridHeight = height + additionalHeight;
        style = _objectSpread({}, this._topRightGridStyle, {
          left: 0
        });
      }

      const topRightGrid = react__WEBPACK_IMPORTED_MODULE_10__.createElement(_Grid__WEBPACK_IMPORTED_MODULE_13__["default"], _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, props, {
        cellRenderer: this._cellRendererTopRightGrid,
        className: this.props.classNameTopRightGrid,
        columnCount: Math.max(0, columnCount - fixedColumnCount) + additionalColumnCount,
        columnWidth: this._columnWidthRightGrid,
        deferredMeasurementCache: this._deferredMeasurementCacheTopRightGrid,
        height: gridHeight,
        onScroll: enableFixedRowScroll ? this._onScrollLeft : undefined,
        ref: this._topRightGridRef,
        rowCount: fixedRowCount,
        scrollLeft: scrollLeft,
        style: style,
        tabIndex: null,
        width: width
      }));

      if (hideTopRightGridScrollbar) {
        return react__WEBPACK_IMPORTED_MODULE_10__.createElement("div", {
          className: "TopRightGrid_ScrollWrapper",
          style: _objectSpread({}, this._topRightGridStyle, {
            height: height,
            width: width,
            overflowX: 'hidden'
          })
        }, topRightGrid);
      }

      return topRightGrid;
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {
        return {
          scrollLeft: nextProps.scrollLeft != null && nextProps.scrollLeft >= 0 ? nextProps.scrollLeft : prevState.scrollLeft,
          scrollTop: nextProps.scrollTop != null && nextProps.scrollTop >= 0 ? nextProps.scrollTop : prevState.scrollTop
        };
      }

      return null;
    }
  }]);

  return MultiGrid;
}(react__WEBPACK_IMPORTED_MODULE_10__.PureComponent);

      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(MultiGrid, "defaultProps", {
        classNameBottomLeftGrid: '',
        classNameBottomRightGrid: '',
        classNameTopLeftGrid: '',
        classNameTopRightGrid: '',
        enableFixedColumnScroll: false,
        enableFixedRowScroll: false,
        fixedColumnCount: 0,
        fixedRowCount: 0,
        scrollToColumn: -1,
        scrollToRow: -1,
        style: {},
        styleBottomLeftGrid: {},
        styleBottomRightGrid: {},
        styleTopLeftGrid: {},
        styleTopRightGrid: {},
        hideTopRightGridScrollbar: false,
        hideBottomLeftGridScrollbar: false
      });

      MultiGrid.propTypes =  true ? {
        classNameBottomLeftGrid: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string).isRequired,
        classNameBottomRightGrid: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string).isRequired,
        classNameTopLeftGrid: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string).isRequired,
        classNameTopRightGrid: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().string).isRequired,
        enableFixedColumnScroll: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().bool).isRequired,
        enableFixedRowScroll: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().bool).isRequired,
        fixedColumnCount: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number).isRequired,
        fixedRowCount: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().number).isRequired,
        onScrollbarPresenceChange: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().func),
        style: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().object).isRequired,
        styleBottomLeftGrid: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().object).isRequired,
        styleBottomRightGrid: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().object).isRequired,
        styleTopLeftGrid: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().object).isRequired,
        styleTopRightGrid: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().object).isRequired,
        hideTopRightGridScrollbar: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().bool),
        hideBottomLeftGridScrollbar: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().bool)
      } : 0;
      (0,react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_11__.polyfill)(MultiGrid);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MultiGrid);

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/MultiGrid/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/MultiGrid/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiGrid: () => (/* reexport safe */ _MultiGrid__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MultiGrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MultiGrid */ "./node_modules/react-virtualized/dist/es/MultiGrid/MultiGrid.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_MultiGrid__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/ScrollSync/ScrollSync.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/ScrollSync/ScrollSync.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ScrollSync)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);








/**
 * HOC that simplifies the process of synchronizing scrolling between two or more virtualized components.
 */

      var ScrollSync =
/*#__PURE__*/
function (_React$PureComponent) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(ScrollSync, _React$PureComponent);

  function ScrollSync(props, context) {
    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, ScrollSync);

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(ScrollSync).call(this, props, context));
    _this.state = {
      clientHeight: 0,
      clientWidth: 0,
      scrollHeight: 0,
      scrollLeft: 0,
      scrollTop: 0,
      scrollWidth: 0
    };
    _this._onScroll = _this._onScroll.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this));
    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(ScrollSync, [{
    key: "render",
    value: function render() {
      const children = this.props.children;
      const _this$state = this.state,
        clientHeight = _this$state.clientHeight,
        clientWidth = _this$state.clientWidth,
        scrollHeight = _this$state.scrollHeight,
        scrollLeft = _this$state.scrollLeft,
        scrollTop = _this$state.scrollTop,
        scrollWidth = _this$state.scrollWidth;
      return children({
        clientHeight: clientHeight,
        clientWidth: clientWidth,
        onScroll: this._onScroll,
        scrollHeight: scrollHeight,
        scrollLeft: scrollLeft,
        scrollTop: scrollTop,
        scrollWidth: scrollWidth
      });
    }
  }, {
    key: "_onScroll",
    value: function _onScroll(_ref) {
      const clientHeight = _ref.clientHeight,
        clientWidth = _ref.clientWidth,
        scrollHeight = _ref.scrollHeight,
        scrollLeft = _ref.scrollLeft,
        scrollTop = _ref.scrollTop,
        scrollWidth = _ref.scrollWidth;
      this.setState({
        clientHeight: clientHeight,
        clientWidth: clientWidth,
        scrollHeight: scrollHeight,
        scrollLeft: scrollLeft,
        scrollTop: scrollTop,
        scrollWidth: scrollWidth
      });
    }
  }]);

  return ScrollSync;
}(react__WEBPACK_IMPORTED_MODULE_7__.PureComponent);


      ScrollSync.propTypes =  true ? {
  /**
   * Function responsible for rendering 2 or more virtualized components.
   * This function should implement the following signature:
   * ({ onScroll, scrollLeft, scrollTop }) => PropTypes.element
   */
        children: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().func).isRequired
      } : 0;

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/ScrollSync/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/ScrollSync/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScrollSync: () => (/* reexport safe */ _ScrollSync__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ScrollSync__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ScrollSync */ "./node_modules/react-virtualized/dist/es/ScrollSync/ScrollSync.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_ScrollSync__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Table/Column.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Table/Column.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Column)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const _defaultHeaderRenderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./defaultHeaderRenderer */ "./node_modules/react-virtualized/dist/es/Table/defaultHeaderRenderer.js");
/* harmony import */ const _defaultCellRenderer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./defaultCellRenderer */ "./node_modules/react-virtualized/dist/es/Table/defaultCellRenderer.js");
/* harmony import */ const _defaultCellDataGetter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./defaultCellDataGetter */ "./node_modules/react-virtualized/dist/es/Table/defaultCellDataGetter.js");
/* harmony import */ const _SortDirection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./SortDirection */ "./node_modules/react-virtualized/dist/es/Table/SortDirection.js");











/**
 * Describes the header and cell contents of a table column.
 */

      var Column =
/*#__PURE__*/
function (_React$Component) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(Column, _React$Component);

  function Column() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, Column);

    return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1___default()(this, _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2___default()(Column).apply(this, arguments));
  }

  return Column;
}(react__WEBPACK_IMPORTED_MODULE_6__.Component);

      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_4___default()(Column, "defaultProps", {
        cellDataGetter: _defaultCellDataGetter__WEBPACK_IMPORTED_MODULE_9__["default"],
        cellRenderer: _defaultCellRenderer__WEBPACK_IMPORTED_MODULE_8__["default"],
        defaultSortDirection: _SortDirection__WEBPACK_IMPORTED_MODULE_10__["default"].ASC,
        flexGrow: 0,
        flexShrink: 1,
        headerRenderer: _defaultHeaderRenderer__WEBPACK_IMPORTED_MODULE_7__["default"],
        style: {}
      });


      Column.propTypes =  true ? {
  /** Optional aria-label value to set on the column header */
        'aria-label': (prop_types__WEBPACK_IMPORTED_MODULE_5___default().string),

  /**
   * Callback responsible for returning a cell's data, given its :dataKey
   * ({ columnData: any, dataKey: string, rowData: any }): any
   */
        cellDataGetter: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().func),

  /**
   * Callback responsible for rendering a cell's contents.
   * ({ cellData: any, columnData: any, dataKey: string, rowData: any, rowIndex: number }): node
   */
        cellRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().func),

  /** Optional CSS class to apply to cell */
        className: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().string),

  /** Optional additional data passed to this column's :cellDataGetter */
        columnData: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().object),

  /** Uniquely identifies the row-data attribute corresponding to this cell */
        dataKey: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().any).isRequired,

  /** Optional direction to be used when clicked the first time */
        defaultSortDirection: prop_types__WEBPACK_IMPORTED_MODULE_5___default().oneOf([_SortDirection__WEBPACK_IMPORTED_MODULE_10__["default"].ASC, _SortDirection__WEBPACK_IMPORTED_MODULE_10__["default"].DESC]),

  /** If sort is enabled for the table at large, disable it for this column */
        disableSort: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().bool),

  /** Flex grow style; defaults to 0 */
        flexGrow: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().number),

  /** Flex shrink style; defaults to 1 */
        flexShrink: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().number),

  /** Optional CSS class to apply to this column's header */
        headerClassName: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().string),

  /**
   * Optional callback responsible for rendering a column header contents.
   * ({ columnData: object, dataKey: string, disableSort: boolean, label: node, sortBy: string, sortDirection: string }): PropTypes.node
   */
        headerRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().func).isRequired,

  /** Optional inline style to apply to this column's header */
        headerStyle: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().object),

  /** Optional id to set on the column header */
        id: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().string),

  /** Header label for this column */
        label: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().node),

  /** Maximum width of column; this property will only be used if :flexGrow is > 0. */
        maxWidth: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().number),

  /** Minimum width of column. */
        minWidth: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().number),

  /** Optional inline style to apply to cell */
        style: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().object),

  /** Flex basis (width) for this column; This value can grow or shrink based on :flexGrow and :flexShrink properties. */
        width: (prop_types__WEBPACK_IMPORTED_MODULE_5___default().number).isRequired
      } : 0;

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Table/SortDirection.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Table/SortDirection.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
      const SortDirection = {
  /**
   * Sort items in ascending order.
   * This means arranging from the lowest value to the highest (e.g. a-z, 0-9).
   */
        ASC: 'ASC',

  /**
   * Sort items in descending order.
   * This means arranging from the highest value to the lowest (e.g. z-a, 9-0).
   */
        DESC: 'DESC'
      };
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SortDirection);

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Table/SortIndicator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Table/SortIndicator.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SortIndicator)
/* harmony export */ });
/* harmony import */ const clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _SortDirection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SortDirection */ "./node_modules/react-virtualized/dist/es/Table/SortDirection.js");




/**
 * Displayed beside a header to indicate that a Table is currently sorted by this column.
 */

      function SortIndicator(_ref) {
        const sortDirection = _ref.sortDirection;
        const classNames = (0,clsx__WEBPACK_IMPORTED_MODULE_0__["default"])('ReactVirtualized__Table__sortableHeaderIcon', {
          'ReactVirtualized__Table__sortableHeaderIcon--ASC': sortDirection === _SortDirection__WEBPACK_IMPORTED_MODULE_3__["default"].ASC,
          'ReactVirtualized__Table__sortableHeaderIcon--DESC': sortDirection === _SortDirection__WEBPACK_IMPORTED_MODULE_3__["default"].DESC
        });
        return react__WEBPACK_IMPORTED_MODULE_2__.createElement("svg", {
          className: classNames,
          width: 18,
          height: 18,
          viewBox: "0 0 24 24"
        }, sortDirection === _SortDirection__WEBPACK_IMPORTED_MODULE_3__["default"].ASC ? react__WEBPACK_IMPORTED_MODULE_2__.createElement("path", {
          d: "M7 14l5-5 5 5z"
        }) : react__WEBPACK_IMPORTED_MODULE_2__.createElement("path", {
          d: "M7 10l5 5 5-5z"
        }), react__WEBPACK_IMPORTED_MODULE_2__.createElement("path", {
          d: "M0 0h24v24H0z",
          fill: "none"
        }));
      }
      SortIndicator.propTypes =  true ? {
        sortDirection: prop_types__WEBPACK_IMPORTED_MODULE_1___default().oneOf([_SortDirection__WEBPACK_IMPORTED_MODULE_3__["default"].ASC, _SortDirection__WEBPACK_IMPORTED_MODULE_3__["default"].DESC])
      } : 0;

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Table/Table.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Table/Table.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Table)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends/index.js");
/* harmony import */ const _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ const clsx__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ const _Column__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Column */ "./node_modules/react-virtualized/dist/es/Table/Column.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ const react_dom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ const react_dom__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ const _Grid__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../Grid */ "./node_modules/react-virtualized/dist/es/Grid/index.js");
/* harmony import */ const _defaultRowRenderer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./defaultRowRenderer */ "./node_modules/react-virtualized/dist/es/Table/defaultRowRenderer.js");
/* harmony import */ const _defaultHeaderRowRenderer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./defaultHeaderRowRenderer */ "./node_modules/react-virtualized/dist/es/Table/defaultHeaderRowRenderer.js");
/* harmony import */ const _SortDirection__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./SortDirection */ "./node_modules/react-virtualized/dist/es/Table/SortDirection.js");









      function ownKeys(object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function _objectSpread(target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }










/**
 * Table component with fixed headers and virtualized rows for improved performance with large data sets.
 * This component expects explicit width, height, and padding parameters.
 */

      var Table =
/*#__PURE__*/
function (_React$PureComponent) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default()(Table, _React$PureComponent);

  function Table(props) {
    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Table);

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Table).call(this, props));
    _this.state = {
      scrollbarWidth: 0
    };
    _this._createColumn = _this._createColumn.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this));
    _this._createRow = _this._createRow.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this));
    _this._onScroll = _this._onScroll.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this));
    _this._onSectionRendered = _this._onSectionRendered.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this));
    _this._setRef = _this._setRef.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5___default()(_this));
    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Table, [{
    key: "forceUpdateGrid",
    value: function forceUpdateGrid() {
      if (this.Grid) {
        this.Grid.forceUpdate();
      }
    }
    /** See Grid#getOffsetForCell */

  }, {
    key: "getOffsetForRow",
    value: function getOffsetForRow(_ref) {
      const alignment = _ref.alignment,
        index = _ref.index;

      if (this.Grid) {
        const _this$Grid$getOffsetF = this.Grid.getOffsetForCell({
            alignment: alignment,
            rowIndex: index
          }),
          scrollTop = _this$Grid$getOffsetF.scrollTop;

        return scrollTop;
      }

      return 0;
    }
    /** CellMeasurer compatibility */

  }, {
    key: "invalidateCellSizeAfterRender",
    value: function invalidateCellSizeAfterRender(_ref2) {
      const columnIndex = _ref2.columnIndex,
        rowIndex = _ref2.rowIndex;

      if (this.Grid) {
        this.Grid.invalidateCellSizeAfterRender({
          rowIndex: rowIndex,
          columnIndex: columnIndex
        });
      }
    }
    /** See Grid#measureAllCells */

  }, {
    key: "measureAllRows",
    value: function measureAllRows() {
      if (this.Grid) {
        this.Grid.measureAllCells();
      }
    }
    /** CellMeasurer compatibility */

  }, {
    key: "recomputeGridSize",
    value: function recomputeGridSize() {
      const _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$columnIndex = _ref3.columnIndex,
        columnIndex = _ref3$columnIndex === void 0 ? 0 : _ref3$columnIndex,
        _ref3$rowIndex = _ref3.rowIndex,
        rowIndex = _ref3$rowIndex === void 0 ? 0 : _ref3$rowIndex;

      if (this.Grid) {
        this.Grid.recomputeGridSize({
          rowIndex: rowIndex,
          columnIndex: columnIndex
        });
      }
    }
    /** See Grid#recomputeGridSize */

  }, {
    key: "recomputeRowHeights",
    value: function recomputeRowHeights() {
      const index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.Grid) {
        this.Grid.recomputeGridSize({
          rowIndex: index
        });
      }
    }
    /** See Grid#scrollToPosition */

  }, {
    key: "scrollToPosition",
    value: function scrollToPosition() {
      const scrollTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.Grid) {
        this.Grid.scrollToPosition({
          scrollTop: scrollTop
        });
      }
    }
    /** See Grid#scrollToCell */

  }, {
    key: "scrollToRow",
    value: function scrollToRow() {
      const index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.Grid) {
        this.Grid.scrollToCell({
          columnIndex: 0,
          rowIndex: index
        });
      }
    }
  }, {
    key: "getScrollbarWidth",
    value: function getScrollbarWidth() {
      if (this.Grid) {
        const _Grid = (0,react_dom__WEBPACK_IMPORTED_MODULE_12__.findDOMNode)(this.Grid);

        const clientWidth = _Grid.clientWidth || 0;
        const offsetWidth = _Grid.offsetWidth || 0;
        return offsetWidth - clientWidth;
      }

      return 0;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this._setScrollbarWidth();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this._setScrollbarWidth();
    }
  }, {
    key: "render",
    value: function render() {
      const _this2 = this;

      const _this$props = this.props,
        children = _this$props.children,
        className = _this$props.className,
        disableHeader = _this$props.disableHeader,
        gridClassName = _this$props.gridClassName,
        gridStyle = _this$props.gridStyle,
        headerHeight = _this$props.headerHeight,
        headerRowRenderer = _this$props.headerRowRenderer,
        height = _this$props.height,
        id = _this$props.id,
        noRowsRenderer = _this$props.noRowsRenderer,
        rowClassName = _this$props.rowClassName,
        rowStyle = _this$props.rowStyle,
        scrollToIndex = _this$props.scrollToIndex,
        style = _this$props.style,
        width = _this$props.width;
      const scrollbarWidth = this.state.scrollbarWidth;
      const availableRowsHeight = disableHeader ? height : height - headerHeight;
      const rowClass = typeof rowClassName === 'function' ? rowClassName({
        index: -1
      }) : rowClassName;
      const rowStyleObject = typeof rowStyle === 'function' ? rowStyle({
        index: -1
      }) : rowStyle; // Precompute and cache column styles before rendering rows and columns to speed things up

      this._cachedColumnStyles = [];
      react__WEBPACK_IMPORTED_MODULE_11__.Children.toArray(children).forEach(function (column, index) {
        const flexStyles = _this2._getFlexStyleForColumn(column, column.props.style);

        _this2._cachedColumnStyles[index] = _objectSpread({
          overflow: 'hidden'
        }, flexStyles);
      }); // Note that we specify :rowCount, :scrollbarWidth, :sortBy, and :sortDirection as properties on Grid even though these have nothing to do with Grid.
      // This is done because Grid is a pure component and won't update unless its properties or state has changed.
      // Any property that should trigger a re-render of Grid then is specified here to avoid a stale display.

      return react__WEBPACK_IMPORTED_MODULE_11__.createElement("div", {
        "aria-label": this.props['aria-label'],
        "aria-labelledby": this.props['aria-labelledby'],
        "aria-colcount": react__WEBPACK_IMPORTED_MODULE_11__.Children.toArray(children).length,
        "aria-rowcount": this.props.rowCount,
        className: (0,clsx__WEBPACK_IMPORTED_MODULE_8__["default"])('ReactVirtualized__Table', className),
        id: id,
        role: "grid",
        style: style
      }, !disableHeader && headerRowRenderer({
        className: (0,clsx__WEBPACK_IMPORTED_MODULE_8__["default"])('ReactVirtualized__Table__headerRow', rowClass),
        columns: this._getHeaderColumns(),
        style: _objectSpread({
          height: headerHeight,
          overflow: 'hidden',
          paddingRight: scrollbarWidth,
          width: width
        }, rowStyleObject)
      }), react__WEBPACK_IMPORTED_MODULE_11__.createElement(_Grid__WEBPACK_IMPORTED_MODULE_13__["default"], _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, this.props, {
        "aria-readonly": null,
        autoContainerWidth: true,
        className: (0,clsx__WEBPACK_IMPORTED_MODULE_8__["default"])('ReactVirtualized__Table__Grid', gridClassName),
        cellRenderer: this._createRow,
        columnWidth: width,
        columnCount: 1,
        height: availableRowsHeight,
        id: undefined,
        noContentRenderer: noRowsRenderer,
        onScroll: this._onScroll,
        onSectionRendered: this._onSectionRendered,
        ref: this._setRef,
        role: "rowgroup",
        scrollbarWidth: scrollbarWidth,
        scrollToRow: scrollToIndex,
        style: _objectSpread({}, gridStyle, {
          overflowX: 'hidden'
        })
      })));
    }
  }, {
    key: "_createColumn",
    value: function _createColumn(_ref4) {
      const column = _ref4.column,
        columnIndex = _ref4.columnIndex,
        isScrolling = _ref4.isScrolling,
        parent = _ref4.parent,
        rowData = _ref4.rowData,
        rowIndex = _ref4.rowIndex;
      const onColumnClick = this.props.onColumnClick;
      const _column$props = column.props,
        cellDataGetter = _column$props.cellDataGetter,
        cellRenderer = _column$props.cellRenderer,
        className = _column$props.className,
        columnData = _column$props.columnData,
        dataKey = _column$props.dataKey,
        id = _column$props.id;
      const cellData = cellDataGetter({
        columnData: columnData,
        dataKey: dataKey,
        rowData: rowData
      });
      const renderedCell = cellRenderer({
        cellData: cellData,
        columnData: columnData,
        columnIndex: columnIndex,
        dataKey: dataKey,
        isScrolling: isScrolling,
        parent: parent,
        rowData: rowData,
        rowIndex: rowIndex
      });

      const onClick = function onClick(event) {
        onColumnClick && onColumnClick({
          columnData: columnData,
          dataKey: dataKey,
          event: event
        });
      };

      const style = this._cachedColumnStyles[columnIndex];
      const title = typeof renderedCell === 'string' ? renderedCell : null; // Avoid using object-spread syntax with multiple objects here,
      // Since it results in an extra method call to 'babel-runtime/helpers/extends'
      // See PR https://github.com/bvaughn/react-virtualized/pull/942

      return react__WEBPACK_IMPORTED_MODULE_11__.createElement("div", {
        "aria-colindex": columnIndex + 1,
        "aria-describedby": id,
        className: (0,clsx__WEBPACK_IMPORTED_MODULE_8__["default"])('ReactVirtualized__Table__rowColumn', className),
        key: 'Row' + rowIndex + '-' + 'Col' + columnIndex,
        onClick: onClick,
        role: "gridcell",
        style: style,
        title: title
      }, renderedCell);
    }
  }, {
    key: "_createHeader",
    value: function _createHeader(_ref5) {
      const column = _ref5.column,
        index = _ref5.index;
      const _this$props2 = this.props,
        headerClassName = _this$props2.headerClassName,
        headerStyle = _this$props2.headerStyle,
        onHeaderClick = _this$props2.onHeaderClick,
        sort = _this$props2.sort,
        sortBy = _this$props2.sortBy,
        sortDirection = _this$props2.sortDirection;
      const _column$props2 = column.props,
        columnData = _column$props2.columnData,
        dataKey = _column$props2.dataKey,
        defaultSortDirection = _column$props2.defaultSortDirection,
        disableSort = _column$props2.disableSort,
        headerRenderer = _column$props2.headerRenderer,
        id = _column$props2.id,
        label = _column$props2.label;
      const sortEnabled = !disableSort && sort;
      const classNames = (0,clsx__WEBPACK_IMPORTED_MODULE_8__["default"])('ReactVirtualized__Table__headerColumn', headerClassName, column.props.headerClassName, {
        ReactVirtualized__Table__sortableHeaderColumn: sortEnabled
      });

      const style = this._getFlexStyleForColumn(column, _objectSpread({}, headerStyle, {}, column.props.headerStyle));

      const renderedHeader = headerRenderer({
        columnData: columnData,
        dataKey: dataKey,
        disableSort: disableSort,
        label: label,
        sortBy: sortBy,
        sortDirection: sortDirection
      });
      let headerOnClick, headerOnKeyDown, headerTabIndex, headerAriaSort, headerAriaLabel;

      if (sortEnabled || onHeaderClick) {
        // If this is a sortable header, clicking it should update the table data's sorting.
        const isFirstTimeSort = sortBy !== dataKey; // If this is the firstTime sort of this column, use the column default sort order.
        // Otherwise, invert the direction of the sort.

        const newSortDirection = isFirstTimeSort ? defaultSortDirection : sortDirection === _SortDirection__WEBPACK_IMPORTED_MODULE_16__["default"].DESC ? _SortDirection__WEBPACK_IMPORTED_MODULE_16__["default"].ASC : _SortDirection__WEBPACK_IMPORTED_MODULE_16__["default"].DESC;

        const onClick = function onClick(event) {
          sortEnabled && sort({
            defaultSortDirection: defaultSortDirection,
            event: event,
            sortBy: dataKey,
            sortDirection: newSortDirection
          });
          onHeaderClick && onHeaderClick({
            columnData: columnData,
            dataKey: dataKey,
            event: event
          });
        };

        const onKeyDown = function onKeyDown(event) {
          if (event.key === 'Enter' || event.key === ' ') {
            onClick(event);
          }
        };

        headerAriaLabel = column.props['aria-label'] || label || dataKey;
        headerAriaSort = 'none';
        headerTabIndex = 0;
        headerOnClick = onClick;
        headerOnKeyDown = onKeyDown;
      }

      if (sortBy === dataKey) {
        headerAriaSort = sortDirection === _SortDirection__WEBPACK_IMPORTED_MODULE_16__["default"].ASC ? 'ascending' : 'descending';
      } // Avoid using object-spread syntax with multiple objects here,
      // Since it results in an extra method call to 'babel-runtime/helpers/extends'
      // See PR https://github.com/bvaughn/react-virtualized/pull/942


      return react__WEBPACK_IMPORTED_MODULE_11__.createElement("div", {
        "aria-label": headerAriaLabel,
        "aria-sort": headerAriaSort,
        className: classNames,
        id: id,
        key: 'Header-Col' + index,
        onClick: headerOnClick,
        onKeyDown: headerOnKeyDown,
        role: "columnheader",
        style: style,
        tabIndex: headerTabIndex
      }, renderedHeader);
    }
  }, {
    key: "_createRow",
    value: function _createRow(_ref6) {
      const _this3 = this;

      const index = _ref6.rowIndex,
        isScrolling = _ref6.isScrolling,
        key = _ref6.key,
        parent = _ref6.parent,
        style = _ref6.style;
      const _this$props3 = this.props,
        children = _this$props3.children,
        onRowClick = _this$props3.onRowClick,
        onRowDoubleClick = _this$props3.onRowDoubleClick,
        onRowRightClick = _this$props3.onRowRightClick,
        onRowMouseOver = _this$props3.onRowMouseOver,
        onRowMouseOut = _this$props3.onRowMouseOut,
        rowClassName = _this$props3.rowClassName,
        rowGetter = _this$props3.rowGetter,
        rowRenderer = _this$props3.rowRenderer,
        rowStyle = _this$props3.rowStyle;
      const scrollbarWidth = this.state.scrollbarWidth;
      const rowClass = typeof rowClassName === 'function' ? rowClassName({
        index: index
      }) : rowClassName;
      const rowStyleObject = typeof rowStyle === 'function' ? rowStyle({
        index: index
      }) : rowStyle;
      const rowData = rowGetter({
        index: index
      });
      const columns = react__WEBPACK_IMPORTED_MODULE_11__.Children.toArray(children).map(function (column, columnIndex) {
        return _this3._createColumn({
          column: column,
          columnIndex: columnIndex,
          isScrolling: isScrolling,
          parent: parent,
          rowData: rowData,
          rowIndex: index,
          scrollbarWidth: scrollbarWidth
        });
      });
      const className = (0,clsx__WEBPACK_IMPORTED_MODULE_8__["default"])('ReactVirtualized__Table__row', rowClass);

      const flattenedStyle = _objectSpread({}, style, {
        height: this._getRowHeight(index),
        overflow: 'hidden',
        paddingRight: scrollbarWidth
      }, rowStyleObject);

      return rowRenderer({
        className: className,
        columns: columns,
        index: index,
        isScrolling: isScrolling,
        key: key,
        onRowClick: onRowClick,
        onRowDoubleClick: onRowDoubleClick,
        onRowRightClick: onRowRightClick,
        onRowMouseOver: onRowMouseOver,
        onRowMouseOut: onRowMouseOut,
        rowData: rowData,
        style: flattenedStyle
      });
    }
    /**
     * Determines the flex-shrink, flex-grow, and width values for a cell (header or column).
     */

  }, {
    key: "_getFlexStyleForColumn",
    value: function _getFlexStyleForColumn(column) {
      const customStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const flexValue = "".concat(column.props.flexGrow, " ").concat(column.props.flexShrink, " ").concat(column.props.width, "px");

      const style = _objectSpread({}, customStyle, {
        flex: flexValue,
        msFlex: flexValue,
        WebkitFlex: flexValue
      });

      if (column.props.maxWidth) {
        style.maxWidth = column.props.maxWidth;
      }

      if (column.props.minWidth) {
        style.minWidth = column.props.minWidth;
      }

      return style;
    }
  }, {
    key: "_getHeaderColumns",
    value: function _getHeaderColumns() {
      const _this4 = this;

      const _this$props4 = this.props,
        children = _this$props4.children,
        disableHeader = _this$props4.disableHeader;
      const items = disableHeader ? [] : react__WEBPACK_IMPORTED_MODULE_11__.Children.toArray(children);
      return items.map(function (column, index) {
        return _this4._createHeader({
          column: column,
          index: index
        });
      });
    }
  }, {
    key: "_getRowHeight",
    value: function _getRowHeight(rowIndex) {
      const rowHeight = this.props.rowHeight;
      return typeof rowHeight === 'function' ? rowHeight({
        index: rowIndex
      }) : rowHeight;
    }
  }, {
    key: "_onScroll",
    value: function _onScroll(_ref7) {
      const clientHeight = _ref7.clientHeight,
        scrollHeight = _ref7.scrollHeight,
        scrollTop = _ref7.scrollTop;
      const onScroll = this.props.onScroll;
      onScroll({
        clientHeight: clientHeight,
        scrollHeight: scrollHeight,
        scrollTop: scrollTop
      });
    }
  }, {
    key: "_onSectionRendered",
    value: function _onSectionRendered(_ref8) {
      const rowOverscanStartIndex = _ref8.rowOverscanStartIndex,
        rowOverscanStopIndex = _ref8.rowOverscanStopIndex,
        rowStartIndex = _ref8.rowStartIndex,
        rowStopIndex = _ref8.rowStopIndex;
      const onRowsRendered = this.props.onRowsRendered;
      onRowsRendered({
        overscanStartIndex: rowOverscanStartIndex,
        overscanStopIndex: rowOverscanStopIndex,
        startIndex: rowStartIndex,
        stopIndex: rowStopIndex
      });
    }
  }, {
    key: "_setRef",
    value: function _setRef(ref) {
      this.Grid = ref;
    }
  }, {
    key: "_setScrollbarWidth",
    value: function _setScrollbarWidth() {
      const scrollbarWidth = this.getScrollbarWidth();
      this.setState({
        scrollbarWidth: scrollbarWidth
      });
    }
  }]);

  return Table;
}(react__WEBPACK_IMPORTED_MODULE_11__.PureComponent);

      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7___default()(Table, "defaultProps", {
        disableHeader: false,
        estimatedRowSize: 30,
        headerHeight: 0,
        headerStyle: {},
        noRowsRenderer: function noRowsRenderer() {
          return null;
        },
        onRowsRendered: function onRowsRendered() {
          return null;
        },
        onScroll: function onScroll() {
          return null;
        },
        overscanIndicesGetter: _Grid__WEBPACK_IMPORTED_MODULE_13__.accessibilityOverscanIndicesGetter,
        overscanRowCount: 10,
        rowRenderer: _defaultRowRenderer__WEBPACK_IMPORTED_MODULE_14__["default"],
        headerRowRenderer: _defaultHeaderRowRenderer__WEBPACK_IMPORTED_MODULE_15__["default"],
        rowStyle: {},
        scrollToAlignment: 'auto',
        scrollToIndex: -1,
        style: {}
      });


      Table.propTypes =  true ? {
  /** This is just set on the grid top element. */
        'aria-label': (prop_types__WEBPACK_IMPORTED_MODULE_10___default().string),

  /** This is just set on the grid top element. */
        'aria-labelledby': (prop_types__WEBPACK_IMPORTED_MODULE_10___default().string),

  /**
   * Removes fixed height from the scrollingContainer so that the total height
   * of rows can stretch the window. Intended for use with WindowScroller
   */
        autoHeight: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().bool),

  /** One or more Columns describing the data displayed in this row */
        children: function children(props) {
          const children = react__WEBPACK_IMPORTED_MODULE_11__.Children.toArray(props.children);

          for (let i = 0; i < children.length; i++) {
            const childType = children[i].type;

            if (childType !== _Column__WEBPACK_IMPORTED_MODULE_9__["default"] && !(childType.prototype instanceof _Column__WEBPACK_IMPORTED_MODULE_9__["default"])) {
              return new Error('Table only accepts children of type Column');
            }
          }
        },

  /** Optional CSS class name */
        className: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().string),

  /** Disable rendering the header at all */
        disableHeader: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().bool),

  /**
   * Used to estimate the total height of a Table before all of its rows have actually been measured.
   * The estimated total height is adjusted as rows are rendered.
   */
        estimatedRowSize: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().number).isRequired,

  /** Optional custom CSS class name to attach to inner Grid element. */
        gridClassName: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().string),

  /** Optional inline style to attach to inner Grid element. */
        gridStyle: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().object),

  /** Optional CSS class to apply to all column headers */
        headerClassName: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().string),

  /** Fixed height of header row */
        headerHeight: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().number).isRequired,

  /**
   * Responsible for rendering a table row given an array of columns:
   * Should implement the following interface: ({
   *   className: string,
   *   columns: any[],
   *   style: any
   * }): PropTypes.node
   */
        headerRowRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func),

  /** Optional custom inline style to attach to table header columns. */
        headerStyle: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().object),

  /** Fixed/available height for out DOM element */
        height: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().number).isRequired,

  /** Optional id */
        id: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().string),

  /** Optional renderer to be used in place of table body rows when rowCount is 0 */
        noRowsRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func),

  /**
   * Optional callback when a column is clicked.
   * ({ columnData: any, dataKey: string }): void
   */
        onColumnClick: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func),

  /**
   * Optional callback when a column's header is clicked.
   * ({ columnData: any, dataKey: string }): void
   */
        onHeaderClick: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func),

  /**
   * Callback invoked when a user clicks on a table row.
   * ({ index: number }): void
   */
        onRowClick: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func),

  /**
   * Callback invoked when a user double-clicks on a table row.
   * ({ index: number }): void
   */
        onRowDoubleClick: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func),

  /**
   * Callback invoked when the mouse leaves a table row.
   * ({ index: number }): void
   */
        onRowMouseOut: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func),

  /**
   * Callback invoked when a user moves the mouse over a table row.
   * ({ index: number }): void
   */
        onRowMouseOver: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func),

  /**
   * Callback invoked when a user right-clicks on a table row.
   * ({ index: number }): void
   */
        onRowRightClick: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func),

  /**
   * Callback invoked with information about the slice of rows that were just rendered.
   * ({ startIndex, stopIndex }): void
   */
        onRowsRendered: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func),

  /**
   * Callback invoked whenever the scroll offset changes within the inner scrollable region.
   * This callback can be used to sync scrolling between lists, tables, or grids.
   * ({ clientHeight, scrollHeight, scrollTop }): void
   */
        onScroll: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func).isRequired,

  /** See Grid#overscanIndicesGetter */
        overscanIndicesGetter: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func).isRequired,

  /**
   * Number of rows to render above/below the visible bounds of the list.
   * These rows can help for smoother scrolling on touch devices.
   */
        overscanRowCount: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().number).isRequired,

  /**
   * Optional CSS class to apply to all table rows (including the header row).
   * This property can be a CSS class name (string) or a function that returns a class name.
   * If a function is provided its signature should be: ({ index: number }): string
   */
        rowClassName: prop_types__WEBPACK_IMPORTED_MODULE_10___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_10___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func)]),

  /**
   * Callback responsible for returning a data row given an index.
   * ({ index: number }): any
   */
        rowGetter: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func).isRequired,

  /**
   * Either a fixed row height (number) or a function that returns the height of a row given its index.
   * ({ index: number }): number
   */
        rowHeight: prop_types__WEBPACK_IMPORTED_MODULE_10___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_10___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func)]).isRequired,

  /** Number of rows in table. */
        rowCount: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().number).isRequired,

  /**
   * Responsible for rendering a table row given an array of columns:
   * Should implement the following interface: ({
   *   className: string,
   *   columns: Array,
   *   index: number,
   *   isScrolling: boolean,
   *   onRowClick: ?Function,
   *   onRowDoubleClick: ?Function,
   *   onRowMouseOver: ?Function,
   *   onRowMouseOut: ?Function,
   *   rowData: any,
   *   style: any
   * }): PropTypes.node
   */
        rowRenderer: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func),

  /** Optional custom inline style to attach to table rows. */
        rowStyle: prop_types__WEBPACK_IMPORTED_MODULE_10___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_10___default().object), (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func)]).isRequired,

  /** See Grid#scrollToAlignment */
        scrollToAlignment: prop_types__WEBPACK_IMPORTED_MODULE_10___default().oneOf(['auto', 'end', 'start', 'center']).isRequired,

  /** Row index to ensure visible (by forcefully scrolling if necessary) */
        scrollToIndex: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().number).isRequired,

  /** Vertical offset. */
        scrollTop: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().number),

  /**
   * Sort function to be called if a sortable header is clicked.
   * Should implement the following interface: ({
   *   defaultSortDirection: 'ASC' | 'DESC',
   *   event: MouseEvent,
   *   sortBy: string,
   *   sortDirection: SortDirection
   * }): void
   */
        sort: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().func),

  /** Table data is currently sorted by this :dataKey (if it is sorted at all) */
        sortBy: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().string),

  /** Table data is currently sorted in this direction (if it is sorted at all) */
        sortDirection: prop_types__WEBPACK_IMPORTED_MODULE_10___default().oneOf([_SortDirection__WEBPACK_IMPORTED_MODULE_16__["default"].ASC, _SortDirection__WEBPACK_IMPORTED_MODULE_16__["default"].DESC]),

  /** Optional inline style */
        style: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().object),

  /** Tab index for focus */
        tabIndex: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().number),

  /** Width of list */
        width: (prop_types__WEBPACK_IMPORTED_MODULE_10___default().number).isRequired
      } : 0;


/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Table/createMultiSort.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Table/createMultiSort.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createMultiSort)
/* harmony export */ });
      function createMultiSort(sortCallback) {
        const _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          defaultSortBy = _ref.defaultSortBy,
          _ref$defaultSortDirec = _ref.defaultSortDirection,
          defaultSortDirection = _ref$defaultSortDirec === void 0 ? {} : _ref$defaultSortDirec;

        if (!sortCallback) {
          throw Error("Required parameter \"sortCallback\" not specified");
        }

        const sortBy = defaultSortBy || [];
        const sortDirection = {};
        sortBy.forEach(function (dataKey) {
          sortDirection[dataKey] = defaultSortDirection[dataKey] !== undefined ? defaultSortDirection[dataKey] : 'ASC';
        });

        function sort(_ref2) {
          const defaultSortDirection = _ref2.defaultSortDirection,
            event = _ref2.event,
            dataKey = _ref2.sortBy;

          if (event.shiftKey) {
      // Shift + click appends a column to existing criteria
            if (sortDirection[dataKey] !== undefined) {
              sortDirection[dataKey] = sortDirection[dataKey] === 'ASC' ? 'DESC' : 'ASC';
            } else {
              sortDirection[dataKey] = defaultSortDirection;
              sortBy.push(dataKey);
            }
          } else if (event.ctrlKey || event.metaKey) {
      // Control + click removes column from sort (if pressent)
            const index = sortBy.indexOf(dataKey);

            if (index >= 0) {
              sortBy.splice(index, 1);
              delete sortDirection[dataKey];
            }
          } else {
      // Clear sortBy array of all non-selected keys
            sortBy.length = 0;
            sortBy.push(dataKey); // Clear sortDirection object of all non-selected keys

            const sortDirectionKeys = Object.keys(sortDirection);
            sortDirectionKeys.forEach(function (key) {
              if (key !== dataKey) delete sortDirection[key];
            }); // If key is already selected, reverse sort direction.
      // Else, set sort direction to default direction.

            if (sortDirection[dataKey] !== undefined) {
              sortDirection[dataKey] = sortDirection[dataKey] === 'ASC' ? 'DESC' : 'ASC';
            } else {
              sortDirection[dataKey] = defaultSortDirection;
            }
          } // Notify application code


          sortCallback({
            sortBy: sortBy,
            sortDirection: sortDirection
          });
        }

        return {
          sort: sort,
          sortBy: sortBy,
          sortDirection: sortDirection
        };
      }

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Table/defaultCellDataGetter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Table/defaultCellDataGetter.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultCellDataGetter)
/* harmony export */ });
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/Table/types.js");
/**
 * Default accessor for returning a cell value for a given attribute.
 * This function expects to operate on either a vanilla Object or an Immutable Map.
 * You should override the column's cellDataGetter if your data is some other type of object.
 */
      function defaultCellDataGetter(_ref) {
        const dataKey = _ref.dataKey,
          rowData = _ref.rowData;

        if (typeof rowData.get === 'function') {
          return rowData.get(dataKey);
        } else {
          return rowData[dataKey];
        }
      }


/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Table/defaultCellRenderer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Table/defaultCellRenderer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultCellRenderer)
/* harmony export */ });
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/Table/types.js");
/**
 * Default cell renderer that displays an attribute as a simple string
 * You should override the column's cellRenderer if your data is some other type of object.
 */
      function defaultCellRenderer(_ref) {
        const cellData = _ref.cellData;

        if (cellData == null) {
          return '';
        } else {
          return String(cellData);
        }
      }


/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Table/defaultHeaderRenderer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Table/defaultHeaderRenderer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultHeaderRenderer)
/* harmony export */ });
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _SortIndicator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SortIndicator */ "./node_modules/react-virtualized/dist/es/Table/SortIndicator.js");
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/Table/types.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);



/**
 * Default table header renderer.
 */
      function defaultHeaderRenderer(_ref) {
        const dataKey = _ref.dataKey,
          label = _ref.label,
          sortBy = _ref.sortBy,
          sortDirection = _ref.sortDirection;
        const showSortIndicator = sortBy === dataKey;
        const children = [react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
          className: "ReactVirtualized__Table__headerTruncatedText",
          key: "label",
          title: typeof label === 'string' ? label : null
        }, label)];

        if (showSortIndicator) {
          children.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(_SortIndicator__WEBPACK_IMPORTED_MODULE_1__["default"], {
            key: "SortIndicator",
            sortDirection: sortDirection
          }));
        }

        return children;
      }
      defaultHeaderRenderer.propTypes =  false ? 0 : _types__WEBPACK_IMPORTED_MODULE_2__.bpfrpt_proptype_HeaderRendererParams === (prop_types__WEBPACK_IMPORTED_MODULE_3___default().any) ? {} : _types__WEBPACK_IMPORTED_MODULE_2__.bpfrpt_proptype_HeaderRendererParams;



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Table/defaultHeaderRowRenderer.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Table/defaultHeaderRowRenderer.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultHeaderRowRenderer)
/* harmony export */ });
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/Table/types.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);

      function defaultHeaderRowRenderer(_ref) {
        const className = _ref.className,
          columns = _ref.columns,
          style = _ref.style;
        return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
          className: className,
          role: "row",
          style: style
        }, columns);
      }
      defaultHeaderRowRenderer.propTypes =  false ? 0 : _types__WEBPACK_IMPORTED_MODULE_1__.bpfrpt_proptype_HeaderRowRendererParams === (prop_types__WEBPACK_IMPORTED_MODULE_2___default().any) ? {} : _types__WEBPACK_IMPORTED_MODULE_1__.bpfrpt_proptype_HeaderRowRendererParams;



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Table/defaultRowRenderer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Table/defaultRowRenderer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultRowRenderer)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends/index.js");
/* harmony import */ const _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/react-virtualized/dist/es/Table/types.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);



/**
 * Default row renderer for Table.
 */
      function defaultRowRenderer(_ref) {
        const className = _ref.className,
          columns = _ref.columns,
          index = _ref.index,
          key = _ref.key,
          onRowClick = _ref.onRowClick,
          onRowDoubleClick = _ref.onRowDoubleClick,
          onRowMouseOut = _ref.onRowMouseOut,
          onRowMouseOver = _ref.onRowMouseOver,
          onRowRightClick = _ref.onRowRightClick,
          rowData = _ref.rowData,
          style = _ref.style;
        const a11yProps = {
          'aria-rowindex': index + 1
        };

        if (onRowClick || onRowDoubleClick || onRowMouseOut || onRowMouseOver || onRowRightClick) {
          a11yProps['aria-label'] = 'row';
          a11yProps.tabIndex = 0;

          if (onRowClick) {
            a11yProps.onClick = function (event) {
              return onRowClick({
                event: event,
                index: index,
                rowData: rowData
              });
            };
          }

          if (onRowDoubleClick) {
            a11yProps.onDoubleClick = function (event) {
              return onRowDoubleClick({
                event: event,
                index: index,
                rowData: rowData
              });
            };
          }

          if (onRowMouseOut) {
            a11yProps.onMouseOut = function (event) {
              return onRowMouseOut({
                event: event,
                index: index,
                rowData: rowData
              });
            };
          }

          if (onRowMouseOver) {
            a11yProps.onMouseOver = function (event) {
              return onRowMouseOver({
                event: event,
                index: index,
                rowData: rowData
              });
            };
          }

          if (onRowRightClick) {
            a11yProps.onContextMenu = function (event) {
              return onRowRightClick({
                event: event,
                index: index,
                rowData: rowData
              });
            };
          }
        }

        return react__WEBPACK_IMPORTED_MODULE_1__.createElement("div", _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({}, a11yProps, {
          className: className,
          key: key,
          role: "row",
          style: style
        }), columns);
      }
      defaultRowRenderer.propTypes =  false ? 0 : _types__WEBPACK_IMPORTED_MODULE_2__.bpfrpt_proptype_RowRendererParams === (prop_types__WEBPACK_IMPORTED_MODULE_3___default().any) ? {} : _types__WEBPACK_IMPORTED_MODULE_2__.bpfrpt_proptype_RowRendererParams;



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Table/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Table/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Column: () => (/* reexport safe */ _Column__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   SortDirection: () => (/* reexport safe */ _SortDirection__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   SortIndicator: () => (/* reexport safe */ _SortIndicator__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   Table: () => (/* reexport safe */ _Table__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   createMultiSort: () => (/* reexport safe */ _createMultiSort__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultCellDataGetter: () => (/* reexport safe */ _defaultCellDataGetter__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   defaultCellRenderer: () => (/* reexport safe */ _defaultCellRenderer__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   defaultHeaderRenderer: () => (/* reexport safe */ _defaultHeaderRenderer__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   defaultHeaderRowRenderer: () => (/* reexport safe */ _defaultHeaderRowRenderer_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   defaultRowRenderer: () => (/* reexport safe */ _defaultRowRenderer__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _createMultiSort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createMultiSort */ "./node_modules/react-virtualized/dist/es/Table/createMultiSort.js");
/* harmony import */ var _defaultCellDataGetter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultCellDataGetter */ "./node_modules/react-virtualized/dist/es/Table/defaultCellDataGetter.js");
/* harmony import */ var _defaultCellRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaultCellRenderer */ "./node_modules/react-virtualized/dist/es/Table/defaultCellRenderer.js");
/* harmony import */ var _defaultHeaderRowRenderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaultHeaderRowRenderer.js */ "./node_modules/react-virtualized/dist/es/Table/defaultHeaderRowRenderer.js");
/* harmony import */ var _defaultHeaderRenderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defaultHeaderRenderer */ "./node_modules/react-virtualized/dist/es/Table/defaultHeaderRenderer.js");
/* harmony import */ var _defaultRowRenderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./defaultRowRenderer */ "./node_modules/react-virtualized/dist/es/Table/defaultRowRenderer.js");
/* harmony import */ var _Column__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Column */ "./node_modules/react-virtualized/dist/es/Table/Column.js");
/* harmony import */ var _SortDirection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SortDirection */ "./node_modules/react-virtualized/dist/es/Table/SortDirection.js");
/* harmony import */ var _SortIndicator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SortIndicator */ "./node_modules/react-virtualized/dist/es/Table/SortIndicator.js");
/* harmony import */ var _Table__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Table */ "./node_modules/react-virtualized/dist/es/Table/Table.js");










/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Table__WEBPACK_IMPORTED_MODULE_9__["default"]);


/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/Table/types.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/Table/types.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bpfrpt_proptype_CellDataGetterParams: () => (/* binding */ bpfrpt_proptype_CellDataGetterParams),
/* harmony export */   bpfrpt_proptype_CellRendererParams: () => (/* binding */ bpfrpt_proptype_CellRendererParams),
/* harmony export */   bpfrpt_proptype_HeaderRendererParams: () => (/* binding */ bpfrpt_proptype_HeaderRendererParams),
/* harmony export */   bpfrpt_proptype_HeaderRowRendererParams: () => (/* binding */ bpfrpt_proptype_HeaderRowRendererParams),
/* harmony export */   bpfrpt_proptype_RowRendererParams: () => (/* binding */ bpfrpt_proptype_RowRendererParams)
/* harmony export */ });
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
      var bpfrpt_proptype_CellDataGetterParams =  false ? 0 : {
        "columnData": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().any),
        "dataKey": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().string).isRequired,
        "rowData": function rowData(props, propName, componentName) {
          if (!Object.prototype.hasOwnProperty.call(props, propName)) {
            throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
          }
        }
      };
      var bpfrpt_proptype_CellRendererParams =  false ? 0 : {
        "cellData": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().any),
        "columnData": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().any),
        "dataKey": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().string).isRequired,
        "rowData": function rowData(props, propName, componentName) {
          if (!Object.prototype.hasOwnProperty.call(props, propName)) {
            throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
          }
        },
        "rowIndex": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired
      };
      var bpfrpt_proptype_HeaderRowRendererParams =  false ? 0 : {
        "className": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().string).isRequired,
        "columns": prop_types__WEBPACK_IMPORTED_MODULE_0___default().arrayOf(function (props, propName, componentName) {
          if (!Object.prototype.hasOwnProperty.call(props, propName)) {
            throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
          }
        }).isRequired,
        "style": function style(props, propName, componentName) {
          if (!Object.prototype.hasOwnProperty.call(props, propName)) {
            throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
          }
        }
      };
      var bpfrpt_proptype_HeaderRendererParams =  false ? 0 : {
        "columnData": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().any),
        "dataKey": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().string).isRequired,
        "disableSort": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().bool),
        "label": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().any),
        "sortBy": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().string),
        "sortDirection": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().string)
      };
      var bpfrpt_proptype_RowRendererParams =  false ? 0 : {
        "className": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().string).isRequired,
        "columns": prop_types__WEBPACK_IMPORTED_MODULE_0___default().arrayOf(function (props, propName, componentName) {
          if (!Object.prototype.hasOwnProperty.call(props, propName)) {
            throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
          }
        }).isRequired,
        "index": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number).isRequired,
        "isScrolling": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().bool).isRequired,
        "onRowClick": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().func),
        "onRowDoubleClick": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().func),
        "onRowMouseOver": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().func),
        "onRowMouseOut": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().func),
        "rowData": function rowData(props, propName, componentName) {
          if (!Object.prototype.hasOwnProperty.call(props, propName)) {
            throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
          }
        },
        "style": function style(props, propName, componentName) {
          if (!Object.prototype.hasOwnProperty.call(props, propName)) {
            throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
          }
        },
        "key": (prop_types__WEBPACK_IMPORTED_MODULE_0___default().string).isRequired
      };







/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/WindowScroller/WindowScroller.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/WindowScroller/WindowScroller.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IS_SCROLLING_TIMEOUT: () => (/* binding */ IS_SCROLLING_TIMEOUT),
/* harmony export */   "default": () => (/* binding */ WindowScroller)
/* harmony export */ });
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck/index.js");
/* harmony import */ const _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass/index.js");
/* harmony import */ const _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn/index.js");
/* harmony import */ const _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf/index.js");
/* harmony import */ const _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized/index.js");
/* harmony import */ const _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits/index.js");
/* harmony import */ const _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty/index.js");
/* harmony import */ const _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "react");
/* harmony import */ const react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ const react_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ const react_dom__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ const _utils_onScroll__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/onScroll */ "./node_modules/react-virtualized/dist/es/WindowScroller/utils/onScroll.js");
/* harmony import */ const _utils_dimensions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/dimensions */ "./node_modules/react-virtualized/dist/es/WindowScroller/utils/dimensions.js");
/* harmony import */ const _vendor_detectElementResize__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../vendor/detectElementResize */ "./node_modules/react-virtualized/dist/es/vendor/detectElementResize.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_12__);








      let _class, _temp;

      function ownKeys(object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

      function _objectSpread(target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }







/**
 * Specifies the number of miliseconds during which to disable pointer events while a scroll is in progress.
 * This improves performance and makes scrolling smoother.
 */
      var IS_SCROLLING_TIMEOUT = 150;

      const getWindow = function getWindow() {
        return typeof window !== 'undefined' ? window : undefined;
      };

      var WindowScroller = (_temp = _class =
/*#__PURE__*/
function (_React$PureComponent) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(WindowScroller, _React$PureComponent);

  function WindowScroller() {
    let _getPrototypeOf2;

    let _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, WindowScroller);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, (_getPrototypeOf2 = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(WindowScroller)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_window", getWindow());

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_isMounted", false);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_positionFromTop", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_positionFromLeft", 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_detectElementResize", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_child", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "state", _objectSpread({}, (0,_utils_dimensions__WEBPACK_IMPORTED_MODULE_10__.getDimensions)(_this.props.scrollElement, _this.props), {
      isScrolling: false,
      scrollLeft: 0,
      scrollTop: 0
    }));

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_registerChild", function (element) {
      if (element && !(element instanceof Element)) {
        console.warn('WindowScroller registerChild expects to be passed Element or null');
      }

      _this._child = element;

      _this.updatePosition();
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_onChildScroll", function (_ref) {
      const scrollTop = _ref.scrollTop;

      if (_this.state.scrollTop === scrollTop) {
        return;
      }

      const scrollElement = _this.props.scrollElement;

      if (scrollElement) {
        if (typeof scrollElement.scrollTo === 'function') {
          scrollElement.scrollTo(0, scrollTop + _this._positionFromTop);
        } else {
          scrollElement.scrollTop = scrollTop + _this._positionFromTop;
        }
      }
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_registerResizeListener", function (element) {
      if (element === window) {
        window.addEventListener('resize', _this._onResize, false);
      } else {
        _this._detectElementResize.addResizeListener(element, _this._onResize);
      }
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_unregisterResizeListener", function (element) {
      if (element === window) {
        window.removeEventListener('resize', _this._onResize, false);
      } else if (element) {
        _this._detectElementResize.removeResizeListener(element, _this._onResize);
      }
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "_onResize", function () {
      _this.updatePosition();
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "__handleWindowScrollEvent", function () {
      if (!_this._isMounted) {
        return;
      }

      const onScroll = _this.props.onScroll;
      const scrollElement = _this.props.scrollElement;

      if (scrollElement) {
        const scrollOffset = (0,_utils_dimensions__WEBPACK_IMPORTED_MODULE_10__.getScrollOffset)(scrollElement);
        const scrollLeft = Math.max(0, scrollOffset.left - _this._positionFromLeft);
        const scrollTop = Math.max(0, scrollOffset.top - _this._positionFromTop);

        _this.setState({
          isScrolling: true,
          scrollLeft: scrollLeft,
          scrollTop: scrollTop
        });

        onScroll({
          scrollLeft: scrollLeft,
          scrollTop: scrollTop
        });
      }
    });

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this), "__resetIsScrolling", function () {
      _this.setState({
        isScrolling: false
      });
    });

    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(WindowScroller, [{
    key: "updatePosition",
    value: function updatePosition() {
      const scrollElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.scrollElement;
      const onResize = this.props.onResize;
      const _this$state = this.state,
        height = _this$state.height,
        width = _this$state.width;
      const thisNode = this._child || react_dom__WEBPACK_IMPORTED_MODULE_8__.findDOMNode(this);

      if (thisNode instanceof Element && scrollElement) {
        const offset = (0,_utils_dimensions__WEBPACK_IMPORTED_MODULE_10__.getPositionOffset)(thisNode, scrollElement);
        this._positionFromTop = offset.top;
        this._positionFromLeft = offset.left;
      }

      const dimensions = (0,_utils_dimensions__WEBPACK_IMPORTED_MODULE_10__.getDimensions)(scrollElement, this.props);

      if (height !== dimensions.height || width !== dimensions.width) {
        this.setState({
          height: dimensions.height,
          width: dimensions.width
        });
        onResize({
          height: dimensions.height,
          width: dimensions.width
        });
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      const scrollElement = this.props.scrollElement;
      this._detectElementResize = (0,_vendor_detectElementResize__WEBPACK_IMPORTED_MODULE_11__["default"])();
      this.updatePosition(scrollElement);

      if (scrollElement) {
        (0,_utils_onScroll__WEBPACK_IMPORTED_MODULE_9__.registerScrollListener)(this, scrollElement);

        this._registerResizeListener(scrollElement);
      }

      this._isMounted = true;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      const scrollElement = this.props.scrollElement;
      const prevScrollElement = prevProps.scrollElement;

      if (prevScrollElement !== scrollElement && prevScrollElement != null && scrollElement != null) {
        this.updatePosition(scrollElement);
        (0,_utils_onScroll__WEBPACK_IMPORTED_MODULE_9__.unregisterScrollListener)(this, prevScrollElement);
        (0,_utils_onScroll__WEBPACK_IMPORTED_MODULE_9__.registerScrollListener)(this, scrollElement);

        this._unregisterResizeListener(prevScrollElement);

        this._registerResizeListener(scrollElement);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      const scrollElement = this.props.scrollElement;

      if (scrollElement) {
        (0,_utils_onScroll__WEBPACK_IMPORTED_MODULE_9__.unregisterScrollListener)(this, scrollElement);

        this._unregisterResizeListener(scrollElement);
      }

      this._isMounted = false;
    }
  }, {
    key: "render",
    value: function render() {
      const children = this.props.children;
      const _this$state2 = this.state,
        isScrolling = _this$state2.isScrolling,
        scrollTop = _this$state2.scrollTop,
        scrollLeft = _this$state2.scrollLeft,
        height = _this$state2.height,
        width = _this$state2.width;
      return children({
        onChildScroll: this._onChildScroll,
        registerChild: this._registerChild,
        height: height,
        isScrolling: isScrolling,
        scrollLeft: scrollLeft,
        scrollTop: scrollTop,
        width: width
      });
    }
  }]);

  return WindowScroller;
}(react__WEBPACK_IMPORTED_MODULE_7__.PureComponent), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(_class, "propTypes",  false ? 0 : {
  /**
   * Function responsible for rendering children.
   * This function should implement the following signature:
   * ({ height, isScrolling, scrollLeft, scrollTop, width }) => PropTypes.element
   */
        "children": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().func).isRequired,

  /** Callback to be invoked on-resize: ({ height, width }) */
        "onResize": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().func).isRequired,

  /** Callback to be invoked on-scroll: ({ scrollLeft, scrollTop }) */
        "onScroll": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().func).isRequired,

  /** Element to attach scroll event listeners. Defaults to window. */
        "scrollElement": prop_types__WEBPACK_IMPORTED_MODULE_12___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_12___default().any), function () {
          return (typeof Element === "function" ? prop_types__WEBPACK_IMPORTED_MODULE_12___default().instanceOf(Element) : (prop_types__WEBPACK_IMPORTED_MODULE_12___default().any)).apply(this, arguments);
        }]),

  /**
   * Wait this amount of time after the last scroll event before resetting child `pointer-events`.
   */
        "scrollingResetTimeInterval": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().number).isRequired,

  /** Height used for server-side rendering */
        "serverHeight": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().number).isRequired,

  /** Width used for server-side rendering */
        "serverWidth": (prop_types__WEBPACK_IMPORTED_MODULE_12___default().number).isRequired
      }), _temp);

      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_6___default()(WindowScroller, "defaultProps", {
        onResize: function onResize() {},
        onScroll: function onScroll() {},
        scrollingResetTimeInterval: IS_SCROLLING_TIMEOUT,
        scrollElement: getWindow(),
        serverHeight: 0,
        serverWidth: 0
      });




/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/WindowScroller/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/WindowScroller/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IS_SCROLLING_TIMEOUT: () => (/* reexport safe */ _WindowScroller__WEBPACK_IMPORTED_MODULE_0__.IS_SCROLLING_TIMEOUT),
/* harmony export */   WindowScroller: () => (/* reexport safe */ _WindowScroller__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _WindowScroller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WindowScroller */ "./node_modules/react-virtualized/dist/es/WindowScroller/WindowScroller.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_WindowScroller__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/WindowScroller/utils/dimensions.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/WindowScroller/utils/dimensions.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDimensions: () => (/* binding */ getDimensions),
/* harmony export */   getPositionOffset: () => (/* binding */ getPositionOffset),
/* harmony export */   getScrollOffset: () => (/* binding */ getScrollOffset)
/* harmony export */ });
/**
 * Gets the dimensions of the element, accounting for API differences between
 * `window` and other DOM elements.
 */
// TODO Move this into WindowScroller and import from there
      const isWindow = function isWindow(element) {
        return element === window;
      };

      const getBoundingBox = function getBoundingBox(element) {
        return element.getBoundingClientRect();
      };

      function getDimensions(scrollElement, props) {
        if (!scrollElement) {
          return {
            height: props.serverHeight,
            width: props.serverWidth
          };
        } else if (isWindow(scrollElement)) {
          const _window = window,
            innerHeight = _window.innerHeight,
            innerWidth = _window.innerWidth;
          return {
            height: typeof innerHeight === 'number' ? innerHeight : 0,
            width: typeof innerWidth === 'number' ? innerWidth : 0
          };
        } else {
          return getBoundingBox(scrollElement);
        }
      }
/**
 * Gets the vertical and horizontal position of an element within its scroll container.
 * Elements that have been scrolled past return negative values.
 * Handles edge-case where a user is navigating back (history) from an already-scrolled page.
 * In this case the bodys top or left position will be a negative number and this elements top or left will be increased (by that amount).
 */

      function getPositionOffset(element, container) {
        if (isWindow(container) && document.documentElement) {
          const containerElement = document.documentElement;
          const elementRect = getBoundingBox(element);
          const containerRect = getBoundingBox(containerElement);
          return {
            top: elementRect.top - containerRect.top,
            left: elementRect.left - containerRect.left
          };
        } else {
          const scrollOffset = getScrollOffset(container);

          const _elementRect = getBoundingBox(element);

          const _containerRect = getBoundingBox(container);

          return {
            top: _elementRect.top + scrollOffset.top - _containerRect.top,
            left: _elementRect.left + scrollOffset.left - _containerRect.left
          };
        }
      }
/**
 * Gets the vertical and horizontal scroll amount of the element, accounting for IE compatibility
 * and API differences between `window` and other DOM elements.
 */

      function getScrollOffset(element) {
        if (isWindow(element) && document.documentElement) {
          return {
            top: 'scrollY' in window ? window.scrollY : document.documentElement.scrollTop,
            left: 'scrollX' in window ? window.scrollX : document.documentElement.scrollLeft
          };
        } else {
          return {
            top: element.scrollTop,
            left: element.scrollLeft
          };
        }
      }

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/WindowScroller/utils/onScroll.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/WindowScroller/utils/onScroll.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerScrollListener: () => (/* binding */ registerScrollListener),
/* harmony export */   unregisterScrollListener: () => (/* binding */ unregisterScrollListener)
/* harmony export */ });
/* harmony import */ const _utils_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/requestAnimationTimeout */ "./node_modules/react-virtualized/dist/es/utils/requestAnimationTimeout.js");
/* harmony import */ const _WindowScroller_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../WindowScroller.js */ "./node_modules/react-virtualized/dist/es/WindowScroller/WindowScroller.js");

      let mountedInstances = [];
      let originalBodyPointerEvents = null;
      let disablePointerEventsTimeoutId = null;

      function enablePointerEventsIfDisabled() {
        if (disablePointerEventsTimeoutId) {
          disablePointerEventsTimeoutId = null;

          if (document.body && originalBodyPointerEvents != null) {
            document.body.style.pointerEvents = originalBodyPointerEvents;
          }

          originalBodyPointerEvents = null;
        }
      }

      function enablePointerEventsAfterDelayCallback() {
        enablePointerEventsIfDisabled();
        mountedInstances.forEach(function (instance) {
          return instance.__resetIsScrolling();
        });
      }

      function enablePointerEventsAfterDelay() {
        if (disablePointerEventsTimeoutId) {
          (0,_utils_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_0__.cancelAnimationTimeout)(disablePointerEventsTimeoutId);
        }

        let maximumTimeout = 0;
        mountedInstances.forEach(function (instance) {
          maximumTimeout = Math.max(maximumTimeout, instance.props.scrollingResetTimeInterval);
        });
        disablePointerEventsTimeoutId = (0,_utils_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_0__.requestAnimationTimeout)(enablePointerEventsAfterDelayCallback, maximumTimeout);
      }

      function onScrollWindow(event) {
        if (event.currentTarget === window && originalBodyPointerEvents == null && document.body) {
          originalBodyPointerEvents = document.body.style.pointerEvents;
          document.body.style.pointerEvents = 'none';
        }

        enablePointerEventsAfterDelay();
        mountedInstances.forEach(function (instance) {
          if (instance.props.scrollElement === event.currentTarget) {
            instance.__handleWindowScrollEvent();
          }
        });
      }

      function registerScrollListener(component, element) {
        if (!mountedInstances.some(function (instance) {
          return instance.props.scrollElement === element;
        })) {
          element.addEventListener('scroll', onScrollWindow);
        }

        mountedInstances.push(component);
      }
      function unregisterScrollListener(component, element) {
        mountedInstances = mountedInstances.filter(function (instance) {
          return instance !== component;
        });

        if (!mountedInstances.length) {
          element.removeEventListener('scroll', onScrollWindow);

          if (disablePointerEventsTimeoutId) {
            (0,_utils_requestAnimationTimeout__WEBPACK_IMPORTED_MODULE_0__.cancelAnimationTimeout)(disablePointerEventsTimeoutId);
            enablePointerEventsIfDisabled();
          }
        }
      }


/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrowKeyStepper: () => (/* reexport safe */ _ArrowKeyStepper__WEBPACK_IMPORTED_MODULE_0__.ArrowKeyStepper),
/* harmony export */   AutoSizer: () => (/* reexport safe */ _AutoSizer__WEBPACK_IMPORTED_MODULE_1__.AutoSizer),
/* harmony export */   CellMeasurer: () => (/* reexport safe */ _CellMeasurer__WEBPACK_IMPORTED_MODULE_2__.CellMeasurer),
/* harmony export */   CellMeasurerCache: () => (/* reexport safe */ _CellMeasurer__WEBPACK_IMPORTED_MODULE_2__.CellMeasurerCache),
/* harmony export */   Collection: () => (/* reexport safe */ _Collection__WEBPACK_IMPORTED_MODULE_3__.Collection),
/* harmony export */   Column: () => (/* reexport safe */ _Table__WEBPACK_IMPORTED_MODULE_11__.Column),
/* harmony export */   ColumnSizer: () => (/* reexport safe */ _ColumnSizer__WEBPACK_IMPORTED_MODULE_4__.ColumnSizer),
/* harmony export */   Grid: () => (/* reexport safe */ _Grid__WEBPACK_IMPORTED_MODULE_5__.Grid),
/* harmony export */   InfiniteLoader: () => (/* reexport safe */ _InfiniteLoader__WEBPACK_IMPORTED_MODULE_6__.InfiniteLoader),
/* harmony export */   List: () => (/* reexport safe */ _List__WEBPACK_IMPORTED_MODULE_7__.List),
/* harmony export */   Masonry: () => (/* reexport safe */ _Masonry__WEBPACK_IMPORTED_MODULE_8__.Masonry),
/* harmony export */   MultiGrid: () => (/* reexport safe */ _MultiGrid__WEBPACK_IMPORTED_MODULE_9__.MultiGrid),
/* harmony export */   ScrollSync: () => (/* reexport safe */ _ScrollSync__WEBPACK_IMPORTED_MODULE_10__.ScrollSync),
/* harmony export */   SortDirection: () => (/* reexport safe */ _Table__WEBPACK_IMPORTED_MODULE_11__.SortDirection),
/* harmony export */   SortIndicator: () => (/* reexport safe */ _Table__WEBPACK_IMPORTED_MODULE_11__.SortIndicator),
/* harmony export */   Table: () => (/* reexport safe */ _Table__WEBPACK_IMPORTED_MODULE_11__.Table),
/* harmony export */   WindowScroller: () => (/* reexport safe */ _WindowScroller__WEBPACK_IMPORTED_MODULE_12__.WindowScroller),
/* harmony export */   accessibilityOverscanIndicesGetter: () => (/* reexport safe */ _Grid__WEBPACK_IMPORTED_MODULE_5__.accessibilityOverscanIndicesGetter),
/* harmony export */   createMasonryCellPositioner: () => (/* reexport safe */ _Masonry__WEBPACK_IMPORTED_MODULE_8__.createCellPositioner),
/* harmony export */   createTableMultiSort: () => (/* reexport safe */ _Table__WEBPACK_IMPORTED_MODULE_11__.createMultiSort),
/* harmony export */   defaultCellRangeRenderer: () => (/* reexport safe */ _Grid__WEBPACK_IMPORTED_MODULE_5__.defaultCellRangeRenderer),
/* harmony export */   defaultOverscanIndicesGetter: () => (/* reexport safe */ _Grid__WEBPACK_IMPORTED_MODULE_5__.defaultOverscanIndicesGetter),
/* harmony export */   defaultTableCellDataGetter: () => (/* reexport safe */ _Table__WEBPACK_IMPORTED_MODULE_11__.defaultCellDataGetter),
/* harmony export */   defaultTableCellRenderer: () => (/* reexport safe */ _Table__WEBPACK_IMPORTED_MODULE_11__.defaultCellRenderer),
/* harmony export */   defaultTableHeaderRenderer: () => (/* reexport safe */ _Table__WEBPACK_IMPORTED_MODULE_11__.defaultHeaderRenderer),
/* harmony export */   defaultTableHeaderRowRenderer: () => (/* reexport safe */ _Table__WEBPACK_IMPORTED_MODULE_11__.defaultHeaderRowRenderer),
/* harmony export */   defaultTableRowRenderer: () => (/* reexport safe */ _Table__WEBPACK_IMPORTED_MODULE_11__.defaultRowRenderer)
/* harmony export */ });
/* harmony import */ var _ArrowKeyStepper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArrowKeyStepper */ "./node_modules/react-virtualized/dist/es/ArrowKeyStepper/index.js");
/* harmony import */ var _AutoSizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AutoSizer */ "./node_modules/react-virtualized/dist/es/AutoSizer/index.js");
/* harmony import */ var _CellMeasurer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CellMeasurer */ "./node_modules/react-virtualized/dist/es/CellMeasurer/index.js");
/* harmony import */ var _Collection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Collection */ "./node_modules/react-virtualized/dist/es/Collection/index.js");
/* harmony import */ var _ColumnSizer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ColumnSizer */ "./node_modules/react-virtualized/dist/es/ColumnSizer/index.js");
/* harmony import */ var _Grid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Grid */ "./node_modules/react-virtualized/dist/es/Grid/index.js");
/* harmony import */ var _InfiniteLoader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./InfiniteLoader */ "./node_modules/react-virtualized/dist/es/InfiniteLoader/index.js");
/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./List */ "./node_modules/react-virtualized/dist/es/List/index.js");
/* harmony import */ var _Masonry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Masonry */ "./node_modules/react-virtualized/dist/es/Masonry/index.js");
/* harmony import */ var _MultiGrid__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./MultiGrid */ "./node_modules/react-virtualized/dist/es/MultiGrid/index.js");
/* harmony import */ var _ScrollSync__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ScrollSync */ "./node_modules/react-virtualized/dist/es/ScrollSync/index.js");
/* harmony import */ var _Table__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Table */ "./node_modules/react-virtualized/dist/es/Table/index.js");
/* harmony import */ var _WindowScroller__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./WindowScroller */ "./node_modules/react-virtualized/dist/es/WindowScroller/index.js");














/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/utils/animationFrame.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/utils/animationFrame.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   caf: () => (/* binding */ caf),
/* harmony export */   raf: () => (/* binding */ raf)
/* harmony export */ });
// Properly handle server-side rendering.
      let win;

      if (typeof window !== 'undefined') {
        win = window;
      } else if (typeof self !== 'undefined') {
        win = self;
      } else {
        win = {};
      } // requestAnimationFrame() shim by Paul Irish
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/


      const request = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function (callback) {
        return win.setTimeout(callback, 1000 / 60);
      };

      const cancel = win.cancelAnimationFrame || win.webkitCancelAnimationFrame || win.mozCancelAnimationFrame || win.oCancelAnimationFrame || win.msCancelAnimationFrame || function (id) {
        win.clearTimeout(id);
      };

      var raf = request;
      var caf = cancel;

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/utils/createCallbackMemoizer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/utils/createCallbackMemoizer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createCallbackMemoizer)
/* harmony export */ });
/**
 * Helper utility that updates the specified callback whenever any of the specified indices have changed.
 */
      function createCallbackMemoizer() {
        const requireAllKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        let cachedIndices = {};
        return function (_ref) {
          const callback = _ref.callback,
            indices = _ref.indices;
          const keys = Object.keys(indices);
          const allInitialized = !requireAllKeys || keys.every(function (key) {
            const value = indices[key];
            return Array.isArray(value) ? value.length > 0 : value >= 0;
          });
          const indexChanged = keys.length !== Object.keys(cachedIndices).length || keys.some(function (key) {
            const cachedValue = cachedIndices[key];
            const value = indices[key];
            return Array.isArray(value) ? cachedValue.join(',') !== value.join(',') : cachedValue !== value;
          });
          cachedIndices = indices;

          if (allInitialized && indexChanged) {
            callback(indices);
          }
        };
      }

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/utils/getUpdatedOffsetForIndex.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/utils/getUpdatedOffsetForIndex.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUpdatedOffsetForIndex)
/* harmony export */ });
/**
 * Determines a new offset that ensures a certain cell is visible, given the current offset.
 * If the cell is already visible then the current offset will be returned.
 * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.
 *
 * @param align Desired alignment within container; one of "auto" (default), "start", or "end"
 * @param cellOffset Offset (x or y) position for cell
 * @param cellSize Size (width or height) of cell
 * @param containerSize Total size (width or height) of the container
 * @param currentOffset Container's current (x or y) offset
 * @return Offset to use to ensure the specified cell is visible
 */
      function getUpdatedOffsetForIndex(_ref) {
        const _ref$align = _ref.align,
          align = _ref$align === void 0 ? 'auto' : _ref$align,
          cellOffset = _ref.cellOffset,
          cellSize = _ref.cellSize,
          containerSize = _ref.containerSize,
          currentOffset = _ref.currentOffset;
        const maxOffset = cellOffset;
        const minOffset = maxOffset - containerSize + cellSize;

        switch (align) {
          case 'start':
            return maxOffset;

          case 'end':
            return minOffset;

          case 'center':
            return maxOffset - (containerSize - cellSize) / 2;

          default:
            return Math.max(minOffset, Math.min(maxOffset, currentOffset));
        }
      }

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/utils/requestAnimationTimeout.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/utils/requestAnimationTimeout.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bpfrpt_proptype_AnimationTimeoutId: () => (/* binding */ bpfrpt_proptype_AnimationTimeoutId),
/* harmony export */   cancelAnimationTimeout: () => (/* binding */ cancelAnimationTimeout),
/* harmony export */   requestAnimationTimeout: () => (/* binding */ requestAnimationTimeout)
/* harmony export */ });
/* harmony import */ const _animationFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./animationFrame */ "./node_modules/react-virtualized/dist/es/utils/animationFrame.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ const prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);

      var bpfrpt_proptype_AnimationTimeoutId =  false ? 0 : {
        "id": (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number).isRequired
      };
      var cancelAnimationTimeout = function cancelAnimationTimeout(frame) {
        return (0,_animationFrame__WEBPACK_IMPORTED_MODULE_0__.caf)(frame.id);
      };
/**
 * Recursively calls requestAnimationFrame until a specified delay has been met or exceeded.
 * When the delay time has been reached the function you're timing out will be called.
 *
 * Credit: Joe Lambert (https://gist.github.com/joelambert/1002116#file-requesttimeout-js)
 */

      var requestAnimationTimeout = function requestAnimationTimeout(callback, delay) {
        let start; // wait for end of processing current event handler, because event handler may be long

        Promise.resolve().then(function () {
          start = Date.now();
        });

        const timeout = function timeout() {
          if (Date.now() - start >= delay) {
            callback.call();
          } else {
            frame.id = (0,_animationFrame__WEBPACK_IMPORTED_MODULE_0__.raf)(timeout);
          }
        };

        var frame = {
          id: (0,_animationFrame__WEBPACK_IMPORTED_MODULE_0__.raf)(timeout)
        };
        return frame;
      };



/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/vendor/binarySearchBounds.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/vendor/binarySearchBounds.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Binary Search Bounds
 * https://github.com/mikolalysenko/binary-search-bounds
 * Mikola Lysenko
 *
 * Inlined because of Content Security Policy issue caused by the use of `new Function(...)` syntax.
 * Issue reported here: https://github.com/mikolalysenko/binary-search-bounds/issues/5
 **/
      function _GEA(a, l, h, y) {
        let i = h + 1;

        while (l <= h) {
          const m = l + h >>> 1,
            x = a[m];

          if (x >= y) {
            i = m;
            h = m - 1;
          } else {
            l = m + 1;
          }
        }

        return i;
      }

      function _GEP(a, l, h, y, c) {
        let i = h + 1;

        while (l <= h) {
          const m = l + h >>> 1,
            x = a[m];

          if (c(x, y) >= 0) {
            i = m;
            h = m - 1;
          } else {
            l = m + 1;
          }
        }

        return i;
      }

      function dispatchBsearchGE(a, y, c, l, h) {
        if (typeof c === 'function') {
          return _GEP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
        } else {
          return _GEA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
        }
      }

      function _GTA(a, l, h, y) {
        let i = h + 1;

        while (l <= h) {
          const m = l + h >>> 1,
            x = a[m];

          if (x > y) {
            i = m;
            h = m - 1;
          } else {
            l = m + 1;
          }
        }

        return i;
      }

      function _GTP(a, l, h, y, c) {
        let i = h + 1;

        while (l <= h) {
          const m = l + h >>> 1,
            x = a[m];

          if (c(x, y) > 0) {
            i = m;
            h = m - 1;
          } else {
            l = m + 1;
          }
        }

        return i;
      }

      function dispatchBsearchGT(a, y, c, l, h) {
        if (typeof c === 'function') {
          return _GTP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
        } else {
          return _GTA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
        }
      }

      function _LTA(a, l, h, y) {
        let i = l - 1;

        while (l <= h) {
          const m = l + h >>> 1,
            x = a[m];

          if (x < y) {
            i = m;
            l = m + 1;
          } else {
            h = m - 1;
          }
        }

        return i;
      }

      function _LTP(a, l, h, y, c) {
        let i = l - 1;

        while (l <= h) {
          const m = l + h >>> 1,
            x = a[m];

          if (c(x, y) < 0) {
            i = m;
            l = m + 1;
          } else {
            h = m - 1;
          }
        }

        return i;
      }

      function dispatchBsearchLT(a, y, c, l, h) {
        if (typeof c === 'function') {
          return _LTP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
        } else {
          return _LTA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
        }
      }

      function _LEA(a, l, h, y) {
        let i = l - 1;

        while (l <= h) {
          const m = l + h >>> 1,
            x = a[m];

          if (x <= y) {
            i = m;
            l = m + 1;
          } else {
            h = m - 1;
          }
        }

        return i;
      }

      function _LEP(a, l, h, y, c) {
        let i = l - 1;

        while (l <= h) {
          const m = l + h >>> 1,
            x = a[m];

          if (c(x, y) <= 0) {
            i = m;
            l = m + 1;
          } else {
            h = m - 1;
          }
        }

        return i;
      }

      function dispatchBsearchLE(a, y, c, l, h) {
        if (typeof c === 'function') {
          return _LEP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
        } else {
          return _LEA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
        }
      }

      function _EQA(a, l, h, y) {
        l - 1;

        while (l <= h) {
          const m = l + h >>> 1,
            x = a[m];

          if (x === y) {
            return m;
          } else if (x <= y) {
            l = m + 1;
          } else {
            h = m - 1;
          }
        }

        return -1;
      }

      function _EQP(a, l, h, y, c) {
        l - 1;

        while (l <= h) {
          const m = l + h >>> 1,
            x = a[m];
          const p = c(x, y);

          if (p === 0) {
            return m;
          } else if (p <= 0) {
            l = m + 1;
          } else {
            h = m - 1;
          }
        }

        return -1;
      }

      function dispatchBsearchEQ(a, y, c, l, h) {
        if (typeof c === 'function') {
          return _EQP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
        } else {
          return _EQA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
        }
      }

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
        ge: dispatchBsearchGE,
        gt: dispatchBsearchGT,
        lt: dispatchBsearchLT,
        le: dispatchBsearchLE,
        eq: dispatchBsearchEQ
      });

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/vendor/detectElementResize.js":
/*!******************************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/vendor/detectElementResize.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createDetectElementResize)
/* harmony export */ });
/**
 * Detect Element Resize.
 * https://github.com/sdecima/javascript-detect-element-resize
 * Sebastian Decima
 *
 * Forked from version 0.5.3; includes the following modifications:
 * 1)Guard against unsafe 'window' and 'document' references (to support SSR).
 * 2)Defer initialization code via a top-level function wrapper (to support SSR).
 * 3) Avoid unnecessary reflows by not measuring size for scroll events bubbling from children.
 * 4) Add nonce for style element.
 * 5) Added support for injecting custom window object
 **/
      function createDetectElementResize(nonce, hostWindow) {
  // Check `document` and `window` in case of server-side rendering
        let _window;

        if (typeof hostWindow !== 'undefined') {
          _window = hostWindow;
        } else if (typeof window !== 'undefined') {
          _window = window;
        } else if (typeof self !== 'undefined') {
          _window = self;
        } else {
          _window = global;
        }

        const attachEvent = typeof _window.document !== 'undefined' && _window.document.attachEvent;

        if (!attachEvent) {
          const requestFrame = function () {
            const raf = _window.requestAnimationFrame || _window.mozRequestAnimationFrame || _window.webkitRequestAnimationFrame || function (fn) {
              return _window.setTimeout(fn, 20);
            };

            return function (fn) {
              return raf(fn);
            };
          }();

          const cancelFrame = function () {
            const cancel = _window.cancelAnimationFrame || _window.mozCancelAnimationFrame || _window.webkitCancelAnimationFrame || _window.clearTimeout;
            return function (id) {
              return cancel(id);
            };
          }();

          var resetTriggers = function resetTriggers(element) {
            const triggers = element.__resizeTriggers__,
              expand = triggers.firstElementChild,
              contract = triggers.lastElementChild,
              expandChild = expand.firstElementChild;
            contract.scrollLeft = contract.scrollWidth;
            contract.scrollTop = contract.scrollHeight;
            expandChild.style.width = expand.offsetWidth + 1 + 'px';
            expandChild.style.height = expand.offsetHeight + 1 + 'px';
            expand.scrollLeft = expand.scrollWidth;
            expand.scrollTop = expand.scrollHeight;
          };

          const checkTriggers = function checkTriggers(element) {
            return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;
          };

          var scrollListener = function scrollListener(e) {
      // Don't measure (which forces) reflow for scrolls that happen inside of children!
            if (e.target.className && typeof e.target.className.indexOf === 'function' && e.target.className.indexOf('contract-trigger') < 0 && e.target.className.indexOf('expand-trigger') < 0) {
              return;
            }

            const element = this;
            resetTriggers(this);

            if (this.__resizeRAF__) {
              cancelFrame(this.__resizeRAF__);
            }

            this.__resizeRAF__ = requestFrame(function () {
              if (checkTriggers(element)) {
                element.__resizeLast__.width = element.offsetWidth;
                element.__resizeLast__.height = element.offsetHeight;

                element.__resizeListeners__.forEach(function (fn) {
                  fn.call(element, e);
                });
              }
            });
          };
    /* Detect CSS Animations support to detect element display/re-attach */


          var animation = false,
            keyframeprefix = '',
            animationstartevent = 'animationstart',
            domPrefixes = 'Webkit Moz O ms'.split(' '),
            startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '),
            pfx = '';
          {
            const elm = _window.document.createElement('fakeelement');

            if (elm.style.animationName !== undefined) {
              animation = true;
            }

            if (animation === false) {
              for (let i = 0; i < domPrefixes.length; i++) {
                if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {
                  pfx = domPrefixes[i];
                  keyframeprefix = '-' + pfx.toLowerCase() + '-';
                  animationstartevent = startEvents[i];
                  animation = true;
                  break;
                }
              }
            }
          }
          var animationName = 'resizeanim';
          var animationKeyframes = '@' + keyframeprefix + 'keyframes ' + animationName + ' { from { opacity: 0; } to { opacity: 0; } } ';
          var animationStyle = keyframeprefix + 'animation: 1ms ' + animationName + '; ';
        }

        const createStyles = function createStyles(doc) {
          if (!doc.getElementById('detectElementResize')) {
      //opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
            const css = (animationKeyframes ? animationKeyframes : '') + '.resize-triggers { ' + (animationStyle ? animationStyle : '') + 'visibility: hidden; opacity: 0; } ' + '.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
              head = doc.head || doc.getElementsByTagName('head')[0],
              style = doc.createElement('style');
            style.id = 'detectElementResize';
            style.type = 'text/css';

            if (nonce != null) {
              style.setAttribute('nonce', nonce);
            }

            if (style.styleSheet) {
              style.styleSheet.cssText = css;
            } else {
              style.appendChild(doc.createTextNode(css));
            }

            head.appendChild(style);
          }
        };

        const addResizeListener = function addResizeListener(element, fn) {
          if (attachEvent) {
            element.attachEvent('onresize', fn);
          } else {
            if (!element.__resizeTriggers__) {
              const doc = element.ownerDocument;

              const elementStyle = _window.getComputedStyle(element);

              if (elementStyle && elementStyle.position == 'static') {
                element.style.position = 'relative';
              }

              createStyles(doc);
              element.__resizeLast__ = {};
              element.__resizeListeners__ = [];
              (element.__resizeTriggers__ = doc.createElement('div')).className = 'resize-triggers';
              const resizeTriggersHtml = '<div class="expand-trigger"><div></div></div>' + '<div class="contract-trigger"></div>';

              if (window.trustedTypes) {
                const staticPolicy = trustedTypes.createPolicy('react-virtualized-auto-sizer', {
                  createHTML: function createHTML() {
                    return resizeTriggersHtml;
                  }
                });
                element.__resizeTriggers__.innerHTML = staticPolicy.createHTML('');
              } else {
                element.__resizeTriggers__.innerHTML = resizeTriggersHtml;
              }

              element.appendChild(element.__resizeTriggers__);
              resetTriggers(element);
              element.addEventListener('scroll', scrollListener, true);
        /* Listen for a css animation to detect element display/re-attach */

              if (animationstartevent) {
                element.__resizeTriggers__.__animationListener__ = function animationListener(e) {
                  if (e.animationName == animationName) {
                    resetTriggers(element);
                  }
                };

                element.__resizeTriggers__.addEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);
              }
            }

            element.__resizeListeners__.push(fn);
          }
        };

        const removeResizeListener = function removeResizeListener(element, fn) {
          if (attachEvent) {
            element.detachEvent('onresize', fn);
          } else {
            element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);

            if (!element.__resizeListeners__.length) {
              element.removeEventListener('scroll', scrollListener, true);

              if (element.__resizeTriggers__.__animationListener__) {
                element.__resizeTriggers__.removeEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);

                element.__resizeTriggers__.__animationListener__ = null;
              }

              try {
                element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
              } catch (e) {// Preact compat; see developit/preact-compat/issues/228
              }
            }
          }
        };

        return {
          addResizeListener: addResizeListener,
          removeResizeListener: removeResizeListener
        };
      }

/***/ }),

/***/ "./node_modules/react-virtualized/dist/es/vendor/intervalTree.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-virtualized/dist/es/vendor/intervalTree.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createWrapper)
/* harmony export */ });
/* harmony import */ const _binarySearchBounds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binarySearchBounds */ "./node_modules/react-virtualized/dist/es/vendor/binarySearchBounds.js");
/**
 * Binary Search Bounds
 * https://github.com/mikolalysenko/interval-tree-1d
 * Mikola Lysenko
 *
 * Inlined because of Content Security Policy issue caused by the use of `new Function(...)` syntax in an upstream dependency.
 * Issue reported here: https://github.com/mikolalysenko/binary-search-bounds/issues/5
 **/

      const NOT_FOUND = 0;
      const SUCCESS = 1;
      const EMPTY = 2;

      function IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {
        this.mid = mid;
        this.left = left;
        this.right = right;
        this.leftPoints = leftPoints;
        this.rightPoints = rightPoints;
        this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length;
      }

      const proto = IntervalTreeNode.prototype;

      function copy(a, b) {
        a.mid = b.mid;
        a.left = b.left;
        a.right = b.right;
        a.leftPoints = b.leftPoints;
        a.rightPoints = b.rightPoints;
        a.count = b.count;
      }

      function rebuild(node, intervals) {
        const ntree = createIntervalTree(intervals);
        node.mid = ntree.mid;
        node.left = ntree.left;
        node.right = ntree.right;
        node.leftPoints = ntree.leftPoints;
        node.rightPoints = ntree.rightPoints;
        node.count = ntree.count;
      }

      function rebuildWithInterval(node, interval) {
        const intervals = node.intervals([]);
        intervals.push(interval);
        rebuild(node, intervals);
      }

      function rebuildWithoutInterval(node, interval) {
        const intervals = node.intervals([]);
        const idx = intervals.indexOf(interval);

        if (idx < 0) {
          return NOT_FOUND;
        }

        intervals.splice(idx, 1);
        rebuild(node, intervals);
        return SUCCESS;
      }

      proto.intervals = function (result) {
        result.push.apply(result, this.leftPoints);

        if (this.left) {
          this.left.intervals(result);
        }

        if (this.right) {
          this.right.intervals(result);
        }

        return result;
      };

      proto.insert = function (interval) {
        const weight = this.count - this.leftPoints.length;
        this.count += 1;

        if (interval[1] < this.mid) {
          if (this.left) {
            if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
              rebuildWithInterval(this, interval);
            } else {
              this.left.insert(interval);
            }
          } else {
            this.left = createIntervalTree([interval]);
          }
        } else if (interval[0] > this.mid) {
          if (this.right) {
            if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
              rebuildWithInterval(this, interval);
            } else {
              this.right.insert(interval);
            }
          } else {
            this.right = createIntervalTree([interval]);
          }
        } else {
          const l = _binarySearchBounds__WEBPACK_IMPORTED_MODULE_0__["default"].ge(this.leftPoints, interval, compareBegin);
          const r = _binarySearchBounds__WEBPACK_IMPORTED_MODULE_0__["default"].ge(this.rightPoints, interval, compareEnd);
          this.leftPoints.splice(l, 0, interval);
          this.rightPoints.splice(r, 0, interval);
        }
      };

      proto.remove = function (interval) {
        const weight = this.count - this.leftPoints;

        if (interval[1] < this.mid) {
          if (!this.left) {
            return NOT_FOUND;
          }

          const rw = this.right ? this.right.count : 0;

          if (4 * rw > 3 * (weight - 1)) {
            return rebuildWithoutInterval(this, interval);
          }

          var r = this.left.remove(interval);

          if (r === EMPTY) {
            this.left = null;
            this.count -= 1;
            return SUCCESS;
          } else if (r === SUCCESS) {
            this.count -= 1;
          }

          return r;
        } else if (interval[0] > this.mid) {
          if (!this.right) {
            return NOT_FOUND;
          }

          const lw = this.left ? this.left.count : 0;

          if (4 * lw > 3 * (weight - 1)) {
            return rebuildWithoutInterval(this, interval);
          }

          var r = this.right.remove(interval);

          if (r === EMPTY) {
            this.right = null;
            this.count -= 1;
            return SUCCESS;
          } else if (r === SUCCESS) {
            this.count -= 1;
          }

          return r;
        } else {
          if (this.count === 1) {
            if (this.leftPoints[0] === interval) {
              return EMPTY;
            } else {
              return NOT_FOUND;
            }
          }

          if (this.leftPoints.length === 1 && this.leftPoints[0] === interval) {
            if (this.left && this.right) {
              let p = this;
              let n = this.left;

              while (n.right) {
                p = n;
                n = n.right;
              }

              if (p === this) {
                n.right = this.right;
              } else {
                var l = this.left;
                var r = this.right;
                p.count -= n.count;
                p.right = n.left;
                n.left = l;
                n.right = r;
              }

              copy(this, n);
              this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
            } else if (this.left) {
              copy(this, this.left);
            } else {
              copy(this, this.right);
            }

            return SUCCESS;
          }

          for (var l = _binarySearchBounds__WEBPACK_IMPORTED_MODULE_0__["default"].ge(this.leftPoints, interval, compareBegin); l < this.leftPoints.length; ++l) {
            if (this.leftPoints[l][0] !== interval[0]) {
              break;
            }

            if (this.leftPoints[l] === interval) {
              this.count -= 1;
              this.leftPoints.splice(l, 1);

              for (var r = _binarySearchBounds__WEBPACK_IMPORTED_MODULE_0__["default"].ge(this.rightPoints, interval, compareEnd); r < this.rightPoints.length; ++r) {
                if (this.rightPoints[r][1] !== interval[1]) {
                  break;
                } else if (this.rightPoints[r] === interval) {
                  this.rightPoints.splice(r, 1);
                  return SUCCESS;
                }
              }
            }
          }

          return NOT_FOUND;
        }
      };

      function reportLeftRange(arr, hi, cb) {
        for (let i = 0; i < arr.length && arr[i][0] <= hi; ++i) {
          const r = cb(arr[i]);

          if (r) {
            return r;
          }
        }
      }

      function reportRightRange(arr, lo, cb) {
        for (let i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {
          const r = cb(arr[i]);

          if (r) {
            return r;
          }
        }
      }

      function reportRange(arr, cb) {
        for (let i = 0; i < arr.length; ++i) {
          const r = cb(arr[i]);

          if (r) {
            return r;
          }
        }
      }

      proto.queryPoint = function (x, cb) {
        if (x < this.mid) {
          if (this.left) {
            var r = this.left.queryPoint(x, cb);

            if (r) {
              return r;
            }
          }

          return reportLeftRange(this.leftPoints, x, cb);
        } else if (x > this.mid) {
          if (this.right) {
            var r = this.right.queryPoint(x, cb);

            if (r) {
              return r;
            }
          }

          return reportRightRange(this.rightPoints, x, cb);
        } else {
          return reportRange(this.leftPoints, cb);
        }
      };

      proto.queryInterval = function (lo, hi, cb) {
        if (lo < this.mid && this.left) {
          var r = this.left.queryInterval(lo, hi, cb);

          if (r) {
            return r;
          }
        }

        if (hi > this.mid && this.right) {
          var r = this.right.queryInterval(lo, hi, cb);

          if (r) {
            return r;
          }
        }

        if (hi < this.mid) {
          return reportLeftRange(this.leftPoints, hi, cb);
        } else if (lo > this.mid) {
          return reportRightRange(this.rightPoints, lo, cb);
        } else {
          return reportRange(this.leftPoints, cb);
        }
      };

      function compareNumbers(a, b) {
        return a - b;
      }

      function compareBegin(a, b) {
        const d = a[0] - b[0];

        if (d) {
          return d;
        }

        return a[1] - b[1];
      }

      function compareEnd(a, b) {
        const d = a[1] - b[1];

        if (d) {
          return d;
        }

        return a[0] - b[0];
      }

      function createIntervalTree(intervals) {
        if (intervals.length === 0) {
          return null;
        }

        const pts = [];

        for (var i = 0; i < intervals.length; ++i) {
          pts.push(intervals[i][0], intervals[i][1]);
        }

        pts.sort(compareNumbers);
        const mid = pts[pts.length >> 1];
        const leftIntervals = [];
        const rightIntervals = [];
        const centerIntervals = [];

        for (var i = 0; i < intervals.length; ++i) {
          const s = intervals[i];

          if (s[1] < mid) {
            leftIntervals.push(s);
          } else if (mid < s[0]) {
            rightIntervals.push(s);
          } else {
            centerIntervals.push(s);
          }
        } //Split center intervals


        const leftPoints = centerIntervals;
        const rightPoints = centerIntervals.slice();
        leftPoints.sort(compareBegin);
        rightPoints.sort(compareEnd);
        return new IntervalTreeNode(mid, createIntervalTree(leftIntervals), createIntervalTree(rightIntervals), leftPoints, rightPoints);
      } //User friendly wrapper that makes it possible to support empty trees


      function IntervalTree(root) {
        this.root = root;
      }

      const tproto = IntervalTree.prototype;

      tproto.insert = function (interval) {
        if (this.root) {
          this.root.insert(interval);
        } else {
          this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval]);
        }
      };

      tproto.remove = function (interval) {
        if (this.root) {
          const r = this.root.remove(interval);

          if (r === EMPTY) {
            this.root = null;
          }

          return r !== NOT_FOUND;
        }

        return false;
      };

      tproto.queryPoint = function (p, cb) {
        if (this.root) {
          return this.root.queryPoint(p, cb);
        }
      };

      tproto.queryInterval = function (lo, hi, cb) {
        if (lo <= hi && this.root) {
          return this.root.queryInterval(lo, hi, cb);
        }
      };

      Object.defineProperty(tproto, 'count', {
        get: function get() {
          if (this.root) {
            return this.root.count;
          }

          return 0;
        }
      });
      Object.defineProperty(tproto, 'intervals', {
        get: function get() {
          if (this.root) {
            return this.root.intervals([]);
          }

          return [];
        }
      });
      function createWrapper(intervals) {
        if (!intervals || intervals.length === 0) {
          return new IntervalTree(null);
        }

        return new IntervalTree(createIntervalTree(intervals));
      }

/***/ }),

/***/ "./node_modules/react-virtualized/node_modules/dom-helpers/esm/canUseDOM.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/react-virtualized/node_modules/dom-helpers/esm/canUseDOM.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (!!(typeof window !== 'undefined' && window.document && window.document.createElement));

/***/ }),

/***/ "./node_modules/react-virtualized/node_modules/dom-helpers/esm/scrollbarSize.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/react-virtualized/node_modules/dom-helpers/esm/scrollbarSize.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ scrollbarSize)
/* harmony export */ });
/* harmony import */ const _canUseDOM__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canUseDOM */ "./node_modules/react-virtualized/node_modules/dom-helpers/esm/canUseDOM.js");

      let size;
      function scrollbarSize(recalc) {
        if (!size && size !== 0 || recalc) {
          if (_canUseDOM__WEBPACK_IMPORTED_MODULE_0__["default"]) {
            const scrollDiv = document.createElement('div');
            scrollDiv.style.position = 'absolute';
            scrollDiv.style.top = '-9999px';
            scrollDiv.style.width = '50px';
            scrollDiv.style.height = '50px';
            scrollDiv.style.overflow = 'scroll';
            document.body.appendChild(scrollDiv);
            size = scrollDiv.offsetWidth - scrollDiv.clientWidth;
            document.body.removeChild(scrollDiv);
          }
        }

        return size;
      }

/***/ }),

/***/ "./src/actions.ts":
/*!************************!*\
  !*** ./src/actions.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.setModTypeConflictsSetting = exports.setEditCycle = exports.setFileOverrideDialog = exports.setConflictDialog = exports.setConflictInfo = exports.highlightConflictIcon = exports.setType = exports.closeDialog = exports.setCreateRule = exports.setTarget = exports.setSource = void 0;
      const redux_act_1 = __webpack_require__(/*! redux-act */ "redux-act");
      exports.setSource = (0, redux_act_1.createAction)('SET_MOD_CONNECTION_SOURCE', (id, pos) => ({ id, pos }));
      exports.setTarget = (0, redux_act_1.createAction)('SET_MOD_CONNECTION_TARGET', (id, pos) => ({ id, pos }));
      exports.setCreateRule = (0, redux_act_1.createAction)('SET_MOD_CREATE_RULE', (gameId, modId, reference, defaultType) => ({ gameId, modId, reference, type: defaultType }));
      exports.closeDialog = (0, redux_act_1.createAction)('CLOSE_MOD_DEPENDENCY_DIALOG');
      exports.setType = (0, redux_act_1.createAction)('SET_MOD_RULE_TYPE');
      exports.highlightConflictIcon = (0, redux_act_1.createAction)('HIGHLIGHT_CONFLICT_ICON');
      exports.setConflictInfo = (0, redux_act_1.createAction)('SET_CONFLICT_INFO');
      exports.setConflictDialog = (0, redux_act_1.createAction)('SET_CONFLICT_DIALOG', (gameId, modIds, modRules) => ({ gameId, modIds, modRules }));
      exports.setFileOverrideDialog = (0, redux_act_1.createAction)('SET_FILE_OVERRIDE_DIALOG', (gameId, modId) => ({ gameId, modId }));
      exports.setEditCycle = (0, redux_act_1.createAction)('SET_EDIT_MOD_CYCLE', (gameId, modIds) => (gameId !== undefined) ? ({ gameId, modIds }) : undefined);
      exports.setModTypeConflictsSetting = (0, redux_act_1.createAction)('SET_MOD_TYPE_CONFLICTS_SETTING', (enabled) => ({ enabled }));


/***/ }),

/***/ "./src/index.tsx":
/*!***********************!*\
  !*** ./src/index.tsx ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      const __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const conflicts_1 = __importDefault(__webpack_require__(/*! ./util/conflicts */ "./src/util/conflicts.ts"));
      const DependenciesFilter_1 = __importDefault(__webpack_require__(/*! ./util/DependenciesFilter */ "./src/util/DependenciesFilter.tsx"));
      const findRule_1 = __importDefault(__webpack_require__(/*! ./util/findRule */ "./src/util/findRule.ts"));
      const renderModLookup_1 = __importDefault(__webpack_require__(/*! ./util/renderModLookup */ "./src/util/renderModLookup.ts"));
      const ruleFulfilled_1 = __importDefault(__webpack_require__(/*! ./util/ruleFulfilled */ "./src/util/ruleFulfilled.ts"));
      const showUnsolvedConflicts_1 = __importDefault(__webpack_require__(/*! ./util/showUnsolvedConflicts */ "./src/util/showUnsolvedConflicts.ts"));
      const topologicalSort_1 = __webpack_require__(/*! ./util/topologicalSort */ "./src/util/topologicalSort.ts");
      const ConflictEditor_1 = __importDefault(__webpack_require__(/*! ./views/ConflictEditor */ "./src/views/ConflictEditor.tsx"));
      const ConflictGraph_1 = __importDefault(__webpack_require__(/*! ./views/ConflictGraph */ "./src/views/ConflictGraph.tsx"));
      const Connector_1 = __importDefault(__webpack_require__(/*! ./views/Connector */ "./src/views/Connector.tsx"));
      const DependencyIcon_1 = __importDefault(__webpack_require__(/*! ./views/DependencyIcon */ "./src/views/DependencyIcon.tsx"));
      const Editor_1 = __importDefault(__webpack_require__(/*! ./views/Editor */ "./src/views/Editor.tsx"));
      const ModNameWrapper_1 = __importDefault(__webpack_require__(/*! ./views/ModNameWrapper */ "./src/views/ModNameWrapper.tsx"));
      const OverrideEditor_1 = __importDefault(__webpack_require__(/*! ./views/OverrideEditor */ "./src/views/OverrideEditor.tsx"));
      const Settings_1 = __importDefault(__webpack_require__(/*! ./views/Settings */ "./src/views/Settings.tsx"));
      const actions_1 = __webpack_require__(/*! ./actions */ "./src/actions.ts");
      const reducers_1 = __webpack_require__(/*! ./reducers */ "./src/reducers.ts");
      const selectors_1 = __webpack_require__(/*! ./selectors */ "./src/selectors.ts");
      const unsolvedConflictsCheck_1 = __importDefault(__webpack_require__(/*! ./unsolvedConflictsCheck */ "./src/unsolvedConflictsCheck.ts"));
      const disableModTypeConflicts_1 = __webpack_require__(/*! ./util/disableModTypeConflicts */ "./src/util/disableModTypeConflicts.ts");
      const bluebird_1 = __importDefault(__webpack_require__(/*! bluebird */ "bluebird"));
      const _ = __importStar(__webpack_require__(/*! lodash */ "lodash"));
      const path = __importStar(__webpack_require__(/*! path */ "path"));
      const React = __importStar(__webpack_require__(/*! react */ "react"));
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const shortid = __webpack_require__(/*! shortid */ "../../node_modules/shortid/index.js");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const CONFLICT_NOTIFICATION_ID = 'mod-file-conflict';
      const UNFULFILLED_NOTIFICATION_ID = 'mod-rule-unfulfilled';
      function makeReference(mod) {
        return {
          fileExpression: mod.fileName !== undefined
            ? path.basename(mod.fileName, path.extname(mod.fileName))
            : undefined,
          fileMD5: mod.fileMD5,
          versionMatch: mod.fileVersion,
          logicalFileName: mod.logicalFileName,
        };
      }
      function inverseRule(ruleType) {
        switch (ruleType) {
          case 'before': return 'after';
          case 'after': return 'before';
          case 'conflicts': return 'conflicts';
          default: throw new Error('unsupported rule ' + ruleType);
        }
      }
      const validRuleTypes = ['before', 'after', 'conflicts', 'requires', 'recommends', 'provides'];
      function mapRules(source, rules) {
        const res = [];
        if (rules === undefined) {
          return res;
        }
        rules.forEach(rule => {
          if (!validRuleTypes.includes(rule === null || rule === void 0 ? void 0 : rule.type)) {
            (0, vortex_api_1.log)('warn', 'unsupported rule type', rule);
            return;
          }
          if (['requires', 'recommends', 'provides'].indexOf(rule.type) !== -1) {
            return;
          }
          res.push({
            source,
            type: rule.type,
            reference: rule.reference,
            original: true,
          });
          try {
            const inverseRuleType = inverseRule(rule.type);
            res.push({
              source: rule.reference,
              type: inverseRuleType,
              reference: source,
              original: false,
            });
          }
          catch (err) {
            (0, vortex_api_1.log)('warn', 'failed to create reverse rule', err);
          }
        });
        return res;
      }
      function updateMetaRules(api, gameId, mods) {
        let rules = [];
        return bluebird_1.default.map(Object.keys(mods || {}), modId => {
          let _a, _b, _c;
          const mod = mods[modId];
          if (mod.attributes === undefined) {
            return;
          }
          const ref = vortex_api_1.util.makeModReference(mod);
          if ((ref.fileExpression === undefined)
            && (ref.fileMD5 === undefined)
            && (ref.logicalFileName === undefined)) {
            return;
          }
          rules = rules.concat(mapRules(ref, mod.rules));
          let downloadGame = mod.attributes['downloadGame'] || gameId;
          if (Array.isArray(downloadGame)) {
            downloadGame = downloadGame[0];
          }
          const state = api.store.getState();
          const downloadPath = vortex_api_1.selectors.downloadPathForGame(state, downloadGame);
          const fileName = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.fileName;
          const filePath = fileName !== undefined ? path.join(downloadPath, fileName) : undefined;
          return api.lookupModMeta({
            fileMD5: (_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.fileMD5,
            fileSize: (_c = mod.attributes) === null || _c === void 0 ? void 0 : _c.fileSize,
            filePath,
            gameId: downloadGame,
          })
            .then((meta) => {
              let _a;
              if ((meta.length > 0) && (meta[0].value !== undefined)) {
                rules = rules.concat(mapRules(makeReference(meta[0].value), meta[0].value.rules));
                if (((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.fileMD5) === undefined) {
                  api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, mod.id, 'fileMD5', meta[0].value.fileMD5));
                }
              }
            })
            .catch((err) => {
              (0, vortex_api_1.log)('warn', 'failed to look up mod', { err: err.message, stack: err.stack });
            });
        })
          .then(() => rules);
      }
      function findOverridenByFile(conflicts, mods, fileName) {
        const res = [];
        const relevantConflicts = conflicts.filter(c => c.files.includes(fileName));
        const relevantMods = mods.filter(m => (m.fileOverrides !== undefined && m.fileOverrides.includes(fileName))
        || relevantConflicts.some(c => c.otherMod.id === m.id));
        res.push(...relevantMods);
        return res;
      }
      const hasOverrides = (mod) => (mod === null || mod === void 0 ? void 0 : mod.fileOverrides) !== undefined && mod.fileOverrides.length > 0;
      const hasSameModType = ((lhs, rhs) => lhs.type === rhs.type);
      const purgeSingleMod = (api, gameMode, modId) => api.emitAndAwait('deploy-single-mod', gameMode, modId, false);
      const purgeModList = (api, modIds, gameMode) => new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
        for (const modId of modIds) {
          yield purgeSingleMod(api, gameMode, modId).catch(err => reject(err));
        }
        return resolve();
      }));
      const purgeAllMods = (api) => new Promise((resolve, reject) => {
        api.events.emit('purge-mods', false, err => (err !== null)
          ? reject(err)
          : resolve());
      });
      function addFileOverrides(api) {
        let _a, _b, _c, _d;
        const state = api.getState();
        const gameId = vortex_api_1.selectors.activeGameId(state);
        const mods = (_b = (_a = state === null || state === void 0 ? void 0 : state.persistent) === null || _a === void 0 ? void 0 : _a.mods) === null || _b === void 0 ? void 0 : _b[gameId];
        const knownConflicts = (_d = (_c = state === null || state === void 0 ? void 0 : state.session) === null || _c === void 0 ? void 0 : _c['dependencies']) === null || _d === void 0 ? void 0 : _d.conflicts;
        const enabled = (0, selectors_1.enabledModKeys)(state).reduce((accum, mod) => {
          if (!!mods[mod === null || mod === void 0 ? void 0 : mod.id]) {
            accum[mod.id] = mods[mod.id];
          }
          return accum;
        }, {});
        const batchedActions = [];
        const addOverrides = (modId, conflict) => {
          const lhs = enabled[modId];
          const rhs = enabled[conflict.otherMod.id];
          if (lhs === undefined || rhs === undefined) {
            return;
          }
          if (!hasSameModType(lhs, rhs)) {
            batchedActions.push(vortex_api_1.actions.setFileOverride(gameId, modId, conflict.files));
            batchedActions.push(vortex_api_1.actions.setFileOverride(gameId, conflict.otherMod.id, conflict.files));
          }
        };
        for (const modId of Object.keys(enabled)) {
          const conflicts = knownConflicts === null || knownConflicts === void 0 ? void 0 : knownConflicts[modId];
          if (conflicts === undefined) {
            continue;
          }
          for (const conflict of conflicts) {
            if (!hasOverrides(enabled[modId]) && !hasOverrides(enabled[conflict.otherMod.id])) {
              addOverrides(modId, conflict);
            }
          }
        }
        if (batchedActions.length > 0) {
          vortex_api_1.util.batchDispatch(api.store, batchedActions);
        }
      }
      function updateOverrides(api, startTime, batched) {
        let _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
          const state = api.store.getState();
          const gameMode = vortex_api_1.selectors.activeGameId(state);
          const mods = (_a = state.persistent.mods) === null || _a === void 0 ? void 0 : _a[gameMode];
          const knownConflicts = (_c = (_b = state === null || state === void 0 ? void 0 : state.session) === null || _b === void 0 ? void 0 : _b['dependencies']) === null || _c === void 0 ? void 0 : _c.conflicts;
          if (!gameMode || !mods) {
            return;
          }
          const ensureUnique = (arr) => Array.from(new Set(arr));
          const enabledKeys = (0, selectors_1.enabledModKeys)(state).map((m) => m.id);
          const toAction = (modId, fileOverrides) => vortex_api_1.actions.setFileOverride(gameMode, modId, fileOverrides);
          const enabled = (_d = (0, selectors_1.enabledModsWithOverrides)(state)) !== null && _d !== void 0 ? _d : [];
          const overrideActions = [];
          const solved = new Set();
          const types = new Set();
          let batchedActions = batched || [];
          const overrideChanges = enabled.reduce((accum, mod) => {
            let _a, _b, _c;
            types.add(mod.type);
            const modId = mod.id;
            const conflicts = ((_a = knownConflicts === null || knownConflicts === void 0 ? void 0 : knownConflicts[modId]) !== null && _a !== void 0 ? _a : []).filter(c => enabledKeys.includes(c.otherMod.id));
            if (conflicts.length === 0) {
              accum[modId] = [];
              return accum;
            }
            const modOverrides = mod.fileOverrides || [];
            const invalidOverrides = modOverrides.reduce((accum, o) => {
              const hasConflict = conflicts.some(c => c.files.includes(o));
              const canFileDeploy = conflicts
                .filter(c => c.files.includes(o))
                .some(c => {
                  let _a;
                  const otherMod = enabled.find(m => m.id === c.otherMod.id);
                  return !((_a = otherMod === null || otherMod === void 0 ? void 0 : otherMod.fileOverrides) === null || _a === void 0 ? void 0 : _a.includes(o));
                });
              if (!hasConflict || !canFileDeploy) {
                accum.push(o);
              }
              return accum;
            }, []);
            const invalidBatched = toAction(modId, modOverrides.filter(o => !invalidOverrides.includes(o)));
            batchedActions = !!batchedActions
              ? [].concat([invalidBatched], batchedActions)
              : [invalidBatched];
            for (const conflict of conflicts) {
              for (const fileName of conflict.files) {
                if (solved.has(fileName)) {
                  continue;
                }
                const conflicting = findOverridenByFile(conflicts, Object.values(enabled), fileName);
                const isDeploying = (conflicting.length > 1)
                  ? conflicting.find(c => { let _a; return ((_a = c.fileOverrides) !== null && _a !== void 0 ? _a : []).includes(fileName); }) === undefined : true;
                if (conflicting.length === 1 && !isDeploying) {
                  const overrides = (mod.fileOverrides || []).filter(over => over !== fileName);
                  accum[modId] = ensureUnique(overrides);
                  solved.add(fileName);
                  continue;
                }
                const sorted = (0, topologicalSort_1.topologicalSort)(conflicting);
                const top = sorted[0];
                solved.add(fileName);
                accum[top] = ensureUnique(accum[top] || mod.fileOverrides).filter(over => over !== fileName);
                for (const iter of sorted.slice(1)) {
                  const overrides = (accum[iter] || ((_c = (_b = mods[iter]) === null || _b === void 0 ? void 0 : _b.fileOverrides) !== null && _c !== void 0 ? _c : [])).concat(fileName);
                  accum[iter] = ensureUnique(overrides);
                }
              }
            }
            return accum;
          }, {});
          if (Object.keys(overrideChanges).length > 0) {
            for (const [modId, overrides] of Object.entries(overrideChanges)) {
              overrideActions.push(vortex_api_1.actions.setFileOverride(gameMode, modId, overrides));
            }
          }
          if (overrideActions.length === 0 && !batchedActions) {
            return;
          }
          (0, vortex_api_1.log)('info', 'starting purge activity to update overrides');
          return (types.size > 1 ? purgeAllMods(api) : Promise.resolve())
            .then(() => {
              if (!!batchedActions && batchedActions.length > 0) {
                overrideActions.push(...batchedActions);
              }
              if (overrideActions.length > 0) {
                vortex_api_1.util.batchDispatch(api.store, overrideActions);
              }
              const purgeEndTime = new Date().getTime();
              const elapsedPurgeTime = (purgeEndTime - startTime) / 1000;
              (0, vortex_api_1.log)('info', `finished purge activity in ${elapsedPurgeTime} seconds`);
              return Promise.resolve();
            });
        });
      }
      function removeFileOverrideRedundancies(api, gameMode, data) {
        let _a;
        const state = api.store.getState();
        if (!data || Object.keys(data).length === 0) {
          return;
        }
        const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', gameMode], {});
        const modsWithRedundancies = ((_a = (0, selectors_1.modsWithOverrides)(state)) !== null && _a !== void 0 ? _a : [])
          .filter(mod => { let _a; return ((_a = mod === null || mod === void 0 ? void 0 : mod.fileOverrides) !== null && _a !== void 0 ? _a : []).find(filePath => { let _a; return ((_a = data === null || data === void 0 ? void 0 : data[mod.id]) !== null && _a !== void 0 ? _a : []).includes(filePath); }) !== undefined; });
        const batchedActions = modsWithRedundancies.reduce((accum, iter) => {
          let _a, _b;
          const currentFileOverrides = ((_a = mods[iter.id]) === null || _a === void 0 ? void 0 : _a.fileOverrides) || [];
          const removedFiles = (_b = data[iter.id]) !== null && _b !== void 0 ? _b : [];
          const newOverrides = currentFileOverrides.filter(over => !removedFiles.includes(over));
          accum.push(vortex_api_1.actions.setFileOverride(gameMode, iter.id, newOverrides));
          return accum;
        }, []);
        vortex_api_1.util.batchDispatch(api.store, batchedActions);
      }
      const dependencyState = vortex_api_1.util.makeReactive({
        modRules: [],
      });
      let loadOrder = {};
      let loadOrderChanged = () => undefined;
      let dependenciesChanged = () => undefined;
      function updateConflictInfo(api, gameId, conflicts) {
        return __awaiter(this, void 0, void 0, function* () {
          const t = api.translate;
          const store = api.store;
          const mods = store.getState().persistent.mods[gameId];
          const unsolved = {};
          if (mods === undefined) {
            store.dispatch(vortex_api_1.actions.dismissNotification(CONFLICT_NOTIFICATION_ID));
            return;
          }
          const encountered = new Set();
          const mapEnc = (lhs, rhs) => [lhs, rhs].sort().join(':');
          Object.keys(conflicts).forEach(modId => {
            const filtered = conflicts[modId].filter(conflict => ((0, findRule_1.default)(dependencyState.modRules, mods[modId], conflict.otherMod) === undefined)
                && !encountered.has(mapEnc(modId, conflict.otherMod.id)));
            if (filtered.length !== 0) {
              unsolved[modId] = filtered;
              filtered.forEach(conflict => {
                encountered.add(mapEnc(modId, conflict.otherMod.id));
              });
            }
          });
          if (Object.keys(unsolved).length === 0) {
            store.dispatch(vortex_api_1.actions.dismissNotification(CONFLICT_NOTIFICATION_ID));
          }
          else {
            const message = [
              t('There are unresolved file conflicts. This just means that two or more mods contain the '
                    + 'same files and you need to decide which of them loads last and thus provides '
                    + 'the files.\n'),
              '[table][tbody]',
            ].concat(Object.keys(unsolved).map(modId => '[tr]' + t('[td]{{modName}}[/td]'
                + '[td][color="red"][svg]conflict[/svg][/color][/td]'
                + '[td][list]{{conflicts}}[/list][/td][/tr]', {
              replace: {
                modName: vortex_api_1.util.renderModName(mods[modId]),
                conflicts: unsolved[modId].map(conflict => '[*] ' + (0, renderModLookup_1.default)(conflict.otherMod)),
              }
            })), '[/tbody][/table]');
            const showDetails = () => {
              store.dispatch(vortex_api_1.actions.showDialog('info', t('Unresolved file conflicts'), {
                bbcode: message.join('\n'),
                options: { translated: true, wrap: true },
              }, [
                { label: 'Close' },
                { label: 'Show', action: () => {
                  (0, showUnsolvedConflicts_1.default)(api, dependencyState.modRules, undefined, gameId);
                } },
              ]));
            };
            store.dispatch(vortex_api_1.actions.addNotification({
              type: 'warning',
              message: 'There are unresolved file conflicts',
              id: CONFLICT_NOTIFICATION_ID,
              noDismiss: true,
              actions: [{
                title: 'More',
                action: showDetails,
              }],
            }));
          }
        });
      }
      function renderRuleType(t, type) {
        switch (type) {
          case 'conflicts': return t('conflicts with');
          case 'requires': return t('requires');
          default: return 'unknown';
        }
      }
      function checkRulesFulfilled(api) {
        const t = api.translate;
        const store = api.store;
        const state = store.getState();
        const enabledMods = (0, selectors_1.enabledModKeys)(state);
        const activeProfile = vortex_api_1.selectors.activeProfile(state);
        if (activeProfile === undefined) {
          return bluebird_1.default.resolve();
        }
        const gameMode = activeProfile.gameId;
        const mods = state.persistent.mods[gameMode];
        return bluebird_1.default.map(enabledMods, modLookup => {
          let _a, _b, _c;
          const mod = mods[modLookup.id];
          let downloadGame = vortex_api_1.util.getSafe(mod.attributes, ['downloadGame'], gameMode);
          if (Array.isArray(downloadGame)) {
            downloadGame = downloadGame[0];
          }
          const downloadPath = vortex_api_1.selectors.downloadPathForGame(state, downloadGame);
          const fileName = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.fileName;
          const filePath = fileName !== undefined ? path.join(downloadPath, fileName) : undefined;
          return api.lookupModMeta({
            fileMD5: (_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.fileMD5,
            fileSize: (_c = mod.attributes) === null || _c === void 0 ? void 0 : _c.fileSize,
            filePath,
            gameId: downloadGame,
          })
            .then((meta) => {
              let _a, _b, _c;
              if ((meta.length > 0) && (((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.fileMD5) === undefined)) {
                api.store.dispatch(vortex_api_1.actions.setModAttribute(gameMode, mod.id, 'fileMD5', meta[0].value.fileMD5));
              }
              const rules = [].concat(((meta.length > 0) && (meta[0].value !== undefined)) ? meta[0].value.rules || [] : [], vortex_api_1.util.getSafe(mods[modLookup.id], ['rules'], []));
              const rulesUnfulfilled = rules.filter(rule => (0, ruleFulfilled_1.default)(enabledMods, rule, { gameId: gameMode, modId: mod.id }) === false);
              const res = (rulesUnfulfilled.length === 0)
                ? null : {
                  modId: mod.id,
                  rules: rulesUnfulfilled,
                };
              if ((((_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.fileMD5) === undefined) && (((_c = meta === null || meta === void 0 ? void 0 : meta[0]) === null || _c === void 0 ? void 0 : _c.value) !== undefined)) {
                store.dispatch(vortex_api_1.actions.setModAttribute(gameMode, mod.id, 'fileMD5', meta[0].value.fileMD5));
              }
              return Promise.resolve(res);
            });
        })
          .then((unfulfilled) => {
            return bluebird_1.default.map(unfulfilled.filter(iter => iter !== null), iter => api.emitAndAwait('unfulfilled-rules', activeProfile.id, iter.modId, iter.rules)
              .then((result) => Promise.resolve(result[0]
                ? undefined
                : iter)))
              .filter(iter => iter !== undefined);
          })
          .then((unfulfilled) => {
            const modsUnfulfilled = unfulfilled.filter(iter => iter !== null);
            if (modsUnfulfilled.length === 0) {
              store.dispatch(vortex_api_1.actions.dismissNotification(UNFULFILLED_NOTIFICATION_ID));
            }
            else {
              const hasRequired = new Set([]);
              const message = [
                t('There are mod dependency rules that aren\'t fulfilled.'),
                '[list]',
              ].concat(modsUnfulfilled.map(iter => iter.rules.map((rule) => {
                const modName = vortex_api_1.util.renderModName(mods[iter.modId]);
                if (rule.type === 'requires') {
                  hasRequired.add(iter.modId);
                }
                const type = renderRuleType(t, rule.type);
                const other = vortex_api_1.util.renderModReference(rule.reference, mods[rule.reference.id]);
                return `[*] "${modName}" ${type} "${other}"`;
              }).join('<br/>')))
                .concat(['[/list]']);
              const showDetails = () => {
                const dialogActions = [{ label: 'Close' }];
                if (hasRequired.size > 0) {
                  dialogActions.push({
                    label: 'Install Dependencies',
                    action: () => {
                      api.events.emit('install-dependencies', activeProfile === null || activeProfile === void 0 ? void 0 : activeProfile.id, gameMode, Array.from(hasRequired));
                    },
                  });
                }
                store.dispatch(vortex_api_1.actions.showDialog('info', t('Unresolved mod conflicts or requirements'), {
                  bbcode: message.join('<br/>'),
                  options: { translated: true, wrap: true },
                }, dialogActions));
              };
              store.dispatch(vortex_api_1.actions.addNotification({
                type: 'warning',
                message: 'Some mod dependencies are not fulfilled',
                id: UNFULFILLED_NOTIFICATION_ID,
                noDismiss: true,
                actions: [{
                  title: 'More',
                  action: showDetails,
                }],
              }));
            }
          });
      }
      const shouldSuppressUpdate = (api) => {
        const state = api.getState();
        const suppressOnActivities = ['conflicts', 'installing_dependencies', 'deployment', 'purging'];
        const isActivityRunning = (activity) => vortex_api_1.util.getSafe(state, ['session', 'base', 'activity', 'mods'], []).includes(activity)
        || vortex_api_1.util.getSafe(state, ['session', 'base', 'activity', activity], []).length > 0;
        const suppressingActivities = suppressOnActivities.filter(activity => isActivityRunning(activity));
        const suppressing = suppressingActivities.length > 0;
        if (suppressing) {
          (0, vortex_api_1.log)('info', 'skipping conflict/override checks during activities', { activities: suppressingActivities });
        }
        return suppressing;
      };
      function checkConflictsAndRules(api) {
        let _a;
        const state = api.getState();
        const stagingPath = vortex_api_1.selectors.installPath(state);
        const gameMode = vortex_api_1.selectors.activeGameId(state);
        (0, vortex_api_1.log)('debug', 'check conflicts and rules', { gameMode });
        if (gameMode === undefined) {
          return Promise.resolve();
        }
        const game = vortex_api_1.util.getGame(gameMode);
        if ((game === undefined) || (game.mergeMods === false)) {
          return Promise.resolve();
        }
        const discovery = vortex_api_1.selectors.currentGameDiscovery(state);
        if ((discovery === undefined) || (discovery.path === undefined)) {
          return Promise.resolve();
        }
        const modState = vortex_api_1.selectors.activeProfile(state).modState;
        const gameMods = (_a = state.persistent.mods[gameMode]) !== null && _a !== void 0 ? _a : {};
        const mods = Object.keys(gameMods)
          .filter(modId => vortex_api_1.util.getSafe(modState, [modId, 'enabled'], false))
          .filter(modId => { let _a, _b; return ((_b = (_a = vortex_api_1.util.getModType(gameMods[modId].type)) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b['noConflicts']) !== true; })
          .map(modId => state.persistent.mods[gameMode][modId]);
        const activator = vortex_api_1.util.getCurrentActivator(state, gameMode, true);
        api.store.dispatch(vortex_api_1.actions.startActivity('mods', 'conflicts'));
        return (0, conflicts_1.default)(api, game, stagingPath, mods, activator)
          .then(conflictMap => {
            if (!_.isEqual(conflictMap, state.session['dependencies'].conflicts)) {
              api.store.dispatch((0, actions_1.setConflictInfo)(conflictMap));
            }
            updateConflictInfo(api, gameMode, conflictMap);
            return checkRulesFulfilled(api);
          })
          .catch(err => {
            const allowReport = ![1392, 433].includes(err === null || err === void 0 ? void 0 : err.systemCode);
            api.showErrorNotification('Failed to determine conflicts', err, { allowReport });
          });
      }
      function checkRedundantFileOverrides(api) {
        return () => new bluebird_1.default((resolve, reject) => {
          let _a;
          const state = api.store.getState();
          const gameId = vortex_api_1.selectors.activeGameId(state);
          const discovery = vortex_api_1.selectors.discoveryByGame(state, gameId);
          if ((discovery === null || discovery === void 0 ? void 0 : discovery.path) === undefined) {
            return resolve(undefined);
          }
          const modsWithFileOverrides = ((_a = (0, selectors_1.enabledModsWithOverrides)(state)) !== null && _a !== void 0 ? _a : []);
          if (modsWithFileOverrides.length === 0) {
            return resolve(undefined);
          }
          const fileExists = (filePath) => vortex_api_1.fs.statAsync(filePath)
            .then(() => bluebird_1.default.resolve(true))
            .catch(err => (err.code !== 'ENOENT') ? bluebird_1.default.resolve(true) : bluebird_1.default.resolve(false));
          const game = vortex_api_1.util.getGame(gameId);
          const modPaths = game.getModPaths(discovery.path);
          return bluebird_1.default.reduce(modsWithFileOverrides, (accum, iter) => {
            if ((iter === null || iter === void 0 ? void 0 : iter.installationPath) === undefined) {
              return accum;
            }
            const deployPath = modPaths[iter.type];
            if (deployPath === undefined) {
              return accum;
            }
            const missing = [];
            const stagingFolder = vortex_api_1.selectors.installPathForGame(state, gameId);
            const modInstallationPath = iter.installationPath;
            const modPath = path.join(stagingFolder, modInstallationPath);
            const filePaths = iter.fileOverrides
              .map(file => {
                const relPath = path.relative(deployPath, file);
                return { rel: relPath, abs: path.join(modPath, relPath) };
              });
            return bluebird_1.default.each(filePaths, filePath => fileExists(filePath.abs)
              .then(res => {
                if (res === false) {
                  missing.push(filePath.abs);
                }
              }))
              .then(() => {
                if (missing.length > 0) {
                  accum[iter.id] = missing;
                }
                return Promise.resolve(accum);
              });
          }, {})
            .then(redundant => {
              removeFileOverrideRedundancies(api, gameId, redundant);
              return Promise.resolve();
            })
            .finally(() => resolve(undefined));
        });
      }
      function showCycles(api, cycles, gameId) {
        const state = api.store.getState();
        const mods = state.persistent.mods[gameId];
        const id = shortid();
        api.showDialog('error', 'Cycles', {
          text: 'Dependency rules between your mods contain cycles, '
            + 'like "A after B" and "B after A". You need to remove one of the '
            + 'rules causing the cycle, otherwise your mods can\'t be '
            + 'applied in the right order.',
          links: cycles.map((cycle, idx) => ({
            label: cycle
              .map(modId => mods[modId] !== undefined ? vortex_api_1.util.renderModName(mods[modId]) : modId)
              .map(name => `[${name}]`)
              .join(' --> '),
            action: () => {
              api.closeDialog(id);
              api.store.dispatch((0, actions_1.setEditCycle)(gameId, cycle));
            },
          })),
        }, [
          { label: 'Close' },
        ], id);
      }
      function updateCycles(api, cycles) {
        const state = api.store.getState();
        if (state.session.dependencies.editCycle !== undefined) {
          const displayed = new Set(state.session.dependencies.editCycle.modIds);
          const update = cycles.find(cycle => cycle.find(modId => displayed.has(modId)) !== undefined);
          const gameId = vortex_api_1.selectors.activeGameId(state);
          api.store.dispatch((0, actions_1.setEditCycle)(update !== undefined ? gameId : undefined, update));
        }
      }
      function generateLoadOrder(api) {
        const store = api.store;
        const gameMode = vortex_api_1.selectors.activeGameId(store.getState());
        const state = store.getState();
        const gameMods = state.persistent.mods[gameMode] || {};
        const profile = vortex_api_1.selectors.activeProfile(state);
        const mods = Object.keys(gameMods)
          .filter(key => vortex_api_1.util.getSafe(profile, ['modState', key, 'enabled'], false))
          .map(key => gameMods[key]);
        return vortex_api_1.util.sortMods(gameMode, mods, api)
          .then(sorted => {
            const newState = api.store.getState();
            if (newState.session.dependencies.editCycle !== undefined) {
              api.store.dispatch((0, actions_1.setEditCycle)(undefined, undefined));
            }
            return Promise.resolve(sorted);
          })
          .catch(vortex_api_1.util.CycleError, err => {
            updateCycles(api, err.cycles);
            api.sendNotification({
              id: 'mod-cycle-warning',
              type: 'warning',
              message: 'Mod rules contain cycles',
              noDismiss: true,
              actions: [
                {
                  title: 'Show', action: () => {
                    showCycles(api, err.cycles, gameMode);
                  },
                },
              ],
            });
            return Promise.resolve(mods);
          })
          .then((sortedMods) => {
            loadOrder = sortedMods
              .filter((mod) => vortex_api_1.util.getSafe(profile.modState, [mod.id, 'enabled'], false))
              .reduce((prev, mod, idx) => {
                prev[mod.id] = idx;
                return prev;
              }, {});
            loadOrderChanged();
          })
          .catch(vortex_api_1.util.CycleError, () => {
            api.sendNotification({
              id: 'sorting-mods-failed',
              type: 'warning',
              title: 'Sorting mods failed',
              message: 'Rules contain cycles',
              displayMS: 5000,
            });
          });
      }
      function changeMayAffectOverrides(before, after) {
        const overrideSort = (mod) => (mod.fileOverrides !== undefined) ? [...mod.fileOverrides].sort() : [];
        if ((before === undefined)
        || (((before === null || before === void 0 ? void 0 : before.type) !== (after === null || after === void 0 ? void 0 : after.type)))
        || ((before.rules !== undefined) !== (after.rules !== undefined))
        || (!_.isEqual(overrideSort(before), overrideSort(after)))) {
          return true;
        }
        return false;
      }
      function changeMayAffectRules(before, after) {
        if ((before === undefined)
        || (((before === null || before === void 0 ? void 0 : before.type) !== (after === null || after === void 0 ? void 0 : after.type)))
        || ((before.attributes !== undefined) !== (after.attributes !== undefined))
        || ((before.rules !== undefined) !== (after.rules !== undefined))) {
          return true;
        }
        if (after.attributes === undefined) {
          return false;
        }
        return (before.rules !== after.rules)
        || (before.attributes['version'] !== after.attributes['version']);
      }
      function makeLoadOrderAttribute(api) {
        return {
          id: 'loadOrder',
          name: 'Deploy Order',
          description: 'Deploy order derived from mod dependencies',
          icon: 'order',
          placement: 'table',
          isToggleable: true,
          isSortable: true,
          isDefaultVisible: false,
          calc: (mod) => loadOrder[mod.id],
          condition: () => {
            const gameMode = vortex_api_1.selectors.activeGameId(api.store.getState());
            return vortex_api_1.util.getGame(gameMode).mergeMods !== false;
          },
          edit: {},
          externalData: (onChange) => {
            loadOrderChanged = onChange;
          },
        };
      }
      function makeDependenciesAttribute(api) {
        const res = {
          id: 'dependencies',
          name: 'Dependencies',
          description: 'Relations to other mods',
          icon: 'plug',
          placement: 'table',
          customRenderer: (mod, detailCell, t, props) => (React.createElement(DependencyIcon_1.default, { mod: Array.isArray(mod) ? mod[0] : mod, t: t, localState: dependencyState, onHighlight: props.onHighlight })),
          condition: () => {
            const gameMode = vortex_api_1.selectors.activeGameId(api.store.getState());
            return vortex_api_1.util.getGame(gameMode).mergeMods !== false;
          },
          calc: (mod) => mod,
          isToggleable: true,
          isDefaultVisible: false,
          externalData: (onChange) => {
            dependenciesChanged = onChange;
          },
          edit: {},
          isSortable: true,
          isVolatile: true,
          sortFuncRaw: (lhs, rhs, locale) => {
            let _a, _b, _c, _d;
            const filter = (_b = (_a = api.getState().settings.tables['mods'].filter) === null || _a === void 0 ? void 0 : _a['dependencies']) !== null && _b !== void 0 ? _b : [];
            if ((filter.length >= 2) && (filter[0] === 'depends')) {
              if (filter[1] === lhs.id) {
                return -1;
              }
              else if (filter[1] === rhs.id) {
                return 1;
              }
            }
            if (lhs.attributes === undefined) {
              return -1;
            }
            else if (rhs.attributes === undefined) {
              return 1;
            }
            const lName = (_c = vortex_api_1.util.renderModName(lhs)) !== null && _c !== void 0 ? _c : '';
            const rName = (_d = vortex_api_1.util.renderModName(rhs)) !== null && _d !== void 0 ? _d : '';
            return lName.localeCompare(rName);
          },
          filter: new DependenciesFilter_1.default(dependencyState, () => {
            const state = api.store.getState();
            return vortex_api_1.util.getSafe(state, ['persistent', 'mods', vortex_api_1.selectors.activeGameId(state)], {});
          }, () => vortex_api_1.util.getSafe(api.store.getState(), ['session', 'dependencies', 'conflicts'], {})),
        };
        return res;
      }
      function nothingNeeds(profile, mod, among, except) {
        const isEnabled = (modId) => vortex_api_1.util.getSafe(profile, ['modState', modId, 'enabled'], false);
        const matchesMod = rule => ['requires', 'recommends'].includes(rule.type)
        && vortex_api_1.util.testModReference(mod, rule.reference);
        return among.find(dependent => {
          return (dependent.id !== except.id)
            && (isEnabled(dependent.id))
            && (dependent.rules.find(matchesMod) !== undefined);
        }) === undefined;
      }
      function setDependenciesEnabled(profile, dependent, mods, recommendations, enabled, allDependents) {
        const filter = recommendations ? ['requires', 'recommends'] : ['requires'];
        return dependent.rules
          .filter(rule => filter.includes(rule.type))
          .map(rule => {
            const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
            if ((mod !== undefined)
            && (enabled || nothingNeeds(profile, mod, allDependents, dependent))) {
              return vortex_api_1.actions.setModEnabled(profile.id, mod.id, enabled);
            }
            else {
              return undefined;
            }
          })
          .filter(act => act !== undefined);
      }
      function queryEnableDependencies(api, modIds, gameMode, enabled) {
        const t = api.translate;
        const state = api.getState();
        const mods = state.persistent.mods[gameMode];
        const profileId = vortex_api_1.selectors.lastActiveProfileForGame(state, gameMode);
        const profile = vortex_api_1.selectors.profileById(state, profileId);
        const dependents = modIds
          .map(id => {
            let _a, _b;
            const applicableRules = ((_b = (_a = mods[id]) === null || _a === void 0 ? void 0 : _a.rules) !== null && _b !== void 0 ? _b : [])
              .filter(rule => {
                let _a, _b;
                if (!['requires', 'recommends'].includes(rule.type)) {
                  return false;
                }
                const refMod = vortex_api_1.util.findModByRef(rule.reference, mods);
                if (refMod === undefined) {
                  return false;
                }
                if (modIds.includes(refMod.id)) {
                  return false;
                }
                const isEnabled = ((_b = (_a = profile.modState[refMod.id]) === null || _a === void 0 ? void 0 : _a.enabled) !== null && _b !== void 0 ? _b : false);
                if (isEnabled === enabled) {
                  return false;
                }
                return true;
              });
            return {
              id,
              rules: applicableRules,
              count: applicableRules.length,
            };
          })
          .filter(ic => ic.count > 0);
        if (dependents.length > 0) {
          const dialogActions = [
            { label: 'Close' },
            { label: enabled ? 'Enable' : 'Disable' },
          ];
          if (dependents.length === 1) {
            dialogActions.splice(1, 0, { label: 'Review' });
          }
          let md = t('The mod you {{enabled}} depends on other mods, do you want to {{enable}} those '
            + 'as well?', {
            replace: {
              enabled: enabled ? t('enabled') : t('disabled'),
              enable: enabled ? t('enable') : t('disable'),
            },
            count: dependents.length,
          }) + '\n';
          if (!enabled) {
            md += t('This will only disable mods not required by something else but it may disable '
                + 'ones you had already enabled manually.') + '\n';
          }
          md += '\n' + dependents.map(ic => `* ${vortex_api_1.util.renderModName(mods[ic.id])}: ${t('{{count}} dependencies', { count: ic.count })}`)
            .join('\n');
          return api.showDialog('question', t('Mod has dependencies', { count: dependents.length }), {
            md,
            checkboxes: [
              { id: 'recommendations', text: 'Apply to Recommended Mods', value: false },
            ],
            options: {
              translated: true,
            },
          }, dialogActions)
            .then(result => {
              if (result.action === 'Review') {
                const batch = [];
                batch.push(vortex_api_1.actions.setAttributeFilter('mods', 'dependencies', ['depends', dependents[0], vortex_api_1.util.renderModName(mods[dependents[0].id])]));
                batch.push(vortex_api_1.actions.setAttributeSort('mods', 'dependencies', 'asc'));
                vortex_api_1.util.batchDispatch(api.store, batch);
                api.events.emit('show-main-page', 'Mods');
              }
              else if (['Enable', 'Disable'].includes(result.action)) {
                const recommendationsToo = result.input['recommendations'];
                const allDependents = Object.values(mods)
                  .filter(mod => {
                    let _a;
                    return ((_a = mod.rules) !== null && _a !== void 0 ? _a : [])
                      .find(rule => ['requires', 'recommends'].includes(rule.type));
                  });
                const batch = dependents.reduce((prev, ic) => {
                  return [].concat(prev, ...setDependenciesEnabled(profile, mods[ic.id], mods, recommendationsToo, enabled, allDependents));
                }, []);
                vortex_api_1.util.batchDispatch(api.store, batch);
              }
            });
        }
        else {
          return bluebird_1.default.resolve();
        }
      }
      let updateConflictDebouncer;
      function once(api) {
        const store = api.store;
        const updateRulesDebouncer = new vortex_api_1.util.Debouncer((gameMode) => {
          const state = store.getState();
          return generateLoadOrder(api)
            .then(() => updateMetaRules(api, gameMode, state.persistent.mods[gameMode]))
            .then(rules => {
              dependencyState.modRules = rules;
              const { conflictDialog } = store.getState().session.dependencies;
              if (!!conflictDialog) {
                store.dispatch((0, actions_1.setConflictDialog)(conflictDialog.gameId, conflictDialog.modIds, rules));
              }
              dependenciesChanged();
              return null;
            })
            .catch(err => {
              api.showErrorNotification('Failed to refresh mod rules', err);
            });
        }, 200);
        updateConflictDebouncer = new vortex_api_1.util.Debouncer((calculateOverrides, batched) => __awaiter(this, void 0, void 0, function* () {
          return (shouldSuppressUpdate(api)
            ? Promise.reject(new vortex_api_1.util.ProcessCanceled('suppressed'))
            : checkConflictsAndRules(api))
            .then(() => {
              const modTypeConflictsEnabled = vortex_api_1.util.getSafe(api.getState(), ['settings', 'workarounds', 'modTypeConflictsEnabled'], true);
              if (!modTypeConflictsEnabled || calculateOverrides === false) {
                return Promise.resolve();
              }
              (0, vortex_api_1.log)('info', 'starting overrides update');
              const startTime = new Date().getTime();
              addFileOverrides(api);
              return updateOverrides(api, startTime, batched)
                .then(() => {
                  const endTime = new Date().getTime();
                  const elapsedTime = (endTime - startTime) / 1000;
                  (0, vortex_api_1.log)('info', 'Updated file overrides in ' + elapsedTime + ' seconds');
                })
                .catch(err => {
                  (0, vortex_api_1.log)('warn', 'Failed to update file overrides', err);
                  return (err instanceof vortex_api_1.util.UserCanceled) ? Promise.resolve() : Promise.reject(err);
                });
            })
            .catch(err => {
              if (err instanceof vortex_api_1.util.ProcessCanceled && err.message === 'suppressed') {
                return Promise.resolve();
              }
              api.showErrorNotification('Failed to determine mod conflicts', err);
            })
            .finally(() => api.store.dispatch(vortex_api_1.actions.stopActivity('mods', 'conflicts')));
        }), 2000, false, true);
        api.setStylesheet('dependency-manager', path.join(__dirname, 'dependency-manager.scss'));
        api.events.on('profile-did-change', () => {
          const gameMode = vortex_api_1.selectors.activeGameId(store.getState());
          updateMetaRules(api, gameMode, store.getState().persistent.mods[gameMode])
            .then(rules => {
              dependencyState.modRules = rules;
              dependenciesChanged();
              updateConflictDebouncer.schedule(undefined, false);
            })
            .catch(err => {
              api.showErrorNotification('failed to update mod rule cache', err);
            });
        });
        api.events.on('recalculate-modtype-conflicts', (modIds) => {
          const gameMode = vortex_api_1.selectors.activeGameId(store.getState());
          updateRulesDebouncer.schedule(() => {
            updateConflictDebouncer.schedule(undefined, true);
          }, gameMode);
        });
        api.events.on('check-file-override-redundancies', (gameMode, data) => removeFileOverrideRedundancies(api, gameMode, data));
        api.events.on('gamemode-activated', (gameMode) => {
          (0, vortex_api_1.log)('debug', 'game mode activated, updating conflict info', { gameMode });
          store.dispatch((0, actions_1.setConflictInfo)(undefined));
          updateConflictInfo(api, gameMode, {});
          updateRulesDebouncer.schedule(() => {
            updateConflictDebouncer.schedule(undefined, false);
          }, gameMode);
        });
        api.events.on('edit-mod-cycle', (gameId, cycle) => {
          store.dispatch((0, actions_1.setEditCycle)(gameId, cycle));
        });
        api.onAsync('did-remove-mod', (gameMode, removedId, modId, options) => {
          let _a;
          if ((options === null || options === void 0 ? void 0 : options.willBeReplaced) || ((options === null || options === void 0 ? void 0 : options.modData) === undefined)) {
            return Promise.resolve();
          }
          const state = api.getState();
          const mods = (_a = state.persistent.mods[gameMode]) !== null && _a !== void 0 ? _a : {};
          const batched = [];
          Object.keys(mods).forEach(id => {
            let _a;
            const rulesToRemove = ((_a = mods[id].rules) !== null && _a !== void 0 ? _a : []).filter((rule) => ['before', 'after'].includes(rule.type)
                && vortex_api_1.util.testModReference(options.modData, rule.reference));
            rulesToRemove.forEach(rule => {
              batched.push(vortex_api_1.actions.removeModRule(gameMode, id, rule));
            });
          });
          if (batched.length > 0) {
            vortex_api_1.util.batchDispatch(api.store, batched);
          }
          return Promise.resolve();
        });
        api.onStateChange(['persistent', 'mods'], (oldState, newState) => {
          const gameMode = vortex_api_1.selectors.activeGameId(store.getState());
          if (oldState[gameMode] !== newState[gameMode]) {
            const relevantChange = Object.keys(newState[gameMode])
              .find(modId => (vortex_api_1.util.getSafe(oldState, [gameMode, modId], undefined) !== newState[gameMode][modId])
                && (changeMayAffectRules(vortex_api_1.util.getSafe(oldState, [gameMode, modId], undefined), newState[gameMode][modId])));
            if (relevantChange !== undefined) {
              updateRulesDebouncer.schedule(() => {
                updateConflictDebouncer.schedule(undefined, true);
              }, gameMode);
            }
          }
        });
        api.onAsync('will-enable-mods', (profileId, modIds, enabled, options) => {
          if ((options === null || options === void 0 ? void 0 : options.installed) || (options === null || options === void 0 ? void 0 : options.willBeReplaced)) {
            return Promise.resolve();
          }
          const profile = vortex_api_1.selectors.profileById(api.getState(), profileId);
          return queryEnableDependencies(api, modIds, profile.gameId, enabled)
            .catch(err => {
              api.showErrorNotification('Failed to test for dependencies', err);
            });
        });
        api.events.on('mods-enabled', (modIds, enabled, gameMode, options) => {
          if (gameMode === vortex_api_1.selectors.activeGameId(store.getState())) {
            updateRulesDebouncer.schedule(() => {
              updateConflictDebouncer.schedule(undefined, true);
            }, gameMode);
          }
        });
      }
      class ManageRuleButtonImpl extends vortex_api_1.PureComponentEx {
        render() {
          const { t, onClick, notifications } = this.props;
          const hasConflicts = notifications.find(iter => iter.id === CONFLICT_NOTIFICATION_ID);
          return (React.createElement(vortex_api_1.ToolbarIcon, { id: 'manage-mod-rules-button', icon: 'connection', text: t('Manage Rules'), className: hasConflicts ? 'toolbar-flash-button' : undefined, onClick: onClick }));
        }
      }
      function mapStateToProps(state) {
        return {
          notifications: state.session.notifications.notifications,
        };
      }
      const ManageRuleButton = (0, react_i18next_1.withTranslation)(['common'])((0, react_redux_1.connect)(mapStateToProps)(ManageRuleButtonImpl));
      const pathTool = {
        isAbsolute: path.isAbsolute,
        relative: path.relative,
        basename: path.basename,
        dirname: path.dirname,
        join: path.join,
        sep: path.sep,
      };
      function main(context) {
        context.registerReducer(['settings', 'workarounds'], reducers_1.settingsReducer);
        context.registerReducer(['session', 'dependencies'], reducers_1.sessionReducer);
        context.registerTableAttribute('mods', makeLoadOrderAttribute(context.api));
        context.registerTableAttribute('mods', makeDependenciesAttribute(context.api));
        context.registerAction('mod-icons', 90, ManageRuleButton, {}, () => {
          const state = context.api.store.getState();
          return {
            notifications: state.session.notifications.notifications,
            onClick: () => (0, showUnsolvedConflicts_1.default)(context.api, dependencyState.modRules, true),
          };
        });
        context.registerDialog('mod-dependencies-connector', Connector_1.default);
        context.registerDialog('mod-dependencies-editor', Editor_1.default);
        context.registerDialog('mod-conflict-editor', ConflictEditor_1.default, () => ({
          pathTool,
        }));
        context.registerDialog('mod-cycle-graph', () => (React.createElement(ConflictGraph_1.default, { width: 500, height: 500, nodeDistance: 80, nodeRadius: 10, localState: dependencyState })));
        context.registerDialog('mod-fileoverride-editor', OverrideEditor_1.default, () => ({
          localState: dependencyState,
          pathTool,
          onSetFileOverrides: (batchedActions) => __awaiter(this, void 0, void 0, function* () {
            const state = context.api.getState();
            const modTypeConflictsEnabled = vortex_api_1.util.getSafe(state, ['settings', 'workarounds', 'modTypeConflictsEnabled'], true);
            if (!modTypeConflictsEnabled) {
              vortex_api_1.util.batchDispatch(context.api.store.dispatch, batchedActions);
            }
            else {
              updateConflictDebouncer.schedule(undefined, true, batchedActions);
            }
          }),
          toRelPath: (mod, filePath) => {
            const state = context.api.getState();
            const gameId = vortex_api_1.selectors.activeGameId(state);
            const discovery = vortex_api_1.selectors.discoveryByGame(state, gameId);
            if ((discovery === null || discovery === void 0 ? void 0 : discovery.path) === undefined) {
              return null;
            }
            const game = vortex_api_1.util.getGame(gameId);
            const modPaths = game.getModPaths(discovery.path);
            const modPath = modPaths[mod.type];
            if (modPath === undefined) {
              return null;
            }
            return pathTool.relative(modPath, filePath);
          }
        }));
        context.registerAction('mods-action-icons', 100, 'groups', {}, 'Manage File Conflicts', instanceIds => {
          const { store } = context.api;
          const gameMode = vortex_api_1.selectors.activeGameId(store.getState());
          store.dispatch((0, actions_1.setFileOverrideDialog)(gameMode, instanceIds[0]));
        }, instanceIds => {
          const { store, translate } = context.api;
          return (vortex_api_1.util.getSafe(store.getState(), ['session', 'dependencies', 'conflicts', instanceIds[0]], [])
            .length > 0) ? true : 'No file conflicts';
        });
        context.registerControlWrapper('mods-name', 100, ModNameWrapper_1.default);
        context.registerTest('redundant-file-overrides', 'gamemode-activated', checkRedundantFileOverrides(context.api));
        context.registerSettings('Workarounds', Settings_1.default, () => ({
          onSetModTypeConflicts: (enable) => __awaiter(this, void 0, void 0, function* () {
            yield vortex_api_1.util.toPromise(cb => context.api.events.emit('purge-mods', true, cb));
            if (enable) {
              context.api.store.dispatch((0, actions_1.setModTypeConflictsSetting)(enable));
            }
            else {
              try {
                yield (0, disableModTypeConflicts_1.disableModTypeConflictsDialog)(context.api);
              }
              catch (err) {
                if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                  context.api.showErrorNotification('Failed to disable mod type conflicts', err);
                }
                return;
              }
            }
            updateConflictDebouncer.schedule(undefined, true);
          })
        }));
        context.registerStartHook(50, 'check-unsolved-conflicts', (input) => (input.options.suggestDeploy !== false)
          ? (0, unsolvedConflictsCheck_1.default)(context.api, dependencyState.modRules, input)
          : bluebird_1.default.resolve(input));
        context.once(() => once(context.api));
        return true;
      }
      exports["default"] = main;


/***/ }),

/***/ "./src/reducers.ts":
/*!*************************!*\
  !*** ./src/reducers.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.sessionReducer = exports.settingsReducer = void 0;
      const _ = __importStar(__webpack_require__(/*! lodash */ "lodash"));
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const actions = __importStar(__webpack_require__(/*! ./actions */ "./src/actions.ts"));
      exports.settingsReducer = {
        reducers: {
          [actions.setModTypeConflictsSetting]: (state, payload) => {
            const { enabled } = payload;
            return vortex_api_1.util.setSafe(state, ['modTypeConflictsEnabled'], enabled);
          }
        },
        defaults: {
          modTypeConflictsEnabled: true,
        }
      };
      exports.sessionReducer = {
        reducers: {
          [actions.setSource]: (state, payload) => {
            if (_.isEqual(payload, vortex_api_1.util.getSafe(state, ['connection', 'source'], undefined))) {
              return state;
            }
            if (payload.pos !== undefined) {
              return vortex_api_1.util.setSafe(state, ['connection', 'source'], payload);
            }
            else if (payload.id === vortex_api_1.util.getSafe(state, ['connection', 'source', 'id'], undefined)) {
              return vortex_api_1.util.setSafe(state, ['connection', 'source'], undefined);
            }
            else {
              return state;
            }
          },
          [actions.setTarget]: (state, payload) => {
            if ((payload.pos !== undefined)
                && ((payload.id !== null)
                    || (state.connection === undefined)
                    || (state.connection.target === undefined)
                    || (state.connection.target.id === undefined)
                    || (state.connection.target.id === null))) {
              return vortex_api_1.util.setSafe(state, ['connection', 'target'], payload);
            }
            else if (payload.id === vortex_api_1.util.getSafe(state, ['connection', 'target', 'id'], undefined)) {
              return vortex_api_1.util.setSafe(state, ['connection', 'target'], undefined);
            }
            else {
              return state;
            }
          },
          [actions.setCreateRule]: (state, payload) => vortex_api_1.util.setSafe(state, ['dialog'], payload),
          [actions.closeDialog]: (state) => vortex_api_1.util.setSafe(state, ['dialog'], undefined),
          [actions.setType]: (state, payload) => vortex_api_1.util.setSafe(state, ['dialog', 'type'], payload),
          [actions.setConflictInfo]: (state, payload) => vortex_api_1.util.setSafe(state, ['conflicts'], payload),
          [actions.setConflictDialog]: (state, payload) => vortex_api_1.util.setSafe(state, ['conflictDialog'], payload),
          [actions.setFileOverrideDialog]: (state, payload) => vortex_api_1.util.setSafe(state, ['overrideDialog'], payload),
          [actions.highlightConflictIcon]: (state, payload) => vortex_api_1.util.setSafe(state, ['highlightConflicts'], payload),
          [actions.setEditCycle]: (state, payload) => vortex_api_1.util.setSafe(state, ['editCycle'], payload),
        },
        defaults: {
          connection: undefined,
          dialog: undefined,
          highlightConflicts: false,
          conflicts: undefined,
          conflictDialog: undefined,
          overrideDialog: undefined,
          editCycle: undefined,
        },
      };


/***/ }),

/***/ "./src/selectors.ts":
/*!**************************!*\
  !*** ./src/selectors.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.disabledModsWithOverrides = exports.enabledModsWithOverrides = exports.modsWithOverrides = exports.enabledModKeys = exports.currentModState = void 0;
      const _ = __importStar(__webpack_require__(/*! lodash */ "lodash"));
      const reselect_1 = __webpack_require__(/*! reselect */ "../../node_modules/reselect/es/index.js");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const allMods = (state) => state.persistent.mods;
      const currentGameMods = (0, reselect_1.createSelector)(allMods, vortex_api_1.selectors.activeGameId, (inMods, gameId) => inMods[gameId]);
      exports.currentModState = (0, reselect_1.createSelector)(vortex_api_1.selectors.activeProfile, (profile) => profile ? profile.modState : {});
      let lastLookupInfo;
      exports.enabledModKeys = (0, reselect_1.createSelector)(currentGameMods, exports.currentModState, (mods, modStateIn) => {
        const res = [];
        Object.keys(mods || {}).forEach(modId => {
          const attributes = mods[modId].attributes || {};
          if (vortex_api_1.util.getSafe(modStateIn, [modId, 'enabled'], false)
            && (attributes['fileMD5'] || attributes['fileName']
                || attributes['logicalFileName'] || attributes['name'])) {
            res.push(Object.assign(Object.assign({}, attributes), { id: modId }));
          }
        });
        if (!_.isEqual(res, lastLookupInfo)) {
          lastLookupInfo = res;
        }
        return lastLookupInfo;
      });
      let lastOverrideLookup;
      exports.modsWithOverrides = (0, reselect_1.createSelector)(currentGameMods, (mods) => {
        const res = [];
        Object.keys(mods || {}).forEach(modId => {
          let _a;
          if (((_a = mods === null || mods === void 0 ? void 0 : mods[modId].fileOverrides) !== null && _a !== void 0 ? _a : []).length > 0) {
            res.push(mods[modId]);
          }
        });
        if (!_.isEqual(res, lastLookupInfo)) {
          lastOverrideLookup = res;
        }
        return lastOverrideLookup;
      });
      exports.enabledModsWithOverrides = (0, reselect_1.createSelector)(exports.modsWithOverrides, exports.enabledModKeys, (mods, enabled) => {
        return Object.values(mods || {}).filter(mod => enabled.some(lookup => lookup.id === mod.id));
      });
      exports.disabledModsWithOverrides = (0, reselect_1.createSelector)(exports.modsWithOverrides, exports.enabledModKeys, (mods, enabled) => {
        return Object.values(mods || {}).filter(mod => !enabled.some(lookup => lookup.id === mod.id));
      });


/***/ }),

/***/ "./src/statics.ts":
/*!************************!*\
  !*** ./src/statics.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.NAMESPACE = void 0;
      exports.NAMESPACE = 'mod-dependency-manager';


/***/ }),

/***/ "./src/unsolvedConflictsCheck.ts":
/*!***************************************!*\
  !*** ./src/unsolvedConflictsCheck.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const bluebird_1 = __importDefault(__webpack_require__(/*! bluebird */ "bluebird"));
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const showUnsolvedConflicts_1 = __importDefault(__webpack_require__(/*! ./util/showUnsolvedConflicts */ "./src/util/showUnsolvedConflicts.ts"));
      function unsolvedConflictsCheck(api, modRules, input) {
        const state = api.store.getState();
        const t = api.translate;
        const findRule = (source, ref) => {
          return modRules.find(rule => vortex_api_1.util.testModReference(source, rule.source)
            && vortex_api_1.util.testModReference(ref, rule.reference));
        };
        const gameMode = vortex_api_1.selectors.activeGameId(state);
        const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', gameMode], {});
        const conflicts = vortex_api_1.util.getSafe(state, ['session', 'dependencies', 'conflicts'], {}) || {};
        const firstConflict = Object.keys(conflicts).find(modId => conflicts[modId].find(conflict => findRule(mods[modId], conflict.otherMod) === undefined) !== undefined);
        if (firstConflict !== undefined) {
          return api.showDialog('error', t('Unresolved Conflict'), {
            bbcode: t('You have unresolved file conflicts {{more}}. '
                + 'In some cases this can lead to incompatible files being used which can cause all '
                + 'kind of problems inside the game.\n'
                + 'Please address all file conflicts before running the game.', {
              replace: {
                more: `[More id='more-conflict' wikiId='file-conflicts' name='${t('Conflicts')}']${vortex_api_1.util.getText('mod', 'conflicts', t)}[/More]`,
              },
            }),
          }, [
            { label: 'Cancel' },
            { label: 'Show' },
          ])
            .then((result) => {
              if (result.action === 'Show') {
                (0, showUnsolvedConflicts_1.default)(api, modRules, undefined, gameMode);
              }
              return bluebird_1.default.reject(new vortex_api_1.util.ProcessCanceled('Unresolved File conflicts'));
            });
        }
        else {
          return bluebird_1.default.resolve(input);
        }
      }
      exports["default"] = unsolvedConflictsCheck;


/***/ }),

/***/ "./src/util/DependenciesFilter.tsx":
/*!*****************************************!*\
  !*** ./src/util/DependenciesFilter.tsx ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.DependenciesFilterComponent = void 0;
      const memoize_one_1 = __importDefault(__webpack_require__(/*! memoize-one */ "../../node_modules/memoize-one/dist/memoize-one.esm.js"));
      const React = __importStar(__webpack_require__(/*! react */ "react"));
      const react_select_1 = __importDefault(__webpack_require__(/*! react-select */ "react-select"));
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const statics_1 = __webpack_require__(/*! ../statics */ "./src/statics.ts");
      class DependenciesFilterComponent extends React.Component {
        constructor() {
          super(...arguments);
          this.changeFilter = (filter) => {
            const { attributeId, onSetFilter } = this.props;
            onSetFilter(attributeId, filter ? [filter.value] : []);
          };
        }
        render() {
          const { t } = this.props;
          let { filter } = this.props;
          if (!Array.isArray(filter)) {
            filter = [filter];
          }
          const options = [
            { value: 'has-conflict', label: t('Conflict', { ns: statics_1.NAMESPACE }) },
            { value: 'has-unsolved', label: t('Unresolved', { ns: statics_1.NAMESPACE }) },
            { value: 'has-rule', label: t('LO Rule', { ns: statics_1.NAMESPACE }) },
            { value: 'depends', label: filter[2] },
          ];
          return (React.createElement(react_select_1.default, { className: 'select-compact', options: options, value: filter[0], onChange: this.changeFilter, searchable: false }));
        }
      }
      exports.DependenciesFilterComponent = DependenciesFilterComponent;
      class DependenciesFilter {
        constructor(localState, getMods, getConflicts) {
          this.component = DependenciesFilterComponent;
          this.raw = true;
          this.dataId = 'id';
          this.getDependencyRules = (0, memoize_one_1.default)(this.getDependencyRulesImpl);
          this.getLORules = (0, memoize_one_1.default)(this.getLORulesImpl);
          this.mLocalState = localState;
          this.mGetMods = getMods;
          this.mGetConflicts = getConflicts;
        }
        matches(filter, value) {
          if (!Array.isArray(filter)) {
            filter = [filter];
          }
          if (filter[0] === 'has-conflict') {
            const conflicts = this.mGetConflicts();
            if (conflicts === undefined) {
              return false;
            }
            return (conflicts[value] !== undefined) && (conflicts[value].length > 0);
          }
          else if (filter[0] === 'has-unsolved') {
            const conflicts = this.mGetConflicts();
            const mods = this.mGetMods();
            if ((mods === undefined)
                || (mods[value] === undefined)
                || (conflicts === undefined)) {
              return false;
            }
            const unsolvedConflict = (conflicts[value] || []).find(conflict => {
              if (conflict.otherMod === undefined) {
                return false;
              }
              const rule = this.findRule(mods[value], conflict.otherMod);
              return rule === undefined;
            });
            return unsolvedConflict !== undefined;
          }
          else if (filter[0] === 'has-rule') {
            return this.getLORules(value).length > 0;
          }
          else if (filter[0] === 'depends') {
            if (value === filter[1]) {
              return true;
            }
            const mods = this.mGetMods();
            const match = this.getDependencyRules(filter[1]).find(rule => vortex_api_1.util.testModReference(mods[value], rule.reference));
            return match !== undefined;
          }
          else {
            return true;
          }
        }
        findRule(source, ref) {
          return this.mLocalState.modRules.find(rule => vortex_api_1.util.testModReference(source, rule.source)
            && vortex_api_1.util.testModReference(ref, rule.reference));
        }
        getDependencyRulesImpl(modId) {
          let _a;
          const mod = this.mGetMods()[modId];
          return ((_a = mod === null || mod === void 0 ? void 0 : mod.rules) !== null && _a !== void 0 ? _a : []).filter(rule => ['requires', 'recommends'].includes(rule.type));
        }
        getLORulesImpl(modId) {
          let _a;
          const mod = this.mGetMods()[modId];
          return ((_a = mod === null || mod === void 0 ? void 0 : mod.rules) !== null && _a !== void 0 ? _a : []).filter(rule => ['after', 'before'].includes(rule.type));
        }
      }
      exports["default"] = DependenciesFilter;


/***/ }),

/***/ "./src/util/blacklist.ts":
/*!*******************************!*\
  !*** ./src/util/blacklist.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const minimatch = __webpack_require__(/*! minimatch */ "minimatch");
      const path = __importStar(__webpack_require__(/*! path */ "path"));
      const blacklist = [
        path.join('**', 'fomod', '*'),
        path.join('**', 'readme*'),
        path.join('**', '.git', '**'),
        path.join('**', '.hgignore'),
        path.join('**', '.gitignore'),
        path.join('**', '.gitattributes'),
        path.join('**', '_macosx', '**', '*'),
        path.join('**', 'meta.ini'),
        path.join('**', 'mod.manifest'),
      ];
      const getBlacklist = (() => {
        let lastGameId;
        let lastBlacklist;
        return (game) => {
          let _a, _b;
          if (game.id !== lastGameId) {
            lastGameId = game.id;
            const customBlacklist = ((((_a = game.details) === null || _a === void 0 ? void 0 : _a.ignoreConflicts) !== undefined)
                && Array.isArray(game.details.ignoreConflicts));
            const filterList = (item) => typeof item === 'string';
            lastBlacklist = customBlacklist
              ? [].concat(blacklist, (((_b = game === null || game === void 0 ? void 0 : game.details) === null || _b === void 0 ? void 0 : _b.ignoreConflicts) || [])
                .filter(filterList))
              : blacklist;
          }
          return lastBlacklist;
        };
      })();
      function isBlacklisted(filePath, game) {
        return getBlacklist(game).some(pattern => minimatch(filePath, pattern, { nocase: true }));
      }
      exports["default"] = isBlacklisted;


/***/ }),

/***/ "./src/util/conflicts.ts":
/*!*******************************!*\
  !*** ./src/util/conflicts.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const blacklist_1 = __importDefault(__webpack_require__(/*! ./blacklist */ "./src/util/blacklist.ts"));
      const path = __importStar(__webpack_require__(/*! path */ "path"));
      const turbowalk_1 = __importDefault(__webpack_require__(/*! turbowalk */ "turbowalk"));
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const ABSOLUTE_PATHS = true;
      function toLookupInfo(mod) {
        let _a;
        const attributes = mod.attributes || {};
        return {
          id: mod.id,
          fileMD5: attributes['fileMD5'],
          customFileName: attributes['customFileName'],
          fileName: attributes['fileName'],
          fileSizeBytes: attributes['fileSizeBytes'],
          logicalFileName: attributes['logicalFileName'],
          name: attributes['name'],
          referenceTag: attributes['referenceTag'],
          version: (_a = vortex_api_1.util.coerceToSemver(attributes['version'])) !== null && _a !== void 0 ? _a : attributes['version'],
        };
      }
      function makeGetRelPath(api, game) {
        const makeResolver = (basePath, mergeMods) => {
          if (typeof (mergeMods) === 'boolean') {
            if (ABSOLUTE_PATHS) {
              return mergeMods
                ? () => basePath
                : (mod) => path.join(basePath, mod.id);
            }
            else {
              return mergeMods
                ? () => ''
                : (mod) => mod.id;
            }
          }
          else {
            return ABSOLUTE_PATHS
              ? (mod) => path.join(basePath, mergeMods(mod))
              : mergeMods;
          }
        };
        const state = api.getState();
        const discovery = state.settings.gameMode.discovered[game.id];
        const modPaths = game.getModPaths(discovery.path);
        const modTypeResolver = Object.keys(modPaths).reduce((prev, modTypeId) => {
          let _a, _b;
          if (modTypeId === '') {
            prev[modTypeId] = makeResolver(modPaths[modTypeId], game.mergeMods);
          }
          else {
            const modType = vortex_api_1.util.getModType(modTypeId);
            prev[modTypeId] = makeResolver(modPaths[modTypeId], (_b = (_a = modType === null || modType === void 0 ? void 0 : modType.options) === null || _a === void 0 ? void 0 : _a.mergeMods) !== null && _b !== void 0 ? _b : game.mergeMods);
          }
          return prev;
        }, {});
        return (mod) => {
          let _a, _b;
          if (modTypeResolver[mod.type] === undefined) {
            const modType = vortex_api_1.util.getModType(mod.type);
            if (modType === undefined) {
              (0, vortex_api_1.log)('warn', 'mod has invalid mod type', mod.type);
              return modTypeResolver[''](mod);
            }
            modTypeResolver[mod.type] = makeResolver(modType.getPath(game), (_b = (_a = modType === null || modType === void 0 ? void 0 : modType.options) === null || _a === void 0 ? void 0 : _a.mergeMods) !== null && _b !== void 0 ? _b : game.mergeMods);
          }
          return modTypeResolver[mod.type](mod);
        };
      }
      function getAllFiles(api, game, stagingPath, mods, activator) {
        const files = {};
        const typeRelPath = makeGetRelPath(api, game);
        const consideredMods = mods
          .filter(mod => (mod.installationPath !== undefined) && mod.state === 'installed');
        return Promise.all(consideredMods.map((mod) => {
          const modPath = path.join(stagingPath, mod.installationPath);
          return (0, turbowalk_1.default)(modPath, entries => {
            entries.forEach(entry => {
              if (!entry.isDirectory) {
                try {
                  let relPath = path.relative(modPath, entry.filePath);
                  if (activator !== undefined) {
                    relPath = activator.getDeployedPath(relPath);
                  }
                  relPath = path.join(typeRelPath(mod), relPath);
                  const relPathL = relPath.toLowerCase();
                  if ((files[relPathL] !== undefined)
                            && (files[relPathL].find(iter => iter.mod === mod) !== undefined)) {
                    return;
                  }
                  vortex_api_1.util.setdefault(files, relPathL, []).push({ mod, relPath, time: entry.mtime });
                }
                catch (err) {
                  (0, vortex_api_1.log)('error', 'invalid file entry - what is this?', { entry, error: err.stack });
                }
              }
            });
          }, {})
            .catch(err => {
              if (!(['ENOENT', 'ENOTFOUND'].includes(err.code))) {
                return Promise.reject(err);
              }
              (0, vortex_api_1.log)('error', 'Mod directory not found', { modDirectory: mod.installationPath, error: err.message });
              return {};
            });
        }))
          .then(() => files);
      }
      function getConflictMap(files, game) {
        const conflictFiles = Object.keys(files)
          .filter(filePath => (files[filePath] !== undefined)
        && (files[filePath].length > 1)
        && !(0, blacklist_1.default)(filePath, game));
        const conflicts = {};
        conflictFiles.forEach(fileKey => {
          const file = files[fileKey];
          for (let i = 0; i < file.length; ++i) {
            for (let j = 0; j < file.length; ++j) {
              if (i !== j) {
                const suggestion = file[i].time < file[j].time
                  ? 'before'
                  : file[i].time > file[j].time
                    ? 'after'
                    : undefined;
                const entry = vortex_api_1.util.setdefault(vortex_api_1.util.setdefault(conflicts, file[i].mod.id, {}), file[j].mod.id, { files: [], suggestion: undefined });
                entry.files.push(file[0].relPath);
                if (suggestion !== undefined) {
                  if (entry.suggestion === undefined) {
                    entry.suggestion = suggestion;
                  }
                  else if ((entry.suggestion !== null) && (entry.suggestion !== suggestion)) {
                    entry.suggestion = null;
                  }
                }
              }
            }
          }
        });
        return conflicts;
      }
      function findConflicts(api, game, stagingPath, mods, activator) {
        return getAllFiles(api, game, stagingPath, mods, activator)
          .then((files) => {
            const conflictMap = getConflictMap(files, game);
            const conflictsByMod = {};
            Object.keys(conflictMap).forEach(lhsId => {
              Object.keys(conflictMap[lhsId]).forEach(rhsId => {
                if (conflictsByMod[lhsId] === undefined) {
                  conflictsByMod[lhsId] = [];
                }
                const mod = mods.find(iter => iter.id === rhsId);
                if (mod !== undefined) {
                  const entry = conflictMap[lhsId][rhsId];
                  conflictsByMod[lhsId].push({
                    otherMod: toLookupInfo(mod),
                    files: entry.files,
                    suggestion: entry.suggestion || null,
                  });
                }
              });
            });
            return conflictsByMod;
          });
      }
      exports["default"] = findConflicts;


/***/ }),

/***/ "./src/util/disableModTypeConflicts.ts":
/*!*********************************************!*\
  !*** ./src/util/disableModTypeConflicts.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.disableModTypeConflictsDialog = void 0;
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const actions_1 = __webpack_require__(/*! ../actions */ "./src/actions.ts");
      const getNonDefaultModTypes = (mod) => {
        return (mod === null || mod === void 0 ? void 0 : mod.type) !== '';
      };
      const allRules = (graph) => {
        return graph.reduce((accum, val) => {
          if (val.rules !== undefined && val.rules.length > 0) {
            accum[val.id] = val.rules;
          }
          return accum;
        }, {});
      };
      const findModsByRules = (mod, modsMap) => {
        let _a;
        const mods = ((_a = mod.rules) !== null && _a !== void 0 ? _a : []).reduce((accum, iter) => {
          const modByRef = modsMap[iter.reference.id];
          if (modByRef !== undefined && vortex_api_1.util.testModReference(modByRef, iter.reference)) {
            accum.push(iter);
          }
          return accum;
        }, []);
        return mods;
      };
      function findAffectedMods(api, gameId) {
        return __awaiter(this, void 0, void 0, function* () {
          const state = api.getState();
          const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', gameId], {});
          const graph = Object.values(mods).map(m => m);
          const graphRules = allRules(graph);
          const nonDefaultMods = graph.filter(getNonDefaultModTypes);
          const affectedMods = nonDefaultMods.reduce((accum, mod) => {
            let _a, _b, _c;
            for (const [sourceId, rules] of Object.entries(graphRules)) {
              const matchingRules = rules.filter(rule => mods[sourceId].type !== mod.type && vortex_api_1.util.testModReference(mod, rule.reference));
              if (matchingRules.length > 0) {
                if (((_a = mod.fileOverrides) !== null && _a !== void 0 ? _a : []).length > 0) {
                  accum[mod.id] = vortex_api_1.util.renderModName(mod);
                }
                if (sourceId !== mod.id && ((_c = (_b = mods[sourceId]) === null || _b === void 0 ? void 0 : _b.fileOverrides) !== null && _c !== void 0 ? _c : []).length > 0) {
                  accum[sourceId] = vortex_api_1.util.renderModName(mod);
                }
              }
            }
            return accum;
          }, {});
          return affectedMods;
        });
      }
      function disableModTypeConflictsDialog(api) {
        let _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const t = api.translate;
          const gameId = vortex_api_1.selectors.activeGameId(api.getState());
          const relevant = yield findAffectedMods(api, gameId);
          const checkboxes = Object.keys(relevant).length > 0
            ? [{ id: 'remove_file_overrides', text: t('Remove file overrides'), value: true }]
            : undefined;
          const message = Object.keys(relevant).length > 0
            ? t('You have {{total}} mod(s) with file overrides that are involved in a modtype conflict:\n', { replace: { total: Object.keys(relevant).length } }) + Object.values(relevant).join('\n')
            : undefined;
          const res = yield ((_a = api === null || api === void 0 ? void 0 : api.showDialog) === null || _a === void 0 ? void 0 : _a.call(api, 'question', 'Disabling Cross-ModType Conflicts', {
            bbcode: t('You are about to disable cross-modtype conflicts - this is not recommended as conflicts across mod types '
                + 'do not adhere to regular deployment rules and are guaranteed to break your modding environment when present.[br][/br][br][/br]'
                + 'If you proceed, and you have such conflicts, the external changes dialog will be raised '
                + 'after each deployment/purge event until you manually remove the conflicting files or disable '
                + 'the mods that are causing the conflict.[br][/br][br][/br]'
                + 'By default, Vortex will now clear any file overrides that were created to resolve cross-modtype conflicts. Please be aware '
                + 'that ALL file overrides will be removed from the mods mentioned below. '
                + 'Uncheck the box if you would rather keep these file overrides and manage them manually.'),
            message,
            checkboxes,
            options: { order: ['bbcode', 'checkboxes', 'message'] },
          }, [
            { label: 'Cancel' },
            { label: 'Proceed' },
          ], 'dependency-manager-disable-modtype-conflicts-dialog'));
          if (res === undefined || (res === null || res === void 0 ? void 0 : res.action) === 'Cancel') {
            throw new vortex_api_1.util.UserCanceled();
          }
          let batchedActions = [(0, actions_1.setModTypeConflictsSetting)(false)];
          const removeOverrides = (_b = res.input) === null || _b === void 0 ? void 0 : _b.remove_file_overrides;
          if (removeOverrides) {
            const overrideActions = Object.keys(relevant).map(id => vortex_api_1.actions.setFileOverride(gameId, id, []));
            batchedActions = batchedActions.concat(overrideActions);
          }
          vortex_api_1.util.batchDispatch(api.store, batchedActions);
        });
      }
      exports.disableModTypeConflictsDialog = disableModTypeConflictsDialog;


/***/ }),

/***/ "./src/util/findRule.ts":
/*!******************************!*\
  !*** ./src/util/findRule.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function findRule(modRules, source, ref) {
        return modRules.find(rule => ((source === undefined) || vortex_api_1.util.testModReference(source, rule.source))
        && vortex_api_1.util.testModReference(ref, rule.reference));
      }
      exports["default"] = findRule;


/***/ }),

/***/ "./src/util/genGraphStyle.ts":
/*!***********************************!*\
  !*** ./src/util/genGraphStyle.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      function transformRules(rules) {
        return rules
          .filter(rule => (rule.selectorText !== undefined) && rule.selectorText.startsWith('#variable'))
          .reduce((prev, rule) => {
            const [id, type, key] = rule.selectorText.split(' ');
            prev[key.slice(1)] = rule.style[type.slice(1)];
            return prev;
          }, {});
      }
      function default_1(rules) {
        const variables = transformRules(rules);
        return [
          {
            selector: 'node',
            style: {
              'background-color': variables['brand-bg'],
              label: 'data(title)',
              color: variables['text-color'],
              'text-background-color': variables['brand-bg'],
              'text-border-opacity': 1,
              'text-border-width': 1,
              'text-border-color': variables['border-color'],
              'text-border-style': 'solid',
              'text-background-opacity': 1,
              'text-background-padding': '4px',
              'text-margin-y': '-20px',
              'font-family': 'Roboto',
              'overlay-color': variables['link-hover-color'],
            },
          },
          {
            selector: 'edge',
            style: {
              width: 2,
              'curve-style': 'bezier',
              'mid-target-arrow-shape': 'triangle',
              'arrow-scale': 1.25,
              'target-endpoint': 'inside-to-node',
              'text-rotation': 'autorotate',
            },
          },
          {
            selector: 'edge.cycle-hidden',
            style: {
              'line-color': variables['text-color-disabled'],
              'mid-target-arrow-color': variables['text-color-disabled'],
            }
          },
          {
            selector: 'edge.cycle-highlight',
            style: {
              'line-color': variables['link-color'],
              'mid-target-arrow-color': variables['link-color'],
            }
          }
        ];
      }
      exports["default"] = default_1;


/***/ }),

/***/ "./src/util/renderModLookup.ts":
/*!*************************************!*\
  !*** ./src/util/renderModLookup.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      function renderModLookup(mod) {
        if (mod === undefined) {
          return undefined;
        }
        const id = mod.customFileName || mod.logicalFileName || mod.name;
        const version = mod.version;
        return version !== undefined ? id + ' v' + version : id;
      }
      exports["default"] = renderModLookup;


/***/ }),

/***/ "./src/util/ruleFulfilled.ts":
/*!***********************************!*\
  !*** ./src/util/ruleFulfilled.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

      "use strict";

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function findReference(reference, mods, source) {
        if (reference['idHint'] !== undefined) {
          const refMod = mods.find(mod => mod.id === reference['idHint']);
          if (vortex_api_1.util.testModReference(refMod, reference)) {
            return refMod;
          }
        }
        if (reference['md5Hint'] !== undefined) {
          const refMod = mods.find(mod => mod.fileMD5 === reference['md5Hint']);
          if (refMod !== undefined) {
            return refMod;
          }
        }
        return mods.find(mod => vortex_api_1.util.testModReference(mod, reference, source));
      }
      function ruleFulfilled(enabledMods, rule, source) {
        if (rule['ignored'] === true) {
          return true;
        }
        if (rule.type === 'conflicts') {
          enabledMods = enabledMods.filter(mod => mod.id !== source.modId);
          if (findReference(rule.reference, enabledMods, source) !== undefined) {
            return false;
          }
          else {
            return true;
          }
        }
        else if (['requires', 'recommends'].includes(rule.type)) {
          if (findReference(rule.reference, enabledMods, source) === undefined) {
            return (rule.type === 'requires') ? false : null;
          }
          else {
            return true;
          }
        }
        else {
          return null;
        }
      }
      exports["default"] = ruleFulfilled;


/***/ }),

/***/ "./src/util/showUnsolvedConflicts.ts":
/*!*******************************************!*\
  !*** ./src/util/showUnsolvedConflicts.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const actions_1 = __webpack_require__(/*! ../actions */ "./src/actions.ts");
      const findRule_1 = __importDefault(__webpack_require__(/*! ./findRule */ "./src/util/findRule.ts"));
      function showUnsolvedConflictsDialog(api, modRules, showAll, gameId) {
        let _a;
        const state = api.store.getState();
        if (gameId === undefined) {
          gameId = vortex_api_1.selectors.activeGameId(state);
        }
        const mods = (_a = state.persistent.mods[gameId]) !== null && _a !== void 0 ? _a : {};
        const conflicts = vortex_api_1.util.getSafe(state.session, ['dependencies', 'conflicts'], undefined);
        if (conflicts === undefined) {
          api.sendNotification({
            type: 'info',
            id: 'conflicts-not-calculated',
            message: 'Conflicts haven\'t been calculated yet, please wait a moment',
            displayMS: 5000,
          });
          return;
        }
        let modsToShow = Object.keys(conflicts);
        if (!showAll) {
          modsToShow = modsToShow.filter(modId => conflicts[modId].find(conflict => {
            if (conflict.otherMod === undefined) {
              return false;
            }
            const rule = (0, findRule_1.default)(modRules, mods[modId], conflict.otherMod);
            return rule === undefined;
          }) !== undefined);
        }
        if (modsToShow.length > 0 || showAll) {
          api.store.dispatch((0, actions_1.setConflictDialog)(gameId, modsToShow, modRules));
        }
      }
      exports["default"] = showUnsolvedConflictsDialog;


/***/ }),

/***/ "./src/util/topologicalSort.ts":
/*!*************************************!*\
  !*** ./src/util/topologicalSort.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.topologicalSort = void 0;
      const memoize_one_1 = __importDefault(__webpack_require__(/*! memoize-one */ "../../node_modules/memoize-one/dist/memoize-one.esm.js"));
      exports.topologicalSort = (0, memoize_one_1.default)((graph) => {
        const visited = new Set();
        const result = [];
        const visit = (modId, ruleType) => {
          let _a, _b;
          if (visited.has(modId)) {
            return;
          }
          visited.add(modId);
          const mod = graph.find(iter => iter.id === modId);
          const rules = (_b = (_a = mod.rules) === null || _a === void 0 ? void 0 : _a.filter(rule => ['before', 'after'].includes(rule.type)
            && graph.find(mod => mod.id === rule.reference.id))) !== null && _b !== void 0 ? _b : [];
          rules.forEach((rule) => {
            if (rule.type === 'after') {
              visit(rule.reference.id, rule.type);
            }
          });
          result.push(modId);
        };
        graph.forEach((mod) => {
          visit(mod.id);
        });
        return result.reverse();
      });


/***/ }),

/***/ "./src/views/ConflictEditor.tsx":
/*!**************************************!*\
  !*** ./src/views/ConflictEditor.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const actions_1 = __webpack_require__(/*! ../actions */ "./src/actions.ts");
      const ConflictEditorTips_1 = __importDefault(__webpack_require__(/*! ./ConflictEditorTips */ "./src/views/ConflictEditorTips.tsx"));
      const statics_1 = __webpack_require__(/*! ../statics */ "./src/statics.ts");
      const memoize_one_1 = __importDefault(__webpack_require__(/*! memoize-one */ "../../node_modules/memoize-one/dist/memoize-one.esm.js"));
      const React = __importStar(__webpack_require__(/*! react */ "react"));
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const redux_act_1 = __webpack_require__(/*! redux-act */ "redux-act");
      const semver = __importStar(__webpack_require__(/*! semver */ "semver"));
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function importVersion(match) {
        if ((match === undefined) || (match === '*')) {
          return 'any';
        }
        else if (match[0] === '^') {
          return 'compatible';
        }
        else {
          return 'exact';
        }
      }
      function getRuleSpec(modId, mods, conflicts) {
        const res = {};
        const modRules = (mods[modId] !== undefined)
          ? (mods[modId].rules || [])
          : [];
        (conflicts || []).forEach(conflict => {
          const existingRule = modRules
            .find(rule => (['before', 'after', 'conflicts'].indexOf(rule.type) !== -1)
            && vortex_api_1.util.testModReference(conflict.otherMod, rule.reference));
          res[conflict.otherMod.id] = existingRule !== undefined
            ? {
              type: existingRule.type,
              version: importVersion(existingRule.reference.versionMatch),
            } : { type: undefined, version: 'any' };
        });
        return res;
      }
      function nop() {
      }
      function VisibilityProxyWrap(props) {
        const { container, entry } = props;
        const [visible, setVisibleImpl] = React.useState(false);
        const ref = React.useRef(null);
        const [height, setHeight] = React.useState(undefined);
        const setVisible = React.useCallback((newValue) => {
          if (!newValue && ref.current !== null) {
            setHeight(ref.current.clientHeight);
          }
          setVisibleImpl(newValue);
        }, [setVisibleImpl, setHeight, ref.current]);
        const content = React.useCallback(() => props.content(entry.id, entry.name, ref), [props.content, entry]);
        const placeholder = React.useCallback(() => (React.createElement("div", { id: `placeholder-${entry.id}`, style: { height: height !== null && height !== void 0 ? height : `${3 * entry.numConflicts}em` } })), [height]);
        return (React.createElement(vortex_api_1.VisibilityProxy, { container: container, content: content, placeholder: placeholder, visible: visible, setVisible: setVisible }));
      }
      class ConflictEditor extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.getModEntriesMemo = (0, memoize_one_1.default)(this.getModEntries);
          this.getFilteredEntriesMemo = (0, memoize_one_1.default)(this.getFilteredEntries);
          this.mRef = React.createRef();
          this.refreshRules = (props) => {
            this.nextState.rules = (props.modIds || []).reduce((prev, modId) => {
              let _a;
              prev[modId] = getRuleSpec(modId, props.mods, (_a = props.conflicts) === null || _a === void 0 ? void 0 : _a[modId]);
              return prev;
            }, {});
          };
          this.clearRules = () => {
            const { t, modIds, conflicts } = this.props;
            this.context.api.showDialog('question', t('Confirm'), {
              text: t('This change will only be applied once you choose to "Save" the change in the main '
                    + 'dialogue window. Please be aware that once saved, this action cannot be undone and the '
                    + 'mod rules and file overrides will have to be set again.'),
            }, [
              { label: 'Cancel', default: true },
              {
                label: 'Clear Rules',
                action: () => {
                  let _a;
                  const batchedActions = [];
                  for (const modId of modIds || []) {
                    if (Array.isArray((_a = this.props.mods[modId]) === null || _a === void 0 ? void 0 : _a.fileOverrides)) {
                      batchedActions.push(vortex_api_1.actions.setFileOverride(this.props.gameId, modId, []));
                    }
                  }
                  if (batchedActions.length > 0) {
                    this.props.onBatchDispatch(batchedActions);
                  }
                  this.nextState.rules = (modIds || []).reduce((prev, modId) => {
                    const res = {};
                    (conflicts[modId] || []).forEach(conflict => {
                      res[conflict.otherMod.id] = { type: undefined, version: 'any' };
                    });
                    prev[modId] = res;
                    return prev;
                  }, {});
                },
              },
            ]);
          };
          this.toggleHideResolved = () => {
            this.nextState.hideResolved = !this.state.hideResolved;
          };
          this.useSuggested = () => {
            const { t, mods, modIds, conflicts } = this.props;
            this.context.api.showDialog('question', t('Confirm'), {
              bbcode: t('Vortex can set some of the rules automatically based on the last modified date. '
                    + 'Mods with newer files will be loaded after mods with older files, effectively overriding '
                    + 'older mods. While this is a quick way to resolve mod conflicts with generally decent results, '
                    + 'it is no guarantee for a working mod load order.[br][/br][br][/br]'
                    + 'Please note: Vortex will be unable to suggest rules for mods with files '
                    + 'that are both older than some and newer than others from a conflicting mod.[br][/br][br][/br]'
                    + 'Loading mods in the incorrect order can lead to in-game errors such as:[br][/br][br][/br]'
                    + '[list][*]Mods not having an effect on the game[*]Incorrect textures or models showing up '
                    + '[*]The game crashing[/list][br][/br]If you find that your mods don\'t work correctly '
                    + 'you can always come here and change their order.'),
            }, [
              { label: 'Cancel', default: true },
              {
                label: 'Use Suggested',
                action: () => {
                  this.nextState.rules = (modIds || []).reduce((prev, modId) => {
                    const modRules = (mods[modId] !== undefined)
                      ? (mods[modId].rules || [])
                      : [];
                    const res = {};
                    (conflicts[modId] || []).forEach(conflict => {
                      let _a, _b;
                      const existingRule = modRules
                        .find(rule => (['before', 'after', 'conflicts'].indexOf(rule.type) !== -1)
                                    && vortex_api_1.util.testModReference(conflict.otherMod, rule.reference));
                      const reverseSuggestion = (conflict.suggestion !== null)
                        ? conflict.suggestion === 'after' ? 'before' : 'after'
                        : undefined;
                      if (((_b = (_a = prev[conflict.otherMod.id]) === null || _a === void 0 ? void 0 : _a[modId]) === null || _b === void 0 ? void 0 : _b.type) === reverseSuggestion) {
                        res[conflict.otherMod.id] = { type: undefined, version: 'any' };
                      }
                      else {
                        res[conflict.otherMod.id] = (conflict.suggestion !== null)
                          ? {
                            type: conflict.suggestion,
                            version: (existingRule !== undefined)
                              ? importVersion(existingRule.reference.versionMatch)
                              : 'any',
                          }
                          : (existingRule !== undefined)
                            ? {
                              type: existingRule.type,
                              version: importVersion(existingRule.reference.versionMatch),
                            }
                            : { type: undefined, version: 'any' };
                      }
                    });
                    prev[modId] = res;
                    return prev;
                  }, {});
                },
              },
            ]);
          };
          this.onFilterChange = (input) => {
            this.nextState.filterValue = input;
          };
          this.isUnresolved = (mods, modId, otherModId, rules, hideResolved) => {
            let _a, _b, _c;
            const isRuleSet = (((_a = rules[otherModId]) === null || _a === void 0 ? void 0 : _a[modId]) === undefined)
              ? ((_c = (_b = mods[otherModId]) === null || _b === void 0 ? void 0 : _b.rules) !== null && _c !== void 0 ? _c : [])
                .find(rule => (['before', 'after', 'conflicts'].includes(rule.type))
                    && vortex_api_1.util.testModReference(mods[modId], rule.reference)) !== undefined
              : rules[otherModId][modId].type !== undefined;
            return (hideResolved)
              ? (rules[modId][otherModId] === undefined)
                ? !isRuleSet
                : (rules[modId][otherModId].type === undefined) && !isRuleSet
              : true;
          };
          this.applyFilter = (conflict, mods, modId, filterValue, rules, hideResolved) => {
            if (!filterValue && !hideResolved) {
              return true;
            }
            if (mods[conflict.otherMod.id] === undefined) {
              return false;
            }
            const isMatch = (val) => val.toLowerCase().includes(filterValue.toLowerCase());
            const modName = vortex_api_1.util.renderModName(mods[modId]);
            const otherModName = vortex_api_1.util.renderModName(mods[conflict.otherMod.id]);
            const testFilterMatch = () => (filterValue)
              ? (isMatch(modName) || isMatch(otherModName))
              : true;
            return testFilterMatch()
                && this.isUnresolved(mods, modId, conflict.otherMod.id, rules, hideResolved);
          };
          this.renderConflicts = () => {
            const { t, conflicts, mods, modIds } = this.props;
            const { filterValue, rules, hideResolved } = this.state;
            const modEntries = this.getModEntriesMemo(mods, conflicts, modIds);
            const filteredEntries = this.getFilteredEntriesMemo(modEntries, mods, conflicts, filterValue, rules, hideResolved);
            const filteredConflictsCount = Object.values(filteredEntries).reduce((prev, entry) => prev += entry.length, 0);
            const renderPlaceholder = () => ((modEntries.length > 0) && (filteredConflictsCount === 0))
              ? (React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'conflict', text: t('Filters are applied'), subtext: t('Please remove applied filters to view all conflicts') }))
              : null;
            const renderModEntry = (modId, name, ref) => {
              const filtered = filteredEntries[modId];
              return (filtered.length > 0) ? (React.createElement("div", { id: `content-${modId}`, key: `mod-conflict-element-${modId}`, ref: ref },
                                                                  React.createElement("div", { className: 'mod-conflict-group-header' },
                                                                                      React.createElement("label", null, vortex_api_1.util.renderModName(mods[modId])),
                                                                                      React.createElement("a", { "data-modid": modId, "data-action": 'before_all', onClick: this.applyGroupRule }, t('Before All')),
                                                                                      React.createElement("span", { className: 'link-action-seperator' }, "\u00A0 | \u00A0"),
                                                                                      React.createElement("a", { "data-modid": modId, "data-action": 'after_all', onClick: this.applyGroupRule }, t('After All'))),
                                                                  React.createElement(react_bootstrap_1.Table, { className: 'mod-conflict-list' },
                                                                                      React.createElement("tbody", null, filtered.map((conf) => this.renderConflict(modId, name, conf)))))) : null;
            };
            return (modEntries.length > 0)
              ? (React.createElement("div", { ref: this.mRef },
                                     modEntries.map(entry => (React.createElement(VisibilityProxyWrap, { key: entry.id, container: this.mRef.current, entry: entry, content: renderModEntry }))),
                                     renderPlaceholder()))
              : null;
          };
          this.confirmGroupRule = (modId, refIds, apply) => {
            const { t } = this.props;
            this.context.api.showDialog('question', t('Confirm'), {
              bbcode: t('You are about to apply a group rule (before/after all), to the following '
                    + 'mods: [br][/br][br][/br]{{mods}}[br][/br][br][/br]', { replace: { mods: [modId].concat(refIds).join('[br][/br]') } }),
            }, [
              { label: 'Cancel', default: true },
              {
                label: 'Apply Rule',
                action: () => apply(),
              },
            ]);
          };
          this.applyGroupRule = (evt) => {
            evt.preventDefault();
            const { conflicts, mods } = this.props;
            const { rules, hideResolved, filterValue } = this.state;
            const action = evt.currentTarget.getAttribute('data-action');
            const modId = evt.currentTarget.getAttribute('data-modid');
            if (['after_all', 'before_all'].indexOf(action) === -1 || conflicts === undefined) {
              return;
            }
            let newRules = Object.assign({}, rules);
            const hasAppliedFilters = hideResolved || !!filterValue;
            const refIds = (hasAppliedFilters)
              ? Object.keys(rules[modId]).filter(refId => {
                if (mods[refId] === undefined) {
                  return false;
                }
                const modName = vortex_api_1.util.renderModName(mods[refId]);
                let matchesFilter = false;
                if (modName !== undefined) {
                  const refModName = modName.toLowerCase();
                  matchesFilter = refModName.includes(filterValue.toLowerCase());
                }
                return (!!filterValue && matchesFilter)
                        || (hideResolved && this.isUnresolved(mods, modId, refId, rules, hideResolved));
              })
              : Object.keys(rules[modId]);
            const unassignedRefIds = refIds.filter(refId => {
              let _a, _b, _c, _d;
              const currentModRule = (_b = (_a = rules[modId]) === null || _a === void 0 ? void 0 : _a[refId]) === null || _b === void 0 ? void 0 : _b.type;
              const currentRefRule = (_d = (_c = rules[refId]) === null || _c === void 0 ? void 0 : _c[modId]) === null || _d === void 0 ? void 0 : _d.type;
              const hasRule = (rule) => rule !== undefined;
              return (!hasRule(currentModRule) && !hasRule(currentRefRule));
            });
            const removeRefRule = (refId) => {
              let _a;
              return (((_a = rules[refId]) === null || _a === void 0 ? void 0 : _a[modId]) === undefined)
                ? newRules = Object.assign(Object.assign({}, newRules), { [refId]: {
                  [modId]: {
                    version: 'any',
                    type: undefined,
                  },
                } })
                : newRules[refId][modId] = {
                  version: 'any',
                  type: undefined,
                };
            };
            const applyRule = () => {
              const refrencedModIds = (unassignedRefIds.length > 0)
                ? unassignedRefIds : refIds;
              refrencedModIds.forEach(refId => {
                let _a, _b, _c;
                const refRules = getRuleSpec(refId, mods, conflicts[refId]);
                if ((((_a = refRules === null || refRules === void 0 ? void 0 : refRules[modId]) === null || _a === void 0 ? void 0 : _a.type) !== undefined)
                        || (((_c = (_b = rules[refId]) === null || _b === void 0 ? void 0 : _b[modId]) === null || _c === void 0 ? void 0 : _c.type) !== undefined)) {
                  removeRefRule(refId);
                }
                newRules[modId][refId] = Object.assign(Object.assign({}, newRules[modId][refId]), { type: (action === 'before_all') ? 'before' : 'after' });
              });
              this.nextState.rules = newRules;
            };
            if (unassignedRefIds.length > 0) {
              applyRule();
            }
            else {
              this.confirmGroupRule(modId, refIds, applyRule);
            }
          };
          this.renderConflict = (modId, name, conflict) => {
            let _a, _b, _c, _d, _e;
            const { t, modRules, mods, pathTool, discovery } = this.props;
            const { rules } = this.state;
            if (((discovery === null || discovery === void 0 ? void 0 : discovery.path) === undefined)
                || (mods[modId] === undefined)
                || (rules[modId] === undefined)
                || (mods[conflict.otherMod.id] === undefined)) {
              return null;
            }
            const toRelPath = (lhs, rhs) => pathTool.relative(lhs, rhs);
            const popover = (React.createElement(react_bootstrap_1.Popover, { className: 'conflict-popover', id: `conflict-popover-${conflict.otherMod.id}` },
                                                 conflict.files.slice(0).sort().map(fileName => React.createElement("p", { key: fileName }, toRelPath(discovery.path, fileName))),
                                                 React.createElement(react_bootstrap_1.Button, { "data-modid": modId, onClick: this.openOverrideDialog }, t('Edit individual files'))));
            const rule = (_a = rules[modId][conflict.otherMod.id]) !== null && _a !== void 0 ? _a : { type: undefined, version: 'any' };
            let reverseRule;
            if (rule.type === undefined) {
              const refId = conflict.otherMod.id;
              if (rules[refId] !== undefined) {
                const reverseMod = (((_b = rules[refId]) === null || _b === void 0 ? void 0 : _b[modId]) !== undefined)
                        && (['before', 'after'].indexOf((_d = (_c = rules[refId]) === null || _c === void 0 ? void 0 : _c[modId]) === null || _d === void 0 ? void 0 : _d.type) !== -1);
                if (reverseMod) {
                  reverseRule = {
                    source: { id: modId },
                    reference: { id: refId },
                    original: false,
                    type: rules[refId][modId].type === 'before' ? 'after' : 'before',
                  };
                }
              }
              else {
                reverseRule = modRules
                  .find(iter => !iter.original
                        && vortex_api_1.util.testModReference(conflict.otherMod, iter.reference)
                        && vortex_api_1.util.testModReference(mods[modId], iter.source));
              }
            }
            return (React.createElement("tr", { key: JSON.stringify(conflict) },
                                        React.createElement("td", { style: { width: '8em' } }, t('Load')),
                                        React.createElement("td", { className: 'conflict-rule-owner' },
                                                            React.createElement("div", null, name)),
                                        React.createElement("td", null,
                                                            React.createElement(react_bootstrap_1.FormControl, { className: 'conflict-rule-select', componentClass: 'select', value: (rule === null || rule === void 0 ? void 0 : rule.type) || (reverseRule === null || reverseRule === void 0 ? void 0 : reverseRule.type) || 'norule', onChange: this.setRuleType, "data-modid": modId, "data-refid": conflict.otherMod.id, disabled: (reverseRule !== undefined) },
                                                                                React.createElement("option", { value: 'norule' }, "???"),
                                                                                React.createElement("option", { value: 'before' }, conflict.suggestion === 'before' ? t('before (suggested)') : t('before')),
                                                                                React.createElement("option", { value: 'after' }, conflict.suggestion === 'after' ? t('after (suggested)') : t('after')),
                                                                                React.createElement("option", { value: 'conflicts' }, t('never together with')))),
                                        React.createElement("td", { className: 'conflict-rule-description' },
                                                            React.createElement("div", { className: 'conflict-rule-reference' },
                                                                                React.createElement("div", { className: 'conflict-rule-name' },
                                                                                                    React.createElement("div", null, vortex_api_1.util.renderModName(mods[conflict.otherMod.id], { version: true })),
                                                                                                    React.createElement(react_bootstrap_1.OverlayTrigger, { trigger: 'click', rootClose: true, placement: 'right', overlay: popover },
                                                                                                                        React.createElement("a", null, t('{{ count }} conflicting file', {
                                                                                                                          count: conflict.files.length,
                                                                                                                          ns: 'dependency-manager',
                                                                                                                        })))))),
                                        React.createElement("td", null,
                                                            React.createElement(react_bootstrap_1.FormControl, { componentClass: 'select', value: (_e = rule === null || rule === void 0 ? void 0 : rule.version) !== null && _e !== void 0 ? _e : 'any', onChange: this.setRuleVersion, "data-modid": modId, "data-refid": conflict.otherMod.id, className: 'conflict-rule-version', disabled: (reverseRule !== undefined) },
                                                                                React.createElement("option", { value: 'any' }, t('Any version')),
                                                                                (conflict.otherMod.version && semver.valid(conflict.otherMod.version))
                                                                                  ? React.createElement("option", { value: 'compatible' }, t('Compatible version'))
                                                                                  : null,
                                                                                conflict.otherMod.version
                                                                                  ? React.createElement("option", { value: 'exact' }, t('Only this version'))
                                                                                  : null)),
                                        React.createElement("td", { style: { width: '5em' } }, this.renderReverseRule(modId, reverseRule))));
          };
          this.unlock = (evt) => {
            const { t, gameId, mods, onRemoveRule } = this.props;
            const modId = evt.currentTarget.getAttribute('data-modid');
            const rule = JSON.parse(evt.currentTarget.getAttribute('data-rule'));
            const reverseType = rule.type === 'before' ? 'after' : 'before';
            const findRule = iter => (iter.type === reverseType)
                && vortex_api_1.util.testModReference(mods[modId], iter.reference);
            const refMod = Object.keys(mods).map(iter => mods[iter])
              .find(iter => vortex_api_1.util.testModReference(iter, rule.reference)
                && iter.rules !== undefined
                && (iter.rules.find(findRule) !== undefined));
            if (refMod === undefined) {
              return;
            }
            const originalRule = refMod.rules.find(findRule);
            this.context.api.showDialog('question', t('Confirm'), {
              text: t('This will remove the existing rule so you can set a new one on this mod.'),
            }, [
              { label: 'Cancel' },
              { label: 'Remove Rule', default: true, action: () => {
                onRemoveRule(gameId, refMod.id, {
                  type: originalRule.type,
                  reference: originalRule.reference,
                });
              } },
            ]);
          };
          this.close = () => {
            const { onClose } = this.props;
            this.nextState.filterValue = '';
            this.nextState.hideResolved = false;
            onClose();
          };
          this.setRuleType = (evt) => {
            const modId = evt.currentTarget.getAttribute('data-modid');
            const refId = evt.currentTarget.getAttribute('data-refid');
            if (this.nextState.rules[modId][refId] !== undefined) {
              this.nextState.rules[modId][refId].type = (evt.currentTarget.value === 'norule')
                ? undefined
                : evt.currentTarget.value;
            }
          };
          this.setRuleVersion = (evt) => {
            const modId = evt.currentTarget.getAttribute('data-modid');
            const refId = evt.currentTarget.getAttribute('data-refid');
            if (this.nextState.rules[modId][refId] !== undefined) {
              this.nextState.rules[modId][refId].version = evt.currentTarget.value;
            }
          };
          this.openOverrideDialog = (evt) => {
            const { gameId, onOverrideDialog } = this.props;
            const modId = evt.currentTarget.getAttribute('data-modid');
            onOverrideDialog(gameId, modId);
            document.body.click();
          };
          this.save = () => {
            const { gameId, mods, onBatchDispatch } = this.props;
            const { rules } = this.state;
            const actions = [];
            Object.keys(rules).forEach(modId => {
              if (mods[modId] === undefined) {
                return;
              }
              Object.keys(rules[modId]).forEach(otherId => {
                if (mods[otherId] === undefined) {
                  return;
                }
                const origRule = (mods[modId].rules || [])
                  .find(rule => (['before', 'after', 'conflicts'].indexOf(rule.type) !== -1)
                        && vortex_api_1.util.testModReference(mods[otherId], rule.reference));
                if (origRule !== undefined) {
                  actions.push(vortex_api_1.actions.removeModRule(gameId, modId, origRule));
                }
                if (rules[modId][otherId].type !== undefined) {
                  actions.push(vortex_api_1.actions.addModRule(gameId, modId, {
                    reference: {
                      id: otherId,
                      versionMatch: this.translateModVersion(mods[otherId], rules[modId][otherId].version),
                    },
                    type: rules[modId][otherId].type,
                  }));
                }
              });
            });
            onBatchDispatch(actions);
            this.close();
          };
          this.initState({
            rules: {},
            filterValue: '',
            hideResolved: false,
          });
        }
        componentDidMount() {
          this.refreshRules(this.props);
        }
        UNSAFE_componentWillReceiveProps(nextProps) {
          if ((this.props.conflicts !== nextProps.conflicts)
            || (this.props.gameId !== nextProps.gameId)
            || (this.props.modIds !== nextProps.modIds)
            || (this.props.modRules !== nextProps.modRules)) {
            this.refreshRules(nextProps);
          }
        }
        render() {
          const { t, modIds, mods, conflicts } = this.props;
          const { filterValue, hideResolved } = this.state;
          let modName = '';
          if (modIds !== undefined) {
            if (modIds.length === 1) {
              modName = vortex_api_1.util.renderModName(mods[modIds[0]]);
            }
            else if (modIds.length > 1) {
              modName = t('Multiple');
            }
          }
          const filterInput = ((conflicts !== undefined) && ((modIds === null || modIds === void 0 ? void 0 : modIds.length) > 0))
            ? (React.createElement(vortex_api_1.FormInput, { className: 'conflict-filter-input', value: filterValue, placeholder: t('Search for a rule...'), onChange: this.onFilterChange, debounceTimer: 100, clearable: true })) : null;
          const hasConflicts = !!(modIds === null || modIds === void 0 ? void 0 : modIds.length);
          const hasAppliedFilters = hideResolved || !!filterValue;
          const content = (conflicts === undefined)
            ? (React.createElement("div", { className: 'conflicts-loading' },
                                   React.createElement(vortex_api_1.Spinner, null),
                                   t('Conflicts haven\'t been calculated yet')))
            : (hasConflicts)
              ? (this.renderConflicts())
              : (React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'conflict', text: t('You have no file conflicts. Wow!') }));
          const renderButton = (clickFunc, text) => hasAppliedFilters
            ? (React.createElement(vortex_api_1.tooltip.Button, { disabled: true, onClick: clickFunc, tooltip: t('Unavailable when filters are applied') }, t(text))) : (React.createElement(react_bootstrap_1.Button, { disabled: !hasConflicts, onClick: clickFunc }, t(text)));
          const tips = React.createElement(ConflictEditorTips_1.default, null);
          return (React.createElement(react_bootstrap_1.Modal, { id: 'conflict-editor-dialog', show: modIds !== undefined, onHide: nop },
                                      React.createElement(react_bootstrap_1.Modal.Header, null,
                                                          React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                                                                              React.createElement(vortex_api_1.FlexLayout.Fixed, { style: { justifyContent: 'space-between', display: 'flex' } },
                                                                                                  React.createElement(react_bootstrap_1.Modal.Title, null, modName),
                                                                                                  React.createElement(vortex_api_1.tooltip.Icon, { id: 'dialog-info', name: 'dialog-info', tooltip: tips })))),
                                      React.createElement(react_bootstrap_1.Modal.Body, null,
                                                          filterInput,
                                                          content),
                                      React.createElement(react_bootstrap_1.Modal.Footer, null,
                                                          React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'conflict-editor-secondary-actions' },
                                                                              renderButton(this.clearRules, 'Clear Rules'),
                                                                              renderButton(this.useSuggested, 'Use Suggestions'),
                                                                              React.createElement(react_bootstrap_1.Button, { disabled: !hasConflicts, onClick: this.toggleHideResolved }, hideResolved ? t('Show Resolved') : t('Hide Resolved'))),
                                                          React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'conflict-editor-main-actions' },
                                                                              React.createElement(react_bootstrap_1.Button, { onClick: this.close }, t('Cancel')),
                                                                              React.createElement(react_bootstrap_1.Button, { onClick: this.save }, t('Save'))))));
        }
        getFilteredEntries(modEntries, mods, conflicts, filterValue, rules, hideResolved) {
          return modEntries.reduce((prev, entry) => {
            prev[entry.id] = (conflicts[entry.id] || [])
              .filter(conflict => this.applyFilter(conflict, mods, entry.id, filterValue, rules, hideResolved));
            return prev;
          }, {});
        }
        getModEntries(mods, conflicts, modIds) {
          return (modIds || [])
            .map(modId => {
              let _a;
              return ({
                id: modId,
                name: vortex_api_1.util.renderModName(mods[modId], { version: true }),
                numConflicts: ((_a = conflicts[modId]) !== null && _a !== void 0 ? _a : []).length,
              });
            })
            .filter(mod => mod.name !== undefined)
            .sort((lhs, rhs) => lhs.name.localeCompare(rhs.name));
        }
        renderReverseRule(modId, rule) {
          const { t, mods } = this.props;
          if (rule === undefined) {
            return null;
          }
          const tip = (React.createElement("div", null, t('{{ otherMod }} has a rule referencing {{ thisMod }}', { replace: {
            otherMod: vortex_api_1.util.renderModReference(rule.reference, mods[rule.reference.id]),
            thisMod: vortex_api_1.util.renderModReference(rule.source, mods[rule.source.id])
          } })));
          return (React.createElement(vortex_api_1.tooltip.IconButton, { id: `conflict-editor-${rule.reference.fileMD5}`, className: 'conflict-editor-reverserule pull-right', icon: 'locked', tooltip: tip, "data-modid": modId, "data-rule": JSON.stringify(rule), onClick: this.unlock }));
        }
        translateModVersion(mod, spe) {
          if ((spe === 'any') || (mod.attributes === undefined)) {
            return '*';
          }
          else if (spe === 'compatible') {
            return '^' + mod.attributes.version;
          }
          else {
            return mod.attributes.version;
          }
        }
      }
      const emptyObj = {};
      function mapStateToProps(state) {
        const dialog = state.session.dependencies.conflictDialog || emptyObj;
        const discovery = ((dialog === null || dialog === void 0 ? void 0 : dialog.gameId) !== undefined)
          ? vortex_api_1.selectors.discoveryByGame(state, dialog.gameId)
          : emptyObj;
        return {
          gameId: dialog.gameId,
          modIds: dialog.modIds,
          conflicts: vortex_api_1.util.getSafe(state, ['session', 'dependencies', 'conflicts'], undefined),
          mods: dialog.gameId !== undefined ? state.persistent.mods[dialog.gameId] : emptyObj,
          modRules: dialog.modRules,
          discovery,
        };
      }
      function mapDispatchToProps(dispatch) {
        return {
          onClose: () => dispatch((0, actions_1.setConflictDialog)(undefined, undefined, undefined)),
          onAddRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.addModRule(gameId, modId, rule)),
          onRemoveRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.removeModRule(gameId, modId, rule)),
          onOverrideDialog: (gameId, modId) => dispatch((0, actions_1.setFileOverrideDialog)(gameId, modId)),
          onBatchDispatch: (actions) => dispatch((0, redux_act_1.batch)(actions)),
        };
      }
      exports["default"] = (0, react_i18next_1.withTranslation)(['common', statics_1.NAMESPACE])((0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(ConflictEditor));


/***/ }),

/***/ "./src/views/ConflictEditorTips.tsx":
/*!******************************************!*\
  !*** ./src/views/ConflictEditorTips.tsx ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const react_1 = __importDefault(__webpack_require__(/*! react */ "react"));
      function ConflictEditorTips() {
        return (react_1.default.createElement("div", null,
                                              react_1.default.createElement("p", null, "Setting rules between conflicting mods will decide which mod's files \"win\" the conflict by loading after the other conflicting files."),
                                              react_1.default.createElement("p", null, "You can think of it like the \"winning\" mod overriding the other mod, only that you can always come back and flip the rule without having to reinstall your mods."),
                                              react_1.default.createElement("p", null, "When it comes to deciding which mod should go after the other, there are a few things to consider."),
                                              react_1.default.createElement("p", null, "It is strongly advised to:"),
                                              react_1.default.createElement("ul", null,
                                                                            react_1.default.createElement("li", null, "Load patches and options after their base mod"),
                                                                            react_1.default.createElement("li", null, "Load mods depending on others after their dependency")),
                                              react_1.default.createElement("p", null, "The following is generally advised, but may not always produce the desired results:"),
                                              react_1.default.createElement("ul", null,
                                                                            react_1.default.createElement("li", null, "Load newer mods after older ones. (\"Use Suggestions\" is based on this principle)"),
                                                                            react_1.default.createElement("li", null, "Load lesser known mods after very popular ones"),
                                                                            react_1.default.createElement("li", null, "Load the mods you care most about after the ones you can live without"))));
      }
      exports["default"] = ConflictEditorTips;


/***/ }),

/***/ "./src/views/ConflictGraph.tsx":
/*!*************************************!*\
  !*** ./src/views/ConflictGraph.tsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const genGraphStyle_1 = __importDefault(__webpack_require__(/*! ../util/genGraphStyle */ "./src/util/genGraphStyle.ts"));
      const actions_1 = __webpack_require__(/*! ../actions */ "./src/actions.ts");
      const statics_1 = __webpack_require__(/*! ../statics */ "./src/statics.ts");
      const GraphView_1 = __importDefault(__webpack_require__(/*! ./GraphView */ "./src/views/GraphView.tsx"));
      const React = __importStar(__webpack_require__(/*! react */ "react"));
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      class ConflictGraph extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.contextNodeActions = [
            {
              title: 'Highlight Cycle',
              show: true,
              action: () => this.highlightCycle(),
            },
            {
              title: 'Load Last (among connected)',
              show: true,
              action: () => this.loadLast(),
            },
          ];
          this.contextEdgeActions = [
            {
              title: 'Flip Rule',
              show: true,
              action: () => this.flipRule(),
            },
            {
              title: 'Remove Rule',
              show: true,
              action: () => this.removeRule(),
            },
          ];
          this.contextBGActions = [
            {
              title: 'Layout',
              show: true,
              action: () => this.mGraphRef.layout(),
            },
          ];
          this.openContext = (x, y, selection) => {
            if ((selection !== undefined) && selection.readonly) {
              return;
            }
            this.nextState.context = { x, y, selection };
            this.mContextTime = Date.now();
          };
          this.hideContext = () => {
            if (Date.now() - this.mContextTime < 100) {
              return;
            }
            this.nextState.context = undefined;
          };
          this.setGraphRef = (ref) => {
            this.mGraphRef = ref;
          };
          this.close = () => {
            const { onClose } = this.props;
            onClose();
          };
          this.highlightCycle = () => {
            const { id } = this.state.context.selection;
            try {
              this.mGraphRef.highlightCycle(id);
            }
            catch (err) {
              this.context.api.showErrorNotification('Failed to highlight cycle', err);
            }
          };
          this.loadLast = () => {
            const { id } = this.state.context.selection;
            const { editCycle, localState, mods, onAddRule, onRemoveRule } = this.props;
            const beforeRules = localState.modRules.filter(rule => rule.original
                && (((rule.type === 'before') && vortex_api_1.util.testModReference(mods[id], rule.source))
                    || (rule.type === 'after') && vortex_api_1.util.testModReference(mods[id], rule.reference)));
            const connReferences = [];
            beforeRules.forEach(rule => {
              if (rule.type === 'before') {
                const otherId = editCycle.modIds
                  .find(modId => vortex_api_1.util.testModReference(mods[modId], rule.reference));
                if (editCycle.modIds.includes(otherId)) {
                  connReferences.push(rule.reference);
                  onRemoveRule(editCycle.gameId, id, rule);
                }
              }
              else {
                const sourceId = editCycle.modIds
                  .find(modId => vortex_api_1.util.testModReference(mods[modId], rule.source));
                if (editCycle.modIds.includes(sourceId)) {
                  connReferences.push(rule.source);
                  onRemoveRule(editCycle.gameId, sourceId, rule);
                }
              }
            });
            const modIds = new Set();
            connReferences.forEach(connRef => {
              const destId = editCycle.modIds
                .find(modId => vortex_api_1.util.testModReference(mods[modId], connRef));
              if (!modIds.has(destId)) {
                modIds.add(destId);
                onAddRule(editCycle.gameId, id, {
                  type: 'after',
                  reference: connRef,
                });
              }
            });
          };
          this.flipRule = () => {
            const { editCycle, localState, mods, onAddRule } = this.props;
            const { selection } = this.state.context;
            const bidirRule = localState.modRules.find(iter => (iter.type === 'before')
                && vortex_api_1.util.testModReference(mods[selection.source], iter.source)
                && vortex_api_1.util.testModReference(mods[selection.target], iter.reference));
            if (bidirRule === undefined) {
              return;
            }
            const sourceId = bidirRule.original ? selection.source : selection.target;
            const rule = {
              type: bidirRule.original ? 'after' : 'before',
              reference: bidirRule.original ? bidirRule.reference : bidirRule.source,
            };
            this.nextState.working = true;
            onAddRule(editCycle.gameId, sourceId, rule);
          };
          this.removeRule = () => {
            const { editCycle, localState, mods, onRemoveRule } = this.props;
            const { selection } = this.state.context;
            const bidirRule = localState.modRules.find(rule => rule.type === 'before'
                && vortex_api_1.util.testModReference(mods[selection.source], rule.source)
                && vortex_api_1.util.testModReference(mods[selection.target], rule.reference));
            if (bidirRule === undefined) {
              return;
            }
            const sourceId = bidirRule.original ? selection.source : selection.target;
            const remRule = {
              type: bidirRule.original ? 'before' : 'after',
              reference: bidirRule.original ? bidirRule.reference : bidirRule.source,
            };
            this.nextState.working = true;
            onRemoveRule(editCycle.gameId, sourceId, remRule);
          };
          this.initState({
            highlighted: undefined,
            counter: 0,
            context: undefined,
            elements: undefined,
            working: false,
          });
          this.mProxy = {
            setState: () => {
              this.nextState.counter++;
              this.nextState.working = false;
              this.updateGraph(this.props);
            },
          };
        }
        componentDidMount() {
          this.nextState.highlighted = undefined;
          this.props.localState.attach(this.mProxy);
        }
        componentWillUnmount() {
          this.props.localState.detach(this.mProxy);
        }
        UNSAFE_componentWillReceiveProps(newProps) {
          if (newProps.editCycle === undefined) {
            return;
          }
          if (!this.state.working
            && ((this.props.conflicts !== newProps.conflicts)
                || (this.props.mods !== newProps.mods)
                || (this.props.editCycle !== newProps.editCycle))) {
            this.updateGraph(newProps);
          }
        }
        render() {
          const { t, editCycle } = this.props;
          const { working } = this.state;
          if (editCycle === undefined) {
            return null;
          }
          let contextActions;
          if (this.state.context !== undefined) {
            contextActions = (this.state.context.selection !== undefined)
              ? (this.state.context.selection.id !== undefined)
                ? this.contextNodeActions
                : this.contextEdgeActions
              : this.contextBGActions;
          }
          return (React.createElement(vortex_api_1.Modal, { id: 'conflict-graph-dialog', show: editCycle !== undefined, onHide: this.close },
                                      React.createElement(vortex_api_1.Modal.Header, null,
                                                          React.createElement(vortex_api_1.Modal.Title, null, t('Cycle'))),
                                      React.createElement(vortex_api_1.Modal.Body, null,
                                                          working ? React.createElement("div", { className: 'conflict-graph-working' },
                                                                                        React.createElement(vortex_api_1.Spinner, null)) : this.renderGraph(),
                                                          React.createElement(vortex_api_1.ContextMenu, { position: this.state.context, visible: this.state.context !== undefined, onHide: this.hideContext, instanceId: '42', actions: contextActions }),
                                                          React.createElement(vortex_api_1.Usage, { infoId: 'conflicting-mods', persistent: true },
                                                                              React.createElement("div", null, t('This screen shows a cluster of mods that form one or more cycles.')),
                                                                              React.createElement("div", null, t('Arrows can be read as "then" (A ->- B reads "A, then B"), meaning the mod the '
                        + 'arrow points towards is the one that overwrites the first one.')),
                                                                              React.createElement("div", null, t('If there are too many connections you can highlight a single cycle '
                        + 'by right-clicking on one of the mods.')),
                                                                              React.createElement("div", null, t('You can resolve a cycle by either removing or flipping one rule, '
                        + 'so if you have a cycle A->-B->-C->-A you could flip the arrow '
                        + 'between C and A to get A->-B->-C-<-A which is no longer a cycle. '
                        + 'Repeat this until there are no cycles left.')))),
                                      React.createElement(vortex_api_1.Modal.Footer, null,
                                                          React.createElement(react_bootstrap_1.Button, { onClick: this.close }, t('Close')))));
        }
        getThemeSheet() {
          for (let i = 0; i < document.styleSheets.length; ++i) {
            if (document.styleSheets[i].ownerNode.id === 'theme') {
              return Array.from(document.styleSheets[i].rules);
            }
          }
          return [];
        }
        getAllLinks(props, modId) {
          const { editCycle, localState, mods } = props;
          return localState.modRules
            .filter(rule => (rule.type === 'after') && vortex_api_1.util.testModReference(mods[modId], rule.source))
            .map(rule => editCycle.modIds.filter(refId => vortex_api_1.util.testModReference(mods[refId], rule.reference)))
            .reduce((prev, refs) => {
              const newRefs = refs.filter(refId => !prev.includes(refId));
              return [...prev, ...newRefs];
            }, []);
        }
        updateGraph(props) {
          const { editCycle, mods } = props;
          if (editCycle === undefined) {
            this.nextState.elements = {};
            return;
          }
          const elements = editCycle.modIds.reduce((prev, modId) => {
            if (mods[modId] !== undefined) {
              prev[modId] = {
                title: vortex_api_1.util.renderModName(mods[modId]),
                connections: this.getAllLinks(props, modId),
                class: `conflictnode`,
                readonly: false,
              };
            }
            return prev;
          }, {});
          this.nextState.elements = elements;
        }
        renderGraph() {
          const { elements } = this.state;
          const sheet = this.getThemeSheet();
          return (React.createElement(GraphView_1.default, { className: 'conflict-graph', elements: elements, visualStyle: (0, genGraphStyle_1.default)(sheet), onContext: this.openContext, ref: this.setGraphRef }));
        }
      }
      const emptyObj = {};
      function mapStateToProps(state, props) {
        let editCycle = vortex_api_1.util.getSafe(state, ['session', 'dependencies', 'editCycle'], undefined)
        || undefined;
        const gameMode = vortex_api_1.selectors.activeGameId(state);
        let gameId = editCycle !== undefined ? editCycle.gameId : undefined;
        if (gameMode !== gameId) {
          editCycle = undefined;
          gameId = undefined;
        }
        return {
          conflicts: vortex_api_1.util.getSafe(state, ['session', 'dependencies', 'conflicts'], emptyObj),
          mods: (gameId !== undefined) ? state.persistent.mods[gameId] : emptyObj,
          editCycle,
        };
      }
      function mapDispatchToProps(dispatch) {
        return {
          onClose: () => dispatch((0, actions_1.setEditCycle)(undefined, undefined)),
          onAddRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.addModRule(gameId, modId, rule)),
          onRemoveRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.removeModRule(gameId, modId, rule)),
        };
      }
      exports["default"] = (0, react_i18next_1.withTranslation)(['common', statics_1.NAMESPACE])((0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(ConflictGraph));


/***/ }),

/***/ "./src/views/Connector.tsx":
/*!*********************************!*\
  !*** ./src/views/Connector.tsx ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const Line_1 = __importDefault(__webpack_require__(/*! ./Line */ "./src/views/Line.tsx"));
      const _ = __importStar(__webpack_require__(/*! lodash */ "lodash"));
      const React = __importStar(__webpack_require__(/*! react */ "react"));
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      class ConnectorImpl extends vortex_api_1.ComponentEx {
        shouldComponentUpdate(nextProps) {
          return !_.isEqual(this.props.source, nextProps.source)
            || !_.isEqual(this.props.target, nextProps.target);
        }
        render() {
          const { source, target } = this.props;
          if ((source === undefined) || (target === undefined)) {
            return null;
          }
          const lineClass = target.id !== null ? 'line-connect' : 'line-disconnect';
          return (React.createElement(Line_1.default, { source: source.pos, target: target.pos, className: lineClass, curved: target.id !== null }));
        }
      }
      function mapStateToProps(state) {
        return {
          source: vortex_api_1.util.getSafe(state, ['session', 'dependencies', 'connection', 'source'], undefined),
          target: vortex_api_1.util.getSafe(state, ['session', 'dependencies', 'connection', 'target'], undefined),
        };
      }
      exports["default"] = (0, react_redux_1.connect)(mapStateToProps)(ConnectorImpl);


/***/ }),

/***/ "./src/views/DependencyIcon.tsx":
/*!**************************************!*\
  !*** ./src/views/DependencyIcon.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const ruleFulfilled_1 = __importDefault(__webpack_require__(/*! ../util/ruleFulfilled */ "./src/util/ruleFulfilled.ts"));
      const actions_1 = __webpack_require__(/*! ../actions */ "./src/actions.ts");
      const selectors_1 = __webpack_require__(/*! ../selectors */ "./src/selectors.ts");
      const memoize_one_1 = __importDefault(__webpack_require__(/*! memoize-one */ "../../node_modules/memoize-one/dist/memoize-one.esm.js"));
      const React = __importStar(__webpack_require__(/*! react */ "react"));
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_dnd_1 = __webpack_require__(/*! react-dnd */ "react-dnd");
      const react_dnd_html5_backend_1 = __webpack_require__(/*! react-dnd-html5-backend */ "react-dnd-html5-backend");
      const react_dom_1 = __webpack_require__(/*! react-dom */ "react-dom");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const semver = __importStar(__webpack_require__(/*! semver */ "semver"));
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const emptyArray = [];
      class RuleDescription extends React.Component {
        constructor() {
          super(...arguments);
          this.renderRemove = () => {
            const { t, onRemoveRule, rule } = this.props;
            if (onRemoveRule === undefined) {
              return null;
            }
            return (React.createElement(vortex_api_1.tooltip.IconButton, { id: this.key(rule), className: 'btn-embed', icon: 'remove', tooltip: t('Remove'), onClick: this.removeThis }));
          };
          this.removeThis = () => {
            this.props.onRemoveRule(this.props.rule);
          };
          this.renderType = (ruleType) => {
            const { t } = this.props;
            let renderString;
            switch (ruleType) {
              case 'before':
                renderString = t('Loads before');
                break;
              case 'after':
                renderString = t('Loads after');
                break;
              case 'requires':
                renderString = t('Requires');
                break;
              case 'recommends':
                renderString = t('Recommends');
                break;
              case 'conflicts':
                renderString = t('Conflicts with');
                break;
              case 'provides':
                renderString = t('Provides');
                break;
              default: throw new Error('invalid rule type ' + ruleType);
            }
            return React.createElement("p", { style: { display: 'inline' } }, renderString);
          };
          this.renderReference = (ref) => {
            const { mod } = this.props;
            if (mod !== undefined) {
              return React.createElement("p", { className: 'rule-mod-name' }, vortex_api_1.util.renderModName(mod, { version: true }));
            }
            let version = '*';
            if (ref.versionMatch !== undefined) {
              try {
                const sv = new semver.Range(ref.versionMatch, { loose: true, includePrerelease: true });
                version = sv.range;
              }
              catch (err) {
                version = ref.versionMatch;
              }
            }
            if (ref.description !== undefined) {
              return React.createElement("p", { className: 'rule-mod-name' },
                                         ref.description,
                                         " ",
                                         version);
            }
            if ((ref.logicalFileName === undefined)
                && (ref.fileExpression === undefined)) {
              return React.createElement("p", { className: 'rule-mod-name' }, ref.fileMD5 || ref.id);
            }
            return (React.createElement("p", { className: 'rule-mod-name' },
                                        ref.logicalFileName || ref.fileExpression,
                                        " ",
                                        version));
          };
        }
        render() {
          const { rule } = this.props;
          const classes = [
            'rule-description',
            this.className(),
          ]
            .filter(iter => iter !== undefined)
            .join(' ');
          const key = this.key(rule);
          return (React.createElement("div", { key: key, className: classes },
                                      this.renderType(rule.type),
                                      ' ',
                                      this.renderReference(rule.reference),
                                      this.renderRemove()));
        }
        className() {
          const { fulfilled, rule } = this.props;
          if (fulfilled === null) {
            return undefined;
          }
          else if (rule['ignored'] === true) {
            return 'rule-ignored';
          }
          else if (fulfilled) {
            return 'rule-fulfilled';
          }
          else {
            return 'rule-unfulfilled';
          }
        }
        key(rule) {
          return rule.type + '_' + (rule.reference.logicalFileName
            || rule.reference.fileExpression
            || rule.reference.fileMD5
            || rule.reference.id);
        }
      }
      function componentCenter(component) {
        const box = (0, react_dom_1.findDOMNode)(component).getBoundingClientRect();
        return {
          x: box.left + box.width / 2,
          y: box.top + box.height / 2,
        };
      }
      let cursorPosUpdater;
      let lastUpdatePos = { x: 0, y: 0 };
      function updateCursorPos(monitor, component, onSetSource, onSetTarget) {
        if (monitor.getClientOffset() !== null) {
          const curPos = monitor.getClientOffset();
          const dist = Math.abs(curPos.x - lastUpdatePos.x) + Math.abs(curPos.y - lastUpdatePos.y);
          if ((dist > 2) && (monitor.getItem() !== null)) {
            const sourceId = monitor.getItem().id;
            lastUpdatePos = curPos;
            onSetTarget(null, curPos);
            try {
              onSetSource(sourceId, componentCenter(component));
            }
            catch (err) {
            }
          }
        }
        cursorPosUpdater = setTimeout(() => updateCursorPos(monitor, component, onSetSource, onSetTarget), 50);
      }
      const dependencySource = {
        beginDrag(props, monitor, component) {
          updateCursorPos(monitor, component, props.onSetSource, props.onSetTarget);
          return {
            id: props.mod.id,
          };
        },
        endDrag(props, monitor) {
          clearTimeout(cursorPosUpdater);
          cursorPosUpdater = undefined;
          const sourceId = monitor.getItem().id;
          props.onSetSource(sourceId, undefined);
          if (monitor.getDropResult() === null) {
            return;
          }
          const destId = monitor.getDropResult().id;
          const reference = monitor.getDropResult().reference;
          if (sourceId !== destId) {
            props.onEditDialog(props.gameId, sourceId, reference, 'after');
          }
        },
      };
      const dependencyTarget = {
        drop(props, monitor, component) {
          const inst = component.decoratedRef.current;
          if (inst === undefined) {
            return undefined;
          }
          return {
            id: props.mod.id,
            reference: inst.state.reference,
          };
        },
      };
      function collectDrag(conn, monitor) {
        return {
          connectDragSource: conn.dragSource(),
          connectDragPreview: conn.dragPreview(),
          isDragging: monitor.isDragging(),
        };
      }
      function collectDrop(conn, monitor) {
        return {
          connectDropTarget: conn.dropTarget(),
          isOver: monitor.isOver(),
          canDrop: monitor.canDrop(),
        };
      }
      class DependencyIcon extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.mRuleFulfillmentMemo = (0, memoize_one_1.default)(this.ruleFulfillment);
          this.setRef = (ref) => {
            this.mRef = ref;
          };
          this.toggleOverlay = () => {
            this.nextState.showOverlay = !this.state.showOverlay;
          };
          this.hideOverlay = () => {
            this.nextState.showOverlay = false;
          };
          this.openConflictDialog = () => {
            const { gameId, mod, onConflictDialog } = this.props;
            const { modRules } = this.state;
            onConflictDialog(gameId, [mod.id], modRules);
          };
          this.openOverrideDialog = () => {
            const { gameId, mod, onOverrideDialog } = this.props;
            onOverrideDialog(gameId, mod.id);
          };
          this.key = (rule) => {
            let _a;
            return [
              rule.type, (rule.reference.logicalFileName
                    || rule.reference.fileExpression
                    || rule.reference.fileMD5
                    || rule.reference.id),
              (_a = rule.reference.versionMatch) !== null && _a !== void 0 ? _a : '*'
            ].join('_');
          };
          this.removeRule = (rule) => {
            const { gameId, mod, onRemoveRule } = this.props;
            onRemoveRule(gameId, mod.id, rule);
          };
          this.initState({
            modInfo: undefined,
            reference: undefined,
            showOverlay: false,
            modRules: props.localState.modRules.filter(rule => vortex_api_1.util.testModReference(props.mod, rule.source)),
          });
          this.mIsMounted = false;
        }
        UNSAFE_componentWillMount() {
          this.updateMod(this.props.mod);
        }
        componentDidMount() {
          this.mIsMounted = true;
          this.props.connectDragPreview((0, react_dnd_html5_backend_1.getEmptyImage)());
        }
        componentWillUnmount() {
          this.mIsMounted = false;
        }
        UNSAFE_componentWillReceiveProps(nextProps) {
          if (this.props.mod !== nextProps.mod) {
            this.updateMod(nextProps.mod);
          }
          if ((this.props.mod !== nextProps.mod)
            || (this.props.localState.modRules !== nextProps.localState.modRules)) {
            this.nextState.modRules = nextProps.localState.modRules.filter(rule => vortex_api_1.util.testModReference(nextProps.mod, rule.source));
          }
          if (this.props.isDragging !== nextProps.isDragging) {
            let pos;
            if (nextProps.isDragging) {
              pos = componentCenter(this);
            }
            nextProps.onSetSource(nextProps.mod.id, pos);
          }
          else if (this.props.isOver !== nextProps.isOver) {
            let pos;
            if (nextProps.isOver) {
              pos = componentCenter(this);
            }
            nextProps.onHighlight(nextProps.isOver);
            nextProps.onSetTarget(nextProps.mod.id, pos);
          }
        }
        shouldComponentUpdate(nextProps, nextState) {
          return this.props.conflicts !== nextProps.conflicts
            || this.props.enabledMods !== nextProps.enabledMods
            || this.props.gameId !== nextProps.gameId
            || this.props.mod !== nextProps.mod
            || this.props.localState.modRules !== nextProps.localState.modRules
            || this.props.source !== nextProps.source
            || this.props.highlightConflict !== nextProps.highlightConflict
            || this.state !== nextState;
        }
        render() {
          const { connectDropTarget, mod, source } = this.props;
          if (mod.state !== 'installed') {
            return null;
          }
          const classes = ['dependencies-inner'];
          if (source !== undefined) {
            classes.push('connecting');
          }
          return connectDropTarget((React.createElement("div", { className: classes.join(' ') },
                                                        this.renderConnectorIcon(mod),
                                                        this.renderConflictIcon(mod),
                                                        this.renderOverrideIcon(mod))));
        }
        ruleFulfillment(staticRules, customRules, enabledMods, gameId, modId) {
          const res = new Map();
          const source = { gameId, modId };
          staticRules.forEach(rule => res.set(rule, (0, ruleFulfilled_1.default)(enabledMods, rule, source)));
          customRules.forEach(rule => res.set(rule, (0, ruleFulfilled_1.default)(enabledMods, rule, source)));
          return res;
        }
        renderConnectorIcon(mod) {
          let _a, _b, _c, _d;
          const { t, connectDragSource, enabledMods, gameId, modState, mods } = this.props;
          const classes = ['btn-dependency'];
          let anyUnfulfilled = false;
          const staticRules = (_b = (_a = this.state.modInfo) === null || _a === void 0 ? void 0 : _a.rules) !== null && _b !== void 0 ? _b : emptyArray;
          const customRules = (_c = mod.rules) !== null && _c !== void 0 ? _c : emptyArray;
          const rulesFulfilled = (((_d = modState === null || modState === void 0 ? void 0 : modState[mod.id]) === null || _d === void 0 ? void 0 : _d.enabled) === true)
            ? this.mRuleFulfillmentMemo(staticRules, customRules, enabledMods, gameId, mod.id)
            : null;
          const renderRule = (rule, onRemove) => {
            const isFulfilled = (rulesFulfilled !== null)
              ? rulesFulfilled.get(rule)
              : true;
            if ((isFulfilled === false) && !rule['ignored']) {
              anyUnfulfilled = true;
            }
            if (mods === undefined) {
              return null;
            }
            const refMod = mods[rule.reference.id];
            return (React.createElement(RuleDescription, { t: t, key: this.key(rule), rule: rule, onRemoveRule: onRemove, fulfilled: isFulfilled, mod: refMod }));
          };
          let popover;
          if ((staticRules.length > 0) || (customRules.length > 0)) {
            popover = (React.createElement(react_bootstrap_1.Popover, { id: `popover-${mod.id}`, style: { maxWidth: 500 } },
                                           staticRules.map(rule => renderRule(rule, undefined)),
                                           customRules.map(rule => renderRule(rule, this.removeRule))));
            classes.push(anyUnfulfilled ? 'btn-dependency-unfulfilledrule' : 'btn-dependency-hasrules');
          }
          else {
            classes.push('btn-dependency-norules');
            popover = (React.createElement(react_bootstrap_1.Popover, { id: `popover-${mod.id}` }, t('No rules')));
          }
          return connectDragSource((React.createElement("div", { style: { display: 'inline' } },
                                                        React.createElement(vortex_api_1.tooltip.IconButton, { id: `btn-meta-data-${mod.id}`, className: classes.join(' '), key: `rules-${mod.id}`, tooltip: t('Drag to another mod to define dependency'), icon: 'connection', ref: this.setRef, onClick: this.toggleOverlay }),
                                                        React.createElement(react_bootstrap_1.Overlay, { show: this.state.showOverlay, onHide: this.hideOverlay, placement: 'left', rootClose: true, target: this.mRef }, popover))));
        }
        findRule(ref) {
          return this.state.modRules.find(rule => vortex_api_1.util.testModReference(ref, rule.reference));
        }
        renderOverrideIcon(mod) {
          const { t } = this.props;
          if ((mod.fileOverrides === undefined)
            || (mod.fileOverrides.length === 0)) {
            return null;
          }
          return (React.createElement(vortex_api_1.tooltip.IconButton, { id: `btn-meta-overrides-${mod.id}`, className: 'btn-overrides', key: `overrides-${mod.id}`, tooltip: t('This mod has files override the deploy order'), icon: 'override', onClick: this.openOverrideDialog }));
        }
        renderConflictIcon(mod) {
          const { t, conflicts, highlightConflict } = this.props;
          if ((conflicts === undefined) || (conflicts[mod.id] === undefined)) {
            return null;
          }
          const classes = ['btn-conflict'];
          const unsolvedConflict = conflicts[mod.id].find(conflict => {
            const rule = this.findRule(conflict.otherMod);
            return rule === undefined;
          });
          if (unsolvedConflict !== undefined) {
            classes.push('btn-conflict-unsolved');
          }
          else {
            classes.push('btn-conflict-allsolved');
          }
          if (highlightConflict) {
            classes.push('btn-conflict-highlight');
          }
          const tip = t('Conflicts with: {{conflicts}}', {
            replace: {
              conflicts: conflicts[mod.id].map(conflict => this.renderModLookup(conflict.otherMod)).join('\n'),
            },
          });
          return (React.createElement(vortex_api_1.tooltip.IconButton, { id: `btn-meta-conflicts-${mod.id}`, className: classes.join(' '), key: `conflicts-${mod.id}`, tooltip: tip, icon: 'conflict', onClick: this.openConflictDialog }));
        }
        renderModLookup(lookupInfo) {
          const id = lookupInfo.customFileName
            || lookupInfo.logicalFileName
            || lookupInfo.name;
          const version = lookupInfo.version;
          return version !== undefined ? id + ' v' + version : id;
        }
        updateMod(mod) {
          let _a;
          const attributes = mod.attributes || {};
          this.nextState.reference = {
            fileMD5: attributes['fileMD5'],
            versionMatch: attributes['version'],
            fileExpression: mod.installationPath,
            logicalFileName: attributes['logicalFileName'],
          };
          if (attributes['fileMD5'] !== undefined) {
            this.context.api.lookupModMeta({
              fileMD5: attributes['fileMD5'],
              fileSize: attributes['fileSize'],
              gameId: (_a = attributes['downloadGame']) !== null && _a !== void 0 ? _a : this.props.gameId,
            })
              .then((meta) => {
                if (this.mIsMounted && (meta.length > 0)) {
                  this.nextState.modInfo = meta[0].value;
                }
              })
              .catch((err) => {
                (0, vortex_api_1.log)('warn', 'failed to look up mod', { err: err.message, stack: err.stack });
              });
          }
        }
      }
      const type = 'dependency-management-icon';
      const DependencyIconDrag = (0, react_dnd_1.DropTarget)(type, dependencyTarget, collectDrop)((0, react_dnd_1.DragSource)(type, dependencySource, collectDrag)(DependencyIcon));
      const emptyObj = {};
      function mapStateToProps(state) {
        const profile = vortex_api_1.selectors.activeProfile(state);
        const gameId = profile !== undefined ? profile.gameId : undefined;
        return {
          gameId,
          conflicts: vortex_api_1.util.getSafe(state.session, ['dependencies', 'conflicts'], emptyObj),
          mods: state.persistent.mods[gameId],
          enabledMods: (0, selectors_1.enabledModKeys)(state),
          modState: profile !== undefined ? profile.modState : undefined,
          source: vortex_api_1.util.getSafe(state, ['session', 'dependencies', 'connection', 'source'], undefined),
          highlightConflict: vortex_api_1.util.getSafe(state, ['session', 'dependencies', 'highlightConflicts'], false),
        };
      }
      function mapDispatchToProps(dispatch) {
        return {
          onSetSource: (id, pos) => dispatch((0, actions_1.setSource)(id, pos)),
          onSetTarget: (id, pos) => dispatch((0, actions_1.setTarget)(id, pos)),
          onEditDialog: (gameId, modId, reference, defaultType) => dispatch((0, actions_1.setCreateRule)(gameId, modId, reference, defaultType)),
          onRemoveRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.removeModRule(gameId, modId, rule)),
          onConflictDialog: (gameId, modIds, modRules) => dispatch((0, actions_1.setConflictDialog)(gameId, modIds, modRules)),
          onOverrideDialog: (gameId, modId) => dispatch((0, actions_1.setFileOverrideDialog)(gameId, modId)),
        };
      }
      exports["default"] = (0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(DependencyIconDrag);


/***/ }),

/***/ "./src/views/Editor.tsx":
/*!******************************!*\
  !*** ./src/views/Editor.tsx ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const actions_1 = __webpack_require__(/*! ../actions */ "./src/actions.ts");
      const statics_1 = __webpack_require__(/*! ../statics */ "./src/statics.ts");
      const minimatch_1 = __importDefault(__webpack_require__(/*! minimatch */ "minimatch"));
      const React = __importStar(__webpack_require__(/*! react */ "react"));
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const semver = __importStar(__webpack_require__(/*! semver */ "semver"));
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function nop() {
      }
      class Editor extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.renderSource = (mod) => {
            return React.createElement("p", null, vortex_api_1.util.renderModName(mod));
          };
          this.renderReference = (reference) => {
            const { t, dialog } = this.props;
            const { logicalFileName, versionMatch, fileExpression, fileMD5 } = reference;
            if (((logicalFileName === '')
                && (fileExpression === ''))
                || (versionMatch === undefined)) {
              return (React.createElement(react_bootstrap_1.Form, { horizontal: true },
                                          React.createElement(react_bootstrap_1.FormGroup, null,
                                                              React.createElement(react_bootstrap_1.Col, { sm: 3, componentClass: react_bootstrap_1.ControlLabel }, t('MD5')),
                                                              React.createElement(react_bootstrap_1.Col, { sm: 9 },
                                                                                  React.createElement(react_bootstrap_1.FormControl, { type: 'text', value: fileMD5, readOnly: true })))));
            }
            let expressionInvalid = null;
            if (logicalFileName === undefined) {
              expressionInvalid = (0, minimatch_1.default)(dialog.reference.fileExpression, fileExpression)
                ? null : t('Doesn\'t match the file name');
            }
            const nameLabel = logicalFileName !== undefined
              ? React.createElement(react_bootstrap_1.Col, { sm: 3, componentClass: react_bootstrap_1.ControlLabel }, t('Name'))
              : (React.createElement(react_bootstrap_1.Col, { sm: 3, componentClass: react_bootstrap_1.ControlLabel },
                                     t('Name matching'),
                                     React.createElement(vortex_api_1.More, { id: 'more-namematch-editor', name: t('Name matching') }, vortex_api_1.util.getText('mod', 'namematch', t))));
            const refVer = dialog.reference.versionMatch;
            let versionInvalid = null;
            if (versionMatch === '*') {
            }
            else if (semver.validRange(versionMatch) === null) {
              versionInvalid = t('Range invalid');
            }
            else if (semver.valid(refVer) && !semver.satisfies(refVer, versionMatch)) {
              versionInvalid = t('Doesn\'t match the mod');
            }
            else if (!semver.valid(refVer) && (refVer !== versionMatch)) {
              versionInvalid = t('Doesn\'t match the mod');
            }
            return (React.createElement(react_bootstrap_1.Form, { horizontal: true },
                                        React.createElement(react_bootstrap_1.FormGroup, null,
                                                            nameLabel,
                                                            React.createElement(react_bootstrap_1.Col, { sm: 9 },
                                                                                React.createElement(react_bootstrap_1.FormGroup, { style: { marginLeft: 0, marginRight: 0 }, validationState: expressionInvalid !== null ? 'error' : 'success' },
                                                                                                    React.createElement(react_bootstrap_1.FormControl, { type: 'text', value: logicalFileName || fileExpression, readOnly: logicalFileName !== undefined, onChange: this.changeFileExpression }),
                                                                                                    React.createElement(react_bootstrap_1.ControlLabel, null, expressionInvalid),
                                                                                                    React.createElement(vortex_api_1.FormFeedback, null)))),
                                        React.createElement(react_bootstrap_1.FormGroup, null,
                                                            React.createElement(react_bootstrap_1.Col, { sm: 3, componentClass: react_bootstrap_1.ControlLabel },
                                                                                t('Version Match'),
                                                                                React.createElement(vortex_api_1.More, { id: 'more-versionmatch-editor', name: t('Version matching') }, vortex_api_1.util.getText('mod', 'versionmatch', t))),
                                                            React.createElement(react_bootstrap_1.Col, { sm: 9 },
                                                                                React.createElement(react_bootstrap_1.FormGroup, { style: { marginLeft: 0, marginRight: 0 }, validationState: versionInvalid !== null ? 'error' : 'success' },
                                                                                                    React.createElement(react_bootstrap_1.FormControl, { type: 'text', value: versionMatch, onChange: this.changeVersion }),
                                                                                                    React.createElement(react_bootstrap_1.ControlLabel, null, versionInvalid),
                                                                                                    React.createElement(vortex_api_1.FormFeedback, null))))));
          };
          this.changeFileExpression = (evt) => {
            this.nextState.reference.fileExpression = evt.currentTarget.value;
          };
          this.changeVersion = (evt) => {
            this.nextState.reference.versionMatch = evt.currentTarget.value;
          };
          this.changeType = (evt) => {
            this.nextState.type = evt.currentTarget.value;
          };
          this.save = () => {
            const { dialog, onAddRule } = this.props;
            const { reference, type } = this.state;
            if (reference === undefined) {
              return;
            }
            let addRef;
            if (reference.versionMatch !== undefined) {
              if (reference.logicalFileName !== undefined) {
                addRef = {
                  logicalFileName: reference.logicalFileName,
                  versionMatch: reference.versionMatch,
                };
              }
              else {
                addRef = {
                  fileExpression: reference.fileExpression,
                  versionMatch: reference.versionMatch,
                };
              }
            }
            else {
              addRef = { fileMD5: reference.fileMD5 };
            }
            onAddRule(dialog.gameId, dialog.modId, {
              reference: addRef,
              type,
            });
            this.close();
          };
          this.close = () => {
            this.props.onCloseDialog();
          };
          this.initState({ type: undefined, reference: undefined });
        }
        UNSAFE_componentWillReceiveProps(nextProps) {
          if (this.props.dialog !== nextProps.dialog) {
            if ((nextProps.dialog !== undefined)
                && (nextProps.dialog.reference !== undefined)) {
              this.nextState.type = nextProps.dialog.type;
              this.nextState.reference = Object.assign(Object.assign({}, nextProps.dialog.reference), { versionMatch: this.genVersionMatch(nextProps.dialog.reference.versionMatch) });
            }
            else {
              this.nextState.type = undefined;
              this.nextState.reference = undefined;
            }
          }
        }
        render() {
          const { t, dialog, mod } = this.props;
          const { reference, type } = this.state;
          return (React.createElement(react_bootstrap_1.Modal, { show: dialog !== undefined, onHide: nop },
                                      dialog !== undefined
                                        ? (React.createElement(react_bootstrap_1.Modal.Body, null,
                                                               this.renderSource(mod),
                                                               React.createElement(react_bootstrap_1.FormControl, { componentClass: 'select', onChange: this.changeType, value: type, style: { marginTop: 20, marginBottom: 20 } },
                                                                                   React.createElement("option", { value: 'before' }, t('Must deploy before')),
                                                                                   React.createElement("option", { value: 'after' }, t('Must deploy after')),
                                                                                   React.createElement("option", { value: 'requires' }, t('Requires')),
                                                                                   React.createElement("option", { value: 'conflicts' }, t('Conflicts with / Can\'t be deployed together with'))),
                                                               this.renderReference(reference))) : null,
                                      React.createElement(react_bootstrap_1.Modal.Footer, null,
                                                          React.createElement(react_bootstrap_1.Button, { onClick: this.close }, t('Cancel')),
                                                          React.createElement(react_bootstrap_1.Button, { onClick: this.save }, t('Save')))));
        }
        genVersionMatch(input) {
          if ((input === undefined) || !semver.valid(input)) {
            return '*';
          }
          else {
            return '^' + input;
          }
        }
      }
      function mapStateToProps(state) {
        const dialog = state.session.dependencies.dialog || undefined;
        const mod = dialog !== undefined
          ? vortex_api_1.util.getSafe(state, ['persistent', 'mods', dialog.gameId, dialog.modId], undefined)
          : undefined;
        return {
          dialog,
          mod,
        };
      }
      function mapDispatchToProps(dispatch) {
        return {
          onCloseDialog: () => dispatch((0, actions_1.closeDialog)()),
          onSetType: (type) => dispatch((0, actions_1.setType)(type)),
          onAddRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.addModRule(gameId, modId, rule)),
        };
      }
      exports["default"] = (0, react_i18next_1.withTranslation)(['common', statics_1.NAMESPACE])((0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(Editor));


/***/ }),

/***/ "./src/views/GraphView.tsx":
/*!*********************************!*\
  !*** ./src/views/GraphView.tsx ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const cytoscape_1 = __importDefault(__webpack_require__(/*! cytoscape */ "./node_modules/cytoscape/dist/cytoscape.cjs.js"));
      const cytoscape_cose_bilkent_1 = __importDefault(__webpack_require__(/*! cytoscape-cose-bilkent */ "./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js"));
      const React = __importStar(__webpack_require__(/*! react */ "react"));
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      cytoscape_1.default.use(cytoscape_cose_bilkent_1.default);
      const MAX_COLUMNS = 5;
      function san(input) {
        return input.replace(/[^a-zA-Z0-9_-]/g, (invalid) => `_${invalid.charCodeAt(0)}_`);
      }
      class GraphView extends React.Component {
        constructor(props) {
          super(props);
          this.mMousePos = { x: 0, y: 0 };
          this.mEdgeIds = new Set();
          this.setRef = (ref) => {
            const { elements, visualStyle } = this.props;
            if (ref === null) {
              this.mGraph.off('cxttap', this.handleContext);
              this.mGraph = undefined;
              return;
            }
            this.mGraph = (0, cytoscape_1.default)({
              container: ref,
              style: visualStyle,
              minZoom: 0.33,
              maxZoom: 2,
              wheelSensitivity: 0.1,
              boxSelectionEnabled: false,
            });
            this.addElements(elements || {});
            this.mGraph.resize();
            this.mGraph.center();
            this.mLayout = this.mGraph.layout({
              name: 'cose-bilkent',
              nodeDimensionsIncludeLabels: true,
              randomize: false,
              nodeRepulsion: 9000,
              idealEdgeLength: 500,
            });
            this.mLayout.run();
            this.mGraph.on('cxttap', this.handleContext);
          };
          this.handleContext = (evt) => {
            let selection;
            if (evt.target.data !== undefined) {
              const data = evt.target.data();
              if ((data.title === undefined) && (data.source === undefined)) {
                return;
              }
              selection = (data.source !== undefined)
                ? { source: data.sourceOrig, target: data.targetOrig, readonly: data.readonly }
                : { id: data.originalId, readonly: data.readonly };
            }
            this.mMousePos = evt.position;
            this.props.onContext(evt.renderedPosition.x, evt.renderedPosition.y, selection);
          };
          this.mLastProps = props;
        }
        UNSAFE_componentWillReceiveProps(newProps) {
          if (newProps.elements !== this.mLastProps.elements) {
            const changed = vortex_api_1.util.objDiff(this.mLastProps.elements, newProps.elements);
            this.mLastProps = newProps;
            const newConnections = [];
            Object.keys(changed).forEach(id => {
              if (id[0] === '+') {
                this.mGraph.add({
                  data: { id: san(id.slice(1)), title: changed[id].title, originalId: id.slice(1) },
                  classes: changed[id].class,
                  position: this.mMousePos,
                });
                const connections = changed[id].connections;
                Object.keys(connections || []).forEach(refId => {
                  const from = san(id.slice(1));
                  const to = san(connections[refId]);
                  newConnections.push({
                    data: {
                      id: `${to}-to-${from}`,
                      source: to,
                      sourceOrig: connections[refId],
                      target: from,
                      targetOrig: id.slice(1),
                    },
                    classes: (newProps.elements[id] !== undefined)
                      ? newProps.elements[id].class
                      : undefined,
                  });
                });
              }
              else if (id[0] === '-') {
                this.mGraph.remove('#' + san(id.slice(1)));
              }
              else {
                const nodeId = san(id);
                if (this.props.elements[id].class !== newProps.elements[id].class) {
                  this.mGraph.$(`node#${nodeId}, edge[target = "${nodeId}"]`)
                    .removeClass(this.props.elements[id].class)
                    .addClass(newProps.elements[id].class);
                }
                Object.keys(changed[id].connections || [])
                  .sort((lhs, rhs) => {
                    if (lhs[0] !== rhs[0]) {
                      return lhs[0] === '-' ? -1 : 1;
                    }
                    else {
                      return lhs.localeCompare(rhs);
                    }
                  })
                  .forEach(refId => {
                    const from = san(id);
                    const to = san(changed[id].connections[refId]);
                    const connId = `${to}-to-${from}`;
                    if (refId[0] === '-') {
                      this.mEdgeIds.delete(connId);
                      this.mGraph.remove('#' + connId);
                    }
                    else if (refId[0] === '+') {
                      newConnections.push({
                        data: {
                          id: connId,
                          source: to,
                          sourceOrig: changed[id].connections[refId],
                          target: from,
                          targetOrig: id,
                        },
                        classes: (newProps.elements[id] !== undefined)
                          ? newProps.elements[id].class
                          : undefined,
                      });
                    }
                  });
              }
            });
            newConnections.forEach(conn => {
              if (!this.mEdgeIds.has(conn.data.id)) {
                this.mEdgeIds.add(conn.data.id);
                this.mGraph.add(conn);
              }
            });
            this.mGraph.elements()
              .removeClass('cycle-hidden')
              .removeClass('cycle-highlight');
          }
        }
        layout() {
          this.mLayout.run();
        }
        highlightCycle(nodeId) {
          const followers = this.mGraph
            .$(`#${san(nodeId)}`)
            .outgoers()
            .filter(ele => (ele !== undefined) && (ele.group() === 'nodes'));
          const firstCycle = followers.reduce((prev, node) => {
            if (node === undefined) {
              return;
            }
            if (prev === undefined) {
              const root = san(node.id());
              const goal = san(nodeId);
              if ((this.mGraph.getElementById(root).length === 0)
                    || (this.mGraph.getElementById(goal).length === 0)) {
                throw new Error(`invalid route "${node.id()}" to "${nodeId}"`);
              }
              const path = this.mGraph.elements().aStar({
                root: `#${root}`,
                goal: `#${goal}`,
                directed: true,
              });
              if (path.found) {
                prev = path.path;
              }
            }
            return prev;
          }, undefined);
          if (firstCycle !== undefined) {
            this.mGraph.elements()
              .addClass('cycle-hidden')
              .removeClass('cycle-highlight');
            this.mGraph.$(`#${san(nodeId)}-to-${san(firstCycle[0].id())}`)
              .removeClass('cycle-hidden')
              .addClass('cycle-highlight');
            firstCycle.filter(iter => iter.group() === 'edges')
              .removeClass('cycle-hidden')
              .addClass('cycle-highlight');
          }
        }
        render() {
          const { className, style } = this.props;
          return React.createElement("div", { ref: this.setRef, className: className, style: style });
        }
        addElements(elements) {
          const width = MAX_COLUMNS;
          const distance = (this.mGraph.width() / width) * 2;
          this.mGraph
            .add(Object.keys(elements).reduce((prev, id, idx) => {
              const ele = elements[id];
              const row = Math.floor(idx / width);
              const pos = (row % 2 === 0) ? (idx % width) : width - (idx % width);
              prev.push({
                data: { id: san(id), title: ele.title, originalId: id, readonly: ele.readonly },
                classes: ele.class,
                position: { x: pos * distance, y: row * distance + (pos % 2) * (distance / 2) },
              });
              (ele.connections || []).forEach(conn => {
                prev.push({
                  data: {
                    id: san(`${san(conn)}-to-${san(id)}`),
                    target: san(id),
                    source: san(conn),
                    targetOrig: id,
                    sourceOrig: conn,
                    readonly: ele.readonly,
                  },
                  classes: ele.class,
                });
              });
              return prev;
            }, []));
        }
      }
      exports["default"] = GraphView;


/***/ }),

/***/ "./src/views/Line.tsx":
/*!****************************!*\
  !*** ./src/views/Line.tsx ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __importStar(__webpack_require__(/*! react */ "react"));
      const Line = (props) => {
        const { className, curved, source, target } = props;
        const top = Math.min(target.y, source.y) - 2;
        const left = Math.min(target.x, source.x);
        const boxWidth = Math.abs(target.x - source.x) + 80;
        const boxHeight = Math.abs(target.y - source.y) + 4;
        const path = curved
          ? `M ${source.x - left} ${source.y - top}
  Q ${boxWidth} ${boxHeight / 2} ${target.x - left} ${target.y - top}`
          : `M ${source.x - left} ${source.y - top} L ${target.x - left} ${target.y - top}`;
        return (React.createElement("svg", { width: boxWidth, height: boxHeight, style: { position: 'fixed', top, left, pointerEvents: 'none' } },
                                    React.createElement("path", { className: className, d: path, fill: 'none' })));
      };
      exports["default"] = Line;


/***/ }),

/***/ "./src/views/ModNameWrapper.tsx":
/*!**************************************!*\
  !*** ./src/views/ModNameWrapper.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const react_1 = __importDefault(__webpack_require__(/*! react */ "react"));
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      const emptyArray = [];
      function ModNameWrapper(props) {
        let _a;
        const { rowId } = props;
        const gameId = (0, react_redux_1.useSelector)(vortex_api_1.selectors.activeGameId);
        const filter = (0, react_redux_1.useSelector)(state => { let _a, _b, _c; return (_c = (_b = (_a = state.settings.tables['mods']) === null || _a === void 0 ? void 0 : _a.filter) === null || _b === void 0 ? void 0 : _b['dependencies']) !== null && _c !== void 0 ? _c : emptyArray; });
        const columnEnabled = (0, react_redux_1.useSelector)(state => { let _a, _b, _c, _d; return (_d = (_c = (_b = (_a = state.settings.tables['mods']) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b['dependencies']) === null || _c === void 0 ? void 0 : _c.enabled) !== null && _d !== void 0 ? _d : false; });
        const mod = (0, react_redux_1.useSelector)(state => { let _a; return (_a = state.persistent.mods[gameId]) === null || _a === void 0 ? void 0 : _a[rowId]; });
        const store = (0, react_redux_1.useStore)();
        const filterByDependencies = react_1.default.useCallback(() => {
          let _a;
          const batch = [];
          batch.push(vortex_api_1.actions.setAttributeFilter('mods', 'dependencies', ['depends', rowId, vortex_api_1.util.renderModName(mod)]));
          const { attributes } = (_a = store.getState().settings.tables['mods']) !== null && _a !== void 0 ? _a : {};
          Object.keys(attributes !== null && attributes !== void 0 ? attributes : {})
            .forEach(key => {
              if ((key !== 'dependencies') && (attributes[key].sortDirection !== 'none')) {
                batch.push(vortex_api_1.actions.setAttributeSort('mods', key, 'none'));
              }
            });
          batch.push(vortex_api_1.actions.setAttributeVisible('mods', 'dependencies', true));
          batch.push(vortex_api_1.actions.setAttributeSort('mods', 'dependencies', 'asc'));
          vortex_api_1.util.batchDispatch(store, batch);
        }, [store, rowId]);
        const indent = (filter.length >= 2) && (filter[0] === 'depends') && (filter[1] !== rowId);
        const icons = [];
        const classes = ['modname-filter-wrapper'];
        if (indent && columnEnabled) {
          classes.push('modname-filter-indented');
          icons.push(react_1.default.createElement(vortex_api_1.Icon, { key: 'dependency', name: 'turn-s', rotate: 270, rotateId: 'turn-s-270', className: 'filter-dependencies-icon' }));
        }
        if (((_a = mod === null || mod === void 0 ? void 0 : mod.rules) !== null && _a !== void 0 ? _a : []).find(iter => ['requires', 'recommends'].includes(iter.type))) {
          icons.push(react_1.default.createElement(vortex_api_1.tooltip.IconButton, { key: 'filter-dependencies', icon: 'filter-dependencies', className: 'filter-dependencies-icon', "data-modid": rowId, onClick: filterByDependencies }));
        }
        return (react_1.default.createElement("div", { className: classes.join(' ') },
                                              ...icons,
                                              props.children));
      }
      exports["default"] = ModNameWrapper;


/***/ }),

/***/ "./src/views/OverrideEditor.tsx":
/*!**************************************!*\
  !*** ./src/views/OverrideEditor.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      const __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const actions_1 = __webpack_require__(/*! ../actions */ "./src/actions.ts");
      const statics_1 = __webpack_require__(/*! ../statics */ "./src/statics.ts");
      const SearchBox_1 = __importDefault(__webpack_require__(/*! ./SearchBox */ "./src/views/SearchBox.tsx"));
      const React = __importStar(__webpack_require__(/*! react */ "react"));
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function nop() {
      }
      class OverrideEditor extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.close = () => {
            const { onClose } = this.props;
            onClose();
          };
          this.openConflictEditor = () => {
            const { gameId, modId, onConflictDialog } = this.props;
            const { modRules } = this.state;
            onConflictDialog(gameId, [modId], modRules);
          };
          this.apply = () => {
            const { onClose, onSetFileOverrides, pathTool, gameId, mods, discovery } = this.props;
            const { treeState } = this.state;
            const files = {};
            const initProvider = (provId) => {
              if (files[provId] === undefined) {
                files[provId] = (mods[provId].fileOverrides || []);
              }
            };
            const walkState = (children, parentPath) => {
              children.forEach(iter => {
                const filePath = pathTool.join(parentPath, iter.title);
                if (iter.isDirectory) {
                  walkState(iter.children, filePath);
                }
                else {
                  iter.providers.forEach(initProvider);
                  iter.providers.forEach(provider => {
                    const fullPath = pathTool.join(discovery.path, filePath);
                    files[provider] = vortex_api_1.util.addUniqueSafe(files[provider], [], fullPath);
                    if ((provider === iter.selected)) {
                      files[provider] = vortex_api_1.util.removeValue(files[provider], [], fullPath);
                    }
                  });
                }
              });
            };
            walkState(treeState, '');
            const batched = Object.keys(files).reduce((accum, provId) => {
              if (files[provId] !== mods[provId].fileOverrides) {
                accum.push(vortex_api_1.actions.setFileOverride(gameId, provId, files[provId]));
              }
              return accum;
            }, []);
            onSetFileOverrides(batched);
            onClose();
          };
          this.searchMethod = ({ node, path, treeIndex, searchQuery }) => {
            return (searchQuery.length > 0) &&
                (node.title.toLowerCase().indexOf(searchQuery.toLowerCase()) !== -1);
          };
          this.searchFinishCallback = (matches) => {
            this.nextState.searchMatches = matches;
          };
          this.setSearch = (search) => {
            this.nextState.searchString = search;
          };
          this.setSearchFocus = (index) => {
            this.nextState.searchIndex = index;
          };
          this.getNodeKey = (node) => node.node.path;
          this.generateNodeProps = (rowInfo) => {
            const { t, mods } = this.props;
            const renderName = (id, clip) => {
              let name = mods[id] !== undefined ? vortex_api_1.util.renderModName(mods[id], { version: true }) : '';
              if (clip && name.length > clip) {
                name = name.substr(0, clip - 3) + '...';
              }
              if (id === rowInfo.node.providers[0]) {
                name += ` (${t('Default')})`;
              }
              return name;
            };
            const key = `provider-select-${rowInfo.path.join('_')}`;
            return {
              buttons: rowInfo.node.isDirectory ? [] : [(React.createElement("a", { key: 'preview', "data-row": rowInfo.path, onClick: this.preview }, t('Preview'))), (React.createElement(react_bootstrap_1.Dropdown, { id: key, key: key, "data-filepath": rowInfo.node.path, onSelect: this.changeProvider, title: renderName(rowInfo.node.selected), pullRight: true },
                                                                                                                                                                                            React.createElement(react_bootstrap_1.Dropdown.Toggle, null,
                                                                                                                                                                                                                React.createElement("span", null, renderName(rowInfo.node.selected, 30))),
                                                                                                                                                                                            React.createElement(react_bootstrap_1.Dropdown.Menu, null, rowInfo.node.providers.map(provider => (React.createElement(react_bootstrap_1.MenuItem, { key: provider, eventKey: provider }, renderName(provider)))))))],
            };
          };
          this.preview = (evt) => {
            const { installPath, mods, pathTool, toRelPath } = this.props;
            const { treeState } = this.state;
            const pathStr = evt.currentTarget.getAttribute('data-row');
            const path = pathStr.split(',');
            const node = this.findByPath(treeState, path);
            if (node !== undefined) {
              const sortIdx = modId => modId === node.selected ? 0
                : modId === node.providers[0] ? 1
                : 2;
              const filePath = path[path.length - 1];
              const options = node.providers.sort((lhs, rhs) => sortIdx(lhs) - sortIdx(rhs))
                .reduce((accum, modId) => {
                  const mod = mods[modId];
                  if (!mod || (mod === null || mod === void 0 ? void 0 : mod.type) === undefined) {
                    return accum;
                  }
                  const relPath = (pathTool.isAbsolute(filePath))
                    ? toRelPath(mod, filePath)
                    : filePath;
                  accum.push({
                    label: vortex_api_1.util.renderModName(mod),
                    filePath: pathTool.join(installPath, mod.installationPath, relPath)
                  });
                  return accum;
                }, []);
              this.context.api.events.emit('preview-files', options);
            }
          };
          this.onChangeTree = (newTreeState) => {
            this.nextState.treeState = newTreeState;
          };
          this.changeProvider = (eventKey, evt) => {
            const { pathTool } = this.props;
            const filePath = evt.currentTarget.parentNode.parentNode.parentNode.getAttribute('data-filepath');
            let cur;
            const searchPos = this.nextState.treeState;
            if ((searchPos.length === 1) && (searchPos[0].title === '.')) {
              cur = searchPos[0];
            }
            const components = filePath.split(pathTool.sep);
            if ((cur === undefined) && (components.length === 1)) {
              components.unshift('.');
            }
            const fileName = pathTool.basename(filePath);
            const sanitizedFileName = vortex_api_1.util.sanitizeFilename(fileName);
            const findFunc = (child) => {
              let _a;
              cur = child;
              const sanitizedTitle = vortex_api_1.util.sanitizeFilename(child.title);
              if (sanitizedFileName === sanitizedTitle && child.path.toLowerCase() === filePath.toLowerCase()) {
                cur.selected = eventKey;
                return true;
              }
              return ((_a = child.children) !== null && _a !== void 0 ? _a : []).find(findFunc);
            };
            this.nextState.treeState.find(findFunc);
            if (cur === undefined) {
              (0, vortex_api_1.log)('error', 'failed to set provider', { filePath, eventKey });
            }
          };
          this.sortedMods = (newProps) => {
            const { gameId, mods, profile } = newProps;
            this.nextState.sorting = true;
            const enabled = Object.keys(mods)
              .filter(key => vortex_api_1.util.getSafe(profile, ['modState', key, 'enabled'], false))
              .map(key => mods[key]);
            return vortex_api_1.util.sortMods(gameId, enabled, this.context.api)
              .map(mod => mod.id)
              .tap(() => this.nextState.sortError = false)
              .catch(() => {
                this.nextState.sortError = true;
                return [];
              })
              .finally(() => {
                this.nextState.sorting = false;
              });
          };
          const modRules = props.localState.modRules.filter(rule => vortex_api_1.util.testModReference(props.mods[props.modId], rule.source));
          this.initState({
            treeState: [],
            sortedMods: [],
            searchString: '',
            searchIndex: 0,
            searchMatches: [],
            modRules,
            hasUnsolved: this.hasUnsolved(props, modRules),
            sorting: false,
            sortError: false,
          });
        }
        componentDidMount() {
          this.sortedMods(this.props)
            .then(sorted => {
              this.nextState.sortedMods = sorted;
            })
            .catch(() => {
              this.nextState.sortedMods = [];
            });
        }
        UNSAFE_componentWillReceiveProps(newProps) {
          if ((newProps.modId !== this.props.modId)
            || (newProps.gameId !== this.props.gameId)
            || (newProps.conflicts !== this.props.conflicts)
            || (newProps.localState.modRules !== this.props.localState.modRules)) {
            this.nextState.treeState = this.toTree(newProps);
            const newModRules = newProps.localState.modRules.filter(rule => vortex_api_1.util.testModReference(newProps.mods[newProps.modId], rule.source));
            this.nextState.modRules = newModRules;
            this.nextState.hasUnsolved = this.hasUnsolved(newProps, newModRules);
          }
          if (newProps.mods !== this.props.mods) {
            this.sortedMods(newProps)
              .then(sorted => {
                this.nextState.sortedMods = sorted;
                this.nextState.treeState = this.toTree(newProps);
              })
              .catch(() => {
                this.nextState.sortedMods = [];
              });
          }
        }
        render() {
          const { t, modId, mods } = this.props;
          const { hasUnsolved, searchString, searchIndex, searchMatches, sorting, sortError, treeState } = this.state;
          const modName = mods[modId] !== undefined
            ? vortex_api_1.util.renderModName(mods[modId])
            : '';
          let content;
          if (hasUnsolved) {
            content = (React.createElement("div", { className: 'file-override-unsolved' },
                                           React.createElement("div", null,
                                                               React.createElement(react_i18next_1.Trans, { i18nKey: 'unsolved-conflicts-first' },
                                                                                   "This mod has unresolved conflicts. Please ",
                                                                                   React.createElement("a", { onClick: this.openConflictEditor }, "create mod rules"),
                                                                                   " to establish a default load order and only use this screen to make exceptions."))));
          }
          else if (sorting) {
            content = (React.createElement("div", { className: 'file-override-sorting' },
                                           React.createElement("div", null,
                                                               React.createElement(vortex_api_1.Spinner, null),
                                                               React.createElement("div", { style: { marginLeft: 8, display: 'inline' } }, t('Sorting mods')))));
          }
          else if (sortError) {
            content = (React.createElement("div", { className: 'file-override-sorting' },
                                           React.createElement("div", null,
                                                               React.createElement(vortex_api_1.Icon, { name: 'feedback-error' }),
                                                               React.createElement("div", { style: { marginLeft: 8, display: 'inline' } }, t('Mods were not sorted. You need to fix that before setting file overrides.')))));
          }
          else {
            const Tree = (__webpack_require__(/*! react-sortable-tree */ "./node_modules/react-sortable-tree/dist/index.esm.js").SortableTreeWithoutDndContext);
            const FileExplorerTheme = __webpack_require__(/*! react-sortable-tree-theme-file-explorer */ "./node_modules/react-sortable-tree-theme-file-explorer/dist/main.js");
            content = (React.createElement(vortex_api_1.DNDContainer, null,
                                           React.createElement("div", { className: 'file-override-container' },
                                                               React.createElement(SearchBox_1.default, { t: t, searchFocusIndex: searchIndex, searchString: searchString, matches: searchMatches, onSetSearch: this.setSearch, onSetSearchFocus: this.setSearchFocus }),
                                                               React.createElement(Tree, { treeData: treeState, onChange: this.onChangeTree, theme: FileExplorerTheme, canDrag: false, getNodeKey: this.getNodeKey, generateNodeProps: this.generateNodeProps, searchMethod: this.searchMethod, searchQuery: searchString, searchFocusOffset: searchIndex, searchFinishCallback: this.searchFinishCallback }),
                                                               React.createElement(vortex_api_1.Usage, { persistent: true, infoId: 'override-editor' },
                                                                                   React.createElement("div", null, t('Use this dialog to select which mod should provide a file.')),
                                                                                   React.createElement("div", null, t('The mod marked as "Default" is the one that will provide the '
                            + 'file based on current mod rules, if you make no change.')),
                                                                                   React.createElement("div", null, t('Please try to minimize the number of overrides you set up here. '
                            + 'Use mod rules to order entire mods.')),
                                                                                   React.createElement("div", null, t('This lists only the files in the selected mod that aren\'t exclusive '
                            + 'to it.'))))));
          }
          return (React.createElement(react_bootstrap_1.Modal, { id: 'file-override-dialog', show: modId !== undefined, onHide: nop },
                                      React.createElement(react_bootstrap_1.Modal.Header, null,
                                                          React.createElement(react_bootstrap_1.Modal.Title, null, modName)),
                                      React.createElement(react_bootstrap_1.Modal.Body, null, content),
                                      React.createElement(react_bootstrap_1.Modal.Footer, null,
                                                          React.createElement(react_bootstrap_1.Button, { onClick: this.close }, t('Cancel')),
                                                          React.createElement(react_bootstrap_1.Button, { disabled: hasUnsolved || sorting || sortError, onClick: this.apply }, t('Save')))));
        }
        findRule(ref, modRules) {
          return modRules.find(rule => vortex_api_1.util.testModReference(ref, rule.reference));
        }
        hasUnsolved(props, modRules) {
          const { conflicts, modId } = props;
          if (modId === undefined) {
            return false;
          }
          return conflicts.find(conflict => {
            const rule = this.findRule(conflict.otherMod, modRules);
            return rule === undefined;
          }) !== undefined;
        }
        findByPath(nodes, path) {
          const temp = nodes.find(tree => tree.path === path[0]);
          if ((path.length === 1) || (temp === undefined)) {
            return temp;
          }
          return this.findByPath(temp.children, path.slice(1));
        }
        toTree(props) {
          const { conflicts, modId, pathTool, discovery } = props;
          if ((discovery === null || discovery === void 0 ? void 0 : discovery.path) === undefined) {
            return [];
          }
          const makeEmpty = (title, filePath, prov) => ({
            title,
            path: filePath,
            children: [],
            providers: prov !== undefined ? [prov] : [],
            selected: '',
            expanded: true,
            isDirectory: prov === undefined,
          });
          const ensure = (ele, name, filePath, prov) => {
            let existing = ele.find(iter => iter.title === name);
            if (existing === undefined) {
              existing = makeEmpty(name, filePath, prov);
              ele.push(existing);
            }
            return existing;
          };
          const result = conflicts.reduce((tree, input) => {
            input.files.forEach(file => {
              let cur = tree;
              pathTool.dirname(pathTool.relative(discovery.path, file)).split(pathTool.sep).forEach((comp, idx, segments) => {
                cur = ensure(cur, comp, segments.slice(0, idx + 1).join(pathTool.sep)).children;
              });
              const fileName = pathTool.basename(file);
              ensure(cur, fileName, file, modId).providers.push(input.otherMod.id);
            });
            return tree;
          }, []);
          this.sortProviders(result, props);
          return result;
        }
        sortProviders(files, props, dirPath = '') {
          const { mods, pathTool } = props;
          const { sortedMods } = this.nextState;
          const sortFunc = (lhs, rhs) => {
            if ((mods[lhs] === undefined) || (mods[rhs] === undefined)) {
              return 0;
            }
            return sortedMods.indexOf(rhs) - sortedMods.indexOf(lhs);
          };
          files.forEach(file => {
            const filePath = pathTool.join(dirPath, file.title);
            file.providers = file.providers
              .filter(modId => mods[modId] !== undefined)
              .sort(sortFunc);
            file.selected = file.providers[0];
            if (pathTool.isAbsolute(file.path)) {
              const overrider = file.providers.find(modId => (mods[modId].fileOverrides || []).indexOf(file.path) === -1);
              if (overrider !== undefined) {
                file.selected = overrider;
              }
            }
            this.sortProviders(file.children, props, filePath);
          });
        }
      }
      const emptyArr = [];
      const emptyObj = {};
      function mapStateToProps(state) {
        const dialog = state.session.dependencies.overrideDialog || emptyObj;
        const discovery = (!!(dialog === null || dialog === void 0 ? void 0 : dialog.gameId)) ? vortex_api_1.selectors.discoveryByGame(state, dialog.gameId) : emptyObj;
        return {
          gameId: dialog.gameId,
          modId: dialog.modId,
          mods: dialog.gameId !== undefined ? state.persistent.mods[dialog.gameId] : emptyObj,
          profile: vortex_api_1.selectors.activeProfile(state),
          installPath: dialog.gameId !== undefined ? vortex_api_1.selectors.installPathForGame(state, dialog.gameId) : undefined,
          discovery,
          conflicts: vortex_api_1.util.getSafe(state, ['session', 'dependencies', 'conflicts', dialog.modId], emptyArr),
        };
      }
      function mapDispatchToProps(dispatch) {
        return {
          onClose: () => dispatch((0, actions_1.setFileOverrideDialog)(undefined, undefined)),
          onConflictDialog: (gameId, modIds, modRules) => dispatch((0, actions_1.setConflictDialog)(gameId, modIds, modRules)),
        };
      }
      exports["default"] = (0, react_i18next_1.withTranslation)(['common', statics_1.NAMESPACE])((0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(OverrideEditor));


/***/ }),

/***/ "./src/views/SearchBox.tsx":
/*!*********************************!*\
  !*** ./src/views/SearchBox.tsx ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __importStar(__webpack_require__(/*! react */ "react"));
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      class SearchBox extends vortex_api_1.ComponentEx {
        constructor(props) {
          super(props);
          this.selectPrevMatch = () => {
            const { onSetSearchFocus, searchFocusIndex } = this.props;
            const { searchFoundCount } = this.state;
            onSetSearchFocus((searchFoundCount + searchFocusIndex - 1) % searchFoundCount);
          };
          this.selectNextMatch = () => {
            const { onSetSearchFocus, searchFocusIndex } = this.props;
            const { searchFoundCount } = this.state;
            onSetSearchFocus((searchFocusIndex + 1) % searchFoundCount);
          };
          this.startSearch = (event) => {
            const { onSetSearch } = this.props;
            onSetSearch(event.target.value);
          };
          this.initState({
            searchFoundCount: 0,
          });
        }
        UNSAFE_componentWillReceiveProps(newProps) {
          if (newProps.matches !== this.props.matches) {
            this.updateMatches(newProps.matches);
          }
        }
        render() {
          const { t, searchFocusIndex, searchString } = this.props;
          const { searchFoundCount } = this.state;
          return (React.createElement("div", { className: 'search-box' },
                                      React.createElement("div", { style: { display: 'inline-block', position: 'relative', height: 30 } },
                                                          React.createElement(react_bootstrap_1.FormControl, { className: 'search-box-input', type: 'text', placeholder: t('Search'), value: searchString || '', onChange: this.startSearch }),
                                                          React.createElement(vortex_api_1.Icon, { className: 'search-icon', name: 'search' }),
                                                          React.createElement("span", { className: 'search-position' }, t('{{ pos }} of {{ total }}', {
                                                            replace: {
                                                              pos: searchFoundCount > 0 ? (searchFocusIndex + 1) : 0,
                                                              total: searchFoundCount || 0,
                                                            },
                                                          }))),
                                      React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed', icon: 'search-up', tooltip: t('Prev'), type: 'button', disabled: !searchFoundCount, onClick: this.selectPrevMatch }),
                                      React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed', icon: 'search-down', tooltip: t('Next'), type: 'button', disabled: !searchFoundCount, onClick: this.selectNextMatch })));
        }
        updateMatches(matches) {
          const { onSetSearchFocus, searchFocusIndex } = this.props;
          if (this.state.searchFoundCount !== matches.length) {
            this.nextState.searchFoundCount = matches.length;
          }
          const newFocusIndex = matches.length > 0 ? searchFocusIndex % matches.length : 0;
          if (searchFocusIndex !== newFocusIndex) {
            onSetSearchFocus(newFocusIndex);
          }
        }
      }
      exports["default"] = SearchBox;


/***/ }),

/***/ "./src/views/Settings.tsx":
/*!********************************!*\
  !*** ./src/views/Settings.tsx ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

      "use strict";

      const __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        let desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      }));
      const __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      const __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null) for (const k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", ({ value: true }));
      const React = __importStar(__webpack_require__(/*! react */ "react"));
      const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
      const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
      const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
      const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
      function Settings(props) {
        const { t } = (0, react_i18next_1.useTranslation)();
        const { onSetModTypeConflicts } = props;
        const connectedProps = (0, react_redux_1.useSelector)(mapStateToProps);
        const modTypeConflictsEnabled = connectedProps.modTypeConflictsEnabled;
        const [modTypeConflicts, setModTypeConflicts] = React.useState(modTypeConflictsEnabled);
        const onToggle = React.useCallback((newVal) => {
          onSetModTypeConflicts(newVal);
        }, [onSetModTypeConflicts, setModTypeConflicts]);
        React.useEffect(() => {
          setModTypeConflicts(modTypeConflictsEnabled);
        }, [modTypeConflictsEnabled]);
        return (React.createElement("form", null,
                                    React.createElement(react_bootstrap_1.FormGroup, { controlId: 'mod-dependency-manager-modtype-conflicts' },
                                                        React.createElement(react_bootstrap_1.ControlLabel, null, t('Cross-ModType Conflicts Detection')),
                                                        (modTypeConflicts) ? (React.createElement(react_bootstrap_1.Alert, { bsStyle: 'warning' }, t('Disabling this feature is not recommended. If you have ModType conflicts present in your mods setup, disabling this '
                + 'will result in the External Changes Dialog being raised before any deployment/purge event and '
                + 'certain files not being deployed/purged correctly '
                + 'until you manually resolve the conflict. Please proceed with caution.'))) : (React.createElement(react_bootstrap_1.Alert, { bsStyle: 'warning' }, t('You have disabled Cross-ModType conflict detection on your system. Any conflicts across modtypes will '
                + 'have to be resolved manually outside of Vortex.'))),
                                                        React.createElement(vortex_api_1.Toggle, { checked: modTypeConflicts, onToggle: onToggle }, t('Enable/Disable Cross-ModType conflict detection (A purge will execute upon change)')))));
      }
      exports["default"] = Settings;
      function mapStateToProps(state) {
        return {
          modTypeConflictsEnabled: vortex_api_1.util.getSafe(state, ['settings', 'workarounds', 'modTypeConflictsEnabled'], true),
        };
      }


/***/ }),

/***/ "../../node_modules/memoize-one/dist/memoize-one.esm.js":
/*!**************************************************************!*\
  !*** ../../node_modules/memoize-one/dist/memoize-one.esm.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
      const safeIsNaN = Number.isNaN ||
    function ponyfill(value) {
      return typeof value === 'number' && value !== value;
    };
      function isEqual(first, second) {
        if (first === second) {
          return true;
        }
        if (safeIsNaN(first) && safeIsNaN(second)) {
          return true;
        }
        return false;
      }
      function areInputsEqual(newInputs, lastInputs) {
        if (newInputs.length !== lastInputs.length) {
          return false;
        }
        for (let i = 0; i < newInputs.length; i++) {
          if (!isEqual(newInputs[i], lastInputs[i])) {
            return false;
          }
        }
        return true;
      }

      function memoizeOne(resultFn, isEqual) {
        if (isEqual === void 0) { isEqual = areInputsEqual; }
        let lastThis;
        let lastArgs = [];
        let lastResult;
        let calledOnce = false;
        function memoized() {
          const newArgs = [];
          for (let _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
          }
          if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
            return lastResult;
          }
          lastResult = resultFn.apply(this, newArgs);
          calledOnce = true;
          lastThis = this;
          lastArgs = newArgs;
          return lastResult;
        }
        return memoized;
      }

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (memoizeOne);


/***/ }),

/***/ "../../node_modules/reselect/es/defaultMemoize.js":
/*!********************************************************!*\
  !*** ../../node_modules/reselect/es/defaultMemoize.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createCacheKeyComparator: () => (/* binding */ createCacheKeyComparator),
/* harmony export */   defaultEqualityCheck: () => (/* binding */ defaultEqualityCheck),
/* harmony export */   defaultMemoize: () => (/* binding */ defaultMemoize)
/* harmony export */ });
// Cache implementation based on Erik Rasmussen's `lru-memoize`:
// https://github.com/erikras/lru-memoize
      const NOT_FOUND = 'NOT_FOUND';

      function createSingletonCache(equals) {
        let entry;
        return {
          get: function get(key) {
            if (entry && equals(entry.key, key)) {
              return entry.value;
            }

            return NOT_FOUND;
          },
          put: function put(key, value) {
            entry = {
              key: key,
              value: value
            };
          },
          getEntries: function getEntries() {
            return entry ? [entry] : [];
          },
          clear: function clear() {
            entry = undefined;
          }
        };
      }

      function createLruCache(maxSize, equals) {
        let entries = [];

        function get(key) {
          const cacheIndex = entries.findIndex(function (entry) {
            return equals(key, entry.key);
          }); // We found a cached entry

          if (cacheIndex > -1) {
            const entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top

            if (cacheIndex > 0) {
              entries.splice(cacheIndex, 1);
              entries.unshift(entry);
            }

            return entry.value;
          } // No entry found in cache, return sentinel


          return NOT_FOUND;
        }

        function put(key, value) {
          if (get(key) === NOT_FOUND) {
      // TODO Is unshift slow?
            entries.unshift({
              key: key,
              value: value
            });

            if (entries.length > maxSize) {
              entries.pop();
            }
          }
        }

        function getEntries() {
          return entries;
        }

        function clear() {
          entries = [];
        }

        return {
          get: get,
          put: put,
          getEntries: getEntries,
          clear: clear
        };
      }

      var defaultEqualityCheck = function defaultEqualityCheck(a, b) {
        return a === b;
      };
      function createCacheKeyComparator(equalityCheck) {
        return function areArgumentsShallowlyEqual(prev, next) {
          if (prev === null || next === null || prev.length !== next.length) {
            return false;
          } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.


          const length = prev.length;

          for (let i = 0; i < length; i++) {
            if (!equalityCheck(prev[i], next[i])) {
              return false;
            }
          }

          return true;
        };
      }
// defaultMemoize now supports a configurable cache size with LRU behavior,
// and optional comparison of the result value with existing values
      function defaultMemoize(func, equalityCheckOrOptions) {
        const providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {
          equalityCheck: equalityCheckOrOptions
        };
        const _providedOptions$equa = providedOptions.equalityCheck,
          equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa,
          _providedOptions$maxS = providedOptions.maxSize,
          maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,
          resultEqualityCheck = providedOptions.resultEqualityCheck;
        const comparator = createCacheKeyComparator(equalityCheck);
        const cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons

        function memoized() {
          let value = cache.get(arguments);

          if (value === NOT_FOUND) {
      // @ts-ignore
            value = func.apply(null, arguments);

            if (resultEqualityCheck) {
              const entries = cache.getEntries();
              const matchingEntry = entries.find(function (entry) {
                return resultEqualityCheck(entry.value, value);
              });

              if (matchingEntry) {
                value = matchingEntry.value;
              }
            }

            cache.put(arguments, value);
          }

          return value;
        }

        memoized.clearCache = function () {
          return cache.clear();
        };

        return memoized;
      }

/***/ }),

/***/ "../../node_modules/reselect/es/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/reselect/es/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSelector: () => (/* binding */ createSelector),
/* harmony export */   createSelectorCreator: () => (/* binding */ createSelectorCreator),
/* harmony export */   createStructuredSelector: () => (/* binding */ createStructuredSelector),
/* harmony export */   defaultEqualityCheck: () => (/* reexport safe */ _defaultMemoize__WEBPACK_IMPORTED_MODULE_0__.defaultEqualityCheck),
/* harmony export */   defaultMemoize: () => (/* reexport safe */ _defaultMemoize__WEBPACK_IMPORTED_MODULE_0__.defaultMemoize)
/* harmony export */ });
/* harmony import */ var _defaultMemoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultMemoize */ "../../node_modules/reselect/es/defaultMemoize.js");



      function getDependencies(funcs) {
        const dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

        if (!dependencies.every(function (dep) {
          return typeof dep === 'function';
        })) {
          const dependencyTypes = dependencies.map(function (dep) {
            return typeof dep === 'function' ? "function " + (dep.name || 'unnamed') + "()" : typeof dep;
          }).join(', ');
          throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + dependencyTypes + "]");
        }

        return dependencies;
      }

      function createSelectorCreator(memoize) {
        for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          memoizeOptionsFromArgs[_key - 1] = arguments[_key];
        }

        const createSelector = function createSelector() {
          for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            funcs[_key2] = arguments[_key2];
          }

          let _recomputations = 0;

          let _lastResult; // Due to the intricacies of rest params, we can't do an optional arg after `...funcs`.
    // So, start by declaring the default value here.
    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)


          let directlyPassedOptions = {
            memoizeOptions: undefined
          }; // Normally, the result func or "output selector" is the last arg

          let resultFunc = funcs.pop(); // If the result func is actually an _object_, assume it's our options object

          if (typeof resultFunc === 'object') {
            directlyPassedOptions = resultFunc; // and pop the real result func off

            resultFunc = funcs.pop();
          }

          if (typeof resultFunc !== 'function') {
            throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof resultFunc + "]");
          } // Determine which set of options we're using. Prefer options passed directly,
    // but fall back to options given to createSelectorCreator.


          const _directlyPassedOption = directlyPassedOptions,
            _directlyPassedOption2 = _directlyPassedOption.memoizeOptions,
            memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2; // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer
    // is an array. In most libs I've looked at, it's an equality function or options object.
    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full
    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so
    // we wrap it in an array so we can apply it.

          const finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];
          const dependencies = getDependencies(funcs);
          const memoizedResultFunc = memoize.apply(void 0, [function recomputationWrapper() {
            _recomputations++; // apply arguments instead of spreading for performance.

            return resultFunc.apply(null, arguments);
          }].concat(finalMemoizeOptions)); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.

          const selector = memoize(function dependenciesChecker() {
            const params = [];
            const length = dependencies.length;

            for (let i = 0; i < length; i++) {
        // apply arguments instead of spreading and mutate a local list of params for performance.
        // @ts-ignore
              params.push(dependencies[i].apply(null, arguments));
            } // apply arguments instead of spreading for performance.


            _lastResult = memoizedResultFunc.apply(null, params);
            return _lastResult;
          });
          Object.assign(selector, {
            resultFunc: resultFunc,
            memoizedResultFunc: memoizedResultFunc,
            dependencies: dependencies,
            lastResult: function lastResult() {
              return _lastResult;
            },
            recomputations: function recomputations() {
              return _recomputations;
            },
            resetRecomputations: function resetRecomputations() {
              return _recomputations = 0;
            }
          });
          return selector;
        }; // @ts-ignore


        return createSelector;
      }
      var createSelector = /* #__PURE__ */createSelectorCreator(_defaultMemoize__WEBPACK_IMPORTED_MODULE_0__.defaultMemoize);
// Manual definition of state and output arguments
      var createStructuredSelector = function createStructuredSelector(selectors, selectorCreator) {
        if (selectorCreator === void 0) {
          selectorCreator = createSelector;
        }

        if (typeof selectors !== 'object') {
          throw new Error('createStructuredSelector expects first argument to be an object ' + ("where each property is a selector, instead received a " + typeof selectors));
        }

        const objectKeys = Object.keys(selectors);
        const resultSelector = selectorCreator( // @ts-ignore
          objectKeys.map(function (key) {
            return selectors[key];
          }), function () {
            for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              values[_key3] = arguments[_key3];
            }

            return values.reduce(function (composition, value, index) {
              composition[objectKeys[index]] = value;
              return composition;
            }, {});
          });
        return resultSelector;
      };

/***/ }),

/***/ "../../node_modules/shortid/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/shortid/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";

      module.exports = __webpack_require__(/*! ./lib/index */ "../../node_modules/shortid/lib/index.js");


/***/ }),

/***/ "../../node_modules/shortid/lib/alphabet.js":
/*!**************************************************!*\
  !*** ../../node_modules/shortid/lib/alphabet.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const randomFromSeed = __webpack_require__(/*! ./random/random-from-seed */ "../../node_modules/shortid/lib/random/random-from-seed.js");

      const ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
      let alphabet;
      let previousSeed;

      let shuffled;

      function reset() {
        shuffled = false;
      }

      function setCharacters(_alphabet_) {
        if (!_alphabet_) {
          if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
          }
          return;
        }

        if (_alphabet_ === alphabet) {
          return;
        }

        if (_alphabet_.length !== ORIGINAL.length) {
          throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
        }

        const unique = _alphabet_.split('').filter(function(item, ind, arr){
          return ind !== arr.lastIndexOf(item);
        });

        if (unique.length) {
          throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
        }

        alphabet = _alphabet_;
        reset();
      }

      function characters(_alphabet_) {
        setCharacters(_alphabet_);
        return alphabet;
      }

      function setSeed(seed) {
        randomFromSeed.seed(seed);
        if (previousSeed !== seed) {
          reset();
          previousSeed = seed;
        }
      }

      function shuffle() {
        if (!alphabet) {
          setCharacters(ORIGINAL);
        }

        const sourceArray = alphabet.split('');
        const targetArray = [];
        let r = randomFromSeed.nextValue();
        let characterIndex;

        while (sourceArray.length > 0) {
          r = randomFromSeed.nextValue();
          characterIndex = Math.floor(r * sourceArray.length);
          targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
        }
        return targetArray.join('');
      }

      function getShuffled() {
        if (shuffled) {
          return shuffled;
        }
        shuffled = shuffle();
        return shuffled;
      }

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
      function lookup(index) {
        const alphabetShuffled = getShuffled();
        return alphabetShuffled[index];
      }

      module.exports = {
        characters: characters,
        seed: setSeed,
        lookup: lookup,
        shuffled: getShuffled
      };


/***/ }),

/***/ "../../node_modules/shortid/lib/build.js":
/*!***********************************************!*\
  !*** ../../node_modules/shortid/lib/build.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const encode = __webpack_require__(/*! ./encode */ "../../node_modules/shortid/lib/encode.js");
      const alphabet = __webpack_require__(/*! ./alphabet */ "../../node_modules/shortid/lib/alphabet.js");

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
      const REDUCE_TIME = 1459707606518;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
      const version = 6;

// Counter is used when shortid is called multiple times in one second.
      let counter;

// Remember the last time shortid was called in case counter is needed.
      let previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
      function build(clusterWorkerId) {

        let str = '';

        const seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

        if (seconds === previousSeconds) {
          counter++;
        } else {
          counter = 0;
          previousSeconds = seconds;
        }

        str = str + encode(alphabet.lookup, version);
        str = str + encode(alphabet.lookup, clusterWorkerId);
        if (counter > 0) {
          str = str + encode(alphabet.lookup, counter);
        }
        str = str + encode(alphabet.lookup, seconds);

        return str;
      }

      module.exports = build;


/***/ }),

/***/ "../../node_modules/shortid/lib/decode.js":
/*!************************************************!*\
  !*** ../../node_modules/shortid/lib/decode.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";

      const alphabet = __webpack_require__(/*! ./alphabet */ "../../node_modules/shortid/lib/alphabet.js");

/**
 * Decode the id to get the version and worker
 * Mainly for debugging and testing.
 * @param id - the shortid-generated id.
 */
      function decode(id) {
        const characters = alphabet.shuffled();
        return {
          version: characters.indexOf(id.substr(0, 1)) & 0x0f,
          worker: characters.indexOf(id.substr(1, 1)) & 0x0f
        };
      }

      module.exports = decode;


/***/ }),

/***/ "../../node_modules/shortid/lib/encode.js":
/*!************************************************!*\
  !*** ../../node_modules/shortid/lib/encode.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const randomByte = __webpack_require__(/*! ./random/random-byte */ "../../node_modules/shortid/lib/random/random-byte-browser.js");

      function encode(lookup, number) {
        let loopCounter = 0;
        let done;

        let str = '';

        while (!done) {
          str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByte() );
          done = number < (Math.pow(16, loopCounter + 1 ) );
          loopCounter++;
        }
        return str;
      }

      module.exports = encode;


/***/ }),

/***/ "../../node_modules/shortid/lib/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/shortid/lib/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";


      const alphabet = __webpack_require__(/*! ./alphabet */ "../../node_modules/shortid/lib/alphabet.js");
      const encode = __webpack_require__(/*! ./encode */ "../../node_modules/shortid/lib/encode.js");
      const decode = __webpack_require__(/*! ./decode */ "../../node_modules/shortid/lib/decode.js");
      const build = __webpack_require__(/*! ./build */ "../../node_modules/shortid/lib/build.js");
      const isValid = __webpack_require__(/*! ./is-valid */ "../../node_modules/shortid/lib/is-valid.js");

// if you are using cluster or multiple servers use this to make each instance
// has a unique value for worker
// Note: I don't know if this is automatically set when using third
// party cluster solutions such as pm2.
      let clusterWorkerId = __webpack_require__(/*! ./util/cluster-worker-id */ "../../node_modules/shortid/lib/util/cluster-worker-id-browser.js") || 0;

/**
 * Set the seed.
 * Highly recommended if you don't want people to try to figure out your id schema.
 * exposed as shortid.seed(int)
 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
 */
      function seed(seedValue) {
        alphabet.seed(seedValue);
        return module.exports;
      }

/**
 * Set the cluster worker or machine id
 * exposed as shortid.worker(int)
 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
 * returns shortid module so it can be chained.
 */
      function worker(workerId) {
        clusterWorkerId = workerId;
        return module.exports;
      }

/**
 *
 * sets new characters to use in the alphabet
 * returns the shuffled alphabet
 */
      function characters(newCharacters) {
        if (newCharacters !== undefined) {
          alphabet.characters(newCharacters);
        }

        return alphabet.shuffled();
      }

/**
 * Generate unique id
 * Returns string id
 */
      function generate() {
        return build(clusterWorkerId);
      }

// Export all other functions as properties of the generate function
      module.exports = generate;
      module.exports.generate = generate;
      module.exports.seed = seed;
      module.exports.worker = worker;
      module.exports.characters = characters;
      module.exports.decode = decode;
      module.exports.isValid = isValid;


/***/ }),

/***/ "../../node_modules/shortid/lib/is-valid.js":
/*!**************************************************!*\
  !*** ../../node_modules/shortid/lib/is-valid.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

      "use strict";

      const alphabet = __webpack_require__(/*! ./alphabet */ "../../node_modules/shortid/lib/alphabet.js");

      function isShortId(id) {
        if (!id || typeof id !== 'string' || id.length < 6 ) {
          return false;
        }

        const characters = alphabet.characters();
        const len = id.length;
        for(let i = 0; i < len;i++) {
          if (characters.indexOf(id[i]) === -1) {
            return false;
          }
        }
        return true;
      }

      module.exports = isShortId;


/***/ }),

/***/ "../../node_modules/shortid/lib/random/random-byte-browser.js":
/*!********************************************************************!*\
  !*** ../../node_modules/shortid/lib/random/random-byte-browser.js ***!
  \********************************************************************/
/***/ ((module) => {

      "use strict";


      const crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

      function randomByte() {
        if (!crypto || !crypto.getRandomValues) {
          return Math.floor(Math.random() * 256) & 0x30;
        }
        const dest = new Uint8Array(1);
        crypto.getRandomValues(dest);
        return dest[0] & 0x30;
      }

      module.exports = randomByte;


/***/ }),

/***/ "../../node_modules/shortid/lib/random/random-from-seed.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/shortid/lib/random/random-from-seed.js ***!
  \*****************************************************************/
/***/ ((module) => {

      "use strict";


// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

      let seed = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
      function getNextValue() {
        seed = (seed * 9301 + 49297) % 233280;
        return seed/(233280.0);
      }

      function setSeed(_seed_) {
        seed = _seed_;
      }

      module.exports = {
        nextValue: getNextValue,
        seed: setSeed
      };


/***/ }),

/***/ "../../node_modules/shortid/lib/util/cluster-worker-id-browser.js":
/*!************************************************************************!*\
  !*** ../../node_modules/shortid/lib/util/cluster-worker-id-browser.js ***!
  \************************************************************************/
/***/ ((module) => {

      "use strict";


      module.exports = 0;


/***/ }),

/***/ "bluebird":
/*!***************************!*\
  !*** external "bluebird" ***!
  \***************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("bluebird");

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("lodash");

/***/ }),

/***/ "minimatch":
/*!****************************!*\
  !*** external "minimatch" ***!
  \****************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("minimatch");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

      "use strict";
      module.exports = require("path");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react");

/***/ }),

/***/ "react-bootstrap":
/*!**********************************!*\
  !*** external "react-bootstrap" ***!
  \**********************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react-bootstrap");

/***/ }),

/***/ "react-dnd":
/*!****************************!*\
  !*** external "react-dnd" ***!
  \****************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react-dnd");

/***/ }),

/***/ "react-dnd-html5-backend":
/*!******************************************!*\
  !*** external "react-dnd-html5-backend" ***!
  \******************************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react-dnd-html5-backend");

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react-dom");

/***/ }),

/***/ "react-i18next":
/*!********************************!*\
  !*** external "react-i18next" ***!
  \********************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react-i18next");

/***/ }),

/***/ "react-redux":
/*!******************************!*\
  !*** external "react-redux" ***!
  \******************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react-redux");

/***/ }),

/***/ "react-select":
/*!*******************************!*\
  !*** external "react-select" ***!
  \*******************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("react-select");

/***/ }),

/***/ "redux-act":
/*!****************************!*\
  !*** external "redux-act" ***!
  \****************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("redux-act");

/***/ }),

/***/ "semver":
/*!*************************!*\
  !*** external "semver" ***!
  \*************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("semver");

/***/ }),

/***/ "turbowalk":
/*!****************************!*\
  !*** external "turbowalk" ***!
  \****************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("turbowalk");

/***/ }),

/***/ "vortex-api":
/*!*****************************!*\
  !*** external "vortex-api" ***!
  \*****************************/
/***/ ((module) => {

      "use strict";
      module.exports = require("vortex-api");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	const __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		const cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		const module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			const getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(const key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	const __webpack_exports__ = __webpack_require__("./src/index.tsx");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=bundledPlugins/mod-dependency-manager/mod-dependency-manager.js.map