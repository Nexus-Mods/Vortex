{"version":3,"file":"index.js","mappings":";;;;;;;;;;AAAa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,mBAAO,CAAC,qDAAoB;AAClD,mCAAmC,mBAAO,CAAC,0BAAU;AACrD,0BAA0B,mBAAO,CAAC,kBAAM;AACxC,qBAAqB,mBAAO,CAAC,8BAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,qBAAqB;AACtF,gEAAgE,kBAAkB;AAClF;AACA;AACA;AACA;AACA;AACA,uFAAuF,kBAAkB;AACzG,uFAAuF,kBAAkB;AACzG;AACA;AACA,SAAS;AACT;AACA,mEAAmE,kBAAkB;AACrF,4FAA4F,kBAAkB;AAC9G,yBAAyB,gBAAgB;AACzC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA,wFAAwF,oBAAoB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D,6CAA6C,gBAAgB;AAC7D,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA,wFAAwF,oBAAoB;AAC5G;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,kGAAkG,4BAA4B;AAC9H,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,kBAAe;;;;;;;;;;;ACtNF;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,mBAAmB,GAAG,yBAAyB,GAAG,mBAAmB,GAAG,qBAAqB,GAAG,uBAAuB;AAC5I,0BAA0B,mBAAO,CAAC,kBAAM;AACxC,qBAAqB,mBAAO,CAAC,8BAAY;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,cAAc,0CAA0C;AACxD,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,cAAc,2CAA2C;AACzD,KAAK;AACL;AACA;AACA;AACA,cAAc,4CAA4C;AAC1D,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,cAAc,2CAA2C;AACzD,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,0CAA0C;AAC5D,SAAS;AACT,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAmE;AAChG;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,kBAAkB;;;;;;;;;;;AC/JlB;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://local-gamesettings/./src/index.ts","webpack://local-gamesettings/./src/util/gameSupport.ts","webpack://local-gamesettings/external commonjs2 \"bluebird\"","webpack://local-gamesettings/external commonjs2 \"path\"","webpack://local-gamesettings/external commonjs2 \"vortex-api\"","webpack://local-gamesettings/webpack/bootstrap","webpack://local-gamesettings/webpack/before-startup","webpack://local-gamesettings/webpack/startup","webpack://local-gamesettings/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst gameSupport_1 = require(\"./util/gameSupport\");\nconst bluebird_1 = __importDefault(require(\"bluebird\"));\nconst path = __importStar(require(\"path\"));\nconst vortex_api_1 = require(\"vortex-api\");\nfunction copyGameSettings(sourcePath, destinationPath, files, copyType) {\n    return bluebird_1.default.map(files, gameSetting => {\n        let source = path.join(sourcePath, gameSetting.name);\n        let destination = path.join(destinationPath, path.basename(gameSetting.name));\n        const destinationOrig = destination;\n        if (copyType.startsWith('Glo')) {\n            source += '.base';\n        }\n        else if (copyType.endsWith('Glo')) {\n            destination += '.base';\n        }\n        (0, vortex_api_1.log)('debug', 'copying profile inis', { source, destination });\n        return vortex_api_1.fs.copyAsync(source, destination, { noSelfCopy: true })\n            .catch(err => {\n            if (gameSetting.optional) {\n                return bluebird_1.default.resolve();\n            }\n            switch (copyType) {\n                case 'BacGlo': return vortex_api_1.fs.copyAsync(destination, source, { noSelfCopy: true });\n                case 'ProGlo': return vortex_api_1.fs.copyAsync(destination, source, { noSelfCopy: true });\n                default: return bluebird_1.default.reject(err);\n            }\n        })\n            .then(() => copyType.endsWith('Glo')\n            ? vortex_api_1.fs.copyAsync(source, destinationOrig, { noSelfCopy: true })\n                .then(() => vortex_api_1.fs.copyAsync(source, destinationOrig + '.baked', { noSelfCopy: true }))\n                .catch({ code: 'ENOENT' }, err => gameSetting.optional ? bluebird_1.default.resolve() : bluebird_1.default.reject(err))\n            : bluebird_1.default.resolve());\n    })\n        .then(() => undefined);\n}\nfunction checkGlobalFiles(oldProfile, newProfile) {\n    let fileList = [];\n    if ((oldProfile !== undefined) && (0, gameSupport_1.gameSupported)(oldProfile.gameId)) {\n        fileList = fileList.concat((0, gameSupport_1.gameSettingsFiles)(oldProfile.gameId, (0, gameSupport_1.mygamesPath)(oldProfile.gameId)));\n    }\n    if ((newProfile !== undefined) && (0, gameSupport_1.gameSupported)(newProfile.gameId)) {\n        fileList = fileList.concat((0, gameSupport_1.gameSettingsFiles)(newProfile.gameId, (0, gameSupport_1.mygamesPath)(newProfile.gameId)));\n    }\n    fileList = vortex_api_1.util.unique(fileList, item => item.name);\n    return bluebird_1.default.filter(fileList, file => file.optional\n        ? bluebird_1.default.resolve(false)\n        : vortex_api_1.fs.statAsync(file.name).then(() => false).catch(() => true))\n        .then((missingFiles) => {\n        if (missingFiles.length > 0) {\n            return bluebird_1.default.resolve(missingFiles);\n        }\n        else {\n            return bluebird_1.default.resolve(null);\n        }\n    });\n}\nfunction updateLocalGameSettings(featureId, oldProfile, newProfile) {\n    let copyFiles = bluebird_1.default.resolve();\n    if (!!oldProfile\n        && (oldProfile.features !== undefined)\n        && oldProfile.features[featureId]\n        && (0, gameSupport_1.gameSupported)(oldProfile.gameId)) {\n        const myGames = (0, gameSupport_1.mygamesPath)(oldProfile.gameId);\n        const gameSettings = (0, gameSupport_1.gameSettingsFiles)(oldProfile.gameId, null);\n        copyFiles = copyFiles\n            .then(() => (oldProfile.pendingRemove === true)\n            ? bluebird_1.default.resolve()\n            : copyGameSettings(myGames, (0, gameSupport_1.profilePath)(oldProfile), gameSettings, 'GloPro'))\n            .then(() => copyGameSettings((0, gameSupport_1.backupPath)(oldProfile), myGames, gameSettings, 'BacGlo'));\n    }\n    if (!!newProfile\n        && (newProfile.features !== undefined)\n        && (newProfile.features[featureId])\n        && (0, gameSupport_1.gameSupported)(newProfile.gameId)) {\n        const myGames = (0, gameSupport_1.mygamesPath)(newProfile.gameId);\n        const gameSettings = (0, gameSupport_1.gameSettingsFiles)(newProfile.gameId, null);\n        copyFiles = copyFiles\n            .then(() => copyGameSettings(myGames, (0, gameSupport_1.backupPath)(newProfile), gameSettings, 'GloBac'))\n            .then(() => copyGameSettings((0, gameSupport_1.profilePath)(newProfile), myGames, gameSettings, 'ProGlo'));\n    }\n    return bluebird_1.default.resolve(copyFiles);\n}\nfunction onSwitchGameProfile(store, oldProfile, newProfile) {\n    return checkGlobalFiles(oldProfile, newProfile)\n        .then(missingFiles => {\n        if ((missingFiles !== undefined) && (missingFiles !== null)) {\n            const fileList = missingFiles.map(fileName => `\"${fileName.name}\"`).join('\\n');\n            vortex_api_1.util.showError(store.dispatch, 'An error occurred activating profile', 'Files are missing or not writeable:\\n' + fileList + '\\n\\n' +\n                'Some games need to be run at least once before they can be modded.', { allowReport: false });\n            return false;\n        }\n        return updateLocalGameSettings('local_game_settings', oldProfile, newProfile)\n            .then(() => true)\n            .catch(vortex_api_1.util.UserCanceled, err => {\n            (0, vortex_api_1.log)('info', 'User canceled game settings update', err);\n            return false;\n        })\n            .catch((err) => {\n            vortex_api_1.util.showError(store.dispatch, 'An error occurred applying game settings', {\n                error: err,\n                'Old Game': (oldProfile || { gameId: 'none' }).gameId,\n                'New Game': (newProfile || { gameId: 'none' }).gameId,\n            });\n            return false;\n        });\n    });\n}\nfunction onDeselectGameProfile(store, profile) {\n    if (!profile || !(0, gameSupport_1.gameSupported)(profile.gameId)) {\n        return bluebird_1.default.resolve(true);\n    }\n    return checkGlobalFiles(undefined, profile)\n        .then(missingFiles => {\n        if ((missingFiles !== undefined) && (missingFiles !== null)) {\n            const fileList = missingFiles.map(fileName => `\"${fileName.name}\"`).join('\\n');\n            vortex_api_1.util.showError(store.dispatch, 'An error occurred activating profile', 'Files are missing or not writeable:\\n' + fileList + '\\n\\n' +\n                'Some games need to be run at least once before they can be modded.', { allowReport: false });\n            return false;\n        }\n    })\n        .then(() => {\n        const myGames = (0, gameSupport_1.mygamesPath)(profile.gameId);\n        const gameSettings = (0, gameSupport_1.gameSettingsFiles)(profile.gameId, null);\n        return copyGameSettings(myGames, (0, gameSupport_1.profilePath)(profile), gameSettings, 'GloPro')\n            .then(() => true);\n    });\n}\nfunction bakeSettings(api, profile) {\n    if (profile === undefined) {\n        return bluebird_1.default.resolve();\n    }\n    const state = api.store.getState();\n    const gameMods = state.persistent.mods[profile.gameId] || [];\n    const mods = Object.keys(gameMods)\n        .filter(key => vortex_api_1.util.getSafe(profile, ['modState', key, 'enabled'], false))\n        .map(key => gameMods[key]);\n    return vortex_api_1.util.sortMods(profile.gameId, mods, api)\n        .then(sortedMods => api.emitAndAwait('bake-settings', profile.gameId, sortedMods, profile));\n}\nfunction init(context) {\n    (0, gameSupport_1.initGameSupport)(context.api);\n    context.registerProfileFeature('local_game_settings', 'boolean', 'settings', 'Game Settings', 'This profile has its own game settings', () => (0, gameSupport_1.gameSupported)(vortex_api_1.selectors.activeGameId(context.api.store.getState())));\n    context.once(() => {\n        const store = context.api.store;\n        context.api.events.on('profile-will-change', (nextProfileId, enqueue) => {\n            const state = store.getState();\n            const oldProfileId = vortex_api_1.util.getSafe(state, ['settings', 'profiles', 'activeProfileId'], undefined);\n            const oldProfile = state.persistent.profiles[oldProfileId];\n            const newProfile = state.persistent.profiles[nextProfileId];\n            const oldGameId = vortex_api_1.util.getSafe(oldProfile, ['gameId'], undefined);\n            const newGameId = vortex_api_1.util.getSafe(newProfile, ['gameId'], undefined);\n            if (oldGameId === newGameId) {\n                enqueue(() => {\n                    return bakeSettings(context.api, oldProfile)\n                        .then(() => onSwitchGameProfile(store, oldProfile, newProfile)\n                        .then(() => bakeSettings(context.api, newProfile))\n                        .then(() => null));\n                });\n            }\n            else {\n                const lastActiveProfileId = newProfile !== undefined\n                    ? vortex_api_1.selectors.lastActiveProfileForGame(state, newProfile.gameId)\n                    : undefined;\n                const lastActiveProfile = newProfile !== undefined\n                    ? state.persistent.profiles[lastActiveProfileId]\n                    : undefined;\n                enqueue(() => bakeSettings(context.api, oldProfile)\n                    .then(() => onDeselectGameProfile(store, oldProfile))\n                    .tap(() => bakeSettings(context.api, lastActiveProfile))\n                    .then((success) => success && (newProfile !== undefined)\n                    ? onSwitchGameProfile(store, lastActiveProfile, newProfile)\n                    : bluebird_1.default.resolve(success))\n                    .then(() => bakeSettings(context.api, newProfile))\n                    .catch(vortex_api_1.util.CycleError, err => {\n                    (0, vortex_api_1.log)('warn', 'settings couldn\\'t be baked because mod rules contain cycles', err);\n                })\n                    .catch(err => {\n                    const usercanceled = (err instanceof vortex_api_1.util.UserCanceled);\n                    context.api.showErrorNotification('failed to swap game settings file', err, { allowReport: !usercanceled });\n                })\n                    .then(() => null));\n            }\n        });\n    });\n    return true;\n}\nexports.default = init;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.backupPath = exports.profilePath = exports.gameSettingsFiles = exports.mygamesPath = exports.gameSupported = exports.initGameSupport = void 0;\nconst path = __importStar(require(\"path\"));\nconst vortex_api_1 = require(\"vortex-api\");\nconst gameSupport = vortex_api_1.util.makeOverlayableDictionary({\n    skyrim: {\n        mygamesPath: 'skyrim',\n        gameSettingsFiles: ['Skyrim.ini', 'SkyrimPrefs.ini'],\n    },\n    enderal: {\n        mygamesPath: 'Enderal',\n        gameSettingsFiles: ['Enderal.ini', 'EnderalPrefs.ini'],\n    },\n    skyrimse: {\n        mygamesPath: 'Skyrim Special Edition',\n        gameSettingsFiles: ['Skyrim.ini', 'SkyrimPrefs.ini',\n            { name: 'SkyrimCustom.ini', optional: true }],\n    },\n    enderalspecialedition: {\n        mygamesPath: 'Enderal Special Edition',\n        gameSettingsFiles: ['Enderal.ini', 'EnderalPrefs.ini'],\n    },\n    skyrimvr: {\n        mygamesPath: 'Skyrim VR',\n        gameSettingsFiles: ['Skyrim.ini', 'SkyrimVR.ini', 'SkyrimPrefs.ini'],\n    },\n    fallout3: {\n        mygamesPath: 'Fallout3',\n        gameSettingsFiles: ['Fallout.ini', 'FalloutPrefs.ini',\n            { name: 'FalloutCustom.ini', optional: true }],\n    },\n    fallout4: {\n        mygamesPath: 'Fallout4',\n        gameSettingsFiles: ['Fallout4.ini', 'Fallout4Prefs.ini',\n            { name: 'Fallout4Custom.ini', optional: true }],\n    },\n    fallout4vr: {\n        mygamesPath: 'Fallout4VR',\n        gameSettingsFiles: ['Fallout4Custom.ini', 'Fallout4Prefs.ini'],\n    },\n    starfield: {\n        mygamesPath: 'Starfield',\n        gameSettingsFiles: ['StarfieldCustom.ini', 'StarfieldPrefs.ini'],\n    },\n    falloutnv: {\n        mygamesPath: 'FalloutNV',\n        gameSettingsFiles: ['Fallout.ini', 'FalloutPrefs.ini',\n            { name: 'FalloutCustom.ini', optional: true }],\n    },\n    oblivion: {\n        mygamesPath: 'Oblivion',\n        gameSettingsFiles: ['Oblivion.ini'],\n    },\n    oblivionremastered: {\n        mygamesPath: path.join('Oblivion Remastered', 'Saved', 'Config', 'Windows'),\n        gameSettingsFiles: ['Altar.ini'],\n    },\n}, {\n    xbox: {\n        skyrimse: {\n            mygamesPath: 'Skyrim Special Edition MS',\n        },\n        fallout4: {\n            mygamesPath: 'Fallout4 MS',\n        },\n    },\n    gog: {\n        skyrimse: {\n            mygamesPath: 'Skyrim Special Edition GOG',\n        },\n        enderalspecialedition: {\n            mygamesPath: 'Enderal Special Edition GOG',\n        },\n    },\n    epic: {\n        skyrimse: {\n            mygamesPath: 'Skyrim Special Edition EPIC',\n        },\n        fallout4: {\n            mygamesPath: 'Fallout4 EPIC',\n        },\n    },\n    enderalseOverlay: {\n        enderalspecialedition: {\n            mygamesPath: 'Skyrim Special Edition',\n            gameSettingsFiles: ['Skyrim.ini', 'SkyrimPrefs.ini',\n                { name: 'SkyrimCustom.ini', optional: true }],\n        },\n    },\n}, (gameId) => {\n    const discovery = discoveryForGame(gameId);\n    if (((discovery === null || discovery === void 0 ? void 0 : discovery.path) !== undefined)\n        && (gameId === 'enderalspecialedition')\n        && discovery.path.includes('skyrim')) {\n        return 'enderalseOverlay';\n    }\n    else {\n        return discovery === null || discovery === void 0 ? void 0 : discovery.store;\n    }\n});\nlet discoveryForGame = () => undefined;\nfunction initGameSupport(api) {\n    discoveryForGame = (gameId) => vortex_api_1.selectors.discoveryByGame(api.store.getState(), gameId);\n}\nexports.initGameSupport = initGameSupport;\nfunction gameSupported(gameMode) {\n    return gameSupport.has(gameMode);\n}\nexports.gameSupported = gameSupported;\nfunction mygamesPath(gameMode) {\n    return path.join(vortex_api_1.util.getVortexPath('documents'), 'My Games', gameSupport.get(gameMode, 'mygamesPath'));\n}\nexports.mygamesPath = mygamesPath;\nfunction gameSettingsFiles(gameMode, customPath) {\n    const fileNames = gameSupport.get(gameMode, 'gameSettingsFiles');\n    const mapFile = (input) => typeof (input) === 'string'\n        ? { name: input, optional: false }\n        : input;\n    if (customPath === null) {\n        return fileNames.map(mapFile);\n    }\n    else {\n        return fileNames\n            .map(mapFile)\n            .map(input => ({ name: path.join(customPath, input.name), optional: input.optional }));\n    }\n}\nexports.gameSettingsFiles = gameSettingsFiles;\nfunction profilePath(profile) {\n    return path.join(vortex_api_1.util.getVortexPath('userData'), profile.gameId, 'profiles', profile.id);\n}\nexports.profilePath = profilePath;\nfunction backupPath(profile) {\n    return path.join(vortex_api_1.util.getVortexPath('userData'), profile.gameId);\n}\nexports.backupPath = backupPath;\n","module.exports = require(\"bluebird\");","module.exports = require(\"path\");","module.exports = require(\"vortex-api\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":[],"sourceRoot":""}