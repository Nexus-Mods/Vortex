/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/bail/index.js":
/*!************************************!*\
  !*** ./node_modules/bail/index.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bail: () => (/* binding */ bail)
/* harmony export */ });
/**
 * Throw a given error.
 *
 * @param {Error|null|undefined} [error]
 *   Maybe error.
 * @returns {asserts error is null|undefined}
 */
function bail(error) {
  if (error) {
    throw error
  }
}


/***/ }),

/***/ "./node_modules/bsdiff-node/index.js":
/*!*******************************************!*\
  !*** ./node_modules/bsdiff-node/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(/*! fs */ "fs");
const { promisify } = __webpack_require__(/*! util */ "util");
const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);

function nodeify(promise, cb) {
  if (typeof cb === "function") {
    promise.then(() => cb()).catch(cb);
    return;
  }
  return promise;
}

function diff(_srcFile, dstFile, patchFile, cb) {
  const work = (async () => {
    const data = await readFile(dstFile);
    await writeFile(patchFile, data);
  })();
  return nodeify(work, cb);
}

function patch(_srcFile, patchFile, dstFile, cb) {
  const work = (async () => {
    const data = await readFile(patchFile);
    await writeFile(dstFile, data);
  })();
  return nodeify(work, cb);
}

module.exports = { diff, patch };


/***/ }),

/***/ "./node_modules/comma-separated-tokens/index.js":
/*!******************************************************!*\
  !*** ./node_modules/comma-separated-tokens/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   stringify: () => (/* binding */ stringify)
/* harmony export */ });
/**
 * @typedef Options
 *   Configuration for `stringify`.
 * @property {boolean} [padLeft=true]
 *   Whether to pad a space before a token.
 * @property {boolean} [padRight=false]
 *   Whether to pad a space after a token.
 */

/**
 * @typedef {Options} StringifyOptions
 *   Please use `StringifyOptions` instead.
 */

/**
 * Parse comma-separated tokens to an array.
 *
 * @param {string} value
 *   Comma-separated tokens.
 * @returns {Array<string>}
 *   List of tokens.
 */
function parse(value) {
  /** @type {Array<string>} */
  const tokens = []
  const input = String(value || '')
  let index = input.indexOf(',')
  let start = 0
  /** @type {boolean} */
  let end = false

  while (!end) {
    if (index === -1) {
      index = input.length
      end = true
    }

    const token = input.slice(start, index).trim()

    if (token || !end) {
      tokens.push(token)
    }

    start = index + 1
    index = input.indexOf(',', start)
  }

  return tokens
}

/**
 * Serialize an array of strings or numbers to comma-separated tokens.
 *
 * @param {Array<string|number>} values
 *   List of tokens.
 * @param {Options} [options]
 *   Configuration for `stringify` (optional).
 * @returns {string}
 *   Comma-separated tokens.
 */
function stringify(values, options) {
  const settings = options || {}

  // Ensure the last empty entry is seen.
  const input = values[values.length - 1] === '' ? [...values, ''] : values

  return input
    .join(
      (settings.padRight ? ' ' : '') +
        ',' +
        (settings.padLeft === false ? '' : ' ')
    )
    .trim()
}


/***/ }),

/***/ "./node_modules/crc-32/crc32.js":
/*!**************************************!*\
  !*** ./node_modules/crc-32/crc32.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
/* vim: set ts=2: */
/*exported CRC32 */
var CRC32;
(function (factory) {
	/*jshint ignore:start */
	/*eslint-disable */
	if(typeof DO_NOT_EXPORT_CRC === 'undefined') {
		if(true) {
			factory(exports);
		} else // removed by dead control flow
{}
	} else {
		factory(CRC32 = {});
	}
	/*eslint-enable */
	/*jshint ignore:end */
}(function(CRC32) {
CRC32.version = '1.2.2';
/*global Int32Array */
function signed_crc_table() {
	var c = 0, table = new Array(256);

	for(var n =0; n != 256; ++n){
		c = n;
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		table[n] = c;
	}

	return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
}

var T0 = signed_crc_table();
function slice_by_16_tables(T) {
	var c = 0, v = 0, n = 0, table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096) ;

	for(n = 0; n != 256; ++n) table[n] = T[n];
	for(n = 0; n != 256; ++n) {
		v = T[n];
		for(c = 256 + n; c < 4096; c += 256) v = table[c] = (v >>> 8) ^ T[v & 0xFF];
	}
	var out = [];
	for(n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
	return out;
}
var TT = slice_by_16_tables(T0);
var T1 = TT[0],  T2 = TT[1],  T3 = TT[2],  T4 = TT[3],  T5 = TT[4];
var T6 = TT[5],  T7 = TT[6],  T8 = TT[7],  T9 = TT[8],  Ta = TT[9];
var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
function crc32_bstr(bstr, seed) {
	var C = seed ^ -1;
	for(var i = 0, L = bstr.length; i < L;) C = (C>>>8) ^ T0[(C^bstr.charCodeAt(i++))&0xFF];
	return ~C;
}

function crc32_buf(B, seed) {
	var C = seed ^ -1, L = B.length - 15, i = 0;
	for(; i < L;) C =
		Tf[B[i++] ^ (C & 255)] ^
		Te[B[i++] ^ ((C >> 8) & 255)] ^
		Td[B[i++] ^ ((C >> 16) & 255)] ^
		Tc[B[i++] ^ (C >>> 24)] ^
		Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^
		T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^
		T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
	L += 15;
	while(i < L) C = (C>>>8) ^ T0[(C^B[i++])&0xFF];
	return ~C;
}

function crc32_str(str, seed) {
	var C = seed ^ -1;
	for(var i = 0, L = str.length, c = 0, d = 0; i < L;) {
		c = str.charCodeAt(i++);
		if(c < 0x80) {
			C = (C>>>8) ^ T0[(C^c)&0xFF];
		} else if(c < 0x800) {
			C = (C>>>8) ^ T0[(C ^ (192|((c>>6)&31)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];
		} else if(c >= 0xD800 && c < 0xE000) {
			c = (c&1023)+64; d = str.charCodeAt(i++)&1023;
			C = (C>>>8) ^ T0[(C ^ (240|((c>>8)&7)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|((c>>2)&63)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|((d>>6)&15)|((c&3)<<4)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|(d&63)))&0xFF];
		} else {
			C = (C>>>8) ^ T0[(C ^ (224|((c>>12)&15)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|((c>>6)&63)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];
		}
	}
	return ~C;
}
CRC32.table = T0;
// $FlowIgnore
CRC32.bstr = crc32_bstr;
// $FlowIgnore
CRC32.buf = crc32_buf;
// $FlowIgnore
CRC32.str = crc32_str;
}));


/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	// eslint-disable-next-line no-return-assign
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		const split = (typeof namespaces === 'string' ? namespaces : '')
			.trim()
			.replace(/\s+/g, ',')
			.split(',')
			.filter(Boolean);

		for (const ns of split) {
			if (ns[0] === '-') {
				createDebug.skips.push(ns.slice(1));
			} else {
				createDebug.names.push(ns);
			}
		}
	}

	/**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */
	function matchesTemplate(search, template) {
		let searchIndex = 0;
		let templateIndex = 0;
		let starIndex = -1;
		let matchIndex = 0;

		while (searchIndex < search.length) {
			if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
				// Match character or proceed with wildcard
				if (template[templateIndex] === '*') {
					starIndex = templateIndex;
					matchIndex = searchIndex;
					templateIndex++; // Skip the '*'
				} else {
					searchIndex++;
					templateIndex++;
				}
			} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
				// Backtrack to the last '*' and try to match more characters
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else {
				return false; // No match
			}
		}

		// Handle trailing '*' in template
		while (templateIndex < template.length && template[templateIndex] === '*') {
			templateIndex++;
		}

		return templateIndex === template.length;
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names,
			...createDebug.skips.map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		for (const skip of createDebug.skips) {
			if (matchesTemplate(name, skip)) {
				return false;
			}
		}

		for (const ns of createDebug.names) {
			if (matchesTemplate(name, ns)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/decode-named-character-reference/index.dom.js":
/*!********************************************************************!*\
  !*** ./node_modules/decode-named-character-reference/index.dom.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decodeNamedCharacterReference: () => (/* binding */ decodeNamedCharacterReference)
/* harmony export */ });
/// <reference lib="dom" />

/* global document */

const element = document.createElement('i')

/**
 * @param {string} value
 * @returns {string | false}
 */
function decodeNamedCharacterReference(value) {
  const characterReference = '&' + value + ';'
  element.innerHTML = characterReference
  const character = element.textContent

  // Some named character references do not require the closing semicolon
  // (`&not`, for instance), which leads to situations where parsing the assumed
  // named reference of `&notit;` will result in the string `¬it;`.
  // When we encounter a trailing semicolon after parsing, and the character
  // reference to decode was not a semicolon (`&semi;`), we can assume that the
  // matching was not complete.
  if (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    character.charCodeAt(character.length - 1) === 59 /* `;` */ &&
    value !== 'semi'
  ) {
    return false
  }

  // If the decoded string is equal to the input, the character reference was
  // not valid.
  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
  // yield `null`.
  return character === characterReference ? false : character
}


/***/ }),

/***/ "./node_modules/dequal/dist/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/dequal/dist/index.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dequal: () => (/* binding */ dequal)
/* harmony export */ });
var has = Object.prototype.hasOwnProperty;

function find(iter, tar, key) {
	for (key of iter.keys()) {
		if (dequal(key, tar)) return key;
	}
}

function dequal(foo, bar) {
	var ctor, len, tmp;
	if (foo === bar) return true;

	if (foo && bar && (ctor=foo.constructor) === bar.constructor) {
		if (ctor === Date) return foo.getTime() === bar.getTime();
		if (ctor === RegExp) return foo.toString() === bar.toString();

		if (ctor === Array) {
			if ((len=foo.length) === bar.length) {
				while (len-- && dequal(foo[len], bar[len]));
			}
			return len === -1;
		}

		if (ctor === Set) {
			if (foo.size !== bar.size) {
				return false;
			}
			for (len of foo) {
				tmp = len;
				if (tmp && typeof tmp === 'object') {
					tmp = find(bar, tmp);
					if (!tmp) return false;
				}
				if (!bar.has(tmp)) return false;
			}
			return true;
		}

		if (ctor === Map) {
			if (foo.size !== bar.size) {
				return false;
			}
			for (len of foo) {
				tmp = len[0];
				if (tmp && typeof tmp === 'object') {
					tmp = find(bar, tmp);
					if (!tmp) return false;
				}
				if (!dequal(len[1], bar.get(tmp))) {
					return false;
				}
			}
			return true;
		}

		if (ctor === ArrayBuffer) {
			foo = new Uint8Array(foo);
			bar = new Uint8Array(bar);
		} else if (ctor === DataView) {
			if ((len=foo.byteLength) === bar.byteLength) {
				while (len-- && foo.getInt8(len) === bar.getInt8(len));
			}
			return len === -1;
		}

		if (ArrayBuffer.isView(foo)) {
			if ((len=foo.byteLength) === bar.byteLength) {
				while (len-- && foo[len] === bar[len]);
			}
			return len === -1;
		}

		if (!ctor || typeof foo === 'object') {
			len = 0;
			for (ctor in foo) {
				if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
				if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
			}
			return Object.keys(bar).length === len;
		}
	}

	return foo !== foo && bar !== bar;
}


/***/ }),

/***/ "./node_modules/diff/lib/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/diff/lib/index.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Diff: () => (/* binding */ Diff),
/* harmony export */   applyPatch: () => (/* binding */ applyPatch),
/* harmony export */   applyPatches: () => (/* binding */ applyPatches),
/* harmony export */   canonicalize: () => (/* binding */ canonicalize),
/* harmony export */   convertChangesToDMP: () => (/* binding */ convertChangesToDMP),
/* harmony export */   convertChangesToXML: () => (/* binding */ convertChangesToXML),
/* harmony export */   createPatch: () => (/* binding */ createPatch),
/* harmony export */   createTwoFilesPatch: () => (/* binding */ createTwoFilesPatch),
/* harmony export */   diffArrays: () => (/* binding */ diffArrays),
/* harmony export */   diffChars: () => (/* binding */ diffChars),
/* harmony export */   diffCss: () => (/* binding */ diffCss),
/* harmony export */   diffJson: () => (/* binding */ diffJson),
/* harmony export */   diffLines: () => (/* binding */ diffLines),
/* harmony export */   diffSentences: () => (/* binding */ diffSentences),
/* harmony export */   diffTrimmedLines: () => (/* binding */ diffTrimmedLines),
/* harmony export */   diffWords: () => (/* binding */ diffWords),
/* harmony export */   diffWordsWithSpace: () => (/* binding */ diffWordsWithSpace),
/* harmony export */   formatPatch: () => (/* binding */ formatPatch),
/* harmony export */   merge: () => (/* binding */ merge),
/* harmony export */   parsePatch: () => (/* binding */ parsePatch),
/* harmony export */   reversePatch: () => (/* binding */ reversePatch),
/* harmony export */   structuredPatch: () => (/* binding */ structuredPatch)
/* harmony export */ });
function Diff() {}
Diff.prototype = {
  diff: function diff(oldString, newString) {
    var _options$timeout;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;

    if (options.maxEditLength) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }

    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: undefined
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Once we hit the right edge of the edit graph on some diagonal k, we can
    // definitely reach the end of the edit graph in no more than k edits, so
    // there's no point in considering any moves to diagonal k+1 any more (from
    // which we're guaranteed to need at least k+1 more edits).
    // Similarly, once we've reached the bottom of the edit graph, there's no
    // point considering moves to lower diagonals.
    // We record this fact by setting minDiagonalToConsider and
    // maxDiagonalToConsider to some finite value once we've hit the edge of
    // the edit graph.
    // This optimization is not faithful to the original algorithm presented in
    // Myers's paper, which instead pointlessly extends D-paths off the end of
    // the edit graph - see page 7 of Myers's paper which notes this point
    // explicitly and illustrates it with a diagram. This has major performance
    // implications for some common scenarios. For instance, to compute a diff
    // where the new text simply appends d characters on the end of the
    // original text of length n, the true Myers algorithm will take O(n+d^2)
    // time while this optimization needs only O(n+d) time.


    var minDiagonalToConsider = -Infinity,
        maxDiagonalToConsider = Infinity; // Main worker method. checks all permutations of a given edit length for acceptance.

    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath = void 0;
        var removePath = bestPath[diagonalPath - 1],
            addPath = bestPath[diagonalPath + 1];

        if (removePath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = false;

        if (addPath) {
          // what newPos will be after we do an insertion:
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }

        var canRemove = removePath && removePath.oldPos + 1 < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the old string is the farthest from the origin
        // and does not pass the bounds of the diff graph
        // TODO: Remove the `+ 1` here to make behavior match Myers algorithm
        //       and prefer to order removals before insertions.


        if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {
          basePath = self.addToPath(addPath, true, undefined, 0);
        } else {
          basePath = self.addToPath(removePath, undefined, true, 1);
        }

        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          // If we have hit the end of both strings, then we are done
          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;

          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }

          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced, or until the edit length exceeds options.maxEditLength (if given),
    // in which case it will return undefined.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },
  addToPath: function addToPath(path, added, removed, oldPosInc) {
    var last = path.lastComponent;

    if (last && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added: added,
          removed: removed,
          previousComponent: last.previousComponent
        }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added: added,
          removed: removed,
          previousComponent: last
        }
      };
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        oldPos = basePath.oldPos,
        newPos = oldPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent
      };
    }

    basePath.oldPos = oldPos;
    return newPos;
  },
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return value.split('');
  },
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, lastComponent, newString, oldString, useLongestToken) {
  // First we convert our linked list of components in reverse order to an
  // array in the right order:
  var components = [];
  var nextComponent;

  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }

  components.reverse();
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var finalComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof finalComponent.value === 'string' && (finalComponent.added || finalComponent.removed) && diff.equals('', finalComponent.value)) {
    components[componentLen - 2].value += finalComponent.value;
    components.pop();
  }

  return components;
}

var characterDiff = new Diff();
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}

function generateOptions(options, defaults) {
  if (typeof options === 'function') {
    defaults.callback = options;
  } else if (options) {
    for (var name in options) {
      /* istanbul ignore else */
      if (options.hasOwnProperty(name)) {
        defaults[name] = options[name];
      }
    }
  }

  return defaults;
}

//
// Ranges and exceptions:
// Latin-1 Supplement, 0080–00FF
//  - U+00D7  × Multiplication sign
//  - U+00F7  ÷ Division sign
// Latin Extended-A, 0100–017F
// Latin Extended-B, 0180–024F
// IPA Extensions, 0250–02AF
// Spacing Modifier Letters, 02B0–02FF
//  - U+02C7  ˇ &#711;  Caron
//  - U+02D8  ˘ &#728;  Breve
//  - U+02D9  ˙ &#729;  Dot Above
//  - U+02DA  ˚ &#730;  Ring Above
//  - U+02DB  ˛ &#731;  Ogonek
//  - U+02DC  ˜ &#732;  Small Tilde
//  - U+02DD  ˝ &#733;  Double Acute Accent
// Latin Extended Additional, 1E00–1EFF

var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new Diff();

wordDiff.equals = function (left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }

  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};

wordDiff.tokenize = function (value) {
  // All whitespace symbols except newline group into one token, each newline - in separate token
  var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.

  for (var i = 0; i < tokens.length - 1; i++) {
    // If we have an empty string in the next field and we have only word chars before and after, merge
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }

  return tokens;
};

function diffWords(oldStr, newStr, options) {
  options = generateOptions(options, {
    ignoreWhitespace: true
  });
  return wordDiff.diff(oldStr, newStr, options);
}
function diffWordsWithSpace(oldStr, newStr, options) {
  return wordDiff.diff(oldStr, newStr, options);
}

var lineDiff = new Diff();

lineDiff.tokenize = function (value) {
  if (this.options.stripTrailingCr) {
    // remove one \r before \n to match GNU diff's --strip-trailing-cr behavior
    value = value.replace(/\r\n/g, '\n');
  }

  var retLines = [],
      linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line

  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  } // Merge the content and line separators into single tokens


  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];

    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }

      retLines.push(line);
    }
  }

  return retLines;
};

function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
function diffTrimmedLines(oldStr, newStr, callback) {
  var options = generateOptions(callback, {
    ignoreWhitespace: true
  });
  return lineDiff.diff(oldStr, newStr, options);
}

var sentenceDiff = new Diff();

sentenceDiff.tokenize = function (value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};

function diffSentences(oldStr, newStr, callback) {
  return sentenceDiff.diff(oldStr, newStr, callback);
}

var cssDiff = new Diff();

cssDiff.tokenize = function (value) {
  return value.split(/([{}:;,]|\s+)/);
};

function diffCss(oldStr, newStr, callback) {
  return cssDiff.diff(oldStr, newStr, callback);
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:

jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;

jsonDiff.castInput = function (value) {
  var _this$options = this.options,
      undefinedReplacement = _this$options.undefinedReplacement,
      _this$options$stringi = _this$options.stringifyReplacer,
      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
    return typeof v === 'undefined' ? undefinedReplacement : v;
  } : _this$options$stringi;
  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
};

jsonDiff.equals = function (left, right) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
};

function diffJson(oldObj, newObj, options) {
  return jsonDiff.diff(oldObj, newObj, options);
} // This function handles the presence of circular references by bailing out when encountering an
// object that is already on the "stack" of items being processed. Accepts an optional replacer

function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];

  if (replacer) {
    obj = replacer(key, obj);
  }

  var i;

  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }

  var canonicalizedObj;

  if ('[object Array]' === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);

    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }

    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }

  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }

  if (_typeof(obj) === 'object' && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);

    var sortedKeys = [],
        _key;

    for (_key in obj) {
      /* istanbul ignore else */
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }

    sortedKeys.sort();

    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }

    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }

  return canonicalizedObj;
}

var arrayDiff = new Diff();

arrayDiff.tokenize = function (value) {
  return value.slice();
};

arrayDiff.join = arrayDiff.removeEmpty = function (value) {
  return value;
};

function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}

function parsePatch(uniDiff) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      list = [],
      i = 0;

  function parseIndex() {
    var index = {};
    list.push(index); // Parse diff metadata

    while (i < diffstr.length) {
      var line = diffstr[i]; // File header found, end parsing diff metadata

      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
        break;
      } // Diff index


      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);

      if (header) {
        index.index = header[1];
      }

      i++;
    } // Parse file headers if they are defined. Unified diff requires them, but
    // there's no technical issues to have an isolated hunk without file header


    parseFileHeader(index);
    parseFileHeader(index); // Parse hunks

    index.hunks = [];

    while (i < diffstr.length) {
      var _line = diffstr[i];

      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
        break;
      } else if (/^@@/.test(_line)) {
        index.hunks.push(parseHunk());
      } else if (_line && options.strict) {
        // Ignore unexpected content unless in strict mode
        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
      } else {
        i++;
      }
    }
  } // Parses the --- and +++ headers, if none are found, no lines
  // are consumed.


  function parseFileHeader(index) {
    var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);

    if (fileHeader) {
      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
      var data = fileHeader[2].split('\t', 2);
      var fileName = data[0].replace(/\\\\/g, '\\');

      if (/^".*"$/.test(fileName)) {
        fileName = fileName.substr(1, fileName.length - 2);
      }

      index[keyPrefix + 'FileName'] = fileName;
      index[keyPrefix + 'Header'] = (data[1] || '').trim();
      i++;
    }
  } // Parses a hunk
  // This assumes that we are at the start of a hunk.


  function parseHunk() {
    var chunkHeaderIndex = i,
        chunkHeaderLine = diffstr[i++],
        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
    var hunk = {
      oldStart: +chunkHeader[1],
      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],
      newStart: +chunkHeader[3],
      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],
      lines: [],
      linedelimiters: []
    }; // Unified Diff Format quirk: If the chunk size is 0,
    // the first number is one lower than one would expect.
    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293

    if (hunk.oldLines === 0) {
      hunk.oldStart += 1;
    }

    if (hunk.newLines === 0) {
      hunk.newStart += 1;
    }

    var addCount = 0,
        removeCount = 0;

    for (; i < diffstr.length; i++) {
      // Lines starting with '---' could be mistaken for the "remove line" operation
      // But they could be the header for the next file. Therefore prune such cases out.
      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
        break;
      }

      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];

      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
        hunk.lines.push(diffstr[i]);
        hunk.linedelimiters.push(delimiters[i] || '\n');

        if (operation === '+') {
          addCount++;
        } else if (operation === '-') {
          removeCount++;
        } else if (operation === ' ') {
          addCount++;
          removeCount++;
        }
      } else {
        break;
      }
    } // Handle the empty block count case


    if (!addCount && hunk.newLines === 1) {
      hunk.newLines = 0;
    }

    if (!removeCount && hunk.oldLines === 1) {
      hunk.oldLines = 0;
    } // Perform optional sanity checking


    if (options.strict) {
      if (addCount !== hunk.newLines) {
        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }

      if (removeCount !== hunk.oldLines) {
        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }
    }

    return hunk;
  }

  while (i < diffstr.length) {
    parseIndex();
  }

  return list;
}

// Iterator that traverses in the range of [min, max], stepping
// by distance from a given start position. I.e. for [0, 4], with
// start of 2, this will iterate 2, 3, 1, 4, 0.
function distanceIterator (start, minLine, maxLine) {
  var wantForward = true,
      backwardExhausted = false,
      forwardExhausted = false,
      localOffset = 1;
  return function iterator() {
    if (wantForward && !forwardExhausted) {
      if (backwardExhausted) {
        localOffset++;
      } else {
        wantForward = false;
      } // Check if trying to fit beyond text length, and if not, check it fits
      // after offset location (or desired location on first iteration)


      if (start + localOffset <= maxLine) {
        return localOffset;
      }

      forwardExhausted = true;
    }

    if (!backwardExhausted) {
      if (!forwardExhausted) {
        wantForward = true;
      } // Check if trying to fit before text beginning, and if not, check it fits
      // before offset location


      if (minLine <= start - localOffset) {
        return -localOffset++;
      }

      backwardExhausted = true;
      return iterator();
    } // We tried to fit hunk before text beginning and beyond text length, then
    // hunk can't fit on the text. Return undefined

  };
}

function applyPatch(source, uniDiff) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (typeof uniDiff === 'string') {
    uniDiff = parsePatch(uniDiff);
  }

  if (Array.isArray(uniDiff)) {
    if (uniDiff.length > 1) {
      throw new Error('applyPatch only works with a single input.');
    }

    uniDiff = uniDiff[0];
  } // Apply the diff to the input


  var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      hunks = uniDiff.hunks,
      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {
    return line === patchContent;
  },
      errorCount = 0,
      fuzzFactor = options.fuzzFactor || 0,
      minLine = 0,
      offset = 0,
      removeEOFNL,
      addEOFNL;
  /**
   * Checks if the hunk exactly fits on the provided location
   */


  function hunkFits(hunk, toPos) {
    for (var j = 0; j < hunk.lines.length; j++) {
      var line = hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line;

      if (operation === ' ' || operation === '-') {
        // Context sanity check
        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
          errorCount++;

          if (errorCount > fuzzFactor) {
            return false;
          }
        }

        toPos++;
      }
    }

    return true;
  } // Search best fit offsets for each hunk based on the previous ones


  for (var i = 0; i < hunks.length; i++) {
    var hunk = hunks[i],
        maxLine = lines.length - hunk.oldLines,
        localOffset = 0,
        toPos = offset + hunk.oldStart - 1;
    var iterator = distanceIterator(toPos, minLine, maxLine);

    for (; localOffset !== undefined; localOffset = iterator()) {
      if (hunkFits(hunk, toPos + localOffset)) {
        hunk.offset = offset += localOffset;
        break;
      }
    }

    if (localOffset === undefined) {
      return false;
    } // Set lower text limit to end of the current hunk, so next ones don't try
    // to fit over already patched text


    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
  } // Apply patch hunks


  var diffOffset = 0;

  for (var _i = 0; _i < hunks.length; _i++) {
    var _hunk = hunks[_i],
        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;

    diffOffset += _hunk.newLines - _hunk.oldLines;

    for (var j = 0; j < _hunk.lines.length; j++) {
      var line = _hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line,
          delimiter = _hunk.linedelimiters && _hunk.linedelimiters[j] || '\n';

      if (operation === ' ') {
        _toPos++;
      } else if (operation === '-') {
        lines.splice(_toPos, 1);
        delimiters.splice(_toPos, 1);
        /* istanbul ignore else */
      } else if (operation === '+') {
        lines.splice(_toPos, 0, content);
        delimiters.splice(_toPos, 0, delimiter);
        _toPos++;
      } else if (operation === '\\') {
        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;

        if (previousOperation === '+') {
          removeEOFNL = true;
        } else if (previousOperation === '-') {
          addEOFNL = true;
        }
      }
    }
  } // Handle EOFNL insertion/removal


  if (removeEOFNL) {
    while (!lines[lines.length - 1]) {
      lines.pop();
      delimiters.pop();
    }
  } else if (addEOFNL) {
    lines.push('');
    delimiters.push('\n');
  }

  for (var _k = 0; _k < lines.length - 1; _k++) {
    lines[_k] = lines[_k] + delimiters[_k];
  }

  return lines.join('');
} // Wrapper that supports multiple file patches via callbacks.

function applyPatches(uniDiff, options) {
  if (typeof uniDiff === 'string') {
    uniDiff = parsePatch(uniDiff);
  }

  var currentIndex = 0;

  function processIndex() {
    var index = uniDiff[currentIndex++];

    if (!index) {
      return options.complete();
    }

    options.loadFile(index, function (err, data) {
      if (err) {
        return options.complete(err);
      }

      var updatedContent = applyPatch(data, index, options);
      options.patched(index, updatedContent, function (err) {
        if (err) {
          return options.complete(err);
        }

        processIndex();
      });
    });
  }

  processIndex();
}

function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (!options) {
    options = {};
  }

  if (typeof options.context === 'undefined') {
    options.context = 4;
  }

  var diff = diffLines(oldStr, newStr, options);

  if (!diff) {
    return;
  }

  diff.push({
    value: '',
    lines: []
  }); // Append an empty value to make cleanup easier

  function contextLines(lines) {
    return lines.map(function (entry) {
      return ' ' + entry;
    });
  }

  var hunks = [];
  var oldRangeStart = 0,
      newRangeStart = 0,
      curRange = [],
      oldLine = 1,
      newLine = 1;

  var _loop = function _loop(i) {
    var current = diff[i],
        lines = current.lines || current.value.replace(/\n$/, '').split('\n');
    current.lines = lines;

    if (current.added || current.removed) {
      var _curRange;

      // If we have previous context, start with that
      if (!oldRangeStart) {
        var prev = diff[i - 1];
        oldRangeStart = oldLine;
        newRangeStart = newLine;

        if (prev) {
          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
          oldRangeStart -= curRange.length;
          newRangeStart -= curRange.length;
        }
      } // Output our changes


      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {
        return (current.added ? '+' : '-') + entry;
      }))); // Track the updated file position


      if (current.added) {
        newLine += lines.length;
      } else {
        oldLine += lines.length;
      }
    } else {
      // Identical context lines. Track line changes
      if (oldRangeStart) {
        // Close out any changes that have been output (or join overlapping)
        if (lines.length <= options.context * 2 && i < diff.length - 2) {
          var _curRange2;

          // Overlapping
          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
        } else {
          var _curRange3;

          // end the range and output
          var contextSize = Math.min(lines.length, options.context);

          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));

          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };

          if (i >= diff.length - 2 && lines.length <= options.context) {
            // EOF is inside this hunk
            var oldEOFNewline = /\n$/.test(oldStr);
            var newEOFNewline = /\n$/.test(newStr);
            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;

            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {
              // special case: old has no eol and no trailing context; no-nl can end up before adds
              // however, if the old file is empty, do not output the no-nl line
              curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
            }

            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
              curRange.push('\\ No newline at end of file');
            }
          }

          hunks.push(hunk);
          oldRangeStart = 0;
          newRangeStart = 0;
          curRange = [];
        }
      }

      oldLine += lines.length;
      newLine += lines.length;
    }
  };

  for (var i = 0; i < diff.length; i++) {
    _loop(i);
  }

  return {
    oldFileName: oldFileName,
    newFileName: newFileName,
    oldHeader: oldHeader,
    newHeader: newHeader,
    hunks: hunks
  };
}
function formatPatch(diff) {
  if (Array.isArray(diff)) {
    return diff.map(formatPatch).join('\n');
  }

  var ret = [];

  if (diff.oldFileName == diff.newFileName) {
    ret.push('Index: ' + diff.oldFileName);
  }

  ret.push('===================================================================');
  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

  for (var i = 0; i < diff.hunks.length; i++) {
    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,
    // the first number is one lower than one would expect.
    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293

    if (hunk.oldLines === 0) {
      hunk.oldStart -= 1;
    }

    if (hunk.newLines === 0) {
      hunk.newStart -= 1;
    }

    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
    ret.push.apply(ret, hunk.lines);
  }

  return ret.join('\n') + '\n';
}
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
}
function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}

function arrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  return arrayStartsWith(a, b);
}
function arrayStartsWith(array, start) {
  if (start.length > array.length) {
    return false;
  }

  for (var i = 0; i < start.length; i++) {
    if (start[i] !== array[i]) {
      return false;
    }
  }

  return true;
}

function calcLineCount(hunk) {
  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),
      oldLines = _calcOldNewLineCount.oldLines,
      newLines = _calcOldNewLineCount.newLines;

  if (oldLines !== undefined) {
    hunk.oldLines = oldLines;
  } else {
    delete hunk.oldLines;
  }

  if (newLines !== undefined) {
    hunk.newLines = newLines;
  } else {
    delete hunk.newLines;
  }
}
function merge(mine, theirs, base) {
  mine = loadPatch(mine, base);
  theirs = loadPatch(theirs, base);
  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.
  // Leaving sanity checks on this to the API consumer that may know more about the
  // meaning in their own context.

  if (mine.index || theirs.index) {
    ret.index = mine.index || theirs.index;
  }

  if (mine.newFileName || theirs.newFileName) {
    if (!fileNameChanged(mine)) {
      // No header or no change in ours, use theirs (and ours if theirs does not exist)
      ret.oldFileName = theirs.oldFileName || mine.oldFileName;
      ret.newFileName = theirs.newFileName || mine.newFileName;
      ret.oldHeader = theirs.oldHeader || mine.oldHeader;
      ret.newHeader = theirs.newHeader || mine.newHeader;
    } else if (!fileNameChanged(theirs)) {
      // No header or no change in theirs, use ours
      ret.oldFileName = mine.oldFileName;
      ret.newFileName = mine.newFileName;
      ret.oldHeader = mine.oldHeader;
      ret.newHeader = mine.newHeader;
    } else {
      // Both changed... figure it out
      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
    }
  }

  ret.hunks = [];
  var mineIndex = 0,
      theirsIndex = 0,
      mineOffset = 0,
      theirsOffset = 0;

  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
    var mineCurrent = mine.hunks[mineIndex] || {
      oldStart: Infinity
    },
        theirsCurrent = theirs.hunks[theirsIndex] || {
      oldStart: Infinity
    };

    if (hunkBefore(mineCurrent, theirsCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
      mineIndex++;
      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
    } else if (hunkBefore(theirsCurrent, mineCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
      theirsIndex++;
      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
    } else {
      // Overlap, merge as best we can
      var mergedHunk = {
        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
        oldLines: 0,
        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
        newLines: 0,
        lines: []
      };
      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
      theirsIndex++;
      mineIndex++;
      ret.hunks.push(mergedHunk);
    }
  }

  return ret;
}

function loadPatch(param, base) {
  if (typeof param === 'string') {
    if (/^@@/m.test(param) || /^Index:/m.test(param)) {
      return parsePatch(param)[0];
    }

    if (!base) {
      throw new Error('Must provide a base reference or pass in a patch');
    }

    return structuredPatch(undefined, undefined, base, param);
  }

  return param;
}

function fileNameChanged(patch) {
  return patch.newFileName && patch.newFileName !== patch.oldFileName;
}

function selectField(index, mine, theirs) {
  if (mine === theirs) {
    return mine;
  } else {
    index.conflict = true;
    return {
      mine: mine,
      theirs: theirs
    };
  }
}

function hunkBefore(test, check) {
  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
}

function cloneHunk(hunk, offset) {
  return {
    oldStart: hunk.oldStart,
    oldLines: hunk.oldLines,
    newStart: hunk.newStart + offset,
    newLines: hunk.newLines,
    lines: hunk.lines
  };
}

function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
  // This will generally result in a conflicted hunk, but there are cases where the context
  // is the only overlap where we can successfully merge the content here.
  var mine = {
    offset: mineOffset,
    lines: mineLines,
    index: 0
  },
      their = {
    offset: theirOffset,
    lines: theirLines,
    index: 0
  }; // Handle any leading content

  insertLeading(hunk, mine, their);
  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.

  while (mine.index < mine.lines.length && their.index < their.lines.length) {
    var mineCurrent = mine.lines[mine.index],
        theirCurrent = their.lines[their.index];

    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
      // Both modified ...
      mutualChange(hunk, mine, their);
    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
      var _hunk$lines;

      // Mine inserted
      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
      var _hunk$lines2;

      // Theirs inserted
      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
      // Mine removed or edited
      removal(hunk, mine, their);
    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
      // Their removed or edited
      removal(hunk, their, mine, true);
    } else if (mineCurrent === theirCurrent) {
      // Context identity
      hunk.lines.push(mineCurrent);
      mine.index++;
      their.index++;
    } else {
      // Context mismatch
      conflict(hunk, collectChange(mine), collectChange(their));
    }
  } // Now push anything that may be remaining


  insertTrailing(hunk, mine);
  insertTrailing(hunk, their);
  calcLineCount(hunk);
}

function mutualChange(hunk, mine, their) {
  var myChanges = collectChange(mine),
      theirChanges = collectChange(their);

  if (allRemoves(myChanges) && allRemoves(theirChanges)) {
    // Special case for remove changes that are supersets of one another
    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
      var _hunk$lines3;

      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));

      return;
    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
      var _hunk$lines4;

      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));

      return;
    }
  } else if (arrayEqual(myChanges, theirChanges)) {
    var _hunk$lines5;

    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));

    return;
  }

  conflict(hunk, myChanges, theirChanges);
}

function removal(hunk, mine, their, swap) {
  var myChanges = collectChange(mine),
      theirChanges = collectContext(their, myChanges);

  if (theirChanges.merged) {
    var _hunk$lines6;

    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
  } else {
    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
  }
}

function conflict(hunk, mine, their) {
  hunk.conflict = true;
  hunk.lines.push({
    conflict: true,
    mine: mine,
    theirs: their
  });
}

function insertLeading(hunk, insert, their) {
  while (insert.offset < their.offset && insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
    insert.offset++;
  }
}

function insertTrailing(hunk, insert) {
  while (insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
  }
}

function collectChange(state) {
  var ret = [],
      operation = state.lines[state.index][0];

  while (state.index < state.lines.length) {
    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.

    if (operation === '-' && line[0] === '+') {
      operation = '+';
    }

    if (operation === line[0]) {
      ret.push(line);
      state.index++;
    } else {
      break;
    }
  }

  return ret;
}

function collectContext(state, matchChanges) {
  var changes = [],
      merged = [],
      matchIndex = 0,
      contextChanges = false,
      conflicted = false;

  while (matchIndex < matchChanges.length && state.index < state.lines.length) {
    var change = state.lines[state.index],
        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done

    if (match[0] === '+') {
      break;
    }

    contextChanges = contextChanges || change[0] !== ' ';
    merged.push(match);
    matchIndex++; // Consume any additions in the other block as a conflict to attempt
    // to pull in the remaining context after this

    if (change[0] === '+') {
      conflicted = true;

      while (change[0] === '+') {
        changes.push(change);
        change = state.lines[++state.index];
      }
    }

    if (match.substr(1) === change.substr(1)) {
      changes.push(change);
      state.index++;
    } else {
      conflicted = true;
    }
  }

  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
    conflicted = true;
  }

  if (conflicted) {
    return changes;
  }

  while (matchIndex < matchChanges.length) {
    merged.push(matchChanges[matchIndex++]);
  }

  return {
    merged: merged,
    changes: changes
  };
}

function allRemoves(changes) {
  return changes.reduce(function (prev, change) {
    return prev && change[0] === '-';
  }, true);
}

function skipRemoveSuperset(state, removeChanges, delta) {
  for (var i = 0; i < delta; i++) {
    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);

    if (state.lines[state.index + i] !== ' ' + changeContent) {
      return false;
    }
  }

  state.index += delta;
  return true;
}

function calcOldNewLineCount(lines) {
  var oldLines = 0;
  var newLines = 0;
  lines.forEach(function (line) {
    if (typeof line !== 'string') {
      var myCount = calcOldNewLineCount(line.mine);
      var theirCount = calcOldNewLineCount(line.theirs);

      if (oldLines !== undefined) {
        if (myCount.oldLines === theirCount.oldLines) {
          oldLines += myCount.oldLines;
        } else {
          oldLines = undefined;
        }
      }

      if (newLines !== undefined) {
        if (myCount.newLines === theirCount.newLines) {
          newLines += myCount.newLines;
        } else {
          newLines = undefined;
        }
      }
    } else {
      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
        newLines++;
      }

      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
        oldLines++;
      }
    }
  });
  return {
    oldLines: oldLines,
    newLines: newLines
  };
}

function reversePatch(structuredPatch) {
  if (Array.isArray(structuredPatch)) {
    return structuredPatch.map(reversePatch).reverse();
  }

  return _objectSpread2(_objectSpread2({}, structuredPatch), {}, {
    oldFileName: structuredPatch.newFileName,
    oldHeader: structuredPatch.newHeader,
    newFileName: structuredPatch.oldFileName,
    newHeader: structuredPatch.oldHeader,
    hunks: structuredPatch.hunks.map(function (hunk) {
      return {
        oldLines: hunk.newLines,
        oldStart: hunk.newStart,
        newLines: hunk.oldLines,
        newStart: hunk.oldStart,
        linedelimiters: hunk.linedelimiters,
        lines: hunk.lines.map(function (l) {
          if (l.startsWith('-')) {
            return "+".concat(l.slice(1));
          }

          if (l.startsWith('+')) {
            return "-".concat(l.slice(1));
          }

          return l;
        })
      };
    })
  });
}

// See: http://code.google.com/p/google-diff-match-patch/wiki/API
function convertChangesToDMP(changes) {
  var ret = [],
      change,
      operation;

  for (var i = 0; i < changes.length; i++) {
    change = changes[i];

    if (change.added) {
      operation = 1;
    } else if (change.removed) {
      operation = -1;
    } else {
      operation = 0;
    }

    ret.push([operation, change.value]);
  }

  return ret;
}

function convertChangesToXML(changes) {
  var ret = [];

  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];

    if (change.added) {
      ret.push('<ins>');
    } else if (change.removed) {
      ret.push('<del>');
    }

    ret.push(escapeHTML(change.value));

    if (change.added) {
      ret.push('</ins>');
    } else if (change.removed) {
      ret.push('</del>');
    }
  }

  return ret.join('');
}

function escapeHTML(s) {
  var n = s;
  n = n.replace(/&/g, '&amp;');
  n = n.replace(/</g, '&lt;');
  n = n.replace(/>/g, '&gt;');
  n = n.replace(/"/g, '&quot;');
  return n;
}




/***/ }),

/***/ "./node_modules/extend/index.js":
/*!**************************************!*\
  !*** ./node_modules/extend/index.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";


var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};


/***/ }),

/***/ "./node_modules/hast-util-whitespace/index.js":
/*!****************************************************!*\
  !*** ./node_modules/hast-util-whitespace/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   whitespace: () => (/* binding */ whitespace)
/* harmony export */ });
/**
 * Check if the given value is *inter-element whitespace*.
 *
 * @param {unknown} thing
 *   Thing to check (typically `Node` or `string`).
 * @returns {boolean}
 *   Whether the `value` is inter-element whitespace (`boolean`): consisting of
 *   zero or more of space, tab (`\t`), line feed (`\n`), carriage return
 *   (`\r`), or form feed (`\f`).
 *   If a node is passed it must be a `Text` node, whose `value` field is
 *   checked.
 */
function whitespace(thing) {
  /** @type {string} */
  const value =
    // @ts-expect-error looks like a node.
    thing && typeof thing === 'object' && thing.type === 'text'
      ? // @ts-expect-error looks like a text.
        thing.value || ''
      : thing

  // HTML whitespace expression.
  // See <https://infra.spec.whatwg.org/#ascii-whitespace>.
  return typeof value === 'string' && value.replace(/[ \t\n\f\r]/g, '') === ''
}


/***/ }),

/***/ "./node_modules/inline-style-parser/index.js":
/*!***************************************************!*\
  !*** ./node_modules/inline-style-parser/index.js ***!
  \***************************************************/
/***/ ((module) => {

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;

var NEWLINE_REGEX = /\n/g;
var WHITESPACE_REGEX = /^\s*/;

// declaration
var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var COLON_REGEX = /^:\s*/;
var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var SEMICOLON_REGEX = /^[;\s]*/;

// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
var TRIM_REGEX = /^\s+|\s+$/g;

// strings
var NEWLINE = '\n';
var FORWARD_SLASH = '/';
var ASTERISK = '*';
var EMPTY_STRING = '';

// types
var TYPE_COMMENT = 'comment';
var TYPE_DECLARATION = 'declaration';

/**
 * @param {String} style
 * @param {Object} [options]
 * @return {Object[]}
 * @throws {TypeError}
 * @throws {Error}
 */
module.exports = function(style, options) {
  if (typeof style !== 'string') {
    throw new TypeError('First argument must be a string');
  }

  if (!style) return [];

  options = options || {};

  /**
   * Positional.
   */
  var lineno = 1;
  var column = 1;

  /**
   * Update lineno and column based on `str`.
   *
   * @param {String} str
   */
  function updatePosition(str) {
    var lines = str.match(NEWLINE_REGEX);
    if (lines) lineno += lines.length;
    var i = str.lastIndexOf(NEWLINE);
    column = ~i ? str.length - i : column + str.length;
  }

  /**
   * Mark position and patch `node.position`.
   *
   * @return {Function}
   */
  function position() {
    var start = { line: lineno, column: column };
    return function(node) {
      node.position = new Position(start);
      whitespace();
      return node;
    };
  }

  /**
   * Store position information for a node.
   *
   * @constructor
   * @property {Object} start
   * @property {Object} end
   * @property {undefined|String} source
   */
  function Position(start) {
    this.start = start;
    this.end = { line: lineno, column: column };
    this.source = options.source;
  }

  /**
   * Non-enumerable source string.
   */
  Position.prototype.content = style;

  var errorsList = [];

  /**
   * Error `msg`.
   *
   * @param {String} msg
   * @throws {Error}
   */
  function error(msg) {
    var err = new Error(
      options.source + ':' + lineno + ':' + column + ': ' + msg
    );
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = style;

    if (options.silent) {
      errorsList.push(err);
    } else {
      throw err;
    }
  }

  /**
   * Match `re` and return captures.
   *
   * @param {RegExp} re
   * @return {undefined|Array}
   */
  function match(re) {
    var m = re.exec(style);
    if (!m) return;
    var str = m[0];
    updatePosition(str);
    style = style.slice(str.length);
    return m;
  }

  /**
   * Parse whitespace.
   */
  function whitespace() {
    match(WHITESPACE_REGEX);
  }

  /**
   * Parse comments.
   *
   * @param {Object[]} [rules]
   * @return {Object[]}
   */
  function comments(rules) {
    var c;
    rules = rules || [];
    while ((c = comment())) {
      if (c !== false) {
        rules.push(c);
      }
    }
    return rules;
  }

  /**
   * Parse comment.
   *
   * @return {Object}
   * @throws {Error}
   */
  function comment() {
    var pos = position();
    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;

    var i = 2;
    while (
      EMPTY_STRING != style.charAt(i) &&
      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))
    ) {
      ++i;
    }
    i += 2;

    if (EMPTY_STRING === style.charAt(i - 1)) {
      return error('End of comment missing');
    }

    var str = style.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    style = style.slice(i);
    column += 2;

    return pos({
      type: TYPE_COMMENT,
      comment: str
    });
  }

  /**
   * Parse declaration.
   *
   * @return {Object}
   * @throws {Error}
   */
  function declaration() {
    var pos = position();

    // prop
    var prop = match(PROPERTY_REGEX);
    if (!prop) return;
    comment();

    // :
    if (!match(COLON_REGEX)) return error("property missing ':'");

    // val
    var val = match(VALUE_REGEX);

    var ret = pos({
      type: TYPE_DECLARATION,
      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
      value: val
        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))
        : EMPTY_STRING
    });

    // ;
    match(SEMICOLON_REGEX);

    return ret;
  }

  /**
   * Parse declarations.
   *
   * @return {Object[]}
   */
  function declarations() {
    var decls = [];

    comments(decls);

    // declarations
    var decl;
    while ((decl = declaration())) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }

    return decls;
  }

  whitespace();
  return declarations();
};

/**
 * Trim `str`.
 *
 * @param {String} str
 * @return {String}
 */
function trim(str) {
  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}


/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/***/ ((module) => {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}


/***/ }),

/***/ "./node_modules/is-plain-obj/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-plain-obj/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isPlainObject)
/* harmony export */ });
function isPlainObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}

	const prototype = Object.getPrototypeOf(value);
	return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}


/***/ }),

/***/ "./node_modules/kleur/index.mjs":
/*!**************************************!*\
  !*** ./node_modules/kleur/index.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


let FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY=true;
if (typeof process !== 'undefined') {
	({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
	isTTY = process.stdout && process.stdout.isTTY;
}

const $ = {
	enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (
		FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY
	),

	// modifiers
	reset: init(0, 0),
	bold: init(1, 22),
	dim: init(2, 22),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),

	// colors
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	grey: init(90, 39),

	// background colors
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49)
};

function run(arr, str) {
	let i=0, tmp, beg='', end='';
	for (; i < arr.length; i++) {
		tmp = arr[i];
		beg += tmp.open;
		end += tmp.close;
		if (!!~str.indexOf(tmp.close)) {
			str = str.replace(tmp.rgx, tmp.close + tmp.open);
		}
	}
	return beg + str + end;
}

function chain(has, keys) {
	let ctx = { has, keys };

	ctx.reset = $.reset.bind(ctx);
	ctx.bold = $.bold.bind(ctx);
	ctx.dim = $.dim.bind(ctx);
	ctx.italic = $.italic.bind(ctx);
	ctx.underline = $.underline.bind(ctx);
	ctx.inverse = $.inverse.bind(ctx);
	ctx.hidden = $.hidden.bind(ctx);
	ctx.strikethrough = $.strikethrough.bind(ctx);

	ctx.black = $.black.bind(ctx);
	ctx.red = $.red.bind(ctx);
	ctx.green = $.green.bind(ctx);
	ctx.yellow = $.yellow.bind(ctx);
	ctx.blue = $.blue.bind(ctx);
	ctx.magenta = $.magenta.bind(ctx);
	ctx.cyan = $.cyan.bind(ctx);
	ctx.white = $.white.bind(ctx);
	ctx.gray = $.gray.bind(ctx);
	ctx.grey = $.grey.bind(ctx);

	ctx.bgBlack = $.bgBlack.bind(ctx);
	ctx.bgRed = $.bgRed.bind(ctx);
	ctx.bgGreen = $.bgGreen.bind(ctx);
	ctx.bgYellow = $.bgYellow.bind(ctx);
	ctx.bgBlue = $.bgBlue.bind(ctx);
	ctx.bgMagenta = $.bgMagenta.bind(ctx);
	ctx.bgCyan = $.bgCyan.bind(ctx);
	ctx.bgWhite = $.bgWhite.bind(ctx);

	return ctx;
}

function init(open, close) {
	let blk = {
		open: `\x1b[${open}m`,
		close: `\x1b[${close}m`,
		rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
	};
	return function (txt) {
		if (this !== void 0 && this.has !== void 0) {
			!!~this.has.indexOf(open) || (this.has.push(open),this.keys.push(blk));
			return txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';
		}
		return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';
	};
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ($);


/***/ }),

/***/ "./node_modules/mdast-util-definitions/lib/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/mdast-util-definitions/lib/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   definitions: () => (/* binding */ definitions)
/* harmony export */ });
/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit */ "./node_modules/unist-util-visit/lib/index.js");
/**
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').Definition} Definition
 */

/**
 * @typedef {Root | Content} Node
 *
 * @callback GetDefinition
 *   Get a definition by identifier.
 * @param {string | null | undefined} [identifier]
 *   Identifier of definition.
 * @returns {Definition | null}
 *   Definition corresponding to `identifier` or `null`.
 */



const own = {}.hasOwnProperty

/**
 * Find definitions in `tree`.
 *
 * Uses CommonMark precedence, which means that earlier definitions are
 * preferred over duplicate later definitions.
 *
 * @param {Node} tree
 *   Tree to check.
 * @returns {GetDefinition}
 *   Getter.
 */
function definitions(tree) {
  /** @type {Record<string, Definition>} */
  const cache = Object.create(null)

  if (!tree || !tree.type) {
    throw new Error('mdast-util-definitions expected node')
  }

  (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(tree, 'definition', (definition) => {
    const id = clean(definition.identifier)
    if (id && !own.call(cache, id)) {
      cache[id] = definition
    }
  })

  return definition

  /** @type {GetDefinition} */
  function definition(identifier) {
    const id = clean(identifier)
    // To do: next major: return `undefined` when not found.
    return id && own.call(cache, id) ? cache[id] : null
  }
}

/**
 * @param {string | null | undefined} [value]
 * @returns {string}
 */
function clean(value) {
  return String(value || '').toUpperCase()
}


/***/ }),

/***/ "./node_modules/mdast-util-from-markdown/dev/lib/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-from-markdown/dev/lib/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fromMarkdown: () => (/* binding */ fromMarkdown)
/* harmony export */ });
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/* harmony import */ var mdast_util_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mdast-util-to-string */ "./node_modules/mdast-util-to-string/lib/index.js");
/* harmony import */ var micromark_lib_parse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark/lib/parse.js */ "./node_modules/micromark/dev/lib/parse.js");
/* harmony import */ var micromark_lib_preprocess_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark/lib/preprocess.js */ "./node_modules/micromark/dev/lib/preprocess.js");
/* harmony import */ var micromark_lib_postprocess_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark/lib/postprocess.js */ "./node_modules/micromark/dev/lib/postprocess.js");
/* harmony import */ var micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-decode-numeric-character-reference */ "./node_modules/micromark-util-decode-numeric-character-reference/dev/index.js");
/* harmony import */ var micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! micromark-util-decode-string */ "./node_modules/micromark-util-decode-string/dev/index.js");
/* harmony import */ var micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! micromark-util-normalize-identifier */ "./node_modules/micromark-util-normalize-identifier/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var decode_named_character_reference__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! decode-named-character-reference */ "./node_modules/decode-named-character-reference/index.dom.js");
/* harmony import */ var unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! unist-util-stringify-position */ "./node_modules/unist-util-stringify-position/lib/index.js");
/**
 * @typedef {import('micromark-util-types').Encoding} Encoding
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').ParseOptions} ParseOptions
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Value} Value
 *
 * @typedef {import('unist').Parent} UnistParent
 * @typedef {import('unist').Point} Point
 *
 * @typedef {import('mdast').PhrasingContent} PhrasingContent
 * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').Break} Break
 * @typedef {import('mdast').Blockquote} Blockquote
 * @typedef {import('mdast').Code} Code
 * @typedef {import('mdast').Definition} Definition
 * @typedef {import('mdast').Emphasis} Emphasis
 * @typedef {import('mdast').Heading} Heading
 * @typedef {import('mdast').HTML} HTML
 * @typedef {import('mdast').Image} Image
 * @typedef {import('mdast').ImageReference} ImageReference
 * @typedef {import('mdast').InlineCode} InlineCode
 * @typedef {import('mdast').Link} Link
 * @typedef {import('mdast').LinkReference} LinkReference
 * @typedef {import('mdast').List} List
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('mdast').Paragraph} Paragraph
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast').Strong} Strong
 * @typedef {import('mdast').Text} Text
 * @typedef {import('mdast').ThematicBreak} ThematicBreak
 * @typedef {import('mdast').ReferenceType} ReferenceType
 * @typedef {import('../index.js').CompileData} CompileData
 */

/**
 * @typedef {Root | Content} Node
 * @typedef {Extract<Node, UnistParent>} Parent
 *
 * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment
 */

/**
 * @callback Transform
 *   Extra transform, to change the AST afterwards.
 * @param {Root} tree
 *   Tree to transform.
 * @returns {Root | undefined | null | void}
 *   New tree or nothing (in which case the current tree is used).
 *
 * @callback Handle
 *   Handle a token.
 * @param {CompileContext} this
 *   Context.
 * @param {Token} token
 *   Current token.
 * @returns {void}
 *   Nothing.
 *
 * @typedef {Record<string, Handle>} Handles
 *   Token types mapping to handles
 *
 * @callback OnEnterError
 *   Handle the case where the `right` token is open, but it is closed (by the
 *   `left` token) or because we reached the end of the document.
 * @param {Omit<CompileContext, 'sliceSerialize'>} this
 *   Context.
 * @param {Token | undefined} left
 *   Left token.
 * @param {Token} right
 *   Right token.
 * @returns {void}
 *   Nothing.
 *
 * @callback OnExitError
 *   Handle the case where the `right` token is open but it is closed by
 *   exiting the `left` token.
 * @param {Omit<CompileContext, 'sliceSerialize'>} this
 *   Context.
 * @param {Token} left
 *   Left token.
 * @param {Token} right
 *   Right token.
 * @returns {void}
 *   Nothing.
 *
 * @typedef {[Token, OnEnterError | undefined]} TokenTuple
 *   Open token on the stack, with an optional error handler for when
 *   that token isn’t closed properly.
 */

/**
 * @typedef Config
 *   Configuration.
 *
 *   We have our defaults, but extensions will add more.
 * @property {Array<string>} canContainEols
 *   Token types where line endings are used.
 * @property {Handles} enter
 *   Opening handles.
 * @property {Handles} exit
 *   Closing handles.
 * @property {Array<Transform>} transforms
 *   Tree transforms.
 *
 * @typedef {Partial<Config>} Extension
 *   Change how markdown tokens from micromark are turned into mdast.
 *
 * @typedef CompileContext
 *   mdast compiler context.
 * @property {Array<Node | Fragment>} stack
 *   Stack of nodes.
 * @property {Array<TokenTuple>} tokenStack
 *   Stack of tokens.
 * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData
 *   Get data from the key/value store.
 * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData
 *   Set data into the key/value store.
 * @property {(this: CompileContext) => void} buffer
 *   Capture some of the output data.
 * @property {(this: CompileContext) => string} resume
 *   Stop capturing and access the output data.
 * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter
 *   Enter a token.
 * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit
 *   Exit a token.
 * @property {TokenizeContext['sliceSerialize']} sliceSerialize
 *   Get the string value of a token.
 * @property {Config} config
 *   Configuration.
 *
 * @typedef FromMarkdownOptions
 *   Configuration for how to build mdast.
 * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]
 *   Extensions for this utility to change how tokens are turned into a tree.
 *
 * @typedef {ParseOptions & FromMarkdownOptions} Options
 *   Configuration.
 */

// To do: micromark: create a registry of tokens?
// To do: next major: don’t return given `Node` from `enter`.
// To do: next major: remove setter/getter.















const own = {}.hasOwnProperty

/**
 * @param value
 *   Markdown to parse.
 * @param encoding
 *   Character encoding for when `value` is `Buffer`.
 * @param options
 *   Configuration.
 * @returns
 *   mdast tree.
 */
const fromMarkdown =
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
   *   ((value: Value, options?: Options | null | undefined) => Root)
   * )}
   */
  (
    /**
     * @param {Value} value
     * @param {Encoding | Options | null | undefined} [encoding]
     * @param {Options | null | undefined} [options]
     * @returns {Root}
     */
    function (value, encoding, options) {
      if (typeof encoding !== 'string') {
        options = encoding
        encoding = undefined
      }

      return compiler(options)(
        (0,micromark_lib_postprocess_js__WEBPACK_IMPORTED_MODULE_4__.postprocess)(
          (0,micromark_lib_parse_js__WEBPACK_IMPORTED_MODULE_2__.parse)(options).document().write((0,micromark_lib_preprocess_js__WEBPACK_IMPORTED_MODULE_3__.preprocess)()(value, encoding, true))
        )
      )
    }
  )

/**
 * Note this compiler only understand complete buffering, not streaming.
 *
 * @param {Options | null | undefined} [options]
 */
function compiler(options) {
  /** @type {Config} */
  const config = {
    transforms: [],
    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],
    enter: {
      autolink: opener(link),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading),
      blockQuote: opener(blockQuote),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis),
      hardBreakEscape: opener(hardBreak),
      hardBreakTrailing: opener(hardBreak),
      htmlFlow: opener(html, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html, buffer),
      htmlTextData: onenterdata,
      image: opener(image),
      label: buffer,
      link: opener(link),
      listItem: opener(listItem),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list, onenterlistordered),
      listUnordered: opener(list),
      paragraph: opener(paragraph),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading),
      strong: opener(strong),
      thematicBreak: opener(thematicBreak)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  }

  configure(config, (options || {}).mdastExtensions || [])

  /** @type {CompileData} */
  const data = {}

  return compile

  /**
   * Turn micromark events into an mdast tree.
   *
   * @param {Array<Event>} events
   *   Events.
   * @returns {Root}
   *   mdast tree.
   */
  function compile(events) {
    /** @type {Root} */
    let tree = {type: 'root', children: []}
    /** @type {Omit<CompileContext, 'sliceSerialize'>} */
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit,
      buffer,
      resume,
      setData,
      getData
    }
    /** @type {Array<number>} */
    const listStack = []
    let index = -1

    while (++index < events.length) {
      // We preprocess lists to add `listItem` tokens, and to infer whether
      // items the list itself are spread out.
      if (
        events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.listOrdered ||
        events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.listUnordered
      ) {
        if (events[index][0] === 'enter') {
          listStack.push(index)
        } else {
          const tail = listStack.pop()
          ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tail === 'number', 'expected list ot be open')
          index = prepareList(events, tail, index)
        }
      }
    }

    index = -1

    while (++index < events.length) {
      const handler = config[events[index][0]]

      if (own.call(handler, events[index][1].type)) {
        handler[events[index][1].type].call(
          Object.assign(
            {sliceSerialize: events[index][2].sliceSerialize},
            context
          ),
          events[index][1]
        )
      }
    }

    // Handle tokens still being open.
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1]
      const handler = tail[1] || defaultOnError
      handler.call(context, undefined, tail[0])
    }

    // Figure out `root` position.
    tree.position = {
      start: point(
        events.length > 0 ? events[0][1].start : {line: 1, column: 1, offset: 0}
      ),
      end: point(
        events.length > 0
          ? events[events.length - 2][1].end
          : {line: 1, column: 1, offset: 0}
      )
    }

    // Call transforms.
    index = -1
    while (++index < config.transforms.length) {
      tree = config.transforms[index](tree) || tree
    }

    return tree
  }

  /**
   * @param {Array<Event>} events
   * @param {number} start
   * @param {number} length
   * @returns {number}
   */
  function prepareList(events, start, length) {
    let index = start - 1
    let containerBalance = -1
    let listSpread = false
    /** @type {Token | undefined} */
    let listItem
    /** @type {number | undefined} */
    let lineIndex
    /** @type {number | undefined} */
    let firstBlankLineIndex
    /** @type {boolean | undefined} */
    let atMarker

    while (++index <= length) {
      const event = events[index]

      if (
        event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.listUnordered ||
        event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.listOrdered ||
        event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.blockQuote
      ) {
        if (event[0] === 'enter') {
          containerBalance++
        } else {
          containerBalance--
        }

        atMarker = undefined
      } else if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.lineEndingBlank) {
        if (event[0] === 'enter') {
          if (
            listItem &&
            !atMarker &&
            !containerBalance &&
            !firstBlankLineIndex
          ) {
            firstBlankLineIndex = index
          }

          atMarker = undefined
        }
      } else if (
        event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.linePrefix ||
        event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.listItemValue ||
        event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.listItemMarker ||
        event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.listItemPrefix ||
        event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.listItemPrefixWhitespace
      ) {
        // Empty.
      } else {
        atMarker = undefined
      }

      if (
        (!containerBalance &&
          event[0] === 'enter' &&
          event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.listItemPrefix) ||
        (containerBalance === -1 &&
          event[0] === 'exit' &&
          (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.listUnordered ||
            event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.listOrdered))
      ) {
        if (listItem) {
          let tailIndex = index
          lineIndex = undefined

          while (tailIndex--) {
            const tailEvent = events[tailIndex]

            if (
              tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.lineEnding ||
              tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.lineEndingBlank
            ) {
              if (tailEvent[0] === 'exit') continue

              if (lineIndex) {
                events[lineIndex][1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.lineEndingBlank
                listSpread = true
              }

              tailEvent[1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.lineEnding
              lineIndex = tailIndex
            } else if (
              tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.linePrefix ||
              tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.blockQuotePrefix ||
              tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.blockQuotePrefixWhitespace ||
              tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.blockQuoteMarker ||
              tailEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.listItemIndent
            ) {
              // Empty
            } else {
              break
            }
          }

          if (
            firstBlankLineIndex &&
            (!lineIndex || firstBlankLineIndex < lineIndex)
          ) {
            listItem._spread = true
          }

          // Fix position.
          listItem.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          )

          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])
          index++
          length++
        }

        // Create a new list item.
        if (event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.listItemPrefix) {
          listItem = {
            type: 'listItem',
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: undefined
          }
          // @ts-expect-error: `listItem` is most definitely defined, TS...
          events.splice(index, 0, ['enter', listItem, event[2]])
          index++
          length++
          firstBlankLineIndex = undefined
          atMarker = true
        }
      }
    }

    events[start][1]._spread = listSpread
    return length
  }

  /**
   * Set data.
   *
   * @template {keyof CompileData} Key
   *   Field type.
   * @param {Key} key
   *   Key of field.
   * @param {CompileData[Key]} [value]
   *   New value.
   * @returns {void}
   *   Nothing.
   */
  function setData(key, value) {
    data[key] = value
  }

  /**
   * Get data.
   *
   * @template {keyof CompileData} Key
   *   Field type.
   * @param {Key} key
   *   Key of field.
   * @returns {CompileData[Key]}
   *   Value.
   */
  function getData(key) {
    return data[key]
  }

  /**
   * Create an opener handle.
   *
   * @param {(token: Token) => Node} create
   *   Create a node.
   * @param {Handle} [and]
   *   Optional function to also run.
   * @returns {Handle}
   *   Handle.
   */
  function opener(create, and) {
    return open

    /**
     * @this {CompileContext}
     * @param {Token} token
     * @returns {void}
     */
    function open(token) {
      enter.call(this, create(token), token)
      if (and) and.call(this, token)
    }
  }

  /**
   * @this {CompileContext}
   * @returns {void}
   */
  function buffer() {
    this.stack.push({type: 'fragment', children: []})
  }

  /**
   * @template {Node} Kind
   *   Node type.
   * @this {CompileContext}
   *   Context.
   * @param {Kind} node
   *   Node to enter.
   * @param {Token} token
   *   Corresponding token.
   * @param {OnEnterError | undefined} [errorHandler]
   *   Handle the case where this token is open, but it is closed by something else.
   * @returns {Kind}
   *   The given node.
   */
  function enter(node, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(parent, 'expected `parent`')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)('children' in parent, 'expected `parent`')
    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.
    parent.children.push(node)
    this.stack.push(node)
    this.tokenStack.push([token, errorHandler])
    // @ts-expect-error: `end` will be patched later.
    node.position = {start: point(token.start)}
    return node
  }

  /**
   * Create a closer handle.
   *
   * @param {Handle} [and]
   *   Optional function to also run.
   * @returns {Handle}
   *   Handle.
   */
  function closer(and) {
    return close

    /**
     * @this {CompileContext}
     * @param {Token} token
     * @returns {void}
     */
    function close(token) {
      if (and) and.call(this, token)
      exit.call(this, token)
    }
  }

  /**
   * @this {CompileContext}
   *   Context.
   * @param {Token} token
   *   Corresponding token.
   * @param {OnExitError | undefined} [onExitError]
   *   Handle the case where another token is open.
   * @returns {Node}
   *   The closed node.
   */
  function exit(token, onExitError) {
    const node = this.stack.pop()
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected `node`')
    const open = this.tokenStack.pop()

    if (!open) {
      throw new Error(
        'Cannot close `' +
          token.type +
          '` (' +
          (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_12__.stringifyPosition)({start: token.start, end: token.end}) +
          '): it’s not open'
      )
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0])
      } else {
        const handler = open[1] || defaultOnError
        handler.call(this, token, open[0])
      }
    }

    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type !== 'fragment', 'unexpected fragment `exit`ed')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.position, 'expected `position` to be defined')
    node.position.end = point(token.end)
    return node
  }

  /**
   * @this {CompileContext}
   * @returns {string}
   */
  function resume() {
    return (0,mdast_util_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(this.stack.pop())
  }

  //
  // Handlers.
  //

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterlistordered() {
    setData('expectingFirstListItemValue', true)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterlistitemvalue(token) {
    if (getData('expectingFirstListItemValue')) {
      const ancestor = this.stack[this.stack.length - 2]
      ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor, 'expected nodes on stack')
      ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor.type === 'list', 'expected list on stack')
      ancestor.start = Number.parseInt(
        this.sliceSerialize(token),
        micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_9__.constants.numericBaseDecimal
      )
      setData('expectingFirstListItemValue')
    }
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcodefencedfenceinfo() {
    const data = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'code', 'expected code on stack')
    node.lang = data
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcodefencedfencemeta() {
    const data = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'code', 'expected code on stack')
    node.meta = data
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcodefencedfence() {
    // Exit if this is the closing fence.
    if (getData('flowCodeInside')) return
    this.buffer()
    setData('flowCodeInside', true)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcodefenced() {
    const data = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'code', 'expected code on stack')

    node.value = data.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, '')
    setData('flowCodeInside')
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcodeindented() {
    const data = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'code', 'expected code on stack')

    node.value = data.replace(/(\r?\n|\r)$/g, '')
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitdefinitionlabelstring(token) {
    const label = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'definition', 'expected definition on stack')

    node.label = label
    node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_7__.normalizeIdentifier)(
      this.sliceSerialize(token)
    ).toLowerCase()
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitdefinitiontitlestring() {
    const data = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'definition', 'expected definition on stack')

    node.title = data
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitdefinitiondestinationstring() {
    const data = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'definition', 'expected definition on stack')

    node.url = data
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitatxheadingsequence(token) {
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'heading', 'expected heading on stack')

    if (!node.depth) {
      const depth = this.sliceSerialize(token).length

      ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(
        depth === 1 ||
          depth === 2 ||
          depth === 3 ||
          depth === 4 ||
          depth === 5 ||
          depth === 6,
        'expected `depth` between `1` and `6`'
      )

      node.depth = depth
    }
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitsetextheadingtext() {
    setData('setextHeadingSlurpLineEnding', true)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitsetextheadinglinesequence(token) {
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'heading', 'expected heading on stack')

    node.depth =
      this.sliceSerialize(token).charCodeAt(0) === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__.codes.equalsTo ? 1 : 2
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitsetextheading() {
    setData('setextHeadingSlurpLineEnding')
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onenterdata(token) {
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)('children' in node, 'expected parent on stack')

    let tail = node.children[node.children.length - 1]

    if (!tail || tail.type !== 'text') {
      // Add a new text node.
      tail = text()
      // @ts-expect-error: we’ll add `end` later.
      tail.position = {start: point(token.start)}
      // @ts-expect-error: Assume `parent` accepts `text`.
      node.children.push(tail)
    }

    this.stack.push(tail)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitdata(token) {
    const tail = this.stack.pop()
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail, 'expected a `node` to be on the stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)('value' in tail, 'expected a `literal` to be on the stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position, 'expected `node` to have an open position')
    tail.value += this.sliceSerialize(token)
    tail.position.end = point(token.end)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(context, 'expected `node`')

    // If we’re at a hard break, include the line ending in there.
    if (getData('atHardBreak')) {
      (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)('children' in context, 'expected `parent`')
      const tail = context.children[context.children.length - 1]
      ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position, 'expected tail to have a starting position')
      tail.position.end = point(token.end)
      setData('atHardBreak')
      return
    }

    if (
      !getData('setextHeadingSlurpLineEnding') &&
      config.canContainEols.includes(context.type)
    ) {
      onenterdata.call(this, token)
      onexitdata.call(this, token)
    }
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexithardbreak() {
    setData('atHardBreak', true)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexithtmlflow() {
    const data = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'html', 'expected html on stack')

    node.value = data
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexithtmltext() {
    const data = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'html', 'expected html on stack')

    node.value = data
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitcodetext() {
    const data = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'inlineCode', 'expected inline code on stack')

    node.value = data
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitlink() {
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'link', 'expected link on stack')

    // Note: there are also `identifier` and `label` fields on this link node!
    // These are used / cleaned here.

    // To do: clean.
    if (getData('inReference')) {
      /** @type {ReferenceType} */
      const referenceType = getData('referenceType') || 'shortcut'

      node.type += 'Reference'
      // @ts-expect-error: mutate.
      node.referenceType = referenceType
      // @ts-expect-error: mutate.
      delete node.url
      delete node.title
    } else {
      // @ts-expect-error: mutate.
      delete node.identifier
      // @ts-expect-error: mutate.
      delete node.label
    }

    setData('referenceType')
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitimage() {
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'image', 'expected image on stack')

    // Note: there are also `identifier` and `label` fields on this link node!
    // These are used / cleaned here.

    // To do: clean.
    if (getData('inReference')) {
      /** @type {ReferenceType} */
      const referenceType = getData('referenceType') || 'shortcut'

      node.type += 'Reference'
      // @ts-expect-error: mutate.
      node.referenceType = referenceType
      // @ts-expect-error: mutate.
      delete node.url
      delete node.title
    } else {
      // @ts-expect-error: mutate.
      delete node.identifier
      // @ts-expect-error: mutate.
      delete node.label
    }

    setData('referenceType')
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitlabeltext(token) {
    const string = this.sliceSerialize(token)
    const ancestor = this.stack[this.stack.length - 2]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(ancestor, 'expected ancestor on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(
      ancestor.type === 'image' || ancestor.type === 'link',
      'expected image or link on stack'
    )

    // @ts-expect-error: stash this on the node, as it might become a reference
    // later.
    ancestor.label = (0,micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_6__.decodeString)(string)
    // @ts-expect-error: same as above.
    ancestor.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_7__.normalizeIdentifier)(string).toLowerCase()
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(fragment, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(fragment.type === 'fragment', 'expected fragment on stack')
    const value = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(
      node.type === 'image' || node.type === 'link',
      'expected image or link on stack'
    )

    // Assume a reference.
    setData('inReference', true)

    if (node.type === 'link') {
      /** @type {Array<StaticPhrasingContent>} */
      // @ts-expect-error: Assume static phrasing content.
      const children = fragment.children

      node.children = children
    } else {
      node.alt = value
    }
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitresourcedestinationstring() {
    const data = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(
      node.type === 'image' || node.type === 'link',
      'expected image or link on stack'
    )
    node.url = data
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitresourcetitlestring() {
    const data = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(
      node.type === 'image' || node.type === 'link',
      'expected image or link on stack'
    )
    node.title = data
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitresource() {
    setData('inReference')
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onenterreference() {
    setData('referenceType', 'collapsed')
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitreferencestring(token) {
    const label = this.resume()
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(
      node.type === 'image' || node.type === 'link',
      'expected image reference or link reference on stack'
    )

    // @ts-expect-error: stash this on the node, as it might become a reference
    // later.
    node.label = label
    // @ts-expect-error: same as above.
    node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_7__.normalizeIdentifier)(
      this.sliceSerialize(token)
    ).toLowerCase()
    setData('referenceType', 'full')
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitcharacterreferencemarker(token) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(
      token.type === 'characterReferenceMarkerNumeric' ||
        token.type === 'characterReferenceMarkerHexadecimal'
    )
    setData('characterReferenceType', token.type)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcharacterreferencevalue(token) {
    const data = this.sliceSerialize(token)
    const type = getData('characterReferenceType')
    /** @type {string} */
    let value

    if (type) {
      value = (0,micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_5__.decodeNumericCharacterReference)(
        data,
        type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.characterReferenceMarkerNumeric
          ? micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_9__.constants.numericBaseDecimal
          : micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_9__.constants.numericBaseHexadecimal
      )
      setData('characterReferenceType')
    } else {
      const result = (0,decode_named_character_reference__WEBPACK_IMPORTED_MODULE_11__.decodeNamedCharacterReference)(data)
      ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(result !== false, 'expected reference to decode')
      value = result
    }

    const tail = this.stack.pop()
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail, 'expected `node`')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tail.position, 'expected `node.position`')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)('value' in tail, 'expected `node.value`')
    tail.value += value
    tail.position.end = point(token.end)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token)
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'link', 'expected link on stack')

    node.url = this.sliceSerialize(token)
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitautolinkemail(token) {
    onexitdata.call(this, token)
    const node = this.stack[this.stack.length - 1]
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node, 'expected node on stack')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'link', 'expected link on stack')

    node.url = 'mailto:' + this.sliceSerialize(token)
  }

  //
  // Creaters.
  //

  /** @returns {Blockquote} */
  function blockQuote() {
    return {type: 'blockquote', children: []}
  }

  /** @returns {Code} */
  function codeFlow() {
    return {type: 'code', lang: null, meta: null, value: ''}
  }

  /** @returns {InlineCode} */
  function codeText() {
    return {type: 'inlineCode', value: ''}
  }

  /** @returns {Definition} */
  function definition() {
    return {
      type: 'definition',
      identifier: '',
      label: null,
      title: null,
      url: ''
    }
  }

  /** @returns {Emphasis} */
  function emphasis() {
    return {type: 'emphasis', children: []}
  }

  /** @returns {Heading} */
  function heading() {
    // @ts-expect-error `depth` will be set later.
    return {type: 'heading', depth: undefined, children: []}
  }

  /** @returns {Break} */
  function hardBreak() {
    return {type: 'break'}
  }

  /** @returns {HTML} */
  function html() {
    return {type: 'html', value: ''}
  }

  /** @returns {Image} */
  function image() {
    return {type: 'image', title: null, url: '', alt: null}
  }

  /** @returns {Link} */
  function link() {
    return {type: 'link', title: null, url: '', children: []}
  }

  /**
   * @param {Token} token
   * @returns {List}
   */
  function list(token) {
    return {
      type: 'list',
      ordered: token.type === 'listOrdered',
      start: null,
      spread: token._spread,
      children: []
    }
  }

  /**
   * @param {Token} token
   * @returns {ListItem}
   */
  function listItem(token) {
    return {
      type: 'listItem',
      spread: token._spread,
      checked: null,
      children: []
    }
  }

  /** @returns {Paragraph} */
  function paragraph() {
    return {type: 'paragraph', children: []}
  }

  /** @returns {Strong} */
  function strong() {
    return {type: 'strong', children: []}
  }

  /** @returns {Text} */
  function text() {
    return {type: 'text', value: ''}
  }

  /** @returns {ThematicBreak} */
  function thematicBreak() {
    return {type: 'thematicBreak'}
  }
}

/**
 * Copy a point-like value.
 *
 * @param {Point} d
 *   Point-like value.
 * @returns {Point}
 *   unist point.
 */
function point(d) {
  return {line: d.line, column: d.column, offset: d.offset}
}

/**
 * @param {Config} combined
 * @param {Array<Extension | Array<Extension>>} extensions
 * @returns {void}
 */
function configure(combined, extensions) {
  let index = -1

  while (++index < extensions.length) {
    const value = extensions[index]

    if (Array.isArray(value)) {
      configure(combined, value)
    } else {
      extension(combined, value)
    }
  }
}

/**
 * @param {Config} combined
 * @param {Extension} extension
 * @returns {void}
 */
function extension(combined, extension) {
  /** @type {keyof Extension} */
  let key

  for (key in extension) {
    if (own.call(extension, key)) {
      if (key === 'canContainEols') {
        const right = extension[key]
        if (right) {
          combined[key].push(...right)
        }
      } else if (key === 'transforms') {
        const right = extension[key]
        if (right) {
          combined[key].push(...right)
        }
      } else if (key === 'enter' || key === 'exit') {
        const right = extension[key]
        if (right) {
          Object.assign(combined[key], right)
        }
      }
    }
  }
}

/** @type {OnEnterError} */
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      'Cannot close `' +
        left.type +
        '` (' +
        (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_12__.stringifyPosition)({start: left.start, end: left.end}) +
        '): a different token (`' +
        right.type +
        '`, ' +
        (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_12__.stringifyPosition)({start: right.start, end: right.end}) +
        ') is open'
    )
  } else {
    throw new Error(
      'Cannot close document, a token (`' +
        right.type +
        '`, ' +
        (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_12__.stringifyPosition)({start: right.start, end: right.end}) +
        ') is still open'
    )
  }
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/footer.js":
/*!*******************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/footer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   footer: () => (/* binding */ footer)
/* harmony export */ });
/* harmony import */ var _handlers_thematic_break_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./handlers/thematic-break.js */ "./node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js");
/* harmony import */ var _handlers_list_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./handlers/list.js */ "./node_modules/mdast-util-to-hast/lib/handlers/list.js");
/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrap.js */ "./node_modules/mdast-util-to-hast/lib/wrap.js");
/**
 * @typedef {import('mdast').BlockContent} BlockContent
 * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition
 * @typedef {import('mdast').Link} Link
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('mdast').Paragraph} Paragraph
 * @typedef {import('./index.js').H} H
 */





/**
 * @param {H} h
 */
function footer(h) {
  const footnoteById = h.footnoteById
  const footnoteOrder = h.footnoteOrder
  let index = -1
  /** @type {Array.<ListItem>} */
  const listItems = []

  while (++index < footnoteOrder.length) {
    const def = footnoteById[footnoteOrder[index].toUpperCase()]

    if (!def) {
      continue
    }

    const marker = String(index + 1)
    const content = [...def.children]
    /** @type {Link} */
    const backReference = {
      type: 'link',
      url: '#fnref' + marker,
      data: {hProperties: {className: ['footnote-back'], role: 'doc-backlink'}},
      children: [{type: 'text', value: '↩'}]
    }
    const tail = content[content.length - 1]

    if (tail && tail.type === 'paragraph') {
      tail.children.push(backReference)
    } else {
      // @ts-expect-error Indeed, link directly added in block content.
      // Which we do because that way at least the handlers will be called
      // for the other HTML we’re generating (as markdown).
      content.push(backReference)
    }

    listItems.push({
      type: 'listItem',
      data: {hProperties: {id: 'fn' + marker, role: 'doc-endnote'}},
      children: content,
      position: def.position
    })
  }

  if (listItems.length === 0) {
    return null
  }

  return h(
    null,
    'section',
    {className: ['footnotes'], role: 'doc-endnotes'},
    (0,_wrap_js__WEBPACK_IMPORTED_MODULE_2__.wrap)(
      [
        (0,_handlers_thematic_break_js__WEBPACK_IMPORTED_MODULE_0__.thematicBreak)(h),
        (0,_handlers_list_js__WEBPACK_IMPORTED_MODULE_1__.list)(h, {type: 'list', ordered: true, children: listItems})
      ],
      true
    )
  )
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/blockquote.js":
/*!********************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/blockquote.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blockquote: () => (/* binding */ blockquote)
/* harmony export */ });
/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../wrap.js */ "./node_modules/mdast-util-to-hast/lib/wrap.js");
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/**
 * @typedef {import('mdast').Blockquote} Blockquote
 * @typedef {import('../index.js').Handler} Handler
 */




/**
 * @type {Handler}
 * @param {Blockquote} node
 */
function blockquote(h, node) {
  return h(node, 'blockquote', (0,_wrap_js__WEBPACK_IMPORTED_MODULE_0__.wrap)((0,_traverse_js__WEBPACK_IMPORTED_MODULE_1__.all)(h, node), true))
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/break.js":
/*!***************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/break.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hardBreak: () => (/* binding */ hardBreak)
/* harmony export */ });
/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-builder */ "./node_modules/unist-builder/lib/index.js");
/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Text} Text
 * @typedef {import('mdast').Break} Break
 * @typedef {import('../index.js').Handler} Handler
 */



/**
 * @type {Handler}
 * @param {Break} node
 * @returns {Array<Element|Text>}
 */
function hardBreak(h, node) {
  return [h(node, 'br'), (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', '\n')]
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/code.js":
/*!**************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/code.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   code: () => (/* binding */ code)
/* harmony export */ });
/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-builder */ "./node_modules/unist-builder/lib/index.js");
/**
 * @typedef {import('mdast').Code} Code
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('../index.js').Handler} Handler
 */



/**
 * @type {Handler}
 * @param {Code} node
 */
function code(h, node) {
  const value = node.value ? node.value + '\n' : ''
  // To do: next major, use `node.lang` w/o regex, the splitting’s been going
  // on for years in remark now.
  const lang = node.lang && node.lang.match(/^[^ \t]+(?=[ \t]|$)/)
  /** @type {Properties} */
  const props = {}

  if (lang) {
    props.className = ['language-' + lang]
  }

  const code = h(node, 'code', props, [(0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', value)])

  if (node.meta) {
    code.data = {meta: node.meta}
  }

  return h(node.position, 'pre', [code])
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/delete.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/delete.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   strikethrough: () => (/* binding */ strikethrough)
/* harmony export */ });
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/**
 * @typedef {import('mdast').Delete} Delete
 * @typedef {import('../index.js').Handler} Handler
 */



/**
 * @type {Handler}
 * @param {Delete} node
 */
function strikethrough(h, node) {
  return h(node, 'del', (0,_traverse_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node))
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/emphasis.js":
/*!******************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/emphasis.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   emphasis: () => (/* binding */ emphasis)
/* harmony export */ });
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/**
 * @typedef {import('mdast').Emphasis} Emphasis
 * @typedef {import('../index.js').Handler} Handler
 */



/**
 * @type {Handler}
 * @param {Emphasis} node
 */
function emphasis(h, node) {
  return h(node, 'em', (0,_traverse_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node))
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   footnoteReference: () => (/* binding */ footnoteReference)
/* harmony export */ });
/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-builder */ "./node_modules/unist-builder/lib/index.js");
/**
 * @typedef {import('mdast').FootnoteReference} FootnoteReference
 * @typedef {import('../index.js').Handler} Handler
 */



/**
 * @type {Handler}
 * @param {FootnoteReference} node
 */
function footnoteReference(h, node) {
  const footnoteOrder = h.footnoteOrder
  const identifier = String(node.identifier)
  const index = footnoteOrder.indexOf(identifier)
  const marker = String(
    index === -1 ? footnoteOrder.push(identifier) : index + 1
  )

  return h(
    node,
    'a',
    {
      href: '#fn' + marker,
      className: ['footnote-ref'],
      id: 'fnref' + marker,
      role: 'doc-noteref'
    },
    [h(node.position, 'sup', [(0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', marker)])]
  )
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/footnote.js":
/*!******************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/footnote.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   footnote: () => (/* binding */ footnote)
/* harmony export */ });
/* harmony import */ var _footnote_reference_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./footnote-reference.js */ "./node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js");
/**
 * @typedef {import('mdast').Footnote} Footnote
 * @typedef {import('../index.js').Handler} Handler
 */



/**
 * @type {Handler}
 * @param {Footnote} node
 */
function footnote(h, node) {
  const footnoteById = h.footnoteById
  const footnoteOrder = h.footnoteOrder
  let no = 1

  while (no in footnoteById) no++

  const identifier = String(no)

  // No need to check if `identifier` exists in `footnoteOrder`, it’s guaranteed
  // to not exist because we just generated it.
  footnoteOrder.push(identifier)

  footnoteById[identifier] = {
    type: 'footnoteDefinition',
    identifier,
    children: [{type: 'paragraph', children: node.children}],
    position: node.position
  }

  return (0,_footnote_reference_js__WEBPACK_IMPORTED_MODULE_0__.footnoteReference)(h, {
    type: 'footnoteReference',
    identifier,
    position: node.position
  })
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/heading.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/heading.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   heading: () => (/* binding */ heading)
/* harmony export */ });
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/**
 * @typedef {import('mdast').Heading} Heading
 * @typedef {import('../index.js').Handler} Handler
 */



/**
 * @type {Handler}
 * @param {Heading} node
 */
function heading(h, node) {
  return h(node, 'h' + node.depth, (0,_traverse_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node))
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/html.js":
/*!**************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/html.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   html: () => (/* binding */ html)
/* harmony export */ });
/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-builder */ "./node_modules/unist-builder/lib/index.js");
/**
 * @typedef {import('mdast').HTML} HTML
 * @typedef {import('../index.js').Handler} Handler
 */



/**
 * Return either a `raw` node in dangerous mode, otherwise nothing.
 *
 * @type {Handler}
 * @param {HTML} node
 */
function html(h, node) {
  return h.dangerous ? h.augment(node, (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('raw', node.value)) : null
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/image-reference.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/image-reference.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   imageReference: () => (/* binding */ imageReference)
/* harmony export */ });
/* harmony import */ var mdurl_encode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mdurl/encode.js */ "./node_modules/mdurl/encode.js");
/* harmony import */ var _revert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../revert.js */ "./node_modules/mdast-util-to-hast/lib/revert.js");
/**
 * @typedef {import('mdast').ImageReference} ImageReference
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('../index.js').Handler} Handler
 */




/**
 * @type {Handler}
 * @param {ImageReference} node
 */
function imageReference(h, node) {
  const def = h.definition(node.identifier)

  if (!def) {
    return (0,_revert_js__WEBPACK_IMPORTED_MODULE_1__.revert)(h, node)
  }

  /** @type {Properties} */
  const props = {src: mdurl_encode_js__WEBPACK_IMPORTED_MODULE_0__(def.url || ''), alt: node.alt}

  if (def.title !== null && def.title !== undefined) {
    props.title = def.title
  }

  return h(node, 'img', props)
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/image.js":
/*!***************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/image.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   image: () => (/* binding */ image)
/* harmony export */ });
/* harmony import */ var mdurl_encode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mdurl/encode.js */ "./node_modules/mdurl/encode.js");
/**
 * @typedef {import('mdast').Image} Image
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('../index.js').Handler} Handler
 */



/**
 * @type {Handler}
 * @param {Image} node
 */
function image(h, node) {
  /** @type {Properties} */
  const props = {src: mdurl_encode_js__WEBPACK_IMPORTED_MODULE_0__(node.url), alt: node.alt}

  if (node.title !== null && node.title !== undefined) {
    props.title = node.title
  }

  return h(node, 'img', props)
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   handlers: () => (/* binding */ handlers)
/* harmony export */ });
/* harmony import */ var _blockquote_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blockquote.js */ "./node_modules/mdast-util-to-hast/lib/handlers/blockquote.js");
/* harmony import */ var _break_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./break.js */ "./node_modules/mdast-util-to-hast/lib/handlers/break.js");
/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./code.js */ "./node_modules/mdast-util-to-hast/lib/handlers/code.js");
/* harmony import */ var _delete_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./delete.js */ "./node_modules/mdast-util-to-hast/lib/handlers/delete.js");
/* harmony import */ var _emphasis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./emphasis.js */ "./node_modules/mdast-util-to-hast/lib/handlers/emphasis.js");
/* harmony import */ var _footnote_reference_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./footnote-reference.js */ "./node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js");
/* harmony import */ var _footnote_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./footnote.js */ "./node_modules/mdast-util-to-hast/lib/handlers/footnote.js");
/* harmony import */ var _heading_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./heading.js */ "./node_modules/mdast-util-to-hast/lib/handlers/heading.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./html.js */ "./node_modules/mdast-util-to-hast/lib/handlers/html.js");
/* harmony import */ var _image_reference_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./image-reference.js */ "./node_modules/mdast-util-to-hast/lib/handlers/image-reference.js");
/* harmony import */ var _image_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./image.js */ "./node_modules/mdast-util-to-hast/lib/handlers/image.js");
/* harmony import */ var _inline_code_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./inline-code.js */ "./node_modules/mdast-util-to-hast/lib/handlers/inline-code.js");
/* harmony import */ var _link_reference_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./link-reference.js */ "./node_modules/mdast-util-to-hast/lib/handlers/link-reference.js");
/* harmony import */ var _link_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./link.js */ "./node_modules/mdast-util-to-hast/lib/handlers/link.js");
/* harmony import */ var _list_item_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./list-item.js */ "./node_modules/mdast-util-to-hast/lib/handlers/list-item.js");
/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./list.js */ "./node_modules/mdast-util-to-hast/lib/handlers/list.js");
/* harmony import */ var _paragraph_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./paragraph.js */ "./node_modules/mdast-util-to-hast/lib/handlers/paragraph.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./root.js */ "./node_modules/mdast-util-to-hast/lib/handlers/root.js");
/* harmony import */ var _strong_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./strong.js */ "./node_modules/mdast-util-to-hast/lib/handlers/strong.js");
/* harmony import */ var _table_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./table.js */ "./node_modules/mdast-util-to-hast/lib/handlers/table.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./text.js */ "./node_modules/mdast-util-to-hast/lib/handlers/text.js");
/* harmony import */ var _thematic_break_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./thematic-break.js */ "./node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js");























const handlers = {
  blockquote: _blockquote_js__WEBPACK_IMPORTED_MODULE_0__.blockquote,
  break: _break_js__WEBPACK_IMPORTED_MODULE_1__.hardBreak,
  code: _code_js__WEBPACK_IMPORTED_MODULE_2__.code,
  delete: _delete_js__WEBPACK_IMPORTED_MODULE_3__.strikethrough,
  emphasis: _emphasis_js__WEBPACK_IMPORTED_MODULE_4__.emphasis,
  footnoteReference: _footnote_reference_js__WEBPACK_IMPORTED_MODULE_5__.footnoteReference,
  footnote: _footnote_js__WEBPACK_IMPORTED_MODULE_6__.footnote,
  heading: _heading_js__WEBPACK_IMPORTED_MODULE_7__.heading,
  html: _html_js__WEBPACK_IMPORTED_MODULE_8__.html,
  imageReference: _image_reference_js__WEBPACK_IMPORTED_MODULE_9__.imageReference,
  image: _image_js__WEBPACK_IMPORTED_MODULE_10__.image,
  inlineCode: _inline_code_js__WEBPACK_IMPORTED_MODULE_11__.inlineCode,
  linkReference: _link_reference_js__WEBPACK_IMPORTED_MODULE_12__.linkReference,
  link: _link_js__WEBPACK_IMPORTED_MODULE_13__.link,
  listItem: _list_item_js__WEBPACK_IMPORTED_MODULE_14__.listItem,
  list: _list_js__WEBPACK_IMPORTED_MODULE_15__.list,
  paragraph: _paragraph_js__WEBPACK_IMPORTED_MODULE_16__.paragraph,
  root: _root_js__WEBPACK_IMPORTED_MODULE_17__.root,
  strong: _strong_js__WEBPACK_IMPORTED_MODULE_18__.strong,
  table: _table_js__WEBPACK_IMPORTED_MODULE_19__.table,
  text: _text_js__WEBPACK_IMPORTED_MODULE_20__.text,
  thematicBreak: _thematic_break_js__WEBPACK_IMPORTED_MODULE_21__.thematicBreak,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
}

// Return nothing for nodes that are ignored.
function ignore() {
  return null
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/inline-code.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/inline-code.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inlineCode: () => (/* binding */ inlineCode)
/* harmony export */ });
/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-builder */ "./node_modules/unist-builder/lib/index.js");
/**
 * @typedef {import('mdast').InlineCode} InlineCode
 * @typedef {import('../index.js').Handler} Handler
 */



/**
 * @type {Handler}
 * @param {InlineCode} node
 */
function inlineCode(h, node) {
  return h(node, 'code', [(0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', node.value.replace(/\r?\n|\r/g, ' '))])
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/link-reference.js":
/*!************************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/link-reference.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   linkReference: () => (/* binding */ linkReference)
/* harmony export */ });
/* harmony import */ var mdurl_encode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mdurl/encode.js */ "./node_modules/mdurl/encode.js");
/* harmony import */ var _revert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../revert.js */ "./node_modules/mdast-util-to-hast/lib/revert.js");
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/**
 * @typedef {import('mdast').LinkReference} LinkReference
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('../index.js').Handler} Handler
 */





/**
 * @type {Handler}
 * @param {LinkReference} node
 */
function linkReference(h, node) {
  const def = h.definition(node.identifier)

  if (!def) {
    return (0,_revert_js__WEBPACK_IMPORTED_MODULE_1__.revert)(h, node)
  }

  /** @type {Properties} */
  const props = {href: mdurl_encode_js__WEBPACK_IMPORTED_MODULE_0__(def.url || '')}

  if (def.title !== null && def.title !== undefined) {
    props.title = def.title
  }

  return h(node, 'a', props, (0,_traverse_js__WEBPACK_IMPORTED_MODULE_2__.all)(h, node))
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/link.js":
/*!**************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/link.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   link: () => (/* binding */ link)
/* harmony export */ });
/* harmony import */ var mdurl_encode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mdurl/encode.js */ "./node_modules/mdurl/encode.js");
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/**
 * @typedef {import('mdast').Link} Link
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('../index.js').Handler} Handler
 */




/**
 * @type {Handler}
 * @param {Link} node
 */
function link(h, node) {
  /** @type {Properties} */
  const props = {href: mdurl_encode_js__WEBPACK_IMPORTED_MODULE_0__(node.url)}

  if (node.title !== null && node.title !== undefined) {
    props.title = node.title
  }

  return h(node, 'a', props, (0,_traverse_js__WEBPACK_IMPORTED_MODULE_1__.all)(h, node))
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/list-item.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/list-item.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   listItem: () => (/* binding */ listItem)
/* harmony export */ });
/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-builder */ "./node_modules/unist-builder/lib/index.js");
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/**
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('mdast').List} List
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('hast').Element} Element
 * @typedef {import('../index.js').Handler} Handler
 * @typedef {import('../index.js').Content} Content
 */




/**
 * @type {Handler}
 * @param {ListItem} node
 * @param {List} parent
 */
function listItem(h, node, parent) {
  const result = (0,_traverse_js__WEBPACK_IMPORTED_MODULE_1__.all)(h, node)
  const loose = parent ? listLoose(parent) : listItemLoose(node)
  /** @type {Properties} */
  const props = {}
  /** @type {Array.<Content>} */
  const wrapped = []

  if (typeof node.checked === 'boolean') {
    /** @type {Element} */
    let paragraph

    if (
      result[0] &&
      result[0].type === 'element' &&
      result[0].tagName === 'p'
    ) {
      paragraph = result[0]
    } else {
      paragraph = h(null, 'p', [])
      result.unshift(paragraph)
    }

    if (paragraph.children.length > 0) {
      paragraph.children.unshift((0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', ' '))
    }

    paragraph.children.unshift(
      h(null, 'input', {
        type: 'checkbox',
        checked: node.checked,
        disabled: true
      })
    )

    // According to github-markdown-css, this class hides bullet.
    // See: <https://github.com/sindresorhus/github-markdown-css>.
    props.className = ['task-list-item']
  }

  let index = -1

  while (++index < result.length) {
    const child = result[index]

    // Add eols before nodes, except if this is a loose, first paragraph.
    if (
      loose ||
      index !== 0 ||
      child.type !== 'element' ||
      child.tagName !== 'p'
    ) {
      wrapped.push((0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', '\n'))
    }

    if (child.type === 'element' && child.tagName === 'p' && !loose) {
      wrapped.push(...child.children)
    } else {
      wrapped.push(child)
    }
  }

  const tail = result[result.length - 1]

  // Add a final eol.
  if (tail && (loose || !('tagName' in tail) || tail.tagName !== 'p')) {
    wrapped.push((0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', '\n'))
  }

  return h(node, 'li', props, wrapped)
}

/**
 * @param {List} node
 * @return {Boolean}
 */
function listLoose(node) {
  let loose = node.spread
  const children = node.children
  let index = -1

  while (!loose && ++index < children.length) {
    loose = listItemLoose(children[index])
  }

  return Boolean(loose)
}

/**
 * @param {ListItem} node
 * @return {Boolean}
 */
function listItemLoose(node) {
  const spread = node.spread

  return spread === undefined || spread === null
    ? node.children.length > 1
    : spread
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/list.js":
/*!**************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/list.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   list: () => (/* binding */ list)
/* harmony export */ });
/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../wrap.js */ "./node_modules/mdast-util-to-hast/lib/wrap.js");
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/**
 * @typedef {import('mdast').List} List
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('../index.js').Handler} Handler
 */




/**
 * @type {Handler}
 * @param {List} node
 * @returns {Element}
 */
function list(h, node) {
  /** @type {Properties} */
  const props = {}
  const name = node.ordered ? 'ol' : 'ul'
  const items = (0,_traverse_js__WEBPACK_IMPORTED_MODULE_1__.all)(h, node)
  let index = -1

  if (typeof node.start === 'number' && node.start !== 1) {
    props.start = node.start
  }

  // Like GitHub, add a class for custom styling.
  while (++index < items.length) {
    const item = items[index]

    if (
      item.type === 'element' &&
      item.tagName === 'li' &&
      item.properties &&
      Array.isArray(item.properties.className) &&
      item.properties.className.includes('task-list-item')
    ) {
      props.className = ['contains-task-list']
      break
    }
  }

  return h(node, name, props, (0,_wrap_js__WEBPACK_IMPORTED_MODULE_0__.wrap)(items, true))
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/paragraph.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/paragraph.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   paragraph: () => (/* binding */ paragraph)
/* harmony export */ });
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/**
 * @typedef {import('mdast').Paragraph} Paragraph
 * @typedef {import('../index.js').Handler} Handler
 */



/**
 * @type {Handler}
 * @param {Paragraph} node
 */
function paragraph(h, node) {
  return h(node, 'p', (0,_traverse_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node))
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/root.js":
/*!**************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/root.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-builder */ "./node_modules/unist-builder/lib/index.js");
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../wrap.js */ "./node_modules/mdast-util-to-hast/lib/wrap.js");
/**
 * @typedef {import('mdast').Root} Root
 * @typedef {import('../index.js').Handler} Handler
 */





/**
 * @type {Handler}
 * @param {Root} node
 */
function root(h, node) {
  // @ts-expect-error `root`s are also fine.
  return h.augment(node, (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('root', (0,_wrap_js__WEBPACK_IMPORTED_MODULE_2__.wrap)((0,_traverse_js__WEBPACK_IMPORTED_MODULE_1__.all)(h, node))))
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/strong.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/strong.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   strong: () => (/* binding */ strong)
/* harmony export */ });
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/**
 * @typedef {import('mdast').Strong} Strong
 * @typedef {import('../index.js').Handler} Handler
 */



/**
 * @type {Handler}
 * @param {Strong} node
 */
function strong(h, node) {
  return h(node, 'strong', (0,_traverse_js__WEBPACK_IMPORTED_MODULE_0__.all)(h, node))
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/table.js":
/*!***************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/table.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   table: () => (/* binding */ table)
/* harmony export */ });
/* harmony import */ var unist_util_position__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-position */ "./node_modules/unist-util-position/lib/index.js");
/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wrap.js */ "./node_modules/mdast-util-to-hast/lib/wrap.js");
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/**
 * @typedef {import('mdast').Table} Table
 * @typedef {import('mdast').TableCell} TableCell
 * @typedef {import('hast').Element} Element
 * @typedef {import('../index.js').Handler} Handler
 * @typedef {import('../index.js').Content} Content
 */





/**
 * @type {Handler}
 * @param {Table} node
 */
function table(h, node) {
  const rows = node.children
  let index = -1
  const align = node.align || []
  /** @type {Array.<Element>} */
  const result = []

  while (++index < rows.length) {
    const row = rows[index].children
    const name = index === 0 ? 'th' : 'td'
    let pos = node.align ? align.length : row.length
    /** @type {Array.<Content>} */
    const out = []

    while (pos--) {
      const cell = row[pos]
      out[pos] = h(cell, name, {align: align[pos]}, cell ? (0,_traverse_js__WEBPACK_IMPORTED_MODULE_2__.all)(h, cell) : [])
    }

    result[index] = h(rows[index], 'tr', (0,_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(out, true))
  }

  return h(
    node,
    'table',
    (0,_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(
      [h(result[0].position, 'thead', (0,_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)([result[0]], true))].concat(
        result[1]
          ? h(
              {
                start: (0,unist_util_position__WEBPACK_IMPORTED_MODULE_0__.pointStart)(result[1]),
                end: (0,unist_util_position__WEBPACK_IMPORTED_MODULE_0__.pointEnd)(result[result.length - 1])
              },
              'tbody',
              (0,_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(result.slice(1), true)
            )
          : []
      ),
      true
    )
  )
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/text.js":
/*!**************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/text.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   text: () => (/* binding */ text)
/* harmony export */ });
/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-builder */ "./node_modules/unist-builder/lib/index.js");
/**
 * @typedef {import('mdast').Text} Text
 * @typedef {import('../index.js').Handler} Handler
 */



/**
 * @type {Handler}
 * @param {Text} node
 */
function text(h, node) {
  return h.augment(
    node,
    (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', String(node.value).replace(/[ \t]*(\r?\n|\r)[ \t]*/g, '$1'))
  )
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js":
/*!************************************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   thematicBreak: () => (/* binding */ thematicBreak)
/* harmony export */ });
/**
 * @typedef {import('mdast').ThematicBreak} ThematicBreak
 * @typedef {import('hast').Element} Element
 * @typedef {import('../index.js').Handler} Handler
 */

/**
 * @type {Handler}
 * @param {ThematicBreak} [node]
 * @returns {Element}
 */
function thematicBreak(h, node) {
  return h(node, 'hr')
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toHast: () => (/* binding */ toHast)
/* harmony export */ });
/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-builder */ "./node_modules/unist-builder/lib/index.js");
/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-visit */ "./node_modules/unist-util-visit/lib/index.js");
/* harmony import */ var unist_util_position__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-util-position */ "./node_modules/unist-util-position/lib/index.js");
/* harmony import */ var unist_util_generated__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unist-util-generated */ "./node_modules/unist-util-generated/lib/index.js");
/* harmony import */ var mdast_util_definitions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! mdast-util-definitions */ "./node_modules/mdast-util-definitions/lib/index.js");
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/* harmony import */ var _footer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./footer.js */ "./node_modules/mdast-util-to-hast/lib/footer.js");
/* harmony import */ var _handlers_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./handlers/index.js */ "./node_modules/mdast-util-to-hast/lib/handlers/index.js");
/**
 * @typedef {import('mdast').Root|import('mdast').Parent['children'][number]} MdastNode
 * @typedef {import('hast').Root|import('hast').Parent['children'][number]} HastNode
 * @typedef {import('mdast').Parent} Parent
 * @typedef {import('mdast').Definition} Definition
 * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('hast').Text} Text
 * @typedef {import('hast').Comment} Comment
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').ElementContent} Content
 * @typedef {import('unist-util-position').PositionLike} PositionLike
 *
 * @typedef EmbeddedHastFields
 * @property {string} [hName] Defines the tag name of an element
 * @property {Properties} [hProperties] Defines the properties of an element
 * @property {Array.<Content>} [hChildren] Defines the (hast) children of an element
 *
 * @typedef {Object.<string, unknown> & EmbeddedHastFields} Data unist data with embedded hast fields
 *
 * @typedef {MdastNode & {data?: Data}} NodeWithData unist node with embedded hast data
 *
 * @callback Handler
 * @param {H} h Handle context
 * @param {any} node mdast node to handle
 * @param {Parent|null} parent Parent of `node`
 * @returns {Content|Array.<Content>|null|undefined} hast node
 *
 * @callback HFunctionProps
 * @param {MdastNode|PositionLike|null|undefined} node mdast node or unist position
 * @param {string} tagName HTML tag name
 * @param {Properties} props Properties
 * @param {Array.<Content>?} [children] hast content
 * @returns {Element}
 *
 * @callback HFunctionNoProps
 * @param {MdastNode|PositionLike|null|undefined} node mdast node or unist position
 * @param {string} tagName HTML tag name
 * @param {Array.<Content>?} [children] hast content
 * @returns {Element}
 *
 * @typedef HFields
 * @property {boolean} dangerous Whether HTML is allowed
 * @property {(identifier: string) => Definition|null} definition Definition cache
 * @property {Object.<string, FootnoteDefinition>} footnoteById Footnote cache
 * @property {Array.<string>} footnoteOrder Order in which footnotes occur
 * @property {Handlers} handlers Applied handlers
 * @property {Handler} unknownHandler Handler for any none not in `passThrough` or otherwise handled
 * @property {(left: NodeWithData|PositionLike|null|undefined, right: Content) => Content} augment Like `h` but lower-level and usable on non-elements.
 * @property {Array.<string>} passThrough List of node types to pass through untouched (except for their children).
 *
 * @typedef Options
 * @property {boolean} [allowDangerousHtml=false] Whether to allow `html` nodes and inject them as `raw` HTML
 * @property {Handlers} [handlers] Object mapping mdast nodes to functions handling them
 * @property {Array.<string>} [passThrough] List of custom mdast node types to pass through (keep) in hast
 * @property {Handler} [unknownHandler] Handler for all unknown nodes.
 *
 * @typedef {Record.<string, Handler>} Handlers Map of node types to handlers
 * @typedef {HFunctionProps & HFunctionNoProps & HFields} H Handle context
 */










const own = {}.hasOwnProperty

/**
 * Factory to transform.
 * @param {MdastNode} tree mdast node
 * @param {Options} [options] Configuration
 * @returns {H} `h` function
 */
function factory(tree, options) {
  const settings = options || {}
  const dangerous = settings.allowDangerousHtml || false
  /** @type {Object.<string, FootnoteDefinition>} */
  const footnoteById = {}

  h.dangerous = dangerous
  h.definition = (0,mdast_util_definitions__WEBPACK_IMPORTED_MODULE_4__.definitions)(tree)
  h.footnoteById = footnoteById
  /** @type {Array.<string>} */
  h.footnoteOrder = []
  h.augment = augment
  h.handlers = {..._handlers_index_js__WEBPACK_IMPORTED_MODULE_7__.handlers, ...settings.handlers}
  h.unknownHandler = settings.unknownHandler
  h.passThrough = settings.passThrough

  ;(0,unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.visit)(tree, 'footnoteDefinition', (definition) => {
    const id = String(definition.identifier).toUpperCase()

    // Mimick CM behavior of link definitions.
    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.
    if (!own.call(footnoteById, id)) {
      footnoteById[id] = definition
    }
  })

  // @ts-expect-error Hush, it’s fine!
  return h

  /**
   * Finalise the created `right`, a hast node, from `left`, an mdast node.
   * @param {(NodeWithData|PositionLike)?} left
   * @param {Content} right
   * @returns {Content}
   */
  function augment(left, right) {
    // Handle `data.hName`, `data.hProperties, `data.hChildren`.
    if (left && 'data' in left && left.data) {
      /** @type {Data} */
      const data = left.data

      if (data.hName) {
        if (right.type !== 'element') {
          right = {
            type: 'element',
            tagName: '',
            properties: {},
            children: []
          }
        }

        right.tagName = data.hName
      }

      if (right.type === 'element' && data.hProperties) {
        right.properties = {...right.properties, ...data.hProperties}
      }

      if ('children' in right && right.children && data.hChildren) {
        right.children = data.hChildren
      }
    }

    if (left) {
      const ctx = 'type' in left ? left : {position: left}

      if (!(0,unist_util_generated__WEBPACK_IMPORTED_MODULE_3__.generated)(ctx)) {
        right.position = {start: (0,unist_util_position__WEBPACK_IMPORTED_MODULE_2__.pointStart)(ctx), end: (0,unist_util_position__WEBPACK_IMPORTED_MODULE_2__.pointEnd)(ctx)}
      }
    }

    return right
  }

  /**
   * Create an element for `node`.
   *
   * @type {HFunctionProps}
   */
  function h(node, tagName, props, children) {
    if (Array.isArray(props)) {
      children = props
      props = {}
    }

    // @ts-expect-error augmenting an element yields an element.
    return augment(node, {
      type: 'element',
      tagName,
      properties: props || {},
      children: children || []
    })
  }
}

/**
 * Transform `tree` (an mdast node) to a hast node.
 *
 * @param {MdastNode} tree mdast node
 * @param {Options} [options] Configuration
 * @returns {HastNode|null|undefined} hast node
 */
function toHast(tree, options) {
  const h = factory(tree, options)
  const node = (0,_traverse_js__WEBPACK_IMPORTED_MODULE_5__.one)(h, tree, null)
  const foot = (0,_footer_js__WEBPACK_IMPORTED_MODULE_6__.footer)(h)

  if (foot) {
    // @ts-expect-error If there’s a footer, there were definitions, meaning block
    // content.
    // So assume `node` is a parent node.
    node.children.push((0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', '\n'), foot)
  }

  return Array.isArray(node) ? {type: 'root', children: node} : node
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/revert.js":
/*!*******************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/revert.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   revert: () => (/* binding */ revert)
/* harmony export */ });
/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-builder */ "./node_modules/unist-builder/lib/index.js");
/* harmony import */ var _traverse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./traverse.js */ "./node_modules/mdast-util-to-hast/lib/traverse.js");
/**
 * @typedef {import('mdast').LinkReference} LinkReference
 * @typedef {import('mdast').ImageReference} ImageReference
 * @typedef {import('./index.js').Handler} Handler
 * @typedef {import('./index.js').Content} Content
 */




/**
 * Return the content of a reference without definition as plain text.
 *
 * @type {Handler}
 * @param {ImageReference|LinkReference} node
 * @returns {Content|Array.<Content>}
 */
function revert(h, node) {
  const subtype = node.referenceType
  let suffix = ']'

  if (subtype === 'collapsed') {
    suffix += '[]'
  } else if (subtype === 'full') {
    suffix += '[' + (node.label || node.identifier) + ']'
  }

  if (node.type === 'imageReference') {
    return (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', '![' + node.alt + suffix)
  }

  const contents = (0,_traverse_js__WEBPACK_IMPORTED_MODULE_1__.all)(h, node)
  const head = contents[0]

  if (head && head.type === 'text') {
    head.value = '[' + head.value
  } else {
    contents.unshift((0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', '['))
  }

  const tail = contents[contents.length - 1]

  if (tail && tail.type === 'text') {
    tail.value += suffix
  } else {
    contents.push((0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', suffix))
  }

  return contents
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/traverse.js":
/*!*********************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/traverse.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   all: () => (/* binding */ all),
/* harmony export */   one: () => (/* binding */ one)
/* harmony export */ });
/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-builder */ "./node_modules/unist-builder/lib/index.js");
/**
 * @typedef {import('mdast').Root|import('mdast').Parent['children'][number]} MdastNode
 * @typedef {import('./index.js').H} H
 * @typedef {import('./index.js').Handler} Handler
 * @typedef {import('./index.js').Content} Content
 */



const own = {}.hasOwnProperty

/**
 * Transform an unknown node.
 * @type {Handler}
 * @param {MdastNode} node
 */
function unknown(h, node) {
  const data = node.data || {}

  if (
    'value' in node &&
    !(
      own.call(data, 'hName') ||
      own.call(data, 'hProperties') ||
      own.call(data, 'hChildren')
    )
  ) {
    return h.augment(node, (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', node.value))
  }

  return h(node, 'div', all(h, node))
}

/**
 * @type {Handler}
 * @param {MdastNode} node
 */
function one(h, node, parent) {
  const type = node && node.type
  /** @type {Handler} */
  let fn

  // Fail on non-nodes.
  if (!type) {
    throw new Error('Expected node, got `' + node + '`')
  }

  if (own.call(h.handlers, type)) {
    fn = h.handlers[type]
  } else if (h.passThrough && h.passThrough.includes(type)) {
    fn = returnNode
  } else {
    fn = h.unknownHandler
  }

  return (typeof fn === 'function' ? fn : unknown)(h, node, parent)
}

/**
 * @type {Handler}
 * @param {MdastNode} node
 */
function returnNode(h, node) {
  // @ts-expect-error: Pass through custom node.
  return 'children' in node ? {...node, children: all(h, node)} : node
}

/**
 * @param {H} h
 * @param {MdastNode} parent
 */
function all(h, parent) {
  /** @type {Array.<Content>} */
  const values = []

  if ('children' in parent) {
    const nodes = parent.children
    let index = -1

    while (++index < nodes.length) {
      const result = one(h, nodes[index], parent)

      if (result) {
        if (index && nodes[index - 1].type === 'break') {
          if (!Array.isArray(result) && result.type === 'text') {
            result.value = result.value.replace(/^\s+/, '')
          }

          if (!Array.isArray(result) && result.type === 'element') {
            const head = result.children[0]

            if (head && head.type === 'text') {
              head.value = head.value.replace(/^\s+/, '')
            }
          }
        }

        if (Array.isArray(result)) {
          values.push(...result)
        } else {
          values.push(result)
        }
      }
    }
  }

  return values
}


/***/ }),

/***/ "./node_modules/mdast-util-to-hast/lib/wrap.js":
/*!*****************************************************!*\
  !*** ./node_modules/mdast-util-to-hast/lib/wrap.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   wrap: () => (/* binding */ wrap)
/* harmony export */ });
/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-builder */ "./node_modules/unist-builder/lib/index.js");
/**
 * @typedef {import('./index.js').Content} Content
 */



/**
 * Wrap `nodes` with line feeds between each entry.
 * Optionally adds line feeds at the start and end.
 *
 * @param {Array.<Content>} nodes
 * @param {boolean} [loose=false]
 * @returns {Array.<Content>}
 */
function wrap(nodes, loose) {
  /** @type {Array.<Content>} */
  const result = []
  let index = -1

  if (loose) {
    result.push((0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', '\n'))
  }

  while (++index < nodes.length) {
    if (index) result.push((0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', '\n'))
    result.push(nodes[index])
  }

  if (loose && nodes.length > 0) {
    result.push((0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)('text', '\n'))
  }

  return result
}


/***/ }),

/***/ "./node_modules/mdast-util-to-string/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/mdast-util-to-string/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toString: () => (/* binding */ toString)
/* harmony export */ });
/**
 * @typedef {import('mdast').Root|import('mdast').Content} Node
 *
 * @typedef Options
 *   Configuration (optional).
 * @property {boolean | null | undefined} [includeImageAlt=true]
 *   Whether to use `alt` for `image`s.
 * @property {boolean | null | undefined} [includeHtml=true]
 *   Whether to use `value` of HTML.
 */

/** @type {Options} */
const emptyOptions = {}

/**
 * Get the text content of a node or list of nodes.
 *
 * Prefers the node’s plain-text fields, otherwise serializes its children,
 * and if the given value is an array, serialize the nodes in it.
 *
 * @param {unknown} value
 *   Thing to serialize, typically `Node`.
 * @param {Options | null | undefined} [options]
 *   Configuration (optional).
 * @returns {string}
 *   Serialized `value`.
 */
function toString(value, options) {
  const settings = options || emptyOptions
  const includeImageAlt =
    typeof settings.includeImageAlt === 'boolean'
      ? settings.includeImageAlt
      : true
  const includeHtml =
    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true

  return one(value, includeImageAlt, includeHtml)
}

/**
 * One node or several nodes.
 *
 * @param {unknown} value
 *   Thing to serialize.
 * @param {boolean} includeImageAlt
 *   Include image `alt`s.
 * @param {boolean} includeHtml
 *   Include HTML.
 * @returns {string}
 *   Serialized node.
 */
function one(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ('value' in value) {
      return value.type === 'html' && !includeHtml ? '' : value.value
    }

    if (includeImageAlt && 'alt' in value && value.alt) {
      return value.alt
    }

    if ('children' in value) {
      return all(value.children, includeImageAlt, includeHtml)
    }
  }

  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml)
  }

  return ''
}

/**
 * Serialize a list of nodes.
 *
 * @param {Array<unknown>} values
 *   Thing to serialize.
 * @param {boolean} includeImageAlt
 *   Include image `alt`s.
 * @param {boolean} includeHtml
 *   Include HTML.
 * @returns {string}
 *   Serialized nodes.
 */
function all(values, includeImageAlt, includeHtml) {
  /** @type {Array<string>} */
  const result = []
  let index = -1

  while (++index < values.length) {
    result[index] = one(values[index], includeImageAlt, includeHtml)
  }

  return result.join('')
}

/**
 * Check if `value` looks like a node.
 *
 * @param {unknown} value
 *   Thing.
 * @returns {value is Node}
 *   Whether `value` is a node.
 */
function node(value) {
  return Boolean(value && typeof value === 'object')
}


/***/ }),

/***/ "./node_modules/mdurl/encode.js":
/*!**************************************!*\
  !*** ./node_modules/mdurl/encode.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";




var encodeCache = {};


// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) { return cache; }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}


// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i, l, code, nextCode, cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped  = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";


module.exports = encode;


/***/ }),

/***/ "./node_modules/memoize-one/dist/memoize-one.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/memoize-one/dist/memoize-one.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ memoizeOne)
/* harmony export */ });
var safeIsNaN = Number.isNaN ||
    function ponyfill(value) {
        return typeof value === 'number' && value !== value;
    };
function isEqual(first, second) {
    if (first === second) {
        return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
        return true;
    }
    return false;
}
function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (!isEqual(newInputs[i], lastInputs[i])) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var cache = null;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {
            return cache.lastResult;
        }
        var lastResult = resultFn.apply(this, newArgs);
        cache = {
            lastResult: lastResult,
            lastArgs: newArgs,
            lastThis: this,
        };
        return lastResult;
    }
    memoized.clear = function clear() {
        cache = null;
    };
    return memoized;
}




/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/attention.js":
/*!*********************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/attention.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attention: () => (/* binding */ attention)
/* harmony export */ });
/* harmony import */ var micromark_util_chunked__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-chunked */ "./node_modules/micromark-util-chunked/dev/index.js");
/* harmony import */ var micromark_util_classify_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-classify-character */ "./node_modules/micromark-util-classify-character/dev/index.js");
/* harmony import */ var micromark_util_resolve_all__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-resolve-all */ "./node_modules/micromark-util-resolve-all/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Point} Point
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */









/** @type {Construct} */
const attention = {
  name: 'attention',
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
}

/**
 * Take all events and resolve attention to emphasis or strong.
 *
 * @type {Resolver}
 */
function resolveAllAttention(events, context) {
  let index = -1
  /** @type {number} */
  let open
  /** @type {Token} */
  let group
  /** @type {Token} */
  let text
  /** @type {Token} */
  let openingSequence
  /** @type {Token} */
  let closingSequence
  /** @type {number} */
  let use
  /** @type {Array<Event>} */
  let nextEvents
  /** @type {number} */
  let offset

  // Walk through all events.
  //
  // Note: performance of this is fine on an mb of normal markdown, but it’s
  // a bottleneck for malicious stuff.
  while (++index < events.length) {
    // Find a token that can close.
    if (
      events[index][0] === 'enter' &&
      events[index][1].type === 'attentionSequence' &&
      events[index][1]._close
    ) {
      open = index

      // Now walk back to find an opener.
      while (open--) {
        // Find a token that can open the closer.
        if (
          events[open][0] === 'exit' &&
          events[open][1].type === 'attentionSequence' &&
          events[open][1]._open &&
          // If the markers are the same:
          context.sliceSerialize(events[open][1]).charCodeAt(0) ===
            context.sliceSerialize(events[index][1]).charCodeAt(0)
        ) {
          // If the opening can close or the closing can open,
          // and the close size *is not* a multiple of three,
          // but the sum of the opening and closing size *is* multiple of three,
          // then don’t match.
          if (
            (events[open][1]._close || events[index][1]._open) &&
            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&
            !(
              (events[open][1].end.offset -
                events[open][1].start.offset +
                events[index][1].end.offset -
                events[index][1].start.offset) %
              3
            )
          ) {
            continue
          }

          // Number of markers to use from the sequence.
          use =
            events[open][1].end.offset - events[open][1].start.offset > 1 &&
            events[index][1].end.offset - events[index][1].start.offset > 1
              ? 2
              : 1

          const start = Object.assign({}, events[open][1].end)
          const end = Object.assign({}, events[index][1].start)
          movePoint(start, -use)
          movePoint(end, use)

          openingSequence = {
            type: use > 1 ? micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.strongSequence : micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.emphasisSequence,
            start,
            end: Object.assign({}, events[open][1].end)
          }
          closingSequence = {
            type: use > 1 ? micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.strongSequence : micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.emphasisSequence,
            start: Object.assign({}, events[index][1].start),
            end
          }
          text = {
            type: use > 1 ? micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.strongText : micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.emphasisText,
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index][1].start)
          }
          group = {
            type: use > 1 ? micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.strong : micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.emphasis,
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          }

          events[open][1].end = Object.assign({}, openingSequence.start)
          events[index][1].start = Object.assign({}, closingSequence.end)

          nextEvents = []

          // If there are more markers in the opening, add them before.
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_0__.push)(nextEvents, [
              ['enter', events[open][1], context],
              ['exit', events[open][1], context]
            ])
          }

          // Opening.
          nextEvents = (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_0__.push)(nextEvents, [
            ['enter', group, context],
            ['enter', openingSequence, context],
            ['exit', openingSequence, context],
            ['enter', text, context]
          ])

          // Always populated by defaults.
          ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
            context.parser.constructs.insideSpan.null,
            'expected `insideSpan` to be populated'
          )

          // Between.
          nextEvents = (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_0__.push)(
            nextEvents,
            (0,micromark_util_resolve_all__WEBPACK_IMPORTED_MODULE_2__.resolveAll)(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index),
              context
            )
          )

          // Closing.
          nextEvents = (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_0__.push)(nextEvents, [
            ['exit', text, context],
            ['enter', closingSequence, context],
            ['exit', closingSequence, context],
            ['exit', group, context]
          ])

          // If there are more markers in the closing, add them after.
          if (events[index][1].end.offset - events[index][1].start.offset) {
            offset = 2
            nextEvents = (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_0__.push)(nextEvents, [
              ['enter', events[index][1], context],
              ['exit', events[index][1], context]
            ])
          } else {
            offset = 0
          }

          (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_0__.splice)(events, open - 1, index - open + 3, nextEvents)

          index = open + nextEvents.length - offset - 2
          break
        }
      }
    }
  }

  // Remove remaining sequences.
  index = -1

  while (++index < events.length) {
    if (events[index][1].type === 'attentionSequence') {
      events[index][1].type = 'data'
    }
  }

  return events
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeAttention(effects, ok) {
  const attentionMarkers = this.parser.constructs.attentionMarkers.null
  const previous = this.previous
  const before = (0,micromark_util_classify_character__WEBPACK_IMPORTED_MODULE_1__.classifyCharacter)(previous)

  /** @type {NonNullable<Code>} */
  let marker

  return start

  /**
   * Before a sequence.
   *
   * ```markdown
   * > | **
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.asterisk || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.underscore,
      'expected asterisk or underscore'
    )
    marker = code
    effects.enter('attentionSequence')
    return inside(code)
  }

  /**
   * In a sequence.
   *
   * ```markdown
   * > | **
   *     ^^
   * ```
   *
   * @type {State}
   */
  function inside(code) {
    if (code === marker) {
      effects.consume(code)
      return inside
    }

    const token = effects.exit('attentionSequence')

    // To do: next major: move this to resolver, just like `markdown-rs`.
    const after = (0,micromark_util_classify_character__WEBPACK_IMPORTED_MODULE_1__.classifyCharacter)(code)

    // Always populated by defaults.
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(attentionMarkers, 'expected `attentionMarkers` to be populated')

    const open =
      !after ||
      (after === micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.characterGroupPunctuation && before) ||
      attentionMarkers.includes(code)
    const close =
      !before ||
      (before === micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.characterGroupPunctuation && after) ||
      attentionMarkers.includes(previous)

    token._open = Boolean(
      marker === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.asterisk ? open : open && (before || !close)
    )
    token._close = Boolean(
      marker === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.asterisk ? close : close && (after || !open)
    )
    return ok(code)
  }
}

/**
 * Move a point a bit.
 *
 * Note: `move` only works inside lines! It’s not possible to move past other
 * chunks (replacement characters, tabs, or line endings).
 *
 * @param {Point} point
 * @param {number} offset
 * @returns {void}
 */
function movePoint(point, offset) {
  point.column += offset
  point.offset += offset
  point._bufferIndex += offset
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/autolink.js":
/*!********************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/autolink.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   autolink: () => (/* binding */ autolink)
/* harmony export */ });
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */







/** @type {Construct} */
const autolink = {name: 'autolink', tokenize: tokenizeAutolink}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeAutolink(effects, ok, nok) {
  let size = 0

  return start

  /**
   * Start of an autolink.
   *
   * ```markdown
   * > | a<https://example.com>b
   *      ^
   * > | a<user@example.com>b
   *      ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_4__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.lessThan, 'expected `<`')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.autolink)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.autolinkMarker)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.autolinkMarker)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.autolinkProtocol)
    return open
  }

  /**
   * After `<`, at protocol or atext.
   *
   * ```markdown
   * > | a<https://example.com>b
   *       ^
   * > | a<user@example.com>b
   *       ^
   * ```
   *
   * @type {State}
   */
  function open(code) {
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiAlpha)(code)) {
      effects.consume(code)
      return schemeOrEmailAtext
    }

    return emailAtext(code)
  }

  /**
   * At second byte of protocol or atext.
   *
   * ```markdown
   * > | a<https://example.com>b
   *        ^
   * > | a<user@example.com>b
   *        ^
   * ```
   *
   * @type {State}
   */
  function schemeOrEmailAtext(code) {
    // ASCII alphanumeric and `+`, `-`, and `.`.
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.plusSign ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.dash ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.dot ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiAlphanumeric)(code)
    ) {
      // Count the previous alphabetical from `open` too.
      size = 1
      return schemeInsideOrEmailAtext(code)
    }

    return emailAtext(code)
  }

  /**
   * In ambiguous protocol or atext.
   *
   * ```markdown
   * > | a<https://example.com>b
   *        ^
   * > | a<user@example.com>b
   *        ^
   * ```
   *
   * @type {State}
   */
  function schemeInsideOrEmailAtext(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.colon) {
      effects.consume(code)
      size = 0
      return urlInside
    }

    // ASCII alphanumeric and `+`, `-`, and `.`.
    if (
      (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.plusSign ||
        code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.dash ||
        code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.dot ||
        (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiAlphanumeric)(code)) &&
      size++ < micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.autolinkSchemeSizeMax
    ) {
      effects.consume(code)
      return schemeInsideOrEmailAtext
    }

    size = 0
    return emailAtext(code)
  }

  /**
   * After protocol, in URL.
   *
   * ```markdown
   * > | a<https://example.com>b
   *             ^
   * ```
   *
   * @type {State}
   */
  function urlInside(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.greaterThan) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.autolinkProtocol)
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.autolinkMarker)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.autolinkMarker)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.autolink)
      return ok
    }

    // ASCII control, space, or `<`.
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.eof ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.space ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.lessThan ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiControl)(code)
    ) {
      return nok(code)
    }

    effects.consume(code)
    return urlInside
  }

  /**
   * In email atext.
   *
   * ```markdown
   * > | a<user.name@example.com>b
   *              ^
   * ```
   *
   * @type {State}
   */
  function emailAtext(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.atSign) {
      effects.consume(code)
      return emailAtSignOrDot
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiAtext)(code)) {
      effects.consume(code)
      return emailAtext
    }

    return nok(code)
  }

  /**
   * In label, after at-sign or dot.
   *
   * ```markdown
   * > | a<user.name@example.com>b
   *                 ^       ^
   * ```
   *
   * @type {State}
   */
  function emailAtSignOrDot(code) {
    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiAlphanumeric)(code) ? emailLabel(code) : nok(code)
  }

  /**
   * In label, where `.` and `>` are allowed.
   *
   * ```markdown
   * > | a<user.name@example.com>b
   *                   ^
   * ```
   *
   * @type {State}
   */
  function emailLabel(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.dot) {
      effects.consume(code)
      size = 0
      return emailAtSignOrDot
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.greaterThan) {
      // Exit, then change the token type.
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.autolinkProtocol).type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.autolinkEmail
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.autolinkMarker)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.autolinkMarker)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.autolink)
      return ok
    }

    return emailValue(code)
  }

  /**
   * In label, where `.` and `>` are *not* allowed.
   *
   * Though, this is also used in `emailLabel` to parse other values.
   *
   * ```markdown
   * > | a<user.name@ex-ample.com>b
   *                    ^
   * ```
   *
   * @type {State}
   */
  function emailValue(code) {
    // ASCII alphanumeric or `-`.
    if (
      (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.dash || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiAlphanumeric)(code)) &&
      size++ < micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.autolinkDomainSizeMax
    ) {
      const next = code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.dash ? emailValue : emailLabel
      effects.consume(code)
      return next
    }

    return nok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/blank-line.js":
/*!**********************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/blank-line.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blankLine: () => (/* binding */ blankLine)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */






/** @type {Construct} */
const blankLine = {tokenize: tokenizeBlankLine, partial: true}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeBlankLine(effects, ok, nok) {
  return start

  /**
   * Start of blank line.
   *
   * > 👉 **Note**: `␠` represents a space character.
   *
   * ```markdown
   * > | ␠␠␊
   *     ^
   * > | ␊
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)
      ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(effects, after, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.linePrefix)(code)
      : after(code)
  }

  /**
   * At eof/eol, after optional whitespace.
   *
   * > 👉 **Note**: `␠` represents a space character.
   *
   * ```markdown
   * > | ␠␠␊
   *       ^
   * > | ␊
   *     ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code) ? ok(code) : nok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/block-quote.js":
/*!***********************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/block-quote.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blockQuote: () => (/* binding */ blockQuote)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Exiter} Exiter
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */








/** @type {Construct} */
const blockQuote = {
  name: 'blockQuote',
  tokenize: tokenizeBlockQuoteStart,
  continuation: {tokenize: tokenizeBlockQuoteContinuation},
  exit
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeBlockQuoteStart(effects, ok, nok) {
  const self = this

  return start

  /**
   * Start of block quote.
   *
   * ```markdown
   * > | > a
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan) {
      const state = self.containerState

      ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(state, 'expected `containerState` to be defined in container')

      if (!state.open) {
        effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuote, {_container: true})
        state.open = true
      }

      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuotePrefix)
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuoteMarker)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuoteMarker)
      return after
    }

    return nok(code)
  }

  /**
   * After `>`, before optional whitespace.
   *
   * ```markdown
   * > | > a
   *      ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuotePrefixWhitespace)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuotePrefixWhitespace)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuotePrefix)
      return ok
    }

    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuotePrefix)
    return ok(code)
  }
}

/**
 * Start of block quote continuation.
 *
 * ```markdown
 *   | > a
 * > | > b
 *     ^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeBlockQuoteContinuation(effects, ok, nok) {
  const self = this

  return contStart

  /**
   * Start of block quote continuation.
   *
   * Also used to parse the first block quote opening.
   *
   * ```markdown
   *   | > a
   * > | > b
   *     ^
   * ```
   *
   * @type {State}
   */
  function contStart(code) {
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)) {
      // Always populated by defaults.
      (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(
        self.parser.constructs.disable.null,
        'expected `disable.null` to be populated'
      )

      return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(
        effects,
        contBefore,
        micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix,
        self.parser.constructs.disable.null.includes('codeIndented')
          ? undefined
          : micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.tabSize
      )(code)
    }

    return contBefore(code)
  }

  /**
   * At `>`, after optional whitespace.
   *
   * Also used to parse the first block quote opening.
   *
   * ```markdown
   *   | > a
   * > | > b
   *     ^
   * ```
   *
   * @type {State}
   */
  function contBefore(code) {
    return effects.attempt(blockQuote, ok, nok)(code)
  }
}

/** @type {Exiter} */
function exit(effects) {
  effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.blockQuote)
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/character-escape.js":
/*!****************************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/character-escape.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   characterEscape: () => (/* binding */ characterEscape)
/* harmony export */ });
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */






/** @type {Construct} */
const characterEscape = {
  name: 'characterEscape',
  tokenize: tokenizeCharacterEscape
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeCharacterEscape(effects, ok, nok) {
  return start

  /**
   * Start of character escape.
   *
   * ```markdown
   * > | a\*b
   *      ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_3__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.backslash, 'expected `\\`')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.characterEscape)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.escapeMarker)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.escapeMarker)
    return inside
  }

  /**
   * After `\`, at punctuation.
   *
   * ```markdown
   * > | a\*b
   *       ^
   * ```
   *
   * @type {State}
   */
  function inside(code) {
    // ASCII punctuation.
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiPunctuation)(code)) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.characterEscapeValue)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.characterEscapeValue)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.characterEscape)
      return ok
    }

    return nok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/character-reference.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/character-reference.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   characterReference: () => (/* binding */ characterReference)
/* harmony export */ });
/* harmony import */ var decode_named_character_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! decode-named-character-reference */ "./node_modules/decode-named-character-reference/index.dom.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */








/** @type {Construct} */
const characterReference = {
  name: 'characterReference',
  tokenize: tokenizeCharacterReference
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeCharacterReference(effects, ok, nok) {
  const self = this
  let size = 0
  /** @type {number} */
  let max
  /** @type {(code: Code) => boolean} */
  let test

  return start

  /**
   * Start of character reference.
   *
   * ```markdown
   * > | a&amp;b
   *      ^
   * > | a&#123;b
   *      ^
   * > | a&#x9;b
   *      ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.ampersand, 'expected `&`')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReference)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceMarker)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceMarker)
    return open
  }

  /**
   * After `&`, at `#` for numeric references or alphanumeric for named
   * references.
   *
   * ```markdown
   * > | a&amp;b
   *       ^
   * > | a&#123;b
   *       ^
   * > | a&#x9;b
   *       ^
   * ```
   *
   * @type {State}
   */
  function open(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.numberSign) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceMarkerNumeric)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceMarkerNumeric)
      return numeric
    }

    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceValue)
    max = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.characterReferenceNamedSizeMax
    test = micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlphanumeric
    return value(code)
  }

  /**
   * After `#`, at `x` for hexadecimals or digit for decimals.
   *
   * ```markdown
   * > | a&#123;b
   *        ^
   * > | a&#x9;b
   *        ^
   * ```
   *
   * @type {State}
   */
  function numeric(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.uppercaseX || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.lowercaseX) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceMarkerHexadecimal)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceMarkerHexadecimal)
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceValue)
      max = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.characterReferenceHexadecimalSizeMax
      test = micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiHexDigit
      return value
    }

    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceValue)
    max = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.characterReferenceDecimalSizeMax
    test = micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiDigit
    return value(code)
  }

  /**
   * After markers (`&#x`, `&#`, or `&`), in value, before `;`.
   *
   * The character reference kind defines what and how many characters are
   * allowed.
   *
   * ```markdown
   * > | a&amp;b
   *       ^^^
   * > | a&#123;b
   *        ^^^
   * > | a&#x9;b
   *         ^
   * ```
   *
   * @type {State}
   */
  function value(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.semicolon && size) {
      const token = effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceValue)

      if (
        test === micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlphanumeric &&
        !(0,decode_named_character_reference__WEBPACK_IMPORTED_MODULE_0__.decodeNamedCharacterReference)(self.sliceSerialize(token))
      ) {
        return nok(code)
      }

      // To do: `markdown-rs` uses a different name:
      // `CharacterReferenceMarkerSemi`.
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceMarker)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReferenceMarker)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.characterReference)
      return ok
    }

    if (test(code) && size++ < max) {
      effects.consume(code)
      return value
    }

    return nok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/code-fenced.js":
/*!***********************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/code-fenced.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   codeFenced: () => (/* binding */ codeFenced)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */








/** @type {Construct} */
const nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
}

/** @type {Construct} */
const codeFenced = {
  name: 'codeFenced',
  tokenize: tokenizeCodeFenced,
  concrete: true
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeCodeFenced(effects, ok, nok) {
  const self = this
  /** @type {Construct} */
  const closeStart = {tokenize: tokenizeCloseStart, partial: true}
  let initialPrefix = 0
  let sizeOpen = 0
  /** @type {NonNullable<Code>} */
  let marker

  return start

  /**
   * Start of code.
   *
   * ```markdown
   * > | ~~~js
   *     ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function start(code) {
    // To do: parse whitespace like `markdown-rs`.
    return beforeSequenceOpen(code)
  }

  /**
   * In opening fence, after prefix, at sequence.
   *
   * ```markdown
   * > | ~~~js
   *     ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function beforeSequenceOpen(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.graveAccent || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.tilde,
      'expected `` ` `` or `~`'
    )

    const tail = self.events[self.events.length - 1]
    initialPrefix =
      tail && tail[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix
        ? tail[2].sliceSerialize(tail[1], true).length
        : 0

    marker = code
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFenced)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFencedFence)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFencedFenceSequence)
    return sequenceOpen(code)
  }

  /**
   * In opening fence sequence.
   *
   * ```markdown
   * > | ~~~js
   *      ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function sequenceOpen(code) {
    if (code === marker) {
      sizeOpen++
      effects.consume(code)
      return sequenceOpen
    }

    if (sizeOpen < micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.codeFencedSequenceSizeMin) {
      return nok(code)
    }

    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFencedFenceSequence)
    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)
      ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(effects, infoBefore, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.whitespace)(code)
      : infoBefore(code)
  }

  /**
   * In opening fence, after the sequence (and optional whitespace), before info.
   *
   * ```markdown
   * > | ~~~js
   *        ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function infoBefore(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFencedFence)
      return self.interrupt
        ? ok(code)
        : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code)
    }

    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFencedFenceInfo)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.chunkString, {contentType: micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.contentTypeString})
    return info(code)
  }

  /**
   * In info.
   *
   * ```markdown
   * > | ~~~js
   *        ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function info(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.chunkString)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFencedFenceInfo)
      return infoBefore(code)
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.chunkString)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFencedFenceInfo)
      return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(effects, metaBefore, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.whitespace)(code)
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.graveAccent && code === marker) {
      return nok(code)
    }

    effects.consume(code)
    return info
  }

  /**
   * In opening fence, after info and whitespace, before meta.
   *
   * ```markdown
   * > | ~~~js eval
   *           ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function metaBefore(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      return infoBefore(code)
    }

    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFencedFenceMeta)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.chunkString, {contentType: micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.contentTypeString})
    return meta(code)
  }

  /**
   * In meta.
   *
   * ```markdown
   * > | ~~~js eval
   *           ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function meta(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.chunkString)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFencedFenceMeta)
      return infoBefore(code)
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.graveAccent && code === marker) {
      return nok(code)
    }

    effects.consume(code)
    return meta
  }

  /**
   * At eol/eof in code, before a non-lazy closing fence or content.
   *
   * ```markdown
   * > | ~~~js
   *          ^
   * > | alert(1)
   *             ^
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function atNonLazyBreak(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code), 'expected eol')
    return effects.attempt(closeStart, after, contentBefore)(code)
  }

  /**
   * Before code content, not a closing fence, at eol.
   *
   * ```markdown
   *   | ~~~js
   * > | alert(1)
   *             ^
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function contentBefore(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code), 'expected eol')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
    return contentStart
  }

  /**
   * Before code content, not a closing fence.
   *
   * ```markdown
   *   | ~~~js
   * > | alert(1)
   *     ^
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function contentStart(code) {
    return initialPrefix > 0 && (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)
      ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(
          effects,
          beforeContentChunk,
          micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix,
          initialPrefix + 1
        )(code)
      : beforeContentChunk(code)
  }

  /**
   * Before code content, after optional prefix.
   *
   * ```markdown
   *   | ~~~js
   * > | alert(1)
   *     ^
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function beforeContentChunk(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code)
    }

    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFlowValue)
    return contentChunk(code)
  }

  /**
   * In code content.
   *
   * ```markdown
   *   | ~~~js
   * > | alert(1)
   *     ^^^^^^^^
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function contentChunk(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFlowValue)
      return beforeContentChunk(code)
    }

    effects.consume(code)
    return contentChunk
  }

  /**
   * After code.
   *
   * ```markdown
   *   | ~~~js
   *   | alert(1)
   * > | ~~~
   *        ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFenced)
    return ok(code)
  }

  /**
   * @this {TokenizeContext}
   * @type {Tokenizer}
   */
  function tokenizeCloseStart(effects, ok, nok) {
    let size = 0

    return startBefore

    /**
     *
     *
     * @type {State}
     */
    function startBefore(code) {
      ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code), 'expected eol')
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
      return start
    }

    /**
     * Before closing fence, at optional whitespace.
     *
     * ```markdown
     *   | ~~~js
     *   | alert(1)
     * > | ~~~
     *     ^
     * ```
     *
     * @type {State}
     */
    function start(code) {
      // Always populated by defaults.
      (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(
        self.parser.constructs.disable.null,
        'expected `disable.null` to be populated'
      )

      // To do: `enter` here or in next state?
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFencedFence)
      return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)
        ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(
            effects,
            beforeSequenceClose,
            micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix,
            self.parser.constructs.disable.null.includes('codeIndented')
              ? undefined
              : micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.tabSize
          )(code)
        : beforeSequenceClose(code)
    }

    /**
     * In closing fence, after optional whitespace, at sequence.
     *
     * ```markdown
     *   | ~~~js
     *   | alert(1)
     * > | ~~~
     *     ^
     * ```
     *
     * @type {State}
     */
    function beforeSequenceClose(code) {
      if (code === marker) {
        effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFencedFenceSequence)
        return sequenceClose(code)
      }

      return nok(code)
    }

    /**
     * In closing fence sequence.
     *
     * ```markdown
     *   | ~~~js
     *   | alert(1)
     * > | ~~~
     *     ^
     * ```
     *
     * @type {State}
     */
    function sequenceClose(code) {
      if (code === marker) {
        size++
        effects.consume(code)
        return sequenceClose
      }

      if (size >= sizeOpen) {
        effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFencedFenceSequence)
        return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)
          ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(effects, sequenceCloseAfter, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.whitespace)(code)
          : sequenceCloseAfter(code)
      }

      return nok(code)
    }

    /**
     * After closing fence sequence, after optional whitespace.
     *
     * ```markdown
     *   | ~~~js
     *   | alert(1)
     * > | ~~~
     *        ^
     * ```
     *
     * @type {State}
     */
    function sequenceCloseAfter(code) {
      if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
        effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFencedFence)
        return ok(code)
      }

      return nok(code)
    }
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeNonLazyContinuation(effects, ok, nok) {
  const self = this

  return start

  /**
   *
   *
   * @type {State}
   */
  function start(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof) {
      return nok(code)
    }

    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code), 'expected eol')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
    return lineStart
  }

  /**
   *
   *
   * @type {State}
   */
  function lineStart(code) {
    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/code-indented.js":
/*!*************************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/code-indented.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   codeIndented: () => (/* binding */ codeIndented)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */








/** @type {Construct} */
const codeIndented = {
  name: 'codeIndented',
  tokenize: tokenizeCodeIndented
}

/** @type {Construct} */
const furtherStart = {tokenize: tokenizeFurtherStart, partial: true}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeCodeIndented(effects, ok, nok) {
  const self = this
  return start

  /**
   * Start of code (indented).
   *
   * > **Parsing note**: it is not needed to check if this first line is a
   * > filled line (that it has a non-whitespace character), because blank lines
   * > are parsed already, so we never run into that.
   *
   * ```markdown
   * > |     aaa
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    // To do: manually check if interrupting like `markdown-rs`.
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code))
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeIndented)
    // To do: use an improved `space_or_tab` function like `markdown-rs`,
    // so that we can drop the next state.
    return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(
      effects,
      afterPrefix,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix,
      micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.tabSize + 1
    )(code)
  }

  /**
   * At start, after 1 or 4 spaces.
   *
   * ```markdown
   * > |     aaa
   *         ^
   * ```
   *
   * @type {State}
   */
  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1]
    return tail &&
      tail[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix &&
      tail[2].sliceSerialize(tail[1], true).length >= micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.tabSize
      ? atBreak(code)
      : nok(code)
  }

  /**
   * At a break.
   *
   * ```markdown
   * > |     aaa
   *         ^  ^
   * ```
   *
   * @type {State}
   */
  function atBreak(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof) {
      return after(code)
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      return effects.attempt(furtherStart, atBreak, after)(code)
    }

    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFlowValue)
    return inside(code)
  }

  /**
   * In code content.
   *
   * ```markdown
   * > |     aaa
   *         ^^^^
   * ```
   *
   * @type {State}
   */
  function inside(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeFlowValue)
      return atBreak(code)
    }

    effects.consume(code)
    return inside
  }

  /** @type {State} */
  function after(code) {
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.codeIndented)
    // To do: allow interrupting like `markdown-rs`.
    // Feel free to interrupt.
    // tokenizer.interrupt = false
    return ok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeFurtherStart(effects, ok, nok) {
  const self = this

  return furtherStart

  /**
   * At eol, trying to parse another indent.
   *
   * ```markdown
   * > |     aaa
   *            ^
   *   |     bbb
   * ```
   *
   * @type {State}
   */
  function furtherStart(code) {
    // To do: improve `lazy` / `pierce` handling.
    // If this is a lazy line, it can’t be code.
    if (self.parser.lazy[self.now().line]) {
      return nok(code)
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
      return furtherStart
    }

    // To do: the code here in `micromark-js` is a bit different from
    // `markdown-rs` because there it can attempt spaces.
    // We can’t yet.
    //
    // To do: use an improved `space_or_tab` function like `markdown-rs`,
    // so that we can drop the next state.
    return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(
      effects,
      afterPrefix,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix,
      micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.tabSize + 1
    )(code)
  }

  /**
   * At start, after 1 or 4 spaces.
   *
   * ```markdown
   * > |     aaa
   *         ^
   * ```
   *
   * @type {State}
   */
  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1]
    return tail &&
      tail[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix &&
      tail[2].sliceSerialize(tail[1], true).length >= micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.tabSize
      ? ok(code)
      : (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)
      ? furtherStart(code)
      : nok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/code-text.js":
/*!*********************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/code-text.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   codeText: () => (/* binding */ codeText)
/* harmony export */ });
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Previous} Previous
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */






/** @type {Construct} */
const codeText = {
  name: 'codeText',
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
}

// To do: next major: don’t resolve, like `markdown-rs`.
/** @type {Resolver} */
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4
  let headEnterIndex = 3
  /** @type {number} */
  let index
  /** @type {number | undefined} */
  let enter

  // If we start and end with an EOL or a space.
  if (
    (events[headEnterIndex][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEnding ||
      events[headEnterIndex][1].type === 'space') &&
    (events[tailExitIndex][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEnding ||
      events[tailExitIndex][1].type === 'space')
  ) {
    index = headEnterIndex

    // And we have data.
    while (++index < tailExitIndex) {
      if (events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.codeTextData) {
        // Then we have padding.
        events[headEnterIndex][1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.codeTextPadding
        events[tailExitIndex][1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.codeTextPadding
        headEnterIndex += 2
        tailExitIndex -= 2
        break
      }
    }
  }

  // Merge adjacent spaces and data.
  index = headEnterIndex - 1
  tailExitIndex++

  while (++index <= tailExitIndex) {
    if (enter === undefined) {
      if (
        index !== tailExitIndex &&
        events[index][1].type !== micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEnding
      ) {
        enter = index
      }
    } else if (
      index === tailExitIndex ||
      events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEnding
    ) {
      events[enter][1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.codeTextData

      if (index !== enter + 2) {
        events[enter][1].end = events[index - 1][1].end
        events.splice(enter + 2, index - enter - 2)
        tailExitIndex -= index - enter - 2
        index = enter + 2
      }

      enter = undefined
    }
  }

  return events
}

/**
 * @this {TokenizeContext}
 * @type {Previous}
 */
function previous(code) {
  // If there is a previous code, there will always be a tail.
  return (
    code !== micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.graveAccent ||
    this.events[this.events.length - 1][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.characterEscape
  )
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeCodeText(effects, ok, nok) {
  const self = this
  let sizeOpen = 0
  /** @type {number} */
  let size
  /** @type {Token} */
  let token

  return start

  /**
   * Start of code (text).
   *
   * ```markdown
   * > | `a`
   *     ^
   * > | \`a`
   *      ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_3__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.graveAccent, 'expected `` ` ``')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_3__.ok)(previous.call(self, self.previous), 'expected correct previous')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.codeText)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.codeTextSequence)
    return sequenceOpen(code)
  }

  /**
   * In opening sequence.
   *
   * ```markdown
   * > | `a`
   *     ^
   * ```
   *
   * @type {State}
   */
  function sequenceOpen(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.graveAccent) {
      effects.consume(code)
      sizeOpen++
      return sequenceOpen
    }

    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.codeTextSequence)
    return between(code)
  }

  /**
   * Between something and something else.
   *
   * ```markdown
   * > | `a`
   *      ^^
   * ```
   *
   * @type {State}
   */
  function between(code) {
    // EOF.
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.eof) {
      return nok(code)
    }

    // To do: next major: don’t do spaces in resolve, but when compiling,
    // like `markdown-rs`.
    // Tabs don’t work, and virtual spaces don’t make sense.
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.space) {
      effects.enter('space')
      effects.consume(code)
      effects.exit('space')
      return between
    }

    // Closing fence? Could also be data.
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.graveAccent) {
      token = effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.codeTextSequence)
      size = 0
      return sequenceClose(code)
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code)) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEnding)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEnding)
      return between
    }

    // Data.
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.codeTextData)
    return data(code)
  }

  /**
   * In data.
   *
   * ```markdown
   * > | `a`
   *      ^
   * ```
   *
   * @type {State}
   */
  function data(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.eof ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.space ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.graveAccent ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code)
    ) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.codeTextData)
      return between(code)
    }

    effects.consume(code)
    return data
  }

  /**
   * In closing sequence.
   *
   * ```markdown
   * > | `a`
   *       ^
   * ```
   *
   * @type {State}
   */
  function sequenceClose(code) {
    // More.
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.graveAccent) {
      effects.consume(code)
      size++
      return sequenceClose
    }

    // Done!
    if (size === sizeOpen) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.codeTextSequence)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.codeText)
      return ok(code)
    }

    // More or less accents: mark as data.
    token.type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.codeTextData
    return data(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/content.js":
/*!*******************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/content.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   content: () => (/* binding */ content)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_subtokenize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-subtokenize */ "./node_modules/micromark-util-subtokenize/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */









/**
 * No name because it must not be turned off.
 * @type {Construct}
 */
const content = {tokenize: tokenizeContent, resolve: resolveContent}

/** @type {Construct} */
const continuationConstruct = {tokenize: tokenizeContinuation, partial: true}

/**
 * Content is transparent: it’s parsed right now. That way, definitions are also
 * parsed right now: before text in paragraphs (specifically, media) are parsed.
 *
 * @type {Resolver}
 */
function resolveContent(events) {
  ;(0,micromark_util_subtokenize__WEBPACK_IMPORTED_MODULE_2__.subtokenize)(events)
  return events
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeContent(effects, ok) {
  /** @type {Token | undefined} */
  let previous

  return chunkStart

  /**
   * Before a content chunk.
   *
   * ```markdown
   * > | abc
   *     ^
   * ```
   *
   * @type {State}
   */
  function chunkStart(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
      code !== micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof && !(0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code),
      'expected no eof or eol'
    )

    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.content)
    previous = effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.chunkContent, {
      contentType: micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.contentTypeContent
    })
    return chunkInside(code)
  }

  /**
   * In a content chunk.
   *
   * ```markdown
   * > | abc
   *     ^^^
   * ```
   *
   * @type {State}
   */
  function chunkInside(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof) {
      return contentEnd(code)
    }

    // To do: in `markdown-rs`, each line is parsed on its own, and everything
    // is stitched together resolving.
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code)
    }

    // Data.
    effects.consume(code)
    return chunkInside
  }

  /**
   *
   *
   * @type {State}
   */
  function contentEnd(code) {
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.chunkContent)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.content)
    return ok(code)
  }

  /**
   *
   *
   * @type {State}
   */
  function contentContinue(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code), 'expected eol')
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.chunkContent)
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(previous, 'expected previous token')
    previous.next = effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.chunkContent, {
      contentType: micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.contentTypeContent,
      previous
    })
    previous = previous.next
    return chunkInside
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeContinuation(effects, ok, nok) {
  const self = this

  return startLookahead

  /**
   *
   *
   * @type {State}
   */
  function startLookahead(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code), 'expected a line ending')
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.chunkContent)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.lineEnding)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.lineEnding)
    return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(effects, prefixed, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.linePrefix)
  }

  /**
   *
   *
   * @type {State}
   */
  function prefixed(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      return nok(code)
    }

    // Always populated by defaults.
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
      self.parser.constructs.disable.null,
      'expected `disable.null` to be populated'
    )

    const tail = self.events[self.events.length - 1]

    if (
      !self.parser.constructs.disable.null.includes('codeIndented') &&
      tail &&
      tail[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.linePrefix &&
      tail[2].sliceSerialize(tail[1], true).length >= micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.tabSize
    ) {
      return ok(code)
    }

    return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/definition.js":
/*!**********************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/definition.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   definition: () => (/* binding */ definition)
/* harmony export */ });
/* harmony import */ var micromark_factory_destination__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-destination */ "./node_modules/micromark-factory-destination/dev/index.js");
/* harmony import */ var micromark_factory_label__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-factory-label */ "./node_modules/micromark-factory-label/dev/index.js");
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_factory_title__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-factory-title */ "./node_modules/micromark-factory-title/dev/index.js");
/* harmony import */ var micromark_factory_whitespace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-factory-whitespace */ "./node_modules/micromark-factory-whitespace/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! micromark-util-normalize-identifier */ "./node_modules/micromark-util-normalize-identifier/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */












/** @type {Construct} */
const definition = {name: 'definition', tokenize: tokenizeDefinition}

/** @type {Construct} */
const titleBefore = {tokenize: tokenizeTitleBefore, partial: true}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeDefinition(effects, ok, nok) {
  const self = this
  /** @type {string} */
  let identifier

  return start

  /**
   * At start of a definition.
   *
   * ```markdown
   * > | [a]: b "c"
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    // Do not interrupt paragraphs (but do follow definitions).
    // To do: do `interrupt` the way `markdown-rs` does.
    // To do: parse whitespace the way `markdown-rs` does.
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definition)
    return before(code)
  }

  /**
   * After optional whitespace, at `[`.
   *
   * ```markdown
   * > | [a]: b "c"
   *     ^
   * ```
   *
   * @type {State}
   */
  function before(code) {
    // To do: parse whitespace the way `markdown-rs` does.
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_9__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_7__.codes.leftSquareBracket, 'expected `[`')
    return micromark_factory_label__WEBPACK_IMPORTED_MODULE_1__.factoryLabel.call(
      self,
      effects,
      labelAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definitionLabel,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definitionLabelMarker,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definitionLabelString
    )(code)
  }

  /**
   * After label.
   *
   * ```markdown
   * > | [a]: b "c"
   *        ^
   * ```
   *
   * @type {State}
   */
  function labelAfter(code) {
    identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_6__.normalizeIdentifier)(
      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
    )

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_7__.codes.colon) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definitionMarker)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definitionMarker)
      return markerAfter
    }

    return nok(code)
  }

  /**
   * After marker.
   *
   * ```markdown
   * > | [a]: b "c"
   *         ^
   * ```
   *
   * @type {State}
   */
  function markerAfter(code) {
    // Note: whitespace is optional.
    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_5__.markdownLineEndingOrSpace)(code)
      ? (0,micromark_factory_whitespace__WEBPACK_IMPORTED_MODULE_4__.factoryWhitespace)(effects, destinationBefore)(code)
      : destinationBefore(code)
  }

  /**
   * Before destination.
   *
   * ```markdown
   * > | [a]: b "c"
   *          ^
   * ```
   *
   * @type {State}
   */
  function destinationBefore(code) {
    return (0,micromark_factory_destination__WEBPACK_IMPORTED_MODULE_0__.factoryDestination)(
      effects,
      destinationAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definitionDestination,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definitionDestinationLiteral,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definitionDestinationLiteralMarker,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definitionDestinationRaw,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definitionDestinationString
    )(code)
  }

  /**
   * After destination.
   *
   * ```markdown
   * > | [a]: b "c"
   *           ^
   * ```
   *
   * @type {State}
   */
  function destinationAfter(code) {
    return effects.attempt(titleBefore, after, after)(code)
  }

  /**
   * After definition.
   *
   * ```markdown
   * > | [a]: b
   *           ^
   * > | [a]: b "c"
   *               ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_5__.markdownSpace)(code)
      ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_2__.factorySpace)(effects, afterWhitespace, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.whitespace)(code)
      : afterWhitespace(code)
  }

  /**
   * After definition, after optional whitespace.
   *
   * ```markdown
   * > | [a]: b
   *           ^
   * > | [a]: b "c"
   *               ^
   * ```
   *
   * @type {State}
   */
  function afterWhitespace(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_7__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_5__.markdownLineEnding)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definition)

      // Note: we don’t care about uniqueness.
      // It’s likely that that doesn’t happen very frequently.
      // It is more likely that it wastes precious time.
      self.parser.defined.push(identifier)

      // To do: `markdown-rs` interrupt.
      // // You’d be interrupting.
      // tokenizer.interrupt = true
      return ok(code)
    }

    return nok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeTitleBefore(effects, ok, nok) {
  return titleBefore

  /**
   * After destination, at whitespace.
   *
   * ```markdown
   * > | [a]: b
   *           ^
   * > | [a]: b "c"
   *           ^
   * ```
   *
   * @type {State}
   */
  function titleBefore(code) {
    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_5__.markdownLineEndingOrSpace)(code)
      ? (0,micromark_factory_whitespace__WEBPACK_IMPORTED_MODULE_4__.factoryWhitespace)(effects, beforeMarker)(code)
      : nok(code)
  }

  /**
   * At title.
   *
   * ```markdown
   *   | [a]: b
   * > | "c"
   *     ^
   * ```
   *
   * @type {State}
   */
  function beforeMarker(code) {
    return (0,micromark_factory_title__WEBPACK_IMPORTED_MODULE_3__.factoryTitle)(
      effects,
      titleAfter,
      nok,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definitionTitle,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definitionTitleMarker,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.definitionTitleString
    )(code)
  }

  /**
   * After title.
   *
   * ```markdown
   * > | [a]: b "c"
   *               ^
   * ```
   *
   * @type {State}
   */
  function titleAfter(code) {
    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_5__.markdownSpace)(code)
      ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_2__.factorySpace)(
          effects,
          titleAfterOptionalWhitespace,
          micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_8__.types.whitespace
        )(code)
      : titleAfterOptionalWhitespace(code)
  }

  /**
   * After title, after optional whitespace.
   *
   * ```markdown
   * > | [a]: b "c"
   *               ^
   * ```
   *
   * @type {State}
   */
  function titleAfterOptionalWhitespace(code) {
    return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_7__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_5__.markdownLineEnding)(code) ? ok(code) : nok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hardBreakEscape: () => (/* binding */ hardBreakEscape)
/* harmony export */ });
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */






/** @type {Construct} */
const hardBreakEscape = {
  name: 'hardBreakEscape',
  tokenize: tokenizeHardBreakEscape
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeHardBreakEscape(effects, ok, nok) {
  return start

  /**
   * Start of a hard break (escape).
   *
   * ```markdown
   * > | a\
   *      ^
   *   | b
   * ```
   *
   * @type {State}
   */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_3__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.backslash, 'expected `\\`')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.hardBreakEscape)
    effects.consume(code)
    return after
  }

  /**
   * After `\`, at eol.
   *
   * ```markdown
   * > | a\
   *       ^
   *   | b
   * ```
   *
   *  @type {State}
   */
  function after(code) {
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.hardBreakEscape)
      return ok(code)
    }

    return nok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/heading-atx.js":
/*!***********************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/heading-atx.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   headingAtx: () => (/* binding */ headingAtx)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_chunked__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-chunked */ "./node_modules/micromark-util-chunked/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */









/** @type {Construct} */
const headingAtx = {
  name: 'headingAtx',
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
}

/** @type {Resolver} */
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2
  let contentStart = 3
  /** @type {Token} */
  let content
  /** @type {Token} */
  let text

  // Prefix whitespace, part of the opening.
  if (events[contentStart][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.whitespace) {
    contentStart += 2
  }

  // Suffix whitespace, part of the closing.
  if (
    contentEnd - 2 > contentStart &&
    events[contentEnd][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.whitespace
  ) {
    contentEnd -= 2
  }

  if (
    events[contentEnd][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.atxHeadingSequence &&
    (contentStart === contentEnd - 1 ||
      (contentEnd - 4 > contentStart &&
        events[contentEnd - 2][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.whitespace))
  ) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4
  }

  if (contentEnd > contentStart) {
    content = {
      type: micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.atxHeadingText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    }
    text = {
      type: micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.chunkText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.contentTypeText
    }

    ;(0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_2__.splice)(events, contentStart, contentEnd - contentStart + 1, [
      ['enter', content, context],
      ['enter', text, context],
      ['exit', text, context],
      ['exit', content, context]
    ])
  }

  return events
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeHeadingAtx(effects, ok, nok) {
  let size = 0

  return start

  /**
   * Start of a heading (atx).
   *
   * ```markdown
   * > | ## aa
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    // To do: parse indent like `markdown-rs`.
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.atxHeading)
    return before(code)
  }

  /**
   * After optional whitespace, at `#`.
   *
   * ```markdown
   * > | ## aa
   *     ^
   * ```
   *
   * @type {State}
   */
  function before(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.numberSign, 'expected `#`')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.atxHeadingSequence)
    return sequenceOpen(code)
  }

  /**
   * In opening sequence.
   *
   * ```markdown
   * > | ## aa
   *     ^
   * ```
   *
   * @type {State}
   */
  function sequenceOpen(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.numberSign &&
      size++ < micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.atxHeadingOpeningFenceSizeMax
    ) {
      effects.consume(code)
      return sequenceOpen
    }

    // Always at least one `#`.
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.atxHeadingSequence)
      return atBreak(code)
    }

    return nok(code)
  }

  /**
   * After something, before something else.
   *
   * ```markdown
   * > | ## aa
   *       ^
   * ```
   *
   * @type {State}
   */
  function atBreak(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.numberSign) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.atxHeadingSequence)
      return sequenceFurther(code)
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.atxHeading)
      // To do: interrupt like `markdown-rs`.
      // // Feel free to interrupt.
      // tokenizer.interrupt = false
      return ok(code)
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)) {
      return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(effects, atBreak, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.whitespace)(code)
    }

    // To do: generate `data` tokens, add the `text` token later.
    // Needs edit map, see: `markdown.rs`.
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.atxHeadingText)
    return data(code)
  }

  /**
   * In further sequence (after whitespace).
   *
   * Could be normal “visible” hashes in the heading or a final sequence.
   *
   * ```markdown
   * > | ## aa ##
   *           ^
   * ```
   *
   * @type {State}
   */
  function sequenceFurther(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.numberSign) {
      effects.consume(code)
      return sequenceFurther
    }

    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.atxHeadingSequence)
    return atBreak(code)
  }

  /**
   * In text.
   *
   * ```markdown
   * > | ## aa
   *        ^
   * ```
   *
   * @type {State}
   */
  function data(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.numberSign ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code)
    ) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.atxHeadingText)
      return atBreak(code)
    }

    effects.consume(code)
    return data
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/html-flow.js":
/*!*********************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/html-flow.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   htmlFlow: () => (/* binding */ htmlFlow)
/* harmony export */ });
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_html_tag_name__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-html-tag-name */ "./node_modules/micromark-util-html-tag-name/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/* harmony import */ var _blank_line_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./blank-line.js */ "./node_modules/micromark-core-commonmark/dev/lib/blank-line.js");
/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */









/** @type {Construct} */
const htmlFlow = {
  name: 'htmlFlow',
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
}

/** @type {Construct} */
const blankLineBefore = {tokenize: tokenizeBlankLineBefore, partial: true}
const nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
}

/** @type {Resolver} */
function resolveToHtmlFlow(events) {
  let index = events.length

  while (index--) {
    if (
      events[index][0] === 'enter' &&
      events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlFlow
    ) {
      break
    }
  }

  if (index > 1 && events[index - 2][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix) {
    // Add the prefix start to the HTML token.
    events[index][1].start = events[index - 2][1].start
    // Add the prefix start to the HTML line token.
    events[index + 1][1].start = events[index - 2][1].start
    // Remove the line prefix.
    events.splice(index - 2, 2)
  }

  return events
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeHtmlFlow(effects, ok, nok) {
  const self = this
  /** @type {number} */
  let marker
  /** @type {boolean} */
  let closingTag
  /** @type {string} */
  let buffer
  /** @type {number} */
  let index
  /** @type {Code} */
  let markerB

  return start

  /**
   * Start of HTML (flow).
   *
   * ```markdown
   * > | <x />
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    // To do: parse indent like `markdown-rs`.
    return before(code)
  }

  /**
   * At `<`, after optional whitespace.
   *
   * ```markdown
   * > | <x />
   *     ^
   * ```
   *
   * @type {State}
   */
  function before(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.lessThan, 'expected `<`')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlFlow)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlFlowData)
    effects.consume(code)
    return open
  }

  /**
   * After `<`, at tag name or other stuff.
   *
   * ```markdown
   * > | <x />
   *      ^
   * > | <!doctype>
   *      ^
   * > | <!--xxx-->
   *      ^
   * ```
   *
   * @type {State}
   */
  function open(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.exclamationMark) {
      effects.consume(code)
      return declarationOpen
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.slash) {
      effects.consume(code)
      closingTag = true
      return tagCloseStart
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.questionMark) {
      effects.consume(code)
      marker = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlInstruction
      // To do:
      // tokenizer.concrete = true
      // To do: use `markdown-rs` style interrupt.
      // While we’re in an instruction instead of a declaration, we’re on a `?`
      // right now, so we do need to search for `>`, similar to declarations.
      return self.interrupt ? ok : continuationDeclarationInside
    }

    // ASCII alphabetical.
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiAlpha)(code)) {
      effects.consume(code)
      // @ts-expect-error: not null.
      buffer = String.fromCharCode(code)
      return tagName
    }

    return nok(code)
  }

  /**
   * After `<!`, at declaration, comment, or CDATA.
   *
   * ```markdown
   * > | <!doctype>
   *       ^
   * > | <!--xxx-->
   *       ^
   * > | <![CDATA[>&<]]>
   *       ^
   * ```
   *
   * @type {State}
   */
  function declarationOpen(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash) {
      effects.consume(code)
      marker = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlComment
      return commentOpenInside
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.leftSquareBracket) {
      effects.consume(code)
      marker = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlCdata
      index = 0
      return cdataOpenInside
    }

    // ASCII alphabetical.
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiAlpha)(code)) {
      effects.consume(code)
      marker = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlDeclaration
      // // Do not form containers.
      // tokenizer.concrete = true
      return self.interrupt ? ok : continuationDeclarationInside
    }

    return nok(code)
  }

  /**
   * After `<!-`, inside a comment, at another `-`.
   *
   * ```markdown
   * > | <!--xxx-->
   *        ^
   * ```
   *
   * @type {State}
   */
  function commentOpenInside(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash) {
      effects.consume(code)
      // // Do not form containers.
      // tokenizer.concrete = true
      return self.interrupt ? ok : continuationDeclarationInside
    }

    return nok(code)
  }

  /**
   * After `<![`, inside CDATA, expecting `CDATA[`.
   *
   * ```markdown
   * > | <![CDATA[>&<]]>
   *        ^^^^^^
   * ```
   *
   * @type {State}
   */
  function cdataOpenInside(code) {
    const value = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.cdataOpeningString

    if (code === value.charCodeAt(index++)) {
      effects.consume(code)

      if (index === value.length) {
        // // Do not form containers.
        // tokenizer.concrete = true
        return self.interrupt ? ok : continuation
      }

      return cdataOpenInside
    }

    return nok(code)
  }

  /**
   * After `</`, in closing tag, at tag name.
   *
   * ```markdown
   * > | </x>
   *       ^
   * ```
   *
   * @type {State}
   */
  function tagCloseStart(code) {
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiAlpha)(code)) {
      effects.consume(code)
      // @ts-expect-error: not null.
      buffer = String.fromCharCode(code)
      return tagName
    }

    return nok(code)
  }

  /**
   * In tag name.
   *
   * ```markdown
   * > | <ab>
   *      ^^
   * > | </ab>
   *       ^^
   * ```
   *
   * @type {State}
   */
  function tagName(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.slash ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEndingOrSpace)(code)
    ) {
      const slash = code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.slash
      const name = buffer.toLowerCase()

      if (!slash && !closingTag && micromark_util_html_tag_name__WEBPACK_IMPORTED_MODULE_1__.htmlRawNames.includes(name)) {
        marker = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlRaw
        // // Do not form containers.
        // tokenizer.concrete = true
        return self.interrupt ? ok(code) : continuation(code)
      }

      if (micromark_util_html_tag_name__WEBPACK_IMPORTED_MODULE_1__.htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlBasic

        if (slash) {
          effects.consume(code)
          return basicSelfClosing
        }

        // // Do not form containers.
        // tokenizer.concrete = true
        return self.interrupt ? ok(code) : continuation(code)
      }

      marker = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlComplete
      // Do not support complete HTML when interrupting.
      return self.interrupt && !self.parser.lazy[self.now().line]
        ? nok(code)
        : closingTag
        ? completeClosingTagAfter(code)
        : completeAttributeNameBefore(code)
    }

    // ASCII alphanumerical and `-`.
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiAlphanumeric)(code)) {
      effects.consume(code)
      buffer += String.fromCharCode(code)
      return tagName
    }

    return nok(code)
  }

  /**
   * After closing slash of a basic tag name.
   *
   * ```markdown
   * > | <div/>
   *          ^
   * ```
   *
   * @type {State}
   */
  function basicSelfClosing(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan) {
      effects.consume(code)
      // // Do not form containers.
      // tokenizer.concrete = true
      return self.interrupt ? ok : continuation
    }

    return nok(code)
  }

  /**
   * After closing slash of a complete tag name.
   *
   * ```markdown
   * > | <x/>
   *        ^
   * ```
   *
   * @type {State}
   */
  function completeClosingTagAfter(code) {
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownSpace)(code)) {
      effects.consume(code)
      return completeClosingTagAfter
    }

    return completeEnd(code)
  }

  /**
   * At an attribute name.
   *
   * At first, this state is used after a complete tag name, after whitespace,
   * where it expects optional attributes or the end of the tag.
   * It is also reused after attributes, when expecting more optional
   * attributes.
   *
   * ```markdown
   * > | <a />
   *        ^
   * > | <a :b>
   *        ^
   * > | <a _b>
   *        ^
   * > | <a b>
   *        ^
   * > | <a >
   *        ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeNameBefore(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.slash) {
      effects.consume(code)
      return completeEnd
    }

    // ASCII alphanumerical and `:` and `_`.
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.colon || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.underscore || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiAlpha)(code)) {
      effects.consume(code)
      return completeAttributeName
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownSpace)(code)) {
      effects.consume(code)
      return completeAttributeNameBefore
    }

    return completeEnd(code)
  }

  /**
   * In attribute name.
   *
   * ```markdown
   * > | <a :b>
   *         ^
   * > | <a _b>
   *         ^
   * > | <a b>
   *         ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeName(code) {
    // ASCII alphanumerical and `-`, `.`, `:`, and `_`.
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dot ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.colon ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.underscore ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiAlphanumeric)(code)
    ) {
      effects.consume(code)
      return completeAttributeName
    }

    return completeAttributeNameAfter(code)
  }

  /**
   * After attribute name, at an optional initializer, the end of the tag, or
   * whitespace.
   *
   * ```markdown
   * > | <a b>
   *         ^
   * > | <a b=c>
   *         ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeNameAfter(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.equalsTo) {
      effects.consume(code)
      return completeAttributeValueBefore
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownSpace)(code)) {
      effects.consume(code)
      return completeAttributeNameAfter
    }

    return completeAttributeNameBefore(code)
  }

  /**
   * Before unquoted, double quoted, or single quoted attribute value, allowing
   * whitespace.
   *
   * ```markdown
   * > | <a b=c>
   *          ^
   * > | <a b="c">
   *          ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeValueBefore(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.lessThan ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.equalsTo ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.graveAccent
    ) {
      return nok(code)
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.quotationMark || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.apostrophe) {
      effects.consume(code)
      markerB = code
      return completeAttributeValueQuoted
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownSpace)(code)) {
      effects.consume(code)
      return completeAttributeValueBefore
    }

    return completeAttributeValueUnquoted(code)
  }

  /**
   * In double or single quoted attribute value.
   *
   * ```markdown
   * > | <a b="c">
   *           ^
   * > | <a b='c'>
   *           ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeValueQuoted(code) {
    if (code === markerB) {
      effects.consume(code)
      markerB = null
      return completeAttributeValueQuotedAfter
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code)) {
      return nok(code)
    }

    effects.consume(code)
    return completeAttributeValueQuoted
  }

  /**
   * In unquoted attribute value.
   *
   * ```markdown
   * > | <a b=c>
   *          ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeValueUnquoted(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.quotationMark ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.apostrophe ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.slash ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.lessThan ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.equalsTo ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.graveAccent ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEndingOrSpace)(code)
    ) {
      return completeAttributeNameAfter(code)
    }

    effects.consume(code)
    return completeAttributeValueUnquoted
  }

  /**
   * After double or single quoted attribute value, before whitespace or the
   * end of the tag.
   *
   * ```markdown
   * > | <a b="c">
   *            ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeValueQuotedAfter(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.slash ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownSpace)(code)
    ) {
      return completeAttributeNameBefore(code)
    }

    return nok(code)
  }

  /**
   * In certain circumstances of a complete tag where only an `>` is allowed.
   *
   * ```markdown
   * > | <a b="c">
   *             ^
   * ```
   *
   * @type {State}
   */
  function completeEnd(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan) {
      effects.consume(code)
      return completeAfter
    }

    return nok(code)
  }

  /**
   * After `>` in a complete tag.
   *
   * ```markdown
   * > | <x>
   *        ^
   * ```
   *
   * @type {State}
   */
  function completeAfter(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code)) {
      // // Do not form containers.
      // tokenizer.concrete = true
      return continuation(code)
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownSpace)(code)) {
      effects.consume(code)
      return completeAfter
    }

    return nok(code)
  }

  /**
   * In continuation of any HTML kind.
   *
   * ```markdown
   * > | <!--xxx-->
   *          ^
   * ```
   *
   * @type {State}
   */
  function continuation(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash && marker === micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlComment) {
      effects.consume(code)
      return continuationCommentInside
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.lessThan && marker === micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlRaw) {
      effects.consume(code)
      return continuationRawTagOpen
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan && marker === micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlDeclaration) {
      effects.consume(code)
      return continuationClose
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.questionMark && marker === micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlInstruction) {
      effects.consume(code)
      return continuationDeclarationInside
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.rightSquareBracket && marker === micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlCdata) {
      effects.consume(code)
      return continuationCdataInside
    }

    if (
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code) &&
      (marker === micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlBasic || marker === micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlComplete)
    ) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlFlowData)
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code)
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlFlowData)
      return continuationStart(code)
    }

    effects.consume(code)
    return continuation
  }

  /**
   * In continuation, at eol.
   *
   * ```markdown
   * > | <x>
   *        ^
   *   | asd
   * ```
   *
   * @type {State}
   */
  function continuationStart(code) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code)
  }

  /**
   * In continuation, at eol, before non-lazy content.
   *
   * ```markdown
   * > | <x>
   *        ^
   *   | asd
   * ```
   *
   * @type {State}
   */
  function continuationStartNonLazy(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code))
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
    return continuationBefore
  }

  /**
   * In continuation, before non-lazy content.
   *
   * ```markdown
   *   | <x>
   * > | asd
   *     ^
   * ```
   *
   * @type {State}
   */
  function continuationBefore(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code)) {
      return continuationStart(code)
    }

    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlFlowData)
    return continuation(code)
  }

  /**
   * In comment continuation, after one `-`, expecting another.
   *
   * ```markdown
   * > | <!--xxx-->
   *             ^
   * ```
   *
   * @type {State}
   */
  function continuationCommentInside(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash) {
      effects.consume(code)
      return continuationDeclarationInside
    }

    return continuation(code)
  }

  /**
   * In raw continuation, after `<`, at `/`.
   *
   * ```markdown
   * > | <script>console.log(1)</script>
   *                            ^
   * ```
   *
   * @type {State}
   */
  function continuationRawTagOpen(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.slash) {
      effects.consume(code)
      buffer = ''
      return continuationRawEndTag
    }

    return continuation(code)
  }

  /**
   * In raw continuation, after `</`, in a raw tag name.
   *
   * ```markdown
   * > | <script>console.log(1)</script>
   *                             ^^^^^^
   * ```
   *
   * @type {State}
   */
  function continuationRawEndTag(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan) {
      const name = buffer.toLowerCase()

      if (micromark_util_html_tag_name__WEBPACK_IMPORTED_MODULE_1__.htmlRawNames.includes(name)) {
        effects.consume(code)
        return continuationClose
      }

      return continuation(code)
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiAlpha)(code) && buffer.length < micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlRawSizeMax) {
      effects.consume(code)
      // @ts-expect-error: not null.
      buffer += String.fromCharCode(code)
      return continuationRawEndTag
    }

    return continuation(code)
  }

  /**
   * In cdata continuation, after `]`, expecting `]>`.
   *
   * ```markdown
   * > | <![CDATA[>&<]]>
   *                  ^
   * ```
   *
   * @type {State}
   */
  function continuationCdataInside(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.rightSquareBracket) {
      effects.consume(code)
      return continuationDeclarationInside
    }

    return continuation(code)
  }

  /**
   * In declaration or instruction continuation, at `>`.
   *
   * ```markdown
   * > | <!-->
   *         ^
   * > | <?>
   *       ^
   * > | <!q>
   *        ^
   * > | <!--ab-->
   *             ^
   * > | <![CDATA[>&<]]>
   *                   ^
   * ```
   *
   * @type {State}
   */
  function continuationDeclarationInside(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan) {
      effects.consume(code)
      return continuationClose
    }

    // More dashes.
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash && marker === micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.htmlComment) {
      effects.consume(code)
      return continuationDeclarationInside
    }

    return continuation(code)
  }

  /**
   * In closed continuation: everything we get until the eol/eof is part of it.
   *
   * ```markdown
   * > | <!doctype>
   *               ^
   * ```
   *
   * @type {State}
   */
  function continuationClose(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlFlowData)
      return continuationAfter(code)
    }

    effects.consume(code)
    return continuationClose
  }

  /**
   * Done.
   *
   * ```markdown
   * > | <!doctype>
   *               ^
   * ```
   *
   * @type {State}
   */
  function continuationAfter(code) {
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlFlow)
    // // Feel free to interrupt.
    // tokenizer.interrupt = false
    // // No longer concrete.
    // tokenizer.concrete = false
    return ok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeNonLazyContinuationStart(effects, ok, nok) {
  const self = this

  return start

  /**
   * At eol, before continuation.
   *
   * ```markdown
   * > | * ```js
   *            ^
   *   | b
   * ```
   *
   * @type {State}
   */
  function start(code) {
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code)) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
      return after
    }

    return nok(code)
  }

  /**
   * A continuation.
   *
   * ```markdown
   *   | * ```js
   * > | b
   *     ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeBlankLineBefore(effects, ok, nok) {
  return start

  /**
   * Before eol, expecting blank line.
   *
   * ```markdown
   * > | <div>
   *          ^
   *   |
   * ```
   *
   * @type {State}
   */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code), 'expected a line ending')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
    return effects.attempt(_blank_line_js__WEBPACK_IMPORTED_MODULE_6__.blankLine, ok, nok)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/html-text.js":
/*!*********************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/html-text.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   htmlText: () => (/* binding */ htmlText)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */








/** @type {Construct} */
const htmlText = {name: 'htmlText', tokenize: tokenizeHtmlText}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeHtmlText(effects, ok, nok) {
  const self = this
  /** @type {NonNullable<Code> | undefined} */
  let marker
  /** @type {number} */
  let index
  /** @type {State} */
  let returnState

  return start

  /**
   * Start of HTML (text).
   *
   * ```markdown
   * > | a <b> c
   *       ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.lessThan, 'expected `<`')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlText)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlTextData)
    effects.consume(code)
    return open
  }

  /**
   * After `<`, at tag name or other stuff.
   *
   * ```markdown
   * > | a <b> c
   *        ^
   * > | a <!doctype> c
   *        ^
   * > | a <!--b--> c
   *        ^
   * ```
   *
   * @type {State}
   */
  function open(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.exclamationMark) {
      effects.consume(code)
      return declarationOpen
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.slash) {
      effects.consume(code)
      return tagCloseStart
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.questionMark) {
      effects.consume(code)
      return instruction
    }

    // ASCII alphabetical.
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(code)) {
      effects.consume(code)
      return tagOpen
    }

    return nok(code)
  }

  /**
   * After `<!`, at declaration, comment, or CDATA.
   *
   * ```markdown
   * > | a <!doctype> c
   *         ^
   * > | a <!--b--> c
   *         ^
   * > | a <![CDATA[>&<]]> c
   *         ^
   * ```
   *
   * @type {State}
   */
  function declarationOpen(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash) {
      effects.consume(code)
      return commentOpenInside
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.leftSquareBracket) {
      effects.consume(code)
      index = 0
      return cdataOpenInside
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(code)) {
      effects.consume(code)
      return declaration
    }

    return nok(code)
  }

  /**
   * In a comment, after `<!-`, at another `-`.
   *
   * ```markdown
   * > | a <!--b--> c
   *          ^
   * ```
   *
   * @type {State}
   */
  function commentOpenInside(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash) {
      effects.consume(code)
      return commentEnd
    }

    return nok(code)
  }

  /**
   * In comment.
   *
   * ```markdown
   * > | a <!--b--> c
   *           ^
   * ```
   *
   * @type {State}
   */
  function comment(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof) {
      return nok(code)
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash) {
      effects.consume(code)
      return commentClose
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      returnState = comment
      return lineEndingBefore(code)
    }

    effects.consume(code)
    return comment
  }

  /**
   * In comment, after `-`.
   *
   * ```markdown
   * > | a <!--b--> c
   *             ^
   * ```
   *
   * @type {State}
   */
  function commentClose(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash) {
      effects.consume(code)
      return commentEnd
    }

    return comment(code)
  }

  /**
   * In comment, after `--`.
   *
   * ```markdown
   * > | a <!--b--> c
   *              ^
   * ```
   *
   * @type {State}
   */
  function commentEnd(code) {
    return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan
      ? end(code)
      : code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash
      ? commentClose(code)
      : comment(code)
  }

  /**
   * After `<![`, in CDATA, expecting `CDATA[`.
   *
   * ```markdown
   * > | a <![CDATA[>&<]]> b
   *          ^^^^^^
   * ```
   *
   * @type {State}
   */
  function cdataOpenInside(code) {
    const value = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.cdataOpeningString

    if (code === value.charCodeAt(index++)) {
      effects.consume(code)
      return index === value.length ? cdata : cdataOpenInside
    }

    return nok(code)
  }

  /**
   * In CDATA.
   *
   * ```markdown
   * > | a <![CDATA[>&<]]> b
   *                ^^^
   * ```
   *
   * @type {State}
   */
  function cdata(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof) {
      return nok(code)
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.rightSquareBracket) {
      effects.consume(code)
      return cdataClose
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      returnState = cdata
      return lineEndingBefore(code)
    }

    effects.consume(code)
    return cdata
  }

  /**
   * In CDATA, after `]`, at another `]`.
   *
   * ```markdown
   * > | a <![CDATA[>&<]]> b
   *                    ^
   * ```
   *
   * @type {State}
   */
  function cdataClose(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.rightSquareBracket) {
      effects.consume(code)
      return cdataEnd
    }

    return cdata(code)
  }

  /**
   * In CDATA, after `]]`, at `>`.
   *
   * ```markdown
   * > | a <![CDATA[>&<]]> b
   *                     ^
   * ```
   *
   * @type {State}
   */
  function cdataEnd(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan) {
      return end(code)
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.rightSquareBracket) {
      effects.consume(code)
      return cdataEnd
    }

    return cdata(code)
  }

  /**
   * In declaration.
   *
   * ```markdown
   * > | a <!b> c
   *          ^
   * ```
   *
   * @type {State}
   */
  function declaration(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan) {
      return end(code)
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      returnState = declaration
      return lineEndingBefore(code)
    }

    effects.consume(code)
    return declaration
  }

  /**
   * In instruction.
   *
   * ```markdown
   * > | a <?b?> c
   *         ^
   * ```
   *
   * @type {State}
   */
  function instruction(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof) {
      return nok(code)
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.questionMark) {
      effects.consume(code)
      return instructionClose
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      returnState = instruction
      return lineEndingBefore(code)
    }

    effects.consume(code)
    return instruction
  }

  /**
   * In instruction, after `?`, at `>`.
   *
   * ```markdown
   * > | a <?b?> c
   *           ^
   * ```
   *
   * @type {State}
   */
  function instructionClose(code) {
    return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan ? end(code) : instruction(code)
  }

  /**
   * After `</`, in closing tag, at tag name.
   *
   * ```markdown
   * > | a </b> c
   *         ^
   * ```
   *
   * @type {State}
   */
  function tagCloseStart(code) {
    // ASCII alphabetical.
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(code)) {
      effects.consume(code)
      return tagClose
    }

    return nok(code)
  }

  /**
   * After `</x`, in a tag name.
   *
   * ```markdown
   * > | a </b> c
   *          ^
   * ```
   *
   * @type {State}
   */
  function tagClose(code) {
    // ASCII alphanumerical and `-`.
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlphanumeric)(code)) {
      effects.consume(code)
      return tagClose
    }

    return tagCloseBetween(code)
  }

  /**
   * In closing tag, after tag name.
   *
   * ```markdown
   * > | a </b> c
   *          ^
   * ```
   *
   * @type {State}
   */
  function tagCloseBetween(code) {
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      returnState = tagCloseBetween
      return lineEndingBefore(code)
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)) {
      effects.consume(code)
      return tagCloseBetween
    }

    return end(code)
  }

  /**
   * After `<x`, in opening tag name.
   *
   * ```markdown
   * > | a <b> c
   *         ^
   * ```
   *
   * @type {State}
   */
  function tagOpen(code) {
    // ASCII alphanumerical and `-`.
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlphanumeric)(code)) {
      effects.consume(code)
      return tagOpen
    }

    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.slash ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code)
    ) {
      return tagOpenBetween(code)
    }

    return nok(code)
  }

  /**
   * In opening tag, after tag name.
   *
   * ```markdown
   * > | a <b> c
   *         ^
   * ```
   *
   * @type {State}
   */
  function tagOpenBetween(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.slash) {
      effects.consume(code)
      return end
    }

    // ASCII alphabetical and `:` and `_`.
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.colon || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.underscore || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(code)) {
      effects.consume(code)
      return tagOpenAttributeName
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      returnState = tagOpenBetween
      return lineEndingBefore(code)
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)) {
      effects.consume(code)
      return tagOpenBetween
    }

    return end(code)
  }

  /**
   * In attribute name.
   *
   * ```markdown
   * > | a <b c> d
   *          ^
   * ```
   *
   * @type {State}
   */
  function tagOpenAttributeName(code) {
    // ASCII alphabetical and `-`, `.`, `:`, and `_`.
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dot ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.colon ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.underscore ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlphanumeric)(code)
    ) {
      effects.consume(code)
      return tagOpenAttributeName
    }

    return tagOpenAttributeNameAfter(code)
  }

  /**
   * After attribute name, before initializer, the end of the tag, or
   * whitespace.
   *
   * ```markdown
   * > | a <b c> d
   *           ^
   * ```
   *
   * @type {State}
   */
  function tagOpenAttributeNameAfter(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.equalsTo) {
      effects.consume(code)
      return tagOpenAttributeValueBefore
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      returnState = tagOpenAttributeNameAfter
      return lineEndingBefore(code)
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)) {
      effects.consume(code)
      return tagOpenAttributeNameAfter
    }

    return tagOpenBetween(code)
  }

  /**
   * Before unquoted, double quoted, or single quoted attribute value, allowing
   * whitespace.
   *
   * ```markdown
   * > | a <b c=d> e
   *            ^
   * ```
   *
   * @type {State}
   */
  function tagOpenAttributeValueBefore(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.lessThan ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.equalsTo ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.graveAccent
    ) {
      return nok(code)
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.quotationMark || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.apostrophe) {
      effects.consume(code)
      marker = code
      return tagOpenAttributeValueQuoted
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      returnState = tagOpenAttributeValueBefore
      return lineEndingBefore(code)
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)) {
      effects.consume(code)
      return tagOpenAttributeValueBefore
    }

    effects.consume(code)
    return tagOpenAttributeValueUnquoted
  }

  /**
   * In double or single quoted attribute value.
   *
   * ```markdown
   * > | a <b c="d"> e
   *             ^
   * ```
   *
   * @type {State}
   */
  function tagOpenAttributeValueQuoted(code) {
    if (code === marker) {
      effects.consume(code)
      marker = undefined
      return tagOpenAttributeValueQuotedAfter
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof) {
      return nok(code)
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      returnState = tagOpenAttributeValueQuoted
      return lineEndingBefore(code)
    }

    effects.consume(code)
    return tagOpenAttributeValueQuoted
  }

  /**
   * In unquoted attribute value.
   *
   * ```markdown
   * > | a <b c=d> e
   *            ^
   * ```
   *
   * @type {State}
   */
  function tagOpenAttributeValueUnquoted(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.quotationMark ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.apostrophe ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.lessThan ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.equalsTo ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.graveAccent
    ) {
      return nok(code)
    }

    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.slash ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code)
    ) {
      return tagOpenBetween(code)
    }

    effects.consume(code)
    return tagOpenAttributeValueUnquoted
  }

  /**
   * After double or single quoted attribute value, before whitespace or the end
   * of the tag.
   *
   * ```markdown
   * > | a <b c="d"> e
   *               ^
   * ```
   *
   * @type {State}
   */
  function tagOpenAttributeValueQuotedAfter(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.slash ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code)
    ) {
      return tagOpenBetween(code)
    }

    return nok(code)
  }

  /**
   * In certain circumstances of a tag where only an `>` is allowed.
   *
   * ```markdown
   * > | a <b c="d"> e
   *               ^
   * ```
   *
   * @type {State}
   */
  function end(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.greaterThan) {
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlTextData)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlText)
      return ok
    }

    return nok(code)
  }

  /**
   * At eol.
   *
   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about
   * > empty tokens.
   *
   * ```markdown
   * > | a <!--a
   *            ^
   *   | b-->
   * ```
   *
   * @type {State}
   */
  function lineEndingBefore(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(returnState, 'expected return state')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code), 'expected eol')
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlTextData)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
    return lineEndingAfter
  }

  /**
   * After eol, at optional whitespace.
   *
   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about
   * > empty tokens.
   *
   * ```markdown
   *   | a <!--a
   * > | b-->
   *     ^
   * ```
   *
   * @type {State}
   */
  function lineEndingAfter(code) {
    // Always populated by defaults.
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(
      self.parser.constructs.disable.null,
      'expected `disable.null` to be populated'
    )
    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)
      ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(
          effects,
          lineEndingAfterPrefix,
          micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix,
          self.parser.constructs.disable.null.includes('codeIndented')
            ? undefined
            : micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.tabSize
        )(code)
      : lineEndingAfterPrefix(code)
  }

  /**
   * After eol, after optional whitespace.
   *
   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about
   * > empty tokens.
   *
   * ```markdown
   *   | a <!--a
   * > | b-->
   *     ^
   * ```
   *
   * @type {State}
   */
  function lineEndingAfterPrefix(code) {
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.htmlTextData)
    return returnState(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/label-end.js":
/*!*********************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/label-end.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   labelEnd: () => (/* binding */ labelEnd)
/* harmony export */ });
/* harmony import */ var micromark_factory_destination__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-destination */ "./node_modules/micromark-factory-destination/dev/index.js");
/* harmony import */ var micromark_factory_label__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-factory-label */ "./node_modules/micromark-factory-label/dev/index.js");
/* harmony import */ var micromark_factory_title__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-factory-title */ "./node_modules/micromark-factory-title/dev/index.js");
/* harmony import */ var micromark_factory_whitespace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-factory-whitespace */ "./node_modules/micromark-factory-whitespace/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_chunked__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-chunked */ "./node_modules/micromark-util-chunked/dev/index.js");
/* harmony import */ var micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! micromark-util-normalize-identifier */ "./node_modules/micromark-util-normalize-identifier/dev/index.js");
/* harmony import */ var micromark_util_resolve_all__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! micromark-util-resolve-all */ "./node_modules/micromark-util-resolve-all/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */














/** @type {Construct} */
const labelEnd = {
  name: 'labelEnd',
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
}

/** @type {Construct} */
const resourceConstruct = {tokenize: tokenizeResource}
/** @type {Construct} */
const referenceFullConstruct = {tokenize: tokenizeReferenceFull}
/** @type {Construct} */
const referenceCollapsedConstruct = {tokenize: tokenizeReferenceCollapsed}

/** @type {Resolver} */
function resolveAllLabelEnd(events) {
  let index = -1

  while (++index < events.length) {
    const token = events[index][1]

    if (
      token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelImage ||
      token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelLink ||
      token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelEnd
    ) {
      // Remove the marker.
      events.splice(index + 1, token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelImage ? 4 : 2)
      token.type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.data
      index++
    }
  }

  return events
}

/** @type {Resolver} */
function resolveToLabelEnd(events, context) {
  let index = events.length
  let offset = 0
  /** @type {Token} */
  let token
  /** @type {number | undefined} */
  let open
  /** @type {number | undefined} */
  let close
  /** @type {Array<Event>} */
  let media

  // Find an opening.
  while (index--) {
    token = events[index][1]

    if (open) {
      // If we see another link, or inactive link label, we’ve been here before.
      if (
        token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.link ||
        (token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelLink && token._inactive)
      ) {
        break
      }

      // Mark other link openings as inactive, as we can’t have links in
      // links.
      if (events[index][0] === 'enter' && token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelLink) {
        token._inactive = true
      }
    } else if (close) {
      if (
        events[index][0] === 'enter' &&
        (token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelImage || token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelLink) &&
        !token._balanced
      ) {
        open = index

        if (token.type !== micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelLink) {
          offset = 2
          break
        }
      }
    } else if (token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelEnd) {
      close = index
    }
  }

  (0,uvu_assert__WEBPACK_IMPORTED_MODULE_11__.ok)(open !== undefined, '`open` is supposed to be found')
  ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_11__.ok)(close !== undefined, '`close` is supposed to be found')

  const group = {
    type: events[open][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelLink ? micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.link : micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.image,
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  }

  const label = {
    type: micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.label,
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  }

  const text = {
    type: micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelText,
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  }

  media = [
    ['enter', group, context],
    ['enter', label, context]
  ]

  // Opening marker.
  media = (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_5__.push)(media, events.slice(open + 1, open + offset + 3))

  // Text open.
  media = (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_5__.push)(media, [['enter', text, context]])

  // Always populated by defaults.
  ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_11__.ok)(
    context.parser.constructs.insideSpan.null,
    'expected `insideSpan.null` to be populated'
  )
  // Between.
  media = (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_5__.push)(
    media,
    (0,micromark_util_resolve_all__WEBPACK_IMPORTED_MODULE_7__.resolveAll)(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  )

  // Text close, marker close, label close.
  media = (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_5__.push)(media, [
    ['exit', text, context],
    events[close - 2],
    events[close - 1],
    ['exit', label, context]
  ])

  // Reference, resource, or so.
  media = (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_5__.push)(media, events.slice(close + 1))

  // Media close.
  media = (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_5__.push)(media, [['exit', group, context]])

  ;(0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_5__.splice)(events, open, events.length, media)

  return events
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeLabelEnd(effects, ok, nok) {
  const self = this
  let index = self.events.length
  /** @type {Token} */
  let labelStart
  /** @type {boolean} */
  let defined

  // Find an opening.
  while (index--) {
    if (
      (self.events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelImage ||
        self.events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelLink) &&
      !self.events[index][1]._balanced
    ) {
      labelStart = self.events[index][1]
      break
    }
  }

  return start

  /**
   * Start of label end.
   *
   * ```markdown
   * > | [a](b) c
   *       ^
   * > | [a][b] c
   *       ^
   * > | [a][] b
   *       ^
   * > | [a] b
   * ```
   *
   * @type {State}
   */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_11__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__.codes.rightSquareBracket, 'expected `]`')

    // If there is not an okay opening.
    if (!labelStart) {
      return nok(code)
    }

    // If the corresponding label (link) start is marked as inactive,
    // it means we’d be wrapping a link, like this:
    //
    // ```markdown
    // > | a [b [c](d) e](f) g.
    //                  ^
    // ```
    //
    // We can’t have that, so it’s just balanced brackets.
    if (labelStart._inactive) {
      return labelEndNok(code)
    }

    defined = self.parser.defined.includes(
      (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_6__.normalizeIdentifier)(
        self.sliceSerialize({start: labelStart.end, end: self.now()})
      )
    )
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelEnd)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelMarker)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelMarker)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.labelEnd)
    return after
  }

  /**
   * After `]`.
   *
   * ```markdown
   * > | [a](b) c
   *       ^
   * > | [a][b] c
   *       ^
   * > | [a][] b
   *       ^
   * > | [a] b
   *       ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in
    // an extension.

    // Resource (`[asd](fgh)`)?
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__.codes.leftParenthesis) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code)
    }

    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__.codes.leftSquareBracket) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code)
    }

    // Shortcut (`[asd]`) reference?
    return defined ? labelEndOk(code) : labelEndNok(code)
  }

  /**
   * After `]`, at `[`, but not at a full reference.
   *
   * > 👉 **Note**: we only get here if the label is defined.
   *
   * ```markdown
   * > | [a][] b
   *        ^
   * > | [a] b
   *        ^
   * ```
   *
   * @type {State}
   */
  function referenceNotFull(code) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code)
  }

  /**
   * Done, we found something.
   *
   * ```markdown
   * > | [a](b) c
   *           ^
   * > | [a][b] c
   *           ^
   * > | [a][] b
   *          ^
   * > | [a] b
   *        ^
   * ```
   *
   * @type {State}
   */
  function labelEndOk(code) {
    // Note: `markdown-rs` does a bunch of stuff here.
    return ok(code)
  }

  /**
   * Done, it’s nothing.
   *
   * There was an okay opening, but we didn’t match anything.
   *
   * ```markdown
   * > | [a](b c
   *        ^
   * > | [a][b c
   *        ^
   * > | [a] b
   *        ^
   * ```
   *
   * @type {State}
   */
  function labelEndNok(code) {
    labelStart._balanced = true
    return nok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeResource(effects, ok, nok) {
  return resourceStart

  /**
   * At a resource.
   *
   * ```markdown
   * > | [a](b) c
   *        ^
   * ```
   *
   * @type {State}
   */
  function resourceStart(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_11__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__.codes.leftParenthesis, 'expected left paren')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resource)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resourceMarker)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resourceMarker)
    return resourceBefore
  }

  /**
   * In resource, after `(`, at optional whitespace.
   *
   * ```markdown
   * > | [a](b) c
   *         ^
   * ```
   *
   * @type {State}
   */
  function resourceBefore(code) {
    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEndingOrSpace)(code)
      ? (0,micromark_factory_whitespace__WEBPACK_IMPORTED_MODULE_3__.factoryWhitespace)(effects, resourceOpen)(code)
      : resourceOpen(code)
  }

  /**
   * In resource, after optional whitespace, at `)` or a destination.
   *
   * ```markdown
   * > | [a](b) c
   *         ^
   * ```
   *
   * @type {State}
   */
  function resourceOpen(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__.codes.rightParenthesis) {
      return resourceEnd(code)
    }

    return (0,micromark_factory_destination__WEBPACK_IMPORTED_MODULE_0__.factoryDestination)(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resourceDestination,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resourceDestinationLiteral,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resourceDestinationLiteralMarker,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resourceDestinationRaw,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resourceDestinationString,
      micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_9__.constants.linkResourceDestinationBalanceMax
    )(code)
  }

  /**
   * In resource, after destination, at optional whitespace.
   *
   * ```markdown
   * > | [a](b) c
   *          ^
   * ```
   *
   * @type {State}
   */
  function resourceDestinationAfter(code) {
    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEndingOrSpace)(code)
      ? (0,micromark_factory_whitespace__WEBPACK_IMPORTED_MODULE_3__.factoryWhitespace)(effects, resourceBetween)(code)
      : resourceEnd(code)
  }

  /**
   * At invalid destination.
   *
   * ```markdown
   * > | [a](<<) b
   *         ^
   * ```
   *
   * @type {State}
   */
  function resourceDestinationMissing(code) {
    return nok(code)
  }

  /**
   * In resource, after destination and whitespace, at `(` or title.
   *
   * ```markdown
   * > | [a](b ) c
   *           ^
   * ```
   *
   * @type {State}
   */
  function resourceBetween(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__.codes.quotationMark ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__.codes.apostrophe ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__.codes.leftParenthesis
    ) {
      return (0,micromark_factory_title__WEBPACK_IMPORTED_MODULE_2__.factoryTitle)(
        effects,
        resourceTitleAfter,
        nok,
        micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resourceTitle,
        micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resourceTitleMarker,
        micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resourceTitleString
      )(code)
    }

    return resourceEnd(code)
  }

  /**
   * In resource, after title, at optional whitespace.
   *
   * ```markdown
   * > | [a](b "c") d
   *              ^
   * ```
   *
   * @type {State}
   */
  function resourceTitleAfter(code) {
    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEndingOrSpace)(code)
      ? (0,micromark_factory_whitespace__WEBPACK_IMPORTED_MODULE_3__.factoryWhitespace)(effects, resourceEnd)(code)
      : resourceEnd(code)
  }

  /**
   * In resource, at `)`.
   *
   * ```markdown
   * > | [a](b) d
   *          ^
   * ```
   *
   * @type {State}
   */
  function resourceEnd(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__.codes.rightParenthesis) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resourceMarker)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resourceMarker)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.resource)
      return ok
    }

    return nok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeReferenceFull(effects, ok, nok) {
  const self = this

  return referenceFull

  /**
   * In a reference (full), at the `[`.
   *
   * ```markdown
   * > | [a][b] d
   *        ^
   * ```
   *
   * @type {State}
   */
  function referenceFull(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_11__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__.codes.leftSquareBracket, 'expected left bracket')
    return micromark_factory_label__WEBPACK_IMPORTED_MODULE_1__.factoryLabel.call(
      self,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.reference,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.referenceMarker,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.referenceString
    )(code)
  }

  /**
   * In a reference (full), after `]`.
   *
   * ```markdown
   * > | [a][b] d
   *          ^
   * ```
   *
   * @type {State}
   */
  function referenceFullAfter(code) {
    return self.parser.defined.includes(
      (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_6__.normalizeIdentifier)(
        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
      )
    )
      ? ok(code)
      : nok(code)
  }

  /**
   * In reference (full) that was missing.
   *
   * ```markdown
   * > | [a][b d
   *        ^
   * ```
   *
   * @type {State}
   */
  function referenceFullMissing(code) {
    return nok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeReferenceCollapsed(effects, ok, nok) {
  return referenceCollapsedStart

  /**
   * In reference (collapsed), at `[`.
   *
   * > 👉 **Note**: we only get here if the label is defined.
   *
   * ```markdown
   * > | [a][] d
   *        ^
   * ```
   *
   * @type {State}
   */
  function referenceCollapsedStart(code) {
    // We only attempt a collapsed label if there’s a `[`.
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_11__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__.codes.leftSquareBracket, 'expected left bracket')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.reference)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.referenceMarker)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.referenceMarker)
    return referenceCollapsedOpen
  }

  /**
   * In reference (collapsed), at `]`.
   *
   * > 👉 **Note**: we only get here if the label is defined.
   *
   * ```markdown
   * > | [a][] d
   *         ^
   * ```
   *
   *  @type {State}
   */
  function referenceCollapsedOpen(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_8__.codes.rightSquareBracket) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.referenceMarker)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.referenceMarker)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_10__.types.reference)
      return ok
    }

    return nok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/label-start-image.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/label-start-image.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   labelStartImage: () => (/* binding */ labelStartImage)
/* harmony export */ });
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/* harmony import */ var _label_end_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./label-end.js */ "./node_modules/micromark-core-commonmark/dev/lib/label-end.js");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */






/** @type {Construct} */
const labelStartImage = {
  name: 'labelStartImage',
  tokenize: tokenizeLabelStartImage,
  resolveAll: _label_end_js__WEBPACK_IMPORTED_MODULE_3__.labelEnd.resolveAll
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeLabelStartImage(effects, ok, nok) {
  const self = this

  return start

  /**
   * Start of label (image) start.
   *
   * ```markdown
   * > | a ![b] c
   *       ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_2__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.exclamationMark, 'expected `!`')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.labelImage)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.labelImageMarker)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.labelImageMarker)
    return open
  }

  /**
   * After `!`, at `[`.
   *
   * ```markdown
   * > | a ![b] c
   *        ^
   * ```
   *
   * @type {State}
   */
  function open(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.labelMarker)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.labelMarker)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.labelImage)
      return after
    }

    return nok(code)
  }

  /**
   * After `![`.
   *
   * ```markdown
   * > | a ![b] c
   *         ^
   * ```
   *
   * This is needed in because, when GFM footnotes are enabled, images never
   * form when started with a `^`.
   * Instead, links form:
   *
   * ```markdown
   * ![^a](b)
   *
   * ![^a][b]
   *
   * [b]: c
   * ```
   *
   * ```html
   * <p>!<a href=\"b\">^a</a></p>
   * <p>!<a href=\"c\">^a</a></p>
   * ```
   *
   * @type {State}
   */
  function after(code) {
    // To do: use a new field to do this, this is still needed for
    // `micromark-extension-gfm-footnote`, but the `label-start-link`
    // behavior isn’t.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.caret &&
      '_hiddenFootnoteSupport' in self.parser.constructs
      ? nok(code)
      : ok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/label-start-link.js":
/*!****************************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/label-start-link.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   labelStartLink: () => (/* binding */ labelStartLink)
/* harmony export */ });
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/* harmony import */ var _label_end_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./label-end.js */ "./node_modules/micromark-core-commonmark/dev/lib/label-end.js");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */






/** @type {Construct} */
const labelStartLink = {
  name: 'labelStartLink',
  tokenize: tokenizeLabelStartLink,
  resolveAll: _label_end_js__WEBPACK_IMPORTED_MODULE_3__.labelEnd.resolveAll
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeLabelStartLink(effects, ok, nok) {
  const self = this

  return start

  /**
   * Start of label (link) start.
   *
   * ```markdown
   * > | a [b] c
   *       ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_2__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket, 'expected `[`')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.labelLink)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.labelMarker)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.labelMarker)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.labelLink)
    return after
  }

  /** @type {State} */
  function after(code) {
    // To do: this isn’t needed in `micromark-extension-gfm-footnote`,
    // remove.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.caret &&
      '_hiddenFootnoteSupport' in self.parser.constructs
      ? nok(code)
      : ok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/line-ending.js":
/*!***********************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/line-ending.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lineEnding: () => (/* binding */ lineEnding)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */






/** @type {Construct} */
const lineEnding = {name: 'lineEnding', tokenize: tokenizeLineEnding}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeLineEnding(effects, ok) {
  return start

  /** @type {State} */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_3__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code), 'expected eol')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEnding)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEnding)
    return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(effects, ok, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.linePrefix)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/list.js":
/*!****************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/list.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   list: () => (/* binding */ list)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/* harmony import */ var _blank_line_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./blank-line.js */ "./node_modules/micromark-core-commonmark/dev/lib/blank-line.js");
/* harmony import */ var _thematic_break_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./thematic-break.js */ "./node_modules/micromark-core-commonmark/dev/lib/thematic-break.js");
/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').ContainerState} ContainerState
 * @typedef {import('micromark-util-types').Exiter} Exiter
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */










/** @type {Construct} */
const list = {
  name: 'list',
  tokenize: tokenizeListStart,
  continuation: {tokenize: tokenizeListContinuation},
  exit: tokenizeListEnd
}

/** @type {Construct} */
const listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
}

/** @type {Construct} */
const indentConstruct = {tokenize: tokenizeIndent, partial: true}

// To do: `markdown-rs` parses list items on their own and later stitches them
// together.

/**
 * @type {Tokenizer}
 * @this {TokenizeContext}
 */
function tokenizeListStart(effects, ok, nok) {
  const self = this
  const tail = self.events[self.events.length - 1]
  let initialSize =
    tail && tail[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix
      ? tail[2].sliceSerialize(tail[1], true).length
      : 0
  let size = 0

  return start

  /** @type {State} */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(self.containerState, 'expected state')
    const kind =
      self.containerState.type ||
      (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.asterisk || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.plusSign || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash
        ? micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listUnordered
        : micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listOrdered)

    if (
      kind === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listUnordered
        ? !self.containerState.marker || code === self.containerState.marker
        : (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiDigit)(code)
    ) {
      if (!self.containerState.type) {
        self.containerState.type = kind
        effects.enter(kind, {_container: true})
      }

      if (kind === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listUnordered) {
        effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefix)
        return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.asterisk || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash
          ? effects.check(_thematic_break_js__WEBPACK_IMPORTED_MODULE_7__.thematicBreak, nok, atMarker)(code)
          : atMarker(code)
      }

      if (!self.interrupt || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.digit1) {
        effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefix)
        effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemValue)
        return inside(code)
      }
    }

    return nok(code)
  }

  /** @type {State} */
  function inside(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(self.containerState, 'expected state')
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiDigit)(code) && ++size < micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.listItemValueSizeMax) {
      effects.consume(code)
      return inside
    }

    if (
      (!self.interrupt || size < 2) &&
      (self.containerState.marker
        ? code === self.containerState.marker
        : code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.rightParenthesis || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dot)
    ) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemValue)
      return atMarker(code)
    }

    return nok(code)
  }

  /**
   * @type {State}
   **/
  function atMarker(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(self.containerState, 'expected state')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(code !== micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof, 'eof (`null`) is not a marker')
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemMarker)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemMarker)
    self.containerState.marker = self.containerState.marker || code
    return effects.check(
      _blank_line_js__WEBPACK_IMPORTED_MODULE_6__.blankLine,
      // Can’t be empty when interrupting.
      self.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    )
  }

  /** @type {State} */
  function onBlank(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(self.containerState, 'expected state')
    self.containerState.initialBlankLine = true
    initialSize++
    return endOfPrefix(code)
  }

  /** @type {State} */
  function otherPrefix(code) {
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefixWhitespace)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefixWhitespace)
      return endOfPrefix
    }

    return nok(code)
  }

  /** @type {State} */
  function endOfPrefix(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(self.containerState, 'expected state')
    self.containerState.size =
      initialSize +
      self.sliceSerialize(effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefix), true).length
    return ok(code)
  }
}

/**
 * @type {Tokenizer}
 * @this {TokenizeContext}
 */
function tokenizeListContinuation(effects, ok, nok) {
  const self = this

  ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(self.containerState, 'expected state')
  self.containerState._closeFlow = undefined

  return effects.check(_blank_line_js__WEBPACK_IMPORTED_MODULE_6__.blankLine, onBlank, notBlank)

  /** @type {State} */
  function onBlank(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(self.containerState, 'expected state')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(typeof self.containerState.size === 'number', 'expected size')
    self.containerState.furtherBlankLines =
      self.containerState.furtherBlankLines ||
      self.containerState.initialBlankLine

    // We have a blank line.
    // Still, try to consume at most the items size.
    return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(
      effects,
      ok,
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemIndent,
      self.containerState.size + 1
    )(code)
  }

  /** @type {State} */
  function notBlank(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(self.containerState, 'expected state')
    if (self.containerState.furtherBlankLines || !(0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)) {
      self.containerState.furtherBlankLines = undefined
      self.containerState.initialBlankLine = undefined
      return notInCurrentItem(code)
    }

    self.containerState.furtherBlankLines = undefined
    self.containerState.initialBlankLine = undefined
    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)
  }

  /** @type {State} */
  function notInCurrentItem(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(self.containerState, 'expected state')
    // While we do continue, we signal that the flow should be closed.
    self.containerState._closeFlow = true
    // As we’re closing flow, we’re no longer interrupting.
    self.interrupt = undefined
    // Always populated by defaults.
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(
      self.parser.constructs.disable.null,
      'expected `disable.null` to be populated'
    )
    return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(
      effects,
      effects.attempt(list, ok, nok),
      micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix,
      self.parser.constructs.disable.null.includes('codeIndented')
        ? undefined
        : micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.tabSize
    )(code)
  }
}

/**
 * @type {Tokenizer}
 * @this {TokenizeContext}
 */
function tokenizeIndent(effects, ok, nok) {
  const self = this

  ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(self.containerState, 'expected state')
  ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(typeof self.containerState.size === 'number', 'expected size')

  return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(
    effects,
    afterPrefix,
    micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemIndent,
    self.containerState.size + 1
  )

  /** @type {State} */
  function afterPrefix(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(self.containerState, 'expected state')
    const tail = self.events[self.events.length - 1]
    return tail &&
      tail[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemIndent &&
      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size
      ? ok(code)
      : nok(code)
  }
}

/**
 * @type {Exiter}
 * @this {TokenizeContext}
 */
function tokenizeListEnd(effects) {
  (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(this.containerState, 'expected state')
  ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(typeof this.containerState.type === 'string', 'expected type')
  effects.exit(this.containerState.type)
}

/**
 * @type {Tokenizer}
 * @this {TokenizeContext}
 */
function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
  const self = this

  // Always populated by defaults.
  ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(
    self.parser.constructs.disable.null,
    'expected `disable.null` to be populated'
  )

  return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(
    effects,
    afterPrefix,
    micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefixWhitespace,
    self.parser.constructs.disable.null.includes('codeIndented')
      ? undefined
      : micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.tabSize + 1
  )

  /** @type {State} */
  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1]

    return !(0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code) &&
      tail &&
      tail[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.listItemPrefixWhitespace
      ? ok(code)
      : nok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/setext-underline.js":
/*!****************************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/setext-underline.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setextUnderline: () => (/* binding */ setextUnderline)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */







/** @type {Construct} */
const setextUnderline = {
  name: 'setextUnderline',
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
}

/** @type {Resolver} */
function resolveToSetextUnderline(events, context) {
  // To do: resolve like `markdown-rs`.
  let index = events.length
  /** @type {number | undefined} */
  let content
  /** @type {number | undefined} */
  let text
  /** @type {number | undefined} */
  let definition

  // Find the opening of the content.
  // It’ll always exist: we don’t tokenize if it isn’t there.
  while (index--) {
    if (events[index][0] === 'enter') {
      if (events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.content) {
        content = index
        break
      }

      if (events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.paragraph) {
        text = index
      }
    }
    // Exit
    else {
      if (events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.content) {
        // Remove the content end (if needed we’ll add it later)
        events.splice(index, 1)
      }

      if (!definition && events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.definition) {
        definition = index
      }
    }
  }

  (0,uvu_assert__WEBPACK_IMPORTED_MODULE_4__.ok)(text !== undefined, 'expected a `text` index to be found')
  ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_4__.ok)(content !== undefined, 'expected a `text` index to be found')

  const heading = {
    type: micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.setextHeading,
    start: Object.assign({}, events[text][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  }

  // Change the paragraph to setext heading text.
  events[text][1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.setextHeadingText

  // If we have definitions in the content, we’ll keep on having content,
  // but we need move it.
  if (definition) {
    events.splice(text, 0, ['enter', heading, context])
    events.splice(definition + 1, 0, ['exit', events[content][1], context])
    events[content][1].end = Object.assign({}, events[definition][1].end)
  } else {
    events[content][1] = heading
  }

  // Add the heading exit at the end.
  events.push(['exit', heading, context])

  return events
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeSetextUnderline(effects, ok, nok) {
  const self = this
  /** @type {NonNullable<Code>} */
  let marker

  return start

  /**
   * At start of heading (setext) underline.
   *
   * ```markdown
   *   | aa
   * > | ==
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    let index = self.events.length
    /** @type {boolean | undefined} */
    let paragraph

    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_4__.ok)(
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.equalsTo,
      'expected `=` or `-`'
    )

    // Find an opening.
    while (index--) {
      // Skip enter/exit of line ending, line prefix, and content.
      // We can now either have a definition or a paragraph.
      if (
        self.events[index][1].type !== micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding &&
        self.events[index][1].type !== micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.linePrefix &&
        self.events[index][1].type !== micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.content
      ) {
        paragraph = self.events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.paragraph
        break
      }
    }

    // To do: handle lazy/pierce like `markdown-rs`.
    // To do: parse indent like `markdown-rs`.
    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.setextHeadingLine)
      marker = code
      return before(code)
    }

    return nok(code)
  }

  /**
   * After optional whitespace, at `-` or `=`.
   *
   * ```markdown
   *   | aa
   * > | ==
   *     ^
   * ```
   *
   * @type {State}
   */
  function before(code) {
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.setextHeadingLineSequence)
    return inside(code)
  }

  /**
   * In sequence.
   *
   * ```markdown
   *   | aa
   * > | ==
   *     ^
   * ```
   *
   * @type {State}
   */
  function inside(code) {
    if (code === marker) {
      effects.consume(code)
      return inside
    }

    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.setextHeadingLineSequence)

    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)
      ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(effects, after, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.lineSuffix)(code)
      : after(code)
  }

  /**
   * After sequence, after optional whitespace.
   *
   * ```markdown
   *   | aa
   * > | ==
   *       ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.setextHeadingLine)
      return ok(code)
    }

    return nok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-core-commonmark/dev/lib/thematic-break.js":
/*!**************************************************************************!*\
  !*** ./node_modules/micromark-core-commonmark/dev/lib/thematic-break.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   thematicBreak: () => (/* binding */ thematicBreak)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */








/** @type {Construct} */
const thematicBreak = {
  name: 'thematicBreak',
  tokenize: tokenizeThematicBreak
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeThematicBreak(effects, ok, nok) {
  let size = 0
  /** @type {NonNullable<Code>} */
  let marker

  return start

  /**
   * Start of thematic break.
   *
   * ```markdown
   * > | ***
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.thematicBreak)
    // To do: parse indent like `markdown-rs`.
    return before(code)
  }

  /**
   * After optional whitespace, at marker.
   *
   * ```markdown
   * > | ***
   *     ^
   * ```
   *
   * @type {State}
   */
  function before(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.asterisk ||
        code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash ||
        code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.underscore,
      'expected `*`, `-`, or `_`'
    )
    marker = code
    return atBreak(code)
  }

  /**
   * After something, before something else.
   *
   * ```markdown
   * > | ***
   *     ^
   * ```
   *
   * @type {State}
   */
  function atBreak(code) {
    if (code === marker) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.thematicBreakSequence)
      return sequence(code)
    }

    if (
      size >= micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.thematicBreakMarkerCountMin &&
      (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code))
    ) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.thematicBreak)
      return ok(code)
    }

    return nok(code)
  }

  /**
   * In sequence.
   *
   * ```markdown
   * > | ***
   *     ^
   * ```
   *
   * @type {State}
   */
  function sequence(code) {
    if (code === marker) {
      effects.consume(code)
      size++
      return sequence
    }

    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.thematicBreakSequence)
    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)
      ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(effects, atBreak, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.whitespace)(code)
      : atBreak(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-factory-destination/dev/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/micromark-factory-destination/dev/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   factoryDestination: () => (/* binding */ factoryDestination)
/* harmony export */ });
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenType} TokenType
 */






/**
 * Parse destinations.
 *
 * ###### Examples
 *
 * ```markdown
 * <a>
 * <a\>b>
 * <a b>
 * <a)>
 * a
 * a\)b
 * a(b)c
 * a(b)
 * ```
 *
 * @param {Effects} effects
 *   Context.
 * @param {State} ok
 *   State switched to when successful.
 * @param {State} nok
 *   State switched to when unsuccessful.
 * @param {TokenType} type
 *   Type for whole (`<a>` or `b`).
 * @param {TokenType} literalType
 *   Type when enclosed (`<a>`).
 * @param {TokenType} literalMarkerType
 *   Type for enclosing (`<` and `>`).
 * @param {TokenType} rawType
 *   Type when not enclosed (`b`).
 * @param {TokenType} stringType
 *   Type for the value (`a` or `b`).
 * @param {number | undefined} [max=Infinity]
 *   Depth of nested parens (inclusive).
 * @returns {State}
 *   Start state.
 */
// eslint-disable-next-line max-params
function factoryDestination(
  effects,
  ok,
  nok,
  type,
  literalType,
  literalMarkerType,
  rawType,
  stringType,
  max
) {
  const limit = max || Number.POSITIVE_INFINITY
  let balance = 0

  return start

  /**
   * Start of destination.
   *
   * ```markdown
   * > | <aa>
   *     ^
   * > | aa
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.lessThan) {
      effects.enter(type)
      effects.enter(literalType)
      effects.enter(literalMarkerType)
      effects.consume(code)
      effects.exit(literalMarkerType)
      return enclosedBefore
    }

    // ASCII control, space, closing paren.
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.eof ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.space ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.rightParenthesis ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiControl)(code)
    ) {
      return nok(code)
    }

    effects.enter(type)
    effects.enter(rawType)
    effects.enter(stringType)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.chunkString, {contentType: micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.contentTypeString})
    return raw(code)
  }

  /**
   * After `<`, at an enclosed destination.
   *
   * ```markdown
   * > | <aa>
   *      ^
   * ```
   *
   * @type {State}
   */
  function enclosedBefore(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.greaterThan) {
      effects.enter(literalMarkerType)
      effects.consume(code)
      effects.exit(literalMarkerType)
      effects.exit(literalType)
      effects.exit(type)
      return ok
    }

    effects.enter(stringType)
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.chunkString, {contentType: micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.contentTypeString})
    return enclosed(code)
  }

  /**
   * In enclosed destination.
   *
   * ```markdown
   * > | <aa>
   *      ^
   * ```
   *
   * @type {State}
   */
  function enclosed(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.greaterThan) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.chunkString)
      effects.exit(stringType)
      return enclosedBefore(code)
    }

    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.eof ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.lessThan ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code)
    ) {
      return nok(code)
    }

    effects.consume(code)
    return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.backslash ? enclosedEscape : enclosed
  }

  /**
   * After `\`, at a special character.
   *
   * ```markdown
   * > | <a\*a>
   *        ^
   * ```
   *
   * @type {State}
   */
  function enclosedEscape(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.lessThan ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.greaterThan ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.backslash
    ) {
      effects.consume(code)
      return enclosed
    }

    return enclosed(code)
  }

  /**
   * In raw destination.
   *
   * ```markdown
   * > | aa
   *     ^
   * ```
   *
   * @type {State}
   */
  function raw(code) {
    if (
      !balance &&
      (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.eof ||
        code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.rightParenthesis ||
        (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEndingOrSpace)(code))
    ) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.chunkString)
      effects.exit(stringType)
      effects.exit(rawType)
      effects.exit(type)
      return ok(code)
    }

    if (balance < limit && code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.leftParenthesis) {
      effects.consume(code)
      balance++
      return raw
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.rightParenthesis) {
      effects.consume(code)
      balance--
      return raw
    }

    // ASCII control (but *not* `\0`) and space and `(`.
    // Note: in `markdown-rs`, `\0` exists in codes, in `micromark-js` it
    // doesn’t.
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.eof ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.space ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.leftParenthesis ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.asciiControl)(code)
    ) {
      return nok(code)
    }

    effects.consume(code)
    return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.backslash ? rawEscape : raw
  }

  /**
   * After `\`, at special character.
   *
   * ```markdown
   * > | a\*a
   *       ^
   * ```
   *
   * @type {State}
   */
  function rawEscape(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.leftParenthesis ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.rightParenthesis ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.backslash
    ) {
      effects.consume(code)
      return raw
    }

    return raw(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-factory-label/dev/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/micromark-factory-label/dev/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   factoryLabel: () => (/* binding */ factoryLabel)
/* harmony export */ });
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').TokenType} TokenType
 */







/**
 * Parse labels.
 *
 * > 👉 **Note**: labels in markdown are capped at 999 characters in the string.
 *
 * ###### Examples
 *
 * ```markdown
 * [a]
 * [a
 * b]
 * [a\]b]
 * ```
 *
 * @this {TokenizeContext}
 *   Tokenize context.
 * @param {Effects} effects
 *   Context.
 * @param {State} ok
 *   State switched to when successful.
 * @param {State} nok
 *   State switched to when unsuccessful.
 * @param {TokenType} type
 *   Type of the whole label (`[a]`).
 * @param {TokenType} markerType
 *   Type for the markers (`[` and `]`).
 * @param {TokenType} stringType
 *   Type for the identifier (`a`).
 * @returns {State}
 *   Start state.
 */
// eslint-disable-next-line max-params
function factoryLabel(effects, ok, nok, type, markerType, stringType) {
  const self = this
  let size = 0
  /** @type {boolean} */
  let seen

  return start

  /**
   * Start of label.
   *
   * ```markdown
   * > | [a]
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_4__.ok)(code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.leftSquareBracket, 'expected `[`')
    effects.enter(type)
    effects.enter(markerType)
    effects.consume(code)
    effects.exit(markerType)
    effects.enter(stringType)
    return atBreak
  }

  /**
   * In label, at something, before something else.
   *
   * ```markdown
   * > | [a]
   *      ^
   * ```
   *
   * @type {State}
   */
  function atBreak(code) {
    if (
      size > micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.linkReferenceSizeMax ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.eof ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.leftSquareBracket ||
      (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.rightSquareBracket && !seen) ||
      // To do: remove in the future once we’ve switched from
      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
      // which doesn’t need this.
      // Hidden footnotes hook.
      /* c8 ignore next 3 */
      (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.caret &&
        !size &&
        '_hiddenFootnoteSupport' in self.parser.constructs)
    ) {
      return nok(code)
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.rightSquareBracket) {
      effects.exit(stringType)
      effects.enter(markerType)
      effects.consume(code)
      effects.exit(markerType)
      effects.exit(type)
      return ok
    }

    // To do: indent? Link chunks and EOLs together?
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code)) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding)
      return atBreak
    }

    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.chunkString, {contentType: micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.contentTypeString})
    return labelInside(code)
  }

  /**
   * In label, in text.
   *
   * ```markdown
   * > | [a]
   *      ^
   * ```
   *
   * @type {State}
   */
  function labelInside(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.eof ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.leftSquareBracket ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.rightSquareBracket ||
      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEnding)(code) ||
      size++ > micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.linkReferenceSizeMax
    ) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_3__.types.chunkString)
      return atBreak(code)
    }

    effects.consume(code)
    if (!seen) seen = !(0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownSpace)(code)
    return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.backslash ? labelEscape : labelInside
  }

  /**
   * After `\`, at a special character.
   *
   * ```markdown
   * > | [a\*a]
   *        ^
   * ```
   *
   * @type {State}
   */
  function labelEscape(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.leftSquareBracket ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.backslash ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.rightSquareBracket
    ) {
      effects.consume(code)
      size++
      return labelInside
    }

    return labelInside(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-factory-space/dev/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/micromark-factory-space/dev/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   factorySpace: () => (/* binding */ factorySpace)
/* harmony export */ });
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenType} TokenType
 */



// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.

/**
 * Parse spaces and tabs.
 *
 * There is no `nok` parameter:
 *
 * *   spaces in markdown are often optional, in which case this factory can be
 *     used and `ok` will be switched to whether spaces were found or not
 * *   one line ending or space can be detected with `markdownSpace(code)` right
 *     before using `factorySpace`
 *
 * ###### Examples
 *
 * Where `␉` represents a tab (plus how much it expands) and `␠` represents a
 * single space.
 *
 * ```markdown
 * ␉
 * ␠␠␠␠
 * ␉␠
 * ```
 *
 * @param {Effects} effects
 *   Context.
 * @param {State} ok
 *   State switched to when successful.
 * @param {TokenType} type
 *   Type (`' \t'`).
 * @param {number | undefined} [max=Infinity]
 *   Max (exclusive).
 * @returns
 *   Start state.
 */
function factorySpace(effects, ok, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY
  let size = 0

  return start

  /** @type {State} */
  function start(code) {
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownSpace)(code)) {
      effects.enter(type)
      return prefix(code)
    }

    return ok(code)
  }

  /** @type {State} */
  function prefix(code) {
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownSpace)(code) && size++ < limit) {
      effects.consume(code)
      return prefix
    }

    effects.exit(type)
    return ok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-factory-title/dev/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/micromark-factory-title/dev/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   factoryTitle: () => (/* binding */ factoryTitle)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenType} TokenType
 */







/**
 * Parse titles.
 *
 * ###### Examples
 *
 * ```markdown
 * "a"
 * 'b'
 * (c)
 * "a
 * b"
 * 'a
 *     b'
 * (a\)b)
 * ```
 *
 * @param {Effects} effects
 *   Context.
 * @param {State} ok
 *   State switched to when successful.
 * @param {State} nok
 *   State switched to when unsuccessful.
 * @param {TokenType} type
 *   Type of the whole title (`"a"`, `'b'`, `(c)`).
 * @param {TokenType} markerType
 *   Type for the markers (`"`, `'`, `(`, and `)`).
 * @param {TokenType} stringType
 *   Type for the value (`a`).
 * @returns {State}
 *   Start state.
 */
// eslint-disable-next-line max-params
function factoryTitle(effects, ok, nok, type, markerType, stringType) {
  /** @type {NonNullable<Code>} */
  let marker

  return start

  /**
   * Start of title.
   *
   * ```markdown
   * > | "a"
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    if (
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.quotationMark ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.apostrophe ||
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.leftParenthesis
    ) {
      effects.enter(type)
      effects.enter(markerType)
      effects.consume(code)
      effects.exit(markerType)
      marker = code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.leftParenthesis ? micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.rightParenthesis : code
      return begin
    }

    return nok(code)
  }

  /**
   * After opening marker.
   *
   * This is also used at the closing marker.
   *
   * ```markdown
   * > | "a"
   *      ^
   * ```
   *
   * @type {State}
   */
  function begin(code) {
    if (code === marker) {
      effects.enter(markerType)
      effects.consume(code)
      effects.exit(markerType)
      effects.exit(type)
      return ok
    }

    effects.enter(stringType)
    return atBreak(code)
  }

  /**
   * At something, before something else.
   *
   * ```markdown
   * > | "a"
   *      ^
   * ```
   *
   * @type {State}
   */
  function atBreak(code) {
    if (code === marker) {
      effects.exit(stringType)
      return begin(marker)
    }

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof) {
      return nok(code)
    }

    // Note: blank lines can’t exist in content.
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      // To do: use `space_or_tab_eol_with_options`, connect.
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
      return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(effects, atBreak, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix)
    }

    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.chunkString, {contentType: micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.contentTypeString})
    return inside(code)
  }

  /**
   *
   *
   * @type {State}
   */
  function inside(code) {
    if (code === marker || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.chunkString)
      return atBreak(code)
    }

    effects.consume(code)
    return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.backslash ? escape : inside
  }

  /**
   * After `\`, at a special character.
   *
   * ```markdown
   * > | "a\*b"
   *      ^
   * ```
   *
   * @type {State}
   */
  function escape(code) {
    if (code === marker || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.backslash) {
      effects.consume(code)
      return inside
    }

    return inside(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-factory-whitespace/dev/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/micromark-factory-whitespace/dev/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   factoryWhitespace: () => (/* binding */ factoryWhitespace)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 */





/**
 * Parse spaces and tabs.
 *
 * There is no `nok` parameter:
 *
 * *   line endings or spaces in markdown are often optional, in which case this
 *     factory can be used and `ok` will be switched to whether spaces were found
 *     or not
 * *   one line ending or space can be detected with
 *     `markdownLineEndingOrSpace(code)` right before using `factoryWhitespace`
 *
 * @param {Effects} effects
 *   Context.
 * @param {State} ok
 *   State switched to when successful.
 * @returns
 *   Start state.
 */
function factoryWhitespace(effects, ok) {
  /** @type {boolean} */
  let seen

  return start

  /** @type {State} */
  function start(code) {
    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEnding)
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEnding)
      seen = true
      return start
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownSpace)(code)) {
      return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(
        effects,
        start,
        seen ? micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.linePrefix : micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineSuffix
      )(code)
    }

    return ok(code)
  }
}


/***/ }),

/***/ "./node_modules/micromark-util-character/dev/index.js":
/*!************************************************************!*\
  !*** ./node_modules/micromark-util-character/dev/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asciiAlpha: () => (/* binding */ asciiAlpha),
/* harmony export */   asciiAlphanumeric: () => (/* binding */ asciiAlphanumeric),
/* harmony export */   asciiAtext: () => (/* binding */ asciiAtext),
/* harmony export */   asciiControl: () => (/* binding */ asciiControl),
/* harmony export */   asciiDigit: () => (/* binding */ asciiDigit),
/* harmony export */   asciiHexDigit: () => (/* binding */ asciiHexDigit),
/* harmony export */   asciiPunctuation: () => (/* binding */ asciiPunctuation),
/* harmony export */   markdownLineEnding: () => (/* binding */ markdownLineEnding),
/* harmony export */   markdownLineEndingOrSpace: () => (/* binding */ markdownLineEndingOrSpace),
/* harmony export */   markdownSpace: () => (/* binding */ markdownSpace),
/* harmony export */   unicodePunctuation: () => (/* binding */ unicodePunctuation),
/* harmony export */   unicodeWhitespace: () => (/* binding */ unicodeWhitespace)
/* harmony export */ });
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var _lib_unicode_punctuation_regex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/unicode-punctuation-regex.js */ "./node_modules/micromark-util-character/dev/lib/unicode-punctuation-regex.js");
/**
 * @typedef {import('micromark-util-types').Code} Code
 */




/**
 * Check whether the character code represents an ASCII alpha (`a` through `z`,
 * case insensitive).
 *
 * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.
 *
 * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)
 * to U+005A (`Z`).
 *
 * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)
 * to U+007A (`z`).
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const asciiAlpha = regexCheck(/[A-Za-z]/)

/**
 * Check whether the character code represents an ASCII alphanumeric (`a`
 * through `z`, case insensitive, or `0` through `9`).
 *
 * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha
 * (see `asciiAlpha`).
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/)

/**
 * Check whether the character code represents an ASCII atext.
 *
 * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in
 * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),
 * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F
 * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E
 * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE
 * (`{`) to U+007E TILDE (`~`).
 *
 * See:
 * **\[RFC5322]**:
 * [Internet Message Format](https://tools.ietf.org/html/rfc5322).
 * P. Resnick.
 * IETF.
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/)

/**
 * Check whether a character code is an ASCII control character.
 *
 * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)
 * to U+001F (US), or U+007F (DEL).
 *
 * @param {Code} code
 *   Code.
 * @returns {boolean}
 *   Whether it matches.
 */
function asciiControl(code) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code !== null && (code < micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.space || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.del)
  )
}

/**
 * Check whether the character code represents an ASCII digit (`0` through `9`).
 *
 * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to
 * U+0039 (`9`).
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const asciiDigit = regexCheck(/\d/)

/**
 * Check whether the character code represents an ASCII hex digit (`a` through
 * `f`, case insensitive, or `0` through `9`).
 *
 * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex
 * digit, or an ASCII lower hex digit.
 *
 * An **ASCII upper hex digit** is a character in the inclusive range U+0041
 * (`A`) to U+0046 (`F`).
 *
 * An **ASCII lower hex digit** is a character in the inclusive range U+0061
 * (`a`) to U+0066 (`f`).
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const asciiHexDigit = regexCheck(/[\dA-Fa-f]/)

/**
 * Check whether the character code represents ASCII punctuation.
 *
 * An **ASCII punctuation** is a character in the inclusive ranges U+0021
 * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT
 * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT
 * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)

/**
 * Check whether a character code is a markdown line ending.
 *
 * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN
 * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).
 *
 * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE
 * RETURN (CR) are replaced by these virtual characters depending on whether
 * they occurred together.
 *
 * @param {Code} code
 *   Code.
 * @returns {boolean}
 *   Whether it matches.
 */
function markdownLineEnding(code) {
  return code !== null && code < micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.horizontalTab
}

/**
 * Check whether a character code is a markdown line ending (see
 * `markdownLineEnding`) or markdown space (see `markdownSpace`).
 *
 * @param {Code} code
 *   Code.
 * @returns {boolean}
 *   Whether it matches.
 */
function markdownLineEndingOrSpace(code) {
  return code !== null && (code < micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.nul || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.space)
}

/**
 * Check whether a character code is a markdown space.
 *
 * A **markdown space** is the concrete character U+0020 SPACE (SP) and the
 * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).
 *
 * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is
 * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL
 * SPACE (VS) characters, depending on the column at which the tab occurred.
 *
 * @param {Code} code
 *   Code.
 * @returns {boolean}
 *   Whether it matches.
 */
function markdownSpace(code) {
  return (
    code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.horizontalTab ||
    code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.virtualSpace ||
    code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.space
  )
}

// Size note: removing ASCII from the regex and using `asciiPunctuation` here
// In fact adds to the bundle size.
/**
 * Check whether the character code represents Unicode punctuation.
 *
 * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,
 * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`
 * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`
 * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII
 * punctuation (see `asciiPunctuation`).
 *
 * See:
 * **\[UNICODE]**:
 * [The Unicode Standard](https://www.unicode.org/versions/).
 * Unicode Consortium.
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const unicodePunctuation = regexCheck(_lib_unicode_punctuation_regex_js__WEBPACK_IMPORTED_MODULE_1__.unicodePunctuationRegex)

/**
 * Check whether the character code represents Unicode whitespace.
 *
 * Note that this does handle micromark specific markdown whitespace characters.
 * See `markdownLineEndingOrSpace` to check that.
 *
 * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,
 * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),
 * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\[UNICODE]**).
 *
 * See:
 * **\[UNICODE]**:
 * [The Unicode Standard](https://www.unicode.org/versions/).
 * Unicode Consortium.
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const unicodeWhitespace = regexCheck(/\s/)

/**
 * Create a code check from a regex.
 *
 * @param {RegExp} regex
 * @returns {(code: Code) => boolean}
 */
function regexCheck(regex) {
  return check

  /**
   * Check whether a code matches the bound regex.
   *
   * @param {Code} code
   *   Character code.
   * @returns {boolean}
   *   Whether the character code matches the bound regex.
   */
  function check(code) {
    return code !== null && regex.test(String.fromCharCode(code))
  }
}


/***/ }),

/***/ "./node_modules/micromark-util-character/dev/lib/unicode-punctuation-regex.js":
/*!************************************************************************************!*\
  !*** ./node_modules/micromark-util-character/dev/lib/unicode-punctuation-regex.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   unicodePunctuationRegex: () => (/* binding */ unicodePunctuationRegex)
/* harmony export */ });
// This module is generated by `script/`.
//
// CommonMark handles attention (emphasis, strong) markers based on what comes
// before or after them.
// One such difference is if those characters are Unicode punctuation.
// This script is generated from the Unicode data.

/**
 * Regular expression that matches a unicode punctuation character.
 */
const unicodePunctuationRegex =
  /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/


/***/ }),

/***/ "./node_modules/micromark-util-chunked/dev/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/micromark-util-chunked/dev/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   push: () => (/* binding */ push),
/* harmony export */   splice: () => (/* binding */ splice)
/* harmony export */ });
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");


/**
 * Like `Array#splice`, but smarter for giant arrays.
 *
 * `Array#splice` takes all items to be inserted as individual argument which
 * causes a stack overflow in V8 when trying to insert 100k items for instance.
 *
 * Otherwise, this does not return the removed items, and takes `items` as an
 * array instead of rest parameters.
 *
 * @template {unknown} T
 *   Item type.
 * @param {Array<T>} list
 *   List to operate on.
 * @param {number} start
 *   Index to remove/insert at (can be negative).
 * @param {number} remove
 *   Number of items to remove.
 * @param {Array<T>} items
 *   Items to inject into `list`.
 * @returns {void}
 *   Nothing.
 */
function splice(list, start, remove, items) {
  const end = list.length
  let chunkStart = 0
  /** @type {Array<unknown>} */
  let parameters

  // Make start between zero and `end` (included).
  if (start < 0) {
    start = -start > end ? 0 : end + start
  } else {
    start = start > end ? end : start
  }

  remove = remove > 0 ? remove : 0

  // No need to chunk the items if there’s only a couple (10k) items.
  if (items.length < micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_0__.constants.v8MaxSafeChunkSize) {
    parameters = Array.from(items)
    parameters.unshift(start, remove)
    // @ts-expect-error Hush, it’s fine.
    list.splice(...parameters)
  } else {
    // Delete `remove` items starting from `start`
    if (remove) list.splice(start, remove)

    // Insert the items in chunks to not cause stack overflows.
    while (chunkStart < items.length) {
      parameters = items.slice(
        chunkStart,
        chunkStart + micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_0__.constants.v8MaxSafeChunkSize
      )
      parameters.unshift(start, 0)
      // @ts-expect-error Hush, it’s fine.
      list.splice(...parameters)

      chunkStart += micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_0__.constants.v8MaxSafeChunkSize
      start += micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_0__.constants.v8MaxSafeChunkSize
    }
  }
}

/**
 * Append `items` (an array) at the end of `list` (another array).
 * When `list` was empty, returns `items` instead.
 *
 * This prevents a potentially expensive operation when `list` is empty,
 * and adds items in batches to prevent V8 from hanging.
 *
 * @template {unknown} T
 *   Item type.
 * @param {Array<T>} list
 *   List to operate on.
 * @param {Array<T>} items
 *   Items to add to `list`.
 * @returns {Array<T>}
 *   Either `list` or `items`.
 */
function push(list, items) {
  if (list.length > 0) {
    splice(list, list.length, 0, items)
    return list
  }

  return items
}


/***/ }),

/***/ "./node_modules/micromark-util-classify-character/dev/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/micromark-util-classify-character/dev/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   classifyCharacter: () => (/* binding */ classifyCharacter)
/* harmony export */ });
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/**
 * @typedef {import('micromark-util-types').Code} Code
 */





/**
 * Classify whether a code represents whitespace, punctuation, or something
 * else.
 *
 * Used for attention (emphasis, strong), whose sequences can open or close
 * based on the class of surrounding characters.
 *
 * > 👉 **Note**: eof (`null`) is seen as whitespace.
 *
 * @param {Code} code
 *   Code.
 * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}
 *   Group.
 */
function classifyCharacter(code) {
  if (
    code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.eof ||
    (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.markdownLineEndingOrSpace)(code) ||
    (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.unicodeWhitespace)(code)
  ) {
    return micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.characterGroupWhitespace
  }

  if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_0__.unicodePunctuation)(code)) {
    return micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_2__.constants.characterGroupPunctuation
  }
}


/***/ }),

/***/ "./node_modules/micromark-util-combine-extensions/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/micromark-util-combine-extensions/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   combineExtensions: () => (/* binding */ combineExtensions),
/* harmony export */   combineHtmlExtensions: () => (/* binding */ combineHtmlExtensions)
/* harmony export */ });
/* harmony import */ var micromark_util_chunked__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-chunked */ "./node_modules/micromark-util-chunked/dev/index.js");
/**
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Handles} Handles
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension
 */



const hasOwnProperty = {}.hasOwnProperty

/**
 * Combine multiple syntax extensions into one.
 *
 * @param {Array<Extension>} extensions
 *   List of syntax extensions.
 * @returns {NormalizedExtension}
 *   A single combined extension.
 */
function combineExtensions(extensions) {
  /** @type {NormalizedExtension} */
  const all = {}
  let index = -1

  while (++index < extensions.length) {
    syntaxExtension(all, extensions[index])
  }

  return all
}

/**
 * Merge `extension` into `all`.
 *
 * @param {NormalizedExtension} all
 *   Extension to merge into.
 * @param {Extension} extension
 *   Extension to merge.
 * @returns {void}
 */
function syntaxExtension(all, extension) {
  /** @type {keyof Extension} */
  let hook

  for (hook in extension) {
    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined
    /** @type {Record<string, unknown>} */
    const left = maybe || (all[hook] = {})
    /** @type {Record<string, unknown> | undefined} */
    const right = extension[hook]
    /** @type {string} */
    let code

    if (right) {
      for (code in right) {
        if (!hasOwnProperty.call(left, code)) left[code] = []
        const value = right[code]
        constructs(
          // @ts-expect-error Looks like a list.
          left[code],
          Array.isArray(value) ? value : value ? [value] : []
        )
      }
    }
  }
}

/**
 * Merge `list` into `existing` (both lists of constructs).
 * Mutates `existing`.
 *
 * @param {Array<unknown>} existing
 * @param {Array<unknown>} list
 * @returns {void}
 */
function constructs(existing, list) {
  let index = -1
  /** @type {Array<unknown>} */
  const before = []

  while (++index < list.length) {
    // @ts-expect-error Looks like an object.
    ;(list[index].add === 'after' ? existing : before).push(list[index])
  }

  (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_0__.splice)(existing, 0, 0, before)
}

/**
 * Combine multiple HTML extensions into one.
 *
 * @param {Array<HtmlExtension>} htmlExtensions
 *   List of HTML extensions.
 * @returns {HtmlExtension}
 *   A single combined HTML extension.
 */
function combineHtmlExtensions(htmlExtensions) {
  /** @type {HtmlExtension} */
  const handlers = {}
  let index = -1

  while (++index < htmlExtensions.length) {
    htmlExtension(handlers, htmlExtensions[index])
  }

  return handlers
}

/**
 * Merge `extension` into `all`.
 *
 * @param {HtmlExtension} all
 *   Extension to merge into.
 * @param {HtmlExtension} extension
 *   Extension to merge.
 * @returns {void}
 */
function htmlExtension(all, extension) {
  /** @type {keyof HtmlExtension} */
  let hook

  for (hook in extension) {
    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined
    const left = maybe || (all[hook] = {})
    const right = extension[hook]
    /** @type {keyof Handles} */
    let type

    if (right) {
      for (type in right) {
        // @ts-expect-error assume document vs regular handler are managed correctly.
        left[type] = right[type]
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/micromark-util-decode-numeric-character-reference/dev/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/micromark-util-decode-numeric-character-reference/dev/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decodeNumericCharacterReference: () => (/* binding */ decodeNumericCharacterReference)
/* harmony export */ });
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/values.js */ "./node_modules/micromark-util-symbol/values.js");



/**
 * Turn the number (in string form as either hexa- or plain decimal) coming from
 * a numeric character reference into a character.
 *
 * Sort of like `String.fromCharCode(Number.parseInt(value, base))`, but makes
 * non-characters and control characters safe.
 *
 * @param {string} value
 *   Value to decode.
 * @param {number} base
 *   Numeric base.
 * @returns {string}
 *   Character.
 */
function decodeNumericCharacterReference(value, base) {
  const code = Number.parseInt(value, base)

  if (
    // C0 except for HT, LF, FF, CR, space.
    code < micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.ht ||
    code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.vt ||
    (code > micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.cr && code < micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.space) ||
    // Control character (DEL) of C0, and C1 controls.
    (code > micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.tilde && code < 160) ||
    // Lone high surrogates and low surrogates.
    (code > 55295 && code < 57344) ||
    // Noncharacters.
    (code > 64975 && code < 65008) ||
    /* eslint-disable no-bitwise */
    (code & 65535) === 65535 ||
    (code & 65535) === 65534 ||
    /* eslint-enable no-bitwise */
    // Out of range
    code > 1114111
  ) {
    return micromark_util_symbol_values_js__WEBPACK_IMPORTED_MODULE_1__.values.replacementCharacter
  }

  return String.fromCharCode(code)
}


/***/ }),

/***/ "./node_modules/micromark-util-decode-string/dev/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/micromark-util-decode-string/dev/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decodeString: () => (/* binding */ decodeString)
/* harmony export */ });
/* harmony import */ var decode_named_character_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! decode-named-character-reference */ "./node_modules/decode-named-character-reference/index.dom.js");
/* harmony import */ var micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-decode-numeric-character-reference */ "./node_modules/micromark-util-decode-numeric-character-reference/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");





const characterEscapeOrReference =
  /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi

/**
 * Decode markdown strings (which occur in places such as fenced code info
 * strings, destinations, labels, and titles).
 *
 * The “string” content type allows character escapes and -references.
 * This decodes those.
 *
 * @param {string} value
 *   Value to decode.
 * @returns {string}
 *   Decoded value.
 */
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode)
}

/**
 * @param {string} $0
 * @param {string} $1
 * @param {string} $2
 * @returns {string}
 */
function decode($0, $1, $2) {
  if ($1) {
    // Escape.
    return $1
  }

  // Reference.
  const head = $2.charCodeAt(0)

  if (head === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.numberSign) {
    const head = $2.charCodeAt(1)
    const hex = head === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.lowercaseX || head === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.uppercaseX
    return (0,micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_1__.decodeNumericCharacterReference)(
      $2.slice(hex ? 2 : 1),
      hex ? micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.numericBaseHexadecimal : micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.numericBaseDecimal
    )
  }

  return (0,decode_named_character_reference__WEBPACK_IMPORTED_MODULE_0__.decodeNamedCharacterReference)($2) || $0
}


/***/ }),

/***/ "./node_modules/micromark-util-html-tag-name/index.js":
/*!************************************************************!*\
  !*** ./node_modules/micromark-util-html-tag-name/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   htmlBlockNames: () => (/* binding */ htmlBlockNames),
/* harmony export */   htmlRawNames: () => (/* binding */ htmlRawNames)
/* harmony export */ });
/**
 * List of lowercase HTML “block” tag names.
 *
 * The list, when parsing HTML (flow), results in more relaxed rules (condition
 * 6).
 * Because they are known blocks, the HTML-like syntax doesn’t have to be
 * strictly parsed.
 * For tag names not in this list, a more strict algorithm (condition 7) is used
 * to detect whether the HTML-like syntax is seen as HTML (flow) or not.
 *
 * This is copied from:
 * <https://spec.commonmark.org/0.30/#html-blocks>.
 *
 * > 👉 **Note**: `search` was added in `CommonMark@0.31`.
 */
const htmlBlockNames = [
  'address',
  'article',
  'aside',
  'base',
  'basefont',
  'blockquote',
  'body',
  'caption',
  'center',
  'col',
  'colgroup',
  'dd',
  'details',
  'dialog',
  'dir',
  'div',
  'dl',
  'dt',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'frame',
  'frameset',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hr',
  'html',
  'iframe',
  'legend',
  'li',
  'link',
  'main',
  'menu',
  'menuitem',
  'nav',
  'noframes',
  'ol',
  'optgroup',
  'option',
  'p',
  'param',
  'search',
  'section',
  'summary',
  'table',
  'tbody',
  'td',
  'tfoot',
  'th',
  'thead',
  'title',
  'tr',
  'track',
  'ul'
]

/**
 * List of lowercase HTML “raw” tag names.
 *
 * The list, when parsing HTML (flow), results in HTML that can include lines
 * without exiting, until a closing tag also in this list is found (condition
 * 1).
 *
 * This module is copied from:
 * <https://spec.commonmark.org/0.30/#html-blocks>.
 *
 * > 👉 **Note**: `textarea` was added in `CommonMark@0.30`.
 */
const htmlRawNames = ['pre', 'script', 'style', 'textarea']


/***/ }),

/***/ "./node_modules/micromark-util-normalize-identifier/dev/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/micromark-util-normalize-identifier/dev/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   normalizeIdentifier: () => (/* binding */ normalizeIdentifier)
/* harmony export */ });
/* harmony import */ var micromark_util_symbol_values_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol/values.js */ "./node_modules/micromark-util-symbol/values.js");


/**
 * Normalize an identifier (as found in references, definitions).
 *
 * Collapses markdown whitespace, trim, and then lower- and uppercase.
 *
 * Some characters are considered “uppercase”, such as U+03F4 (`ϴ`), but if their
 * lowercase counterpart (U+03B8 (`θ`)) is uppercased will result in a different
 * uppercase character (U+0398 (`Θ`)).
 * So, to get a canonical form, we perform both lower- and uppercase.
 *
 * Using uppercase last makes sure keys will never interact with default
 * prototypal values (such as `constructor`): nothing in the prototype of
 * `Object` is uppercase.
 *
 * @param {string} value
 *   Identifier to normalize.
 * @returns {string}
 *   Normalized identifier.
 */
function normalizeIdentifier(value) {
  return (
    value
      // Collapse markdown whitespace.
      .replace(/[\t\n\r ]+/g, micromark_util_symbol_values_js__WEBPACK_IMPORTED_MODULE_0__.values.space)
      // Trim.
      .replace(/^ | $/g, '')
      // Some characters are considered “uppercase”, but if their lowercase
      // counterpart is uppercased will result in a different uppercase
      // character.
      // Hence, to get that form, we perform both lower- and uppercase.
      // Upper case makes sure keys will not interact with default prototypal
      // methods: no method is uppercase.
      .toLowerCase()
      .toUpperCase()
  )
}


/***/ }),

/***/ "./node_modules/micromark-util-resolve-all/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/micromark-util-resolve-all/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveAll: () => (/* binding */ resolveAll)
/* harmony export */ });
/**
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 */

/**
 * Call all `resolveAll`s.
 *
 * @param {Array<{resolveAll?: Resolver | undefined}>} constructs
 *   List of constructs, optionally with `resolveAll`s.
 * @param {Array<Event>} events
 *   List of events.
 * @param {TokenizeContext} context
 *   Context used by `tokenize`.
 * @returns {Array<Event>}
 *   Changed events.
 */
function resolveAll(constructs, events, context) {
  /** @type {Array<Resolver>} */
  const called = []
  let index = -1

  while (++index < constructs.length) {
    const resolve = constructs[index].resolveAll

    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context)
      called.push(resolve)
    }
  }

  return events
}


/***/ }),

/***/ "./node_modules/micromark-util-subtokenize/dev/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/micromark-util-subtokenize/dev/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   subtokenize: () => (/* binding */ subtokenize)
/* harmony export */ });
/* harmony import */ var micromark_util_chunked__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-chunked */ "./node_modules/micromark-util-chunked/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Chunk} Chunk
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Token} Token
 */






/**
 * Tokenize subcontent.
 *
 * @param {Array<Event>} events
 *   List of events.
 * @returns {boolean}
 *   Whether subtokens were found.
 */
function subtokenize(events) {
  /** @type {Record<string, number>} */
  const jumps = {}
  let index = -1
  /** @type {Event} */
  let event
  /** @type {number | undefined} */
  let lineIndex
  /** @type {number} */
  let otherIndex
  /** @type {Event} */
  let otherEvent
  /** @type {Array<Event>} */
  let parameters
  /** @type {Array<Event>} */
  let subevents
  /** @type {boolean | undefined} */
  let more

  while (++index < events.length) {
    while (index in jumps) {
      index = jumps[index]
    }

    event = events[index]

    // Add a hook for the GFM tasklist extension, which needs to know if text
    // is in the first content of a list item.
    if (
      index &&
      event[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.chunkFlow &&
      events[index - 1][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.listItemPrefix
    ) {
      (0,uvu_assert__WEBPACK_IMPORTED_MODULE_3__.ok)(event[1]._tokenizer, 'expected `_tokenizer` on subtokens')
      subevents = event[1]._tokenizer.events
      otherIndex = 0

      if (
        otherIndex < subevents.length &&
        subevents[otherIndex][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEndingBlank
      ) {
        otherIndex += 2
      }

      if (
        otherIndex < subevents.length &&
        subevents[otherIndex][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.content
      ) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.content) {
            break
          }

          if (subevents[otherIndex][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true
            otherIndex++
          }
        }
      }
    }

    // Enter.
    if (event[0] === 'enter') {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index))
        index = jumps[index]
        more = true
      }
    }
    // Exit.
    else if (event[1]._container) {
      otherIndex = index
      lineIndex = undefined

      while (otherIndex--) {
        otherEvent = events[otherIndex]

        if (
          otherEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEnding ||
          otherEvent[1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEndingBlank
        ) {
          if (otherEvent[0] === 'enter') {
            if (lineIndex) {
              events[lineIndex][1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEndingBlank
            }

            otherEvent[1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEnding
            lineIndex = otherIndex
          }
        } else {
          break
        }
      }

      if (lineIndex) {
        // Fix position.
        event[1].end = Object.assign({}, events[lineIndex][1].start)

        // Switch container exit w/ line endings.
        parameters = events.slice(lineIndex, index)
        parameters.unshift(event)
        ;(0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_0__.splice)(events, lineIndex, index - lineIndex + 1, parameters)
      }
    }
  }

  return !more
}

/**
 * Tokenize embedded tokens.
 *
 * @param {Array<Event>} events
 * @param {number} eventIndex
 * @returns {Record<string, number>}
 */
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1]
  const context = events[eventIndex][2]
  let startPosition = eventIndex - 1
  /** @type {Array<number>} */
  const startPositions = []
  ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_3__.ok)(token.contentType, 'expected `contentType` on subtokens')
  const tokenizer =
    token._tokenizer || context.parser[token.contentType](token.start)
  const childEvents = tokenizer.events
  /** @type {Array<[number, number]>} */
  const jumps = []
  /** @type {Record<string, number>} */
  const gaps = {}
  /** @type {Array<Chunk>} */
  let stream
  /** @type {Token | undefined} */
  let previous
  let index = -1
  /** @type {Token | undefined} */
  let current = token
  let adjust = 0
  let start = 0
  const breaks = [start]

  // Loop forward through the linked tokens to pass them in order to the
  // subtokenizer.
  while (current) {
    // Find the position of the event for this token.
    while (events[++startPosition][1] !== current) {
      // Empty.
    }

    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_3__.ok)(
      !previous || current.previous === previous,
      'expected previous to match'
    )
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_3__.ok)(!previous || previous.next === current, 'expected next to match')

    startPositions.push(startPosition)

    if (!current._tokenizer) {
      stream = context.sliceStream(current)

      if (!current.next) {
        stream.push(micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_1__.codes.eof)
      }

      if (previous) {
        tokenizer.defineSkip(current.start)
      }

      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true
      }

      tokenizer.write(stream)

      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = undefined
      }
    }

    // Unravel the next token.
    previous = current
    current = current.next
  }

  // Now, loop back through all events (and linked tokens), to figure out which
  // parts belong where.
  current = token

  while (++index < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index][0] === 'exit' &&
      childEvents[index - 1][0] === 'enter' &&
      childEvents[index][1].type === childEvents[index - 1][1].type &&
      childEvents[index][1].start.line !== childEvents[index][1].end.line
    ) {
      (0,uvu_assert__WEBPACK_IMPORTED_MODULE_3__.ok)(current, 'expected a current token')
      start = index + 1
      breaks.push(start)
      // Help GC.
      current._tokenizer = undefined
      current.previous = undefined
      current = current.next
    }
  }

  // Help GC.
  tokenizer.events = []

  // If there’s one more token (which is the cases for lines that end in an
  // EOF), that’s perfect: the last point we found starts it.
  // If there isn’t then make sure any remaining content is added to it.
  if (current) {
    // Help GC.
    current._tokenizer = undefined
    current.previous = undefined
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_3__.ok)(!current.next, 'expected no next token')
  } else {
    breaks.pop()
  }

  // Now splice the events from the subtokenizer into the current events,
  // moving back to front so that splice indices aren’t affected.
  index = breaks.length

  while (index--) {
    const slice = childEvents.slice(breaks[index], breaks[index + 1])
    const start = startPositions.pop()
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_3__.ok)(start !== undefined, 'expected a start position when splicing')
    jumps.unshift([start, start + slice.length - 1])
    ;(0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_0__.splice)(events, start, 2, slice)
  }

  index = -1

  while (++index < jumps.length) {
    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1]
    adjust += jumps[index][1] - jumps[index][0] - 1
  }

  return gaps
}


/***/ }),

/***/ "./node_modules/micromark-util-symbol/codes.js":
/*!*****************************************************!*\
  !*** ./node_modules/micromark-util-symbol/codes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   codes: () => (/* binding */ codes)
/* harmony export */ });
/**
 * Character codes.
 *
 * This module is compiled away!
 *
 * micromark works based on character codes.
 * This module contains constants for the ASCII block and the replacement
 * character.
 * A couple of them are handled in a special way, such as the line endings
 * (CR, LF, and CR+LF, commonly known as end-of-line: EOLs), the tab (horizontal
 * tab) and its expansion based on what column it’s at (virtual space),
 * and the end-of-file (eof) character.
 * As values are preprocessed before handling them, the actual characters LF,
 * CR, HT, and NUL (which is present as the replacement character), are
 * guaranteed to not exist.
 *
 * Unicode basic latin block.
 */
const codes = /** @type {const} */ ({
  carriageReturn: -5,
  lineFeed: -4,
  carriageReturnLineFeed: -3,
  horizontalTab: -2,
  virtualSpace: -1,
  eof: null,
  nul: 0,
  soh: 1,
  stx: 2,
  etx: 3,
  eot: 4,
  enq: 5,
  ack: 6,
  bel: 7,
  bs: 8,
  ht: 9, // `\t`
  lf: 10, // `\n`
  vt: 11, // `\v`
  ff: 12, // `\f`
  cr: 13, // `\r`
  so: 14,
  si: 15,
  dle: 16,
  dc1: 17,
  dc2: 18,
  dc3: 19,
  dc4: 20,
  nak: 21,
  syn: 22,
  etb: 23,
  can: 24,
  em: 25,
  sub: 26,
  esc: 27,
  fs: 28,
  gs: 29,
  rs: 30,
  us: 31,
  space: 32,
  exclamationMark: 33, // `!`
  quotationMark: 34, // `"`
  numberSign: 35, // `#`
  dollarSign: 36, // `$`
  percentSign: 37, // `%`
  ampersand: 38, // `&`
  apostrophe: 39, // `'`
  leftParenthesis: 40, // `(`
  rightParenthesis: 41, // `)`
  asterisk: 42, // `*`
  plusSign: 43, // `+`
  comma: 44, // `,`
  dash: 45, // `-`
  dot: 46, // `.`
  slash: 47, // `/`
  digit0: 48, // `0`
  digit1: 49, // `1`
  digit2: 50, // `2`
  digit3: 51, // `3`
  digit4: 52, // `4`
  digit5: 53, // `5`
  digit6: 54, // `6`
  digit7: 55, // `7`
  digit8: 56, // `8`
  digit9: 57, // `9`
  colon: 58, // `:`
  semicolon: 59, // `;`
  lessThan: 60, // `<`
  equalsTo: 61, // `=`
  greaterThan: 62, // `>`
  questionMark: 63, // `?`
  atSign: 64, // `@`
  uppercaseA: 65, // `A`
  uppercaseB: 66, // `B`
  uppercaseC: 67, // `C`
  uppercaseD: 68, // `D`
  uppercaseE: 69, // `E`
  uppercaseF: 70, // `F`
  uppercaseG: 71, // `G`
  uppercaseH: 72, // `H`
  uppercaseI: 73, // `I`
  uppercaseJ: 74, // `J`
  uppercaseK: 75, // `K`
  uppercaseL: 76, // `L`
  uppercaseM: 77, // `M`
  uppercaseN: 78, // `N`
  uppercaseO: 79, // `O`
  uppercaseP: 80, // `P`
  uppercaseQ: 81, // `Q`
  uppercaseR: 82, // `R`
  uppercaseS: 83, // `S`
  uppercaseT: 84, // `T`
  uppercaseU: 85, // `U`
  uppercaseV: 86, // `V`
  uppercaseW: 87, // `W`
  uppercaseX: 88, // `X`
  uppercaseY: 89, // `Y`
  uppercaseZ: 90, // `Z`
  leftSquareBracket: 91, // `[`
  backslash: 92, // `\`
  rightSquareBracket: 93, // `]`
  caret: 94, // `^`
  underscore: 95, // `_`
  graveAccent: 96, // `` ` ``
  lowercaseA: 97, // `a`
  lowercaseB: 98, // `b`
  lowercaseC: 99, // `c`
  lowercaseD: 100, // `d`
  lowercaseE: 101, // `e`
  lowercaseF: 102, // `f`
  lowercaseG: 103, // `g`
  lowercaseH: 104, // `h`
  lowercaseI: 105, // `i`
  lowercaseJ: 106, // `j`
  lowercaseK: 107, // `k`
  lowercaseL: 108, // `l`
  lowercaseM: 109, // `m`
  lowercaseN: 110, // `n`
  lowercaseO: 111, // `o`
  lowercaseP: 112, // `p`
  lowercaseQ: 113, // `q`
  lowercaseR: 114, // `r`
  lowercaseS: 115, // `s`
  lowercaseT: 116, // `t`
  lowercaseU: 117, // `u`
  lowercaseV: 118, // `v`
  lowercaseW: 119, // `w`
  lowercaseX: 120, // `x`
  lowercaseY: 121, // `y`
  lowercaseZ: 122, // `z`
  leftCurlyBrace: 123, // `{`
  verticalBar: 124, // `|`
  rightCurlyBrace: 125, // `}`
  tilde: 126, // `~`
  del: 127,
  // Unicode Specials block.
  byteOrderMarker: 65279,
  // Unicode Specials block.
  replacementCharacter: 65533 // `�`
})


/***/ }),

/***/ "./node_modules/micromark-util-symbol/constants.js":
/*!*********************************************************!*\
  !*** ./node_modules/micromark-util-symbol/constants.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   constants: () => (/* binding */ constants)
/* harmony export */ });
/**
 * This module is compiled away!
 *
 * Parsing markdown comes with a couple of constants, such as minimum or maximum
 * sizes of certain sequences.
 * Additionally, there are a couple symbols used inside micromark.
 * These are all defined here, but compiled away by scripts.
 */
const constants = /** @type {const} */ ({
  attentionSideBefore: 1, // Symbol to mark an attention sequence as before content: `*a`
  attentionSideAfter: 2, // Symbol to mark an attention sequence as after content: `a*`
  atxHeadingOpeningFenceSizeMax: 6, // 6 number signs is fine, 7 isn’t.
  autolinkDomainSizeMax: 63, // 63 characters is fine, 64 is too many.
  autolinkSchemeSizeMax: 32, // 32 characters is fine, 33 is too many.
  cdataOpeningString: 'CDATA[', // And preceded by `<![`.
  characterGroupWhitespace: 1, // Symbol used to indicate a character is whitespace
  characterGroupPunctuation: 2, // Symbol used to indicate a character is punctuation
  characterReferenceDecimalSizeMax: 7, // `&#9999999;`.
  characterReferenceHexadecimalSizeMax: 6, // `&#xff9999;`.
  characterReferenceNamedSizeMax: 31, // `&CounterClockwiseContourIntegral;`.
  codeFencedSequenceSizeMin: 3, // At least 3 ticks or tildes are needed.
  contentTypeDocument: 'document',
  contentTypeFlow: 'flow',
  contentTypeContent: 'content',
  contentTypeString: 'string',
  contentTypeText: 'text',
  hardBreakPrefixSizeMin: 2, // At least 2 trailing spaces are needed.
  htmlRaw: 1, // Symbol for `<script>`
  htmlComment: 2, // Symbol for `<!---->`
  htmlInstruction: 3, // Symbol for `<?php?>`
  htmlDeclaration: 4, // Symbol for `<!doctype>`
  htmlCdata: 5, // Symbol for `<![CDATA[]]>`
  htmlBasic: 6, // Symbol for `<div`
  htmlComplete: 7, // Symbol for `<x>`
  htmlRawSizeMax: 8, // Length of `textarea`.
  linkResourceDestinationBalanceMax: 32, // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
  linkReferenceSizeMax: 999, // See: <https://spec.commonmark.org/0.30/#link-label>
  listItemValueSizeMax: 10, // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
  numericBaseDecimal: 10,
  numericBaseHexadecimal: 0x10,
  tabSize: 4, // Tabs have a hard-coded size of 4, per CommonMark.
  thematicBreakMarkerCountMin: 3, // At least 3 asterisks, dashes, or underscores are needed.
  v8MaxSafeChunkSize: 10000 // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
})


/***/ }),

/***/ "./node_modules/micromark-util-symbol/types.js":
/*!*****************************************************!*\
  !*** ./node_modules/micromark-util-symbol/types.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   types: () => (/* binding */ types)
/* harmony export */ });
/**
 * This module is compiled away!
 *
 * Here is the list of all types of tokens exposed by micromark, with a short
 * explanation of what they include and where they are found.
 * In picking names, generally, the rule is to be as explicit as possible
 * instead of reusing names.
 * For example, there is a `definitionDestination` and a `resourceDestination`,
 * instead of one shared name.
 */

// Note: when changing the next record, you must also change `TokenTypeMap`
// in `micromark-util-types/index.d.ts`.
const types = /** @type {const} */ ({
  // Generic type for data, such as in a title, a destination, etc.
  data: 'data',

  // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
  // Such as, between a fenced code fence and an info string.
  whitespace: 'whitespace',

  // Generic type for line endings (line feed, carriage return, carriage return +
  // line feed).
  lineEnding: 'lineEnding',

  // A line ending, but ending a blank line.
  lineEndingBlank: 'lineEndingBlank',

  // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
  // line.
  linePrefix: 'linePrefix',

  // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
  // line.
  lineSuffix: 'lineSuffix',

  // Whole ATX heading:
  //
  // ```markdown
  // #
  // ## Alpha
  // ### Bravo ###
  // ```
  //
  // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
  atxHeading: 'atxHeading',

  // Sequence of number signs in an ATX heading (`###`).
  atxHeadingSequence: 'atxHeadingSequence',

  // Content in an ATX heading (`alpha`).
  // Includes text.
  atxHeadingText: 'atxHeadingText',

  // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
  // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
  autolink: 'autolink',

  // Email autolink w/o markers (`admin@example.com`)
  autolinkEmail: 'autolinkEmail',

  // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
  autolinkMarker: 'autolinkMarker',

  // Protocol autolink w/o markers (`https://example.com`)
  autolinkProtocol: 'autolinkProtocol',

  // A whole character escape (`\-`).
  // Includes `escapeMarker` and `characterEscapeValue`.
  characterEscape: 'characterEscape',

  // The escaped character (`-`).
  characterEscapeValue: 'characterEscapeValue',

  // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
  // Includes `characterReferenceMarker`, an optional
  // `characterReferenceMarkerNumeric`, in which case an optional
  // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
  characterReference: 'characterReference',

  // The start or end marker (`&` or `;`).
  characterReferenceMarker: 'characterReferenceMarker',

  // Mark reference as numeric (`#`).
  characterReferenceMarkerNumeric: 'characterReferenceMarkerNumeric',

  // Mark reference as numeric (`x` or `X`).
  characterReferenceMarkerHexadecimal: 'characterReferenceMarkerHexadecimal',

  // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
  characterReferenceValue: 'characterReferenceValue',

  // Whole fenced code:
  //
  // ````markdown
  // ```js
  // alert(1)
  // ```
  // ````
  codeFenced: 'codeFenced',

  // A fenced code fence, including whitespace, sequence, info, and meta
  // (` ```js `).
  codeFencedFence: 'codeFencedFence',

  // Sequence of grave accent or tilde characters (` ``` `) in a fence.
  codeFencedFenceSequence: 'codeFencedFenceSequence',

  // Info word (`js`) in a fence.
  // Includes string.
  codeFencedFenceInfo: 'codeFencedFenceInfo',

  // Meta words (`highlight="1"`) in a fence.
  // Includes string.
  codeFencedFenceMeta: 'codeFencedFenceMeta',

  // A line of code.
  codeFlowValue: 'codeFlowValue',

  // Whole indented code:
  //
  // ```markdown
  //     alert(1)
  // ```
  //
  // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
  codeIndented: 'codeIndented',

  // A text code (``` `alpha` ```).
  // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
  // `codeTextPadding`.
  codeText: 'codeText',

  codeTextData: 'codeTextData',

  // A space or line ending right after or before a tick.
  codeTextPadding: 'codeTextPadding',

  // A text code fence (` `` `).
  codeTextSequence: 'codeTextSequence',

  // Whole content:
  //
  // ```markdown
  // [a]: b
  // c
  // =
  // d
  // ```
  //
  // Includes `paragraph` and `definition`.
  content: 'content',
  // Whole definition:
  //
  // ```markdown
  // [micromark]: https://github.com/micromark/micromark
  // ```
  //
  // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
  // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
  definition: 'definition',

  // Destination of a definition (`https://github.com/micromark/micromark` or
  // `<https://github.com/micromark/micromark>`).
  // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
  definitionDestination: 'definitionDestination',

  // Enclosed destination of a definition
  // (`<https://github.com/micromark/micromark>`).
  // Includes `definitionDestinationLiteralMarker` and optionally
  // `definitionDestinationString`.
  definitionDestinationLiteral: 'definitionDestinationLiteral',

  // Markers of an enclosed definition destination (`<` or `>`).
  definitionDestinationLiteralMarker: 'definitionDestinationLiteralMarker',

  // Unenclosed destination of a definition
  // (`https://github.com/micromark/micromark`).
  // Includes `definitionDestinationString`.
  definitionDestinationRaw: 'definitionDestinationRaw',

  // Text in an destination (`https://github.com/micromark/micromark`).
  // Includes string.
  definitionDestinationString: 'definitionDestinationString',

  // Label of a definition (`[micromark]`).
  // Includes `definitionLabelMarker` and `definitionLabelString`.
  definitionLabel: 'definitionLabel',

  // Markers of a definition label (`[` or `]`).
  definitionLabelMarker: 'definitionLabelMarker',

  // Value of a definition label (`micromark`).
  // Includes string.
  definitionLabelString: 'definitionLabelString',

  // Marker between a label and a destination (`:`).
  definitionMarker: 'definitionMarker',

  // Title of a definition (`"x"`, `'y'`, or `(z)`).
  // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
  definitionTitle: 'definitionTitle',

  // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
  definitionTitleMarker: 'definitionTitleMarker',

  // Data without markers in a title (`z`).
  // Includes string.
  definitionTitleString: 'definitionTitleString',

  // Emphasis (`*alpha*`).
  // Includes `emphasisSequence` and `emphasisText`.
  emphasis: 'emphasis',

  // Sequence of emphasis markers (`*` or `_`).
  emphasisSequence: 'emphasisSequence',

  // Emphasis text (`alpha`).
  // Includes text.
  emphasisText: 'emphasisText',

  // The character escape marker (`\`).
  escapeMarker: 'escapeMarker',

  // A hard break created with a backslash (`\\n`).
  // Note: does not include the line ending.
  hardBreakEscape: 'hardBreakEscape',

  // A hard break created with trailing spaces (`  \n`).
  // Does not include the line ending.
  hardBreakTrailing: 'hardBreakTrailing',

  // Flow HTML:
  //
  // ```markdown
  // <div
  // ```
  //
  // Inlcudes `lineEnding`, `htmlFlowData`.
  htmlFlow: 'htmlFlow',

  htmlFlowData: 'htmlFlowData',

  // HTML in text (the tag in `a <i> b`).
  // Includes `lineEnding`, `htmlTextData`.
  htmlText: 'htmlText',

  htmlTextData: 'htmlTextData',

  // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
  // `![alpha]`).
  // Includes `label` and an optional `resource` or `reference`.
  image: 'image',

  // Whole link label (`[*alpha*]`).
  // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
  label: 'label',

  // Text in an label (`*alpha*`).
  // Includes text.
  labelText: 'labelText',

  // Start a link label (`[`).
  // Includes a `labelMarker`.
  labelLink: 'labelLink',

  // Start an image label (`![`).
  // Includes `labelImageMarker` and `labelMarker`.
  labelImage: 'labelImage',

  // Marker of a label (`[` or `]`).
  labelMarker: 'labelMarker',

  // Marker to start an image (`!`).
  labelImageMarker: 'labelImageMarker',

  // End a label (`]`).
  // Includes `labelMarker`.
  labelEnd: 'labelEnd',

  // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
  // Includes `label` and an optional `resource` or `reference`.
  link: 'link',

  // Whole paragraph:
  //
  // ```markdown
  // alpha
  // bravo.
  // ```
  //
  // Includes text.
  paragraph: 'paragraph',

  // A reference (`[alpha]` or `[]`).
  // Includes `referenceMarker` and an optional `referenceString`.
  reference: 'reference',

  // A reference marker (`[` or `]`).
  referenceMarker: 'referenceMarker',

  // Reference text (`alpha`).
  // Includes string.
  referenceString: 'referenceString',

  // A resource (`(https://example.com "alpha")`).
  // Includes `resourceMarker`, an optional `resourceDestination` with an optional
  // `whitespace` and `resourceTitle`.
  resource: 'resource',

  // A resource destination (`https://example.com`).
  // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
  resourceDestination: 'resourceDestination',

  // A literal resource destination (`<https://example.com>`).
  // Includes `resourceDestinationLiteralMarker` and optionally
  // `resourceDestinationString`.
  resourceDestinationLiteral: 'resourceDestinationLiteral',

  // A resource destination marker (`<` or `>`).
  resourceDestinationLiteralMarker: 'resourceDestinationLiteralMarker',

  // A raw resource destination (`https://example.com`).
  // Includes `resourceDestinationString`.
  resourceDestinationRaw: 'resourceDestinationRaw',

  // Resource destination text (`https://example.com`).
  // Includes string.
  resourceDestinationString: 'resourceDestinationString',

  // A resource marker (`(` or `)`).
  resourceMarker: 'resourceMarker',

  // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
  // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
  resourceTitle: 'resourceTitle',

  // A resource title marker (`"`, `'`, `(`, or `)`).
  resourceTitleMarker: 'resourceTitleMarker',

  // Resource destination title (`alpha`).
  // Includes string.
  resourceTitleString: 'resourceTitleString',

  // Whole setext heading:
  //
  // ```markdown
  // alpha
  // bravo
  // =====
  // ```
  //
  // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
  // `setextHeadingLine`.
  setextHeading: 'setextHeading',

  // Content in a setext heading (`alpha\nbravo`).
  // Includes text.
  setextHeadingText: 'setextHeadingText',

  // Underline in a setext heading, including whitespace suffix (`==`).
  // Includes `setextHeadingLineSequence`.
  setextHeadingLine: 'setextHeadingLine',

  // Sequence of equals or dash characters in underline in a setext heading (`-`).
  setextHeadingLineSequence: 'setextHeadingLineSequence',

  // Strong (`**alpha**`).
  // Includes `strongSequence` and `strongText`.
  strong: 'strong',

  // Sequence of strong markers (`**` or `__`).
  strongSequence: 'strongSequence',

  // Strong text (`alpha`).
  // Includes text.
  strongText: 'strongText',

  // Whole thematic break:
  //
  // ```markdown
  // * * *
  // ```
  //
  // Includes `thematicBreakSequence` and `whitespace`.
  thematicBreak: 'thematicBreak',

  // A sequence of one or more thematic break markers (`***`).
  thematicBreakSequence: 'thematicBreakSequence',

  // Whole block quote:
  //
  // ```markdown
  // > a
  // >
  // > b
  // ```
  //
  // Includes `blockQuotePrefix` and flow.
  blockQuote: 'blockQuote',
  // The `>` or `> ` of a block quote.
  blockQuotePrefix: 'blockQuotePrefix',
  // The `>` of a block quote prefix.
  blockQuoteMarker: 'blockQuoteMarker',
  // The optional ` ` of a block quote prefix.
  blockQuotePrefixWhitespace: 'blockQuotePrefixWhitespace',

  // Whole unordered list:
  //
  // ```markdown
  // - a
  //   b
  // ```
  //
  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
  // lines.
  listOrdered: 'listOrdered',

  // Whole ordered list:
  //
  // ```markdown
  // 1. a
  //    b
  // ```
  //
  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
  // lines.
  listUnordered: 'listUnordered',

  // The indent of further list item lines.
  listItemIndent: 'listItemIndent',

  // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
  listItemMarker: 'listItemMarker',

  // The thing that starts a list item, such as `1. `.
  // Includes `listItemValue` if ordered, `listItemMarker`, and
  // `listItemPrefixWhitespace` (unless followed by a line ending).
  listItemPrefix: 'listItemPrefix',

  // The whitespace after a marker.
  listItemPrefixWhitespace: 'listItemPrefixWhitespace',

  // The numerical value of an ordered item.
  listItemValue: 'listItemValue',

  // Internal types used for subtokenizers, compiled away
  chunkDocument: 'chunkDocument',
  chunkContent: 'chunkContent',
  chunkFlow: 'chunkFlow',
  chunkText: 'chunkText',
  chunkString: 'chunkString'
})


/***/ }),

/***/ "./node_modules/micromark-util-symbol/values.js":
/*!******************************************************!*\
  !*** ./node_modules/micromark-util-symbol/values.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   values: () => (/* binding */ values)
/* harmony export */ });
/**
 * This module is compiled away!
 *
 * While micromark works based on character codes, this module includes the
 * string versions of ’em.
 * The C0 block, except for LF, CR, HT, and w/ the replacement character added,
 * are available here.
 */
const values = /** @type {const} */ ({
  ht: '\t',
  lf: '\n',
  cr: '\r',
  space: ' ',
  exclamationMark: '!',
  quotationMark: '"',
  numberSign: '#',
  dollarSign: '$',
  percentSign: '%',
  ampersand: '&',
  apostrophe: "'",
  leftParenthesis: '(',
  rightParenthesis: ')',
  asterisk: '*',
  plusSign: '+',
  comma: ',',
  dash: '-',
  dot: '.',
  slash: '/',
  digit0: '0',
  digit1: '1',
  digit2: '2',
  digit3: '3',
  digit4: '4',
  digit5: '5',
  digit6: '6',
  digit7: '7',
  digit8: '8',
  digit9: '9',
  colon: ':',
  semicolon: ';',
  lessThan: '<',
  equalsTo: '=',
  greaterThan: '>',
  questionMark: '?',
  atSign: '@',
  uppercaseA: 'A',
  uppercaseB: 'B',
  uppercaseC: 'C',
  uppercaseD: 'D',
  uppercaseE: 'E',
  uppercaseF: 'F',
  uppercaseG: 'G',
  uppercaseH: 'H',
  uppercaseI: 'I',
  uppercaseJ: 'J',
  uppercaseK: 'K',
  uppercaseL: 'L',
  uppercaseM: 'M',
  uppercaseN: 'N',
  uppercaseO: 'O',
  uppercaseP: 'P',
  uppercaseQ: 'Q',
  uppercaseR: 'R',
  uppercaseS: 'S',
  uppercaseT: 'T',
  uppercaseU: 'U',
  uppercaseV: 'V',
  uppercaseW: 'W',
  uppercaseX: 'X',
  uppercaseY: 'Y',
  uppercaseZ: 'Z',
  leftSquareBracket: '[',
  backslash: '\\',
  rightSquareBracket: ']',
  caret: '^',
  underscore: '_',
  graveAccent: '`',
  lowercaseA: 'a',
  lowercaseB: 'b',
  lowercaseC: 'c',
  lowercaseD: 'd',
  lowercaseE: 'e',
  lowercaseF: 'f',
  lowercaseG: 'g',
  lowercaseH: 'h',
  lowercaseI: 'i',
  lowercaseJ: 'j',
  lowercaseK: 'k',
  lowercaseL: 'l',
  lowercaseM: 'm',
  lowercaseN: 'n',
  lowercaseO: 'o',
  lowercaseP: 'p',
  lowercaseQ: 'q',
  lowercaseR: 'r',
  lowercaseS: 's',
  lowercaseT: 't',
  lowercaseU: 'u',
  lowercaseV: 'v',
  lowercaseW: 'w',
  lowercaseX: 'x',
  lowercaseY: 'y',
  lowercaseZ: 'z',
  leftCurlyBrace: '{',
  verticalBar: '|',
  rightCurlyBrace: '}',
  tilde: '~',
  replacementCharacter: '�'
})


/***/ }),

/***/ "./node_modules/micromark/dev/lib/constructs.js":
/*!******************************************************!*\
  !*** ./node_modules/micromark/dev/lib/constructs.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attentionMarkers: () => (/* binding */ attentionMarkers),
/* harmony export */   contentInitial: () => (/* binding */ contentInitial),
/* harmony export */   disable: () => (/* binding */ disable),
/* harmony export */   document: () => (/* binding */ document),
/* harmony export */   flow: () => (/* binding */ flow),
/* harmony export */   flowInitial: () => (/* binding */ flowInitial),
/* harmony export */   insideSpan: () => (/* binding */ insideSpan),
/* harmony export */   string: () => (/* binding */ string),
/* harmony export */   text: () => (/* binding */ text)
/* harmony export */ });
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/attention.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/autolink.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/block-quote.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/character-escape.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/character-reference.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/code-fenced.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/code-indented.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/code-text.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/definition.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/heading-atx.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/html-flow.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/html-text.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/label-end.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/label-start-image.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/label-start-link.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/line-ending.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/list.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/setext-underline.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/thematic-break.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var _initialize_text_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./initialize/text.js */ "./node_modules/micromark/dev/lib/initialize/text.js");
/**
 * @typedef {import('micromark-util-types').Extension} Extension
 */





/** @satisfies {Extension['document']} */
const document = {
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.asterisk]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__.list,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.plusSign]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__.list,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.dash]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__.list,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.digit0]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__.list,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.digit1]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__.list,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.digit2]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__.list,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.digit3]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__.list,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.digit4]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__.list,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.digit5]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__.list,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.digit6]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__.list,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.digit7]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__.list,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.digit8]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__.list,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.digit9]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_17__.list,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.greaterThan]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_2__.blockQuote
}

/** @satisfies {Extension['contentInitial']} */
const contentInitial = {
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.leftSquareBracket]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_8__.definition
}

/** @satisfies {Extension['flowInitial']} */
const flowInitial = {
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.horizontalTab]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_6__.codeIndented,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.virtualSpace]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_6__.codeIndented,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.space]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_6__.codeIndented
}

/** @satisfies {Extension['flow']} */
const flow = {
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.numberSign]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_10__.headingAtx,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.asterisk]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_19__.thematicBreak,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.dash]: [micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_18__.setextUnderline, micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_19__.thematicBreak],
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.lessThan]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_11__.htmlFlow,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.equalsTo]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_18__.setextUnderline,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.underscore]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_19__.thematicBreak,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.graveAccent]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_5__.codeFenced,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.tilde]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_5__.codeFenced
}

/** @satisfies {Extension['string']} */
const string = {
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.ampersand]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_4__.characterReference,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.backslash]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_3__.characterEscape
}

/** @satisfies {Extension['text']} */
const text = {
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.carriageReturn]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_16__.lineEnding,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.lineFeed]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_16__.lineEnding,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.carriageReturnLineFeed]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_16__.lineEnding,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.exclamationMark]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_14__.labelStartImage,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.ampersand]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_4__.characterReference,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.asterisk]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_0__.attention,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.lessThan]: [micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_1__.autolink, micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_12__.htmlText],
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.leftSquareBracket]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_15__.labelStartLink,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.backslash]: [micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_9__.hardBreakEscape, micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_3__.characterEscape],
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.rightSquareBracket]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_13__.labelEnd,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.underscore]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_0__.attention,
  [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.graveAccent]: micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_7__.codeText
}

/** @satisfies {Extension['insideSpan']} */
const insideSpan = {null: [micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_0__.attention, _initialize_text_js__WEBPACK_IMPORTED_MODULE_21__.resolver]}

/** @satisfies {Extension['attentionMarkers']} */
const attentionMarkers = {null: [micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.asterisk, micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_20__.codes.underscore]}

/** @satisfies {Extension['disable']} */
const disable = {null: []}


/***/ }),

/***/ "./node_modules/micromark/dev/lib/create-tokenizer.js":
/*!************************************************************!*\
  !*** ./node_modules/micromark/dev/lib/create-tokenizer.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTokenizer: () => (/* binding */ createTokenizer)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_chunked__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-chunked */ "./node_modules/micromark-util-chunked/dev/index.js");
/* harmony import */ var micromark_util_resolve_all__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-resolve-all */ "./node_modules/micromark-util-resolve-all/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_values_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol/values.js */ "./node_modules/micromark-util-symbol/values.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Chunk} Chunk
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').ParseContext} ParseContext
 * @typedef {import('micromark-util-types').Point} Point
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenType} TokenType
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 */

/**
 * @callback Restore
 * @returns {void}
 *
 * @typedef Info
 * @property {Restore} restore
 * @property {number} from
 *
 * @callback ReturnHandle
 *   Handle a successful run.
 * @param {Construct} construct
 * @param {Info} info
 * @returns {void}
 */









const debug = debug__WEBPACK_IMPORTED_MODULE_0__('micromark')

/**
 * Create a tokenizer.
 * Tokenizers deal with one type of data (e.g., containers, flow, text).
 * The parser is the object dealing with it all.
 * `initialize` works like other constructs, except that only its `tokenize`
 * function is used, in which case it doesn’t receive an `ok` or `nok`.
 * `from` can be given to set the point before the first character, although
 * when further lines are indented, they must be set with `defineSkip`.
 *
 * @param {ParseContext} parser
 * @param {InitialConstruct} initialize
 * @param {Omit<Point, '_bufferIndex' | '_index'> | undefined} [from]
 * @returns {TokenizeContext}
 */
function createTokenizer(parser, initialize, from) {
  /** @type {Point} */
  let point = Object.assign(
    from ? Object.assign({}, from) : {line: 1, column: 1, offset: 0},
    {_index: 0, _bufferIndex: -1}
  )
  /** @type {Record<string, number>} */
  const columnStart = {}
  /** @type {Array<Construct>} */
  const resolveAllConstructs = []
  /** @type {Array<Chunk>} */
  let chunks = []
  /** @type {Array<Token>} */
  let stack = []
  /** @type {boolean | undefined} */
  let consumed = true

  /**
   * Tools used for tokenizing.
   *
   * @type {Effects}
   */
  const effects = {
    consume,
    enter,
    exit,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {interrupt: true})
  }

  /**
   * State and tools for resolving and serializing.
   *
   * @type {TokenizeContext}
   */
  const context = {
    previous: micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.eof,
    code: micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.eof,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  }

  /**
   * The state function.
   *
   * @type {State | void}
   */
  let state = initialize.tokenize.call(context, effects)

  /**
   * Track which character we expect to be consumed, to catch bugs.
   *
   * @type {Code}
   */
  let expectedCode

  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize)
  }

  return context

  /** @type {TokenizeContext['write']} */
  function write(slice) {
    chunks = (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_2__.push)(chunks, slice)

    main()

    // Exit if we’re not done, resolve might change stuff.
    if (chunks[chunks.length - 1] !== micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.eof) {
      return []
    }

    addResult(initialize, 0)

    // Otherwise, resolve, and exit.
    context.events = (0,micromark_util_resolve_all__WEBPACK_IMPORTED_MODULE_3__.resolveAll)(resolveAllConstructs, context.events, context)

    return context.events
  }

  //
  // Tools.
  //

  /** @type {TokenizeContext['sliceSerialize']} */
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs)
  }

  /** @type {TokenizeContext['sliceStream']} */
  function sliceStream(token) {
    return sliceChunks(chunks, token)
  }

  /** @type {TokenizeContext['now']} */
  function now() {
    // This is a hot path, so we clone manually instead of `Object.assign({}, point)`
    const {line, column, offset, _index, _bufferIndex} = point
    return {line, column, offset, _index, _bufferIndex}
  }

  /** @type {TokenizeContext['defineSkip']} */
  function defineSkip(value) {
    columnStart[value.line] = value.column
    accountForPotentialSkip()
    debug('position: define skip: `%j`', point)
  }

  //
  // State management.
  //

  /**
   * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by
   * `consume`).
   * Here is where we walk through the chunks, which either include strings of
   * several characters, or numerical character codes.
   * The reason to do this in a loop instead of a call is so the stack can
   * drain.
   *
   * @returns {void}
   */
  function main() {
    /** @type {number} */
    let chunkIndex

    while (point._index < chunks.length) {
      const chunk = chunks[point._index]

      // If we’re in a buffer chunk, loop through it.
      if (typeof chunk === 'string') {
        chunkIndex = point._index

        if (point._bufferIndex < 0) {
          point._bufferIndex = 0
        }

        while (
          point._index === chunkIndex &&
          point._bufferIndex < chunk.length
        ) {
          go(chunk.charCodeAt(point._bufferIndex))
        }
      } else {
        go(chunk)
      }
    }
  }

  /**
   * Deal with one code.
   *
   * @param {Code} code
   * @returns {void}
   */
  function go(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(consumed === true, 'expected character to be consumed')
    consumed = undefined
    debug('main: passing `%s` to %s', code, state && state.name)
    expectedCode = code
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(typeof state === 'function', 'expected state')
    state = state(code)
  }

  /** @type {Effects['consume']} */
  function consume(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(code === expectedCode, 'expected given code to equal expected code')

    debug('consume: `%s`', code)

    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
      consumed === undefined,
      'expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used'
    )
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
      code === null
        ? context.events.length === 0 ||
            context.events[context.events.length - 1][0] === 'exit'
        : context.events[context.events.length - 1][0] === 'enter',
      'expected last token to be open'
    )

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      point.line++
      point.column = 1
      point.offset += code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.carriageReturnLineFeed ? 2 : 1
      accountForPotentialSkip()
      debug('position: after eol: `%j`', point)
    } else if (code !== micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.virtualSpace) {
      point.column++
      point.offset++
    }

    // Not in a string chunk.
    if (point._bufferIndex < 0) {
      point._index++
    } else {
      point._bufferIndex++

      // At end of string chunk.
      // @ts-expect-error Points w/ non-negative `_bufferIndex` reference
      // strings.
      if (point._bufferIndex === chunks[point._index].length) {
        point._bufferIndex = -1
        point._index++
      }
    }

    // Expose the previous character.
    context.previous = code

    // Mark as consumed.
    consumed = true
  }

  /** @type {Effects['enter']} */
  function enter(type, fields) {
    /** @type {Token} */
    // @ts-expect-error Patch instead of assign required fields to help GC.
    const token = fields || {}
    token.type = type
    token.start = now()

    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(typeof type === 'string', 'expected string type')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(type.length > 0, 'expected non-empty string')
    debug('enter: `%s`', type)

    context.events.push(['enter', token, context])

    stack.push(token)

    return token
  }

  /** @type {Effects['exit']} */
  function exit(type) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(typeof type === 'string', 'expected string type')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(type.length > 0, 'expected non-empty string')

    const token = stack.pop()
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(token, 'cannot close w/o open tokens')
    token.end = now()

    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(type === token.type, 'expected exit token to match current token')

    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
      !(
        token.start._index === token.end._index &&
        token.start._bufferIndex === token.end._bufferIndex
      ),
      'expected non-empty token (`' + type + '`)'
    )

    debug('exit: `%s`', token.type)
    context.events.push(['exit', token, context])

    return token
  }

  /**
   * Use results.
   *
   * @type {ReturnHandle}
   */
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from)
  }

  /**
   * Discard results.
   *
   * @type {ReturnHandle}
   */
  function onsuccessfulcheck(_, info) {
    info.restore()
  }

  /**
   * Factory to attempt/check/interrupt.
   *
   * @param {ReturnHandle} onreturn
   * @param {{interrupt?: boolean | undefined} | undefined} [fields]
   */
  function constructFactory(onreturn, fields) {
    return hook

    /**
     * Handle either an object mapping codes to constructs, a list of
     * constructs, or a single construct.
     *
     * @param {Array<Construct> | Construct | ConstructRecord} constructs
     * @param {State} returnState
     * @param {State | undefined} [bogusState]
     * @returns {State}
     */
    function hook(constructs, returnState, bogusState) {
      /** @type {Array<Construct>} */
      let listOfConstructs
      /** @type {number} */
      let constructIndex
      /** @type {Construct} */
      let currentConstruct
      /** @type {Info} */
      let info

      return Array.isArray(constructs)
        ? /* c8 ignore next 1 */
          handleListOfConstructs(constructs)
        : 'tokenize' in constructs
        ? // @ts-expect-error Looks like a construct.
          handleListOfConstructs([constructs])
        : handleMapOfConstructs(constructs)

      /**
       * Handle a list of construct.
       *
       * @param {ConstructRecord} map
       * @returns {State}
       */
      function handleMapOfConstructs(map) {
        return start

        /** @type {State} */
        function start(code) {
          const def = code !== null && map[code]
          const all = code !== null && map.null
          const list = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...(Array.isArray(def) ? def : def ? [def] : []),
            ...(Array.isArray(all) ? all : all ? [all] : [])
          ]

          return handleListOfConstructs(list)(code)
        }
      }

      /**
       * Handle a list of construct.
       *
       * @param {Array<Construct>} list
       * @returns {State}
       */
      function handleListOfConstructs(list) {
        listOfConstructs = list
        constructIndex = 0

        if (list.length === 0) {
          (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(bogusState, 'expected `bogusState` to be given')
          return bogusState
        }

        return handleConstruct(list[constructIndex])
      }

      /**
       * Handle a single construct.
       *
       * @param {Construct} construct
       * @returns {State}
       */
      function handleConstruct(construct) {
        return start

        /** @type {State} */
        function start(code) {
          // To do: not needed to store if there is no bogus state, probably?
          // Currently doesn’t work because `inspect` in document does a check
          // w/o a bogus, which doesn’t make sense. But it does seem to help perf
          // by not storing.
          info = store()
          currentConstruct = construct

          if (!construct.partial) {
            context.currentConstruct = construct
          }

          // Always populated by defaults.
          (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
            context.parser.constructs.disable.null,
            'expected `disable.null` to be populated'
          )

          if (
            construct.name &&
            context.parser.constructs.disable.null.includes(construct.name)
          ) {
            return nok(code)
          }

          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok,
            nok
          )(code)
        }
      }

      /** @type {State} */
      function ok(code) {
        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(code === expectedCode, 'expected code')
        consumed = true
        onreturn(currentConstruct, info)
        return returnState
      }

      /** @type {State} */
      function nok(code) {
        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(code === expectedCode, 'expected code')
        consumed = true
        info.restore()

        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex])
        }

        return bogusState
      }
    }
  }

  /**
   * @param {Construct} construct
   * @param {number} from
   * @returns {void}
   */
  function addResult(construct, from) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct)
    }

    if (construct.resolve) {
      (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_2__.splice)(
        context.events,
        from,
        context.events.length - from,
        construct.resolve(context.events.slice(from), context)
      )
    }

    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context)
    }

    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
      construct.partial ||
        context.events.length === 0 ||
        context.events[context.events.length - 1][0] === 'exit',
      'expected last token to end'
    )
  }

  /**
   * Store state.
   *
   * @returns {Info}
   */
  function store() {
    const startPoint = now()
    const startPrevious = context.previous
    const startCurrentConstruct = context.currentConstruct
    const startEventsIndex = context.events.length
    const startStack = Array.from(stack)

    return {restore, from: startEventsIndex}

    /**
     * Restore state.
     *
     * @returns {void}
     */
    function restore() {
      point = startPoint
      context.previous = startPrevious
      context.currentConstruct = startCurrentConstruct
      context.events.length = startEventsIndex
      stack = startStack
      accountForPotentialSkip()
      debug('position: restore: `%j`', point)
    }
  }

  /**
   * Move the current point a bit forward in the line when it’s on a column
   * skip.
   *
   * @returns {void}
   */
  function accountForPotentialSkip() {
    if (point.line in columnStart && point.column < 2) {
      point.column = columnStart[point.line]
      point.offset += columnStart[point.line] - 1
    }
  }
}

/**
 * Get the chunks from a slice of chunks in the range of a token.
 *
 * @param {Array<Chunk>} chunks
 * @param {Pick<Token, 'end' | 'start'>} token
 * @returns {Array<Chunk>}
 */
function sliceChunks(chunks, token) {
  const startIndex = token.start._index
  const startBufferIndex = token.start._bufferIndex
  const endIndex = token.end._index
  const endBufferIndex = token.end._bufferIndex
  /** @type {Array<Chunk>} */
  let view

  if (startIndex === endIndex) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(endBufferIndex > -1, 'expected non-negative end buffer index')
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(startBufferIndex > -1, 'expected non-negative start buffer index')
    // @ts-expect-error `_bufferIndex` is used on string chunks.
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]
  } else {
    view = chunks.slice(startIndex, endIndex)

    if (startBufferIndex > -1) {
      const head = view[0]
      if (typeof head === 'string') {
        view[0] = head.slice(startBufferIndex)
      } else {
        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(startBufferIndex === 0, 'expected `startBufferIndex` to be `0`')
        view.shift()
      }
    }

    if (endBufferIndex > 0) {
      // @ts-expect-error `_bufferIndex` is used on string chunks.
      view.push(chunks[endIndex].slice(0, endBufferIndex))
    }
  }

  return view
}

/**
 * Get the string value of a slice of chunks.
 *
 * @param {Array<Chunk>} chunks
 * @param {boolean | undefined} [expandTabs=false]
 * @returns {string}
 */
function serializeChunks(chunks, expandTabs) {
  let index = -1
  /** @type {Array<string>} */
  const result = []
  /** @type {boolean | undefined} */
  let atTab

  while (++index < chunks.length) {
    const chunk = chunks[index]
    /** @type {string} */
    let value

    if (typeof chunk === 'string') {
      value = chunk
    } else
      switch (chunk) {
        case micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.carriageReturn: {
          value = micromark_util_symbol_values_js__WEBPACK_IMPORTED_MODULE_5__.values.cr

          break
        }

        case micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.lineFeed: {
          value = micromark_util_symbol_values_js__WEBPACK_IMPORTED_MODULE_5__.values.lf

          break
        }

        case micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.carriageReturnLineFeed: {
          value = micromark_util_symbol_values_js__WEBPACK_IMPORTED_MODULE_5__.values.cr + micromark_util_symbol_values_js__WEBPACK_IMPORTED_MODULE_5__.values.lf

          break
        }

        case micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.horizontalTab: {
          value = expandTabs ? micromark_util_symbol_values_js__WEBPACK_IMPORTED_MODULE_5__.values.space : micromark_util_symbol_values_js__WEBPACK_IMPORTED_MODULE_5__.values.ht

          break
        }

        case micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.virtualSpace: {
          if (!expandTabs && atTab) continue
          value = micromark_util_symbol_values_js__WEBPACK_IMPORTED_MODULE_5__.values.space

          break
        }

        default: {
          (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(typeof chunk === 'number', 'expected number')
          // Currently only replacement character.
          value = String.fromCharCode(chunk)
        }
      }

    atTab = chunk === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.horizontalTab
    result.push(value)
  }

  return result.join('')
}


/***/ }),

/***/ "./node_modules/micromark/dev/lib/initialize/content.js":
/*!**************************************************************!*\
  !*** ./node_modules/micromark/dev/lib/initialize/content.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   content: () => (/* binding */ content)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').Initializer} Initializer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 */








/** @type {InitialConstruct} */
const content = {tokenize: initializeContent}

/**
 * @this {TokenizeContext}
 * @type {Initializer}
 */
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  )
  /** @type {Token} */
  let previous

  return contentStart

  /** @type {State} */
  function afterContentStartConstruct(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code),
      'expected eol or eof'
    )

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof) {
      effects.consume(code)
      return
    }

    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.lineEnding)
    return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(effects, contentStart, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.linePrefix)
  }

  /** @type {State} */
  function paragraphInitial(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_5__.ok)(
      code !== micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof && !(0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code),
      'expected anything other than a line ending or EOF'
    )
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.paragraph)
    return lineStart(code)
  }

  /** @type {State} */
  function lineStart(code) {
    const token = effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.chunkText, {
      contentType: micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_3__.constants.contentTypeText,
      previous
    })

    if (previous) {
      previous.next = token
    }

    previous = token

    return data(code)
  }

  /** @type {State} */
  function data(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof) {
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.chunkText)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.paragraph)
      effects.consume(code)
      return
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      effects.consume(code)
      effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_4__.types.chunkText)
      return lineStart
    }

    // Data.
    effects.consume(code)
    return data
  }
}


/***/ }),

/***/ "./node_modules/micromark/dev/lib/initialize/document.js":
/*!***************************************************************!*\
  !*** ./node_modules/micromark/dev/lib/initialize/document.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   document: () => (/* binding */ document)
/* harmony export */ });
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_chunked__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-chunked */ "./node_modules/micromark-util-chunked/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').ContainerState} ContainerState
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').Initializer} Initializer
 * @typedef {import('micromark-util-types').Point} Point
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/**
 * @typedef {[Construct, ContainerState]} StackItem
 */









/** @type {InitialConstruct} */
const document = {tokenize: initializeDocument}

/** @type {Construct} */
const containerConstruct = {tokenize: tokenizeContainer}

/**
 * @this {TokenizeContext}
 * @type {Initializer}
 */
function initializeDocument(effects) {
  const self = this
  /** @type {Array<StackItem>} */
  const stack = []
  let continued = 0
  /** @type {TokenizeContext | undefined} */
  let childFlow
  /** @type {Token | undefined} */
  let childToken
  /** @type {number} */
  let lineStartOffset

  return start

  /** @type {State} */
  function start(code) {
    // First we iterate through the open blocks, starting with the root
    // document, and descending through last children down to the last open
    // block.
    // Each block imposes a condition that the line must satisfy if the block is
    // to remain open.
    // For example, a block quote requires a `>` character.
    // A paragraph requires a non-blank line.
    // In this phase we may match all or just some of the open blocks.
    // But we cannot close unmatched blocks yet, because we may have a lazy
    // continuation line.
    if (continued < stack.length) {
      const item = stack[continued]
      self.containerState = item[1]
      ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
        item[0].continuation,
        'expected `continuation` to be defined on container construct'
      )
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code)
    }

    // Done.
    return checkNewContainers(code)
  }

  /** @type {State} */
  function documentContinue(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
      self.containerState,
      'expected `containerState` to be defined after continuation'
    )

    continued++

    // Note: this field is called `_closeFlow` but it also closes containers.
    // Perhaps a good idea to rename it but it’s already used in the wild by
    // extensions.
    if (self.containerState._closeFlow) {
      self.containerState._closeFlow = undefined

      if (childFlow) {
        closeFlow()
      }

      // Note: this algorithm for moving events around is similar to the
      // algorithm when dealing with lazy lines in `writeToChild`.
      const indexBeforeExits = self.events.length
      let indexBeforeFlow = indexBeforeExits
      /** @type {Point | undefined} */
      let point

      // Find the flow chunk.
      while (indexBeforeFlow--) {
        if (
          self.events[indexBeforeFlow][0] === 'exit' &&
          self.events[indexBeforeFlow][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.chunkFlow
        ) {
          point = self.events[indexBeforeFlow][1].end
          break
        }
      }

      (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(point, 'could not find previous flow chunk')

      exitContainers(continued)

      // Fix positions.
      let index = indexBeforeExits

      while (index < self.events.length) {
        self.events[index][1].end = Object.assign({}, point)
        index++
      }

      // Inject the exits earlier (they’re still also at the end).
      (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_2__.splice)(
        self.events,
        indexBeforeFlow + 1,
        0,
        self.events.slice(indexBeforeExits)
      )

      // Discard the duplicate exits.
      self.events.length = index

      return checkNewContainers(code)
    }

    return start(code)
  }

  /** @type {State} */
  function checkNewContainers(code) {
    // Next, after consuming the continuation markers for existing blocks, we
    // look for new block starts (e.g. `>` for a block quote).
    // If we encounter a new block start, we close any blocks unmatched in
    // step 1 before creating the new block as a child of the last matched
    // block.
    if (continued === stack.length) {
      // No need to `check` whether there’s a container, of `exitContainers`
      // would be moot.
      // We can instead immediately `attempt` to parse one.
      if (!childFlow) {
        return documentContinued(code)
      }

      // If we have concrete content, such as block HTML or fenced code,
      // we can’t have containers “pierce” into them, so we can immediately
      // start.
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code)
      }

      // If we do have flow, it could still be a blank line,
      // but we’d be interrupting it w/ a new container if there’s a current
      // construct.
      // To do: next major: remove `_gfmTableDynamicInterruptHack` (no longer
      // needed in micromark-extension-gfm-table@1.0.6).
      self.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      )
    }

    // Check if there is a new container.
    self.containerState = {}
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code)
  }

  /** @type {State} */
  function thereIsANewContainer(code) {
    if (childFlow) closeFlow()
    exitContainers(continued)
    return documentContinued(code)
  }

  /** @type {State} */
  function thereIsNoNewContainer(code) {
    self.parser.lazy[self.now().line] = continued !== stack.length
    lineStartOffset = self.now().offset
    return flowStart(code)
  }

  /** @type {State} */
  function documentContinued(code) {
    // Try new containers.
    self.containerState = {}
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code)
  }

  /** @type {State} */
  function containerContinue(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
      self.currentConstruct,
      'expected `currentConstruct` to be defined on tokenizer'
    )
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
      self.containerState,
      'expected `containerState` to be defined on tokenizer'
    )
    continued++
    stack.push([self.currentConstruct, self.containerState])
    // Try another.
    return documentContinued(code)
  }

  /** @type {State} */
  function flowStart(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof) {
      if (childFlow) closeFlow()
      exitContainers(0)
      effects.consume(code)
      return
    }

    childFlow = childFlow || self.parser.flow(self.now())
    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.chunkFlow, {
      contentType: micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.contentTypeFlow,
      previous: childToken,
      _tokenizer: childFlow
    })

    return flowContinue(code)
  }

  /** @type {State} */
  function flowContinue(code) {
    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof) {
      writeToChild(effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.chunkFlow), true)
      exitContainers(0)
      effects.consume(code)
      return
    }

    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEnding)(code)) {
      effects.consume(code)
      writeToChild(effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.chunkFlow))
      // Get ready for the next line.
      continued = 0
      self.interrupt = undefined
      return start
    }

    effects.consume(code)
    return flowContinue
  }

  /**
   * @param {Token} token
   * @param {boolean | undefined} [eof]
   * @returns {void}
   */
  function writeToChild(token, eof) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(childFlow, 'expected `childFlow` to be defined when continuing')
    const stream = self.sliceStream(token)
    if (eof) stream.push(null)
    token.previous = childToken
    if (childToken) childToken.next = token
    childToken = token
    childFlow.defineSkip(token.start)
    childFlow.write(stream)

    // Alright, so we just added a lazy line:
    //
    // ```markdown
    // > a
    // b.
    //
    // Or:
    //
    // > ~~~c
    // d
    //
    // Or:
    //
    // > | e |
    // f
    // ```
    //
    // The construct in the second example (fenced code) does not accept lazy
    // lines, so it marked itself as done at the end of its first line, and
    // then the content construct parses `d`.
    // Most constructs in markdown match on the first line: if the first line
    // forms a construct, a non-lazy line can’t “unmake” it.
    //
    // The construct in the third example is potentially a GFM table, and
    // those are *weird*.
    // It *could* be a table, from the first line, if the following line
    // matches a condition.
    // In this case, that second line is lazy, which “unmakes” the first line
    // and turns the whole into one content block.
    //
    // We’ve now parsed the non-lazy and the lazy line, and can figure out
    // whether the lazy line started a new flow block.
    // If it did, we exit the current containers between the two flow blocks.
    if (self.parser.lazy[token.start.line]) {
      let index = childFlow.events.length

      while (index--) {
        if (
          // The token starts before the line ending…
          childFlow.events[index][1].start.offset < lineStartOffset &&
          // …and either is not ended yet…
          (!childFlow.events[index][1].end ||
            // …or ends after it.
            childFlow.events[index][1].end.offset > lineStartOffset)
        ) {
          // Exit: there’s still something open, which means it’s a lazy line
          // part of something.
          return
        }
      }

      // Note: this algorithm for moving events around is similar to the
      // algorithm when closing flow in `documentContinue`.
      const indexBeforeExits = self.events.length
      let indexBeforeFlow = indexBeforeExits
      /** @type {boolean | undefined} */
      let seen
      /** @type {Point | undefined} */
      let point

      // Find the previous chunk (the one before the lazy line).
      while (indexBeforeFlow--) {
        if (
          self.events[indexBeforeFlow][0] === 'exit' &&
          self.events[indexBeforeFlow][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.chunkFlow
        ) {
          if (seen) {
            point = self.events[indexBeforeFlow][1].end
            break
          }

          seen = true
        }
      }

      (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(point, 'could not find previous flow chunk')

      exitContainers(continued)

      // Fix positions.
      index = indexBeforeExits

      while (index < self.events.length) {
        self.events[index][1].end = Object.assign({}, point)
        index++
      }

      // Inject the exits earlier (they’re still also at the end).
      (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_2__.splice)(
        self.events,
        indexBeforeFlow + 1,
        0,
        self.events.slice(indexBeforeExits)
      )

      // Discard the duplicate exits.
      self.events.length = index
    }
  }

  /**
   * @param {number} size
   * @returns {void}
   */
  function exitContainers(size) {
    let index = stack.length

    // Exit open containers.
    while (index-- > size) {
      const entry = stack[index]
      self.containerState = entry[1]
      ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
        entry[0].exit,
        'expected `exit` to be defined on container construct'
      )
      entry[0].exit.call(self, effects)
    }

    stack.length = size
  }

  function closeFlow() {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
      self.containerState,
      'expected `containerState` to be defined when closing flow'
    )
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(childFlow, 'expected `childFlow` to be defined when closing it')
    childFlow.write([micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_3__.codes.eof])
    childToken = undefined
    childFlow = undefined
    self.containerState._closeFlow = undefined
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeContainer(effects, ok, nok) {
  // Always populated by defaults.
  (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
    this.parser.constructs.disable.null,
    'expected `disable.null` to be populated'
  )
  return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_0__.factorySpace)(
    effects,
    effects.attempt(this.parser.constructs.document, ok, nok),
    micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.linePrefix,
    this.parser.constructs.disable.null.includes('codeIndented')
      ? undefined
      : micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_4__.constants.tabSize
  )
}


/***/ }),

/***/ "./node_modules/micromark/dev/lib/initialize/flow.js":
/*!***********************************************************!*\
  !*** ./node_modules/micromark/dev/lib/initialize/flow.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   flow: () => (/* binding */ flow)
/* harmony export */ });
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/blank-line.js");
/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-core-commonmark */ "./node_modules/micromark-core-commonmark/dev/lib/content.js");
/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-factory-space */ "./node_modules/micromark-factory-space/dev/index.js");
/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-character */ "./node_modules/micromark-util-character/dev/index.js");
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').Initializer} Initializer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 */








/** @type {InitialConstruct} */
const flow = {tokenize: initializeFlow}

/**
 * @this {TokenizeContext}
 * @type {Initializer}
 */
function initializeFlow(effects) {
  const self = this
  const initial = effects.attempt(
    // Try to parse a blank line.
    micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_0__.blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_2__.factorySpace)(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_1__.content, afterConstruct)
        ),
        micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.linePrefix
      )
    )
  )

  return initial

  /** @type {State} */
  function atBlankEnding(code) {
    ;(0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code),
      'expected eol or eof'
    )

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.eof) {
      effects.consume(code)
      return
    }

    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.lineEndingBlank)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.lineEndingBlank)
    self.currentConstruct = undefined
    return initial
  }

  /** @type {State} */
  function afterConstruct(code) {
    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_6__.ok)(
      code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code),
      'expected eol or eof'
    )

    if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_4__.codes.eof) {
      effects.consume(code)
      return
    }

    effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.lineEnding)
    effects.consume(code)
    effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_5__.types.lineEnding)
    self.currentConstruct = undefined
    return initial
  }
}


/***/ }),

/***/ "./node_modules/micromark/dev/lib/initialize/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/micromark/dev/lib/initialize/text.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolver: () => (/* binding */ resolver),
/* harmony export */   string: () => (/* binding */ string),
/* harmony export */   text: () => (/* binding */ text)
/* harmony export */ });
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/types.js */ "./node_modules/micromark-util-symbol/types.js");
/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uvu/assert */ "./node_modules/uvu/assert/index.mjs");
/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').Initializer} Initializer
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 */






const resolver = {resolveAll: createResolver()}
const string = initializeFactory('string')
const text = initializeFactory('text')

/**
 * @param {'string' | 'text'} field
 * @returns {InitialConstruct}
 */
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === 'text' ? resolveAllLineSuffixes : undefined
    )
  }

  /**
   * @this {TokenizeContext}
   * @type {Initializer}
   */
  function initializeText(effects) {
    const self = this
    const constructs = this.parser.constructs[field]
    const text = effects.attempt(constructs, start, notText)

    return start

    /** @type {State} */
    function start(code) {
      return atBreak(code) ? text(code) : notText(code)
    }

    /** @type {State} */
    function notText(code) {
      if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.eof) {
        effects.consume(code)
        return
      }

      effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.data)
      effects.consume(code)
      return data
    }

    /** @type {State} */
    function data(code) {
      if (atBreak(code)) {
        effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.data)
        return text(code)
      }

      // Data.
      effects.consume(code)
      return data
    }

    /**
     * @param {Code} code
     * @returns {boolean}
     */
    function atBreak(code) {
      if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.eof) {
        return true
      }

      const list = constructs[code]
      let index = -1

      if (list) {
        // Always populated by defaults.
        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_3__.ok)(Array.isArray(list), 'expected `disable.null` to be populated')

        while (++index < list.length) {
          const item = list[index]
          if (!item.previous || item.previous.call(self, self.previous)) {
            return true
          }
        }
      }

      return false
    }
  }
}

/**
 * @param {Resolver | undefined} [extraResolver]
 * @returns {Resolver}
 */
function createResolver(extraResolver) {
  return resolveAllText

  /** @type {Resolver} */
  function resolveAllText(events, context) {
    let index = -1
    /** @type {number | undefined} */
    let enter

    // A rather boring computation (to merge adjacent `data` events) which
    // improves mm performance by 29%.
    while (++index <= events.length) {
      if (enter === undefined) {
        if (events[index] && events[index][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.data) {
          enter = index
          index++
        }
      } else if (!events[index] || events[index][1].type !== micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.data) {
        // Don’t do anything if there is one data token.
        if (index !== enter + 2) {
          events[enter][1].end = events[index - 1][1].end
          events.splice(enter + 2, index - enter - 2)
          index = enter + 2
        }

        enter = undefined
      }
    }

    return extraResolver ? extraResolver(events, context) : events
  }
}

/**
 * A rather ugly set of instructions which again looks at chunks in the input
 * stream.
 * The reason to do this here is that it is *much* faster to parse in reverse.
 * And that we can’t hook into `null` to split the line suffix before an EOF.
 * To do: figure out if we can make this into a clean utility, or even in core.
 * As it will be useful for GFMs literal autolink extension (and maybe even
 * tables?)
 *
 * @type {Resolver}
 */
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0 // Skip first.

  while (++eventIndex <= events.length) {
    if (
      (eventIndex === events.length ||
        events[eventIndex][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineEnding) &&
      events[eventIndex - 1][1].type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.data
    ) {
      const data = events[eventIndex - 1][1]
      const chunks = context.sliceStream(data)
      let index = chunks.length
      let bufferIndex = -1
      let size = 0
      /** @type {boolean | undefined} */
      let tabs

      while (index--) {
        const chunk = chunks[index]

        if (typeof chunk === 'string') {
          bufferIndex = chunk.length

          while (chunk.charCodeAt(bufferIndex - 1) === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.space) {
            size++
            bufferIndex--
          }

          if (bufferIndex) break
          bufferIndex = -1
        }
        // Number
        else if (chunk === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.horizontalTab) {
          tabs = true
          size++
        } else if (chunk === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.virtualSpace) {
          // Empty
        } else {
          // Replacement character, exit.
          index++
          break
        }
      }

      if (size) {
        const token = {
          type:
            eventIndex === events.length ||
            tabs ||
            size < micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_1__.constants.hardBreakPrefixSizeMin
              ? micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.lineSuffix
              : micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_2__.types.hardBreakTrailing,
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index,
            _bufferIndex: index
              ? bufferIndex
              : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        }

        data.end = Object.assign({}, token.start)

        if (data.start.offset === data.end.offset) {
          Object.assign(data, token)
        } else {
          events.splice(
            eventIndex,
            0,
            ['enter', token, context],
            ['exit', token, context]
          )
          eventIndex += 2
        }
      }

      eventIndex++
    }
  }

  return events
}


/***/ }),

/***/ "./node_modules/micromark/dev/lib/parse.js":
/*!*************************************************!*\
  !*** ./node_modules/micromark/dev/lib/parse.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parse: () => (/* binding */ parse)
/* harmony export */ });
/* harmony import */ var micromark_util_combine_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-combine-extensions */ "./node_modules/micromark-util-combine-extensions/index.js");
/* harmony import */ var _initialize_content_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./initialize/content.js */ "./node_modules/micromark/dev/lib/initialize/content.js");
/* harmony import */ var _initialize_document_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./initialize/document.js */ "./node_modules/micromark/dev/lib/initialize/document.js");
/* harmony import */ var _initialize_flow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./initialize/flow.js */ "./node_modules/micromark/dev/lib/initialize/flow.js");
/* harmony import */ var _initialize_text_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./initialize/text.js */ "./node_modules/micromark/dev/lib/initialize/text.js");
/* harmony import */ var _create_tokenizer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./create-tokenizer.js */ "./node_modules/micromark/dev/lib/create-tokenizer.js");
/* harmony import */ var _constructs_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constructs.js */ "./node_modules/micromark/dev/lib/constructs.js");
/**
 * @typedef {import('micromark-util-types').Create} Create
 * @typedef {import('micromark-util-types').FullNormalizedExtension} FullNormalizedExtension
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').ParseContext} ParseContext
 * @typedef {import('micromark-util-types').ParseOptions} ParseOptions
 */









/**
 * @param {ParseOptions | null | undefined} [options]
 * @returns {ParseContext}
 */
function parse(options) {
  const settings = options || {}
  const constructs = /** @type {FullNormalizedExtension} */ (
    (0,micromark_util_combine_extensions__WEBPACK_IMPORTED_MODULE_0__.combineExtensions)([_constructs_js__WEBPACK_IMPORTED_MODULE_6__, ...(settings.extensions || [])])
  )

  /** @type {ParseContext} */
  const parser = {
    defined: [],
    lazy: {},
    constructs,
    content: create(_initialize_content_js__WEBPACK_IMPORTED_MODULE_1__.content),
    document: create(_initialize_document_js__WEBPACK_IMPORTED_MODULE_2__.document),
    flow: create(_initialize_flow_js__WEBPACK_IMPORTED_MODULE_3__.flow),
    string: create(_initialize_text_js__WEBPACK_IMPORTED_MODULE_4__.string),
    text: create(_initialize_text_js__WEBPACK_IMPORTED_MODULE_4__.text)
  }

  return parser

  /**
   * @param {InitialConstruct} initial
   */
  function create(initial) {
    return creator
    /** @type {Create} */
    function creator(from) {
      return (0,_create_tokenizer_js__WEBPACK_IMPORTED_MODULE_5__.createTokenizer)(parser, initial, from)
    }
  }
}


/***/ }),

/***/ "./node_modules/micromark/dev/lib/postprocess.js":
/*!*******************************************************!*\
  !*** ./node_modules/micromark/dev/lib/postprocess.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   postprocess: () => (/* binding */ postprocess)
/* harmony export */ });
/* harmony import */ var micromark_util_subtokenize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-subtokenize */ "./node_modules/micromark-util-subtokenize/dev/index.js");
/**
 * @typedef {import('micromark-util-types').Event} Event
 */



/**
 * @param {Array<Event>} events
 * @returns {Array<Event>}
 */
function postprocess(events) {
  while (!(0,micromark_util_subtokenize__WEBPACK_IMPORTED_MODULE_0__.subtokenize)(events)) {
    // Empty
  }

  return events
}


/***/ }),

/***/ "./node_modules/micromark/dev/lib/preprocess.js":
/*!******************************************************!*\
  !*** ./node_modules/micromark/dev/lib/preprocess.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   preprocess: () => (/* binding */ preprocess)
/* harmony export */ });
/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ "./node_modules/micromark-util-symbol/codes.js");
/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ "./node_modules/micromark-util-symbol/constants.js");
/**
 * @typedef {import('micromark-util-types').Chunk} Chunk
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Encoding} Encoding
 * @typedef {import('micromark-util-types').Value} Value
 */

/**
 * @callback Preprocessor
 * @param {Value} value
 * @param {Encoding | null | undefined} [encoding]
 * @param {boolean | null | undefined} [end=false]
 * @returns {Array<Chunk>}
 */




const search = /[\0\t\n\r]/g

/**
 * @returns {Preprocessor}
 */
function preprocess() {
  let column = 1
  let buffer = ''
  /** @type {boolean | undefined} */
  let start = true
  /** @type {boolean | undefined} */
  let atCarriageReturn

  return preprocessor

  /** @type {Preprocessor} */
  function preprocessor(value, encoding, end) {
    /** @type {Array<Chunk>} */
    const chunks = []
    /** @type {RegExpMatchArray | null} */
    let match
    /** @type {number} */
    let next
    /** @type {number} */
    let startPosition
    /** @type {number} */
    let endPosition
    /** @type {Code} */
    let code

    // @ts-expect-error `Buffer` does allow an encoding.
    value = buffer + value.toString(encoding)
    startPosition = 0
    buffer = ''

    if (start) {
      // To do: `markdown-rs` actually parses BOMs (byte order mark).
      if (value.charCodeAt(0) === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.byteOrderMarker) {
        startPosition++
      }

      start = undefined
    }

    while (startPosition < value.length) {
      search.lastIndex = startPosition
      match = search.exec(value)
      endPosition =
        match && match.index !== undefined ? match.index : value.length
      code = value.charCodeAt(endPosition)

      if (!match) {
        buffer = value.slice(startPosition)
        break
      }

      if (
        code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.lf &&
        startPosition === endPosition &&
        atCarriageReturn
      ) {
        chunks.push(micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.carriageReturnLineFeed)
        atCarriageReturn = undefined
      } else {
        if (atCarriageReturn) {
          chunks.push(micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.carriageReturn)
          atCarriageReturn = undefined
        }

        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition))
          column += endPosition - startPosition
        }

        switch (code) {
          case micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.nul: {
            chunks.push(micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.replacementCharacter)
            column++

            break
          }

          case micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.ht: {
            next = Math.ceil(column / micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_1__.constants.tabSize) * micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_1__.constants.tabSize
            chunks.push(micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.horizontalTab)
            while (column++ < next) chunks.push(micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.virtualSpace)

            break
          }

          case micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.lf: {
            chunks.push(micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.lineFeed)
            column = 1

            break
          }

          default: {
            atCarriageReturn = true
            column = 1
          }
        }
      }

      startPosition = endPosition + 1
    }

    if (end) {
      if (atCarriageReturn) chunks.push(micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.carriageReturn)
      if (buffer) chunks.push(buffer)
      chunks.push(micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_0__.codes.eof)
    }

    return chunks
  }
}


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/nanoid/index.browser.js":
/*!**********************************************!*\
  !*** ./node_modules/nanoid/index.browser.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),
/* harmony export */   customRandom: () => (/* binding */ customRandom),
/* harmony export */   nanoid: () => (/* binding */ nanoid),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   urlAlphabet: () => (/* reexport safe */ _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__.urlAlphabet)
/* harmony export */ });
/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-alphabet/index.js */ "./node_modules/nanoid/url-alphabet/index.js");

let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * defaultSize) / alphabet.length)
  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let j = step | 0
      while (j--) {
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)
let nanoid = (size = 21) =>
  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte > 62) {
      id += '-'
    } else {
      id += '_'
    }
    return id
  }, '')



/***/ }),

/***/ "./node_modules/nanoid/url-alphabet/index.js":
/*!***************************************************!*\
  !*** ./node_modules/nanoid/url-alphabet/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   urlAlphabet: () => (/* binding */ urlAlphabet)
/* harmony export */ });
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'



/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = __webpack_require__(/*! ./lib/has */ "./node_modules/prop-types/lib/has.js");

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) { /**/ }
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var has = __webpack_require__(/*! ./lib/has */ "./node_modules/prop-types/lib/has.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bigint: createPrimitiveTypeChecker('bigint'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message, data) {
    this.message = message;
    this.data = data && typeof data === 'object' ? data: {};
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError(
          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
          {expectedType: expectedType}
        );
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      var expectedTypes = [];
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
        if (checkerResult == null) {
          return null;
        }
        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
          expectedTypes.push(checkerResult.data.expectedType);
        }
      }
      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function invalidValidatorError(componentName, location, propFullName, key, type) {
    return new PropTypeError(
      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
    );
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (has(shapeTypes, key) && typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else // removed by dead control flow
{}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/prop-types/lib/has.js":
/*!********************************************!*\
  !*** ./node_modules/prop-types/lib/has.js ***!
  \********************************************/
/***/ ((module) => {

module.exports = Function.call.bind(Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/property-information/index.js":
/*!****************************************************!*\
  !*** ./node_modules/property-information/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   find: () => (/* reexport safe */ _lib_find_js__WEBPACK_IMPORTED_MODULE_7__.find),
/* harmony export */   hastToReact: () => (/* reexport safe */ _lib_hast_to_react_js__WEBPACK_IMPORTED_MODULE_8__.hastToReact),
/* harmony export */   html: () => (/* binding */ html),
/* harmony export */   normalize: () => (/* reexport safe */ _lib_normalize_js__WEBPACK_IMPORTED_MODULE_9__.normalize),
/* harmony export */   svg: () => (/* binding */ svg)
/* harmony export */ });
/* harmony import */ var _lib_util_merge_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/util/merge.js */ "./node_modules/property-information/lib/util/merge.js");
/* harmony import */ var _lib_xlink_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/xlink.js */ "./node_modules/property-information/lib/xlink.js");
/* harmony import */ var _lib_xml_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/xml.js */ "./node_modules/property-information/lib/xml.js");
/* harmony import */ var _lib_xmlns_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/xmlns.js */ "./node_modules/property-information/lib/xmlns.js");
/* harmony import */ var _lib_aria_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/aria.js */ "./node_modules/property-information/lib/aria.js");
/* harmony import */ var _lib_html_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/html.js */ "./node_modules/property-information/lib/html.js");
/* harmony import */ var _lib_svg_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/svg.js */ "./node_modules/property-information/lib/svg.js");
/* harmony import */ var _lib_find_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/find.js */ "./node_modules/property-information/lib/find.js");
/* harmony import */ var _lib_hast_to_react_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/hast-to-react.js */ "./node_modules/property-information/lib/hast-to-react.js");
/* harmony import */ var _lib_normalize_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/normalize.js */ "./node_modules/property-information/lib/normalize.js");
/**
 * @typedef {import('./lib/util/info.js').Info} Info
 * @typedef {import('./lib/util/schema.js').Schema} Schema
 */












const html = (0,_lib_util_merge_js__WEBPACK_IMPORTED_MODULE_0__.merge)([_lib_xml_js__WEBPACK_IMPORTED_MODULE_2__.xml, _lib_xlink_js__WEBPACK_IMPORTED_MODULE_1__.xlink, _lib_xmlns_js__WEBPACK_IMPORTED_MODULE_3__.xmlns, _lib_aria_js__WEBPACK_IMPORTED_MODULE_4__.aria, _lib_html_js__WEBPACK_IMPORTED_MODULE_5__.html], 'html')
const svg = (0,_lib_util_merge_js__WEBPACK_IMPORTED_MODULE_0__.merge)([_lib_xml_js__WEBPACK_IMPORTED_MODULE_2__.xml, _lib_xlink_js__WEBPACK_IMPORTED_MODULE_1__.xlink, _lib_xmlns_js__WEBPACK_IMPORTED_MODULE_3__.xmlns, _lib_aria_js__WEBPACK_IMPORTED_MODULE_4__.aria, _lib_svg_js__WEBPACK_IMPORTED_MODULE_6__.svg], 'svg')


/***/ }),

/***/ "./node_modules/property-information/lib/aria.js":
/*!*******************************************************!*\
  !*** ./node_modules/property-information/lib/aria.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   aria: () => (/* binding */ aria)
/* harmony export */ });
/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/types.js */ "./node_modules/property-information/lib/util/types.js");
/* harmony import */ var _util_create_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/create.js */ "./node_modules/property-information/lib/util/create.js");



const aria = (0,_util_create_js__WEBPACK_IMPORTED_MODULE_1__.create)({
  transform(_, prop) {
    return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase()
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaAutoComplete: null,
    ariaBusy: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaChecked: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaColCount: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    ariaColIndex: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    ariaColSpan: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    ariaControls: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    ariaDetails: null,
    ariaDisabled: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaDropEffect: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaFlowTo: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    ariaGrabbed: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaHasPopup: null,
    ariaHidden: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    ariaLevel: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    ariaLive: null,
    ariaModal: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaMultiLine: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaMultiSelectable: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaOrientation: null,
    ariaOwns: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    ariaPressed: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaReadOnly: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaRelevant: null,
    ariaRequired: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaRoleDescription: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    ariaRowCount: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    ariaRowIndex: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    ariaRowSpan: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    ariaSelected: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    ariaSetSize: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    ariaSort: null,
    ariaValueMax: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    ariaValueMin: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    ariaValueNow: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    ariaValueText: null,
    role: null
  }
})


/***/ }),

/***/ "./node_modules/property-information/lib/find.js":
/*!*******************************************************!*\
  !*** ./node_modules/property-information/lib/find.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   find: () => (/* binding */ find)
/* harmony export */ });
/* harmony import */ var _normalize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normalize.js */ "./node_modules/property-information/lib/normalize.js");
/* harmony import */ var _util_defined_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/defined-info.js */ "./node_modules/property-information/lib/util/defined-info.js");
/* harmony import */ var _util_info_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/info.js */ "./node_modules/property-information/lib/util/info.js");
/**
 * @typedef {import('./util/schema.js').Schema} Schema
 */





const valid = /^data[-\w.:]+$/i
const dash = /-[a-z]/g
const cap = /[A-Z]/g

/**
 * @param {Schema} schema
 * @param {string} value
 * @returns {Info}
 */
function find(schema, value) {
  const normal = (0,_normalize_js__WEBPACK_IMPORTED_MODULE_0__.normalize)(value)
  let prop = value
  let Type = _util_info_js__WEBPACK_IMPORTED_MODULE_2__.Info

  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]]
  }

  if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {
    // Attribute or property.
    if (value.charAt(4) === '-') {
      // Turn it into a property.
      const rest = value.slice(5).replace(dash, camelcase)
      prop = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1)
    } else {
      // Turn it into an attribute.
      const rest = value.slice(4)

      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab)

        if (dashes.charAt(0) !== '-') {
          dashes = '-' + dashes
        }

        value = 'data' + dashes
      }
    }

    Type = _util_defined_info_js__WEBPACK_IMPORTED_MODULE_1__.DefinedInfo
  }

  return new Type(prop, value)
}

/**
 * @param {string} $0
 * @returns {string}
 */
function kebab($0) {
  return '-' + $0.toLowerCase()
}

/**
 * @param {string} $0
 * @returns {string}
 */
function camelcase($0) {
  return $0.charAt(1).toUpperCase()
}


/***/ }),

/***/ "./node_modules/property-information/lib/hast-to-react.js":
/*!****************************************************************!*\
  !*** ./node_modules/property-information/lib/hast-to-react.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hastToReact: () => (/* binding */ hastToReact)
/* harmony export */ });
/**
 * `hast` is close to `React`, but differs in a couple of cases.
 *
 * To get a React property from a hast property, check if it is in
 * `hastToReact`, if it is, then use the corresponding value,
 * otherwise, use the hast property.
 *
 * @type {Record<string, string>}
 */
const hastToReact = {
  classId: 'classID',
  dataType: 'datatype',
  itemId: 'itemID',
  strokeDashArray: 'strokeDasharray',
  strokeDashOffset: 'strokeDashoffset',
  strokeLineCap: 'strokeLinecap',
  strokeLineJoin: 'strokeLinejoin',
  strokeMiterLimit: 'strokeMiterlimit',
  typeOf: 'typeof',
  xLinkActuate: 'xlinkActuate',
  xLinkArcRole: 'xlinkArcrole',
  xLinkHref: 'xlinkHref',
  xLinkRole: 'xlinkRole',
  xLinkShow: 'xlinkShow',
  xLinkTitle: 'xlinkTitle',
  xLinkType: 'xlinkType',
  xmlnsXLink: 'xmlnsXlink'
}


/***/ }),

/***/ "./node_modules/property-information/lib/html.js":
/*!*******************************************************!*\
  !*** ./node_modules/property-information/lib/html.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   html: () => (/* binding */ html)
/* harmony export */ });
/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/types.js */ "./node_modules/property-information/lib/util/types.js");
/* harmony import */ var _util_create_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/create.js */ "./node_modules/property-information/lib/util/create.js");
/* harmony import */ var _util_case_insensitive_transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/case-insensitive-transform.js */ "./node_modules/property-information/lib/util/case-insensitive-transform.js");




const html = (0,_util_create_js__WEBPACK_IMPORTED_MODULE_1__.create)({
  space: 'html',
  attributes: {
    acceptcharset: 'accept-charset',
    classname: 'class',
    htmlfor: 'for',
    httpequiv: 'http-equiv'
  },
  transform: _util_case_insensitive_transform_js__WEBPACK_IMPORTED_MODULE_2__.caseInsensitiveTransform,
  mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaSeparated,
    acceptCharset: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    accessKey: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    allowPaymentRequest: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    allowUserMedia: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    alt: null,
    as: null,
    async: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    autoCapitalize: null,
    autoComplete: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    autoFocus: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    autoPlay: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    blocking: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    capture: null,
    charSet: null,
    checked: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    cite: null,
    className: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    cols: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    colSpan: null,
    content: null,
    contentEditable: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    controls: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    controlsList: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    coords: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number | _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    defer: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    dir: null,
    dirName: null,
    disabled: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    download: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.overloadedBoolean,
    draggable: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    formTarget: null,
    headers: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    height: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    hidden: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    high: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    href: null,
    hrefLang: null,
    htmlFor: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    httpEquiv: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    itemId: null,
    itemProp: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    itemRef: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    itemScope: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    itemType: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    low: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    manifest: null,
    max: null,
    maxLength: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    media: null,
    method: null,
    min: null,
    minLength: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    multiple: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    muted: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    name: null,
    nonce: null,
    noModule: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    noValidate: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    optimum: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    pattern: null,
    ping: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    placeholder: null,
    playsInline: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    referrerPolicy: null,
    rel: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    required: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    reversed: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    rows: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    rowSpan: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    sandbox: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    scope: null,
    scoped: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    seamless: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    selected: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    shadowRootClonable: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    shadowRootDelegatesFocus: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    shadowRootMode: null,
    shape: null,
    size: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    sizes: null,
    slot: null,
    span: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    spellCheck: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    step: null,
    style: null,
    tabIndex: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    useMap: null,
    value: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish,
    width: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    wrap: null,
    writingSuggestions: null,

    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null, // Several. Use CSS `text-align` instead,
    aLink: null, // `<body>`. Use CSS `a:active {color}` instead
    archive: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated, // `<object>`. List of URIs to archives
    axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null, // `<body>`. Use CSS `background-image` instead
    bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead
    border: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number, // `<table>`. Use CSS `border-width` instead,
    borderColor: null, // `<table>`. Use CSS `border-color` instead,
    bottomMargin: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number, // `<body>`
    cellPadding: null, // `<table>`
    cellSpacing: null, // `<table>`
    char: null, // Several table elements. When `align=char`, sets the character to align on
    charOff: null, // Several table elements. When `char`, offsets the alignment
    classId: null, // `<object>`
    clear: null, // `<br>`. Use CSS `clear` instead
    code: null, // `<object>`
    codeBase: null, // `<object>`
    codeType: null, // `<object>`
    color: null, // `<font>` and `<hr>`. Use CSS instead
    compact: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean, // Lists. Use CSS to reduce space between items instead
    declare: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean, // `<object>`
    event: null, // `<script>`
    face: null, // `<font>`. Use CSS instead
    frame: null, // `<table>`
    frameBorder: null, // `<iframe>`. Use CSS `border` instead
    hSpace: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number, // `<img>` and `<object>`
    leftMargin: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number, // `<body>`
    link: null, // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null, // `<img>`. Use a `<picture>`
    marginHeight: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number, // `<body>`
    marginWidth: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number, // `<body>`
    noResize: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean, // `<frame>`
    noHref: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean, // `<area>`. Use no href instead of an explicit `nohref`
    noShade: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean, // `<hr>`. Use background-color and height instead of borders
    noWrap: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean, // `<td>` and `<th>`
    object: null, // `<applet>`
    profile: null, // `<head>`
    prompt: null, // `<isindex>`
    rev: null, // `<link>`
    rightMargin: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number, // `<body>`
    rules: null, // `<table>`
    scheme: null, // `<meta>`
    scrolling: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanish, // `<frame>`. Use overflow in the child context
    standby: null, // `<object>`
    summary: null, // `<table>`
    text: null, // `<body>`. Use CSS `color` instead
    topMargin: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number, // `<body>`
    valueType: null, // `<param>`
    version: null, // `<html>`. Use a doctype.
    vAlign: null, // Several. Use CSS `vertical-align` instead
    vLink: null, // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number, // `<img>` and `<object>`

    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    disableRemotePlayback: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    prefix: null,
    property: null,
    results: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    security: null,
    unselectable: null
  }
})


/***/ }),

/***/ "./node_modules/property-information/lib/normalize.js":
/*!************************************************************!*\
  !*** ./node_modules/property-information/lib/normalize.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   normalize: () => (/* binding */ normalize)
/* harmony export */ });
/**
 * @param {string} value
 * @returns {string}
 */
function normalize(value) {
  return value.toLowerCase()
}


/***/ }),

/***/ "./node_modules/property-information/lib/svg.js":
/*!******************************************************!*\
  !*** ./node_modules/property-information/lib/svg.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   svg: () => (/* binding */ svg)
/* harmony export */ });
/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/types.js */ "./node_modules/property-information/lib/util/types.js");
/* harmony import */ var _util_create_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/create.js */ "./node_modules/property-information/lib/util/create.js");
/* harmony import */ var _util_case_sensitive_transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/case-sensitive-transform.js */ "./node_modules/property-information/lib/util/case-sensitive-transform.js");




const svg = (0,_util_create_js__WEBPACK_IMPORTED_MODULE_1__.create)({
  space: 'svg',
  attributes: {
    accentHeight: 'accent-height',
    alignmentBaseline: 'alignment-baseline',
    arabicForm: 'arabic-form',
    baselineShift: 'baseline-shift',
    capHeight: 'cap-height',
    className: 'class',
    clipPath: 'clip-path',
    clipRule: 'clip-rule',
    colorInterpolation: 'color-interpolation',
    colorInterpolationFilters: 'color-interpolation-filters',
    colorProfile: 'color-profile',
    colorRendering: 'color-rendering',
    crossOrigin: 'crossorigin',
    dataType: 'datatype',
    dominantBaseline: 'dominant-baseline',
    enableBackground: 'enable-background',
    fillOpacity: 'fill-opacity',
    fillRule: 'fill-rule',
    floodColor: 'flood-color',
    floodOpacity: 'flood-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    fontSizeAdjust: 'font-size-adjust',
    fontStretch: 'font-stretch',
    fontStyle: 'font-style',
    fontVariant: 'font-variant',
    fontWeight: 'font-weight',
    glyphName: 'glyph-name',
    glyphOrientationHorizontal: 'glyph-orientation-horizontal',
    glyphOrientationVertical: 'glyph-orientation-vertical',
    hrefLang: 'hreflang',
    horizAdvX: 'horiz-adv-x',
    horizOriginX: 'horiz-origin-x',
    horizOriginY: 'horiz-origin-y',
    imageRendering: 'image-rendering',
    letterSpacing: 'letter-spacing',
    lightingColor: 'lighting-color',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    navDown: 'nav-down',
    navDownLeft: 'nav-down-left',
    navDownRight: 'nav-down-right',
    navLeft: 'nav-left',
    navNext: 'nav-next',
    navPrev: 'nav-prev',
    navRight: 'nav-right',
    navUp: 'nav-up',
    navUpLeft: 'nav-up-left',
    navUpRight: 'nav-up-right',
    onAbort: 'onabort',
    onActivate: 'onactivate',
    onAfterPrint: 'onafterprint',
    onBeforePrint: 'onbeforeprint',
    onBegin: 'onbegin',
    onCancel: 'oncancel',
    onCanPlay: 'oncanplay',
    onCanPlayThrough: 'oncanplaythrough',
    onChange: 'onchange',
    onClick: 'onclick',
    onClose: 'onclose',
    onCopy: 'oncopy',
    onCueChange: 'oncuechange',
    onCut: 'oncut',
    onDblClick: 'ondblclick',
    onDrag: 'ondrag',
    onDragEnd: 'ondragend',
    onDragEnter: 'ondragenter',
    onDragExit: 'ondragexit',
    onDragLeave: 'ondragleave',
    onDragOver: 'ondragover',
    onDragStart: 'ondragstart',
    onDrop: 'ondrop',
    onDurationChange: 'ondurationchange',
    onEmptied: 'onemptied',
    onEnd: 'onend',
    onEnded: 'onended',
    onError: 'onerror',
    onFocus: 'onfocus',
    onFocusIn: 'onfocusin',
    onFocusOut: 'onfocusout',
    onHashChange: 'onhashchange',
    onInput: 'oninput',
    onInvalid: 'oninvalid',
    onKeyDown: 'onkeydown',
    onKeyPress: 'onkeypress',
    onKeyUp: 'onkeyup',
    onLoad: 'onload',
    onLoadedData: 'onloadeddata',
    onLoadedMetadata: 'onloadedmetadata',
    onLoadStart: 'onloadstart',
    onMessage: 'onmessage',
    onMouseDown: 'onmousedown',
    onMouseEnter: 'onmouseenter',
    onMouseLeave: 'onmouseleave',
    onMouseMove: 'onmousemove',
    onMouseOut: 'onmouseout',
    onMouseOver: 'onmouseover',
    onMouseUp: 'onmouseup',
    onMouseWheel: 'onmousewheel',
    onOffline: 'onoffline',
    onOnline: 'ononline',
    onPageHide: 'onpagehide',
    onPageShow: 'onpageshow',
    onPaste: 'onpaste',
    onPause: 'onpause',
    onPlay: 'onplay',
    onPlaying: 'onplaying',
    onPopState: 'onpopstate',
    onProgress: 'onprogress',
    onRateChange: 'onratechange',
    onRepeat: 'onrepeat',
    onReset: 'onreset',
    onResize: 'onresize',
    onScroll: 'onscroll',
    onSeeked: 'onseeked',
    onSeeking: 'onseeking',
    onSelect: 'onselect',
    onShow: 'onshow',
    onStalled: 'onstalled',
    onStorage: 'onstorage',
    onSubmit: 'onsubmit',
    onSuspend: 'onsuspend',
    onTimeUpdate: 'ontimeupdate',
    onToggle: 'ontoggle',
    onUnload: 'onunload',
    onVolumeChange: 'onvolumechange',
    onWaiting: 'onwaiting',
    onZoom: 'onzoom',
    overlinePosition: 'overline-position',
    overlineThickness: 'overline-thickness',
    paintOrder: 'paint-order',
    panose1: 'panose-1',
    pointerEvents: 'pointer-events',
    referrerPolicy: 'referrerpolicy',
    renderingIntent: 'rendering-intent',
    shapeRendering: 'shape-rendering',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strikethroughPosition: 'strikethrough-position',
    strikethroughThickness: 'strikethrough-thickness',
    strokeDashArray: 'stroke-dasharray',
    strokeDashOffset: 'stroke-dashoffset',
    strokeLineCap: 'stroke-linecap',
    strokeLineJoin: 'stroke-linejoin',
    strokeMiterLimit: 'stroke-miterlimit',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    tabIndex: 'tabindex',
    textAnchor: 'text-anchor',
    textDecoration: 'text-decoration',
    textRendering: 'text-rendering',
    transformOrigin: 'transform-origin',
    typeOf: 'typeof',
    underlinePosition: 'underline-position',
    underlineThickness: 'underline-thickness',
    unicodeBidi: 'unicode-bidi',
    unicodeRange: 'unicode-range',
    unitsPerEm: 'units-per-em',
    vAlphabetic: 'v-alphabetic',
    vHanging: 'v-hanging',
    vIdeographic: 'v-ideographic',
    vMathematical: 'v-mathematical',
    vectorEffect: 'vector-effect',
    vertAdvY: 'vert-adv-y',
    vertOriginX: 'vert-origin-x',
    vertOriginY: 'vert-origin-y',
    wordSpacing: 'word-spacing',
    writingMode: 'writing-mode',
    xHeight: 'x-height',
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: 'playbackorder',
    timelineBegin: 'timelinebegin'
  },
  transform: _util_case_sensitive_transform_js__WEBPACK_IMPORTED_MODULE_2__.caseSensitiveTransform,
  properties: {
    about: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaOrSpaceSeparated,
    accentHeight: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    amplitude: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    arabicForm: null,
    ascent: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    attributeName: null,
    attributeType: null,
    azimuth: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    by: null,
    calcMode: null,
    capHeight: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    className: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    diffuseConstant: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    direction: null,
    display: null,
    dur: null,
    divisor: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    dominantBaseline: null,
    download: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaSeparated,
    g2: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaSeparated,
    glyphName: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    horizOriginX: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    horizOriginY: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    id: null,
    ideographic: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    k: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    k1: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    k2: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    k3: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    k4: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    kernelMatrix: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null, // SEMI_COLON_SEPARATED
    keySplines: null, // SEMI_COLON_SEPARATED
    keyTimes: null, // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    overlineThickness: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    pointsAtY: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    pointsAtZ: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaOrSpaceSeparated,
    rev: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaOrSpaceSeparated,
    requiredFeatures: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaOrSpaceSeparated,
    requiredFonts: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaOrSpaceSeparated,
    requiredFormats: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    specularExponent: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    strikethroughThickness: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    string: null,
    stroke: null,
    strokeDashArray: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    strokeOpacity: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    strokeWidth: null,
    style: null,
    surfaceScale: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaOrSpaceSeparated,
    tabIndex: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    tableValues: null,
    target: null,
    targetX: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    targetY: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    underlineThickness: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    values: null,
    vAlphabetic: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    vMathematical: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    vectorEffect: null,
    vHanging: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    vIdeographic: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    version: null,
    vertAdvY: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    vertOriginX: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    vertOriginY: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: _util_types_js__WEBPACK_IMPORTED_MODULE_0__.number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
})


/***/ }),

/***/ "./node_modules/property-information/lib/util/case-insensitive-transform.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/property-information/lib/util/case-insensitive-transform.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   caseInsensitiveTransform: () => (/* binding */ caseInsensitiveTransform)
/* harmony export */ });
/* harmony import */ var _case_sensitive_transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./case-sensitive-transform.js */ "./node_modules/property-information/lib/util/case-sensitive-transform.js");


/**
 * @param {Record<string, string>} attributes
 * @param {string} property
 * @returns {string}
 */
function caseInsensitiveTransform(attributes, property) {
  return (0,_case_sensitive_transform_js__WEBPACK_IMPORTED_MODULE_0__.caseSensitiveTransform)(attributes, property.toLowerCase())
}


/***/ }),

/***/ "./node_modules/property-information/lib/util/case-sensitive-transform.js":
/*!********************************************************************************!*\
  !*** ./node_modules/property-information/lib/util/case-sensitive-transform.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   caseSensitiveTransform: () => (/* binding */ caseSensitiveTransform)
/* harmony export */ });
/**
 * @param {Record<string, string>} attributes
 * @param {string} attribute
 * @returns {string}
 */
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute
}


/***/ }),

/***/ "./node_modules/property-information/lib/util/create.js":
/*!**************************************************************!*\
  !*** ./node_modules/property-information/lib/util/create.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   create: () => (/* binding */ create)
/* harmony export */ });
/* harmony import */ var _normalize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../normalize.js */ "./node_modules/property-information/lib/normalize.js");
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schema.js */ "./node_modules/property-information/lib/util/schema.js");
/* harmony import */ var _defined_info_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defined-info.js */ "./node_modules/property-information/lib/util/defined-info.js");
/**
 * @typedef {import('./schema.js').Properties} Properties
 * @typedef {import('./schema.js').Normal} Normal
 *
 * @typedef {Record<string, string>} Attributes
 *
 * @typedef {Object} Definition
 * @property {Record<string, number|null>} properties
 * @property {(attributes: Attributes, property: string) => string} transform
 * @property {string} [space]
 * @property {Attributes} [attributes]
 * @property {Array<string>} [mustUseProperty]
 */





const own = {}.hasOwnProperty

/**
 * @param {Definition} definition
 * @returns {Schema}
 */
function create(definition) {
  /** @type {Properties} */
  const property = {}
  /** @type {Normal} */
  const normal = {}
  /** @type {string} */
  let prop

  for (prop in definition.properties) {
    if (own.call(definition.properties, prop)) {
      const value = definition.properties[prop]
      const info = new _defined_info_js__WEBPACK_IMPORTED_MODULE_2__.DefinedInfo(
        prop,
        definition.transform(definition.attributes || {}, prop),
        value,
        definition.space
      )

      if (
        definition.mustUseProperty &&
        definition.mustUseProperty.includes(prop)
      ) {
        info.mustUseProperty = true
      }

      property[prop] = info

      normal[(0,_normalize_js__WEBPACK_IMPORTED_MODULE_0__.normalize)(prop)] = prop
      normal[(0,_normalize_js__WEBPACK_IMPORTED_MODULE_0__.normalize)(info.attribute)] = prop
    }
  }

  return new _schema_js__WEBPACK_IMPORTED_MODULE_1__.Schema(property, normal, definition.space)
}


/***/ }),

/***/ "./node_modules/property-information/lib/util/defined-info.js":
/*!********************************************************************!*\
  !*** ./node_modules/property-information/lib/util/defined-info.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefinedInfo: () => (/* binding */ DefinedInfo)
/* harmony export */ });
/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./info.js */ "./node_modules/property-information/lib/util/info.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.js */ "./node_modules/property-information/lib/util/types.js");



/** @type {Array<keyof types>} */
// @ts-expect-error: hush.
const checks = Object.keys(_types_js__WEBPACK_IMPORTED_MODULE_1__)

class DefinedInfo extends _info_js__WEBPACK_IMPORTED_MODULE_0__.Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property, attribute, mask, space) {
    let index = -1

    super(property, attribute)

    mark(this, 'space', space)

    if (typeof mask === 'number') {
      while (++index < checks.length) {
        const check = checks[index]
        mark(this, checks[index], (mask & _types_js__WEBPACK_IMPORTED_MODULE_1__[check]) === _types_js__WEBPACK_IMPORTED_MODULE_1__[check])
      }
    }
  }
}

DefinedInfo.prototype.defined = true

/**
 * @param {DefinedInfo} values
 * @param {string} key
 * @param {unknown} value
 */
function mark(values, key, value) {
  if (value) {
    // @ts-expect-error: assume `value` matches the expected value of `key`.
    values[key] = value
  }
}


/***/ }),

/***/ "./node_modules/property-information/lib/util/info.js":
/*!************************************************************!*\
  !*** ./node_modules/property-information/lib/util/info.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Info: () => (/* binding */ Info)
/* harmony export */ });
class Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property, attribute) {
    /** @type {string} */
    this.property = property
    /** @type {string} */
    this.attribute = attribute
  }
}

/** @type {string|null} */
Info.prototype.space = null
Info.prototype.boolean = false
Info.prototype.booleanish = false
Info.prototype.overloadedBoolean = false
Info.prototype.number = false
Info.prototype.commaSeparated = false
Info.prototype.spaceSeparated = false
Info.prototype.commaOrSpaceSeparated = false
Info.prototype.mustUseProperty = false
Info.prototype.defined = false


/***/ }),

/***/ "./node_modules/property-information/lib/util/merge.js":
/*!*************************************************************!*\
  !*** ./node_modules/property-information/lib/util/merge.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   merge: () => (/* binding */ merge)
/* harmony export */ });
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schema.js */ "./node_modules/property-information/lib/util/schema.js");
/**
 * @typedef {import('./schema.js').Properties} Properties
 * @typedef {import('./schema.js').Normal} Normal
 */



/**
 * @param {Schema[]} definitions
 * @param {string} [space]
 * @returns {Schema}
 */
function merge(definitions, space) {
  /** @type {Properties} */
  const property = {}
  /** @type {Normal} */
  const normal = {}
  let index = -1

  while (++index < definitions.length) {
    Object.assign(property, definitions[index].property)
    Object.assign(normal, definitions[index].normal)
  }

  return new _schema_js__WEBPACK_IMPORTED_MODULE_0__.Schema(property, normal, space)
}


/***/ }),

/***/ "./node_modules/property-information/lib/util/schema.js":
/*!**************************************************************!*\
  !*** ./node_modules/property-information/lib/util/schema.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Schema: () => (/* binding */ Schema)
/* harmony export */ });
/**
 * @typedef {import('./info.js').Info} Info
 * @typedef {Record<string, Info>} Properties
 * @typedef {Record<string, string>} Normal
 */

class Schema {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property, normal, space) {
    this.property = property
    this.normal = normal
    if (space) {
      this.space = space
    }
  }
}

/** @type {Properties} */
Schema.prototype.property = {}
/** @type {Normal} */
Schema.prototype.normal = {}
/** @type {string|null} */
Schema.prototype.space = null


/***/ }),

/***/ "./node_modules/property-information/lib/util/types.js":
/*!*************************************************************!*\
  !*** ./node_modules/property-information/lib/util/types.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   boolean: () => (/* binding */ boolean),
/* harmony export */   booleanish: () => (/* binding */ booleanish),
/* harmony export */   commaOrSpaceSeparated: () => (/* binding */ commaOrSpaceSeparated),
/* harmony export */   commaSeparated: () => (/* binding */ commaSeparated),
/* harmony export */   number: () => (/* binding */ number),
/* harmony export */   overloadedBoolean: () => (/* binding */ overloadedBoolean),
/* harmony export */   spaceSeparated: () => (/* binding */ spaceSeparated)
/* harmony export */ });
let powers = 0

const boolean = increment()
const booleanish = increment()
const overloadedBoolean = increment()
const number = increment()
const spaceSeparated = increment()
const commaSeparated = increment()
const commaOrSpaceSeparated = increment()

function increment() {
  return 2 ** ++powers
}


/***/ }),

/***/ "./node_modules/property-information/lib/xlink.js":
/*!********************************************************!*\
  !*** ./node_modules/property-information/lib/xlink.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   xlink: () => (/* binding */ xlink)
/* harmony export */ });
/* harmony import */ var _util_create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/create.js */ "./node_modules/property-information/lib/util/create.js");


const xlink = (0,_util_create_js__WEBPACK_IMPORTED_MODULE_0__.create)({
  space: 'xlink',
  transform(_, prop) {
    return 'xlink:' + prop.slice(5).toLowerCase()
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
})


/***/ }),

/***/ "./node_modules/property-information/lib/xml.js":
/*!******************************************************!*\
  !*** ./node_modules/property-information/lib/xml.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   xml: () => (/* binding */ xml)
/* harmony export */ });
/* harmony import */ var _util_create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/create.js */ "./node_modules/property-information/lib/util/create.js");


const xml = (0,_util_create_js__WEBPACK_IMPORTED_MODULE_0__.create)({
  space: 'xml',
  transform(_, prop) {
    return 'xml:' + prop.slice(3).toLowerCase()
  },
  properties: {xmlLang: null, xmlBase: null, xmlSpace: null}
})


/***/ }),

/***/ "./node_modules/property-information/lib/xmlns.js":
/*!********************************************************!*\
  !*** ./node_modules/property-information/lib/xmlns.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   xmlns: () => (/* binding */ xmlns)
/* harmony export */ });
/* harmony import */ var _util_create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/create.js */ "./node_modules/property-information/lib/util/create.js");
/* harmony import */ var _util_case_insensitive_transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/case-insensitive-transform.js */ "./node_modules/property-information/lib/util/case-insensitive-transform.js");



const xmlns = (0,_util_create_js__WEBPACK_IMPORTED_MODULE_0__.create)({
  space: 'xmlns',
  attributes: {xmlnsxlink: 'xmlns:xlink'},
  transform: _util_case_insensitive_transform_js__WEBPACK_IMPORTED_MODULE_1__.caseInsensitiveTransform,
  properties: {xmlns: null, xmlnsXLink: null}
})


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) // removed by dead control flow
{} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react-markdown/index.js":
/*!**********************************************!*\
  !*** ./node_modules/react-markdown/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _lib_react_markdown_js__WEBPACK_IMPORTED_MODULE_1__.ReactMarkdown),
/* harmony export */   uriTransformer: () => (/* reexport safe */ _lib_uri_transformer_js__WEBPACK_IMPORTED_MODULE_0__.uriTransformer)
/* harmony export */ });
/* harmony import */ var _lib_uri_transformer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/uri-transformer.js */ "./node_modules/react-markdown/lib/uri-transformer.js");
/* harmony import */ var _lib_react_markdown_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/react-markdown.js */ "./node_modules/react-markdown/lib/react-markdown.js");
/**
 * @typedef {import('./lib/react-markdown.js').ReactMarkdownOptions} Options
 * @typedef {import('./lib/ast-to-react.js').Components} Components
 */






/***/ }),

/***/ "./node_modules/react-markdown/lib/ast-to-react.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-markdown/lib/ast-to-react.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   childrenToReact: () => (/* binding */ childrenToReact)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-is */ "./node_modules/react-markdown/node_modules/react-is/index.js");
/* harmony import */ var hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-whitespace */ "./node_modules/hast-util-whitespace/index.js");
/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! property-information */ "./node_modules/property-information/index.js");
/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! property-information */ "./node_modules/property-information/lib/find.js");
/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! property-information */ "./node_modules/property-information/lib/hast-to-react.js");
/* harmony import */ var space_separated_tokens__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! space-separated-tokens */ "./node_modules/space-separated-tokens/index.js");
/* harmony import */ var comma_separated_tokens__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! comma-separated-tokens */ "./node_modules/comma-separated-tokens/index.js");
/* harmony import */ var style_to_object__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! style-to-object */ "./node_modules/style-to-object/index.js");
/**
 * @template T
 * @typedef {import('react').ComponentType<T>} ComponentType<T>
 */

/**
 * @template T
 * @typedef {import('react').ComponentPropsWithoutRef<T>} ComponentPropsWithoutRef<T>
 */

/**
 * @typedef {import('react').ReactNode} ReactNode
 * @typedef {import('unist').Position} Position
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').ElementContent} ElementContent
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Text} Text
 * @typedef {import('hast').Comment} Comment
 * @typedef {import('hast').DocType} Doctype
 * @typedef {import('property-information').Info} Info
 * @typedef {import('property-information').Schema} Schema
 * @typedef {import('./complex-types').ReactMarkdownProps} ReactMarkdownProps
 *
 * @typedef Raw
 * @property {'raw'} type
 * @property {string} value
 *
 * @typedef Context
 * @property {Options} options
 * @property {Schema} schema
 * @property {number} listDepth
 *
 * @callback TransformLink
 * @param {string} href
 * @param {Array<ElementContent>} children
 * @param {string?} title
 * @returns {string}
 *
 * @callback TransformImage
 * @param {string} src
 * @param {string} alt
 * @param {string?} title
 * @returns {string}
 *
 * @typedef {import('react').HTMLAttributeAnchorTarget} TransformLinkTargetType
 *
 * @callback TransformLinkTarget
 * @param {string} href
 * @param {Array<ElementContent>} children
 * @param {string?} title
 * @returns {TransformLinkTargetType|undefined}
 *
 * @typedef {keyof JSX.IntrinsicElements} ReactMarkdownNames
 *
 * To do: is `data-sourcepos` typeable?
 *
 * @typedef {ComponentPropsWithoutRef<'code'> & ReactMarkdownProps & {inline?: boolean}} CodeProps
 * @typedef {ComponentPropsWithoutRef<'h1'> & ReactMarkdownProps & {level: number}} HeadingProps
 * @typedef {ComponentPropsWithoutRef<'li'> & ReactMarkdownProps & {checked: boolean|null, index: number, ordered: boolean}} LiProps
 * @typedef {ComponentPropsWithoutRef<'ol'> & ReactMarkdownProps & {depth: number, ordered: true}} OrderedListProps
 * @typedef {ComponentPropsWithoutRef<'table'> & ReactMarkdownProps & {style?: Record<string, unknown>, isHeader: boolean}} TableCellProps
 * @typedef {ComponentPropsWithoutRef<'tr'> & ReactMarkdownProps & {isHeader: boolean}} TableRowProps
 * @typedef {ComponentPropsWithoutRef<'ul'> & ReactMarkdownProps & {depth: number, ordered: false}} UnorderedListProps
 *
 * @typedef {ComponentType<CodeProps>} CodeComponent
 * @typedef {ComponentType<HeadingProps>} HeadingComponent
 * @typedef {ComponentType<LiProps>} LiComponent
 * @typedef {ComponentType<OrderedListProps>} OrderedListComponent
 * @typedef {ComponentType<TableCellProps>} TableCellComponent
 * @typedef {ComponentType<TableRowProps>} TableRowComponent
 * @typedef {ComponentType<UnorderedListProps>} UnorderedListComponent
 *
 * @typedef SpecialComponents
 * @property {CodeComponent|ReactMarkdownNames} code
 * @property {HeadingComponent|ReactMarkdownNames} h1
 * @property {HeadingComponent|ReactMarkdownNames} h2
 * @property {HeadingComponent|ReactMarkdownNames} h3
 * @property {HeadingComponent|ReactMarkdownNames} h4
 * @property {HeadingComponent|ReactMarkdownNames} h5
 * @property {HeadingComponent|ReactMarkdownNames} h6
 * @property {LiComponent|ReactMarkdownNames} li
 * @property {OrderedListComponent|ReactMarkdownNames} ol
 * @property {TableCellComponent|ReactMarkdownNames} td
 * @property {TableCellComponent|ReactMarkdownNames} th
 * @property {TableRowComponent|ReactMarkdownNames} tr
 * @property {UnorderedListComponent|ReactMarkdownNames} ul
 *
 * @typedef {Partial<Omit<import('./complex-types').NormalComponents, keyof SpecialComponents> & SpecialComponents>} Components
 *
 * @typedef Options
 * @property {boolean} [sourcePos=false]
 * @property {boolean} [rawSourcePos=false]
 * @property {boolean} [skipHtml=false]
 * @property {boolean} [includeElementIndex=false]
 * @property {null|false|TransformLink} [transformLinkUri]
 * @property {TransformImage} [transformImageUri]
 * @property {TransformLinkTargetType|TransformLinkTarget} [linkTarget]
 * @property {Components} [components]
 */









const own = {}.hasOwnProperty

// The table-related elements that must not contain whitespace text according
// to React.
const tableElements = new Set(['table', 'thead', 'tbody', 'tfoot', 'tr'])

/**
 * @param {Context} context
 * @param {Element|Root} node
 */
function childrenToReact(context, node) {
  /** @type {Array<ReactNode>} */
  const children = []
  let childIndex = -1
  /** @type {Comment|Doctype|Element|Raw|Text} */
  let child

  while (++childIndex < node.children.length) {
    child = node.children[childIndex]

    if (child.type === 'element') {
      children.push(toReact(context, child, childIndex, node))
    } else if (child.type === 'text') {
      // Currently, a warning is triggered by react for *any* white space in
      // tables.
      // So we drop it.
      // See: <https://github.com/facebook/react/pull/7081>.
      // See: <https://github.com/facebook/react/pull/7515>.
      // See: <https://github.com/remarkjs/remark-react/issues/64>.
      // See: <https://github.com/remarkjs/react-markdown/issues/576>.
      if (
        node.type !== 'element' ||
        !tableElements.has(node.tagName) ||
        !(0,hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__.whitespace)(child)
      ) {
        children.push(child.value)
      }
    } else if (child.type === 'raw' && !context.options.skipHtml) {
      // Default behavior is to show (encoded) HTML.
      children.push(child.value)
    }
  }

  return children
}

/**
 * @param {Context} context
 * @param {Element} node
 * @param {number} index
 * @param {Element|Root} parent
 */
function toReact(context, node, index, parent) {
  const options = context.options
  const parentSchema = context.schema
  /** @type {ReactMarkdownNames} */
  // @ts-expect-error assume a known HTML/SVG element.
  const name = node.tagName
  /** @type {Record<string, unknown>} */
  const properties = {}
  let schema = parentSchema
  /** @type {string} */
  let property

  if (parentSchema.space === 'html' && name === 'svg') {
    schema = property_information__WEBPACK_IMPORTED_MODULE_3__.svg
    context.schema = schema
  }

  if (node.properties) {
    for (property in node.properties) {
      if (own.call(node.properties, property)) {
        addProperty(properties, property, node.properties[property], context)
      }
    }
  }

  if (name === 'ol' || name === 'ul') {
    context.listDepth++
  }

  const children = childrenToReact(context, node)

  if (name === 'ol' || name === 'ul') {
    context.listDepth--
  }

  // Restore parent schema.
  context.schema = parentSchema

  // Nodes created by plugins do not have positional info, in which case we use
  // an object that matches the position interface.
  const position = node.position || {
    start: {line: null, column: null, offset: null},
    end: {line: null, column: null, offset: null}
  }
  const component =
    options.components && own.call(options.components, name)
      ? options.components[name]
      : name
  const basic = typeof component === 'string' || component === react__WEBPACK_IMPORTED_MODULE_0__.Fragment

  if (!react_is__WEBPACK_IMPORTED_MODULE_1__.isValidElementType(component)) {
    throw new TypeError(
      `Component for name \`${name}\` not defined or is not renderable`
    )
  }

  properties.key = [
    name,
    position.start.line,
    position.start.column,
    index
  ].join('-')

  if (name === 'a' && options.linkTarget) {
    properties.target =
      typeof options.linkTarget === 'function'
        ? options.linkTarget(
            String(properties.href || ''),
            node.children,
            typeof properties.title === 'string' ? properties.title : null
          )
        : options.linkTarget
  }

  if (name === 'a' && options.transformLinkUri) {
    properties.href = options.transformLinkUri(
      String(properties.href || ''),
      node.children,
      typeof properties.title === 'string' ? properties.title : null
    )
  }

  if (
    !basic &&
    name === 'code' &&
    parent.type === 'element' &&
    parent.tagName !== 'pre'
  ) {
    properties.inline = true
  }

  if (
    !basic &&
    (name === 'h1' ||
      name === 'h2' ||
      name === 'h3' ||
      name === 'h4' ||
      name === 'h5' ||
      name === 'h6')
  ) {
    properties.level = Number.parseInt(name.charAt(1), 10)
  }

  if (name === 'img' && options.transformImageUri) {
    properties.src = options.transformImageUri(
      String(properties.src || ''),
      String(properties.alt || ''),
      typeof properties.title === 'string' ? properties.title : null
    )
  }

  if (!basic && name === 'li' && parent.type === 'element') {
    const input = getInputElement(node)
    properties.checked =
      input && input.properties ? Boolean(input.properties.checked) : null
    properties.index = getElementsBeforeCount(parent, node)
    properties.ordered = parent.tagName === 'ol'
  }

  if (!basic && (name === 'ol' || name === 'ul')) {
    properties.ordered = name === 'ol'
    properties.depth = context.listDepth
  }

  if (name === 'td' || name === 'th') {
    if (properties.align) {
      if (!properties.style) properties.style = {}
      // @ts-expect-error assume `style` is an object
      properties.style.textAlign = properties.align
      delete properties.align
    }

    if (!basic) {
      properties.isHeader = name === 'th'
    }
  }

  if (!basic && name === 'tr' && parent.type === 'element') {
    properties.isHeader = Boolean(parent.tagName === 'thead')
  }

  // If `sourcePos` is given, pass source information (line/column info from markdown source).
  if (options.sourcePos) {
    properties['data-sourcepos'] = flattenPosition(position)
  }

  if (!basic && options.rawSourcePos) {
    properties.sourcePosition = node.position
  }

  // If `includeElementIndex` is given, pass node index info to components.
  if (!basic && options.includeElementIndex) {
    properties.index = getElementsBeforeCount(parent, node)
    properties.siblingCount = getElementsBeforeCount(parent)
  }

  if (!basic) {
    properties.node = node
  }

  // Ensure no React warnings are emitted for void elements w/ children.
  return children.length > 0
    ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(component, properties, children)
    : react__WEBPACK_IMPORTED_MODULE_0__.createElement(component, properties)
}

/**
 * @param {Element|Root} node
 * @returns {Element?}
 */
function getInputElement(node) {
  let index = -1

  while (++index < node.children.length) {
    const child = node.children[index]

    if (child.type === 'element' && child.tagName === 'input') {
      return child
    }
  }

  return null
}

/**
 * @param {Element|Root} parent
 * @param {Element} [node]
 * @returns {number}
 */
function getElementsBeforeCount(parent, node) {
  let index = -1
  let count = 0

  while (++index < parent.children.length) {
    if (parent.children[index] === node) break
    if (parent.children[index].type === 'element') count++
  }

  return count
}

/**
 * @param {Record<string, unknown>} props
 * @param {string} prop
 * @param {unknown} value
 * @param {Context} ctx
 */
function addProperty(props, prop, value, ctx) {
  const info = (0,property_information__WEBPACK_IMPORTED_MODULE_4__.find)(ctx.schema, prop)
  let result = value

  // Ignore nullish and `NaN` values.
  // eslint-disable-next-line no-self-compare
  if (result === null || result === undefined || result !== result) {
    return
  }

  // Accept `array`.
  // Most props are space-separated.
  if (Array.isArray(result)) {
    result = info.commaSeparated ? (0,comma_separated_tokens__WEBPACK_IMPORTED_MODULE_7__.stringify)(result) : (0,space_separated_tokens__WEBPACK_IMPORTED_MODULE_6__.stringify)(result)
  }

  if (info.property === 'style' && typeof result === 'string') {
    result = parseStyle(result)
  }

  if (info.space && info.property) {
    props[
      own.call(property_information__WEBPACK_IMPORTED_MODULE_5__.hastToReact, info.property)
        ? property_information__WEBPACK_IMPORTED_MODULE_5__.hastToReact[info.property]
        : info.property
    ] = result
  } else if (info.attribute) {
    props[info.attribute] = result
  }
}

/**
 * @param {string} value
 * @returns {Record<string, string>}
 */
function parseStyle(value) {
  /** @type {Record<string, string>} */
  const result = {}

  try {
    style_to_object__WEBPACK_IMPORTED_MODULE_8__(value, iterator)
  } catch {
    // Silent.
  }

  return result

  /**
   * @param {string} name
   * @param {string} v
   */
  function iterator(name, v) {
    const k = name.slice(0, 4) === '-ms-' ? `ms-${name.slice(4)}` : name
    result[k.replace(/-([a-z])/g, styleReplacer)] = v
  }
}

/**
 * @param {unknown} _
 * @param {string} $1
 */
function styleReplacer(_, $1) {
  return $1.toUpperCase()
}

/**
 * @param {Position|{start: {line: null, column: null, offset: null}, end: {line: null, column: null, offset: null}}} pos
 * @returns {string}
 */
function flattenPosition(pos) {
  return [
    pos.start.line,
    ':',
    pos.start.column,
    '-',
    pos.end.line,
    ':',
    pos.end.column
  ]
    .map((d) => String(d))
    .join('')
}


/***/ }),

/***/ "./node_modules/react-markdown/lib/react-markdown.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-markdown/lib/react-markdown.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReactMarkdown: () => (/* binding */ ReactMarkdown)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var vfile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vfile */ "./node_modules/vfile/lib/index.js");
/* harmony import */ var unified__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unified */ "./node_modules/unified/lib/index.js");
/* harmony import */ var remark_parse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! remark-parse */ "./node_modules/remark-parse/lib/index.js");
/* harmony import */ var remark_rehype__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! remark-rehype */ "./node_modules/remark-rehype/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! property-information */ "./node_modules/property-information/index.js");
/* harmony import */ var _rehype_filter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rehype-filter.js */ "./node_modules/react-markdown/lib/rehype-filter.js");
/* harmony import */ var _uri_transformer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./uri-transformer.js */ "./node_modules/react-markdown/lib/uri-transformer.js");
/* harmony import */ var _ast_to_react_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ast-to-react.js */ "./node_modules/react-markdown/lib/ast-to-react.js");
/**
 * @typedef {import('react').ReactNode} ReactNode
 * @typedef {import('react').ReactElement<{}>} ReactElement
 * @typedef {import('unified').PluggableList} PluggableList
 * @typedef {import('hast').Root} Root
 * @typedef {import('./rehype-filter.js').Options} FilterOptions
 * @typedef {import('./ast-to-react.js').Options} TransformOptions
 *
 * @typedef CoreOptions
 * @property {string} children
 *
 * @typedef PluginOptions
 * @property {PluggableList} [plugins=[]] **deprecated**: use `remarkPlugins` instead
 * @property {PluggableList} [remarkPlugins=[]]
 * @property {PluggableList} [rehypePlugins=[]]
 *
 * @typedef LayoutOptions
 * @property {string} [className]
 *
 * @typedef {CoreOptions & PluginOptions & LayoutOptions & FilterOptions & TransformOptions} ReactMarkdownOptions
 *
 * @typedef Deprecation
 * @property {string} id
 * @property {string} [to]
 */












const own = {}.hasOwnProperty
const changelog =
  'https://github.com/remarkjs/react-markdown/blob/main/changelog.md'

/** @type {Record<string, Deprecation>} */
const deprecated = {
  renderers: {to: 'components', id: 'change-renderers-to-components'},
  astPlugins: {id: 'remove-buggy-html-in-markdown-parser'},
  allowDangerousHtml: {id: 'remove-buggy-html-in-markdown-parser'},
  escapeHtml: {id: 'remove-buggy-html-in-markdown-parser'},
  source: {to: 'children', id: 'change-source-to-children'},
  allowNode: {
    to: 'allowElement',
    id: 'replace-allownode-allowedtypes-and-disallowedtypes'
  },
  allowedTypes: {
    to: 'allowedElements',
    id: 'replace-allownode-allowedtypes-and-disallowedtypes'
  },
  disallowedTypes: {
    to: 'disallowedElements',
    id: 'replace-allownode-allowedtypes-and-disallowedtypes'
  },
  includeNodeIndex: {
    to: 'includeElementIndex',
    id: 'change-includenodeindex-to-includeelementindex'
  }
}

/**
 * React component to render markdown.
 *
 * @param {ReactMarkdownOptions} options
 * @returns {ReactElement}
 */
function ReactMarkdown(options) {
  for (const key in deprecated) {
    if (own.call(deprecated, key) && own.call(options, key)) {
      const deprecation = deprecated[key]
      console.warn(
        `[react-markdown] Warning: please ${
          deprecation.to ? `use \`${deprecation.to}\` instead of` : 'remove'
        } \`${key}\` (see <${changelog}#${deprecation.id}> for more info)`
      )
      delete deprecated[key]
    }
  }

  const processor = (0,unified__WEBPACK_IMPORTED_MODULE_2__.unified)()
    .use(remark_parse__WEBPACK_IMPORTED_MODULE_3__["default"])
    // TODO: deprecate `plugins` in v8.0.0.
    .use(options.remarkPlugins || options.plugins || [])
    .use(remark_rehype__WEBPACK_IMPORTED_MODULE_4__["default"], {allowDangerousHtml: true})
    .use(options.rehypePlugins || [])
    .use(_rehype_filter_js__WEBPACK_IMPORTED_MODULE_7__["default"], options)

  const file = new vfile__WEBPACK_IMPORTED_MODULE_1__.VFile()

  if (typeof options.children === 'string') {
    file.value = options.children
  } else if (options.children !== undefined && options.children !== null) {
    console.warn(
      `[react-markdown] Warning: please pass a string as \`children\` (not: \`${options.children}\`)`
    )
  }

  const hastNode = processor.runSync(processor.parse(file), file)

  if (hastNode.type !== 'root') {
    throw new TypeError('Expected a `root` node')
  }

  /** @type {ReactElement} */
  let result = react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    react__WEBPACK_IMPORTED_MODULE_0__.Fragment,
    {},
    (0,_ast_to_react_js__WEBPACK_IMPORTED_MODULE_9__.childrenToReact)({options, schema: property_information__WEBPACK_IMPORTED_MODULE_6__.html, listDepth: 0}, hastNode)
  )

  if (options.className) {
    result = react__WEBPACK_IMPORTED_MODULE_0__.createElement('div', {className: options.className}, result)
  }

  return result
}

ReactMarkdown.defaultProps = {transformLinkUri: _uri_transformer_js__WEBPACK_IMPORTED_MODULE_8__.uriTransformer}

ReactMarkdown.propTypes = {
  // Core options:
  children: prop_types__WEBPACK_IMPORTED_MODULE_5__.string,
  // Layout options:
  className: prop_types__WEBPACK_IMPORTED_MODULE_5__.string,
  // Filter options:
  allowElement: prop_types__WEBPACK_IMPORTED_MODULE_5__.func,
  allowedElements: prop_types__WEBPACK_IMPORTED_MODULE_5__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_5__.string),
  disallowedElements: prop_types__WEBPACK_IMPORTED_MODULE_5__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_5__.string),
  unwrapDisallowed: prop_types__WEBPACK_IMPORTED_MODULE_5__.bool,
  // Plugin options:
  remarkPlugins: prop_types__WEBPACK_IMPORTED_MODULE_5__.arrayOf(
    prop_types__WEBPACK_IMPORTED_MODULE_5__.oneOfType([
      prop_types__WEBPACK_IMPORTED_MODULE_5__.object,
      prop_types__WEBPACK_IMPORTED_MODULE_5__.func,
      prop_types__WEBPACK_IMPORTED_MODULE_5__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_5__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_5__.object, prop_types__WEBPACK_IMPORTED_MODULE_5__.func]))
    ])
  ),
  rehypePlugins: prop_types__WEBPACK_IMPORTED_MODULE_5__.arrayOf(
    prop_types__WEBPACK_IMPORTED_MODULE_5__.oneOfType([
      prop_types__WEBPACK_IMPORTED_MODULE_5__.object,
      prop_types__WEBPACK_IMPORTED_MODULE_5__.func,
      prop_types__WEBPACK_IMPORTED_MODULE_5__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_5__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_5__.object, prop_types__WEBPACK_IMPORTED_MODULE_5__.func]))
    ])
  ),
  // Transform options:
  sourcePos: prop_types__WEBPACK_IMPORTED_MODULE_5__.bool,
  rawSourcePos: prop_types__WEBPACK_IMPORTED_MODULE_5__.bool,
  skipHtml: prop_types__WEBPACK_IMPORTED_MODULE_5__.bool,
  includeElementIndex: prop_types__WEBPACK_IMPORTED_MODULE_5__.bool,
  transformLinkUri: prop_types__WEBPACK_IMPORTED_MODULE_5__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_5__.func, prop_types__WEBPACK_IMPORTED_MODULE_5__.bool]),
  linkTarget: prop_types__WEBPACK_IMPORTED_MODULE_5__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_5__.func, prop_types__WEBPACK_IMPORTED_MODULE_5__.string]),
  transformImageUri: prop_types__WEBPACK_IMPORTED_MODULE_5__.func,
  components: prop_types__WEBPACK_IMPORTED_MODULE_5__.object
}


/***/ }),

/***/ "./node_modules/react-markdown/lib/rehype-filter.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-markdown/lib/rehype-filter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rehypeFilter)
/* harmony export */ });
/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit */ "./node_modules/unist-util-visit/lib/index.js");


/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Element} Element
 *
 * @callback AllowElement
 * @param {Element} element
 * @param {number} index
 * @param {Element|Root} parent
 * @returns {boolean|undefined}
 *
 * @typedef Options
 * @property {Array<string>} [allowedElements]
 * @property {Array<string>} [disallowedElements=[]]
 * @property {AllowElement} [allowElement]
 * @property {boolean} [unwrapDisallowed=false]
 */

/**
 * @type {import('unified').Plugin<[Options], Root>}
 */
function rehypeFilter(options) {
  if (options.allowedElements && options.disallowedElements) {
    throw new TypeError(
      'Only one of `allowedElements` and `disallowedElements` should be defined'
    )
  }

  if (
    options.allowedElements ||
    options.disallowedElements ||
    options.allowElement
  ) {
    return (tree) => {
      (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(tree, 'element', (node, index, parent_) => {
        const parent = /** @type {Element|Root} */ (parent_)
        /** @type {boolean|undefined} */
        let remove

        if (options.allowedElements) {
          remove = !options.allowedElements.includes(node.tagName)
        } else if (options.disallowedElements) {
          remove = options.disallowedElements.includes(node.tagName)
        }

        if (!remove && options.allowElement && typeof index === 'number') {
          remove = !options.allowElement(node, index, parent)
        }

        if (remove && typeof index === 'number') {
          if (options.unwrapDisallowed && node.children) {
            parent.children.splice(index, 1, ...node.children)
          } else {
            parent.children.splice(index, 1)
          }

          return index
        }

        return undefined
      })
    }
  }
}


/***/ }),

/***/ "./node_modules/react-markdown/lib/uri-transformer.js":
/*!************************************************************!*\
  !*** ./node_modules/react-markdown/lib/uri-transformer.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   uriTransformer: () => (/* binding */ uriTransformer)
/* harmony export */ });
const protocols = ['http', 'https', 'mailto', 'tel']

/**
 * @param {string} uri
 * @returns {string}
 */
function uriTransformer(uri) {
  const url = (uri || '').trim()
  const first = url.charAt(0)

  if (first === '#' || first === '/') {
    return url
  }

  const colon = url.indexOf(':')
  if (colon === -1) {
    return url
  }

  let index = -1

  while (++index < protocols.length) {
    const protocol = protocols[index]

    if (
      colon === protocol.length &&
      url.slice(0, protocol.length).toLowerCase() === protocol
    ) {
      return url
    }
  }

  index = url.indexOf('?')
  if (index !== -1 && colon > index) {
    return url
  }

  index = url.indexOf('#')
  if (index !== -1 && colon > index) {
    return url
  }

  // eslint-disable-next-line no-script-url
  return 'javascript:void(0)'
}


/***/ }),

/***/ "./node_modules/react-markdown/node_modules/react-is/cjs/react-is.development.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/react-markdown/node_modules/react-is/cjs/react-is.development.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v17.0.2
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
var REACT_FRAGMENT_TYPE = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
          case REACT_SUSPENSE_LIST_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
}
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false;
var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
    }
  }

  return false;
}
function isConcurrentMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
    }
  }

  return false;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-markdown/node_modules/react-is/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-markdown/node_modules/react-is/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) // removed by dead control flow
{} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-markdown/node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/remark-parse/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/remark-parse/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ remarkParse)
/* harmony export */ });
/* harmony import */ var mdast_util_from_markdown__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mdast-util-from-markdown */ "./node_modules/mdast-util-from-markdown/dev/lib/index.js");
/**
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast-util-from-markdown').Options} Options
 */



/**
 * @this {import('unified').Processor}
 * @type {import('unified').Plugin<[Options?] | void[], string, Root>}
 */
function remarkParse(options) {
  /** @type {import('unified').ParserFunction<Root>} */
  const parser = (doc) => {
    // Assume options.
    const settings = /** @type {Options} */ (this.data('settings'))

    return (0,mdast_util_from_markdown__WEBPACK_IMPORTED_MODULE_0__.fromMarkdown)(
      doc,
      Object.assign({}, settings, options, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data('micromarkExtensions') || [],
        mdastExtensions: this.data('fromMarkdownExtensions') || []
      })
    )
  }

  Object.assign(this, {Parser: parser})
}


/***/ }),

/***/ "./node_modules/remark-rehype/index.js":
/*!*********************************************!*\
  !*** ./node_modules/remark-rehype/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var mdast_util_to_hast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mdast-util-to-hast */ "./node_modules/mdast-util-to-hast/lib/index.js");
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('hast').Root} HastRoot
 * @typedef {import('mdast').Root} MdastRoot
 * @typedef {import('mdast-util-to-hast').Options} Options
 * @typedef {import('unified').Processor<any, any, any, any>} Processor
 *
 * @typedef {import('mdast-util-to-hast')} DoNotTouchAsThisImportIncludesRawInTree
 */



// Note: the `<MdastRoot, HastRoot>` overload doesn’t seem to work :'(

/**
 * Plugin to bridge or mutate to rehype.
 *
 * If a destination is given, runs the destination with the new hast tree
 * (bridge-mode).
 * Without destination, returns the hast tree: further plugins run on that tree
 * (mutate-mode).
 *
 * @param destination
 *   Optional unified processor.
 * @param options
 *   Options passed to `mdast-util-to-hast`.
 */
const remarkRehype =
  /** @type {(import('unified').Plugin<[Processor, Options?]|[Options]|[], MdastRoot>)} */
  (
    function (destination, options) {
      return destination && 'run' in destination
        ? bridge(destination, options)
        : mutate(destination)
    }
  )

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (remarkRehype);

/**
 * Bridge-mode.
 * Runs the destination with the new hast tree.
 *
 * @type {import('unified').Plugin<[Processor, Options?], MdastRoot>}
 */
function bridge(destination, options) {
  return (node, file, next) => {
    destination.run((0,mdast_util_to_hast__WEBPACK_IMPORTED_MODULE_0__.toHast)(node, options), file, (error) => {
      next(error)
    })
  }
}

/**
 * Mutate-mode.
 * Further transformers run on the nlcst tree.
 *
 * @type {import('unified').Plugin<[Options?]|void[], MdastRoot, HastRoot>}
 */
function mutate(options) {
  // @ts-expect-error: assume a corresponding node is returned for `toHast`.
  return (node) => (0,mdast_util_to_hast__WEBPACK_IMPORTED_MODULE_0__.toHast)(node, options)
}


/***/ }),

/***/ "./node_modules/shortid/index.js":
/*!***************************************!*\
  !*** ./node_modules/shortid/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(/*! ./lib/index */ "./node_modules/shortid/lib/index.js");


/***/ }),

/***/ "./node_modules/shortid/lib/alphabet.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/alphabet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var randomFromSeed = __webpack_require__(/*! ./random/random-from-seed */ "./node_modules/shortid/lib/random/random-from-seed.js");

var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
var alphabet;
var previousSeed;

var shuffled;

function reset() {
    shuffled = false;
}

function setCharacters(_alphabet_) {
    if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
        }
        return;
    }

    if (_alphabet_ === alphabet) {
        return;
    }

    if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
    }

    var unique = _alphabet_.split('').filter(function(item, ind, arr){
       return ind !== arr.lastIndexOf(item);
    });

    if (unique.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
    }

    alphabet = _alphabet_;
    reset();
}

function characters(_alphabet_) {
    setCharacters(_alphabet_);
    return alphabet;
}

function setSeed(seed) {
    randomFromSeed.seed(seed);
    if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
    }
}

function shuffle() {
    if (!alphabet) {
        setCharacters(ORIGINAL);
    }

    var sourceArray = alphabet.split('');
    var targetArray = [];
    var r = randomFromSeed.nextValue();
    var characterIndex;

    while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join('');
}

function getShuffled() {
    if (shuffled) {
        return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
}

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
function lookup(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
}

function get () {
  return alphabet || ORIGINAL;
}

module.exports = {
    get: get,
    characters: characters,
    seed: setSeed,
    lookup: lookup,
    shuffled: getShuffled
};


/***/ }),

/***/ "./node_modules/shortid/lib/build.js":
/*!*******************************************!*\
  !*** ./node_modules/shortid/lib/build.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var generate = __webpack_require__(/*! ./generate */ "./node_modules/shortid/lib/generate.js");
var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
var REDUCE_TIME = 1567752802062;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
var version = 7;

// Counter is used when shortid is called multiple times in one second.
var counter;

// Remember the last time shortid was called in case counter is needed.
var previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
function build(clusterWorkerId) {
    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

    if (seconds === previousSeconds) {
        counter++;
    } else {
        counter = 0;
        previousSeconds = seconds;
    }

    str = str + generate(version);
    str = str + generate(clusterWorkerId);
    if (counter > 0) {
        str = str + generate(counter);
    }
    str = str + generate(seconds);
    return str;
}

module.exports = build;


/***/ }),

/***/ "./node_modules/shortid/lib/generate.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/generate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");
var random = __webpack_require__(/*! ./random/random-byte */ "./node_modules/shortid/lib/random/random-byte-browser.js");
var customRandom = (__webpack_require__(/*! nanoid */ "./node_modules/nanoid/index.browser.js").customRandom);

function generate(number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + customRandom(alphabet.get(), 1, random)();
        done = number < (Math.pow(16, loopCounter + 1 ) );
        loopCounter++;
    }
    return str;
}

module.exports = generate;


/***/ }),

/***/ "./node_modules/shortid/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/shortid/lib/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");
var build = __webpack_require__(/*! ./build */ "./node_modules/shortid/lib/build.js");
var isValid = __webpack_require__(/*! ./is-valid */ "./node_modules/shortid/lib/is-valid.js");

// if you are using cluster or multiple servers use this to make each instance
// has a unique value for worker
// Note: I don't know if this is automatically set when using third
// party cluster solutions such as pm2.
var clusterWorkerId = __webpack_require__(/*! ./util/cluster-worker-id */ "./node_modules/shortid/lib/util/cluster-worker-id-browser.js") || 0;

/**
 * Set the seed.
 * Highly recommended if you don't want people to try to figure out your id schema.
 * exposed as shortid.seed(int)
 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
 */
function seed(seedValue) {
    alphabet.seed(seedValue);
    return module.exports;
}

/**
 * Set the cluster worker or machine id
 * exposed as shortid.worker(int)
 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
 * returns shortid module so it can be chained.
 */
function worker(workerId) {
    clusterWorkerId = workerId;
    return module.exports;
}

/**
 *
 * sets new characters to use in the alphabet
 * returns the shuffled alphabet
 */
function characters(newCharacters) {
    if (newCharacters !== undefined) {
        alphabet.characters(newCharacters);
    }

    return alphabet.shuffled();
}

/**
 * Generate unique id
 * Returns string id
 */
function generate() {
  return build(clusterWorkerId);
}

// Export all other functions as properties of the generate function
module.exports = generate;
module.exports.generate = generate;
module.exports.seed = seed;
module.exports.worker = worker;
module.exports.characters = characters;
module.exports.isValid = isValid;


/***/ }),

/***/ "./node_modules/shortid/lib/is-valid.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/is-valid.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");

function isShortId(id) {
    if (!id || typeof id !== 'string' || id.length < 6 ) {
        return false;
    }

    var nonAlphabetic = new RegExp('[^' +
      alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&') +
    ']');
    return !nonAlphabetic.test(id);
}

module.exports = isShortId;


/***/ }),

/***/ "./node_modules/shortid/lib/random/random-byte-browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/shortid/lib/random/random-byte-browser.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";


var crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

var randomByte;

if (!crypto || !crypto.getRandomValues) {
    randomByte = function(size) {
        var bytes = [];
        for (var i = 0; i < size; i++) {
            bytes.push(Math.floor(Math.random() * 256));
        }
        return bytes;
    };
} else {
    randomByte = function(size) {
        return crypto.getRandomValues(new Uint8Array(size));
    };
}

module.exports = randomByte;


/***/ }),

/***/ "./node_modules/shortid/lib/random/random-from-seed.js":
/*!*************************************************************!*\
  !*** ./node_modules/shortid/lib/random/random-from-seed.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

var seed = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
function getNextValue() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed/(233280.0);
}

function setSeed(_seed_) {
    seed = _seed_;
}

module.exports = {
    nextValue: getNextValue,
    seed: setSeed
};


/***/ }),

/***/ "./node_modules/shortid/lib/util/cluster-worker-id-browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/shortid/lib/util/cluster-worker-id-browser.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


module.exports = 0;


/***/ }),

/***/ "./node_modules/space-separated-tokens/index.js":
/*!******************************************************!*\
  !*** ./node_modules/space-separated-tokens/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   stringify: () => (/* binding */ stringify)
/* harmony export */ });
/**
 * Parse space-separated tokens to an array of strings.
 *
 * @param {string} value
 *   Space-separated tokens.
 * @returns {Array<string>}
 *   List of tokens.
 */
function parse(value) {
  const input = String(value || '').trim()
  return input ? input.split(/[ \t\n\r\f]+/g) : []
}

/**
 * Serialize an array of strings as space separated-tokens.
 *
 * @param {Array<string|number>} values
 *   List of tokens.
 * @returns {string}
 *   Space-separated tokens.
 */
function stringify(values) {
  return values.join(' ').trim()
}


/***/ }),

/***/ "./node_modules/style-to-object/index.js":
/*!***********************************************!*\
  !*** ./node_modules/style-to-object/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parse = __webpack_require__(/*! inline-style-parser */ "./node_modules/inline-style-parser/index.js");

/**
 * Parses inline style to object.
 *
 * @example
 * // returns { 'line-height': '42' }
 * StyleToObject('line-height: 42;');
 *
 * @param  {String}      style      - The inline style.
 * @param  {Function}    [iterator] - The iterator function.
 * @return {null|Object}
 */
function StyleToObject(style, iterator) {
  var output = null;
  if (!style || typeof style !== 'string') {
    return output;
  }

  var declaration;
  var declarations = parse(style);
  var hasIterator = typeof iterator === 'function';
  var property;
  var value;

  for (var i = 0, len = declarations.length; i < len; i++) {
    declaration = declarations[i];
    property = declaration.property;
    value = declaration.value;

    if (hasIterator) {
      iterator(property, value, declaration);
    } else if (value) {
      output || (output = {});
      output[property] = value;
    }
  }

  return output;
}

module.exports = StyleToObject;


/***/ }),

/***/ "./node_modules/tmp/lib/tmp.js":
/*!*************************************!*\
  !*** ./node_modules/tmp/lib/tmp.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */

/*
 * Module dependencies.
 */
const fs = __webpack_require__(/*! fs */ "fs");
const os = __webpack_require__(/*! os */ "os");
const path = __webpack_require__(/*! path */ "path");
const crypto = __webpack_require__(/*! crypto */ "crypto");
const _c = { fs: fs.constants, os: os.constants };

/*
 * The working inner variables.
 */
const // the random characters to choose from
  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
  TEMPLATE_PATTERN = /XXXXXX/,
  DEFAULT_TRIES = 3,
  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),
  // constants are off on the windows platform and will not match the actual errno codes
  IS_WIN32 = os.platform() === 'win32',
  EBADF = _c.EBADF || _c.os.errno.EBADF,
  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,
  DIR_MODE = 0o700 /* 448 */,
  FILE_MODE = 0o600 /* 384 */,
  EXIT = 'exit',
  // this will hold the objects need to be removed on exit
  _removeObjects = [],
  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback
  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);

let _gracefulCleanup = false;

/**
 * Recursively remove a directory and its contents.
 *
 * @param {string} dirPath path of directory to remove
 * @param {Function} callback
 * @private
 */
function rimraf(dirPath, callback) {
  return fs.rm(dirPath, { recursive: true }, callback);
}

/**
 * Recursively remove a directory and its contents, synchronously.
 *
 * @param {string} dirPath path of directory to remove
 * @private
 */
function FN_RIMRAF_SYNC(dirPath) {
  return fs.rmSync(dirPath, { recursive: true });
}

/**
 * Gets a temporary file name.
 *
 * @param {(Options|tmpNameCallback)} options options or callback
 * @param {?tmpNameCallback} callback the callback function
 */
function tmpName(options, callback) {
  const args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  _assertAndSanitizeOptions(opts, function (err, sanitizedOptions) {
    if (err) return cb(err);

    let tries = sanitizedOptions.tries;
    (function _getUniqueName() {
      try {
        const name = _generateTmpName(sanitizedOptions);

        // check whether the path exists then retry if needed
        fs.stat(name, function (err) {
          /* istanbul ignore else */
          if (!err) {
            /* istanbul ignore else */
            if (tries-- > 0) return _getUniqueName();

            return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));
          }

          cb(null, name);
        });
      } catch (err) {
        cb(err);
      }
    })();
  });
}

/**
 * Synchronous version of tmpName.
 *
 * @param {Object} options
 * @returns {string} the generated random name
 * @throws {Error} if the options are invalid or could not generate a filename
 */
function tmpNameSync(options) {
  const args = _parseArguments(options),
    opts = args[0];

  const sanitizedOptions = _assertAndSanitizeOptionsSync(opts);

  let tries = sanitizedOptions.tries;
  do {
    const name = _generateTmpName(sanitizedOptions);
    try {
      fs.statSync(name);
    } catch (e) {
      return name;
    }
  } while (tries-- > 0);

  throw new Error('Could not get a unique tmp filename, max tries reached');
}

/**
 * Creates and opens a temporary file.
 *
 * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined
 * @param {?fileCallback} callback
 */
function file(options, callback) {
  const args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
    if (err) return cb(err);

    // create and open the file
    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
      /* istanbu ignore else */
      if (err) return cb(err);

      if (opts.discardDescriptor) {
        return fs.close(fd, function _discardCallback(possibleErr) {
          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only
          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));
        });
      } else {
        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care
        // about the descriptor
        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
      }
    });
  });
}

/**
 * Synchronous version of file.
 *
 * @param {Options} options
 * @returns {FileSyncObject} object consists of name, fd and removeCallback
 * @throws {Error} if cannot create a file
 */
function fileSync(options) {
  const args = _parseArguments(options),
    opts = args[0];

  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
  const name = tmpNameSync(opts);
  let fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
  /* istanbul ignore else */
  if (opts.discardDescriptor) {
    fs.closeSync(fd);
    fd = undefined;
  }

  return {
    name: name,
    fd: fd,
    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
  };
}

/**
 * Creates a temporary directory.
 *
 * @param {(Options|dirCallback)} options the options or the callback function
 * @param {?dirCallback} callback
 */
function dir(options, callback) {
  const args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
    if (err) return cb(err);

    // create the directory
    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
      /* istanbul ignore else */
      if (err) return cb(err);

      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
    });
  });
}

/**
 * Synchronous version of dir.
 *
 * @param {Options} options
 * @returns {DirSyncObject} object consists of name and removeCallback
 * @throws {Error} if it cannot create a directory
 */
function dirSync(options) {
  const args = _parseArguments(options),
    opts = args[0];

  const name = tmpNameSync(opts);
  fs.mkdirSync(name, opts.mode || DIR_MODE);

  return {
    name: name,
    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
  };
}

/**
 * Removes files asynchronously.
 *
 * @param {Object} fdPath
 * @param {Function} next
 * @private
 */
function _removeFileAsync(fdPath, next) {
  const _handler = function (err) {
    if (err && !_isENOENT(err)) {
      // reraise any unanticipated error
      return next(err);
    }
    next();
  };

  if (0 <= fdPath[0])
    fs.close(fdPath[0], function () {
      fs.unlink(fdPath[1], _handler);
    });
  else fs.unlink(fdPath[1], _handler);
}

/**
 * Removes files synchronously.
 *
 * @param {Object} fdPath
 * @private
 */
function _removeFileSync(fdPath) {
  let rethrownException = null;
  try {
    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);
  } catch (e) {
    // reraise any unanticipated error
    if (!_isEBADF(e) && !_isENOENT(e)) throw e;
  } finally {
    try {
      fs.unlinkSync(fdPath[1]);
    } catch (e) {
      // reraise any unanticipated error
      if (!_isENOENT(e)) rethrownException = e;
    }
  }
  if (rethrownException !== null) {
    throw rethrownException;
  }
}

/**
 * Prepares the callback for removal of the temporary file.
 *
 * Returns either a sync callback or a async callback depending on whether
 * fileSync or file was called, which is expressed by the sync parameter.
 *
 * @param {string} name the path of the file
 * @param {number} fd file descriptor
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {fileCallback | fileCallbackSync}
 * @private
 */
function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {
  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);
  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);

  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return sync ? removeCallbackSync : removeCallback;
}

/**
 * Prepares the callback for removal of the temporary directory.
 *
 * Returns either a sync callback or a async callback depending on whether
 * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.
 *
 * @param {string} name
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {Function} the callback
 * @private
 */
function _prepareTmpDirRemoveCallback(name, opts, sync) {
  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);
  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);
  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);
  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return sync ? removeCallbackSync : removeCallback;
}

/**
 * Creates a guarded function wrapping the removeFunction call.
 *
 * The cleanup callback is save to be called multiple times.
 * Subsequent invocations will be ignored.
 *
 * @param {Function} removeFunction
 * @param {string} fileOrDirName
 * @param {boolean} sync
 * @param {cleanupCallbackSync?} cleanupCallbackSync
 * @returns {cleanupCallback | cleanupCallbackSync}
 * @private
 */
function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {
  let called = false;

  // if sync is true, the next parameter will be ignored
  return function _cleanupCallback(next) {
    /* istanbul ignore else */
    if (!called) {
      // remove cleanupCallback from cache
      const toRemove = cleanupCallbackSync || _cleanupCallback;
      const index = _removeObjects.indexOf(toRemove);
      /* istanbul ignore else */
      if (index >= 0) _removeObjects.splice(index, 1);

      called = true;
      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
        return removeFunction(fileOrDirName);
      } else {
        return removeFunction(fileOrDirName, next || function () {});
      }
    }
  };
}

/**
 * The garbage collector.
 *
 * @private
 */
function _garbageCollector() {
  /* istanbul ignore else */
  if (!_gracefulCleanup) return;

  // the function being called removes itself from _removeObjects,
  // loop until _removeObjects is empty
  while (_removeObjects.length) {
    try {
      _removeObjects[0]();
    } catch (e) {
      // already removed?
    }
  }
}

/**
 * Random name generator based on crypto.
 * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
 *
 * @param {number} howMany
 * @returns {string} the generated random name
 * @private
 */
function _randomChars(howMany) {
  let value = [],
    rnd = null;

  // make sure that we do not fail because we ran out of entropy
  try {
    rnd = crypto.randomBytes(howMany);
  } catch (e) {
    rnd = crypto.pseudoRandomBytes(howMany);
  }

  for (let i = 0; i < howMany; i++) {
    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
  }

  return value.join('');
}

/**
 * Checks whether the `obj` parameter is defined or not.
 *
 * @param {Object} obj
 * @returns {boolean} true if the object is undefined
 * @private
 */
function _isUndefined(obj) {
  return typeof obj === 'undefined';
}

/**
 * Parses the function arguments.
 *
 * This function helps to have optional arguments.
 *
 * @param {(Options|null|undefined|Function)} options
 * @param {?Function} callback
 * @returns {Array} parsed arguments
 * @private
 */
function _parseArguments(options, callback) {
  /* istanbul ignore else */
  if (typeof options === 'function') {
    return [{}, options];
  }

  /* istanbul ignore else */
  if (_isUndefined(options)) {
    return [{}, callback];
  }

  // copy options so we do not leak the changes we make internally
  const actualOptions = {};
  for (const key of Object.getOwnPropertyNames(options)) {
    actualOptions[key] = options[key];
  }

  return [actualOptions, callback];
}

/**
 * Resolve the specified path name in respect to tmpDir.
 *
 * The specified name might include relative path components, e.g. ../
 * so we need to resolve in order to be sure that is is located inside tmpDir
 *
 * @private
 */
function _resolvePath(name, tmpDir, cb) {
  const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);

  fs.stat(pathToResolve, function (err) {
    if (err) {
      fs.realpath(path.dirname(pathToResolve), function (err, parentDir) {
        if (err) return cb(err);

        cb(null, path.join(parentDir, path.basename(pathToResolve)));
      });
    } else {
      fs.realpath(pathToResolve, cb);
    }
  });
}

/**
 * Resolve the specified path name in respect to tmpDir.
 *
 * The specified name might include relative path components, e.g. ../
 * so we need to resolve in order to be sure that is is located inside tmpDir
 *
 * @private
 */
function _resolvePathSync(name, tmpDir) {
  const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);

  try {
    fs.statSync(pathToResolve);
    return fs.realpathSync(pathToResolve);
  } catch (_err) {
    const parentDir = fs.realpathSync(path.dirname(pathToResolve));

    return path.join(parentDir, path.basename(pathToResolve));
  }
}

/**
 * Generates a new temporary name.
 *
 * @param {Object} opts
 * @returns {string} the new random name according to opts
 * @private
 */
function _generateTmpName(opts) {
  const tmpDir = opts.tmpdir;

  /* istanbul ignore else */
  if (!_isUndefined(opts.name)) {
    return path.join(tmpDir, opts.dir, opts.name);
  }

  /* istanbul ignore else */
  if (!_isUndefined(opts.template)) {
    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));
  }

  // prefix and postfix
  const name = [
    opts.prefix ? opts.prefix : 'tmp',
    '-',
    process.pid,
    '-',
    _randomChars(12),
    opts.postfix ? '-' + opts.postfix : ''
  ].join('');

  return path.join(tmpDir, opts.dir, name);
}

/**
 * Asserts and sanitizes the basic options.
 *
 * @private
 */
function _assertOptionsBase(options) {
  if (!_isUndefined(options.name)) {
    const name = options.name;

    // assert that name is not absolute and does not contain a path
    if (path.isAbsolute(name)) throw new Error(`name option must not contain an absolute path, found "${name}".`);

    // must not fail on valid .<name> or ..<name> or similar such constructs
    const basename = path.basename(name);
    if (basename === '..' || basename === '.' || basename !== name)
      throw new Error(`name option must not contain a path, found "${name}".`);
  }

  /* istanbul ignore else */
  if (!_isUndefined(options.template) && !options.template.match(TEMPLATE_PATTERN)) {
    throw new Error(`Invalid template, found "${options.template}".`);
  }

  /* istanbul ignore else */
  if ((!_isUndefined(options.tries) && isNaN(options.tries)) || options.tries < 0) {
    throw new Error(`Invalid tries, found "${options.tries}".`);
  }

  // if a name was specified we will try once
  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
  options.keep = !!options.keep;
  options.detachDescriptor = !!options.detachDescriptor;
  options.discardDescriptor = !!options.discardDescriptor;
  options.unsafeCleanup = !!options.unsafeCleanup;

  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to
  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;
  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;
}

/**
 * Gets the relative directory to tmpDir.
 *
 * @private
 */
function _getRelativePath(option, name, tmpDir, cb) {
  if (_isUndefined(name)) return cb(null);

  _resolvePath(name, tmpDir, function (err, resolvedPath) {
    if (err) return cb(err);

    const relativePath = path.relative(tmpDir, resolvedPath);

    if (!resolvedPath.startsWith(tmpDir)) {
      return cb(new Error(`${option} option must be relative to "${tmpDir}", found "${relativePath}".`));
    }

    cb(null, relativePath);
  });
}

/**
 * Gets the relative path to tmpDir.
 *
 * @private
 */
function _getRelativePathSync(option, name, tmpDir) {
  if (_isUndefined(name)) return;

  const resolvedPath = _resolvePathSync(name, tmpDir);
  const relativePath = path.relative(tmpDir, resolvedPath);

  if (!resolvedPath.startsWith(tmpDir)) {
    throw new Error(`${option} option must be relative to "${tmpDir}", found "${relativePath}".`);
  }

  return relativePath;
}

/**
 * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
 * options.
 *
 * @private
 */
function _assertAndSanitizeOptions(options, cb) {
  _getTmpDir(options, function (err, tmpDir) {
    if (err) return cb(err);

    options.tmpdir = tmpDir;

    try {
      _assertOptionsBase(options, tmpDir);
    } catch (err) {
      return cb(err);
    }

    // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to
    _getRelativePath('dir', options.dir, tmpDir, function (err, dir) {
      if (err) return cb(err);

      options.dir = _isUndefined(dir) ? '' : dir;

      // sanitize further if template is relative to options.dir
      _getRelativePath('template', options.template, tmpDir, function (err, template) {
        if (err) return cb(err);

        options.template = template;

        cb(null, options);
      });
    });
  });
}

/**
 * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
 * options.
 *
 * @private
 */
function _assertAndSanitizeOptionsSync(options) {
  const tmpDir = (options.tmpdir = _getTmpDirSync(options));

  _assertOptionsBase(options, tmpDir);

  const dir = _getRelativePathSync('dir', options.dir, tmpDir);
  options.dir = _isUndefined(dir) ? '' : dir;

  options.template = _getRelativePathSync('template', options.template, tmpDir);

  return options;
}

/**
 * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
function _isEBADF(error) {
  return _isExpectedError(error, -EBADF, 'EBADF');
}

/**
 * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
function _isENOENT(error) {
  return _isExpectedError(error, -ENOENT, 'ENOENT');
}

/**
 * Helper to determine whether the expected error code matches the actual code and errno,
 * which will differ between the supported node versions.
 *
 * - Node >= 7.0:
 *   error.code {string}
 *   error.errno {number} any numerical value will be negated
 *
 * CAVEAT
 *
 * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT
 * is no different here.
 *
 * @param {SystemError} error
 * @param {number} errno
 * @param {string} code
 * @private
 */
function _isExpectedError(error, errno, code) {
  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;
}

/**
 * Sets the graceful cleanup.
 *
 * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the
 * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary
 * object removals.
 */
function setGracefulCleanup() {
  _gracefulCleanup = true;
}

/**
 * Returns the currently configured tmp dir from os.tmpdir().
 *
 * @private
 */
function _getTmpDir(options, cb) {
  return fs.realpath((options && options.tmpdir) || os.tmpdir(), cb);
}

/**
 * Returns the currently configured tmp dir from os.tmpdir().
 *
 * @private
 */
function _getTmpDirSync(options) {
  return fs.realpathSync((options && options.tmpdir) || os.tmpdir());
}

// Install process exit listener
process.addListener(EXIT, _garbageCollector);

/**
 * Configuration options.
 *
 * @typedef {Object} Options
 * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected
 * @property {?number} tries the number of tries before give up the name generation
 * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files
 * @property {?string} template the "mkstemp" like filename template
 * @property {?string} name fixed name relative to tmpdir or the specified dir option
 * @property {?string} dir tmp directory relative to the root tmp directory in use
 * @property {?string} prefix prefix for the generated name
 * @property {?string} postfix postfix for the generated name
 * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir
 * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty
 * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection
 * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection
 */

/**
 * @typedef {Object} FileSyncObject
 * @property {string} name the name of the file
 * @property {string} fd the file descriptor or -1 if the fd has been discarded
 * @property {fileCallback} removeCallback the callback function to remove the file
 */

/**
 * @typedef {Object} DirSyncObject
 * @property {string} name the name of the directory
 * @property {fileCallback} removeCallback the callback function to remove the directory
 */

/**
 * @callback tmpNameCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 */

/**
 * @callback fileCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback fileCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * @callback dirCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback dirCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallback
 * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallbackSync
 */

/**
 * Callback function for function composition.
 * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
 *
 * @callback simpleCallback
 */

// exporting all the needed methods

// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will
// allow users to reconfigure the temporary directory
Object.defineProperty(module.exports, "tmpdir", ({
  enumerable: true,
  configurable: false,
  get: function () {
    return _getTmpDirSync();
  }
}));

module.exports.dir = dir;
module.exports.dirSync = dirSync;

module.exports.file = file;
module.exports.fileSync = fileSync;

module.exports.tmpName = tmpName;
module.exports.tmpNameSync = tmpNameSync;

module.exports.setGracefulCleanup = setGracefulCleanup;


/***/ }),

/***/ "./node_modules/trough/lib/index.js":
/*!******************************************!*\
  !*** ./node_modules/trough/lib/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   trough: () => (/* binding */ trough),
/* harmony export */   wrap: () => (/* binding */ wrap)
/* harmony export */ });
// To do: remove `void`s
// To do: remove `null` from output of our APIs, allow it as user APIs.

/**
 * @typedef {(error?: Error | null | undefined, ...output: Array<any>) => void} Callback
 *   Callback.
 *
 * @typedef {(...input: Array<any>) => any} Middleware
 *   Ware.
 *
 * @typedef Pipeline
 *   Pipeline.
 * @property {Run} run
 *   Run the pipeline.
 * @property {Use} use
 *   Add middleware.
 *
 * @typedef {(...input: Array<any>) => void} Run
 *   Call all middleware.
 *
 *   Calls `done` on completion with either an error or the output of the
 *   last middleware.
 *
 *   > 👉 **Note**: as the length of input defines whether async functions get a
 *   > `next` function,
 *   > it’s recommended to keep `input` at one value normally.

 *
 * @typedef {(fn: Middleware) => Pipeline} Use
 *   Add middleware.
 */

/**
 * Create new middleware.
 *
 * @returns {Pipeline}
 *   Pipeline.
 */
function trough() {
  /** @type {Array<Middleware>} */
  const fns = []
  /** @type {Pipeline} */
  const pipeline = {run, use}

  return pipeline

  /** @type {Run} */
  function run(...values) {
    let middlewareIndex = -1
    /** @type {Callback} */
    const callback = values.pop()

    if (typeof callback !== 'function') {
      throw new TypeError('Expected function as last argument, not ' + callback)
    }

    next(null, ...values)

    /**
     * Run the next `fn`, or we’re done.
     *
     * @param {Error | null | undefined} error
     * @param {Array<any>} output
     */
    function next(error, ...output) {
      const fn = fns[++middlewareIndex]
      let index = -1

      if (error) {
        callback(error)
        return
      }

      // Copy non-nullish input into values.
      while (++index < values.length) {
        if (output[index] === null || output[index] === undefined) {
          output[index] = values[index]
        }
      }

      // Save the newly created `output` for the next call.
      values = output

      // Next or done.
      if (fn) {
        wrap(fn, next)(...output)
      } else {
        callback(null, ...output)
      }
    }
  }

  /** @type {Use} */
  function use(middelware) {
    if (typeof middelware !== 'function') {
      throw new TypeError(
        'Expected `middelware` to be a function, not ' + middelware
      )
    }

    fns.push(middelware)
    return pipeline
  }
}

/**
 * Wrap `middleware` into a uniform interface.
 *
 * You can pass all input to the resulting function.
 * `callback` is then called with the output of `middleware`.
 *
 * If `middleware` accepts more arguments than the later given in input,
 * an extra `done` function is passed to it after that input,
 * which must be called by `middleware`.
 *
 * The first value in `input` is the main input value.
 * All other input values are the rest input values.
 * The values given to `callback` are the input values,
 * merged with every non-nullish output value.
 *
 * * if `middleware` throws an error,
 *   returns a promise that is rejected,
 *   or calls the given `done` function with an error,
 *   `callback` is called with that error
 * * if `middleware` returns a value or returns a promise that is resolved,
 *   that value is the main output value
 * * if `middleware` calls `done`,
 *   all non-nullish values except for the first one (the error) overwrite the
 *   output values
 *
 * @param {Middleware} middleware
 *   Function to wrap.
 * @param {Callback} callback
 *   Callback called with the output of `middleware`.
 * @returns {Run}
 *   Wrapped middleware.
 */
function wrap(middleware, callback) {
  /** @type {boolean} */
  let called

  return wrapped

  /**
   * Call `middleware`.
   * @this {any}
   * @param {Array<any>} parameters
   * @returns {void}
   */
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length
    /** @type {any} */
    let result

    if (fnExpectsCallback) {
      parameters.push(done)
    }

    try {
      result = middleware.apply(this, parameters)
    } catch (error) {
      const exception = /** @type {Error} */ (error)

      // Well, this is quite the pickle.
      // `middleware` received a callback and called it synchronously, but that
      // threw an error.
      // The only thing left to do is to throw the thing instead.
      if (fnExpectsCallback && called) {
        throw exception
      }

      return done(exception)
    }

    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === 'function') {
        result.then(then, done)
      } else if (result instanceof Error) {
        done(result)
      } else {
        then(result)
      }
    }
  }

  /**
   * Call `callback`, only once.
   *
   * @type {Callback}
   */
  function done(error, ...output) {
    if (!called) {
      called = true
      callback(error, ...output)
    }
  }

  /**
   * Call `done` with one value.
   *
   * @param {any} [value]
   */
  function then(value) {
    done(null, value)
  }
}


/***/ }),

/***/ "./node_modules/unified/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/unified/lib/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   unified: () => (/* binding */ unified)
/* harmony export */ });
/* harmony import */ var bail__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bail */ "./node_modules/bail/index.js");
/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-buffer */ "./node_modules/is-buffer/index.js");
/* harmony import */ var extend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! extend */ "./node_modules/extend/index.js");
/* harmony import */ var is_plain_obj__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! is-plain-obj */ "./node_modules/is-plain-obj/index.js");
/* harmony import */ var trough__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! trough */ "./node_modules/trough/lib/index.js");
/* harmony import */ var vfile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vfile */ "./node_modules/vfile/lib/index.js");
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('vfile').VFileCompatible} VFileCompatible
 * @typedef {import('vfile').VFileValue} VFileValue
 * @typedef {import('..').Processor} Processor
 * @typedef {import('..').Plugin} Plugin
 * @typedef {import('..').Preset} Preset
 * @typedef {import('..').Pluggable} Pluggable
 * @typedef {import('..').PluggableList} PluggableList
 * @typedef {import('..').Transformer} Transformer
 * @typedef {import('..').Parser} Parser
 * @typedef {import('..').Compiler} Compiler
 * @typedef {import('..').RunCallback} RunCallback
 * @typedef {import('..').ProcessCallback} ProcessCallback
 *
 * @typedef Context
 * @property {Node} tree
 * @property {VFile} file
 */








// Expose a frozen processor.
const unified = base().freeze()

const own = {}.hasOwnProperty

// Function to create the first processor.
/**
 * @returns {Processor}
 */
function base() {
  const transformers = (0,trough__WEBPACK_IMPORTED_MODULE_4__.trough)()
  /** @type {Processor['attachers']} */
  const attachers = []
  /** @type {Record<string, unknown>} */
  let namespace = {}
  /** @type {boolean|undefined} */
  let frozen
  let freezeIndex = -1

  // Data management.
  // @ts-expect-error: overloads are handled.
  processor.data = data
  processor.Parser = undefined
  processor.Compiler = undefined

  // Lock.
  processor.freeze = freeze

  // Plugins.
  processor.attachers = attachers
  // @ts-expect-error: overloads are handled.
  processor.use = use

  // API.
  processor.parse = parse
  processor.stringify = stringify
  // @ts-expect-error: overloads are handled.
  processor.run = run
  processor.runSync = runSync
  // @ts-expect-error: overloads are handled.
  processor.process = process
  processor.processSync = processSync

  // Expose.
  return processor

  // Create a new processor based on the processor in the current scope.
  /** @type {Processor} */
  function processor() {
    const destination = base()
    let index = -1

    while (++index < attachers.length) {
      destination.use(...attachers[index])
    }

    destination.data(extend__WEBPACK_IMPORTED_MODULE_2__(true, {}, namespace))

    return destination
  }

  /**
   * @param {string|Record<string, unknown>} [key]
   * @param {unknown} [value]
   * @returns {unknown}
   */
  function data(key, value) {
    if (typeof key === 'string') {
      // Set `key`.
      if (arguments.length === 2) {
        assertUnfrozen('data', frozen)
        namespace[key] = value
        return processor
      }

      // Get `key`.
      return (own.call(namespace, key) && namespace[key]) || null
    }

    // Set space.
    if (key) {
      assertUnfrozen('data', frozen)
      namespace = key
      return processor
    }

    // Get space.
    return namespace
  }

  /** @type {Processor['freeze']} */
  function freeze() {
    if (frozen) {
      return processor
    }

    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex]

      if (options[0] === false) {
        continue
      }

      if (options[0] === true) {
        options[0] = undefined
      }

      /** @type {Transformer|void} */
      const transformer = attacher.call(processor, ...options)

      if (typeof transformer === 'function') {
        transformers.use(transformer)
      }
    }

    frozen = true
    freezeIndex = Number.POSITIVE_INFINITY

    return processor
  }

  /**
   * @param {Pluggable|null|undefined} [value]
   * @param {...unknown} options
   * @returns {Processor}
   */
  function use(value, ...options) {
    /** @type {Record<string, unknown>|undefined} */
    let settings

    assertUnfrozen('use', frozen)

    if (value === null || value === undefined) {
      // Empty.
    } else if (typeof value === 'function') {
      addPlugin(value, ...options)
    } else if (typeof value === 'object') {
      if (Array.isArray(value)) {
        addList(value)
      } else {
        addPreset(value)
      }
    } else {
      throw new TypeError('Expected usable value, not `' + value + '`')
    }

    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings)
    }

    return processor

    /**
     * @param {import('..').Pluggable<unknown[]>} value
     * @returns {void}
     */
    function add(value) {
      if (typeof value === 'function') {
        addPlugin(value)
      } else if (typeof value === 'object') {
        if (Array.isArray(value)) {
          const [plugin, ...options] = value
          addPlugin(plugin, ...options)
        } else {
          addPreset(value)
        }
      } else {
        throw new TypeError('Expected usable value, not `' + value + '`')
      }
    }

    /**
     * @param {Preset} result
     * @returns {void}
     */
    function addPreset(result) {
      addList(result.plugins)

      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings)
      }
    }

    /**
     * @param {PluggableList|null|undefined} [plugins]
     * @returns {void}
     */
    function addList(plugins) {
      let index = -1

      if (plugins === null || plugins === undefined) {
        // Empty.
      } else if (Array.isArray(plugins)) {
        while (++index < plugins.length) {
          const thing = plugins[index]
          add(thing)
        }
      } else {
        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')
      }
    }

    /**
     * @param {Plugin} plugin
     * @param {...unknown} [value]
     * @returns {void}
     */
    function addPlugin(plugin, value) {
      let index = -1
      /** @type {Processor['attachers'][number]|undefined} */
      let entry

      while (++index < attachers.length) {
        if (attachers[index][0] === plugin) {
          entry = attachers[index]
          break
        }
      }

      if (entry) {
        if ((0,is_plain_obj__WEBPACK_IMPORTED_MODULE_3__["default"])(entry[1]) && (0,is_plain_obj__WEBPACK_IMPORTED_MODULE_3__["default"])(value)) {
          value = extend__WEBPACK_IMPORTED_MODULE_2__(true, entry[1], value)
        }

        entry[1] = value
      } else {
        // @ts-expect-error: fine.
        attachers.push([...arguments])
      }
    }
  }

  /** @type {Processor['parse']} */
  function parse(doc) {
    processor.freeze()
    const file = vfile(doc)
    const Parser = processor.Parser
    assertParser('parse', Parser)

    if (newable(Parser, 'parse')) {
      // @ts-expect-error: `newable` checks this.
      return new Parser(String(file), file).parse()
    }

    // @ts-expect-error: `newable` checks this.
    return Parser(String(file), file) // eslint-disable-line new-cap
  }

  /** @type {Processor['stringify']} */
  function stringify(node, doc) {
    processor.freeze()
    const file = vfile(doc)
    const Compiler = processor.Compiler
    assertCompiler('stringify', Compiler)
    assertNode(node)

    if (newable(Compiler, 'compile')) {
      // @ts-expect-error: `newable` checks this.
      return new Compiler(node, file).compile()
    }

    // @ts-expect-error: `newable` checks this.
    return Compiler(node, file) // eslint-disable-line new-cap
  }

  /**
   * @param {Node} node
   * @param {VFileCompatible|RunCallback} [doc]
   * @param {RunCallback} [callback]
   * @returns {Promise<Node>|void}
   */
  function run(node, doc, callback) {
    assertNode(node)
    processor.freeze()

    if (!callback && typeof doc === 'function') {
      callback = doc
      doc = undefined
    }

    if (!callback) {
      return new Promise(executor)
    }

    executor(null, callback)

    /**
     * @param {null|((node: Node) => void)} resolve
     * @param {(error: Error) => void} reject
     * @returns {void}
     */
    function executor(resolve, reject) {
      // @ts-expect-error: `doc` can’t be a callback anymore, we checked.
      transformers.run(node, vfile(doc), done)

      /**
       * @param {Error|null} error
       * @param {Node} tree
       * @param {VFile} file
       * @returns {void}
       */
      function done(error, tree, file) {
        tree = tree || node
        if (error) {
          reject(error)
        } else if (resolve) {
          resolve(tree)
        } else {
          // @ts-expect-error: `callback` is defined if `resolve` is not.
          callback(null, tree, file)
        }
      }
    }
  }

  /** @type {Processor['runSync']} */
  function runSync(node, file) {
    /** @type {Node|undefined} */
    let result
    /** @type {boolean|undefined} */
    let complete

    processor.run(node, file, done)

    assertDone('runSync', 'run', complete)

    // @ts-expect-error: we either bailed on an error or have a tree.
    return result

    /**
     * @param {Error|null} [error]
     * @param {Node} [tree]
     * @returns {void}
     */
    function done(error, tree) {
      ;(0,bail__WEBPACK_IMPORTED_MODULE_0__.bail)(error)
      result = tree
      complete = true
    }
  }

  /**
   * @param {VFileCompatible} doc
   * @param {ProcessCallback} [callback]
   * @returns {Promise<VFile>|undefined}
   */
  function process(doc, callback) {
    processor.freeze()
    assertParser('process', processor.Parser)
    assertCompiler('process', processor.Compiler)

    if (!callback) {
      return new Promise(executor)
    }

    executor(null, callback)

    /**
     * @param {null|((file: VFile) => void)} resolve
     * @param {(error?: Error|null|undefined) => void} reject
     * @returns {void}
     */
    function executor(resolve, reject) {
      const file = vfile(doc)

      processor.run(processor.parse(file), file, (error, tree, file) => {
        if (error || !tree || !file) {
          done(error)
        } else {
          /** @type {unknown} */
          const result = processor.stringify(tree, file)

          if (result === undefined || result === null) {
            // Empty.
          } else if (looksLikeAVFileValue(result)) {
            file.value = result
          } else {
            file.result = result
          }

          done(error, file)
        }
      })

      /**
       * @param {Error|null|undefined} [error]
       * @param {VFile|undefined} [file]
       * @returns {void}
       */
      function done(error, file) {
        if (error || !file) {
          reject(error)
        } else if (resolve) {
          resolve(file)
        } else {
          // @ts-expect-error: `callback` is defined if `resolve` is not.
          callback(null, file)
        }
      }
    }
  }

  /** @type {Processor['processSync']} */
  function processSync(doc) {
    /** @type {boolean|undefined} */
    let complete

    processor.freeze()
    assertParser('processSync', processor.Parser)
    assertCompiler('processSync', processor.Compiler)

    const file = vfile(doc)

    processor.process(file, done)

    assertDone('processSync', 'process', complete)

    return file

    /**
     * @param {Error|null|undefined} [error]
     * @returns {void}
     */
    function done(error) {
      complete = true
      ;(0,bail__WEBPACK_IMPORTED_MODULE_0__.bail)(error)
    }
  }
}

/**
 * Check if `value` is a constructor.
 *
 * @param {unknown} value
 * @param {string} name
 * @returns {boolean}
 */
function newable(value, name) {
  return (
    typeof value === 'function' &&
    // Prototypes do exist.
    // type-coverage:ignore-next-line
    value.prototype &&
    // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    // type-coverage:ignore-next-line
    (keys(value.prototype) || name in value.prototype)
  )
}

/**
 * Check if `value` is an object with keys.
 *
 * @param {Record<string, unknown>} value
 * @returns {boolean}
 */
function keys(value) {
  /** @type {string} */
  let key

  for (key in value) {
    if (own.call(value, key)) {
      return true
    }
  }

  return false
}

/**
 * Assert a parser is available.
 *
 * @param {string} name
 * @param {unknown} value
 * @returns {asserts value is Parser}
 */
function assertParser(name, value) {
  if (typeof value !== 'function') {
    throw new TypeError('Cannot `' + name + '` without `Parser`')
  }
}

/**
 * Assert a compiler is available.
 *
 * @param {string} name
 * @param {unknown} value
 * @returns {asserts value is Compiler}
 */
function assertCompiler(name, value) {
  if (typeof value !== 'function') {
    throw new TypeError('Cannot `' + name + '` without `Compiler`')
  }
}

/**
 * Assert the processor is not frozen.
 *
 * @param {string} name
 * @param {unknown} frozen
 * @returns {asserts frozen is false}
 */
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      'Cannot call `' +
        name +
        '` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'
    )
  }
}

/**
 * Assert `node` is a unist node.
 *
 * @param {unknown} node
 * @returns {asserts node is Node}
 */
function assertNode(node) {
  // `isPlainObj` unfortunately uses `any` instead of `unknown`.
  // type-coverage:ignore-next-line
  if (!(0,is_plain_obj__WEBPACK_IMPORTED_MODULE_3__["default"])(node) || typeof node.type !== 'string') {
    throw new TypeError('Expected node, got `' + node + '`')
    // Fine.
  }
}

/**
 * Assert that `complete` is `true`.
 *
 * @param {string} name
 * @param {string} asyncName
 * @param {unknown} complete
 * @returns {asserts complete is true}
 */
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      '`' + name + '` finished async. Use `' + asyncName + '` instead'
    )
  }
}

/**
 * @param {VFileCompatible} [value]
 * @returns {VFile}
 */
function vfile(value) {
  return looksLikeAVFile(value) ? value : new vfile__WEBPACK_IMPORTED_MODULE_5__.VFile(value)
}

/**
 * @param {VFileCompatible} [value]
 * @returns {value is VFile}
 */
function looksLikeAVFile(value) {
  return Boolean(
    value &&
      typeof value === 'object' &&
      'message' in value &&
      'messages' in value
  )
}

/**
 * @param {unknown} [value]
 * @returns {value is VFileValue}
 */
function looksLikeAVFileValue(value) {
  return typeof value === 'string' || is_buffer__WEBPACK_IMPORTED_MODULE_1__(value)
}


/***/ }),

/***/ "./node_modules/unist-builder/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/unist-builder/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ u)
/* harmony export */ });
/**
 * @typedef {import('unist').Node} Node
 */

/**
 * @typedef {Array<Node> | string} ChildrenOrValue
 *   List to use as `children` or value to use as `value`.
 *
 * @typedef {Record<string, unknown>} Props
 *   Other fields to add to the node.
 */

/**
 * Build a node.
 *
 * @param type
 *   Node type.
 * @param props
 *   Fields assigned to node.
 * @param value
 *   Children of node or value of `node` (cast to string).
 * @returns
 *   Built node.
 */
const u =
  /**
   * @type {(
   *   (<T extends string>(type: T) => {type: T}) &
   *   (<T extends string, P extends Props>(type: T, props: P) => {type: T} & P) &
   *   (<T extends string>(type: T, value: string) => {type: T, value: string}) &
   *   (<T extends string, P extends Props>(type: T, props: P, value: string) => {type: T, value: string} & P) &
   *   (<T extends string, C extends Array<Node>>(type: T, children: C) => {type: T, children: C}) &
   *   (<T extends string, P extends Props, C extends Array<Node>>(type: T, props: P, children: C) => {type: T, children: C} & P)
   * )}
   */
  (
    /**
     * @param {string} type
     * @param {Props | ChildrenOrValue | null | undefined} [props]
     * @param {ChildrenOrValue | null | undefined} [value]
     * @returns {Node}
     */
    function (type, props, value) {
      /** @type {Node} */
      const node = {type: String(type)}

      if (
        (value === undefined || value === null) &&
        (typeof props === 'string' || Array.isArray(props))
      ) {
        value = props
      } else {
        Object.assign(node, props)
      }

      if (Array.isArray(value)) {
        // @ts-expect-error: create a parent.
        node.children = value
      } else if (value !== undefined && value !== null) {
        // @ts-expect-error: create a literal.
        node.value = String(value)
      }

      return node
    }
  )


/***/ }),

/***/ "./node_modules/unist-util-generated/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/unist-util-generated/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generated: () => (/* binding */ generated)
/* harmony export */ });
/**
 * @typedef PointLike
 * @property {number | null | undefined} [line]
 * @property {number | null | undefined} [column]
 * @property {number | null | undefined} [offset]
 *
 * @typedef PositionLike
 * @property {PointLike | null | undefined} [start]
 * @property {PointLike | null | undefined} [end]
 *
 * @typedef NodeLike
 * @property {PositionLike | null | undefined} [position]
 */

/**
 * Check if `node` is generated.
 *
 * @param {NodeLike | null | undefined} [node]
 *   Node to check.
 * @returns {boolean}
 *   Whether `node` is generated (does not have positional info).
 */
function generated(node) {
  return (
    !node ||
    !node.position ||
    !node.position.start ||
    !node.position.start.line ||
    !node.position.start.column ||
    !node.position.end ||
    !node.position.end.line ||
    !node.position.end.column
  )
}


/***/ }),

/***/ "./node_modules/unist-util-is/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/unist-util-is/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convert: () => (/* binding */ convert),
/* harmony export */   is: () => (/* binding */ is)
/* harmony export */ });
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 */

/**
 * @typedef {Record<string, unknown>} Props
 * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test
 *   Check for an arbitrary node, unaware of TypeScript inferral.
 *
 * @callback TestFunctionAnything
 *   Check if a node passes a test, unaware of TypeScript inferral.
 * @param {unknown} this
 *   The given context.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean | void}
 *   Whether this node passes the test.
 */

/**
 * @template {Node} Kind
 *   Node type.
 * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest
 *   Check for a node that can be inferred by TypeScript.
 */

/**
 * Check if a node passes a certain test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback TestFunctionPredicate
 *   Complex test function for a node that can be inferred by TypeScript.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this node passes the test.
 */

/**
 * @callback AssertAnything
 *   Check that an arbitrary value is a node, unaware of TypeScript inferral.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean}
 *   Whether this is a node and passes a test.
 */

/**
 * Check if a node is a node and passes a certain node test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback AssertPredicate
 *   Check that an arbitrary value is a specific node, aware of TypeScript.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this is a node and passes a test.
 */

/**
 * Check if `node` is a `Node` and whether it passes the given test.
 *
 * @param node
 *   Thing to check, typically `Node`.
 * @param test
 *   A check for a specific node.
 * @param index
 *   The node’s position in its parent.
 * @param parent
 *   The node’s parent.
 * @returns
 *   Whether `node` is a node and passes a test.
 */
const is =
  /**
   * @type {(
   *   (() => false) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &
   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &
   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)
   * )}
   */
  (
    /**
     * @param {unknown} [node]
     * @param {Test} [test]
     * @param {number | null | undefined} [index]
     * @param {Parent | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */
    // eslint-disable-next-line max-params
    function is(node, test, index, parent, context) {
      const check = convert(test)

      if (
        index !== undefined &&
        index !== null &&
        (typeof index !== 'number' ||
          index < 0 ||
          index === Number.POSITIVE_INFINITY)
      ) {
        throw new Error('Expected positive finite index')
      }

      if (
        parent !== undefined &&
        parent !== null &&
        (!is(parent) || !parent.children)
      ) {
        throw new Error('Expected parent node')
      }

      if (
        (parent === undefined || parent === null) !==
        (index === undefined || index === null)
      ) {
        throw new Error('Expected both parent and index')
      }

      // @ts-expect-error Looks like a node.
      return node && node.type && typeof node.type === 'string'
        ? Boolean(check.call(context, node, index, parent))
        : false
    }
  )

/**
 * Generate an assertion from a test.
 *
 * Useful if you’re going to test many nodes, for example when creating a
 * utility where something else passes a compatible test.
 *
 * The created function is a bit faster because it expects valid input only:
 * a `node`, `index`, and `parent`.
 *
 * @param test
 *   *   when nullish, checks if `node` is a `Node`.
 *   *   when `string`, works like passing `(node) => node.type === test`.
 *   *   when `function` checks if function passed the node is true.
 *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
 *   *   when `array`, checks if any one of the subtests pass.
 * @returns
 *   An assertion.
 */
const convert =
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  (
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    function (test) {
      if (test === undefined || test === null) {
        return ok
      }

      if (typeof test === 'string') {
        return typeFactory(test)
      }

      if (typeof test === 'object') {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
      }

      if (typeof test === 'function') {
        return castFactory(test)
      }

      throw new Error('Expected function, string, or object as test')
    }
  )

/**
 * @param {Array<string | Props | TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */
function anyFactory(tests) {
  /** @type {Array<AssertAnything>} */
  const checks = []
  let index = -1

  while (++index < tests.length) {
    checks[index] = convert(tests[index])
  }

  return castFactory(any)

  /**
   * @this {unknown}
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function any(...parameters) {
    let index = -1

    while (++index < checks.length) {
      if (checks[index].call(this, ...parameters)) return true
    }

    return false
  }
}

/**
 * Turn an object into a test for a node with a certain fields.
 *
 * @param {Props} check
 * @returns {AssertAnything}
 */
function propsFactory(check) {
  return castFactory(all)

  /**
   * @param {Node} node
   * @returns {boolean}
   */
  function all(node) {
    /** @type {string} */
    let key

    for (key in check) {
      // @ts-expect-error: hush, it sure works as an index.
      if (node[key] !== check[key]) return false
    }

    return true
  }
}

/**
 * Turn a string into a test for a node with a certain type.
 *
 * @param {string} check
 * @returns {AssertAnything}
 */
function typeFactory(check) {
  return castFactory(type)

  /**
   * @param {Node} node
   */
  function type(node) {
    return node && node.type === check
  }
}

/**
 * Turn a custom test into a test for a node that passes that test.
 *
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */
function castFactory(check) {
  return assertion

  /**
   * @this {unknown}
   * @param {unknown} node
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function assertion(node, ...parameters) {
    return Boolean(
      node &&
        typeof node === 'object' &&
        'type' in node &&
        // @ts-expect-error: fine.
        Boolean(check.call(this, node, ...parameters))
    )
  }
}

function ok() {
  return true
}


/***/ }),

/***/ "./node_modules/unist-util-position/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/unist-util-position/lib/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pointEnd: () => (/* binding */ pointEnd),
/* harmony export */   pointStart: () => (/* binding */ pointStart),
/* harmony export */   position: () => (/* binding */ position)
/* harmony export */ });
/**
 * @typedef {import('unist').Position} Position
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Point} Point
 */

/**
 * @typedef NodeLike
 * @property {string} type
 * @property {PositionLike | null | undefined} [position]
 *
 * @typedef PositionLike
 * @property {PointLike | null | undefined} [start]
 * @property {PointLike | null | undefined} [end]
 *
 * @typedef PointLike
 * @property {number | null | undefined} [line]
 * @property {number | null | undefined} [column]
 * @property {number | null | undefined} [offset]
 */

/**
 * Get the starting point of `node`.
 *
 * @param node
 *   Node.
 * @returns
 *   Point.
 */
const pointStart = point('start')

/**
 * Get the ending point of `node`.
 *
 * @param node
 *   Node.
 * @returns
 *   Point.
 */
const pointEnd = point('end')

/**
 * Get the positional info of `node`.
 *
 * @param {NodeLike | Node | null | undefined} [node]
 *   Node.
 * @returns {Position}
 *   Position.
 */
function position(node) {
  return {start: pointStart(node), end: pointEnd(node)}
}

/**
 * Get the positional info of `node`.
 *
 * @param {'start' | 'end'} type
 *   Side.
 * @returns
 *   Getter.
 */
function point(type) {
  return point

  /**
   * Get the point info of `node` at a bound side.
   *
   * @param {NodeLike | Node | null | undefined} [node]
   * @returns {Point}
   */
  function point(node) {
    const point = (node && node.position && node.position[type]) || {}

    // To do: next major: don’t return points when invalid.
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: point.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: point.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: point.offset > -1 ? point.offset : null
    }
  }
}


/***/ }),

/***/ "./node_modules/unist-util-stringify-position/lib/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/unist-util-stringify-position/lib/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   stringifyPosition: () => (/* binding */ stringifyPosition)
/* harmony export */ });
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Point} Point
 * @typedef {import('unist').Position} Position
 */

/**
 * @typedef NodeLike
 * @property {string} type
 * @property {PositionLike | null | undefined} [position]
 *
 * @typedef PositionLike
 * @property {PointLike | null | undefined} [start]
 * @property {PointLike | null | undefined} [end]
 *
 * @typedef PointLike
 * @property {number | null | undefined} [line]
 * @property {number | null | undefined} [column]
 * @property {number | null | undefined} [offset]
 */

/**
 * Serialize the positional info of a point, position (start and end points),
 * or node.
 *
 * @param {Node | NodeLike | Position | PositionLike | Point | PointLike | null | undefined} [value]
 *   Node, position, or point.
 * @returns {string}
 *   Pretty printed positional info of a node (`string`).
 *
 *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)
 *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for
 *   column, `s` for `start`, and `e` for end.
 *   An empty string (`''`) is returned if the given value is neither `node`,
 *   `position`, nor `point`.
 */
function stringifyPosition(value) {
  // Nothing.
  if (!value || typeof value !== 'object') {
    return ''
  }

  // Node.
  if ('position' in value || 'type' in value) {
    return position(value.position)
  }

  // Position.
  if ('start' in value || 'end' in value) {
    return position(value)
  }

  // Point.
  if ('line' in value || 'column' in value) {
    return point(value)
  }

  // ?
  return ''
}

/**
 * @param {Point | PointLike | null | undefined} point
 * @returns {string}
 */
function point(point) {
  return index(point && point.line) + ':' + index(point && point.column)
}

/**
 * @param {Position | PositionLike | null | undefined} pos
 * @returns {string}
 */
function position(pos) {
  return point(pos && pos.start) + '-' + point(pos && pos.end)
}

/**
 * @param {number | null | undefined} value
 * @returns {number}
 */
function index(value) {
  return value && typeof value === 'number' ? value : 1
}


/***/ }),

/***/ "./node_modules/unist-util-visit-parents/lib/color.browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/unist-util-visit-parents/lib/color.browser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   color: () => (/* binding */ color)
/* harmony export */ });
/**
 * @param {string} d
 * @returns {string}
 */
function color(d) {
  return d
}


/***/ }),

/***/ "./node_modules/unist-util-visit-parents/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/unist-util-visit-parents/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CONTINUE: () => (/* binding */ CONTINUE),
/* harmony export */   EXIT: () => (/* binding */ EXIT),
/* harmony export */   SKIP: () => (/* binding */ SKIP),
/* harmony export */   visitParents: () => (/* binding */ visitParents)
/* harmony export */ });
/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-is */ "./node_modules/unist-util-is/lib/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/unist-util-visit-parents/lib/color.browser.js");
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 */

/**
 * @typedef {boolean | 'skip'} Action
 *   Union of the action types.
 *
 * @typedef {number} Index
 *   Move to the sibling at `index` next (after node itself is completely
 *   traversed).
 *
 *   Useful if mutating the tree, such as removing the node the visitor is
 *   currently on, or any of its previous siblings.
 *   Results less than 0 or greater than or equal to `children.length` stop
 *   traversing the parent.
 *
 * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple
 *   List with one or two values, the first an action, the second an index.
 *
 * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult
 *   Any value that can be returned from a visitor.
 */

/**
 * @template {Node} [Visited=Node]
 *   Visited node type.
 * @template {Parent} [Ancestor=Parent]
 *   Ancestor type.
 * @callback Visitor
 *   Handle a node (matching `test`, if given).
 *
 *   Visitors are free to transform `node`.
 *   They can also transform the parent of node (the last of `ancestors`).
 *
 *   Replacing `node` itself, if `SKIP` is not returned, still causes its
 *   descendants to be walked (which is a bug).
 *
 *   When adding or removing previous siblings of `node` (or next siblings, in
 *   case of reverse), the `Visitor` should return a new `Index` to specify the
 *   sibling to traverse after `node` is traversed.
 *   Adding or removing next siblings of `node` (or previous siblings, in case
 *   of reverse) is handled as expected without needing to return a new `Index`.
 *
 *   Removing the children property of an ancestor still results in them being
 *   traversed.
 * @param {Visited} node
 *   Found node.
 * @param {Array<Ancestor>} ancestors
 *   Ancestors of `node`.
 * @returns {VisitorResult}
 *   What to do next.
 *
 *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
 *   An `Action` is treated as a tuple of `[Action]`.
 *
 *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
 *   When the `Action` is `EXIT`, that action can be returned.
 *   When the `Action` is `CONTINUE`, `Index` can be returned.
 */

/**
 * @template {Node} [Tree=Node]
 *   Tree type.
 * @template {Test} [Check=string]
 *   Test type.
 * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor
 *   Build a typed `Visitor` function from a tree and a test.
 *
 *   It will infer which values are passed as `node` and which as `parents`.
 */




/**
 * Continue traversing as normal.
 */
const CONTINUE = true

/**
 * Stop traversing immediately.
 */
const EXIT = false

/**
 * Do not traverse this node’s children.
 */
const SKIP = 'skip'

/**
 * Visit nodes, with ancestral information.
 *
 * This algorithm performs *depth-first* *tree traversal* in *preorder*
 * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
 *
 * You can choose for which nodes `visitor` is called by passing a `test`.
 * For complex tests, you should test yourself in `visitor`, as it will be
 * faster and will have improved type information.
 *
 * Walking the tree is an intensive task.
 * Make use of the return values of the visitor when possible.
 * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
 * to check if a node matches, and then perform different operations.
 *
 * You can change the tree.
 * See `Visitor` for more info.
 *
 * @param tree
 *   Tree to traverse.
 * @param test
 *   `unist-util-is`-compatible test
 * @param visitor
 *   Handle each node.
 * @param reverse
 *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
 * @returns
 *   Nothing.
 */
const visitParents =
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  (
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor<Node>} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */
    function (tree, test, visitor, reverse) {
      if (typeof test === 'function' && typeof visitor !== 'function') {
        reverse = visitor
        // @ts-expect-error no visitor given, so `visitor` is test.
        visitor = test
        test = null
      }

      const is = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_0__.convert)(test)
      const step = reverse ? -1 : 1

      factory(tree, undefined, [])()

      /**
       * @param {Node} node
       * @param {number | undefined} index
       * @param {Array<Parent>} parents
       */
      function factory(node, index, parents) {
        /** @type {Record<string, unknown>} */
        // @ts-expect-error: hush
        const value = node && typeof node === 'object' ? node : {}

        if (typeof value.type === 'string') {
          const name =
            // `hast`
            typeof value.tagName === 'string'
              ? value.tagName
              : // `xast`
              typeof value.name === 'string'
              ? value.name
              : undefined

          Object.defineProperty(visit, 'name', {
            value:
              'node (' + (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.color)(node.type + (name ? '<' + name + '>' : '')) + ')'
          })
        }

        return visit

        function visit() {
          /** @type {ActionTuple} */
          let result = []
          /** @type {ActionTuple} */
          let subresult
          /** @type {number} */
          let offset
          /** @type {Array<Parent>} */
          let grandparents

          if (!test || is(node, index, parents[parents.length - 1] || null)) {
            result = toResult(visitor(node, parents))

            if (result[0] === EXIT) {
              return result
            }
          }

          // @ts-expect-error looks like a parent.
          if (node.children && result[0] !== SKIP) {
            // @ts-expect-error looks like a parent.
            offset = (reverse ? node.children.length : -1) + step
            // @ts-expect-error looks like a parent.
            grandparents = parents.concat(node)

            // @ts-expect-error looks like a parent.
            while (offset > -1 && offset < node.children.length) {
              // @ts-expect-error looks like a parent.
              subresult = factory(node.children[offset], offset, grandparents)()

              if (subresult[0] === EXIT) {
                return subresult
              }

              offset =
                typeof subresult[1] === 'number' ? subresult[1] : offset + step
            }
          }

          return result
        }
      }
    }
  )

/**
 * Turn a return value into a clean result.
 *
 * @param {VisitorResult} value
 *   Valid return values from visitors.
 * @returns {ActionTuple}
 *   Clean result.
 */
function toResult(value) {
  if (Array.isArray(value)) {
    return value
  }

  if (typeof value === 'number') {
    return [CONTINUE, value]
  }

  return [value]
}


/***/ }),

/***/ "./node_modules/unist-util-visit/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/unist-util-visit/lib/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CONTINUE: () => (/* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.CONTINUE),
/* harmony export */   EXIT: () => (/* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.EXIT),
/* harmony export */   SKIP: () => (/* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.SKIP),
/* harmony export */   visit: () => (/* binding */ visit)
/* harmony export */ });
/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit-parents */ "./node_modules/unist-util-visit-parents/lib/index.js");
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
 */

/**
 * Check if `Child` can be a child of `Ancestor`.
 *
 * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns
 * `never`.
 *
 * @template {Node} Ancestor
 *   Node type.
 * @template {Node} Child
 *   Node type.
 * @typedef {(
 *   Ancestor extends Parent
 *     ? Child extends Ancestor['children'][number]
 *       ? Ancestor
 *       : never
 *     : never
 * )} ParentsOf
 */

/**
 * @template {Node} [Visited=Node]
 *   Visited node type.
 * @template {Parent} [Ancestor=Parent]
 *   Ancestor type.
 * @callback Visitor
 *   Handle a node (matching `test`, if given).
 *
 *   Visitors are free to transform `node`.
 *   They can also transform `parent`.
 *
 *   Replacing `node` itself, if `SKIP` is not returned, still causes its
 *   descendants to be walked (which is a bug).
 *
 *   When adding or removing previous siblings of `node` (or next siblings, in
 *   case of reverse), the `Visitor` should return a new `Index` to specify the
 *   sibling to traverse after `node` is traversed.
 *   Adding or removing next siblings of `node` (or previous siblings, in case
 *   of reverse) is handled as expected without needing to return a new `Index`.
 *
 *   Removing the children property of `parent` still results in them being
 *   traversed.
 * @param {Visited} node
 *   Found node.
 * @param {Visited extends Node ? number | null : never} index
 *   Index of `node` in `parent`.
 * @param {Ancestor extends Node ? Ancestor | null : never} parent
 *   Parent of `node`.
 * @returns {VisitorResult}
 *   What to do next.
 *
 *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
 *   An `Action` is treated as a tuple of `[Action]`.
 *
 *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
 *   When the `Action` is `EXIT`, that action can be returned.
 *   When the `Action` is `CONTINUE`, `Index` can be returned.
 */

/**
 * Build a typed `Visitor` function from a node and all possible parents.
 *
 * It will infer which values are passed as `node` and which as `parent`.
 *
 * @template {Node} Visited
 *   Node type.
 * @template {Parent} Ancestor
 *   Parent type.
 * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch
 */

/**
 * Build a typed `Visitor` function from a list of descendants and a test.
 *
 * It will infer which values are passed as `node` and which as `parent`.
 *
 * @template {Node} Descendant
 *   Node type.
 * @template {Test} Check
 *   Test type.
 * @typedef {(
 *   BuildVisitorFromMatch<
 *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,
 *     Extract<Descendant, Parent>
 *   >
 * )} BuildVisitorFromDescendants
 */

/**
 * Build a typed `Visitor` function from a tree and a test.
 *
 * It will infer which values are passed as `node` and which as `parent`.
 *
 * @template {Node} [Tree=Node]
 *   Node type.
 * @template {Test} [Check=string]
 *   Test type.
 * @typedef {(
 *   BuildVisitorFromDescendants<
 *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,
 *     Check
 *   >
 * )} BuildVisitor
 */



/**
 * Visit nodes.
 *
 * This algorithm performs *depth-first* *tree traversal* in *preorder*
 * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
 *
 * You can choose for which nodes `visitor` is called by passing a `test`.
 * For complex tests, you should test yourself in `visitor`, as it will be
 * faster and will have improved type information.
 *
 * Walking the tree is an intensive task.
 * Make use of the return values of the visitor when possible.
 * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
 * to check if a node matches, and then perform different operations.
 *
 * You can change the tree.
 * See `Visitor` for more info.
 *
 * @param tree
 *   Tree to traverse.
 * @param test
 *   `unist-util-is`-compatible test
 * @param visitor
 *   Handle each node.
 * @param reverse
 *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
 * @returns
 *   Nothing.
 */
const visit =
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  (
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */
    function (tree, test, visitor, reverse) {
      if (typeof test === 'function' && typeof visitor !== 'function') {
        reverse = visitor
        visitor = test
        test = null
      }

      (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.visitParents)(tree, test, overload, reverse)

      /**
       * @param {Node} node
       * @param {Array<Parent>} parents
       */
      function overload(node, parents) {
        const parent = parents[parents.length - 1]
        return visitor(
          node,
          parent ? parent.children.indexOf(node) : null,
          parent
        )
      }
    }
  )




/***/ }),

/***/ "./node_modules/uvu/assert/index.mjs":
/*!*******************************************!*\
  !*** ./node_modules/uvu/assert/index.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Assertion: () => (/* binding */ Assertion),
/* harmony export */   equal: () => (/* binding */ equal),
/* harmony export */   fixture: () => (/* binding */ fixture),
/* harmony export */   instance: () => (/* binding */ instance),
/* harmony export */   is: () => (/* binding */ is),
/* harmony export */   match: () => (/* binding */ match),
/* harmony export */   not: () => (/* binding */ not),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   snapshot: () => (/* binding */ snapshot),
/* harmony export */   throws: () => (/* binding */ throws),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   unreachable: () => (/* binding */ unreachable)
/* harmony export */ });
/* harmony import */ var dequal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dequal */ "./node_modules/dequal/dist/index.mjs");
/* harmony import */ var uvu_diff__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uvu/diff */ "./node_modules/uvu/diff/index.mjs");



function dedent(str) {
	str = str.replace(/\r?\n/g, '\n');
  let arr = str.match(/^[ \t]*(?=\S)/gm);
  let i = 0, min = 1/0, len = (arr||[]).length;
  for (; i < len; i++) min = Math.min(min, arr[i].length);
  return len && min ? str.replace(new RegExp(`^[ \\t]{${min}}`, 'gm'), '') : str;
}

class Assertion extends Error {
	constructor(opts={}) {
		super(opts.message);
		this.name = 'Assertion';
		this.code = 'ERR_ASSERTION';
		if (Error.captureStackTrace) {
			Error.captureStackTrace(this, this.constructor);
		}
		this.details = opts.details || false;
		this.generated = !!opts.generated;
		this.operator = opts.operator;
		this.expects = opts.expects;
		this.actual = opts.actual;
	}
}

function assert(bool, actual, expects, operator, detailer, backup, msg) {
	if (bool) return;
	let message = msg || backup;
	if (msg instanceof Error) throw msg;
	let details = detailer && detailer(actual, expects);
	throw new Assertion({ actual, expects, operator, message, details, generated: !msg });
}

function ok(val, msg) {
	assert(!!val, false, true, 'ok', false, 'Expected value to be truthy', msg);
}

function is(val, exp, msg) {
	assert(val === exp, val, exp, 'is', uvu_diff__WEBPACK_IMPORTED_MODULE_1__.compare, 'Expected values to be strictly equal:', msg);
}

function equal(val, exp, msg) {
	assert((0,dequal__WEBPACK_IMPORTED_MODULE_0__.dequal)(val, exp), val, exp, 'equal', uvu_diff__WEBPACK_IMPORTED_MODULE_1__.compare, 'Expected values to be deeply equal:', msg);
}

function unreachable(msg) {
	assert(false, true, false, 'unreachable', false, 'Expected not to be reached!', msg);
}

function type(val, exp, msg) {
	let tmp = typeof val;
	assert(tmp === exp, tmp, exp, 'type', false, `Expected "${tmp}" to be "${exp}"`, msg);
}

function instance(val, exp, msg) {
	let name = '`' + (exp.name || exp.constructor.name) + '`';
	assert(val instanceof exp, val, exp, 'instance', false, `Expected value to be an instance of ${name}`, msg);
}

function match(val, exp, msg) {
	if (typeof exp === 'string') {
		assert(val.includes(exp), val, exp, 'match', false, `Expected value to include "${exp}" substring`, msg);
	} else {
		assert(exp.test(val), val, exp, 'match', false, `Expected value to match \`${String(exp)}\` pattern`, msg);
	}
}

function snapshot(val, exp, msg) {
	val=dedent(val); exp=dedent(exp);
	assert(val === exp, val, exp, 'snapshot', uvu_diff__WEBPACK_IMPORTED_MODULE_1__.lines, 'Expected value to match snapshot:', msg);
}

const lineNums = (x, y) => (0,uvu_diff__WEBPACK_IMPORTED_MODULE_1__.lines)(x, y, 1);
function fixture(val, exp, msg) {
	val=dedent(val); exp=dedent(exp);
	assert(val === exp, val, exp, 'fixture', lineNums, 'Expected value to match fixture:', msg);
}

function throws(blk, exp, msg) {
	if (!msg && typeof exp === 'string') {
		msg = exp; exp = null;
	}

	try {
		blk();
		assert(false, false, true, 'throws', false, 'Expected function to throw', msg);
	} catch (err) {
		if (err instanceof Assertion) throw err;

		if (typeof exp === 'function') {
			assert(exp(err), false, true, 'throws', false, 'Expected function to throw matching exception', msg);
		} else if (exp instanceof RegExp) {
			assert(exp.test(err.message), false, true, 'throws', false, `Expected function to throw exception matching \`${String(exp)}\` pattern`, msg);
		}
	}
}

// ---

function not(val, msg) {
	assert(!val, true, false, 'not', false, 'Expected value to be falsey', msg);
}

not.ok = not;

is.not = function (val, exp, msg) {
	assert(val !== exp, val, exp, 'is.not', false, 'Expected values not to be strictly equal', msg);
}

not.equal = function (val, exp, msg) {
	assert(!(0,dequal__WEBPACK_IMPORTED_MODULE_0__.dequal)(val, exp), val, exp, 'not.equal', false, 'Expected values not to be deeply equal', msg);
}

not.type = function (val, exp, msg) {
	let tmp = typeof val;
	assert(tmp !== exp, tmp, exp, 'not.type', false, `Expected "${tmp}" not to be "${exp}"`, msg);
}

not.instance = function (val, exp, msg) {
	let name = '`' + (exp.name || exp.constructor.name) + '`';
	assert(!(val instanceof exp), val, exp, 'not.instance', false, `Expected value not to be an instance of ${name}`, msg);
}

not.snapshot = function (val, exp, msg) {
	val=dedent(val); exp=dedent(exp);
	assert(val !== exp, val, exp, 'not.snapshot', false, 'Expected value not to match snapshot', msg);
}

not.fixture = function (val, exp, msg) {
	val=dedent(val); exp=dedent(exp);
	assert(val !== exp, val, exp, 'not.fixture', false, 'Expected value not to match fixture', msg);
}

not.match = function (val, exp, msg) {
	if (typeof exp === 'string') {
		assert(!val.includes(exp), val, exp, 'not.match', false, `Expected value not to include "${exp}" substring`, msg);
	} else {
		assert(!exp.test(val), val, exp, 'not.match', false, `Expected value not to match \`${String(exp)}\` pattern`, msg);
	}
}

not.throws = function (blk, exp, msg) {
	if (!msg && typeof exp === 'string') {
		msg = exp; exp = null;
	}

	try {
		blk();
	} catch (err) {
		if (typeof exp === 'function') {
			assert(!exp(err), true, false, 'not.throws', false, 'Expected function not to throw matching exception', msg);
		} else if (exp instanceof RegExp) {
			assert(!exp.test(err.message), true, false, 'not.throws', false, `Expected function not to throw exception matching \`${String(exp)}\` pattern`, msg);
		} else if (!exp) {
			assert(false, true, false, 'not.throws', false, 'Expected function not to throw', msg);
		}
	}
}


/***/ }),

/***/ "./node_modules/uvu/diff/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/uvu/diff/index.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrays: () => (/* binding */ arrays),
/* harmony export */   chars: () => (/* binding */ chars),
/* harmony export */   circular: () => (/* binding */ circular),
/* harmony export */   compare: () => (/* binding */ compare),
/* harmony export */   direct: () => (/* binding */ direct),
/* harmony export */   lines: () => (/* binding */ lines),
/* harmony export */   sort: () => (/* binding */ sort),
/* harmony export */   stringify: () => (/* binding */ stringify)
/* harmony export */ });
/* harmony import */ var kleur__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! kleur */ "./node_modules/kleur/index.mjs");
/* harmony import */ var diff__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diff */ "./node_modules/diff/lib/index.mjs");



const colors = {
	'--': kleur__WEBPACK_IMPORTED_MODULE_0__["default"].red,
	'··': kleur__WEBPACK_IMPORTED_MODULE_0__["default"].grey,
	'++': kleur__WEBPACK_IMPORTED_MODULE_0__["default"].green,
};

const TITLE = kleur__WEBPACK_IMPORTED_MODULE_0__["default"].dim().italic;
const TAB=kleur__WEBPACK_IMPORTED_MODULE_0__["default"].dim('→'), SPACE=kleur__WEBPACK_IMPORTED_MODULE_0__["default"].dim('·'), NL=kleur__WEBPACK_IMPORTED_MODULE_0__["default"].dim('↵');
const LOG = (sym, str) => colors[sym](sym + PRETTY(str)) + '\n';
const LINE = (num, x) => kleur__WEBPACK_IMPORTED_MODULE_0__["default"].dim('L' + String(num).padStart(x, '0') + ' ');
const PRETTY = str => str.replace(/[ ]/g, SPACE).replace(/\t/g, TAB).replace(/(\r?\n)/g, NL);

function line(obj, prev, pad) {
	let char = obj.removed ? '--' : obj.added ? '++' : '··';
	let arr = obj.value.replace(/\r?\n$/, '').split('\n');
	let i=0, tmp, out='';

	if (obj.added) out += colors[char]().underline(TITLE('Expected:')) + '\n';
	else if (obj.removed) out += colors[char]().underline(TITLE('Actual:')) + '\n';

	for (; i < arr.length; i++) {
		tmp = arr[i];
		if (tmp != null) {
			if (prev) out += LINE(prev + i, pad);
			out += LOG(char, tmp || '\n');
		}
	}

	return out;
}

// TODO: want better diffing
//~> complex items bail outright
function arrays(input, expect) {
	let arr = diff__WEBPACK_IMPORTED_MODULE_1__.diffArrays(input, expect);
	let i=0, j=0, k=0, tmp, val, char, isObj, str;
	let out = LOG('··', '[');

	for (; i < arr.length; i++) {
		char = (tmp = arr[i]).removed ? '--' : tmp.added ? '++' : '··';

		if (tmp.added) {
			out += colors[char]().underline(TITLE('Expected:')) + '\n';
		} else if (tmp.removed) {
			out += colors[char]().underline(TITLE('Actual:')) + '\n';
		}

		for (j=0; j < tmp.value.length; j++) {
			isObj = (tmp.value[j] && typeof tmp.value[j] === 'object');
			val = stringify(tmp.value[j]).split(/\r?\n/g);
			for (k=0; k < val.length;) {
				str = '  ' + val[k++] + (isObj ? '' : ',');
				if (isObj && k === val.length && (j + 1) < tmp.value.length) str += ',';
				out += LOG(char, str);
			}
		}
	}

	return out + LOG('··', ']');
}

function lines(input, expect, linenum = 0) {
	let i=0, tmp, output='';
	let arr = diff__WEBPACK_IMPORTED_MODULE_1__.diffLines(input, expect);
	let pad = String(expect.split(/\r?\n/g).length - linenum).length;

	for (; i < arr.length; i++) {
		output += line(tmp = arr[i], linenum, pad);
		if (linenum && !tmp.removed) linenum += tmp.count;
	}

	return output;
}

function chars(input, expect) {
	let arr = diff__WEBPACK_IMPORTED_MODULE_1__.diffChars(input, expect);
	let i=0, output='', tmp;

	let l1 = input.length;
	let l2 = expect.length;

	let p1 = PRETTY(input);
	let p2 = PRETTY(expect);

	tmp = arr[i];

	if (l1 === l2) {
		// no length offsets
	} else if (tmp.removed && arr[i + 1]) {
		let del = tmp.count - arr[i + 1].count;
		if (del == 0) {
			// wash~
		} else if (del > 0) {
			expect = ' '.repeat(del) + expect;
			p2 = ' '.repeat(del) + p2;
			l2 += del;
		} else if (del < 0) {
			input = ' '.repeat(-del) + input;
			p1 = ' '.repeat(-del) + p1;
			l1 += -del;
		}
	}

	output += direct(p1, p2, l1, l2);

	if (l1 === l2) {
		for (tmp='  '; i < l1; i++) {
			tmp += input[i] === expect[i] ? ' ' : '^';
		}
	} else {
		for (tmp='  '; i < arr.length; i++) {
			tmp += ((arr[i].added || arr[i].removed) ? '^' : ' ').repeat(Math.max(arr[i].count, 0));
			if (i + 1 < arr.length && ((arr[i].added && arr[i+1].removed) || (arr[i].removed && arr[i+1].added))) {
				arr[i + 1].count -= arr[i].count;
			}
		}
	}

	return output + kleur__WEBPACK_IMPORTED_MODULE_0__["default"].red(tmp);
}

function direct(input, expect, lenA = String(input).length, lenB = String(expect).length) {
	let gutter = 4;
	let lenC = Math.max(lenA, lenB);
	let typeA=typeof input, typeB=typeof expect;

	if (typeA !== typeB) {
		gutter = 2;

		let delA = gutter + lenC - lenA;
		let delB = gutter + lenC - lenB;

		input += ' '.repeat(delA) + kleur__WEBPACK_IMPORTED_MODULE_0__["default"].dim(`[${typeA}]`);
		expect += ' '.repeat(delB) + kleur__WEBPACK_IMPORTED_MODULE_0__["default"].dim(`[${typeB}]`);

		lenA += delA + typeA.length + 2;
		lenB += delB + typeB.length + 2;
		lenC = Math.max(lenA, lenB);
	}

	let output = colors['++']('++' + expect + ' '.repeat(gutter + lenC - lenB) + TITLE('(Expected)')) + '\n';
	return output + colors['--']('--' + input + ' '.repeat(gutter + lenC - lenA) + TITLE('(Actual)')) + '\n';
}

function sort(input, expect) {
	var k, i=0, tmp, isArr = Array.isArray(input);
	var keys=[], out=isArr ? Array(input.length) : {};

	if (isArr) {
		for (i=0; i < out.length; i++) {
			tmp = input[i];
			if (!tmp || typeof tmp !== 'object') out[i] = tmp;
			else out[i] = sort(tmp, expect[i]); // might not be right
		}
	} else {
		for (k in expect)
			keys.push(k);

		for (; i < keys.length; i++) {
			if (Object.prototype.hasOwnProperty.call(input, k = keys[i])) {
				if (!(tmp = input[k]) || typeof tmp !== 'object') out[k] = tmp;
				else out[k] = sort(tmp, expect[k]);
			}
		}

		for (k in input) {
			if (!out.hasOwnProperty(k)) {
				out[k] = input[k]; // expect didnt have
			}
		}
	}

	return out;
}

function circular() {
	var cache = new Set;
	return function print(key, val) {
		if (val === void 0) return '[__VOID__]';
		if (typeof val === 'number' && val !== val) return '[__NAN__]';
		if (typeof val === 'bigint') return val.toString();
		if (!val || typeof val !== 'object') return val;
		if (cache.has(val)) return '[Circular]';
		cache.add(val); return val;
	}
}

function stringify(input) {
	return JSON.stringify(input, circular(), 2).replace(/"\[__NAN__\]"/g, 'NaN').replace(/"\[__VOID__\]"/g, 'undefined');
}

function compare(input, expect) {
	if (Array.isArray(expect) && Array.isArray(input)) return arrays(input, expect);
	if (expect instanceof RegExp) return chars(''+input, ''+expect);

	let isA = input && typeof input == 'object';
	let isB = expect && typeof expect == 'object';

	if (isA && isB) input = sort(input, expect);
	if (isB) expect = stringify(expect);
	if (isA) input = stringify(input);

	if (expect && typeof expect == 'object') {
		input = stringify(sort(input, expect));
		expect = stringify(expect);
	}

	isA = typeof input == 'string';
	isB = typeof expect == 'string';

	if (isA && /\r?\n/.test(input)) return lines(input, ''+expect);
	if (isB && /\r?\n/.test(expect)) return lines(''+input, expect);
	if (isA && isB) return chars(input, expect);

	return direct(input, expect);
}


/***/ }),

/***/ "./node_modules/vfile-message/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/vfile-message/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VFileMessage: () => (/* binding */ VFileMessage)
/* harmony export */ });
/* harmony import */ var unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-stringify-position */ "./node_modules/unist-util-stringify-position/lib/index.js");
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Position} Position
 * @typedef {import('unist').Point} Point
 * @typedef {object & {type: string, position?: Position | undefined}} NodeLike
 */



/**
 * Message.
 */
class VFileMessage extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > 👉 **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(reason, place, origin) {
    /** @type {[string | null, string | null]} */
    const parts = [null, null]
    /** @type {Position} */
    let position = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: {line: null, column: null},
      // @ts-expect-error: "
      end: {line: null, column: null}
    }

    super()

    if (typeof place === 'string') {
      origin = place
      place = undefined
    }

    if (typeof origin === 'string') {
      const index = origin.indexOf(':')

      if (index === -1) {
        parts[1] = origin
      } else {
        parts[0] = origin.slice(0, index)
        parts[1] = origin.slice(index + 1)
      }
    }

    if (place) {
      // Node.
      if ('type' in place || 'position' in place) {
        if (place.position) {
          // To do: next major: deep clone.
          // @ts-expect-error: looks like a position.
          position = place.position
        }
      }
      // Position.
      else if ('start' in place || 'end' in place) {
        // @ts-expect-error: looks like a position.
        // To do: next major: deep clone.
        position = place
      }
      // Point.
      else if ('line' in place || 'column' in place) {
        // To do: next major: deep clone.
        position.start = place
      }
    }

    // Fields from `Error`.
    /**
     * Serialized positional info of error.
     *
     * On normal errors, this would be something like `ParseError`, buit in
     * `VFile` messages we use this space to show where an error happened.
     */
    this.name = (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_0__.stringifyPosition)(place) || '1:1'

    /**
     * Reason for message.
     *
     * @type {string}
     */
    this.message = typeof reason === 'object' ? reason.message : reason

    /**
     * Stack of message.
     *
     * This is used by normal errors to show where something happened in
     * programming code, irrelevant for `VFile` messages,
     *
     * @type {string}
     */
    this.stack = ''

    if (typeof reason === 'object' && reason.stack) {
      this.stack = reason.stack
    }

    /**
     * Reason for message.
     *
     * > 👉 **Note**: you should use markdown.
     *
     * @type {string}
     */
    this.reason = this.message

    /* eslint-disable no-unused-expressions */
    /**
     * State of problem.
     *
     * * `true` — marks associated file as no longer processable (error)
     * * `false` — necessitates a (potential) change (warning)
     * * `null | undefined` — for things that might not need changing (info)
     *
     * @type {boolean | null | undefined}
     */
    this.fatal

    /**
     * Starting line of error.
     *
     * @type {number | null}
     */
    this.line = position.start.line

    /**
     * Starting column of error.
     *
     * @type {number | null}
     */
    this.column = position.start.column

    /**
     * Full unist position.
     *
     * @type {Position | null}
     */
    this.position = position

    /**
     * Namespace of message (example: `'my-package'`).
     *
     * @type {string | null}
     */
    this.source = parts[0]

    /**
     * Category of message (example: `'my-rule'`).
     *
     * @type {string | null}
     */
    this.ruleId = parts[1]

    /**
     * Path of a file (used throughout the `VFile` ecosystem).
     *
     * @type {string | null}
     */
    this.file

    // The following fields are “well known”.
    // Not standard.
    // Feel free to add other non-standard fields to your messages.

    /**
     * Specify the source value that’s being reported, which is deemed
     * incorrect.
     *
     * @type {string | null}
     */
    this.actual

    /**
     * Suggest acceptable values that can be used instead of `actual`.
     *
     * @type {Array<string> | null}
     */
    this.expected

    /**
     * Link to docs for the message.
     *
     * > 👉 **Note**: this must be an absolute URL that can be passed as `x`
     * > to `new URL(x)`.
     *
     * @type {string | null}
     */
    this.url

    /**
     * Long form description of the message (you should use markdown).
     *
     * @type {string | null}
     */
    this.note
    /* eslint-enable no-unused-expressions */
  }
}

VFileMessage.prototype.file = ''
VFileMessage.prototype.name = ''
VFileMessage.prototype.reason = ''
VFileMessage.prototype.message = ''
VFileMessage.prototype.stack = ''
VFileMessage.prototype.fatal = null
VFileMessage.prototype.column = null
VFileMessage.prototype.line = null
VFileMessage.prototype.source = null
VFileMessage.prototype.ruleId = null
VFileMessage.prototype.position = null


/***/ }),

/***/ "./node_modules/vfile/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/vfile/lib/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VFile: () => (/* binding */ VFile)
/* harmony export */ });
/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-buffer */ "./node_modules/is-buffer/index.js");
/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vfile-message */ "./node_modules/vfile-message/lib/index.js");
/* harmony import */ var _minpath_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./minpath.js */ "./node_modules/vfile/lib/minpath.browser.js");
/* harmony import */ var _minproc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./minproc.js */ "./node_modules/vfile/lib/minproc.browser.js");
/* harmony import */ var _minurl_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./minurl.js */ "./node_modules/vfile/lib/minurl.shared.js");
/* harmony import */ var _minurl_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./minurl.js */ "./node_modules/vfile/lib/minurl.browser.js");
/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Position} Position
 * @typedef {import('unist').Point} Point
 * @typedef {import('./minurl.shared.js').URL} URL
 * @typedef {import('../index.js').Data} Data
 * @typedef {import('../index.js').Value} Value
 */

/**
 * @typedef {Record<string, unknown> & {type: string, position?: Position | undefined}} NodeLike
 *
 * @typedef {'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'base64url' | 'latin1' | 'binary' | 'hex'} BufferEncoding
 *   Encodings supported by the buffer class.
 *
 *   This is a copy of the types from Node, copied to prevent Node globals from
 *   being needed.
 *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>
 *
 * @typedef {Options | URL | Value | VFile} Compatible
 *   Things that can be passed to the constructor.
 *
 * @typedef VFileCoreOptions
 *   Set multiple values.
 * @property {Value | null | undefined} [value]
 *   Set `value`.
 * @property {string | null | undefined} [cwd]
 *   Set `cwd`.
 * @property {Array<string> | null | undefined} [history]
 *   Set `history`.
 * @property {URL | string | null | undefined} [path]
 *   Set `path`.
 * @property {string | null | undefined} [basename]
 *   Set `basename`.
 * @property {string | null | undefined} [stem]
 *   Set `stem`.
 * @property {string | null | undefined} [extname]
 *   Set `extname`.
 * @property {string | null | undefined} [dirname]
 *   Set `dirname`.
 * @property {Data | null | undefined} [data]
 *   Set `data`.
 *
 * @typedef Map
 *   Raw source map.
 *
 *   See:
 *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.
 * @property {number} version
 *   Which version of the source map spec this map is following.
 * @property {Array<string>} sources
 *   An array of URLs to the original source files.
 * @property {Array<string>} names
 *   An array of identifiers which can be referenced by individual mappings.
 * @property {string | undefined} [sourceRoot]
 *   The URL root from which all sources are relative.
 * @property {Array<string> | undefined} [sourcesContent]
 *   An array of contents of the original source files.
 * @property {string} mappings
 *   A string of base64 VLQs which contain the actual mappings.
 * @property {string} file
 *   The generated file this source map is associated with.
 *
 * @typedef {{[key: string]: unknown} & VFileCoreOptions} Options
 *   Configuration.
 *
 *   A bunch of keys that will be shallow copied over to the new file.
 *
 * @typedef {Record<string, unknown>} ReporterSettings
 *   Configuration for reporters.
 */

/**
 * @template {ReporterSettings} Settings
 *   Options type.
 * @callback Reporter
 *   Type for a reporter.
 * @param {Array<VFile>} files
 *   Files to report.
 * @param {Settings} options
 *   Configuration.
 * @returns {string}
 *   Report.
 */







/**
 * Order of setting (least specific to most), we need this because otherwise
 * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
 * stem can be set.
 *
 * @type {Array<'basename' | 'dirname' | 'extname' | 'history' | 'path' | 'stem'>}
 */
const order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']

class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    /** @type {Options | VFile} */
    let options

    if (!value) {
      options = {}
    } else if (typeof value === 'string' || buffer(value)) {
      options = {value}
    } else if ((0,_minurl_js__WEBPACK_IMPORTED_MODULE_4__.isUrl)(value)) {
      options = {path: value}
    } else {
      options = value
    }

    /**
     * Place to store custom information (default: `{}`).
     *
     * It’s OK to store custom data directly on the file but moving it to
     * `data` is recommended.
     *
     * @type {Data}
     */
    this.data = {}

    /**
     * List of messages associated with the file.
     *
     * @type {Array<VFileMessage>}
     */
    this.messages = []

    /**
     * List of filepaths the file moved between.
     *
     * The first is the original path and the last is the current path.
     *
     * @type {Array<string>}
     */
    this.history = []

    /**
     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).
     *
     * @type {string}
     */
    this.cwd = _minproc_js__WEBPACK_IMPORTED_MODULE_3__.proc.cwd()

    /* eslint-disable no-unused-expressions */
    /**
     * Raw value.
     *
     * @type {Value}
     */
    this.value

    // The below are non-standard, they are “well-known”.
    // As in, used in several tools.

    /**
     * Whether a file was saved to disk.
     *
     * This is used by vfile reporters.
     *
     * @type {boolean}
     */
    this.stored

    /**
     * Custom, non-string, compiled, representation.
     *
     * This is used by unified to store non-string results.
     * One example is when turning markdown into React nodes.
     *
     * @type {unknown}
     */
    this.result

    /**
     * Source map.
     *
     * This type is equivalent to the `RawSourceMap` type from the `source-map`
     * module.
     *
     * @type {Map | null | undefined}
     */
    this.map
    /* eslint-enable no-unused-expressions */

    // Set path related properties in the correct order.
    let index = -1

    while (++index < order.length) {
      const prop = order[index]

      // Note: we specifically use `in` instead of `hasOwnProperty` to accept
      // `vfile`s too.
      if (
        prop in options &&
        options[prop] !== undefined &&
        options[prop] !== null
      ) {
        // @ts-expect-error: TS doesn’t understand basic reality.
        this[prop] = prop === 'history' ? [...options[prop]] : options[prop]
      }
    }

    /** @type {string} */
    let prop

    // Set non-path related properties.
    for (prop in options) {
      // @ts-expect-error: fine to set other things.
      if (!order.includes(prop)) {
        // @ts-expect-error: fine to set other things.
        this[prop] = options[prop]
      }
    }
  }

  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1]
  }

  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(path) {
    if ((0,_minurl_js__WEBPACK_IMPORTED_MODULE_4__.isUrl)(path)) {
      path = (0,_minurl_js__WEBPACK_IMPORTED_MODULE_5__.urlToPath)(path)
    }

    assertNonEmpty(path, 'path')

    if (this.path !== path) {
      this.history.push(path)
    }
  }

  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path === 'string' ? _minpath_js__WEBPACK_IMPORTED_MODULE_2__.path.dirname(this.path) : undefined
  }

  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   */
  set dirname(dirname) {
    assertPath(this.basename, 'dirname')
    this.path = _minpath_js__WEBPACK_IMPORTED_MODULE_2__.path.join(dirname || '', this.basename)
  }

  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path === 'string' ? _minpath_js__WEBPACK_IMPORTED_MODULE_2__.path.basename(this.path) : undefined
  }

  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(basename) {
    assertNonEmpty(basename, 'basename')
    assertPart(basename, 'basename')
    this.path = _minpath_js__WEBPACK_IMPORTED_MODULE_2__.path.join(this.dirname || '', basename)
  }

  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path === 'string' ? _minpath_js__WEBPACK_IMPORTED_MODULE_2__.path.extname(this.path) : undefined
  }

  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   */
  set extname(extname) {
    assertPart(extname, 'extname')
    assertPath(this.dirname, 'extname')

    if (extname) {
      if (extname.charCodeAt(0) !== 46 /* `.` */) {
        throw new Error('`extname` must start with `.`')
      }

      if (extname.includes('.', 1)) {
        throw new Error('`extname` cannot contain multiple dots')
      }
    }

    this.path = _minpath_js__WEBPACK_IMPORTED_MODULE_2__.path.join(this.dirname, this.stem + (extname || ''))
  }

  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path === 'string'
      ? _minpath_js__WEBPACK_IMPORTED_MODULE_2__.path.basename(this.path, this.extname)
      : undefined
  }

  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(stem) {
    assertNonEmpty(stem, 'stem')
    assertPart(stem, 'stem')
    this.path = _minpath_js__WEBPACK_IMPORTED_MODULE_2__.path.join(this.dirname || '', stem + (this.extname || ''))
  }

  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    return (this.value || '').toString(encoding || undefined)
  }

  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(reason, place, origin) {
    const message = new vfile_message__WEBPACK_IMPORTED_MODULE_1__.VFileMessage(reason, place, origin)

    if (this.path) {
      message.name = this.path + ':' + message.name
      message.file = this.path
    }

    message.fatal = false

    this.messages.push(message)

    return message
  }

  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(reason, place, origin) {
    const message = this.message(reason, place, origin)

    message.fatal = null

    return message
  }

  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * > 👉 **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(reason, place, origin) {
    const message = this.message(reason, place, origin)

    message.fatal = true

    throw message
  }
}

/**
 * Assert that `part` is not a path (as in, does not contain `path.sep`).
 *
 * @param {string | null | undefined} part
 *   File path part.
 * @param {string} name
 *   Part name.
 * @returns {void}
 *   Nothing.
 */
function assertPart(part, name) {
  if (part && part.includes(_minpath_js__WEBPACK_IMPORTED_MODULE_2__.path.sep)) {
    throw new Error(
      '`' + name + '` cannot be a path: did not expect `' + _minpath_js__WEBPACK_IMPORTED_MODULE_2__.path.sep + '`'
    )
  }
}

/**
 * Assert that `part` is not empty.
 *
 * @param {string | undefined} part
 *   Thing.
 * @param {string} name
 *   Part name.
 * @returns {asserts part is string}
 *   Nothing.
 */
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error('`' + name + '` cannot be empty')
  }
}

/**
 * Assert `path` exists.
 *
 * @param {string | undefined} path
 *   Path.
 * @param {string} name
 *   Dependency name.
 * @returns {asserts path is string}
 *   Nothing.
 */
function assertPath(path, name) {
  if (!path) {
    throw new Error('Setting `' + name + '` requires `path` to be set too')
  }
}

/**
 * Assert `value` is a buffer.
 *
 * @param {unknown} value
 *   thing.
 * @returns {value is Buffer}
 *   Whether `value` is a Node.js buffer.
 */
function buffer(value) {
  return is_buffer__WEBPACK_IMPORTED_MODULE_0__(value)
}


/***/ }),

/***/ "./node_modules/vfile/lib/minpath.browser.js":
/*!***************************************************!*\
  !*** ./node_modules/vfile/lib/minpath.browser.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   path: () => (/* binding */ path)
/* harmony export */ });
// A derivative work based on:
// <https://github.com/browserify/path-browserify>.
// Which is licensed:
//
// MIT License
//
// Copyright (c) 2013 James Halliday
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// A derivative work based on:
//
// Parts of that are extracted from Node’s internal `path` module:
// <https://github.com/nodejs/node/blob/master/lib/path.js>.
// Which is licensed:
//
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

const path = {basename, dirname, extname, join, sep: '/'}

/* eslint-disable max-depth, complexity */

/**
 * Get the basename from a path.
 *
 * @param {string} path
 *   File path.
 * @param {string | undefined} [ext]
 *   Extension to strip.
 * @returns {string}
 *   Stem or basename.
 */
function basename(path, ext) {
  if (ext !== undefined && typeof ext !== 'string') {
    throw new TypeError('"ext" argument must be a string')
  }

  assertPath(path)
  let start = 0
  let end = -1
  let index = path.length
  /** @type {boolean | undefined} */
  let seenNonSlash

  if (ext === undefined || ext.length === 0 || ext.length > path.length) {
    while (index--) {
      if (path.charCodeAt(index) === 47 /* `/` */) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now.
        if (seenNonSlash) {
          start = index + 1
          break
        }
      } else if (end < 0) {
        // We saw the first non-path separator, mark this as the end of our
        // path component.
        seenNonSlash = true
        end = index + 1
      }
    }

    return end < 0 ? '' : path.slice(start, end)
  }

  if (ext === path) {
    return ''
  }

  let firstNonSlashEnd = -1
  let extIndex = ext.length - 1

  while (index--) {
    if (path.charCodeAt(index) === 47 /* `/` */) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now.
      if (seenNonSlash) {
        start = index + 1
        break
      }
    } else {
      if (firstNonSlashEnd < 0) {
        // We saw the first non-path separator, remember this index in case
        // we need it if the extension ends up not matching.
        seenNonSlash = true
        firstNonSlashEnd = index + 1
      }

      if (extIndex > -1) {
        // Try to match the explicit extension.
        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            // We matched the extension, so mark this as the end of our path
            // component
            end = index
          }
        } else {
          // Extension does not match, so our result is the entire path
          // component
          extIndex = -1
          end = firstNonSlashEnd
        }
      }
    }
  }

  if (start === end) {
    end = firstNonSlashEnd
  } else if (end < 0) {
    end = path.length
  }

  return path.slice(start, end)
}

/**
 * Get the dirname from a path.
 *
 * @param {string} path
 *   File path.
 * @returns {string}
 *   File path.
 */
function dirname(path) {
  assertPath(path)

  if (path.length === 0) {
    return '.'
  }

  let end = -1
  let index = path.length
  /** @type {boolean | undefined} */
  let unmatchedSlash

  // Prefix `--` is important to not run on `0`.
  while (--index) {
    if (path.charCodeAt(index) === 47 /* `/` */) {
      if (unmatchedSlash) {
        end = index
        break
      }
    } else if (!unmatchedSlash) {
      // We saw the first non-path separator
      unmatchedSlash = true
    }
  }

  return end < 0
    ? path.charCodeAt(0) === 47 /* `/` */
      ? '/'
      : '.'
    : end === 1 && path.charCodeAt(0) === 47 /* `/` */
    ? '//'
    : path.slice(0, end)
}

/**
 * Get an extname from a path.
 *
 * @param {string} path
 *   File path.
 * @returns {string}
 *   Extname.
 */
function extname(path) {
  assertPath(path)

  let index = path.length

  let end = -1
  let startPart = 0
  let startDot = -1
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find.
  let preDotState = 0
  /** @type {boolean | undefined} */
  let unmatchedSlash

  while (index--) {
    const code = path.charCodeAt(index)

    if (code === 47 /* `/` */) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now.
      if (unmatchedSlash) {
        startPart = index + 1
        break
      }

      continue
    }

    if (end < 0) {
      // We saw the first non-path separator, mark this as the end of our
      // extension.
      unmatchedSlash = true
      end = index + 1
    }

    if (code === 46 /* `.` */) {
      // If this is our first dot, mark it as the start of our extension.
      if (startDot < 0) {
        startDot = index
      } else if (preDotState !== 1) {
        preDotState = 1
      }
    } else if (startDot > -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension.
      preDotState = -1
    }
  }

  if (
    startDot < 0 ||
    end < 0 ||
    // We saw a non-dot character immediately before the dot.
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly `..`.
    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)
  ) {
    return ''
  }

  return path.slice(startDot, end)
}

/**
 * Join segments from a path.
 *
 * @param {Array<string>} segments
 *   Path segments.
 * @returns {string}
 *   File path.
 */
function join(...segments) {
  let index = -1
  /** @type {string | undefined} */
  let joined

  while (++index < segments.length) {
    assertPath(segments[index])

    if (segments[index]) {
      joined =
        joined === undefined ? segments[index] : joined + '/' + segments[index]
    }
  }

  return joined === undefined ? '.' : normalize(joined)
}

/**
 * Normalize a basic file path.
 *
 * @param {string} path
 *   File path.
 * @returns {string}
 *   File path.
 */
// Note: `normalize` is not exposed as `path.normalize`, so some code is
// manually removed from it.
function normalize(path) {
  assertPath(path)

  const absolute = path.charCodeAt(0) === 47 /* `/` */

  // Normalize the path according to POSIX rules.
  let value = normalizeString(path, !absolute)

  if (value.length === 0 && !absolute) {
    value = '.'
  }

  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */) {
    value += '/'
  }

  return absolute ? '/' + value : value
}

/**
 * Resolve `.` and `..` elements in a path with directory names.
 *
 * @param {string} path
 *   File path.
 * @param {boolean} allowAboveRoot
 *   Whether `..` can move above root.
 * @returns {string}
 *   File path.
 */
function normalizeString(path, allowAboveRoot) {
  let result = ''
  let lastSegmentLength = 0
  let lastSlash = -1
  let dots = 0
  let index = -1
  /** @type {number | undefined} */
  let code
  /** @type {number} */
  let lastSlashIndex

  while (++index <= path.length) {
    if (index < path.length) {
      code = path.charCodeAt(index)
    } else if (code === 47 /* `/` */) {
      break
    } else {
      code = 47 /* `/` */
    }

    if (code === 47 /* `/` */) {
      if (lastSlash === index - 1 || dots === 1) {
        // Empty.
      } else if (lastSlash !== index - 1 && dots === 2) {
        if (
          result.length < 2 ||
          lastSegmentLength !== 2 ||
          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||
          result.charCodeAt(result.length - 2) !== 46 /* `.` */
        ) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf('/')

            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = ''
                lastSegmentLength = 0
              } else {
                result = result.slice(0, lastSlashIndex)
                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')
              }

              lastSlash = index
              dots = 0
              continue
            }
          } else if (result.length > 0) {
            result = ''
            lastSegmentLength = 0
            lastSlash = index
            dots = 0
            continue
          }
        }

        if (allowAboveRoot) {
          result = result.length > 0 ? result + '/..' : '..'
          lastSegmentLength = 2
        }
      } else {
        if (result.length > 0) {
          result += '/' + path.slice(lastSlash + 1, index)
        } else {
          result = path.slice(lastSlash + 1, index)
        }

        lastSegmentLength = index - lastSlash - 1
      }

      lastSlash = index
      dots = 0
    } else if (code === 46 /* `.` */ && dots > -1) {
      dots++
    } else {
      dots = -1
    }
  }

  return result
}

/**
 * Make sure `path` is a string.
 *
 * @param {string} path
 *   File path.
 * @returns {asserts path is string}
 *   Nothing.
 */
function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError(
      'Path must be a string. Received ' + JSON.stringify(path)
    )
  }
}

/* eslint-enable max-depth, complexity */


/***/ }),

/***/ "./node_modules/vfile/lib/minproc.browser.js":
/*!***************************************************!*\
  !*** ./node_modules/vfile/lib/minproc.browser.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   proc: () => (/* binding */ proc)
/* harmony export */ });
// Somewhat based on:
// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.
// But I don’t think one tiny line of code can be copyrighted. 😅
const proc = {cwd}

function cwd() {
  return '/'
}


/***/ }),

/***/ "./node_modules/vfile/lib/minurl.browser.js":
/*!**************************************************!*\
  !*** ./node_modules/vfile/lib/minurl.browser.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isUrl: () => (/* reexport safe */ _minurl_shared_js__WEBPACK_IMPORTED_MODULE_0__.isUrl),
/* harmony export */   urlToPath: () => (/* binding */ urlToPath)
/* harmony export */ });
/* harmony import */ var _minurl_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./minurl.shared.js */ "./node_modules/vfile/lib/minurl.shared.js");
/// <reference lib="dom" />



// See: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js>

/**
 * @param {string | URL} path
 *   File URL.
 * @returns {string}
 *   File URL.
 */
function urlToPath(path) {
  if (typeof path === 'string') {
    path = new URL(path)
  } else if (!(0,_minurl_shared_js__WEBPACK_IMPORTED_MODULE_0__.isUrl)(path)) {
    /** @type {NodeJS.ErrnoException} */
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' +
        path +
        '`'
    )
    error.code = 'ERR_INVALID_ARG_TYPE'
    throw error
  }

  if (path.protocol !== 'file:') {
    /** @type {NodeJS.ErrnoException} */
    const error = new TypeError('The URL must be of scheme file')
    error.code = 'ERR_INVALID_URL_SCHEME'
    throw error
  }

  return getPathFromURLPosix(path)
}

/**
 * Get a path from a POSIX URL.
 *
 * @param {URL} url
 *   URL.
 * @returns {string}
 *   File path.
 */
function getPathFromURLPosix(url) {
  if (url.hostname !== '') {
    /** @type {NodeJS.ErrnoException} */
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    )
    error.code = 'ERR_INVALID_FILE_URL_HOST'
    throw error
  }

  const pathname = url.pathname
  let index = -1

  while (++index < pathname.length) {
    if (
      pathname.charCodeAt(index) === 37 /* `%` */ &&
      pathname.charCodeAt(index + 1) === 50 /* `2` */
    ) {
      const third = pathname.charCodeAt(index + 2)
      if (third === 70 /* `F` */ || third === 102 /* `f` */) {
        /** @type {NodeJS.ErrnoException} */
        const error = new TypeError(
          'File URL path must not include encoded / characters'
        )
        error.code = 'ERR_INVALID_FILE_URL_PATH'
        throw error
      }
    }
  }

  return decodeURIComponent(pathname)
}




/***/ }),

/***/ "./node_modules/vfile/lib/minurl.shared.js":
/*!*************************************************!*\
  !*** ./node_modules/vfile/lib/minurl.shared.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isUrl: () => (/* binding */ isUrl)
/* harmony export */ });
/**
 * @typedef URL
 * @property {string} hash
 * @property {string} host
 * @property {string} hostname
 * @property {string} href
 * @property {string} origin
 * @property {string} password
 * @property {string} pathname
 * @property {string} port
 * @property {string} protocol
 * @property {string} search
 * @property {any} searchParams
 * @property {string} username
 * @property {() => string} toString
 * @property {() => string} toJSON
 */

/**
 * Check if `fileUrlOrPath` looks like a URL.
 *
 * @param {unknown} fileUrlOrPath
 *   File path or URL.
 * @returns {fileUrlOrPath is URL}
 *   Whether it’s a URL.
 */
// From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>
function isUrl(fileUrlOrPath) {
  return (
    fileUrlOrPath !== null &&
    typeof fileUrlOrPath === 'object' &&
    // @ts-expect-error: indexable.
    fileUrlOrPath.href &&
    // @ts-expect-error: indexable.
    fileUrlOrPath.origin
  )
}


/***/ }),

/***/ "./src/actions/persistent.ts":
/*!***********************************!*\
  !*** ./src/actions/persistent.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clearPendingVote = exports.setPendingVote = exports.updateSuccessRate = exports.updateRevisionInfo = exports.updateCollectionInfo = void 0;
const redux_act_1 = __webpack_require__(/*! redux-act */ "redux-act");
exports.updateCollectionInfo = (0, redux_act_1.createAction)('UPDATE_COLLECTION_INFO', (collectionId, collectionInfo, timestamp) => ({ collectionId, collectionInfo, timestamp }));
exports.updateRevisionInfo = (0, redux_act_1.createAction)('UPDATE_REVISION_INFO', (revisionId, revisionInfo, timestamp) => ({ revisionId, revisionInfo, timestamp }));
exports.updateSuccessRate = (0, redux_act_1.createAction)('UPDATE_COLLECTION_HEALTH_RATE', (revisionId, vote, average, total) => ({ revisionId, vote, average, total }));
exports.setPendingVote = (0, redux_act_1.createAction)('SET_REVISION_PENDING_VOTE', (revisionId, collectionSlug, revisionNumber, time) => ({ revisionId, collectionSlug, revisionNumber, time }));
exports.clearPendingVote = (0, redux_act_1.createAction)('CLEAR_REVISION_PENDING_VOTE', (revisionId) => ({ revisionId }));


/***/ }),

/***/ "./src/actions/session.ts":
/*!********************************!*\
  !*** ./src/actions/session.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.healthDownvoteDialog = exports.startAddModsToCollection = exports.startEditCollection = void 0;
const redux_act_1 = __webpack_require__(/*! redux-act */ "redux-act");
exports.startEditCollection = (0, redux_act_1.createAction)('START_EDIT_COLLECTION', (modId) => ({ modId }));
exports.startAddModsToCollection = (0, redux_act_1.createAction)('START_ADD_MODS_TO_COLLECTION', (collectionId) => ({ collectionId }));
exports.healthDownvoteDialog = (0, redux_act_1.createAction)('HEALTH_DOWNVOTE_DIALOG', (collectionModId) => ({ collectionModId }));


/***/ }),

/***/ "./src/actions/settings.ts":
/*!*********************************!*\
  !*** ./src/actions/settings.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setSortWorkshop = exports.setSortAdded = void 0;
const redux_act_1 = __webpack_require__(/*! redux-act */ "redux-act");
exports.setSortAdded = (0, redux_act_1.createAction)('SORT_COLLECTION_ADDED', (sorting) => ({ sorting }));
exports.setSortWorkshop = (0, redux_act_1.createAction)('SORT_COLLECTION_WORKSHOP', (sorting) => ({ sorting }));


/***/ }),

/***/ "./src/collectionCreate.ts":
/*!*********************************!*\
  !*** ./src/collectionCreate.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeCollectionAction = exports.addCollectionAction = exports.alreadyIncluded = exports.removeCollectionCondition = exports.addCollectionCondition = exports.initFromProfile = void 0;
const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
const transformCollection_1 = __webpack_require__(/*! ./util/transformCollection */ "./src/util/transformCollection.ts");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const util_1 = __webpack_require__(/*! ./util/util */ "./src/util/util.ts");
async function initFromProfile(api, profileId) {
    var _a, _b;
    try {
        let forcedName;
        const isQuickCollection = profileId === undefined;
        if (isQuickCollection && vortex_api_1.selectors.activeProfile(api.getState()) === undefined) {
            throw new vortex_api_1.util.ProcessCanceled('No active profile');
        }
        else if (isQuickCollection) {
            profileId = vortex_api_1.selectors.activeProfile(api.getState()).id;
            await (0, transformCollection_1.showQuickCollectionRestrictionsDialog)(api);
            forcedName = `My mods: ${new Date().toLocaleDateString('en-GB', {
                day: '2-digit',
                month: 'short',
                year: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
            })}`;
        }
        const { id, name, updated, wantsToUpload } = await (0, transformCollection_1.createCollectionFromProfile)(api, profileId, forcedName);
        if (isQuickCollection) {
            const state = api.getState();
            const activeGameId = vortex_api_1.selectors.activeGameId(state);
            const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', activeGameId], {});
            const hasRules = ((_b = (_a = mods[id]) === null || _a === void 0 ? void 0 : _a.rules) !== null && _b !== void 0 ? _b : []).length > 0;
            if (!hasRules) {
                await api.showDialog('error', 'Collection is empty', {
                    text: 'The generated quick collection is empty. Please ensure the Nexus Mods sourced mods you want to include are '
                        + 'enabled and deployed.',
                }, [
                    { label: 'Close' },
                ]);
                return;
            }
        }
        api.store.dispatch(vortex_api_1.actions.setModEnabled(profileId, id, true));
        if (wantsToUpload) {
            await (0, util_1.uploadCollection)(api, profileId, id);
        }
        api.sendNotification({
            type: 'success',
            id: 'collection-created',
            title: updated ? 'Collection updated' : 'Collection created',
            message: name,
            displayMS: vortex_api_1.util.calcDuration(name.length + 20),
            actions: [
                {
                    title: 'Edit',
                    action: dismiss => {
                        api.events.emit('edit-collection', id);
                        dismiss();
                    },
                },
            ],
        });
    }
    catch (err) {
        if (!(err instanceof vortex_api_1.util.UserCanceled)) {
            throw err;
        }
    }
}
exports.initFromProfile = initFromProfile;
const collections = (mods) => {
    const isWorkshopCollection = mod => {
        var _a;
        return (mod.type === constants_1.MOD_TYPE)
            && (((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.editable) === true);
    };
    return Object.values(mods)
        .filter(isWorkshopCollection)
        .map(coll => { var _a; return new Set(((_a = coll.rules) !== null && _a !== void 0 ? _a : []).map(rule => rule.reference.id)); });
};
function addCollectionCondition(api, instanceIds) {
    const state = api.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const mods = state.persistent.mods[gameId];
    return collections(mods).find(ruleSet => {
        return instanceIds.find(modId => (mods[modId].type !== constants_1.MOD_TYPE) && !ruleSet.has(modId)) !== undefined;
    }) !== undefined;
}
exports.addCollectionCondition = addCollectionCondition;
function removeCollectionCondition(api, instanceIds) {
    const state = api.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const mods = state.persistent.mods[gameId];
    return collections(mods).find(ruleSet => {
        return instanceIds.find(modId => ruleSet.has(modId)) !== undefined;
    }) !== undefined;
}
exports.removeCollectionCondition = removeCollectionCondition;
function alreadyIncluded(rules, modId) {
    var _a;
    return ((_a = rules === null || rules === void 0 ? void 0 : rules.find) === null || _a === void 0 ? void 0 : _a.call(rules, rule => rule.reference.id === modId)) !== undefined;
}
exports.alreadyIncluded = alreadyIncluded;
function addCollectionAction(api, instanceIdsIn) {
    const state = api.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const mods = state.persistent.mods[gameId];
    const instanceIds = instanceIdsIn.filter(modId => mods[modId] !== undefined);
    const filtered = instanceIds.filter(modId => (mods[modId].type !== constants_1.MOD_TYPE));
    const collections = Object.keys(mods)
        .filter(collectionId => {
        var _a, _b;
        if ((mods[collectionId].type !== constants_1.MOD_TYPE)
            || (((_a = mods[collectionId].attributes) === null || _a === void 0 ? void 0 : _a.editable) !== true)) {
            return false;
        }
        const rules = (_b = mods[collectionId].rules) !== null && _b !== void 0 ? _b : [];
        return filtered.find(modId => !alreadyIncluded(rules, modId)) !== undefined;
    });
    const sortAlphabetically = (modIds) => {
        const temp = [...modIds];
        temp.sort((a, b) => {
            const modA = vortex_api_1.util.renderModName(mods[a]).toLowerCase();
            const modB = vortex_api_1.util.renderModName(mods[b]).toLowerCase();
            return modA.localeCompare(modB);
        });
        return temp;
    };
    return api.showDialog('question', 'Add Mods to Collection', {
        text: 'Choose which collection you want the selected mods to be added',
        message: sortAlphabetically(filtered).map(modId => vortex_api_1.util.renderModName(mods[modId], { version: true, variant: true })).join('\n'),
        choices: sortAlphabetically(collections).map((modId, idx) => ({
            id: modId,
            text: vortex_api_1.util.renderModName(mods[modId]),
            value: idx === 0,
        })),
    }, [
        { label: 'Cancel' },
        { label: 'Add' },
    ])
        .then((result) => {
        var _a;
        if (result.action === 'Add') {
            const collectionId = Object.keys(result.input).find(target => result.input[target]);
            if (mods[collectionId] === undefined) {
                return;
            }
            const rules = (_a = mods[collectionId].rules) !== null && _a !== void 0 ? _a : [];
            vortex_api_1.util.batchDispatch(api.store, filtered.reduce((prev, modId) => {
                if (!alreadyIncluded(rules, modId) && (mods[modId].type !== constants_1.MOD_TYPE)) {
                    prev.push(vortex_api_1.actions.addModRule(gameId, collectionId, {
                        type: 'requires',
                        reference: {
                            id: modId,
                        },
                    }));
                }
                return prev;
            }, []));
        }
    });
}
exports.addCollectionAction = addCollectionAction;
function removeCollectionAction(api, instanceIds) {
    const state = api.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const mods = state.persistent.mods[gameId];
    const collections = Object.keys(mods)
        .filter(collectionId => {
        var _a, _b;
        if ((mods[collectionId].type !== constants_1.MOD_TYPE)
            || (((_a = mods[collectionId].attributes) === null || _a === void 0 ? void 0 : _a.editable) !== true)) {
            return false;
        }
        const rules = (_b = mods[collectionId].rules) !== null && _b !== void 0 ? _b : [];
        return instanceIds.find(modId => alreadyIncluded(rules, modId)) !== undefined;
    });
    return api.showDialog('question', 'Remove Mods from Collection', {
        text: 'Please select the (modifiable) collection to remove the mods from',
        message: instanceIds.map(modId => vortex_api_1.util.renderModName(mods[modId])).join('\n'),
        choices: collections.map((modId, idx) => ({
            id: modId,
            text: vortex_api_1.util.renderModName(mods[modId]),
            value: idx === 0,
        })),
    }, [
        { label: 'Cancel' },
        { label: 'Remove' },
    ])
        .then((result) => {
        var _a;
        if (result.action === 'Remove') {
            const collectionId = Object.keys(result.input).find(target => result.input[target]);
            const rules = (_a = mods[collectionId].rules) !== null && _a !== void 0 ? _a : [];
            vortex_api_1.util.batchDispatch(api.store, instanceIds.reduce((prev, modId) => {
                const ruleToRemove = rules.find(rule => rule.reference.id === modId);
                if (ruleToRemove !== undefined) {
                    prev.push(vortex_api_1.actions.removeModRule(gameId, collectionId, ruleToRemove));
                }
                return prev;
            }, []));
        }
    });
}
exports.removeCollectionAction = removeCollectionAction;


/***/ }),

/***/ "./src/collectionExport.ts":
/*!*********************************!*\
  !*** ./src/collectionExport.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.doExportToFile = exports.doExportToAPI = void 0;
const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
const transformCollection_1 = __webpack_require__(/*! ./util/transformCollection */ "./src/util/transformCollection.ts");
const util_1 = __webpack_require__(/*! ./util/util */ "./src/util/util.ts");
const PromiseBB = __webpack_require__(/*! bluebird */ "bluebird");
const _ = __webpack_require__(/*! lodash */ "lodash");
const Zip = __webpack_require__(/*! node-7z */ "node-7z");
const path = __webpack_require__(/*! path */ "path");
const tmp_1 = __webpack_require__(/*! tmp */ "./node_modules/tmp/lib/tmp.js");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
async function withTmpDir(cb) {
    return new Promise((resolve, reject) => {
        (0, tmp_1.dir)((err, tmpPath, cleanup) => {
            if (err !== null) {
                return reject(err);
            }
            else {
                cb(tmpPath)
                    .then(() => {
                    resolve();
                })
                    .catch(tmpErr => {
                    reject(tmpErr);
                })
                    .finally(() => {
                    try {
                        cleanup();
                    }
                    catch (err) {
                        (0, vortex_api_1.log)('warn', 'Failed to clean up temp file', { path, err });
                    }
                });
            }
        });
    });
}
async function zip(zipPath, sourcePath) {
    const zipper = new Zip();
    const files = await vortex_api_1.fs.readdirAsync(sourcePath);
    await zipper.add(zipPath, files.map(fileName => path.join(sourcePath, fileName)));
}
async function generateCollectionInfo(api, gameId, collection, progress, error) {
    const state = api.getState();
    const mods = state.persistent.mods[gameId];
    const stagingPath = vortex_api_1.selectors.installPath(state);
    return (0, transformCollection_1.modToCollection)(api, gameId, stagingPath, collection, mods, progress, error);
}
async function writeCollectionToFile(state, info, mod, outputPath) {
    var _a, _b, _c;
    await vortex_api_1.fs.ensureDirWritableAsync(outputPath, () => PromiseBB.resolve());
    await vortex_api_1.fs.writeFileAsync(path.join(outputPath, 'collection.json'), JSON.stringify(info, undefined, 2));
    const stagingPath = vortex_api_1.selectors.installPath(state);
    const modPath = path.join(stagingPath, mod.installationPath);
    try {
        const tweaks = (_a = mod.enabledINITweaks) !== null && _a !== void 0 ? _a : [];
        for (const tweak of tweaks) {
            await vortex_api_1.fs.copyAsync(path.join(modPath, 'INI Tweaks', tweak), path.join(outputPath, 'INI Tweaks', tweak));
        }
    }
    catch (err) {
        if (err.code !== 'ENOENT') {
            throw err;
        }
    }
    await vortex_api_1.fs.copyAsync(path.join(modPath, constants_1.BUNDLED_PATH), path.join(outputPath, constants_1.BUNDLED_PATH));
    await vortex_api_1.fs.copyAsync(path.join(modPath, constants_1.PATCHES_PATH), path.join(outputPath, constants_1.PATCHES_PATH));
    const zipPath = path.join(modPath, 'export', `collection_${(_c = (_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.version) !== null && _c !== void 0 ? _c : '0'}.7z`);
    try {
        await vortex_api_1.fs.removeAsync(zipPath);
    }
    catch (err) {
        if (err.code !== 'ENOENT') {
            throw err;
        }
    }
    await zip(zipPath, outputPath);
    await vortex_api_1.fs.removeAsync(outputPath);
    return zipPath;
}
function filterInfoModSource(source) {
    return _.omit(source, ['instructions', 'fileSize', 'tag']);
}
function filterInfoMod(mod) {
    const res = _.omit(mod, ['hashes', 'choices', 'patches', 'details', 'instructions', 'phase', 'fileOverrides']);
    res.source = filterInfoModSource(res.source);
    return res;
}
function filterInfo(input) {
    const info = _.omit(input.info, ['installInstructions']);
    return {
        info,
        mods: input.mods.map(mod => filterInfoMod(mod)),
    };
}
async function queryErrorsContinue(api, errors) {
    const res = await api.showDialog('error', 'Errors creating collection', {
        text: 'There were errors creating the collection, do you want to proceed anyway?',
        message: errors.map(err => api.translate(err.message, { replace: err.replace })).join('\n'),
    }, [
        { label: 'Cancel' },
        { label: 'Continue' },
    ]);
    if (res.action === 'Cancel') {
        throw new vortex_api_1.util.UserCanceled();
    }
}
function renderGraphLocateError(api, gameId, modId, det) {
    var _a, _b, _c;
    const t = api.translate;
    const state = api.getState();
    const mods = state.persistent.mods[gameId];
    switch (det.attribute) {
        case 'modId': {
            const missingMod = Object.values(mods).find(iter => { var _a, _b, _c; return ((_c = (_b = (_a = iter.attributes) === null || _a === void 0 ? void 0 : _a.modId) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) === det.value.toString(); });
            if (missingMod !== undefined) {
                return t('Mod not found on nexusmods.com: {{modName}} (modId: {{modId}}), '
                    + 'it may have been removed.', { replace: {
                        modName: vortex_api_1.util.renderModName(missingMod),
                        modId: det.value,
                    } });
            }
            else {
                return t('Mod with id {{modId}} not found', { replace: { modId: det.value } });
            }
        }
        case 'fileId': {
            const missingMod = Object.values(mods).find(iter => { var _a, _b, _c; return ((_c = (_b = (_a = iter.attributes) === null || _a === void 0 ? void 0 : _a.fileId) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) === det.value.toString(); });
            if (missingMod !== undefined) {
                return t('Mod not found on nexusmods.com: {{modName}} '
                    + '(modId: {{modId}}, fileId: {{fileId}}), '
                    + 'it may have been removed.', { replace: {
                        modName: vortex_api_1.util.renderModName(missingMod, { version: true }),
                        modId: (_b = (_a = missingMod.attributes) === null || _a === void 0 ? void 0 : _a.modId) !== null && _b !== void 0 ? _b : 'Unknown',
                        fileId: (_c = missingMod.attributes) === null || _c === void 0 ? void 0 : _c.fileId,
                    } });
            }
            else {
                return t('Mod with file id {{fileId}} not found', { replace: { fileId: det.value } });
            }
        }
        default: {
            return det.message;
        }
    }
}
function renderGraphErrorFallback(message, det) {
    return det.message || message;
}
function renderGraphErrorDetail(api, gameId, modId, message, det) {
    if ((det.type === 'LOCATE_ERROR') && !!det.value) {
        return renderGraphLocateError(api, gameId, modId, det);
    }
    else {
        return renderGraphErrorFallback(message, det);
    }
}
async function doExportToAPI(api, gameId, modId, uploaderName) {
    var _a;
    const state = api.store.getState();
    const mod = state.persistent.mods[gameId][modId];
    const { progress, progressEnd } = (0, util_1.makeProgressFunction)(api);
    const errors = [];
    let mayIgnore = true;
    const onError = (message, replace, allowIgnore) => {
        errors.push({ message, replace });
        mayIgnore && (mayIgnore = allowIgnore);
    };
    let info;
    let collectionId;
    let collectionSlug;
    let revisionNumber;
    try {
        info = await generateCollectionInfo(api, gameId, mod, progress, onError);
        if (errors.length > 0) {
            if (mayIgnore) {
                await queryErrorsContinue(api, errors);
            }
            else {
                throw new vortex_api_1.util.UserCanceled();
            }
        }
        await withTmpDir(async (tmpPath) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const filePath = await writeCollectionToFile(state, info, mod, tmpPath);
            collectionId = (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.collectionId) !== null && _b !== void 0 ? _b : undefined;
            const modUploader = (_d = (_c = mod.attributes) === null || _c === void 0 ? void 0 : _c.uploader) !== null && _d !== void 0 ? _d : (_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.author;
            if ((collectionId !== undefined) && (modUploader !== uploaderName)) {
                (0, vortex_api_1.log)('info', 'user doesn\'t match original author, creating new collection');
                collectionId = undefined;
            }
            const result = await vortex_api_1.util.toPromise(cb => api.events.emit('submit-collection', filterInfo(info), filePath, collectionId, cb));
            collectionId = result.collection.id;
            collectionSlug = result.collection.slug;
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'collectionId', collectionId));
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'collectionSlug', result.collection.slug));
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'source', 'nexus'));
            const revisionId = (_g = (_f = result.revision) === null || _f === void 0 ? void 0 : _f.id) !== null && _g !== void 0 ? _g : result['revisionId'];
            revisionNumber = (_j = (_h = result.revision) === null || _h === void 0 ? void 0 : _h.revisionNumber) !== null && _j !== void 0 ? _j : result['revisionNumber'];
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'revisionId', revisionId));
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'revisionNumber', revisionNumber));
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'version', ((revisionNumber !== null && revisionNumber !== void 0 ? revisionNumber : 0) + 1).toString()));
        });
        progressEnd();
    }
    catch (err) {
        progressEnd();
        if (err.name === 'ModFileNotFound') {
            const file = info.mods.find(iter => iter.source.fileId === err.fileId);
            api.sendNotification({
                type: 'error',
                title: 'The server can\'t find one of the files in the collection, '
                    + 'are mod id and file id for it set correctly?',
                message: file !== undefined ? file.name : `id: ${err.fileId}`,
            });
            throw new vortex_api_1.util.ProcessCanceled('Mod file not found');
        }
        else if (err.constructor.name === 'ParameterInvalid') {
            api.sendNotification({
                type: 'error',
                title: 'The server rejected this collection',
                message: err.message || '<No reason given>',
            });
            throw new vortex_api_1.util.ProcessCanceled('collection rejected');
        }
        else if (err.constructor.name === 'GraphError') {
            const message = err.message;
            const details = (_a = err['details']) !== null && _a !== void 0 ? _a : [];
            api.sendNotification({
                type: 'error',
                message: 'The server rejected this collection',
                actions: [
                    { title: 'More', action: () => {
                            api.showDialog('error', 'The server rejected this collection', {
                                text: details.length === 0 ? message : details.map(detail => renderGraphErrorDetail(api, gameId, modId, message, detail)).join('\n'),
                            }, [
                                { label: 'Close' },
                            ]);
                        } },
                ],
            });
            throw new vortex_api_1.util.ProcessCanceled('collection rejected');
        }
        else if (err instanceof vortex_api_1.util.ProcessCanceled) {
            api.showErrorNotification('Failed to upload collection', err, { allowReport: false });
        }
        else {
            throw err;
        }
    }
    return { slug: collectionSlug, revisionNumber };
}
exports.doExportToAPI = doExportToAPI;
async function doExportToFile(api, gameId, modId) {
    const state = api.store.getState();
    const mod = state.persistent.mods[gameId][modId];
    const { progress, progressEnd } = (0, util_1.makeProgressFunction)(api);
    const errors = [];
    const onError = (message, replace) => {
        errors.push({ message, replace });
    };
    try {
        const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
        const modPath = path.join(stagingPath, mod.installationPath);
        const outputPath = path.join(modPath, 'build');
        const info = await generateCollectionInfo(api, gameId, mod, progress, onError);
        const zipPath = await writeCollectionToFile(state, info, mod, outputPath);
        const dialogActions = [
            {
                title: 'Open', action: () => {
                    vortex_api_1.util.opn(path.join(stagingPath, mod.installationPath, 'export')).catch(() => null);
                },
            },
        ];
        if (errors.length > 0) {
            const li = (input) => `[*]${input}`;
            dialogActions.unshift({
                title: 'Errors',
                action: () => {
                    api.showDialog('error', 'Collection Export Errors', {
                        bbcode: '[list]'
                            + errors.map(err => li(api.translate(err.message, { replace: err.replace })))
                            + '[/list]',
                    }, [
                        { label: 'Close' },
                    ]);
                },
            });
        }
        api.sendNotification({
            id: 'collection-exported',
            title: errors.length > 0 ? 'Collection exported, there were errors' : 'Collection exported',
            message: zipPath,
            type: errors.length > 0 ? 'warning' : 'success',
            actions: dialogActions,
        });
    }
    catch (err) {
        api.showErrorNotification('Failed to export collection', err);
    }
    progressEnd();
}
exports.doExportToFile = doExportToFile;


/***/ }),

/***/ "./src/collectionInstall.ts":
/*!**********************************!*\
  !*** ./src/collectionInstall.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.postprocessCollection = exports.makeInstall = exports.testSupported = void 0;
const extension_1 = __webpack_require__(/*! ./util/extension */ "./src/util/extension.ts");
const gameSupport_1 = __webpack_require__(/*! ./util/gameSupport */ "./src/util/gameSupport/index.ts");
const transformCollection_1 = __webpack_require__(/*! ./util/transformCollection */ "./src/util/transformCollection.ts");
const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
const _ = __webpack_require__(/*! lodash */ "lodash");
const path = __webpack_require__(/*! path */ "path");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const importCollection_1 = __webpack_require__(/*! ./util/importCollection */ "./src/util/importCollection.ts");
const collectionConfig_1 = __webpack_require__(/*! ./util/collectionConfig */ "./src/util/collectionConfig/index.ts");
async function testSupported(files, gameId) {
    return {
        supported: files.indexOf('collection.json') !== -1,
        requiredFiles: ['collection.json'],
    };
}
exports.testSupported = testSupported;
function makeInstall(api) {
    return async (files, destinationPath, gameId, progressDelegate) => {
        var _a;
        const collection = await (0, importCollection_1.readCollection)(api, path.join(destinationPath, 'collection.json'));
        const config = await (0, collectionConfig_1.parseConfig)({ collection, gameId });
        const configInstructions = Object.entries(config).reduce((accum, [key, value]) => {
            const instr = { type: 'attribute', key, value, };
            accum.push(instr);
            return accum;
        }, []);
        const filesToCopy = files
            .filter(filePath => !filePath.endsWith(path.sep)
            && (filePath.split(path.sep)[0] !== constants_1.BUNDLED_PATH));
        const bundled = files
            .filter(filePath => !filePath.endsWith(path.sep)
            && (filePath.split(path.sep)[0] === constants_1.BUNDLED_PATH));
        const knownGames = vortex_api_1.selectors.knownGames(api.getState());
        const state = api.getState();
        const downloads = Object.values(state.persistent.downloads.files).reverse();
        const collectionDownload = downloads.find(down => (down.localPath !== undefined)
            && (path.basename(destinationPath, '.installing')
                === path.basename(down.localPath, path.extname(down.localPath))));
        return Promise.resolve({
            instructions: [
                {
                    type: 'attribute',
                    key: 'customFileName',
                    value: (((_a = collectionDownload === null || collectionDownload === void 0 ? void 0 : collectionDownload.modInfo) === null || _a === void 0 ? void 0 : _a.name) !== undefined)
                        ? collectionDownload.modInfo.name
                        : collection.info.name,
                },
                {
                    type: 'attribute',
                    key: 'installInstructions',
                    value: collection.info.installInstructions,
                },
                ...configInstructions,
                {
                    type: 'setmodtype',
                    value: constants_1.MOD_TYPE,
                },
                ...filesToCopy.map(filePath => ({
                    type: 'copy',
                    source: filePath,
                    destination: filePath,
                })),
                ...bundled.map(filePath => ({
                    type: 'copy',
                    source: filePath,
                    destination: filePath,
                })),
                ...collection.mods.map(mod => ({
                    type: 'rule',
                    rule: (0, transformCollection_1.collectionModToRule)(knownGames, mod),
                })),
            ],
        });
    };
}
exports.makeInstall = makeInstall;
function applyCollectionRules(api, gameId, collection, mods) {
    var _a;
    const batch = ((_a = collection.modRules) !== null && _a !== void 0 ? _a : []).reduce((prev, rule) => {
        var _a, _b;
        const sourceMod = vortex_api_1.util.findModByRef(rule.source, mods);
        if (sourceMod !== undefined) {
            const destMod = vortex_api_1.util.findModByRef(rule.reference, mods);
            let exists = false;
            if (destMod !== undefined) {
                const exSourceRules = ((_a = sourceMod.rules) !== null && _a !== void 0 ? _a : []).filter(iter => ['before', 'after'].includes(iter.type)
                    && vortex_api_1.util.testModReference(destMod, iter.reference));
                exSourceRules.forEach(exSourceRule => {
                    const copy = JSON.parse(JSON.stringify(exSourceRule));
                    delete copy.reference.idHint;
                    if (!exists && _.isEqual(copy, rule)) {
                        exists = true;
                    }
                    else {
                        prev.push(vortex_api_1.actions.removeModRule(gameId, sourceMod.id, exSourceRule));
                    }
                });
                const exDestRules = ((_b = destMod.rules) !== null && _b !== void 0 ? _b : []).filter(iter => ['before', 'after'].includes(iter.type)
                    && vortex_api_1.util.testModReference(sourceMod, iter.reference));
                exDestRules.forEach(exDestRule => {
                    prev.push(vortex_api_1.actions.removeModRule(gameId, destMod.id, exDestRule));
                });
                rule.reference = {
                    id: destMod.id,
                    idHint: destMod.id,
                    archiveId: destMod.archiveId,
                };
            }
            if (!exists) {
                (0, vortex_api_1.log)('info', 'add collection rule', { gameId, sourceMod: sourceMod.id, rule: JSON.stringify(rule) });
                prev.push(vortex_api_1.actions.addModRule(gameId, sourceMod.id, rule));
            }
        }
        return prev;
    }, []);
    vortex_api_1.util.batchDispatch(api.store, batch);
}
async function postprocessCollection(api, gameId, collectionMod, collection, mods) {
    (0, vortex_api_1.log)('info', 'postprocess collection');
    applyCollectionRules(api, gameId, collection, mods);
    try {
        await vortex_api_1.util.toPromise(cb => api.events.emit('deploy-mods', cb));
    }
    catch (err) {
        (0, vortex_api_1.log)('warn', 'Failed to deploy during collection post processing');
    }
    const exts = (0, extension_1.findExtensions)(api.getState(), gameId);
    for (const ext of exts) {
        await ext.parse(gameId, collection, collectionMod);
    }
    await (0, gameSupport_1.parseGameSpecifics)(api, gameId, collection, collectionMod);
}
exports.postprocessCollection = postprocessCollection;


/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.INSTRUCTIONS_PLACEHOLDER = exports.DEFAULT_INSTRUCTIONS = exports.CACHE_LRU_COUNT = exports.CACHE_EXPIRE_MS = exports.PATCH_OVERHEAD = exports.MAX_PATCH_SIZE = exports.DELAY_FIRST_VOTE_REQUEST = exports.TIME_BEFORE_VOTE = exports.OPTIONAL_TWEAK_PREFIX = exports.INI_TWEAKS_PATH = exports.MAX_COLLECTION_NAME_LENGTH = exports.MIN_COLLECTION_NAME_LENGTH = exports.INSTALLING_NOTIFICATION_ID = exports.PATCHES_PATH = exports.BUNDLED_PATH = exports.ADULT_CONTENT_URL = exports.TOS_URL = exports.PREMIUM_PATH = exports.NEXUS_PROTOCOL = exports.NEXUS_BASE_GAMES_URL = exports.NEXUS_NEXT_URL = exports.NEXUS_BASE_URL = exports.NEXUS_NEXT_SUBDOMAIN = exports.NEXUS_FLAMEWORK_SUBDOMAIN = exports.NEXUS_DOMAIN = exports.AVATAR_FALLBACK = exports.AUTHOR_UNKNOWN = exports.NAMESPACE = exports.MOD_TYPE = void 0;
exports.MOD_TYPE = 'collection';
exports.NAMESPACE = 'collection';
exports.AUTHOR_UNKNOWN = '<Unknown User>';
exports.AVATAR_FALLBACK = 'assets/images/noavatar.png';
exports.NEXUS_DOMAIN = process.env['NEXUS_DOMAIN'] || 'nexusmods.com';
exports.NEXUS_FLAMEWORK_SUBDOMAIN = process.env['FLAMEWORK_SUBDOMAIN'] || 'www';
exports.NEXUS_NEXT_SUBDOMAIN = process.env['NEXT_SUBDOMAIN'] || 'next';
exports.NEXUS_BASE_URL = process.env['NEXUS_BASE_URL'] || `https://${exports.NEXUS_FLAMEWORK_SUBDOMAIN}.${exports.NEXUS_DOMAIN}`;
exports.NEXUS_NEXT_URL = process.env['NEXUS_NEXT_URL'] || `https://${exports.NEXUS_DOMAIN}/games`;
exports.NEXUS_BASE_GAMES_URL = process.env['NEXUS_BASE_GAMES_URL'] || `https://${exports.NEXUS_FLAMEWORK_SUBDOMAIN}.${exports.NEXUS_DOMAIN}/games`;
exports.NEXUS_PROTOCOL = 'https:';
exports.PREMIUM_PATH = ['account', 'billing', 'premium'];
exports.TOS_URL = 'https://help.nexusmods.com/article/115-guidelines-for-collections';
exports.ADULT_CONTENT_URL = 'https://help.nexusmods.com/article/19-adult-content-guidelines';
exports.BUNDLED_PATH = 'bundled';
exports.PATCHES_PATH = 'patches';
exports.INSTALLING_NOTIFICATION_ID = 'installing-collection-';
exports.MIN_COLLECTION_NAME_LENGTH = 3;
exports.MAX_COLLECTION_NAME_LENGTH = 36;
exports.INI_TWEAKS_PATH = 'Ini Tweaks';
exports.OPTIONAL_TWEAK_PREFIX = '(optional).';
exports.TIME_BEFORE_VOTE = 48 * 60 * 60 * 1000;
exports.DELAY_FIRST_VOTE_REQUEST = 1 * 60 * 1000;
exports.MAX_PATCH_SIZE = 0.2;
exports.PATCH_OVERHEAD = 130;
exports.CACHE_EXPIRE_MS = 1 * 60 * 60 * 1000;
exports.CACHE_LRU_COUNT = 50;
exports.DEFAULT_INSTRUCTIONS = 'No additional instructions.';
exports.INSTRUCTIONS_PLACEHOLDER = 'Enter instructions here (Markdown supported - Links, Bold, Italics)';


/***/ }),

/***/ "./src/eventHandlers.ts":
/*!******************************!*\
  !*** ./src/eventHandlers.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.onCollectionUpdate = void 0;
const Bluebird = __webpack_require__(/*! bluebird */ "bluebird");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const InstallChangelogDialog_1 = __webpack_require__(/*! ./views/InstallDialog/InstallChangelogDialog */ "./src/views/InstallDialog/InstallChangelogDialog.tsx");
async function collectionUpdate(api, downloadGameId, collectionSlug, revisionNumber, oldModId) {
    var _a, _b, _c;
    try {
        const latest = (await api.emitAndAwait('get-nexus-collection-revision', collectionSlug, parseInt(revisionNumber, 10)))[0];
        if (latest === undefined) {
            throw new vortex_api_1.util.ProcessCanceled(`Server returned no info on collection ${collectionSlug}, revision ${revisionNumber}`);
        }
        const collection = latest.collection;
        if (collectionSlug !== collection.slug) {
            throw new Error(`Invalid collection "${collectionSlug}"`);
        }
        const state = api.getState();
        const gameMode = vortex_api_1.selectors.activeGameId(state);
        const oldMod = state.persistent.mods[gameMode][oldModId];
        if (!!((_a = latest.collectionChangelog) === null || _a === void 0 ? void 0 : _a.description) && (oldMod !== undefined)) {
            await (0, InstallChangelogDialog_1.default)(oldMod, gameMode, latest);
        }
        const modInfo = {
            game: downloadGameId,
            source: 'nexus',
            name: collection === null || collection === void 0 ? void 0 : collection.name,
            nexus: {
                ids: {
                    gameId: downloadGameId,
                    collectionId: collection.id,
                    collectionSlug,
                    revisionId: latest.id,
                    revisionNumber: latest.revisionNumber,
                },
                revisionInfo: latest,
            },
        };
        const downloadURLs = (await api.emitAndAwait('resolve-collection-url', latest.downloadLink))[0];
        let dlId;
        try {
            const fileName = vortex_api_1.util.sanitizeFilename(collection.name);
            dlId = await vortex_api_1.util.toPromise(cb => api.events.emit('start-download', downloadURLs.map(iter => iter.URI), modInfo, fileName + `-rev${latest.revisionNumber}.7z`, cb, 'never', { allowInstall: false }));
        }
        catch (err) {
            if (err.name === 'AlreadyDownloaded') {
                const { files } = api.getState().persistent.downloads;
                dlId = Object.keys(files).find(iter => files[iter].localPath === err.fileName);
            }
            if (dlId === undefined) {
                throw err;
            }
        }
        api.events.emit('analytics-track-click-event', 'Collections', 'Update Collection');
        const oldRules = (_b = oldMod === null || oldMod === void 0 ? void 0 : oldMod.rules) !== null && _b !== void 0 ? _b : [];
        const newModId = await vortex_api_1.util.toPromise(cb => api.events.emit('start-install-download', dlId, undefined, cb));
        const mods = api.getState().persistent.mods[gameMode];
        if (mods[newModId] === undefined) {
            throw new vortex_api_1.util.ProcessCanceled('Download failed, update archive not found');
        }
        const candidates = oldRules
            .filter(rule => ['requires', 'recommends'].includes(rule.type))
            .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
            .filter(mod => {
            var _a;
            return (mod !== undefined)
                && (((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a['installedAsDependency']) === true);
        });
        const notCandidates = Object.values(mods)
            .filter(mod => !candidates.includes(mod) && ![oldModId, newModId].includes(mod.id));
        const references = (rules, mod) => (rules !== null && rules !== void 0 ? rules : []).find(rule => ['requires', 'recommends'].includes(rule.type)
            && vortex_api_1.util.testModReference(mod, rule.reference)) !== undefined;
        const obsolete = candidates
            .filter(mod => !references(mods[newModId].rules, mod))
            .filter(mod => notCandidates
            .find(other => references(other.rules, mod)) === undefined);
        let ops = { remove: [], keep: [] };
        if (obsolete.length > 0) {
            const collectionName = (_c = collection === null || collection === void 0 ? void 0 : collection.name) !== null && _c !== void 0 ? _c : vortex_api_1.util.renderModName(oldMod);
            const result = await api.showDialog('question', 'Remove mods from old revision?', {
                text: 'There are {{count}} mods installed that are not present in the latest '
                    + 'revision of "{{collectionName}}". It is recommended that you remove the '
                    + 'unused mods to avoid compatibility issues going forward. '
                    + 'If you choose to keep the mods installed they will no longer be associated '
                    + 'with this Collection and will be managed as if they have been installed '
                    + 'individually. Would you like to remove the old mods now?',
                parameters: {
                    count: obsolete.length,
                    collectionName,
                },
            }, [
                { label: 'Keep All' },
                { label: 'Review Mods' },
                { label: 'Remove All' },
            ]);
            if (result.action === 'Keep All') {
                ops.keep = obsolete.map(mod => mod.id);
            }
            else if (result.action === 'Remove All') {
                ops.remove = obsolete.map(mod => mod.id);
            }
            else {
                const reviewResult = await api.showDialog('question', 'Remove mods from old revision?', {
                    text: 'The following mods are not present in the latest revision of '
                        + '"{{collectionName}}". Please select the ones to remove.',
                    parameters: {
                        collectionName,
                    },
                    checkboxes: obsolete.map(mod => ({ id: mod.id, text: vortex_api_1.util.renderModName(mod), value: true })),
                }, [
                    { label: 'Keep All' },
                    { label: 'Remove selected' },
                ]);
                if (reviewResult.action === 'Keep All') {
                    ops.keep = obsolete.map(mod => mod.id);
                }
                else {
                    ops = Object.keys(reviewResult.input).reduce((prev, value) => {
                        if (reviewResult.input[value]) {
                            prev.remove.push(value);
                        }
                        else {
                            prev.keep.push(value);
                        }
                        return prev;
                    }, { remove: [], keep: [] });
                }
            }
        }
        vortex_api_1.util.batchDispatch(api.store, ops.keep.map(modId => vortex_api_1.actions.setModAttribute(gameMode, modId, 'installedAsDependency', false)));
        await vortex_api_1.util.toPromise(cb => api.events.emit('remove-mods', gameMode, [oldModId, ...ops.remove], cb, { incomplete: true, ignoreInstalling: true }));
    }
    catch (err) {
        if (!(err instanceof vortex_api_1.util.UserCanceled)) {
            api.showErrorNotification('Failed to download collection', err, {
                allowReport: !(err instanceof vortex_api_1.util.ProcessCanceled),
                warning: err instanceof vortex_api_1.util.ProcessCanceled,
            });
        }
    }
}
function onCollectionUpdate(api, driver) {
    return (gameId, collectionSlug, revisionNumber, source, oldModId, cb) => {
        if ((source !== 'nexus') || (collectionSlug === undefined) || (revisionNumber === undefined)) {
            return;
        }
        driver.prepare(() => Bluebird.resolve(collectionUpdate(api, gameId, collectionSlug, revisionNumber.toString(), oldModId))
            .then(() => {
            cb === null || cb === void 0 ? void 0 : cb(null);
        })
            .catch(err => {
            if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                api.showErrorNotification('Failed to update collection', err);
            }
            cb === null || cb === void 0 ? void 0 : cb(err);
        }));
    };
}
exports.onCollectionUpdate = onCollectionUpdate;


/***/ }),

/***/ "./src/initweaks.ts":
/*!**************************!*\
  !*** ./src/initweaks.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.importTweaks = exports.getEnabledTweaks = void 0;
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const IniTweaks_1 = __webpack_require__(/*! ./views/IniTweaks */ "./src/views/IniTweaks.tsx");
const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
const gameSupport = {
    skyrim: {
        gameSettingsFiles: ['Skyrim.ini', 'SkyrimPrefs.ini'],
    },
    skyrimse: {
        gameSettingsFiles: ['Skyrim.ini', 'SkyrimPrefs.ini', 'SkyrimCustom.ini'],
    },
    skyrimvr: {
        gameSettingsFiles: ['Skyrim.ini', 'SkyrimPrefs.ini'],
    },
    fallout3: {
        gameSettingsFiles: ['Fallout.ini', 'FalloutPrefs.ini', 'FalloutCustom.ini'],
    },
    fallout4: {
        gameSettingsFiles: ['Fallout4.ini', 'Fallout4Prefs.ini', 'Fallout4Custom.ini'],
    },
    fallout4vr: {
        gameSettingsFiles: ['Fallout4Custom.ini', 'Fallout4Prefs.ini'],
    },
    falloutnv: {
        gameSettingsFiles: ['Fallout.ini', 'FalloutPrefs.ini'],
    },
    starfield: {
        gameSettingsFiles: ['StarfieldCustom.ini', 'StarfieldPrefs.ini'],
    },
    oblivion: {
        gameSettingsFiles: ['Oblivion.ini'],
    },
    enderal: {
        gameSettingsFiles: ['Enderal.ini', 'EnderalPrefs.ini'],
    },
    enderalspecialedition: {
        gameSettingsFiles: ['Enderal.ini', 'EnderalPrefs.ini'],
    },
};
function isSupported(gameId) {
    return gameSupport[gameId] !== undefined;
}
function validateFilenameInput(content) {
    const input = content.input[0].value || '';
    if ((input.length < 2) || !vortex_api_1.util.isFilenameValid(input)) {
        return [{
                actions: ['Confirm'],
                errorText: 'Has to be a valid file name',
                id: content.input[0].id,
            }];
    }
    else {
        return [];
    }
}
function TweakListWrap(api, prop) {
    return React.createElement(IniTweaks_1.default, {
        ...prop,
        settingsFiles: gameSupport[prop.gameId].gameSettingsFiles,
        onRefreshTweaks: genRefreshTweaks,
        onAddIniTweak: (modPath, settingsFiles) => genAddIniTweak(api, modPath, settingsFiles),
        onRemoveIniTweak: (modPath, tweak) => genRemoveIniTweak(api, prop, modPath, tweak),
    });
}
async function getTweaks(dirPath) {
    try {
        const tweaks = await vortex_api_1.fs.readdirAsync(dirPath);
        return tweaks;
    }
    catch (err) {
        (0, vortex_api_1.log)('debug', 'failed to find tweaks', err);
        return [];
    }
}
function getEnabledTweaks(api, gameId, modId) {
    const state = api.getState();
    const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', gameId], {});
    const tweaks = vortex_api_1.util.getSafe(mods[modId], ['enabledINITweaks'], []);
    return tweaks;
}
exports.getEnabledTweaks = getEnabledTweaks;
async function importTweaks(api, profile, mods, destCollection, force) {
    var _a;
    const tweaks = await getAllTweaks(api, profile, mods);
    const state = api.getState();
    const stagingFolder = vortex_api_1.selectors.installPathForGame(state, profile.gameId);
    const destTweakDirPath = path.join(stagingFolder, destCollection.id, constants_1.INI_TWEAKS_PATH);
    const batchedActions = [];
    const existingTweaks = (_a = destCollection.enabledINITweaks) !== null && _a !== void 0 ? _a : [];
    await vortex_api_1.fs.ensureDirWritableAsync(destTweakDirPath);
    for (const tweak of tweaks) {
        if (force !== true && existingTweaks.includes(tweak.fileName)) {
            continue;
        }
        try {
            const dest = path.join(destTweakDirPath, path.basename(tweak.sourcePath));
            await vortex_api_1.fs.copyAsync(tweak.sourcePath, dest, { overwrite: true });
            batchedActions.push(vortex_api_1.actions.setINITweakEnabled(profile.gameId, destCollection.id, tweak.fileName, true));
        }
        catch (err) {
            (0, vortex_api_1.log)('error', 'Unable to import tweak', err);
            continue;
        }
    }
    if (batchedActions.length > 0) {
        vortex_api_1.util.batchDispatch(api.store, batchedActions);
    }
    return Promise.resolve(tweaks);
}
exports.importTweaks = importTweaks;
async function getAllTweaks(api, profile, mods) {
    const state = api.getState();
    if ((profile === null || profile === void 0 ? void 0 : profile.gameId) === undefined) {
        return Promise.resolve([]);
    }
    const installationPath = vortex_api_1.selectors.installPathForGame(state, profile.gameId);
    const enabledMods = Object.keys(mods)
        .filter(id => vortex_api_1.util.getSafe(profile.modState, [id, 'enabled'], false)
        && (mods[id].installationPath !== undefined));
    const validTweaks = [];
    for (const modId of enabledMods) {
        const modPath = path.join(installationPath, mods[modId].installationPath);
        const tweaks = getEnabledTweaks(api, profile.gameId, modId);
        if (tweaks.length === 0) {
            continue;
        }
        for (const tweak of tweaks) {
            try {
                const tweakPath = path.join(modPath, constants_1.INI_TWEAKS_PATH, tweak);
                await vortex_api_1.fs.statAsync(tweakPath);
                validTweaks.push({
                    enabled: true,
                    sourcePath: tweakPath,
                    fileName: tweak,
                });
            }
            catch (err) {
                continue;
            }
        }
    }
    return Promise.resolve(validTweaks);
}
async function removeOptionalPrefix(filePath) {
    try {
        if (filePath.indexOf(constants_1.OPTIONAL_TWEAK_PREFIX) !== -1) {
            const trimmedFilePath = filePath.replace(constants_1.OPTIONAL_TWEAK_PREFIX, '');
            await vortex_api_1.fs.removeAsync(trimmedFilePath).catch(err => null);
            await vortex_api_1.fs.linkAsync(filePath, trimmedFilePath);
            await vortex_api_1.fs.removeAsync(filePath);
            return Promise.resolve(trimmedFilePath);
        }
        else {
            return Promise.resolve(filePath);
        }
    }
    catch (err) {
        (0, vortex_api_1.log)('error', 'failed to remove optional prefix from ini file', { error: err, filePath });
        return Promise.resolve(filePath);
    }
}
async function genRefreshTweaks(modPath) {
    const tweakPath = path.join(modPath, constants_1.INI_TWEAKS_PATH);
    const tweaks = await getTweaks(tweakPath);
    return tweaks.reduce(async (accumP, twk) => {
        const accum = await accumP;
        const filePath = await removeOptionalPrefix(path.join(tweakPath, twk));
        accum.push({ fileName: path.basename(filePath) });
        return accum;
    }, Promise.resolve([]));
}
async function genRemoveIniTweak(api, props, modPath, tweak) {
    return api.showDialog('question', 'Remove INI Tweak', {
        text: 'You are about to remove an INI tweak "{{fileName}}" from the collection. Are you sure you wish to proceed ?',
        parameters: { fileName: tweak.fileName },
    }, [
        { label: 'Cancel' },
        { label: 'Remove' },
    ]).then(async (res) => {
        if (res.action === 'Remove') {
            try {
                const tweaks = await genRefreshTweaks(modPath);
                const targetTweak = tweaks.find(twk => twk.fileName === tweak.fileName);
                const tweakPath = path.join(modPath, constants_1.INI_TWEAKS_PATH, targetTweak.fileName);
                await vortex_api_1.fs.removeAsync(tweakPath);
                const { gameId, collection } = props;
                api.store.dispatch(vortex_api_1.actions.setINITweakEnabled(gameId, collection.id, targetTweak.fileName, false));
            }
            catch (err) {
                if (err.code === 'ENOENT') {
                    const { gameId, collection } = props;
                    api.store.dispatch(vortex_api_1.actions.setINITweakEnabled(gameId, collection.id, tweak.fileName, false));
                    return;
                }
                api.showErrorNotification('Failed to remove INI tweak', err, { allowReport: ['EPERM'].includes(err.code) });
            }
        }
    });
}
async function genAddIniTweak(api, modPath, settingsFiles) {
    return api.showDialog('question', 'Name', {
        text: 'Please enter a name for the ini tweak',
        input: [
            { id: 'name', type: 'text' },
        ],
        choices: settingsFiles.map((fileName, idx) => ({
            text: fileName,
            value: idx === 0,
            id: fileName,
        })),
        condition: validateFilenameInput,
    }, [
        { label: 'Cancel' },
        { label: 'Confirm' },
    ]).then(res => {
        if (res.action === 'Confirm') {
            const tweaksPath = path.join(modPath, constants_1.INI_TWEAKS_PATH);
            let selectedIni = Object.keys(res.input)
                .find(key => (path.extname(key) === '.ini') && res.input[key] === true);
            if (selectedIni === undefined) {
                return Promise.reject(new Error('No ini file selected'));
            }
            selectedIni = path.basename(selectedIni, path.extname(selectedIni));
            const fileName = `${res.input['name']} [${selectedIni}].ini`;
            return vortex_api_1.fs.ensureDirWritableAsync(tweaksPath, () => Promise.resolve())
                .then(() => vortex_api_1.fs.writeFileAsync(path.join(tweaksPath, fileName), ''));
        }
        else {
            return Promise.resolve();
        }
    });
}
async function genEnableIniTweaks(api, gameId, mod) {
    const stagingPath = vortex_api_1.selectors.installPathForGame(api.getState(), gameId);
    const modPath = path.join(stagingPath, mod.installationPath);
    try {
        const tweaks = await genRefreshTweaks(modPath);
        const batched = tweaks.map(req => vortex_api_1.actions.setINITweakEnabled(gameId, mod.id, req.fileName, true));
        if (batched.length > 0) {
            vortex_api_1.util.batchDispatch(api.store, batched);
        }
    }
    catch (err) {
        if (err.code !== 'ENOENT') {
            api.showErrorNotification('Failed to enable collection ini tweaks', err);
        }
    }
}
function init(context) {
    context.optional.registerCollectionFeature('ini-tweaks', () => Promise.resolve({}), (gameId, collection, mod) => genEnableIniTweaks(context.api, gameId, mod), () => Promise.resolve(), () => 'INI Tweaks', (state, gameId) => isSupported(gameId), (prop) => TweakListWrap(context.api, prop));
}
exports["default"] = init;


/***/ }),

/***/ "./src/reducers/persistent.ts":
/*!************************************!*\
  !*** ./src/reducers/persistent.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const actions = __webpack_require__(/*! ../actions/persistent */ "./src/actions/persistent.ts");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const persistentReducer = {
    reducers: {
        [actions.updateCollectionInfo]: (state, payload) => {
            const { collectionId, collectionInfo, timestamp } = payload;
            if (collectionInfo === undefined) {
                return vortex_api_1.util.deleteOrNop(state, ['collections', collectionId]);
            }
            else {
                return vortex_api_1.util.setSafe(state, ['collections', collectionId], { timestamp, info: collectionInfo });
            }
        },
        [actions.updateRevisionInfo]: (state, payload) => {
            const { revisionId, revisionInfo, timestamp } = payload;
            if (revisionInfo === undefined) {
                return vortex_api_1.util.deleteOrNop(state, ['revisions', 'revisionId']);
            }
            else {
                return vortex_api_1.util.setSafe(state, ['revisions', revisionId], { timestamp, info: revisionInfo });
            }
        },
        [actions.updateSuccessRate]: (state, payload) => {
            const { revisionId, vote, average, total } = payload;
            const revPath = ['revisions', revisionId, 'info'];
            state = vortex_api_1.util.setSafe(state, [...revPath, 'metadata', 'ratingValue'], vote);
            return vortex_api_1.util.setSafe(state, [...revPath, 'rating'], {
                average,
                total,
            });
        },
        [actions.setPendingVote]: (state, payload) => {
            const { revisionId, collectionSlug, revisionNumber, time } = payload;
            return vortex_api_1.util.setSafe(state, ['pendingVotes', revisionId], {
                collectionSlug, revisionNumber, time
            });
        },
        [actions.clearPendingVote]: (state, payload) => {
            const { revisionId } = payload;
            return vortex_api_1.util.deleteOrNop(state, ['pendingVotes', revisionId]);
        },
    },
    defaults: {
        collections: {},
        revisions: {},
        pendingVotes: {},
    },
};
exports["default"] = persistentReducer;


/***/ }),

/***/ "./src/reducers/session.ts":
/*!*********************************!*\
  !*** ./src/reducers/session.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const actions = __webpack_require__(/*! ../actions/session */ "./src/actions/session.ts");
const sessionReducer = {
    reducers: {
        [actions.startEditCollection]: (state, payload) => {
            const { modId } = payload;
            return vortex_api_1.util.setSafe(state, ['editCollectionId'], modId);
        },
        [actions.startAddModsToCollection]: (state, payload) => {
            const { collectionId } = payload;
            return vortex_api_1.util.setSafe(state, ['addModsId'], collectionId);
        },
        [actions.healthDownvoteDialog]: (state, payload) => {
            const { collectionModId } = payload;
            return vortex_api_1.util.setSafe(state, ['healthDownvoteDialog'], collectionModId);
        }
    },
    defaults: {
        editCollectionId: undefined,
        addModsId: undefined,
        healthDownvoteDialog: undefined,
    },
};
exports["default"] = sessionReducer;


/***/ }),

/***/ "./src/reducers/settings.ts":
/*!**********************************!*\
  !*** ./src/reducers/settings.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const actions = __webpack_require__(/*! ../actions/settings */ "./src/actions/settings.ts");
const settingsReducer = {
    reducers: {
        [actions.setSortAdded]: (state, payload) => {
            const { sorting } = payload;
            return vortex_api_1.util.setSafe(state, ['sortAdded'], sorting);
        },
        [actions.setSortWorkshop]: (state, payload) => {
            const { sorting } = payload;
            return vortex_api_1.util.setSafe(state, ['sortWorkshop'], sorting);
        },
    },
    defaults: {
        sortAdded: 'datedownloaded',
        sortWorkshop: 'recentlyupdated',
    },
};
exports["default"] = settingsReducer;


/***/ }),

/***/ "./src/tools.ts":
/*!**********************!*\
  !*** ./src/tools.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Tools_1 = __webpack_require__(/*! ./views/Tools */ "./src/views/Tools.tsx");
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const shortid_1 = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function ToolsListWrap(prop) {
    return React.createElement(Tools_1.default, {
        ...prop,
    });
}
function convertTools(state, gameId, includedTools) {
    const { tools } = state.settings.gameMode.discovered[gameId];
    const discovery = vortex_api_1.selectors.discoveryByGame(state, gameId);
    return vortex_api_1.util.makeUniqueByKey(includedTools !== null && includedTools !== void 0 ? includedTools : [], item => item)
        .filter(toolId => { var _a, _b; return ((_a = tools[toolId]) === null || _a === void 0 ? void 0 : _a.custom) && !((_b = tools[toolId]) === null || _b === void 0 ? void 0 : _b.hidden); })
        .map(toolId => {
        const tool = tools[toolId];
        const exe = vortex_api_1.util.isChildPath(tool.path, discovery.path)
            ? path.relative(discovery.path, tool.path)
            : tool.path;
        return {
            name: tool.name,
            exe,
            args: tool.parameters,
            env: tool.environment,
            cwd: tool.workingDirectory,
            detach: tool.detach,
            shell: tool.shell,
            onStart: tool.onStart,
        };
    });
}
function generateTools(api, gameId, mod) {
    var _a, _b;
    return {
        tools: convertTools(api.getState(), gameId, (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.includedTools),
    };
}
function normalizePath(input) {
    return path.normalize(input.toUpperCase());
}
function isSameTool(discovery, lhs, rhs) {
    if ((lhs === null || lhs === void 0 ? void 0 : lhs.path) === undefined) {
        return false;
    }
    return (normalizePath(lhs.path) === normalizePath(path.resolve(discovery.path, rhs.exe)))
        || (lhs.name === rhs.name);
}
function updatePaths(tool, gamePath) {
    return {
        ...tool,
        exe: path.isAbsolute(tool.exe)
            ? tool.exe
            : path.join(gamePath, tool.exe),
    };
}
async function cloneTools(api, gameId, tools, from, to) {
    const discovery = vortex_api_1.selectors.discoveryByGame(api.getState(), gameId);
    const knownTools = api.getState().settings.gameMode.discovered[gameId].tools;
    const includedTools = (tools !== null && tools !== void 0 ? tools : []).map(tool => {
        const exePath = path.isAbsolute(tool.exe)
            ? tool.exe
            : path.join(discovery.path, tool.exe);
        return Object.keys(knownTools !== null && knownTools !== void 0 ? knownTools : {})
            .find(iter => (knownTools[iter].custom && !knownTools[iter].hidden)
            && (normalizePath(knownTools[iter].path) === normalizePath(exePath)
                || knownTools[iter].name === tool.name));
    })
        .filter(iter => iter !== undefined);
    const attributes = vortex_api_1.util.setSafe(to.attributes.collection, ['includedTools'], includedTools);
    api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, to.id, 'collection', attributes));
}
async function setUpTools(api, gameId, tools) {
    const knownTools = api.getState().settings.gameMode.discovered[gameId].tools;
    const discovery = vortex_api_1.selectors.discoveryByGame(api.getState(), gameId);
    const addTools = (tools !== null && tools !== void 0 ? tools : [])
        .map(tool => updatePaths(tool, discovery.path))
        .filter(tool => Object.values(knownTools !== null && knownTools !== void 0 ? knownTools : {})
        .find(iter => isSameTool(discovery, iter, tool)) === undefined);
    const addActions = addTools.map(tool => {
        tool.id = (0, shortid_1.generate)();
        return vortex_api_1.actions.addDiscoveredTool(gameId, tool.id, {
            id: tool.id,
            path: tool.exe,
            name: tool.name,
            requiredFiles: [],
            executable: null,
            parameters: tool.args,
            environment: tool.env,
            workingDirectory: tool.cwd,
            shell: tool.shell,
            detach: tool.detach,
            onStart: tool.onStart,
            custom: true,
            hidden: true,
        }, true);
    });
    vortex_api_1.util.batchDispatch(api.store, addActions);
    const notFoundTools = [];
    await Promise.all(addTools.map(async (tool) => {
        try {
            await vortex_api_1.fs.statAsync(tool.exe);
        }
        catch (err) {
            notFoundTools.push(tool.name);
        }
        if (path.extname(tool.exe) === '.exe') {
            const iconPath = vortex_api_1.util.StarterInfo.toolIconRW(gameId, tool.id);
            await vortex_api_1.fs.ensureDirWritableAsync(path.dirname(iconPath), () => Promise.resolve());
            try {
                await vortex_api_1.util['extractExeIcon'](tool.exe, iconPath);
            }
            catch (err) {
                (0, vortex_api_1.log)('warn', 'failed to extract exe icon', { executable: tool.exe, error: err.message });
            }
        }
    }));
    if (notFoundTools.length > 0) {
        await api.showDialog('info', 'Tool not found', {
            text: 'The collection you just installed set up tools to be run from the dashboard, '
                + 'however not all were found locally. '
                + 'It\'s possible that these tools will be available after the next deployment '
                + 'completes, otherwise you may have to edit the configuration for the tool to '
                + 'adjust them to your own setup.',
            message: notFoundTools.join('\n'),
        }, [
            { label: 'Continue' },
        ]);
    }
    vortex_api_1.util.batchDispatch(api.store, addTools.map(tool => vortex_api_1.actions.setToolVisible(gameId, tool.id, true)));
}
function init(context) {
    context.optional.registerCollectionFeature('tools', (gameId, includedMods, mod) => generateTools(context.api, gameId, mod), (gameId, collection, mod) => setUpTools(context.api, gameId, collection['tools']), (gameId, collection, from, to) => cloneTools(context.api, gameId, collection['tools'], from, to), () => 'Tools', (state, gameId) => true, ToolsListWrap);
}
exports["default"] = init;


/***/ }),

/***/ "./src/util/InfoCache.ts":
/*!*******************************!*\
  !*** ./src/util/InfoCache.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const persistent_1 = __webpack_require__(/*! ../actions/persistent */ "./src/actions/persistent.ts");
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
const importCollection_1 = __webpack_require__(/*! ./importCollection */ "./src/util/importCollection.ts");
const path = __webpack_require__(/*! path */ "path");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
class InfoCache {
    constructor(api) {
        this.mCacheRevRequests = {};
        this.mCacheColRequests = {};
        this.mCacheColRules = {};
        this.mApi = api;
    }
    async getCollectionModRules(revisionId, collection, gameId) {
        const cacheId = revisionId !== null && revisionId !== void 0 ? revisionId : collection.id;
        if (this.mCacheColRules[cacheId] === undefined) {
            this.mCacheColRules[cacheId] = this.cacheCollectionModRules(revisionId, collection, gameId);
        }
        return this.mCacheColRules[cacheId];
    }
    async getCollectionInfo(slug, forceFetch) {
        var _a, _b;
        const { store } = this.mApi;
        if (slug === undefined) {
            return;
        }
        const collections = (_a = store.getState().persistent.collections.collections) !== null && _a !== void 0 ? _a : {};
        if (forceFetch
            || (((_b = collections[slug]) === null || _b === void 0 ? void 0 : _b.timestamp) === undefined)
            || ((Date.now() - collections[slug].timestamp) > constants_1.CACHE_EXPIRE_MS)) {
            if (this.mCacheColRequests[slug] === undefined) {
                this.mCacheColRequests[slug] = this.cacheCollectionInfo(slug);
            }
            return this.mCacheColRequests[slug];
        }
        return collections[slug].info;
    }
    async clearCache() {
        const { store } = this.mApi;
        const state = this.mApi.getState();
        const cutOffTime = Date.now() - constants_1.CACHE_EXPIRE_MS;
        {
            const { collections } = state.persistent.collections;
            const collectionsToDrop = Object.keys(collections)
                .sort((lhs, rhs) => collections[rhs].timestamp - collections[lhs].timestamp)
                .reduce((prev, iter, idx) => {
                if ((idx >= constants_1.CACHE_LRU_COUNT) || (collections[iter].timestamp < cutOffTime)) {
                    prev.push(iter);
                }
                return prev;
            }, []);
            if (collectionsToDrop.length > 0) {
                (0, vortex_api_1.log)('debug', 'dropping outdated collections cache', { ids: collectionsToDrop });
                vortex_api_1.util.batchDispatch(store, collectionsToDrop
                    .map(coll => (0, persistent_1.updateCollectionInfo)(coll, undefined, undefined)));
            }
        }
        {
            const { revisions } = state.persistent.collections;
            const revisionsToDrop = Object.keys(revisions)
                .sort((lhs, rhs) => revisions[rhs].timestamp - revisions[lhs].timestamp)
                .reduce((prev, iter, idx) => {
                if ((idx >= constants_1.CACHE_LRU_COUNT) || (revisions[iter].timestamp < cutOffTime)) {
                    prev.push(iter);
                }
                return prev;
            }, []);
            if (revisionsToDrop.length > 0) {
                (0, vortex_api_1.log)('debug', 'dropping outdated revision cache', { ids: revisionsToDrop });
                vortex_api_1.util.batchDispatch(store, revisionsToDrop
                    .map(rev => (0, persistent_1.updateRevisionInfo)(rev, undefined, undefined)));
            }
        }
    }
    async getRevisionInfo(revisionId, collectionSlug, revisionNumber, fetchBehavior = 'allow') {
        var _a, _b, _c, _d;
        const { store } = this.mApi;
        const revisions = (_a = store.getState().persistent.collections.revisions) !== null && _a !== void 0 ? _a : {};
        if ((fetchBehavior === 'force')
            || (((_b = revisions[revisionId]) === null || _b === void 0 ? void 0 : _b.timestamp) === undefined)
            || (((Date.now() - revisions[revisionId].timestamp) > constants_1.CACHE_EXPIRE_MS)
                && (fetchBehavior === 'allow'))) {
            this.fetchRevisionInfo(revisions, revisionId, collectionSlug, revisionNumber);
            return this.mCacheRevRequests[revisionId];
        }
        if (!((_d = (_c = revisions[revisionId]) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.collection)) {
            return Promise.resolve(undefined);
        }
        const collectionInfo = await this.getCollectionInfo(revisions[revisionId].info.collection.slug);
        return {
            ...revisions[revisionId].info,
            collection: {
                ...collectionInfo,
            },
        };
    }
    fetchRevisionInfo(revisions, revisionId, collectionSlug, revisionNumber) {
        var _a;
        (0, vortex_api_1.log)('info', 'revision info cache outdated', {
            timestamp: (_a = revisions[revisionId]) === null || _a === void 0 ? void 0 : _a.timestamp,
            now: Date.now(),
        });
        if (this.mCacheRevRequests[revisionId] === undefined) {
            this.mCacheRevRequests[revisionId] =
                this.cacheRevisionInfo(revisionId, collectionSlug, revisionNumber);
        }
    }
    async cacheCollectionModRules(revisionId, collection, gameId) {
        const store = this.mApi.store;
        const state = store.getState();
        const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', gameId], {});
        const colMod = collection !== null && collection !== void 0 ? collection : (Object.values(mods).find(iter => { var _a; return (iter.type === constants_1.MOD_TYPE) && (((_a = iter.attributes) === null || _a === void 0 ? void 0 : _a.revisionId) === revisionId); }));
        if ((colMod === null || colMod === void 0 ? void 0 : colMod.installationPath) === undefined) {
            return [];
        }
        const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
        try {
            const collectionInfo = await (0, importCollection_1.readCollection)(this.mApi, path.join(stagingPath, colMod.installationPath, 'collection.json'));
            return collectionInfo.modRules;
        }
        catch (err) {
            if (err.code !== 'ENOENT') {
                this.mApi.showErrorNotification('Failed to cache collection mod rules', err, {
                    allowReport: false,
                });
            }
            return [];
        }
    }
    async cacheCollectionInfo(collectionSlug) {
        const { store } = this.mApi;
        const collectionInfo = (await this.mApi.emitAndAwait('get-nexus-collection', collectionSlug))[0];
        if (!!(collectionInfo === null || collectionInfo === void 0 ? void 0 : collectionInfo.id)) {
            store.dispatch((0, persistent_1.updateCollectionInfo)(collectionInfo.id.toString(), collectionInfo, Date.now()));
            delete this.mCacheColRequests[collectionInfo.id.toString()];
        }
        return collectionInfo;
    }
    updateRevisionCacheState(store, revisionId, revisionInfo, now) {
        store.dispatch((0, persistent_1.updateCollectionInfo)(revisionInfo.collection.id.toString(), revisionInfo.collection, now));
        store.dispatch((0, persistent_1.updateRevisionInfo)(revisionId, {
            ...revisionInfo,
            collection: {
                id: revisionInfo.collection.id,
                slug: revisionInfo.collection.slug,
            },
        }, now));
    }
    async cacheRevisionInfo(revisionId, collectionSlug, revisionNumber) {
        const { store } = this.mApi;
        if ((collectionSlug === undefined) || (revisionNumber === undefined)) {
            const err = new Error('missing collection/revision id');
            err['allowReport'] = false;
            return Promise.reject(err);
        }
        const revisionInfo = (await this.mApi.emitAndAwait('get-nexus-collection-revision', collectionSlug, revisionNumber))[0];
        const now = Date.now();
        if (!!revisionInfo) {
            this.updateRevisionCacheState(store, revisionId, revisionInfo, now);
        }
        else {
            store.dispatch((0, persistent_1.updateRevisionInfo)(revisionId, null, now));
        }
        const result = await revisionInfo;
        delete this.mCacheRevRequests[revisionId];
        return result !== null && result !== void 0 ? result : null;
    }
}
exports["default"] = InfoCache;


/***/ }),

/***/ "./src/util/InstallDriver.ts":
/*!***********************************!*\
  !*** ./src/util/InstallDriver.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Promise = __webpack_require__(/*! bluebird */ "bluebird");
const path = __webpack_require__(/*! path */ "path");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const persistent_1 = __webpack_require__(/*! ../actions/persistent */ "./src/actions/persistent.ts");
const collectionInstall_1 = __webpack_require__(/*! ../collectionInstall */ "./src/collectionInstall.ts");
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
const binaryPatching_1 = __webpack_require__(/*! ./binaryPatching */ "./src/util/binaryPatching.ts");
const importCollection_1 = __webpack_require__(/*! ./importCollection */ "./src/util/importCollection.ts");
const InfoCache_1 = __webpack_require__(/*! ./InfoCache */ "./src/util/InfoCache.ts");
const util_1 = __webpack_require__(/*! ./util */ "./src/util/util.ts");
class InstallDriver {
    get requiredMods() {
        return this.mDependentMods.filter(_ => _.type === 'requires');
    }
    get recommendedMods() {
        return this.mDependentMods.filter(_ => _.type === 'recommends');
    }
    constructor(api) {
        this.mStep = 'prepare';
        this.mUpdateHandlers = [];
        this.mInstalledMods = [];
        this.mDependentMods = [];
        this.mInstallDone = false;
        this.mPrepare = Promise.resolve();
        this.mDebounce = new vortex_api_1.util.Debouncer((collectionSlug, revisionNumber) => {
            this.mApi.events.emit('analytics-track-event-with-payload', 'Collection Installation Failed', {
                collection_slug: collectionSlug,
                collection_revision_number: revisionNumber
            });
            return null;
        }, 1000);
        this.startInstall = async () => {
            var _a, _b;
            (_b = (_a = this.mApi.ext).withSuppressedTests) === null || _b === void 0 ? void 0 : _b.call(_a, ['plugins-changed', 'settings-changed', 'mod-activated', 'mod-installed'], () => new Promise(resolve => {
                this.mOnStop = () => {
                    resolve(undefined);
                    this.mOnStop = undefined;
                };
            }));
            return this.startImpl();
        };
        this.startImpl = async () => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            this.mApi.events.emit('analytics-track-event-with-payload', 'Collection Installation Started', {
                collection_slug: this.collectionSlug,
                collection_revision_number: this.revisionNumber
            });
            if ((((_a = this.mCollection) === null || _a === void 0 ? void 0 : _a.archiveId) === undefined) || (this.mProfile === undefined)) {
                return false;
            }
            this.mInstalledMods = [];
            this.mInstallingMod = undefined;
            this.mInstallDone = false;
            this.mStep = 'start';
            const collection = this.mCollection;
            const profile = this.mProfile;
            const gameId = this.mGameId;
            const state = this.mApi.store.getState();
            const mods = (_b = state.persistent.mods[gameId]) !== null && _b !== void 0 ? _b : {};
            const modInfo = (_c = state.persistent.downloads.files[collection.archiveId]) === null || _c === void 0 ? void 0 : _c.modInfo;
            const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
            const slug = this.collectionSlug;
            const revisionId = this.revisionId;
            if (revisionId !== undefined) {
                try {
                    this.mRevisionInfo = (_d = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.revisionInfo) !== null && _d !== void 0 ? _d : await this.mInfoCache.getRevisionInfo(revisionId, slug, this.revisionNumber);
                }
                catch (err) {
                    (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                        revisionId, slug, revisionNumber: this.revisionNumber, error: err.message
                    });
                }
            }
            const { userInfo } = (_e = state.persistent['nexus']) !== null && _e !== void 0 ? _e : {};
            if (((_h = (_g = (_f = this.mRevisionInfo) === null || _f === void 0 ? void 0 : _f.collection) === null || _g === void 0 ? void 0 : _g.user) === null || _h === void 0 ? void 0 : _h.memberId) !== (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId)) {
                this.mApi.store.dispatch((0, persistent_1.setPendingVote)(revisionId, slug, this.revisionNumber, Date.now()));
            }
            const gameMode = gameId;
            const currentgame = vortex_api_1.util.getGame(gameMode);
            const discovery = vortex_api_1.selectors.discoveryByGame(state, gameMode);
            const gameVersion = await currentgame.getInstalledVersion(discovery);
            const gvMatch = gv => gv.reference === gameVersion;
            const revGameVersions = (_k = (_j = this.mRevisionInfo) === null || _j === void 0 ? void 0 : _j.gameVersions) !== null && _k !== void 0 ? _k : [];
            if (((_l = revGameVersions.length) !== null && _l !== void 0 ? _l : 0 !== 0)
                && (revGameVersions.find(gvMatch) === undefined)) {
                const choice = await this.mApi.showDialog('question', 'Game version mismatch', {
                    bbcode: 'The version of the game you have installed is different to the one the curator used when creating this collection.'
                        + '[br][/br][br][/br]'
                        + 'Your game version: [style=dialog-success-text]{{actual}}[/style][br][/br]'
                        + 'Recommended game version: [style=dialog-danger-text]{{intended}}[/style]'
                        + '[br][/br][br][/br]'
                        + 'If you choose to continue, some or all of the mods included in the collection may not work properly for you. This will '
                        + 'require manual troubleshooting to correct. For users who are not familiar with modding, we do not recommend continuing with installation.'
                        + '[br][/br][br][/br]'
                        + 'You can also check the description, comments and bug reports on the Collection page to see if others have been successful'
                        + 'while playing with the game version you have installed or to request advice from the curator.',
                    parameters: {
                        actual: gameVersion,
                        intended: revGameVersions.map(gv => gv.reference).join(' or '),
                    },
                }, [
                    { label: 'Cancel' },
                    { label: 'Continue' },
                ]);
                if (choice.action === 'Cancel') {
                    this.mInstallDone = true;
                    return false;
                }
            }
            this.mApi.events.emit('will-install-collection', gameId, collection.id);
            this.mApi.events.emit('view-collection', collection.id);
            this.updateProgress(profile, gameId, collection);
            this.augmentRules(gameId, collection);
            this.mApi.dismissNotification((0, util_1.getUnfulfilledNotificationId)(collection.id));
            this.mApi.store.dispatch(vortex_api_1.actions.setModEnabled(profile.id, collection.id, true));
            const required = ((_m = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _m !== void 0 ? _m : [])
                .filter(rule => ['requires', 'recommends'].includes(rule.type));
            const dependencies = required
                .reduce((accum, rule) => {
                var _a;
                const modRef = {
                    ...rule.reference,
                    patches: ((_a = rule === null || rule === void 0 ? void 0 : rule.extra) === null || _a === void 0 ? void 0 : _a.patches) ? { ...rule.extra.patches } : undefined,
                    fileList: rule === null || rule === void 0 ? void 0 : rule.fileList,
                };
                const mod = vortex_api_1.util.findModByRef(modRef, mods);
                if (mod === undefined) {
                    accum.push(rule);
                }
                return accum;
            }, []);
            this.mDependentMods = dependencies;
            if (this.requiredMods.length === 0) {
                this.mInstallDone = false;
            }
            (0, vortex_api_1.log)('info', 'starting install of collection', {
                totalMods: required.length,
                missing: this.requiredMods.length,
            });
        };
        this.begin = () => {
            var _a;
            if ((this.mCollection === undefined) || (((_a = this.mProfile) === null || _a === void 0 ? void 0 : _a.id) === undefined)) {
                return;
            }
            this.mApi.events.emit('install-dependencies', this.mProfile.id, this.mGameId, [this.mCollection.id], true);
            this.mStep = 'installing';
        };
        this.closeDisclaimers = () => {
            this.mStep = 'installing';
        };
        this.finishInstalling = () => {
            this.mStep = 'review';
        };
        this.close = () => {
            if ((this.mGameId !== undefined) && (this.mCollection !== undefined)) {
                this.mApi.events.emit('did-install-collection', this.mGameId, this.mCollection.id);
            }
            this.mCollection = undefined;
            this.mInstallDone = true;
            this.triggerUpdate();
        };
        this.mApi = api;
        this.mInfoCache = new InfoCache_1.default(api);
        api.onAsync('will-install-mod', (gameId, archiveId, modId) => {
            const state = api.store.getState();
            const download = state.persistent.downloads.files[archiveId];
            if (download !== undefined) {
                this.mInstallingMod = download.localPath;
            }
            return Promise.resolve();
        });
        api.events.on('did-install-mod', (gameId, archiveId, modId) => {
            var _a, _b, _c, _d;
            const state = api.store.getState();
            const mod = vortex_api_1.util.getSafe(state.persistent.mods, [gameId, modId], undefined);
            const dependent = this.mDependentMods.find(iter => vortex_api_1.util.testModReference(mod, iter.reference));
            if ((mod !== undefined) && (dependent !== undefined)) {
                if (dependent.type === 'requires') {
                    this.mInstalledMods.push(mod);
                }
                if ((((_a = this.mCollection) === null || _a === void 0 ? void 0 : _a.installationPath) !== undefined)
                    && (dependent.reference.description !== undefined)) {
                    if (dependent.type === 'requires') {
                        this.updateProgress(this.mProfile, this.mGameId, this.mCollection);
                    }
                    (0, binaryPatching_1.applyPatches)(api, this.mCollection, gameId, dependent.reference.description, modId, (_b = dependent.extra) === null || _b === void 0 ? void 0 : _b.patches);
                    vortex_api_1.util.batchDispatch(api.store, [
                        vortex_api_1.actions.setFileOverride(gameId, modId, (_c = dependent.extra) === null || _c === void 0 ? void 0 : _c.fileOverrides),
                        vortex_api_1.actions.setModAttribute(gameId, modId, 'patches', (_d = dependent.extra) === null || _d === void 0 ? void 0 : _d.patches),
                        vortex_api_1.actions.setModAttribute(gameId, modId, 'fileList', dependent.fileList),
                    ]);
                }
            }
            this.triggerUpdate();
        });
        api.events.on('did-finish-download', () => {
            this.updateProgress(this.mProfile, this.mGameId, this.mCollection);
        });
        api.events.on('will-install-dependencies', (profileId, modId, recommendations, onCancel) => {
            var _a, _b;
            const state = api.getState();
            const profile = this.profile || vortex_api_1.selectors.profileById(state, profileId);
            const gameId = this.mGameId || (profile === null || profile === void 0 ? void 0 : profile.gameId);
            if (gameId === undefined) {
                return;
            }
            const mods = state.persistent.mods[gameId];
            if ((this.mCollection === undefined)
                && (((_a = mods[modId]) === null || _a === void 0 ? void 0 : _a.type) === constants_1.MOD_TYPE)
                && recommendations) {
                this.mLastCollection = this.mCollection = mods[modId];
                this.mStep = 'installing';
            }
            const isCollectionMod = rule => { var _a; return ((_a = vortex_api_1.util.findModByRef(rule.reference, mods)) === null || _a === void 0 ? void 0 : _a.id) === modId; };
            if ((this.mCollection !== undefined)
                && recommendations
                && ((_b = this.mCollection.rules) !== null && _b !== void 0 ? _b : []).find(isCollectionMod)) {
                onCancel();
            }
        });
        api.events.on('did-install-dependencies', (gameId, modId, recommendations) => {
            this.onDidInstallDependencies(gameId, modId, recommendations);
        });
    }
    async prepare(func) {
        this.mPrepare = this.mPrepare.then(func);
    }
    async query(profile, collection) {
        var _a;
        await this.mPrepare;
        this.mPrepare = Promise.resolve();
        if ((collection === null || collection === void 0 ? void 0 : collection.archiveId) === undefined) {
            return;
        }
        if (!this.mInstallDone && (this.mCollection !== undefined)) {
            this.mApi.sendNotification({
                type: 'warning',
                message: 'Already installing a collection',
            });
            return;
        }
        this.mProfile = profile;
        this.mLastCollection = this.mCollection = collection;
        this.mGameId = (_a = profile === null || profile === void 0 ? void 0 : profile.gameId) !== null && _a !== void 0 ? _a : vortex_api_1.selectors.activeGameId(this.mApi.getState());
        this.mStep = 'query';
        await this.initCollectionInfo();
        this.triggerUpdate();
    }
    async start(profile, collection) {
        var _a;
        await this.mPrepare;
        this.mPrepare = Promise.resolve();
        if ((collection === null || collection === void 0 ? void 0 : collection.archiveId) === undefined) {
            return;
        }
        if (!this.mInstallDone && (this.mCollection !== undefined)) {
            this.mApi.sendNotification({
                type: 'warning',
                message: 'Already installing a collection',
                displayMS: 5000,
            });
            (0, vortex_api_1.log)('warn', 'already installing a collection');
            return;
        }
        this.mProfile = profile;
        this.mLastCollection = this.mCollection = collection;
        this.mGameId = (_a = profile === null || profile === void 0 ? void 0 : profile.gameId) !== null && _a !== void 0 ? _a : vortex_api_1.selectors.activeGameId(this.mApi.getState());
        this.mTotalSize = (0, util_1.calculateCollectionSize)(this.getModsEx(profile, this.mGameId, collection));
        await this.startInstall();
        await this.initCollectionInfo();
        this.triggerUpdate();
    }
    onUpdate(cb) {
        this.mUpdateHandlers.push(cb);
    }
    get profile() {
        return this.mProfile;
    }
    set profile(val) {
        this.mProfile = val;
        if (val !== undefined) {
            this.mGameId = val === null || val === void 0 ? void 0 : val.gameId;
        }
    }
    get infoCache() {
        return this.mInfoCache;
    }
    get step() {
        return this.mStep;
    }
    get installedMods() {
        return this.mInstalledMods;
    }
    get numRequired() {
        return this.requiredMods.length;
    }
    get installingMod() {
        return this.mInstallingMod;
    }
    get collection() {
        return this.mCollection;
    }
    get lastCollection() {
        return this.mLastCollection;
    }
    get collectionId() {
        var _a, _b, _c;
        const state = this.mApi.store.getState();
        const modInfo = (this.mCollection !== undefined)
            ? (_a = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _a === void 0 ? void 0 : _a.modInfo
            : undefined;
        const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
        return ((_b = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.ids) === null || _b === void 0 ? void 0 : _b.collectionId) || ((_c = modInfo === null || modInfo === void 0 ? void 0 : modInfo.ids) === null || _c === void 0 ? void 0 : _c.collectionId);
    }
    get collectionSlug() {
        var _a, _b, _c;
        const state = this.mApi.store.getState();
        const modInfo = (this.mCollection !== undefined)
            ? (_a = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _a === void 0 ? void 0 : _a.modInfo
            : undefined;
        const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
        return ((_b = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.ids) === null || _b === void 0 ? void 0 : _b.collectionSlug) || ((_c = modInfo === null || modInfo === void 0 ? void 0 : modInfo.ids) === null || _c === void 0 ? void 0 : _c.collectionSlug);
    }
    get revisionNumber() {
        var _a, _b, _c;
        const state = this.mApi.store.getState();
        const modInfo = (this.mCollection !== undefined)
            ? (_a = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _a === void 0 ? void 0 : _a.modInfo
            : undefined;
        const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
        return ((_b = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.ids) === null || _b === void 0 ? void 0 : _b.revisionNumber) || ((_c = modInfo === null || modInfo === void 0 ? void 0 : modInfo.ids) === null || _c === void 0 ? void 0 : _c.revisionNumber);
    }
    get revisionId() {
        var _a, _b, _c;
        const state = this.mApi.store.getState();
        const modInfo = (this.mCollection !== undefined)
            ? (_a = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _a === void 0 ? void 0 : _a.modInfo
            : undefined;
        const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
        return ((_b = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.ids) === null || _b === void 0 ? void 0 : _b.revisionId) || ((_c = modInfo === null || modInfo === void 0 ? void 0 : modInfo.ids) === null || _c === void 0 ? void 0 : _c.revisionId);
    }
    get collectionInfo() {
        return this.mCollectionInfo;
    }
    get revisionInfo() {
        return this.mRevisionInfo;
    }
    get installDone() {
        return this.mInstallDone;
    }
    cancel() {
        this.onStop();
        this.triggerUpdate();
    }
    installRecommended() {
        this.mApi.emitAndAwait('install-from-dependencies', this.mCollection.id, this.mCollection.rules, true);
        this.mStep = 'recommendations';
        this.triggerUpdate();
    }
    async continue() {
        var _a, _b;
        if (this.canContinue() && (((_a = this.mCollection) === null || _a === void 0 ? void 0 : _a.archiveId) !== undefined)) {
            await this.initCollectionInfo();
            const steps = {
                query: this.startInstall,
                start: this.begin,
                disclaimer: this.closeDisclaimers,
                installing: this.finishInstalling,
                recommendations: this.finishInstalling,
                review: this.close,
            };
            const res = await ((_b = steps[this.mStep]) === null || _b === void 0 ? void 0 : _b.call(steps));
            if (res !== false) {
                this.triggerUpdate();
            }
        }
    }
    canContinue() {
        if (this.mCollection === undefined) {
            return false;
        }
        if (this.mStep === 'installing') {
            return this.mInstallDone;
        }
        else if (this.mStep === 'disclaimer') {
            return (this.mInstalledMods.length > 0) || this.mInstallDone;
        }
        else {
            return true;
        }
    }
    canClose() {
        return ['start'].indexOf(this.mStep) !== -1;
    }
    canHide() {
        return ['disclaimer', 'installing'].indexOf(this.mStep) !== -1;
    }
    async initCollectionInfo() {
        var _a, _b, _c, _d, _e;
        if (((_a = this.mCollection) === null || _a === void 0 ? void 0 : _a.archiveId) === undefined) {
            return;
        }
        const slug = this.collectionSlug;
        const state = this.mApi.store.getState();
        const modInfo = (_b = state.persistent.downloads.files[this.mCollection.archiveId]) === null || _b === void 0 ? void 0 : _b.modInfo;
        const nexusInfo = modInfo === null || modInfo === void 0 ? void 0 : modInfo.nexus;
        this.mCollectionInfo = (_d = (_c = nexusInfo === null || nexusInfo === void 0 ? void 0 : nexusInfo.collectionInfo) !== null && _c !== void 0 ? _c : await this.mInfoCache.getCollectionInfo(slug)) !== null && _d !== void 0 ? _d : (_e = this.mRevisionInfo) === null || _e === void 0 ? void 0 : _e.collection;
    }
    async onDidInstallDependencies(gameId, modId, recommendations) {
        var _a, _b, _c;
        const mods = this.mApi.getState().persistent.mods[gameId];
        if (((_a = mods[modId]) === null || _a === void 0 ? void 0 : _a.type) === constants_1.MOD_TYPE) {
            (0, vortex_api_1.log)('info', 'did install dependencies', { gameId, modId });
        }
        if ((this.mCollection !== undefined) && (modId === this.mCollection.id)) {
            this.mLastCollection = this.mCollection = mods[modId];
            if (this.mCollection !== undefined) {
                if (!recommendations) {
                    const filter = rule => (rule.type === 'requires')
                        && (rule['ignored'] !== true)
                        && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined);
                    const incomplete = ((_b = this.mCollection.rules) !== null && _b !== void 0 ? _b : []).find(filter);
                    if (incomplete === undefined) {
                        await this.initCollectionInfo();
                        this.mStep = 'review';
                    }
                    else {
                        this.mInstallDone = true;
                        this.mInstallingMod = undefined;
                    }
                    this.mApi.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + modId);
                    this.triggerUpdate();
                }
                else {
                    const filter = rule => (['requires', 'recommends'].includes(rule.type))
                        && (rule['ignored'] !== true)
                        && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined);
                    const incomplete = ((_c = this.mCollection.rules) !== null && _c !== void 0 ? _c : []).find(filter);
                    this.mApi.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + modId);
                    if (incomplete === undefined) {
                        await this.initCollectionInfo();
                        this.mStep = 'review';
                    }
                    else {
                        this.onStop();
                    }
                }
            }
        }
        const stagingPath = vortex_api_1.selectors.installPathForGame(this.mApi.getState(), gameId);
        const mod = mods[modId];
        if ((mod !== undefined) && (mod.type === constants_1.MOD_TYPE)) {
            try {
                const collectionInfo = await (0, importCollection_1.readCollection)(this.mApi, path.join(stagingPath, mod.installationPath, 'collection.json'));
                await (0, collectionInstall_1.postprocessCollection)(this.mApi, gameId, mod, collectionInfo, mods);
                this.mApi.events.emit('analytics-track-event-with-payload', 'Collection Installation Completed', {
                    collection_slug: this.collectionSlug,
                    collection_revision_number: this.revisionNumber
                });
            }
            catch (err) {
                (0, vortex_api_1.log)('info', 'Failed to apply mod rules from collection. This is normal if this is the '
                    + 'platform where the collection has been created.');
                this.mDebounce.schedule(undefined, this.collectionSlug, this.revisionNumber);
            }
        }
    }
    onStop() {
        var _a;
        if (this.mCollection !== undefined) {
            this.mApi.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + this.mCollection.id);
        }
        this.mCollection = undefined;
        this.mProfile = undefined;
        this.mGameId = undefined;
        this.mInstalledMods = [];
        this.mStep = 'prepare';
        (_a = this.mOnStop) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    getModsEx(profile, gameId, collection) {
        var _a;
        if (profile === undefined) {
            profile = this.mProfile;
        }
        if (profile === undefined) {
            return {};
        }
        const mods = this.mApi.getState().persistent.mods[gameId];
        if (mods === undefined) {
            (0, vortex_api_1.log)('error', 'no mods for game', { gameId });
            return {};
        }
        return ((_a = collection.rules) !== null && _a !== void 0 ? _a : []).reduce((prev, rule) => {
            if (!['requires', 'recommends'].includes(rule.type)) {
                return prev;
            }
            const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
            prev[(0, util_1.modRuleId)(rule)] = { ...mod, collectionRule: rule };
            return prev;
        }, {});
    }
    matchRepo(rule, ref) {
        var _a, _b;
        if (ref === null) {
            return false;
        }
        const modId = (_a = rule.reference.repo) === null || _a === void 0 ? void 0 : _a.modId;
        const fileId = (_b = rule.reference.repo) === null || _b === void 0 ? void 0 : _b.fileId;
        if ((modId === undefined) || (fileId === undefined)
            || !ref.modId || !ref.fileId) {
            return false;
        }
        return modId.toString() === ref.modId.toString()
            && fileId.toString() === ref.fileId.toString();
    }
    augmentRules(gameId, collection) {
        var _a;
        vortex_api_1.util.batchDispatch(this.mApi.store, ((_a = collection.rules) !== null && _a !== void 0 ? _a : []).map(rule => {
            var _a, _b;
            if (rule.reference.repo === undefined) {
                return undefined;
            }
            const revMod = ((_b = (_a = this.mRevisionInfo) === null || _a === void 0 ? void 0 : _a.modFiles) !== null && _b !== void 0 ? _b : []).find(iter => this.matchRepo(rule, iter.file));
            if ((revMod === null || revMod === void 0 ? void 0 : revMod.file) !== undefined) {
                const newRule = vortex_api_1.util.setSafe(rule, ['extra', 'fileName'], revMod.file.uri);
                return vortex_api_1.actions.addModRule(gameId, collection.id, newRule);
            }
        })
            .filter(rule => rule !== undefined));
    }
    triggerUpdate() {
        this.mUpdateHandlers.forEach(cb => {
            cb();
        });
    }
    installProgress(profile, gameId, collection) {
        const mods = this.getModsEx(profile, gameId, collection);
        const downloads = this.mApi.getState().persistent.downloads.files;
        const downloadProgress = Object.values(mods).reduce((prev, mod) => {
            var _a;
            let size = 0;
            if ((mod.state === 'downloading') || (mod.state === null)) {
                const download = downloads[mod.archiveId];
                size += (download === null || download === void 0 ? void 0 : download.received) || 0;
            }
            else {
                size += ((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.fileSize) || 0;
            }
            return prev + size;
        }, 0);
        const installedMods = Object.values(mods).filter(mod => mod.state === 'installed');
        const totalMods = Object.values(mods).filter(util_1.isRelevant);
        const dlPerc = downloadProgress / this.mTotalSize;
        const instPerc = installedMods.length / totalMods.length;
        return (dlPerc + instPerc) * 50.0;
    }
    updateProgress(profile, gameId, collection) {
        if (collection === undefined) {
            return;
        }
        if (this.mTotalSize === undefined) {
            this.mTotalSize = (0, util_1.calculateCollectionSize)(this.getModsEx(profile, gameId, collection));
        }
        this.mApi.sendNotification({
            id: constants_1.INSTALLING_NOTIFICATION_ID + collection.id,
            type: 'activity',
            title: 'Installing Collection',
            message: vortex_api_1.util.renderModName(collection),
            progress: this.installProgress(profile, gameId, collection),
            actions: [
                {
                    title: 'Show',
                    action: () => {
                        this.mApi.events.emit('view-collection', collection.id);
                    },
                },
            ],
        });
    }
}
exports["default"] = InstallDriver;


/***/ }),

/***/ "./src/util/binaryPatching.ts":
/*!************************************!*\
  !*** ./src/util/binaryPatching.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.applyPatches = exports.scanForDiffs = void 0;
const crc32 = __webpack_require__(/*! crc-32 */ "./node_modules/crc-32/crc32.js");
const path = __webpack_require__(/*! path */ "path");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
const bsdiff = vortex_api_1.util.lazyRequire(() => __webpack_require__(/*! bsdiff-node */ "./node_modules/bsdiff-node/index.js"));
function crcFromBuf(data) {
    return (crc32.buf(data) >>> 0).toString(16).toUpperCase().padStart(8, '0');
}
async function validatePatch(srcFilePath, patchFilePath) {
    const srcStats = await vortex_api_1.fs.statAsync(srcFilePath);
    const patchStats = await vortex_api_1.fs.statAsync(patchFilePath);
    if ((patchStats.size - constants_1.PATCH_OVERHEAD) > (srcStats.size * constants_1.MAX_PATCH_SIZE)) {
        throw new vortex_api_1.util.DataInvalid('patch too large');
    }
}
const queue = vortex_api_1.util.makeQueue();
async function scanForDiffs(api, gameId, modId, destPath, onProgress) {
    var _a;
    const state = api.getState();
    const mod = state.persistent.mods[gameId][modId];
    const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
    const localPath = path.join(stagingPath, mod.installationPath);
    const archive = state.persistent.downloads.files[mod.archiveId];
    if (archive === undefined) {
        throw new vortex_api_1.util.ProcessCanceled('Archive not found');
    }
    const choices = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.installerChoices;
    return queue(() => new Promise((resolve, reject) => {
        api.events.emit('simulate-installer', gameId, mod.archiveId, { choices }, async (instRes, tempPath) => {
            try {
                const dlPath = vortex_api_1.selectors.downloadPathForGame(state, archive.game[0]);
                const archivePath = path.join(dlPath, archive.localPath);
                const sourceChecksums = {};
                const szip = new vortex_api_1.util.SevenZip();
                await szip.list(archivePath, undefined, async (entries) => {
                    for (const entry of entries) {
                        if (entry.attr !== 'D') {
                            try {
                                sourceChecksums[entry.name] = entry['crc'].toUpperCase();
                            }
                            catch (err) {
                                api.showErrorNotification('Failed to determine checksum for file', err, {
                                    message: entry.name,
                                });
                            }
                        }
                    }
                });
                const result = {};
                for (const file of instRes.instructions.filter(instr => instr.type === 'copy')) {
                    const srcCRC = sourceChecksums[file.source];
                    const dstFilePath = path.join(localPath, file.destination);
                    const dat = await vortex_api_1.fs.readFileAsync(dstFilePath);
                    const dstCRC = crcFromBuf(dat);
                    if (srcCRC !== dstCRC) {
                        onProgress(undefined, api.translate('Creating patch for {{fileName}}', { replace: {
                                fileName: path.basename(file.source),
                            } }));
                        (0, vortex_api_1.log)('debug', 'found modified file', { filePath: file.source, srcCRC, dstCRC });
                        const srcFilePath = path.join(tempPath, file.source);
                        const patchPath = path.join(destPath, file.destination + '.diff');
                        await vortex_api_1.fs.ensureDirWritableAsync(path.dirname(patchPath));
                        await bsdiff.diff(srcFilePath, dstFilePath, patchPath, progress => {
                        });
                        try {
                            await validatePatch(srcFilePath, patchPath);
                            result[file.destination] = srcCRC;
                        }
                        catch (err) {
                            await vortex_api_1.fs.removeAsync(patchPath);
                            const res = await api.showDialog('error', 'Can\'t save local edits', {
                                text: 'The local modifications to file "{{fileName}}" can not be included in '
                                    + 'the collection.\n'
                                    + 'We don\'t allow edits that exceed a certain percentage '
                                    + 'of the original file size.\n'
                                    + 'If you continue anyway this file will be installed unmodified for users.',
                                parameters: {
                                    fileName: file.source,
                                },
                            }, [
                                { label: 'Cancel' },
                                { label: 'Continue' },
                            ]);
                            if (res.action === 'Cancel') {
                                err['mayIgnore'] = false;
                                throw err;
                            }
                        }
                        (0, vortex_api_1.log)('debug', 'patch created at', patchPath);
                    }
                }
                resolve(result);
            }
            catch (err) {
                reject(err);
            }
        });
    }), false);
}
exports.scanForDiffs = scanForDiffs;
async function applyPatches(api, collection, gameId, modName, modId, patches) {
    const state = api.getState();
    const installPath = vortex_api_1.selectors.installPathForGame(state, gameId);
    const mod = state.persistent.mods[gameId][modId];
    const modPath = path.join(installPath, mod.installationPath);
    const patchesPath = path.join(installPath, collection.installationPath, constants_1.PATCHES_PATH, modName);
    for (const filePath of Object.keys(patches !== null && patches !== void 0 ? patches : {})) {
        try {
            const srcPath = path.join(modPath, filePath);
            const diffPath = path.join(patchesPath, filePath) + '.diff';
            await vortex_api_1.fs.statAsync(diffPath);
            const srcDat = await vortex_api_1.fs.readFileAsync(srcPath);
            const srcCRC = crcFromBuf(srcDat);
            if (srcCRC === patches[filePath]) {
                await bsdiff.patch(srcPath, srcPath + '.patched', diffPath);
                await vortex_api_1.fs.removeAsync(srcPath);
                await vortex_api_1.fs.renameAsync(srcPath + '.patched', srcPath);
                (0, vortex_api_1.log)('info', 'patched', srcPath);
            }
            else {
                (0, vortex_api_1.log)('warn', 'patch not applied because reference CRC differs', { filePath, srcCRC });
            }
        }
        catch (err) {
            err['Collection'] = vortex_api_1.util.renderModName(collection);
            api.showErrorNotification('failed to patch', err, {
                message: filePath,
            });
        }
    }
}
exports.applyPatches = applyPatches;


/***/ }),

/***/ "./src/util/checksumMatcher.ts":
/*!*************************************!*\
  !*** ./src/util/checksumMatcher.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.matchChecksums = void 0;
const crc32 = __webpack_require__(/*! crc-32 */ "./node_modules/crc-32/crc32.js");
const path = __webpack_require__(/*! path */ "path");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const errors_1 = __webpack_require__(/*! ../util/errors */ "./src/util/errors.ts");
async function matchChecksums(api, gameId, modId) {
    const state = api.getState();
    const mod = state.persistent.mods[gameId][modId];
    if (!(mod === null || mod === void 0 ? void 0 : mod.archiveId)) {
        throw new vortex_api_1.util.ProcessCanceled('Mod not found');
    }
    const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
    const localPath = path.join(stagingPath, mod.installationPath);
    const archive = state.persistent.downloads.files[mod.archiveId];
    if (archive === undefined) {
        throw new vortex_api_1.util.ProcessCanceled('Archive not found');
    }
    const dlPath = vortex_api_1.selectors.downloadPathForGame(state, archive.game[0]);
    const archivePath = path.join(dlPath, archive.localPath);
    const sourceChecksums = new Set();
    const szip = new vortex_api_1.util.SevenZip();
    await szip.list(archivePath, undefined, async (entries) => {
        for (const entry of entries) {
            if (entry.attr !== 'D') {
                try {
                    if (!!entry['crc']) {
                        sourceChecksums.add(entry['crc'].toUpperCase());
                    }
                }
                catch (err) {
                    api.showErrorNotification('Failed to determine checksum for file', err, {
                        message: entry.name,
                    });
                }
            }
        }
    });
    let entries = [];
    await vortex_api_1.util.walk(localPath, async (input) => {
        entries = [].concat(entries, input);
    }, {});
    const localChecksums = new Set();
    const computeCRC32Stream = (filePath) => {
        return new Promise((resolve, reject) => {
            const stream = vortex_api_1.fs.createReadStream(filePath);
            let crc = 0;
            stream.on('data', (chunk) => {
                crc = crc32.buf(chunk, crc);
            });
            stream.on('end', () => {
                resolve((crc >>> 0).toString(16).toUpperCase().padStart(8, '0'));
            });
            stream.on('error', (err) => {
                reject(err);
            });
        });
    };
    for (const entry of entries) {
        const isDirectory = (await vortex_api_1.fs.statAsync(entry)).isDirectory();
        if (isDirectory) {
            continue;
        }
        const crc = await computeCRC32Stream(entry);
        localChecksums.add(crc);
    }
    const missingChecksums = [];
    for (const crc of localChecksums) {
        if (!sourceChecksums.has(crc)) {
            missingChecksums.push(crc);
        }
    }
    if (missingChecksums.length > 0) {
        throw new errors_1.ReplicateHashMismatchError();
    }
}
exports.matchChecksums = matchChecksums;


/***/ }),

/***/ "./src/util/collectionConfig/index.ts":
/*!********************************************!*\
  !*** ./src/util/collectionConfig/index.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseConfig = exports.generateConfig = void 0;
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const configDefaults = {
    recommendNewProfile: false,
};
async function generateConfig(props) {
    const { collectionMod } = props;
    const config = vortex_api_1.util.getSafe(collectionMod, ['attributes', 'collection', 'collectionConfig'], configDefaults);
    return {
        ...config,
    };
}
exports.generateConfig = generateConfig;
async function parseConfig(props) {
    const { collection } = props;
    const config = vortex_api_1.util.getSafe(collection, ['collectionConfig'], configDefaults);
    return config;
}
exports.parseConfig = parseConfig;


/***/ }),

/***/ "./src/util/defaults.ts":
/*!******************************!*\
  !*** ./src/util/defaults.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.genDefaultsAction = void 0;
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function applyDefaultInstallMode(prev, mod) {
    var _a, _b, _c;
    if (((_a = prev === null || prev === void 0 ? void 0 : prev.installMode) === null || _a === void 0 ? void 0 : _a[mod.id]) === undefined) {
        const { installerChoices } = (_b = mod === null || mod === void 0 ? void 0 : mod.attributes) !== null && _b !== void 0 ? _b : {};
        if (((installerChoices === null || installerChoices === void 0 ? void 0 : installerChoices.type) === 'fomod') && (((_c = installerChoices === null || installerChoices === void 0 ? void 0 : installerChoices.options) === null || _c === void 0 ? void 0 : _c.length) > 0)) {
            prev = vortex_api_1.util.setSafe(prev, ['installMode', mod.id], 'choices');
        }
    }
    return prev;
}
function applyDefaultSource(prev, mod) {
    var _a, _b, _c;
    if (((_a = prev === null || prev === void 0 ? void 0 : prev.source) === null || _a === void 0 ? void 0 : _a[mod.id]) === undefined) {
        if (((_b = mod === null || mod === void 0 ? void 0 : mod.attributes) === null || _b === void 0 ? void 0 : _b.source) === 'website') {
            prev = vortex_api_1.util.setSafe(prev, ['source', mod.id], {
                type: 'browse',
                url: (_c = mod === null || mod === void 0 ? void 0 : mod.attributes) === null || _c === void 0 ? void 0 : _c.url,
            });
        }
    }
    return prev;
}
function genDefaultsAction(api, collectionId, mods, gameId) {
    if (mods.length === 0) {
        return undefined;
    }
    const state = api.getState();
    const collection = vortex_api_1.util.getSafe(state, ['persistent', 'mods', gameId, collectionId], undefined);
    if (collection === undefined) {
        const error = new vortex_api_1.util.ProcessCanceled('Unable to find collection mod', { collectionId: collection.id });
        api.showErrorNotification('Failed to ascertain default install mode', error);
        return undefined;
    }
    const attr = vortex_api_1.util.getSafe(collection.attributes, ['collection'], {});
    const resAttr = mods.reduce((prev, mod) => {
        prev = applyDefaultInstallMode(prev, mod);
        prev = applyDefaultSource(prev, mod);
        return prev;
    }, attr);
    return vortex_api_1.actions.setModAttribute(gameId, collection.id, 'collection', resAttr);
}
exports.genDefaultsAction = genDefaultsAction;


/***/ }),

/***/ "./src/util/errors.ts":
/*!****************************!*\
  !*** ./src/util/errors.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReplicateHashMismatchError = void 0;
class ReplicateHashMismatchError extends Error {
    constructor() {
        super('Replicate install mode can only work if the checksums of the installed files match those in the archive. Please try to reinstall the mod or use binary patching instead.');
        this.mayIgnore = false;
        this.name = 'ReplicateHashMismatchError';
        this.mayIgnore = false;
    }
}
exports.ReplicateHashMismatchError = ReplicateHashMismatchError;


/***/ }),

/***/ "./src/util/extension.ts":
/*!*******************************!*\
  !*** ./src/util/extension.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findExtensions = exports.addExtension = void 0;
const features = [];
function addExtension(feature) {
    features.push(feature);
}
exports.addExtension = addExtension;
function findExtensions(state, gameId) {
    return features.filter(iter => (iter.condition === undefined) || iter.condition(state, gameId));
}
exports.findExtensions = findExtensions;


/***/ }),

/***/ "./src/util/findModByRef.ts":
/*!**********************************!*\
  !*** ./src/util/findModByRef.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.testDownloadReference = void 0;
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function testDownloadReference(download, reference) {
    if (download === undefined) {
        return false;
    }
    return vortex_api_1.util.testModReference(vortex_api_1.util.lookupFromDownload(download), reference);
}
exports.testDownloadReference = testDownloadReference;


/***/ }),

/***/ "./src/util/gameSupport/gamebryo.tsx":
/*!*******************************************!*\
  !*** ./src/util/gameSupport/gamebryo.tsx ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Interface = exports.PluginRule = exports.parser = exports.generate = void 0;
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function getEnabledPlugins(state, plugins) {
    const gamebryoLO = state['loadOrder'];
    return plugins.map(pluginName => ({
        ...gamebryoLO[pluginName.toLowerCase()],
        name: pluginName,
    }))
        .filter(lo => (lo !== undefined) && (lo.name !== undefined) && (lo.enabled === true))
        .sort((lhs, rhs) => lhs.loadOrder - rhs.loadOrder)
        .map(lo => ({ name: lo.name, enabled: lo.enabled }));
}
function extractPluginRules(state, plugins) {
    const installedPlugins = new Set(plugins.map(name => name.toLowerCase()));
    const customisedPlugins = state['userlist'].plugins.filter((plug) => installedPlugins.has(plug.name.toLowerCase())
        && ((plug.after !== undefined) || (plug.group !== undefined)));
    return {
        plugins: customisedPlugins,
        groups: state['userlist'].groups,
    };
}
async function getIncludedPlugins(gameId, stagingPath, mods, modIds) {
    const extensions = ['fallout4', 'skyrimse'].includes(gameId)
        ? new Set(['.esp', '.esm', '.esl'])
        : new Set(['.esp', '.esm']);
    const includedPlugins = [];
    await Promise.all(modIds.map(async (modId) => {
        if (mods[modId] !== undefined) {
            try {
                const files = await vortex_api_1.fs.readdirAsync(path.join(stagingPath, mods[modId].installationPath));
                const plugins = files.filter(fileName => extensions.has(path.extname(fileName).toLowerCase()));
                includedPlugins.push(...plugins);
            }
            catch (err) {
                (0, vortex_api_1.log)('warn', 'failed to read plugins included in mod', err.message);
            }
        }
    }));
    return includedPlugins;
}
async function generate(state, gameId, stagingPath, modIds, mods) {
    const includedPlugins = await getIncludedPlugins(gameId, stagingPath, mods, modIds);
    return {
        plugins: getEnabledPlugins(state, includedPlugins),
        pluginRules: extractPluginRules(state, includedPlugins),
    };
}
exports.generate = generate;
function toLootType(type) {
    switch (type) {
        case 'requires': return 'req';
        case 'incompatible': return 'inc';
        default: return 'after';
    }
}
function refName(iter) {
    if (typeof (iter) === 'string') {
        return iter;
    }
    else {
        return iter.name;
    }
}
async function parser(api, gameId, collection, collectionMod) {
    var _a, _b, _c;
    const state = api.getState();
    if (state.userlist === undefined) {
        return;
    }
    const mods = state.persistent.mods[gameId];
    vortex_api_1.util.batchDispatch(api.store, ((_a = collection.pluginRules.groups) !== null && _a !== void 0 ? _a : []).reduce((prev, group) => {
        if (state.userlist.groups[group.name] === undefined) {
            prev.push({
                type: 'ADD_PLUGIN_GROUP', payload: {
                    group: group.name,
                },
            });
        }
        group.after.forEach(after => {
            prev.push({
                type: 'ADD_GROUP_RULE', payload: {
                    groupId: group.name,
                    reference: after,
                },
            });
        });
        return prev;
    }, []));
    const collectionModIds = collectionMod.rules
        .filter(rule => ['requires', 'recommends'].includes(rule.type))
        .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
        .filter(mod => !!mod)
        .map(mod => mod.id);
    const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
    const includedPlugins = await getIncludedPlugins(gameId, stagingPath, mods, collectionModIds);
    const isEnabled = (pluginName) => collection.plugins.find(plugin => ((plugin.name === pluginName) && (plugin.enabled))) !== undefined;
    vortex_api_1.util.batchDispatch(api.store, includedPlugins.map(plugin => {
        return {
            type: 'SET_PLUGIN_ENABLED', payload: {
                pluginName: plugin,
                enabled: isEnabled(plugin),
            }
        };
    }));
    state.session.notifications.notifications
        .filter(noti => noti.id.startsWith('multiple-plugins-'))
        .forEach(noti => api.dismissNotification(noti.id));
    vortex_api_1.util.batchDispatch(api.store, ((_c = (_b = collection.pluginRules) === null || _b === void 0 ? void 0 : _b.plugins) !== null && _c !== void 0 ? _c : []).reduce((prev, plugin) => {
        const existing = state.userlist.plugins.find(plug => plug.name.toUpperCase() === plugin.name.toUpperCase());
        if ((plugin.group !== undefined) && ((existing === null || existing === void 0 ? void 0 : existing.group) === undefined)) {
            prev.push({
                type: 'SET_PLUGIN_GROUP',
                payload: {
                    pluginId: plugin.name.toLowerCase(),
                    group: plugin.group,
                },
            });
        }
        ['requires', 'incompatible', 'after'].forEach(type => {
            const lootType = toLootType(type);
            (plugin[type] || []).forEach(ref => {
                const match = iter => refName(iter).toUpperCase() === ref.toUpperCase();
                if (vortex_api_1.util.getSafe(existing, [lootType], []).find(match) === undefined) {
                    prev.push({
                        type: 'ADD_USERLIST_RULE',
                        payload: {
                            pluginId: plugin.name.toLowerCase(),
                            reference: ref,
                            type,
                        },
                    });
                }
            });
        });
        return prev;
    }, []));
}
exports.parser = parser;
function ruleName(rule) {
    var _a;
    if (typeof (rule) === 'string') {
        return rule;
    }
    else {
        return (_a = rule.display) !== null && _a !== void 0 ? _a : rule.name;
    }
}
function ruleId(rule) {
    if (typeof (rule) === 'string') {
        return rule.toLowerCase();
    }
    else {
        return rule.name.toLowerCase();
    }
}
function ruleType(t, type) {
    switch (type) {
        case 'after': return t('after');
        case 'requires': return t('requires');
        case 'incompatible': return t('incompatible with');
        default: return '???';
    }
}
function renderRefName(rule) {
    return typeof (rule.ref) === 'string'
        ? rule.ref
        : rule.ref.display;
}
function renderType(t, type) {
    if (type === 'assigned') {
        return t('assigned to group');
    }
    else {
        return t(type);
    }
}
function PluginRule(props) {
    const { t, onRemove, rule } = props;
    const remove = React.useCallback((evt) => {
        onRemove(rule);
    }, [rule]);
    return (React.createElement(react_bootstrap_1.ListGroupItem, null,
        React.createElement("div", { className: 'rule-name' },
            rule.isGroup ? t('Group') + ' ' : '',
            rule.name),
        React.createElement("div", { className: 'rule-type' }, renderType(t, rule.type)),
        React.createElement("div", { className: 'rule-name' }, renderRefName(rule)),
        React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed remove-btn', icon: 'remove', tooltip: t('Remove plugin rule'), onClick: remove })));
}
exports.PluginRule = PluginRule;
function Interface(props) {
    var _a;
    const { t, collection } = props;
    const [pluginRules, setPluginRules] = React.useState(null);
    const [groupAssignments, setGroupAssignments] = React.useState(null);
    const store = (0, react_redux_1.useStore)();
    const gameId = (0, react_redux_1.useSelector)(vortex_api_1.selectors.activeGameId);
    const mods = (0, react_redux_1.useSelector)((selState) => selState.persistent.mods[gameId]);
    const userlist = (0, react_redux_1.useSelector)((selState) => selState.userlist);
    const state = store.getState();
    React.useEffect(() => {
        const modIds = collection.rules
            .map(rule => rule.reference.id)
            .filter(modId => modId !== undefined);
        const stagingPath = vortex_api_1.selectors.installPath(state);
        getIncludedPlugins(gameId, stagingPath, mods, modIds)
            .then(plugins => {
            var _a, _b, _c, _d;
            const pluginsL = plugins.map(plug => plug.toLowerCase());
            const rules = [];
            const assignments = {};
            for (const plugin of plugins) {
                const plug = ((_a = userlist === null || userlist === void 0 ? void 0 : userlist.plugins) !== null && _a !== void 0 ? _a : [])
                    .find(iter => iter.name.toLowerCase() === plugin.toLowerCase());
                const byRef = (name) => pluginsL.includes(ruleId(name));
                const toRule = (ref, type) => ({
                    name: plugin,
                    ref,
                    type,
                });
                if (plug !== undefined) {
                    rules.push(...((_b = plug.after) !== null && _b !== void 0 ? _b : []).filter(byRef).map(aft => toRule(aft, 'after')));
                    rules.push(...((_c = plug.req) !== null && _c !== void 0 ? _c : []).filter(byRef).map(req => toRule(req, 'requires')));
                    rules.push(...((_d = plug.inc) !== null && _d !== void 0 ? _d : []).filter(byRef).map(inc => toRule(inc, 'incompatible')));
                    if (plug.group !== undefined) {
                        assignments[plug.name] = plug.group;
                    }
                }
            }
            setPluginRules(rules);
            setGroupAssignments(assignments);
        });
    }, [collection, mods, userlist, setPluginRules]);
    const removeRule = React.useCallback((rule) => {
        store.dispatch({ type: 'REMOVE_USERLIST_RULE', payload: {
                pluginId: rule.name.toLowerCase(), reference: rule.ref, type: rule.type,
            } });
    }, [store]);
    const removeGroupRule = React.useCallback((rule) => {
        store.dispatch({ type: 'REMOVE_GROUP_RULE', payload: {
                groupId: rule.name.toLowerCase(), reference: rule.ref,
            } });
    }, [store]);
    const unassignGroup = React.useCallback((rule) => {
        store.dispatch({ type: 'SET_PLUGIN_GROUP', payload: {
                pluginId: rule.name.toLowerCase(), group: undefined,
            } });
    }, [store]);
    if (userlist === undefined) {
        return (React.createElement(react_bootstrap_1.Panel, null, t('No userlist loaded, is the gamebryo-plugin-management extension disabled?')));
    }
    const grpsFlattened = ((_a = userlist === null || userlist === void 0 ? void 0 : userlist.groups) !== null && _a !== void 0 ? _a : []).reduce((prev, grp) => {
        var _a;
        ((_a = grp.after) !== null && _a !== void 0 ? _a : []).forEach(aft => {
            prev.push({ name: grp.name, ref: aft, type: 'after' });
        });
        return prev;
    }, []);
    return (React.createElement("div", { className: 'collection-rules-edit collection-scrollable' },
        React.createElement(react_bootstrap_1.ControlLabel, null,
            React.createElement("p", null,
                t('The collection will include your custom load order rules so that '
                    + 'users of your collection will get the same load order.'),
                React.createElement("br", null),
                t('Rules you remove here are also removed from your actual setup.'))),
        (pluginRules !== null) ? (React.createElement(react_bootstrap_1.ListGroup, null, pluginRules.map(rule => (React.createElement(PluginRule, { t: t, key: `${rule.name}_after_${rule.ref}`, rule: rule, onRemove: removeRule }))))) : React.createElement(vortex_api_1.Spinner, null),
        (groupAssignments !== null) ? (React.createElement(react_bootstrap_1.ListGroup, null, Object.keys(groupAssignments).map(pluginName => (React.createElement(PluginRule, { t: t, key: `${pluginName}_assigned_${groupAssignments[pluginName]}`, rule: { name: pluginName, type: 'assigned', ref: groupAssignments[pluginName] }, onRemove: unassignGroup }))))) : React.createElement(vortex_api_1.Spinner, null),
        React.createElement(react_bootstrap_1.ListGroup, null, (grpsFlattened.map(grp => (React.createElement(PluginRule, { t: t, key: `${grp.name}_after_${grp.ref}`, rule: grp, onRemove: removeGroupRule })))))));
}
exports.Interface = Interface;


/***/ }),

/***/ "./src/util/gameSupport/index.ts":
/*!***************************************!*\
  !*** ./src/util/gameSupport/index.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getInterface = exports.parseGameSpecifics = exports.generateGameSpecifics = void 0;
const gamebryo = __webpack_require__(/*! ./gamebryo */ "./src/util/gameSupport/gamebryo.tsx");
const gameSupport = {
    skyrim: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    skyrimse: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    skyrimvr: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    fallout3: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    fallout4: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    fallout4vr: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    falloutnv: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    starfield: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    oblivion: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    enderal: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
    enderalspecialedition: {
        generator: gamebryo.generate,
        parser: gamebryo.parser,
        interface: gamebryo.Interface,
    },
};
function generateGameSpecifics(state, gameId, stagingPath, modIds, mods) {
    if ((gameSupport[gameId] !== undefined) && (gameSupport[gameId].generator !== undefined)) {
        return gameSupport[gameId].generator(state, gameId, stagingPath, modIds, mods);
    }
    else {
        return Promise.resolve({});
    }
}
exports.generateGameSpecifics = generateGameSpecifics;
function parseGameSpecifics(api, gameId, collection, collectionMod) {
    if ((gameSupport[gameId] !== undefined) && (gameSupport[gameId].parser !== undefined)) {
        return gameSupport[gameId].parser(api, gameId, collection, collectionMod);
    }
    else {
        return Promise.resolve();
    }
}
exports.parseGameSpecifics = parseGameSpecifics;
function getInterface(gameId) {
    if (gameSupport[gameId] === undefined) {
        return null;
    }
    else {
        return gameSupport[gameId].interface;
    }
}
exports.getInterface = getInterface;


/***/ }),

/***/ "./src/util/importCollection.ts":
/*!**************************************!*\
  !*** ./src/util/importCollection.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readCollection = void 0;
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const validation_1 = __webpack_require__(/*! ../validationCode/validation */ "./src/validationCode/validation.ts");
function isFuzzyVersion(input) {
    if (!input) {
        return false;
    }
    return input.endsWith('+prefer') || (input === '*');
}
function postProcessRule(rule) {
    const result = JSON.parse(JSON.stringify(rule));
    if (isFuzzyVersion(result.reference.versionMatch)
        && !!result.reference.logicalFileName) {
        delete result.reference.fileExpression;
    }
    if (isFuzzyVersion(result.source.versionMatch)
        && !!result.source.logicalFileName) {
        delete result.source.fileExpression;
    }
    return result;
}
function validationMessage(msg) {
    return `${(msg.instancePath || '/')} ${msg.message}`;
}
async function readCollection(api, manifest) {
    var _a;
    const collectionData = await vortex_api_1.fs.readFileAsync(manifest, { encoding: 'utf-8' });
    const collection = JSON.parse(collectionData);
    const readErrors = (0, validation_1.validateICollection)(collection);
    if (readErrors.length > 0) {
        api.showErrorNotification('Collection validation mismatch', 'There was a validation issue with this collection. '
            + 'During the testing phase, this is likely caused by the checks being too strict and '
            + 'the collection itself should still work correctly.\n'
            + 'To help us improve the validation, please report this error once on each '
            + 'collection it appears for.\n\n'
            + readErrors.map(validationMessage).join('\n'));
    }
    collection.modRules = ((_a = collection.modRules) !== null && _a !== void 0 ? _a : []).map(rule => postProcessRule(rule));
    return collection;
}
exports.readCollection = readCollection;


/***/ }),

/***/ "./src/util/transformCollection.ts":
/*!*****************************************!*\
  !*** ./src/util/transformCollection.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createCollectionFromProfile = exports.showQuickCollectionRestrictionsDialog = exports.validateName = exports.createCollection = exports.cloneCollection = exports.makeCollectionId = exports.modToCollection = exports.collectionModToRule = exports.makeBiDirRule = exports.generateCollection = void 0;
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
const binaryPatching_1 = __webpack_require__(/*! ./binaryPatching */ "./src/util/binaryPatching.ts");
const extension_1 = __webpack_require__(/*! ./extension */ "./src/util/extension.ts");
const gameSupport_1 = __webpack_require__(/*! ./gameSupport */ "./src/util/gameSupport/index.ts");
const collectionConfig_1 = __webpack_require__(/*! ./collectionConfig */ "./src/util/collectionConfig/index.ts");
const util_1 = __webpack_require__(/*! ./util */ "./src/util/util.ts");
const _ = __webpack_require__(/*! lodash */ "lodash");
const path = __webpack_require__(/*! path */ "path");
const shortid_1 = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
const turbowalk_1 = __webpack_require__(/*! turbowalk */ "turbowalk");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const util_2 = __webpack_require__(/*! ./util */ "./src/util/util.ts");
const checksumMatcher_1 = __webpack_require__(/*! ./checksumMatcher */ "./src/util/checksumMatcher.ts");
const initweaks_1 = __webpack_require__(/*! ../initweaks */ "./src/initweaks.ts");
const errors_1 = __webpack_require__(/*! ./errors */ "./src/util/errors.ts");
function sanitizeExpression(fileName) {
    return path.basename(fileName, path.extname(fileName))
        .replace(/\.\d+$/, '')
        .replace(/ \(\d+\)$/, '');
}
function toInt(input) {
    if (!input) {
        return 0;
    }
    if (typeof (input) === 'string') {
        return parseInt(input, 10);
    }
    return input;
}
function deduceSource(mod, sourceInfo, versionMatcher, metaInfo, tag) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const res = (sourceInfo !== undefined)
        ? { ...sourceInfo }
        : { type: 'nexus' };
    const assign = (obj, key, value) => {
        if (obj[key] === undefined) {
            obj[key] = value;
        }
    };
    if (res.type === 'nexus') {
        if (((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.source) !== 'nexus') {
            throw new Error(`"${vortex_api_1.util.renderModName(mod)}" doesn't have Nexus as its source`);
        }
        const modId = (mod.type === constants_1.MOD_TYPE) ? (_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.collectionId : (_c = mod.attributes) === null || _c === void 0 ? void 0 : _c.modId;
        const fileId = (mod.type === constants_1.MOD_TYPE) ? (_d = mod.attributes) === null || _d === void 0 ? void 0 : _d.revisionId : (_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.fileId;
        if (!modId || !fileId || isNaN(modId) || isNaN(fileId)) {
            throw new Error(`"${mod.id}" is missing mod id or file id`);
        }
        res.modId = toInt(modId);
        res.fileId = toInt(fileId);
    }
    else {
        assign(res, 'adultContent', sourceInfo === null || sourceInfo === void 0 ? void 0 : sourceInfo.adultContent);
    }
    if (['browse', 'direct'].includes(res.type) && !res.url) {
        throw new Error(`"${mod.id}" has no URL set`);
    }
    if ((sourceInfo === null || sourceInfo === void 0 ? void 0 : sourceInfo.type) !== 'bundle') {
        assign(res, 'md5', (_f = mod.attributes) === null || _f === void 0 ? void 0 : _f.fileMD5);
    }
    assign(res, 'fileSize', (_g = mod.attributes) === null || _g === void 0 ? void 0 : _g.fileSize);
    assign(res, 'logicalFilename', (_k = (_j = (_h = metaInfo === null || metaInfo === void 0 ? void 0 : metaInfo[0]) === null || _h === void 0 ? void 0 : _h.value) === null || _j === void 0 ? void 0 : _j.logicalFileName) !== null && _k !== void 0 ? _k : (_l = mod.attributes) === null || _l === void 0 ? void 0 : _l.logicalFileName);
    if ((sourceInfo === null || sourceInfo === void 0 ? void 0 : sourceInfo.updatePolicy) !== undefined) {
        assign(res, 'updatePolicy', sourceInfo.updatePolicy);
    }
    else if ((sourceInfo === null || sourceInfo === void 0 ? void 0 : sourceInfo.type) === 'bundle') {
        assign(res, 'updatePolicy', 'exact');
    }
    else {
        if (versionMatcher === '*') {
            assign(res, 'updatePolicy', 'latest');
        }
        else if ((versionMatcher === undefined)
            || versionMatcher.endsWith('+prefer')) {
            assign(res, 'updatePolicy', 'prefer');
        }
        else {
            assign(res, 'updatePolicy', 'exact');
        }
    }
    if ((res.md5 === undefined)
        && (res.logicalFilename === undefined)
        && (res.fileExpression === undefined)
        && (((_m = mod.attributes) === null || _m === void 0 ? void 0 : _m.fileName) !== undefined)) {
        assign(res, 'fileExpression', sanitizeExpression(mod.attributes.fileName));
    }
    assign(res, 'tag', tag);
    return res;
}
function generateCollection(info, mods, modRules) {
    return {
        info,
        mods,
        modRules,
    };
}
exports.generateCollection = generateCollection;
async function rulesToCollectionMods(api, collection, resolvedRules, mods, stagingPath, game, collectionInfo, bundleTags, onProgress, onError) {
    var _a;
    let total = resolvedRules.length;
    let finished = 0;
    const collectionPath = path.join(stagingPath, collection.installationPath);
    await vortex_api_1.fs.removeAsync(path.join(collectionPath, constants_1.BUNDLED_PATH));
    await vortex_api_1.fs.removeAsync(path.join(collectionPath, constants_1.PATCHES_PATH));
    await vortex_api_1.fs.ensureDirAsync(path.join(collectionPath, constants_1.BUNDLED_PATH));
    await vortex_api_1.fs.ensureDirAsync(path.join(collectionPath, constants_1.PATCHES_PATH));
    const state = api.getState();
    const downloads = state.persistent.downloads.files;
    const downloadPath = vortex_api_1.selectors.downloadPathForGame(state, game.id);
    const fileOverridesIds = new Set(Object.keys((_a = collectionInfo.fileOverrides) !== null && _a !== void 0 ? _a : {})
        .filter(modId => collectionInfo.fileOverrides[modId]));
    const result = await Promise.all(resolvedRules.map(async (resolvedRule) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
        const { mod, rule } = resolvedRule;
        const fileName = (_a = downloads[mod.archiveId]) === null || _a === void 0 ? void 0 : _a.localPath;
        const refMD5 = (((_c = (_b = collectionInfo.source) === null || _b === void 0 ? void 0 : _b[mod.id]) === null || _c === void 0 ? void 0 : _c.type) === 'bundle')
            ? undefined
            : (_d = mod.attributes) === null || _d === void 0 ? void 0 : _d.fileMD5;
        const meta = await api.lookupModMeta({
            fileName,
            filePath: fileName !== undefined ? path.join(downloadPath, fileName) : undefined,
            fileMD5: refMD5,
            fileSize: (_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.fileSize,
            gameId: game.id,
        });
        const modName = vortex_api_1.util.renderModName(mod, { version: false });
        try {
            const source = deduceSource(mod, (_f = collectionInfo.source) === null || _f === void 0 ? void 0 : _f[mod.id], rule.reference.versionMatch, meta, bundleTags[mod.id]);
            let hashes;
            let choices;
            let entries = [];
            const installMode = (_h = (_g = collectionInfo.installMode) === null || _g === void 0 ? void 0 : _g[mod.id]) !== null && _h !== void 0 ? _h : 'fresh';
            const modPath = path.join(stagingPath, mod.installationPath);
            if (installMode === 'clone') {
                await (0, checksumMatcher_1.matchChecksums)(api, game.id, mod.id);
                await (0, turbowalk_1.default)(modPath, async (input) => {
                    entries = [].concat(entries, input);
                }, {});
                hashes = await Promise.all(entries
                    .filter(iter => !iter.isDirectory)
                    .map(async (iter) => ({
                    path: path.relative(modPath, iter.filePath),
                    md5: await (0, util_2.fileMD5Async)(iter.filePath),
                })));
                onProgress(undefined, modName);
                ++finished;
            }
            else if (installMode === 'choices') {
                choices = (_j = mod === null || mod === void 0 ? void 0 : mod.attributes) === null || _j === void 0 ? void 0 : _j.installerChoices;
                --total;
            }
            else {
                --total;
            }
            let patches;
            if (((_k = collectionInfo.saveEdits) === null || _k === void 0 ? void 0 : _k[mod.id]) === true) {
                const destPath = path.join(collectionPath, constants_1.PATCHES_PATH, modName);
                await vortex_api_1.fs.ensureDirWritableAsync(destPath);
                patches = await (0, binaryPatching_1.scanForDiffs)(api, game.id, mod.id, destPath, onProgress);
            }
            if (((_m = (_l = collectionInfo.source) === null || _l === void 0 ? void 0 : _l[mod.id]) === null || _m === void 0 ? void 0 : _m.type) === 'bundle') {
                const tlFiles = await vortex_api_1.fs.readdirAsync(modPath);
                const generatedName = `Bundled - ${vortex_api_1.util.sanitizeFilename(vortex_api_1.util.renderModName(mod, { version: true }))}`;
                const destPath = path.join(collectionPath, constants_1.BUNDLED_PATH, generatedName);
                try {
                    await vortex_api_1.fs.removeAsync(destPath);
                }
                catch (err) {
                    if (err.code !== 'ENOENT') {
                        throw err;
                    }
                }
                await Promise.all(tlFiles.map(async (name) => {
                    await vortex_api_1.fs.copyAsync(path.join(modPath, name), path.join(destPath, name));
                }));
                source.fileExpression = generatedName;
                let totalSize = 0;
                await (0, turbowalk_1.default)(destPath, items => totalSize += items.reduce((sub, entry) => sub + entry.size, 0));
                source.fileSize = totalSize;
            }
            onProgress(Math.floor((finished / total) * 100), modName);
            const dlGame = (((_o = mod.attributes) === null || _o === void 0 ? void 0 : _o.downloadGame) !== undefined)
                ? vortex_api_1.util.getGame(mod.attributes.downloadGame)
                : game;
            const domainName = (dlGame !== undefined)
                ? vortex_api_1.util.nexusGameId(dlGame) : (_p = mod.attributes) === null || _p === void 0 ? void 0 : _p.downloadGame;
            const res = {
                name: modName,
                version: (_r = (_q = mod.attributes) === null || _q === void 0 ? void 0 : _q.version) !== null && _r !== void 0 ? _r : '1.0.0',
                optional: rule.type === 'recommends',
                domainName,
                source,
                hashes,
                choices,
                patches,
                instructions: !!((_s = collectionInfo.instructions) === null || _s === void 0 ? void 0 : _s[mod.id])
                    ? (_t = collectionInfo.instructions) === null || _t === void 0 ? void 0 : _t[mod.id]
                    : undefined,
                author: (_u = mod.attributes) === null || _u === void 0 ? void 0 : _u.author,
                details: {
                    category: vortex_api_1.util.resolveCategoryName((_v = mod.attributes) === null || _v === void 0 ? void 0 : _v.category, state),
                    type: mod.type,
                },
                phase: (_x = (_w = rule.extra) === null || _w === void 0 ? void 0 : _w['phase']) !== null && _x !== void 0 ? _x : 0,
                fileOverrides: fileOverridesIds.has(mod.id) ? mod.fileOverrides : undefined,
            };
            return res;
        }
        catch (err) {
            --total;
            onError('failed to pack "{{modName}}": {{error}}', {
                modName, error: err.message, stack: err.stack,
            }, (_y = err['mayIgnore']) !== null && _y !== void 0 ? _y : true);
            if (err instanceof errors_1.ReplicateHashMismatchError) {
                api.showDialog('error', 'Collection export failed', {
                    bbcode: '"{{modName}}" cannot be exported using the replicate install mode.[br][/br][br][/br]The hashes of '
                        + 'the below files in your staging folder do not match the hashes of the files in the mod\'s '
                        + 'archive, which is guaranteed to cause issues for the end user.[br][/br][br][/br] Please consider using '
                        + 'binary patching or bundle your changes instead.',
                    parameters: {
                        modName: vortex_api_1.util.renderModName(mod),
                    },
                    message: err.affectedFiles.map(file => vortex_api_1.util.sanitizeFilename(file)).join('\n'),
                    options: {
                        order: ['bbcode', 'message'],
                    }
                }, [
                    {
                        label: 'Close',
                    },
                ], 'replicate-hash-mismatch-error-dialog');
            }
            return undefined;
        }
    }));
    return result.filter(mod => (mod !== undefined) && (Object.keys(mod.source).length > 0));
}
function makeBiDirRule(source, rule) {
    if (rule === undefined) {
        return undefined;
    }
    return {
        type: rule.type,
        reference: rule.reference,
        source,
    };
}
exports.makeBiDirRule = makeBiDirRule;
function makeTransferrable(mods, collection, rule) {
    let newRef = { ...rule.reference };
    const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
    if ((rule.reference.fileMD5 === undefined)
        && (rule.reference.logicalFileName === undefined)
        && (rule.reference.fileExpression === undefined)) {
        if (rule.reference.id === undefined) {
            (0, vortex_api_1.log)('warn', 'invalid rule couldn\'t be included in the collection', JSON.stringify(rule));
            return undefined;
        }
        if (mod === undefined) {
            (0, vortex_api_1.log)('warn', 'mod enabled in collection isn\'t installed', JSON.stringify(rule));
            return undefined;
        }
        newRef = vortex_api_1.util.makeModReference(mod);
    }
    if (mod !== undefined) {
        const mpRule = collection.rules.find(iter => vortex_api_1.util.testModReference(mod, iter.reference));
        if ((mpRule !== undefined) && ((mpRule.reference.versionMatch === undefined)
            || (mpRule.reference.versionMatch === '*')
            || (mpRule.reference.versionMatch.startsWith('>=')))) {
            newRef.versionMatch = '*';
        }
    }
    return {
        type: rule.type,
        fileList: rule.fileList,
        comment: rule.comment,
        reference: newRef,
    };
}
function ruleEnabled(rule, mods, collection) {
    var _a, _b, _c, _d;
    if (rule === undefined) {
        return false;
    }
    const ruleEx = {
        ...rule,
        sourceName: (0, util_1.renderReference)(rule.source, mods),
        referenceName: (0, util_1.renderReference)(rule.reference, mods),
    };
    const id = (0, util_1.ruleId)(ruleEx);
    return (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.rule) === null || _c === void 0 ? void 0 : _c[id]) !== null && _d !== void 0 ? _d : true;
}
function extractModRules(collectionRules, collection, mods, collectionAttributes, bundleTags) {
    return collectionRules.reduce((prev, resolvedRule) => {
        var _a, _b;
        const { mod } = resolvedRule;
        const source = vortex_api_1.util.makeModReference(mod);
        const sourceOrig = JSON.parse(JSON.stringify(source));
        const mpRule = collection.rules.find(iter => vortex_api_1.util.testModReference(mod, iter.reference));
        if ((mpRule !== undefined) && ((mpRule.reference.versionMatch === undefined)
            || (mpRule.reference.versionMatch === '*')
            || (mpRule.reference.versionMatch.startsWith('>=')))) {
            source.versionMatch = '*';
        }
        if (((_b = (_a = collectionAttributes.source) === null || _a === void 0 ? void 0 : _a[mod.id]) === null || _b === void 0 ? void 0 : _b.type) === 'bundle') {
            source.fileMD5 = undefined;
            source.tag = bundleTags[mod.id];
        }
        const includedRules = (mod.rules || [])
            .filter(rule => !['requires', 'recommends'].includes(rule.type));
        return [].concat(prev, includedRules.map((input) => {
            var _a, _b, _c, _d;
            if (((_a = input.extra) === null || _a === void 0 ? void 0 : _a['automatic']) === true) {
                return undefined;
            }
            const target = JSON.parse(JSON.stringify(input));
            const targetRef = vortex_api_1.util.findModByRef(target.reference, mods);
            const targetId = (_b = targetRef === null || targetRef === void 0 ? void 0 : targetRef.id) !== null && _b !== void 0 ? _b : target.reference.idHint;
            const targetRule = makeTransferrable(mods, collection, target);
            if (((_d = (_c = collectionAttributes.source) === null || _c === void 0 ? void 0 : _c[targetId]) === null || _d === void 0 ? void 0 : _d.type) === 'bundle') {
                target.reference.fileMD5 = undefined;
                if (targetRule !== undefined) {
                    targetRule.reference.tag = bundleTags[targetId];
                }
            }
            if ((targetRule === undefined)
                || !ruleEnabled(makeBiDirRule(sourceOrig, targetRule), mods, collection)) {
                return undefined;
            }
            return makeBiDirRule(source, targetRule);
        }));
    }, [])
        .filter(rule => rule !== undefined);
}
function collectionModToRule(knownGames, mod) {
    var _a, _b, _c, _d;
    const downloadHint = ['manual', 'browse', 'direct'].includes(mod.source.type)
        ? {
            url: mod.source.url,
            instructions: mod.source.instructions,
            mode: mod.source.type,
        }
        : undefined;
    const coerced = vortex_api_1.util.coerceToSemver(mod.version);
    let versionMatch = !!coerced
        ? `>=${coerced !== null && coerced !== void 0 ? coerced : '0.0.0'}+prefer`
        : vortex_api_1.util.coerceToSemver(mod.version);
    const { updatePolicy } = mod.source;
    if ((updatePolicy === 'exact')
        || (mod.source.type === 'bundle')
        || (mod.hashes !== undefined)) {
        versionMatch = !!coerced ? coerced : vortex_api_1.util.coerceToSemver(mod.version);
    }
    else if (updatePolicy === 'latest') {
        versionMatch = '*';
    }
    const refMD5 = (mod.source.type === 'bundle')
        ? undefined
        : mod.source.md5;
    const fileExpression = (updatePolicy === 'exact') || (mod.source.logicalFilename === undefined)
        ? mod.source.fileExpression
        : undefined;
    const reference = {
        description: mod.name,
        fileMD5: refMD5,
        gameId: vortex_api_1.util.convertGameIdReverse(knownGames, mod.domainName),
        fileSize: mod.source.fileSize,
        versionMatch,
        logicalFileName: mod.source.logicalFilename,
        fileExpression,
        tag: (_a = mod.source.tag) !== null && _a !== void 0 ? _a : (0, shortid_1.generate)(),
    };
    if (['latest', 'prefer'].includes(updatePolicy)) {
        reference['md5Hint'] = mod.source.md5;
    }
    if (mod.source.type === 'nexus') {
        if (!mod.source.modId || !mod.source.fileId) {
            const err = new Error('Invalid nexus repo specification');
            err['mod'] = mod;
            throw err;
        }
        reference['repo'] = {
            repository: 'nexus',
            gameId: mod.domainName,
            modId: mod.source.modId.toString(),
            fileId: mod.source.fileId.toString(),
            campaign: 'collection',
        };
    }
    const res = {
        type: mod.optional ? 'recommends' : 'requires',
        reference,
        fileList: mod.hashes,
        installerChoices: mod.choices,
        downloadHint,
        extra: {
            author: mod.author,
            type: (_b = mod.details) === null || _b === void 0 ? void 0 : _b.type,
            category: (_c = mod.details) === null || _c === void 0 ? void 0 : _c.category,
            version: mod.version,
            url: mod.source.url,
            name: mod.name,
            instructions: !!mod.instructions
                ? mod.instructions
                : undefined,
            phase: (_d = mod.phase) !== null && _d !== void 0 ? _d : 0,
            patches: mod.patches,
            fileOverrides: mod.fileOverrides,
        },
    };
    if (mod.source.type === 'bundle') {
        res.extra.localPath = path.join('bundled', mod.source.fileExpression);
    }
    return res;
}
exports.collectionModToRule = collectionModToRule;
async function modToCollection(api, gameId, stagingPath, collection, mods, onProgress, onError) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const state = api.getState();
    if (vortex_api_1.selectors.activeGameId(state) !== gameId) {
        return Promise.reject(new Error('Can only export collection for the active profile'));
    }
    const includedMods = collection.rules
        .map(rule => {
        let id = rule.reference.id;
        if (id === undefined) {
            const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
            if (mod !== undefined) {
                id = mod.id;
            }
        }
        return id;
    })
        .filter(id => id !== undefined);
    const missing = includedMods.find(modId => mods[modId] === undefined);
    if (missing !== undefined) {
        return Promise.reject(new Error('Can only export collections that are fully installed'));
    }
    const exts = (0, extension_1.findExtensions)(state, gameId);
    const extData = {};
    for (const ext of exts) {
        Object.assign(extData, await ext.generate(gameId, includedMods, collection));
    }
    const gameSpecific = await (0, gameSupport_1.generateGameSpecifics)(state, gameId, stagingPath, includedMods, mods);
    const game = vortex_api_1.util.getGame(gameId);
    const discovery = vortex_api_1.selectors.discoveryByGame(state, gameId);
    const gameVersions = (game !== undefined)
        ? [await game.getInstalledVersion(discovery)]
        : [];
    const collectionAttributes = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) !== null && _b !== void 0 ? _b : {};
    const collectionConfig = await (0, collectionConfig_1.generateConfig)({ gameId, collectionMod: collection });
    const collectionInfo = {
        author: (_d = (_c = collection.attributes) === null || _c === void 0 ? void 0 : _c.uploader) !== null && _d !== void 0 ? _d : 'Anonymous',
        authorUrl: (_f = (_e = collection.attributes) === null || _e === void 0 ? void 0 : _e.authorURL) !== null && _f !== void 0 ? _f : '',
        name: vortex_api_1.util.renderModName(collection),
        description: (_h = (_g = collection.attributes) === null || _g === void 0 ? void 0 : _g.shortDescription) !== null && _h !== void 0 ? _h : '',
        installInstructions: (_j = collectionAttributes.installInstructions) !== null && _j !== void 0 ? _j : '',
        domainName: vortex_api_1.util.nexusGameId(game),
        gameVersions,
    };
    const bundleTags = includedMods.reduce((prev, modId) => {
        prev[modId] = (0, shortid_1.generate)();
        return prev;
    }, {});
    const resolvedRules = collection.rules.reduce((prev, rule) => {
        const mod = (rule.reference.id !== undefined)
            ? mods[rule.reference.id]
            : vortex_api_1.util.findModByRef(rule.reference, mods);
        if (mod === undefined) {
            onError('Not packaging mod that isn\'t installed: "{{id}}"', { id: rule.reference.id }, true);
        }
        else if (mod.type === constants_1.MOD_TYPE) {
        }
        else {
            prev.push({ mod, rule });
        }
        return prev;
    }, []);
    const modRules = extractModRules(resolvedRules, collection, mods, collectionAttributes, bundleTags);
    const res = {
        info: collectionInfo,
        mods: await rulesToCollectionMods(api, collection, resolvedRules, mods, stagingPath, game, collectionAttributes, bundleTags, onProgress, onError),
        modRules,
        ...extData,
        ...gameSpecific,
        collectionConfig: { ...collectionConfig },
    };
    return res;
}
exports.modToCollection = modToCollection;
async function createTweaksFromProfile(api, profile, mods, existingId) {
    var _a;
    return (0, initweaks_1.importTweaks)(api, profile, api.getState().persistent.mods[profile.gameId], (_a = api.getState().persistent.mods[profile.gameId]) === null || _a === void 0 ? void 0 : _a[existingId]);
}
function createRulesFromProfile(profile, mods, existingRules, existingId, filterFunc, isQuickCollection) {
    var _a;
    return Object.keys((_a = profile.modState) !== null && _a !== void 0 ? _a : {})
        .filter(modId => {
        var _a, _b;
        return ((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[modId]) === null || _b === void 0 ? void 0 : _b.enabled)
            && (mods[modId] !== undefined)
            && (modId !== existingId)
            && (mods[modId].type !== constants_1.MOD_TYPE)
            && filterFunc(mods[modId]);
    })
        .map(modId => {
        let versionMatch;
        const oldRule = existingRules
            .find(iter => vortex_api_1.util.testModReference(mods[modId], iter.reference));
        if ((oldRule !== undefined) && (oldRule.reference.versionMatch !== undefined)) {
            versionMatch = (oldRule.reference.versionMatch === '*')
                ? '*'
                : mods[modId].attributes.version;
        }
        if (isQuickCollection) {
            versionMatch = mods[modId].attributes.version;
        }
        return {
            type: 'requires',
            reference: {
                id: modId,
                archiveId: mods[modId].archiveId,
                versionMatch,
            },
        };
    });
}
function makeCollectionId(baseId) {
    return `vortex_collection_${baseId}`;
}
exports.makeCollectionId = makeCollectionId;
function deduceCollectionAttributes(collectionMod, collection, mods) {
    var _a;
    const res = {
        installMode: {},
        instructions: {},
        source: {},
        saveEdits: {},
    };
    ((_a = collectionMod.rules) !== null && _a !== void 0 ? _a : []).forEach(rule => {
        var _a, _b, _c, _d, _e, _f, _g;
        const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
        if (mod === undefined) {
            return;
        }
        res.installMode[mod.id] = (rule.installerChoices !== undefined)
            ? 'choices'
            : (rule.fileList !== undefined)
                ? 'clone'
                : 'fresh';
        res.instructions[mod.id] = (_a = rule.extra) === null || _a === void 0 ? void 0 : _a.instructions;
        res.source[mod.id] = {
            type: (_c = (_b = rule.downloadHint) === null || _b === void 0 ? void 0 : _b.mode) !== null && _c !== void 0 ? _c : ((((_d = rule.reference.repo) === null || _d === void 0 ? void 0 : _d.repository) === 'nexus') ? 'nexus' : 'bundle'),
            url: (_e = rule.downloadHint) === null || _e === void 0 ? void 0 : _e.url,
            instructions: (_f = rule.downloadHint) === null || _f === void 0 ? void 0 : _f.instructions,
        };
        res.saveEdits[mod.id] = ((_g = rule.extra) === null || _g === void 0 ? void 0 : _g.patches) !== undefined;
    });
    return res;
}
async function cloneCollection(api, gameId, id, sourceId) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const state = api.getState();
    const t = api.translate;
    const { userInfo } = (_a = state.persistent['nexus']) !== null && _a !== void 0 ? _a : {};
    const mods = ((_b = state.persistent.mods[gameId]) !== null && _b !== void 0 ? _b : {});
    const existingCollection = mods[sourceId];
    const stagingPath = vortex_api_1.selectors.installPathForGame(state, gameId);
    let collection;
    try {
        const collectionData = await vortex_api_1.fs.readFileAsync(path.join(stagingPath, existingCollection.installationPath, 'collection.json'), { encoding: 'utf-8' });
        collection = JSON.parse(collectionData);
    }
    catch (err) {
        api.showErrorNotification('Failed to clone collection', err);
        return undefined;
    }
    const ruleFilter = (rule) => {
        if (rule.ignored) {
            return false;
        }
        if (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined) {
            return false;
        }
        return true;
    };
    const ruleSimplify = (rule) => {
        const referencedMod = vortex_api_1.util.findModByRef(rule.reference, mods);
        return ({
            ...rule,
            reference: {
                archiveId: referencedMod.archiveId,
                id: referencedMod.id,
                idHint: referencedMod.id,
                versionMatch: rule.reference.versionMatch,
            },
        });
    };
    const ownCollection = ((_c = existingCollection.attributes) === null || _c === void 0 ? void 0 : _c.uploaderId) === (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId);
    let name = 'Copy of ' + ((_d = existingCollection.attributes) === null || _d === void 0 ? void 0 : _d.name);
    if (name.length > constants_1.MAX_COLLECTION_NAME_LENGTH) {
        name = name.slice(0, constants_1.MAX_COLLECTION_NAME_LENGTH) + '...';
    }
    const customFileName = ownCollection
        ? (_e = existingCollection.attributes) === null || _e === void 0 ? void 0 : _e.customFileName
        : t('Copy of {{name}}', { replace: { name: (_f = existingCollection.attributes) === null || _f === void 0 ? void 0 : _f.customFileName } });
    const ownCollectionAttributes = ownCollection ? ({
        pictureUrl: existingCollection.attributes.pictureUrl,
        uploader: userInfo.name,
        uploaderAvatar: existingCollection.attributes.uploaderAvatar,
    }) : {};
    const mod = {
        id,
        type: constants_1.MOD_TYPE,
        state: 'installed',
        attributes: {
            name,
            customFileName,
            version: ownCollection ? (_g = existingCollection.attributes) === null || _g === void 0 ? void 0 : _g.version : '0',
            installTime: new Date(),
            author: (_h = userInfo === null || userInfo === void 0 ? void 0 : userInfo.name) !== null && _h !== void 0 ? _h : 'Anonymous',
            uploader: (_j = userInfo === null || userInfo === void 0 ? void 0 : userInfo.name) !== null && _j !== void 0 ? _j : 'Anonymous',
            uploaderId: userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId,
            editable: true,
            collectionId: ownCollection ? (_k = existingCollection.attributes) === null || _k === void 0 ? void 0 : _k.collectionId : undefined,
            revisionId: ownCollection ? (_l = existingCollection.attributes) === null || _l === void 0 ? void 0 : _l.revisionId : undefined,
            collectionSlug: ownCollection ? (_m = existingCollection.attributes) === null || _m === void 0 ? void 0 : _m.collectionSlug : undefined,
            revisionNumber: ownCollection
                ? (((_o = existingCollection.attributes) === null || _o === void 0 ? void 0 : _o.revisionNumber) + 1) : undefined,
            collection: deduceCollectionAttributes(existingCollection, collection, mods),
            ...ownCollectionAttributes,
        },
        installationPath: id,
        rules: existingCollection.rules
            .filter(ruleFilter)
            .map(ruleSimplify),
    };
    try {
        await new Promise((resolve, reject) => {
            api.events.emit('create-mod', gameId, mod, (error) => {
                if (error !== null) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
        const deployPath = vortex_api_1.selectors.installPathForGame(state, gameId);
        const sourcePath = path.join(deployPath, sourceId);
        const clonePath = path.join(deployPath, id);
        const files = await vortex_api_1.fs.readdirAsync(sourcePath);
        for (const file of files) {
            await vortex_api_1.fs.copyAsync(path.join(sourcePath, file), path.join(clonePath, file));
        }
        const exts = (0, extension_1.findExtensions)(api.getState(), gameId);
        for (const ext of exts) {
            if (ext.clone !== undefined) {
                await ext.clone(gameId, collection, existingCollection, mod);
            }
        }
        return id;
    }
    catch (err) {
        api.showErrorNotification('Failed to clone collection', err);
        return undefined;
    }
}
exports.cloneCollection = cloneCollection;
async function createCollection(api, gameId, id, name, rules) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const state = api.store.getState();
    const mod = {
        id,
        type: constants_1.MOD_TYPE,
        state: 'installed',
        attributes: {
            name,
            version: '0',
            installTime: new Date(),
            author: (_c = (_b = (_a = state.persistent['nexus']) === null || _a === void 0 ? void 0 : _a.userInfo) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : 'Anonymous',
            uploader: (_f = (_e = (_d = state.persistent['nexus']) === null || _d === void 0 ? void 0 : _d.userInfo) === null || _e === void 0 ? void 0 : _e.name) !== null && _f !== void 0 ? _f : 'Anonymous',
            uploaderId: (_h = (_g = state.persistent['nexus']) === null || _g === void 0 ? void 0 : _g.userInfo) === null || _h === void 0 ? void 0 : _h.user_id,
            editable: true,
            source: 'user-generated',
            recommendNewProfile: false,
        },
        installationPath: id,
        rules,
    };
    try {
        await new Promise((resolve, reject) => {
            api.events.emit('create-mod', gameId, mod, (error) => {
                if (error !== null) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    catch (err) {
        api.showErrorNotification('Failed to create collection', err);
    }
}
exports.createCollection = createCollection;
function updateCollection(api, gameId, mod, newRules) {
    var _a;
    api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, mod.id, 'editable', true));
    const removedRules = [];
    vortex_api_1.util.batchDispatch(api.store, ((_a = mod.rules) !== null && _a !== void 0 ? _a : []).reduce((prev, rule) => {
        if (newRules.find(iter => _.isEqual(rule, iter)) === undefined) {
            removedRules.push(rule);
            prev.push(vortex_api_1.actions.removeModRule(gameId, mod.id, rule));
        }
        return prev;
    }, []));
    vortex_api_1.util.batchDispatch(api.store, newRules.reduce((prev, rule) => {
        var _a;
        if (((_a = mod.rules) !== null && _a !== void 0 ? _a : []).find(iter => _.isEqual(rule, iter)) === undefined) {
            prev.push(vortex_api_1.actions.addModRule(gameId, mod.id, rule));
        }
        return prev;
    }, []));
}
function validateName(t, content) {
    const input = content.input[0].value || '';
    if ((input.length >= constants_1.MIN_COLLECTION_NAME_LENGTH)
        && (input.length <= constants_1.MAX_COLLECTION_NAME_LENGTH)) {
        return [];
    }
    else {
        return [{
                id: 'name',
                errorText: t('Name must be between {{min}}-{{max}} characters long', {
                    replace: {
                        min: constants_1.MIN_COLLECTION_NAME_LENGTH,
                        max: constants_1.MAX_COLLECTION_NAME_LENGTH,
                    },
                }),
                actions: ['Create'],
            }];
    }
}
exports.validateName = validateName;
async function showQuickCollectionRestrictionsDialog(api) {
    var _a;
    const t = api.translate;
    const state = api.store.getState();
    const profileId = (_a = vortex_api_1.selectors.activeProfile(state)) === null || _a === void 0 ? void 0 : _a.id;
    if (!profileId) {
        return;
    }
    const restrictionsDialog = await api.showDialog('info', 'Quick Collection', {
        bbcode: t('Quick Collections create a backup of your mod list for easy import by another PC or mod manager. '
            + 'They can be created in a few clicks but do not include all the features of a "full" collection.[br][/br][br][/br]'
            + 'Your Quick Collection will include:[br][/br]'
            + '[list]'
            + '[*] All mods downloaded from Nexus Mods that are currently enabled and deployed.'
            + '[*] Installer choices for mods that support installers (such as FOMODs).'
            + '[*] File conflict rules.'
            + '[*] Load order rules.'
            + '[/list][br][/br]'
            + 'Quick Collections do NOT include:[br][/br]'
            + '[list]'
            + '[*] Mods from sources other than Nexus Mods.'
            + '[*] Alterations you have made mods after installing them.'
            + '[*] Outputs of automated tools generated on your PC (FNIS, Script Merger, etc).'
            + '[*] Mods that you have created on your PC and added to Vortex.'
            + '[/list][br][/br]'
            + 'If you are using this feature migrate your mod list to the Nexus Mods app, see the '
            + `[url=https://nexus-mods.github.io/NexusMods.App/users/gettingstarted/MovingToTheApp/]full guide here.[/url]`),
    }, [
        { label: 'Cancel' },
        { label: 'Proceed' },
    ]);
    return (restrictionsDialog.action === 'Cancel')
        ? Promise.reject(new vortex_api_1.util.UserCanceled())
        : Promise.resolve();
}
exports.showQuickCollectionRestrictionsDialog = showQuickCollectionRestrictionsDialog;
async function createCollectionFromProfile(api, profileId, forceName) {
    var _a, _b, _c, _d, _e;
    const state = api.store.getState();
    const profile = state.persistent.profiles[profileId];
    const isQuickCollection = forceName !== undefined;
    const id = (isQuickCollection)
        ? makeCollectionId(`${profileId}_${(0, shortid_1.generate)()}`)
        : makeCollectionId(profileId);
    const mod = (_a = state.persistent.mods[profile.gameId]) === null || _a === void 0 ? void 0 : _a[id];
    const isNexusSourced = (m) => { var _a; return (((_a = m === null || m === void 0 ? void 0 : m.attributes) === null || _a === void 0 ? void 0 : _a.source) === 'nexus'); };
    const isGeneratedMod = (m) => { var _a; return (((_a = m === null || m === void 0 ? void 0 : m.attributes) === null || _a === void 0 ? void 0 : _a.generated) === true); };
    const filterFunc = (m) => forceName ? (isNexusSourced(m) && !isGeneratedMod(m)) : true;
    const rules = createRulesFromProfile(profile, (_b = state.persistent.mods[profile.gameId]) !== null && _b !== void 0 ? _b : {}, (_c = mod === null || mod === void 0 ? void 0 : mod.rules) !== null && _c !== void 0 ? _c : [], mod === null || mod === void 0 ? void 0 : mod.id, filterFunc, isQuickCollection);
    let name = forceName !== null && forceName !== void 0 ? forceName : profile.name;
    const uploadLabel = 'Create and Upload';
    let wantsToUpload = false;
    if (mod === undefined) {
        const t = api.translate;
        const result = await api.showDialog('question', 'New collection from profile', {
            text: 'Create a collection containing the mods enabled in your current profile.',
            input: [{
                    id: 'name',
                    label: 'Please enter a name for your new collection',
                    type: 'text',
                    value: name,
                }],
            condition: content => validateName(t, content),
        }, [
            { label: 'Cancel' },
            { label: forceName ? uploadLabel : 'Create', default: true },
        ]);
        const cancelled = result.action === 'Cancel';
        if (cancelled) {
            throw new vortex_api_1.util.UserCanceled();
        }
        wantsToUpload = result.action === uploadLabel;
        name = result.input['name'];
        await createCollection(api, profile.gameId, id, name, rules);
        await createTweaksFromProfile(api, profile, (_d = state.persistent.mods[profile.gameId]) !== null && _d !== void 0 ? _d : {}, id);
    }
    else {
        name = (_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.name;
        updateCollection(api, profile.gameId, mod, rules);
    }
    return { id, name, updated: mod !== undefined, wantsToUpload };
}
exports.createCollectionFromProfile = createCollectionFromProfile;


/***/ }),

/***/ "./src/util/util.ts":
/*!**************************!*\
  !*** ./src/util/util.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uploadCollection = exports.isEmpty = exports.walkPath = exports.fileMD5Async = exports.calculateCollectionSize = exports.isRelevant = exports.modRuleId = exports.ruleId = exports.renderReference = exports.md5sum = exports.getUnfulfilledNotificationId = exports.bbProm = exports.makeProgressFunction = void 0;
const PromiseBB = __webpack_require__(/*! bluebird */ "bluebird");
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const collectionExport_1 = __webpack_require__(/*! ../collectionExport */ "./src/collectionExport.ts");
const vortexmt_1 = __webpack_require__(/*! vortexmt */ "vortexmt");
const turbowalk_1 = __webpack_require__(/*! turbowalk */ "turbowalk");
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
function makeProgressFunction(api) {
    const notificationId = api.sendNotification({
        type: 'activity',
        title: 'Building Collection',
        message: '',
        progress: 0,
    });
    let notiPerc = 0;
    let notiText = '';
    const items = new Set();
    const progress = (percent, text) => {
        let change = false;
        if ((percent !== undefined)) {
            if (percent > notiPerc) {
                change = true;
                notiPerc = percent;
            }
            if (text !== undefined) {
                items.delete(text);
                if (items.size > 0) {
                    const itemList = Array.from(items);
                    const newText = itemList[itemList.length - 1];
                    if (newText !== notiText) {
                        change = true;
                        notiText = newText;
                    }
                }
            }
        }
        if ((percent === undefined) && (text !== undefined) && (text !== notiText)) {
            change = true;
            notiText = text;
            if (percent === undefined) {
                items.add(text);
            }
        }
        if (change) {
            api.sendNotification({
                id: notificationId,
                type: 'activity',
                title: 'Building Collection',
                progress: notiPerc,
                message: notiText,
            });
        }
    };
    const progressEnd = () => {
        api.dismissNotification(notificationId);
    };
    return { progress, progressEnd };
}
exports.makeProgressFunction = makeProgressFunction;
function bbProm(func) {
    return (...args) => PromiseBB.resolve(func(...args));
}
exports.bbProm = bbProm;
function getUnfulfilledNotificationId(collectionId) {
    return `collection-incomplete-${collectionId}`;
}
exports.getUnfulfilledNotificationId = getUnfulfilledNotificationId;
function md5sum(input) {
    const hash = (0, crypto_1.createHash)('md5');
    hash.update(input);
    return hash.digest('hex');
}
exports.md5sum = md5sum;
function renderReference(ref, mods) {
    const mod = vortex_api_1.util.findModByRef(ref, mods);
    return vortex_api_1.util.renderModReference(ref, mod);
}
exports.renderReference = renderReference;
function ruleId(rule) {
    return md5sum(`${rule.sourceName}-${rule.type}-${rule.referenceName}`);
}
exports.ruleId = ruleId;
function modRuleId(input) {
    return input.type + '_' + (input.reference.fileMD5
        || input.reference.id
        || input.reference.logicalFileName
        || input.reference.fileExpression
        || input.reference.description);
}
exports.modRuleId = modRuleId;
function isRelevant(mod) {
    if (!!mod.state) {
        return true;
    }
    if (mod.collectionRule['ignored']) {
        return false;
    }
    if (mod.collectionRule.type !== 'requires') {
        return false;
    }
    return true;
}
exports.isRelevant = isRelevant;
function calculateCollectionSize(mods) {
    return Object.values(mods).reduce((prev, mod) => {
        var _a, _b, _c;
        if (!isRelevant(mod)) {
            return prev;
        }
        const size = (_c = (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.fileSize) !== null && _b !== void 0 ? _b : mod.collectionRule.reference.fileSize) !== null && _c !== void 0 ? _c : 0;
        return prev + size;
    }, 0);
}
exports.calculateCollectionSize = calculateCollectionSize;
async function fileMD5Async(fileName) {
    return new Promise((resolve, reject) => {
        (0, vortexmt_1.fileMD5)(fileName, (err, result) => (err !== null) ? reject(err) : resolve(result), () => null);
    });
}
exports.fileMD5Async = fileMD5Async;
async function walkPath(dirPath, walkOptions) {
    walkOptions = walkOptions || { skipLinks: true, skipHidden: true, skipInaccessible: true };
    const walkResults = [];
    return new Promise(async (resolve, reject) => {
        await (0, turbowalk_1.default)(dirPath, async (entries) => {
            for (const entry of entries) {
                const md5 = await fileMD5Async(entry.filePath);
                const extendedEntry = { ...entry, fileMD5: md5 };
                walkResults.push(extendedEntry);
            }
            return Promise.resolve();
        }, walkOptions).catch(err => err.code === 'ENOENT' ? Promise.resolve() : Promise.reject(err));
        return resolve(walkResults);
    });
}
exports.walkPath = walkPath;
function isEmpty(value) {
    return (!value)
        || (value.hasOwnProperty('length') && value.length === 0)
        || (value.constructor === Object && Object.keys(value).length === 0);
}
exports.isEmpty = isEmpty;
async function uploadCollection(api, profileId, collectionId) {
    var _a, _b;
    if (!profileId || !collectionId) {
        return;
    }
    const state = api.getState();
    const profile = vortex_api_1.selectors.profileById(state, profileId);
    const userInfo = vortex_api_1.util.getSafe(state, ['persistent', 'nexus', 'userInfo'], undefined);
    if (userInfo === undefined) {
        api.showErrorNotification('Not logged in', 'You have to be logged into nexusmods.com to upload collections.');
        return;
    }
    const mods = vortex_api_1.util.getSafe(state, ['persistent', 'mods', profile.gameId], {});
    if (mods[collectionId] === undefined) {
        return;
    }
    api.events.emit('analytics-track-click-event', 'Collections', 'Upload collection');
    const missing = ((_b = (_a = mods[collectionId]) === null || _a === void 0 ? void 0 : _a.rules) !== null && _b !== void 0 ? _b : []).filter(rule => ['requires', 'recommends'].includes(rule.type)
        && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined));
    if (missing.length > 0) {
        await api.showDialog('error', 'Collection isn\'t fully installed', {
            text: 'You can only upload collections that are fully installed on this system.\n'
                + 'If you have removed mods that were part of this collection you may want to remove '
                + 'them from the collection as well. If this collection is connected to a '
                + 'profile you can simply update from that.',
            message: missing.map(rule => vortex_api_1.util.renderModReference(rule.reference)).join('\n'),
        }, [
            { label: 'Close' },
        ]);
        return;
    }
    const choice = await api.showDialog('question', 'Share on Nexus Mods', {
        bbcode: 'You are about to upload "{{collectionName}}" to Nexus Mods in a draft state. '
            + 'You will be able to add additional metadata and media before sharing it with '
            + 'the community.'
            + '\n\n'
            + 'Please ensure that your collection complies with our '
            + `[url=${constants_1.TOS_URL}]Collections Guidelines[/url] before publishing.`,
        parameters: {
            collectionName: vortex_api_1.util.renderModName(mods[collectionId]),
        },
    }, [
        { label: 'Cancel' },
        { label: 'Upload' },
    ]);
    if (choice.action === 'Upload') {
        try {
            const { slug, revisionNumber } = await (0, collectionExport_1.doExportToAPI)(api, profile.gameId, collectionId, userInfo.name);
            if ((slug !== undefined) && (revisionNumber !== undefined)) {
                api.sendNotification({
                    type: 'success',
                    message: 'Collection submitted',
                    actions: [
                        {
                            title: 'Open in Browser', action: () => {
                                const game = vortex_api_1.selectors.gameById(api.getState(), profile.gameId);
                                const domainName = vortex_api_1.util.nexusGameId(game);
                                const url = vortex_api_1.util.nexusModsURL([domainName, 'collections', slug, 'revisions', revisionNumber.toString()], {
                                    campaign: vortex_api_1.util.Campaign.ViewCollection,
                                    section: vortex_api_1.util.Section.Collections,
                                });
                                vortex_api_1.util.opn(url).catch(() => null);
                            },
                        },
                    ],
                });
            }
        }
        catch (err) {
            if (!(err instanceof vortex_api_1.util.UserCanceled)
                && !(err instanceof vortex_api_1.util.ProcessCanceled)) {
                api.showErrorNotification('Failed to upload to API', err, {
                    allowReport: false,
                });
            }
        }
    }
}
exports.uploadCollection = uploadCollection;


/***/ }),

/***/ "./src/validationCode/ICollection.validate.js":
/*!****************************************************!*\
  !*** ./src/validationCode/ICollection.validate.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = validate10;module.exports["default"] = validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","anyOf":[{"$ref":"#/definitions/ICollection"}],"definitions":{"ICollection":{"type":"object","properties":{"plugins":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"enabled":{"type":"boolean"}},"required":["name"]}},"pluginRules":{"type":"object","properties":{"plugins":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"group":{"type":"string"},"after":{"type":"array","items":{"type":"string"}}},"required":["name"]}},"groups":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"group":{"type":"string"},"after":{"type":"array","items":{"type":"string"}}},"required":["name"]}}},"required":["plugins"]},"info":{"$ref":"#/definitions/ICollectionInfo"},"mods":{"type":"array","items":{"$ref":"#/definitions/ICollectionMod"}},"modRules":{"type":"array","items":{"$ref":"#/definitions/ICollectionModRule"}}},"required":["info","mods","modRules"]},"ICollectionInfo":{"type":"object","properties":{"author":{"type":"string"},"authorUrl":{"type":"string"},"name":{"type":"string"},"description":{"type":"string"},"domainName":{"type":"string"},"gameVersions":{"type":"array","items":{"type":"string"}}},"required":["author","authorUrl","name","description","domainName"]},"ICollectionMod":{"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"},"optional":{"type":"boolean"},"domainName":{"type":"string"},"source":{"$ref":"#/definitions/ICollectionSourceInfo"},"hashes":{},"choices":{},"patches":{"type":"object","additionalProperties":{"type":"string"}},"instructions":{"type":"string"},"author":{"type":"string"},"details":{"$ref":"#/definitions/ICollectionModDetails"},"phase":{"type":"number"},"fileOverrides":{"type":"array","items":{"type":"string"}}},"required":["name","version","optional","domainName","source"]},"ICollectionSourceInfo":{"type":"object","properties":{"type":{"$ref":"#/definitions/SourceType"},"url":{"type":"string"},"instructions":{"type":"string"},"modId":{"type":"number"},"fileId":{"type":"number"},"updatePolicy":{"$ref":"#/definitions/UpdatePolicy"},"adultContent":{"type":"boolean"},"md5":{"type":"string"},"fileSize":{"type":"number"},"logicalFilename":{"type":"string"},"fileExpression":{"type":"string"},"tag":{"type":"string"}},"required":["type"]},"SourceType":{"type":"string","enum":["browse","manual","direct","nexus","bundle"]},"UpdatePolicy":{"type":"string","enum":["exact","latest","prefer"]},"ICollectionModDetails":{"type":"object","properties":{"type":{"type":"string"},"category":{"type":"string"}}},"ICollectionModRule":{"type":"object","properties":{"source":{"$ref":"#/definitions/IModReference"},"type":{"$ref":"#/definitions/RuleType"},"reference":{"$ref":"#/definitions/IModReference"}},"required":["source","type","reference"]},"IModReference":{"type":"object","properties":{"fileMD5":{"type":"string"},"fileSize":{"type":"number"},"gameId":{"type":"string"},"versionMatch":{"type":"string"},"logicalFileName":{"type":"string"},"fileExpression":{"type":"string"},"id":{"type":"string"},"idHint":{"type":"string"},"md5Hint":{"type":"string"},"tag":{"type":"string"},"archiveId":{"type":"string"},"repo":{"type":"object","properties":{"gameId":{"type":"string"},"modId":{"type":"string"},"fileId":{"type":"string"},"repository":{"type":"string"},"campaign":{"type":"string"}},"required":["fileId","repository"]},"description":{"type":"string"},"instructions":{"type":"string"}}},"RuleType":{"type":"string","enum":["before","after","requires","conflicts","recommends","provides"]}},"exported":["ICollection"]};const schema12 = {"type":"object","properties":{"plugins":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"enabled":{"type":"boolean"}},"required":["name"]}},"pluginRules":{"type":"object","properties":{"plugins":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"group":{"type":"string"},"after":{"type":"array","items":{"type":"string"}}},"required":["name"]}},"groups":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"group":{"type":"string"},"after":{"type":"array","items":{"type":"string"}}},"required":["name"]}}},"required":["plugins"]},"info":{"$ref":"#/definitions/ICollectionInfo"},"mods":{"type":"array","items":{"$ref":"#/definitions/ICollectionMod"}},"modRules":{"type":"array","items":{"$ref":"#/definitions/ICollectionModRule"}}},"required":["info","mods","modRules"]};const schema13 = {"type":"object","properties":{"author":{"type":"string"},"authorUrl":{"type":"string"},"name":{"type":"string"},"description":{"type":"string"},"domainName":{"type":"string"},"gameVersions":{"type":"array","items":{"type":"string"}}},"required":["author","authorUrl","name","description","domainName"]};const schema14 = {"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"},"optional":{"type":"boolean"},"domainName":{"type":"string"},"source":{"$ref":"#/definitions/ICollectionSourceInfo"},"hashes":{},"choices":{},"patches":{"type":"object","additionalProperties":{"type":"string"}},"instructions":{"type":"string"},"author":{"type":"string"},"details":{"$ref":"#/definitions/ICollectionModDetails"},"phase":{"type":"number"},"fileOverrides":{"type":"array","items":{"type":"string"}}},"required":["name","version","optional","domainName","source"]};const schema18 = {"type":"object","properties":{"type":{"type":"string"},"category":{"type":"string"}}};const schema15 = {"type":"object","properties":{"type":{"$ref":"#/definitions/SourceType"},"url":{"type":"string"},"instructions":{"type":"string"},"modId":{"type":"number"},"fileId":{"type":"number"},"updatePolicy":{"$ref":"#/definitions/UpdatePolicy"},"adultContent":{"type":"boolean"},"md5":{"type":"string"},"fileSize":{"type":"number"},"logicalFilename":{"type":"string"},"fileExpression":{"type":"string"},"tag":{"type":"string"}},"required":["type"]};const schema16 = {"type":"string","enum":["browse","manual","direct","nexus","bundle"]};const schema17 = {"type":"string","enum":["exact","latest","prefer"]};const func0 = (__webpack_require__(/*! ./dummy */ "./src/validationCode/dummy.js")["default"]);function validate13(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(data && typeof data == "object" && !Array.isArray(data)){if(data.type === undefined){const err0 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "type"},message:"must have required property '"+"type"+"'",schema:schema15.required,parentSchema:schema15,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}if(data.type !== undefined){let data0 = data.type;if(typeof data0 !== "string"){const err1 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/SourceType/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema16.type,parentSchema:schema16,data:data0};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}if(!(((((data0 === "browse") || (data0 === "manual")) || (data0 === "direct")) || (data0 === "nexus")) || (data0 === "bundle"))){const err2 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/SourceType/enum",keyword:"enum",params:{allowedValues: schema16.enum},message:"must be equal to one of the allowed values",schema:schema16.enum,parentSchema:schema16,data:data0};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}}if(data.url !== undefined){let data1 = data.url;if(typeof data1 !== "string"){const err3 = {instancePath:instancePath+"/url",schemaPath:"#/properties/url/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.url.type,parentSchema:schema15.properties.url,data:data1};if(vErrors === null){vErrors = [err3];}else {vErrors.push(err3);}errors++;}}if(data.instructions !== undefined){let data2 = data.instructions;if(typeof data2 !== "string"){const err4 = {instancePath:instancePath+"/instructions",schemaPath:"#/properties/instructions/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.instructions.type,parentSchema:schema15.properties.instructions,data:data2};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}}if(data.modId !== undefined){let data3 = data.modId;if(!((typeof data3 == "number") && (isFinite(data3)))){const err5 = {instancePath:instancePath+"/modId",schemaPath:"#/properties/modId/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema15.properties.modId.type,parentSchema:schema15.properties.modId,data:data3};if(vErrors === null){vErrors = [err5];}else {vErrors.push(err5);}errors++;}}if(data.fileId !== undefined){let data4 = data.fileId;if(!((typeof data4 == "number") && (isFinite(data4)))){const err6 = {instancePath:instancePath+"/fileId",schemaPath:"#/properties/fileId/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema15.properties.fileId.type,parentSchema:schema15.properties.fileId,data:data4};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}}if(data.updatePolicy !== undefined){let data5 = data.updatePolicy;if(typeof data5 !== "string"){const err7 = {instancePath:instancePath+"/updatePolicy",schemaPath:"#/definitions/UpdatePolicy/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema17.type,parentSchema:schema17,data:data5};if(vErrors === null){vErrors = [err7];}else {vErrors.push(err7);}errors++;}if(!(((data5 === "exact") || (data5 === "latest")) || (data5 === "prefer"))){const err8 = {instancePath:instancePath+"/updatePolicy",schemaPath:"#/definitions/UpdatePolicy/enum",keyword:"enum",params:{allowedValues: schema17.enum},message:"must be equal to one of the allowed values",schema:schema17.enum,parentSchema:schema17,data:data5};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}}if(data.adultContent !== undefined){let data6 = data.adultContent;if(typeof data6 !== "boolean"){const err9 = {instancePath:instancePath+"/adultContent",schemaPath:"#/properties/adultContent/type",keyword:"type",params:{type: "boolean"},message:"must be boolean",schema:schema15.properties.adultContent.type,parentSchema:schema15.properties.adultContent,data:data6};if(vErrors === null){vErrors = [err9];}else {vErrors.push(err9);}errors++;}}if(data.md5 !== undefined){let data7 = data.md5;if(typeof data7 !== "string"){const err10 = {instancePath:instancePath+"/md5",schemaPath:"#/properties/md5/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.md5.type,parentSchema:schema15.properties.md5,data:data7};if(vErrors === null){vErrors = [err10];}else {vErrors.push(err10);}errors++;}}if(data.fileSize !== undefined){let data8 = data.fileSize;if(!((typeof data8 == "number") && (isFinite(data8)))){const err11 = {instancePath:instancePath+"/fileSize",schemaPath:"#/properties/fileSize/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema15.properties.fileSize.type,parentSchema:schema15.properties.fileSize,data:data8};if(vErrors === null){vErrors = [err11];}else {vErrors.push(err11);}errors++;}}if(data.logicalFilename !== undefined){let data9 = data.logicalFilename;if(typeof data9 !== "string"){const err12 = {instancePath:instancePath+"/logicalFilename",schemaPath:"#/properties/logicalFilename/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.logicalFilename.type,parentSchema:schema15.properties.logicalFilename,data:data9};if(vErrors === null){vErrors = [err12];}else {vErrors.push(err12);}errors++;}}if(data.fileExpression !== undefined){let data10 = data.fileExpression;if(typeof data10 !== "string"){const err13 = {instancePath:instancePath+"/fileExpression",schemaPath:"#/properties/fileExpression/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.fileExpression.type,parentSchema:schema15.properties.fileExpression,data:data10};if(vErrors === null){vErrors = [err13];}else {vErrors.push(err13);}errors++;}}if(data.tag !== undefined){let data11 = data.tag;if(typeof data11 !== "string"){const err14 = {instancePath:instancePath+"/tag",schemaPath:"#/properties/tag/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema15.properties.tag.type,parentSchema:schema15.properties.tag,data:data11};if(vErrors === null){vErrors = [err14];}else {vErrors.push(err14);}errors++;}}}else {const err15 = {instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema15.type,parentSchema:schema15,data};if(vErrors === null){vErrors = [err15];}else {vErrors.push(err15);}errors++;}validate13.errors = vErrors;return errors === 0;}function validate12(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(data && typeof data == "object" && !Array.isArray(data)){if(data.name === undefined){const err0 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}if(data.version === undefined){const err1 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "version"},message:"must have required property '"+"version"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}if(data.optional === undefined){const err2 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "optional"},message:"must have required property '"+"optional"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}if(data.domainName === undefined){const err3 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "domainName"},message:"must have required property '"+"domainName"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err3];}else {vErrors.push(err3);}errors++;}if(data.source === undefined){const err4 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "source"},message:"must have required property '"+"source"+"'",schema:schema14.required,parentSchema:schema14,data};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}if(data.name !== undefined){let data0 = data.name;if(typeof data0 !== "string"){const err5 = {instancePath:instancePath+"/name",schemaPath:"#/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.name.type,parentSchema:schema14.properties.name,data:data0};if(vErrors === null){vErrors = [err5];}else {vErrors.push(err5);}errors++;}}if(data.version !== undefined){let data1 = data.version;if(typeof data1 !== "string"){const err6 = {instancePath:instancePath+"/version",schemaPath:"#/properties/version/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.version.type,parentSchema:schema14.properties.version,data:data1};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}}if(data.optional !== undefined){let data2 = data.optional;if(typeof data2 !== "boolean"){const err7 = {instancePath:instancePath+"/optional",schemaPath:"#/properties/optional/type",keyword:"type",params:{type: "boolean"},message:"must be boolean",schema:schema14.properties.optional.type,parentSchema:schema14.properties.optional,data:data2};if(vErrors === null){vErrors = [err7];}else {vErrors.push(err7);}errors++;}}if(data.domainName !== undefined){let data3 = data.domainName;if(typeof data3 !== "string"){const err8 = {instancePath:instancePath+"/domainName",schemaPath:"#/properties/domainName/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.domainName.type,parentSchema:schema14.properties.domainName,data:data3};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}}if(data.source !== undefined){if(!(validate13(data.source, {instancePath:instancePath+"/source",parentData:data,parentDataProperty:"source",rootData}))){vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);errors = vErrors.length;}}if(data.patches !== undefined){let data5 = data.patches;if(data5 && typeof data5 == "object" && !Array.isArray(data5)){for(const key0 in data5){let data6 = data5[key0];if(typeof data6 !== "string"){const err9 = {instancePath:instancePath+"/patches/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"),schemaPath:"#/properties/patches/additionalProperties/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.patches.additionalProperties.type,parentSchema:schema14.properties.patches.additionalProperties,data:data6};if(vErrors === null){vErrors = [err9];}else {vErrors.push(err9);}errors++;}}}else {const err10 = {instancePath:instancePath+"/patches",schemaPath:"#/properties/patches/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema14.properties.patches.type,parentSchema:schema14.properties.patches,data:data5};if(vErrors === null){vErrors = [err10];}else {vErrors.push(err10);}errors++;}}if(data.instructions !== undefined){let data7 = data.instructions;if(typeof data7 !== "string"){const err11 = {instancePath:instancePath+"/instructions",schemaPath:"#/properties/instructions/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.instructions.type,parentSchema:schema14.properties.instructions,data:data7};if(vErrors === null){vErrors = [err11];}else {vErrors.push(err11);}errors++;}}if(data.author !== undefined){let data8 = data.author;if(typeof data8 !== "string"){const err12 = {instancePath:instancePath+"/author",schemaPath:"#/properties/author/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.author.type,parentSchema:schema14.properties.author,data:data8};if(vErrors === null){vErrors = [err12];}else {vErrors.push(err12);}errors++;}}if(data.details !== undefined){let data9 = data.details;if(data9 && typeof data9 == "object" && !Array.isArray(data9)){if(data9.type !== undefined){let data10 = data9.type;if(typeof data10 !== "string"){const err13 = {instancePath:instancePath+"/details/type",schemaPath:"#/definitions/ICollectionModDetails/properties/type/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema18.properties.type.type,parentSchema:schema18.properties.type,data:data10};if(vErrors === null){vErrors = [err13];}else {vErrors.push(err13);}errors++;}}if(data9.category !== undefined){let data11 = data9.category;if(typeof data11 !== "string"){const err14 = {instancePath:instancePath+"/details/category",schemaPath:"#/definitions/ICollectionModDetails/properties/category/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema18.properties.category.type,parentSchema:schema18.properties.category,data:data11};if(vErrors === null){vErrors = [err14];}else {vErrors.push(err14);}errors++;}}}else {const err15 = {instancePath:instancePath+"/details",schemaPath:"#/definitions/ICollectionModDetails/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema18.type,parentSchema:schema18,data:data9};if(vErrors === null){vErrors = [err15];}else {vErrors.push(err15);}errors++;}}if(data.phase !== undefined){let data12 = data.phase;if(!((typeof data12 == "number") && (isFinite(data12)))){const err16 = {instancePath:instancePath+"/phase",schemaPath:"#/properties/phase/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema14.properties.phase.type,parentSchema:schema14.properties.phase,data:data12};if(vErrors === null){vErrors = [err16];}else {vErrors.push(err16);}errors++;}}if(data.fileOverrides !== undefined){let data13 = data.fileOverrides;if(Array.isArray(data13)){const len0 = data13.length;for(let i0=0; i0<len0; i0++){let data14 = data13[i0];if(typeof data14 !== "string"){const err17 = {instancePath:instancePath+"/fileOverrides/" + i0,schemaPath:"#/properties/fileOverrides/items/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema14.properties.fileOverrides.items.type,parentSchema:schema14.properties.fileOverrides.items,data:data14};if(vErrors === null){vErrors = [err17];}else {vErrors.push(err17);}errors++;}}}else {const err18 = {instancePath:instancePath+"/fileOverrides",schemaPath:"#/properties/fileOverrides/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema14.properties.fileOverrides.type,parentSchema:schema14.properties.fileOverrides,data:data13};if(vErrors === null){vErrors = [err18];}else {vErrors.push(err18);}errors++;}}}else {const err19 = {instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema14.type,parentSchema:schema14,data};if(vErrors === null){vErrors = [err19];}else {vErrors.push(err19);}errors++;}validate12.errors = vErrors;return errors === 0;}const schema19 = {"type":"object","properties":{"source":{"$ref":"#/definitions/IModReference"},"type":{"$ref":"#/definitions/RuleType"},"reference":{"$ref":"#/definitions/IModReference"}},"required":["source","type","reference"]};const schema20 = {"type":"object","properties":{"fileMD5":{"type":"string"},"fileSize":{"type":"number"},"gameId":{"type":"string"},"versionMatch":{"type":"string"},"logicalFileName":{"type":"string"},"fileExpression":{"type":"string"},"id":{"type":"string"},"idHint":{"type":"string"},"md5Hint":{"type":"string"},"tag":{"type":"string"},"archiveId":{"type":"string"},"repo":{"type":"object","properties":{"gameId":{"type":"string"},"modId":{"type":"string"},"fileId":{"type":"string"},"repository":{"type":"string"},"campaign":{"type":"string"}},"required":["fileId","repository"]},"description":{"type":"string"},"instructions":{"type":"string"}}};const schema21 = {"type":"string","enum":["before","after","requires","conflicts","recommends","provides"]};function validate16(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(data && typeof data == "object" && !Array.isArray(data)){if(data.source === undefined){const err0 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "source"},message:"must have required property '"+"source"+"'",schema:schema19.required,parentSchema:schema19,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}if(data.type === undefined){const err1 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "type"},message:"must have required property '"+"type"+"'",schema:schema19.required,parentSchema:schema19,data};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}if(data.reference === undefined){const err2 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "reference"},message:"must have required property '"+"reference"+"'",schema:schema19.required,parentSchema:schema19,data};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}if(data.source !== undefined){let data0 = data.source;if(data0 && typeof data0 == "object" && !Array.isArray(data0)){if(data0.fileMD5 !== undefined){let data1 = data0.fileMD5;if(typeof data1 !== "string"){const err3 = {instancePath:instancePath+"/source/fileMD5",schemaPath:"#/definitions/IModReference/properties/fileMD5/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.fileMD5.type,parentSchema:schema20.properties.fileMD5,data:data1};if(vErrors === null){vErrors = [err3];}else {vErrors.push(err3);}errors++;}}if(data0.fileSize !== undefined){let data2 = data0.fileSize;if(!((typeof data2 == "number") && (isFinite(data2)))){const err4 = {instancePath:instancePath+"/source/fileSize",schemaPath:"#/definitions/IModReference/properties/fileSize/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema20.properties.fileSize.type,parentSchema:schema20.properties.fileSize,data:data2};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}}if(data0.gameId !== undefined){let data3 = data0.gameId;if(typeof data3 !== "string"){const err5 = {instancePath:instancePath+"/source/gameId",schemaPath:"#/definitions/IModReference/properties/gameId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.gameId.type,parentSchema:schema20.properties.gameId,data:data3};if(vErrors === null){vErrors = [err5];}else {vErrors.push(err5);}errors++;}}if(data0.versionMatch !== undefined){let data4 = data0.versionMatch;if(typeof data4 !== "string"){const err6 = {instancePath:instancePath+"/source/versionMatch",schemaPath:"#/definitions/IModReference/properties/versionMatch/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.versionMatch.type,parentSchema:schema20.properties.versionMatch,data:data4};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}}if(data0.logicalFileName !== undefined){let data5 = data0.logicalFileName;if(typeof data5 !== "string"){const err7 = {instancePath:instancePath+"/source/logicalFileName",schemaPath:"#/definitions/IModReference/properties/logicalFileName/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.logicalFileName.type,parentSchema:schema20.properties.logicalFileName,data:data5};if(vErrors === null){vErrors = [err7];}else {vErrors.push(err7);}errors++;}}if(data0.fileExpression !== undefined){let data6 = data0.fileExpression;if(typeof data6 !== "string"){const err8 = {instancePath:instancePath+"/source/fileExpression",schemaPath:"#/definitions/IModReference/properties/fileExpression/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.fileExpression.type,parentSchema:schema20.properties.fileExpression,data:data6};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}}if(data0.id !== undefined){let data7 = data0.id;if(typeof data7 !== "string"){const err9 = {instancePath:instancePath+"/source/id",schemaPath:"#/definitions/IModReference/properties/id/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.id.type,parentSchema:schema20.properties.id,data:data7};if(vErrors === null){vErrors = [err9];}else {vErrors.push(err9);}errors++;}}if(data0.idHint !== undefined){let data8 = data0.idHint;if(typeof data8 !== "string"){const err10 = {instancePath:instancePath+"/source/idHint",schemaPath:"#/definitions/IModReference/properties/idHint/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.idHint.type,parentSchema:schema20.properties.idHint,data:data8};if(vErrors === null){vErrors = [err10];}else {vErrors.push(err10);}errors++;}}if(data0.md5Hint !== undefined){let data9 = data0.md5Hint;if(typeof data9 !== "string"){const err11 = {instancePath:instancePath+"/source/md5Hint",schemaPath:"#/definitions/IModReference/properties/md5Hint/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.md5Hint.type,parentSchema:schema20.properties.md5Hint,data:data9};if(vErrors === null){vErrors = [err11];}else {vErrors.push(err11);}errors++;}}if(data0.tag !== undefined){let data10 = data0.tag;if(typeof data10 !== "string"){const err12 = {instancePath:instancePath+"/source/tag",schemaPath:"#/definitions/IModReference/properties/tag/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.tag.type,parentSchema:schema20.properties.tag,data:data10};if(vErrors === null){vErrors = [err12];}else {vErrors.push(err12);}errors++;}}if(data0.archiveId !== undefined){let data11 = data0.archiveId;if(typeof data11 !== "string"){const err13 = {instancePath:instancePath+"/source/archiveId",schemaPath:"#/definitions/IModReference/properties/archiveId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.archiveId.type,parentSchema:schema20.properties.archiveId,data:data11};if(vErrors === null){vErrors = [err13];}else {vErrors.push(err13);}errors++;}}if(data0.repo !== undefined){let data12 = data0.repo;if(data12 && typeof data12 == "object" && !Array.isArray(data12)){if(data12.fileId === undefined){const err14 = {instancePath:instancePath+"/source/repo",schemaPath:"#/definitions/IModReference/properties/repo/required",keyword:"required",params:{missingProperty: "fileId"},message:"must have required property '"+"fileId"+"'",schema:schema20.properties.repo.required,parentSchema:schema20.properties.repo,data:data12};if(vErrors === null){vErrors = [err14];}else {vErrors.push(err14);}errors++;}if(data12.repository === undefined){const err15 = {instancePath:instancePath+"/source/repo",schemaPath:"#/definitions/IModReference/properties/repo/required",keyword:"required",params:{missingProperty: "repository"},message:"must have required property '"+"repository"+"'",schema:schema20.properties.repo.required,parentSchema:schema20.properties.repo,data:data12};if(vErrors === null){vErrors = [err15];}else {vErrors.push(err15);}errors++;}if(data12.gameId !== undefined){let data13 = data12.gameId;if(typeof data13 !== "string"){const err16 = {instancePath:instancePath+"/source/repo/gameId",schemaPath:"#/definitions/IModReference/properties/repo/properties/gameId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.gameId.type,parentSchema:schema20.properties.repo.properties.gameId,data:data13};if(vErrors === null){vErrors = [err16];}else {vErrors.push(err16);}errors++;}}if(data12.modId !== undefined){let data14 = data12.modId;if(typeof data14 !== "string"){const err17 = {instancePath:instancePath+"/source/repo/modId",schemaPath:"#/definitions/IModReference/properties/repo/properties/modId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.modId.type,parentSchema:schema20.properties.repo.properties.modId,data:data14};if(vErrors === null){vErrors = [err17];}else {vErrors.push(err17);}errors++;}}if(data12.fileId !== undefined){let data15 = data12.fileId;if(typeof data15 !== "string"){const err18 = {instancePath:instancePath+"/source/repo/fileId",schemaPath:"#/definitions/IModReference/properties/repo/properties/fileId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.fileId.type,parentSchema:schema20.properties.repo.properties.fileId,data:data15};if(vErrors === null){vErrors = [err18];}else {vErrors.push(err18);}errors++;}}if(data12.repository !== undefined){let data16 = data12.repository;if(typeof data16 !== "string"){const err19 = {instancePath:instancePath+"/source/repo/repository",schemaPath:"#/definitions/IModReference/properties/repo/properties/repository/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.repository.type,parentSchema:schema20.properties.repo.properties.repository,data:data16};if(vErrors === null){vErrors = [err19];}else {vErrors.push(err19);}errors++;}}if(data12.campaign !== undefined){let data17 = data12.campaign;if(typeof data17 !== "string"){const err20 = {instancePath:instancePath+"/source/repo/campaign",schemaPath:"#/definitions/IModReference/properties/repo/properties/campaign/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.campaign.type,parentSchema:schema20.properties.repo.properties.campaign,data:data17};if(vErrors === null){vErrors = [err20];}else {vErrors.push(err20);}errors++;}}}else {const err21 = {instancePath:instancePath+"/source/repo",schemaPath:"#/definitions/IModReference/properties/repo/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema20.properties.repo.type,parentSchema:schema20.properties.repo,data:data12};if(vErrors === null){vErrors = [err21];}else {vErrors.push(err21);}errors++;}}if(data0.description !== undefined){let data18 = data0.description;if(typeof data18 !== "string"){const err22 = {instancePath:instancePath+"/source/description",schemaPath:"#/definitions/IModReference/properties/description/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.description.type,parentSchema:schema20.properties.description,data:data18};if(vErrors === null){vErrors = [err22];}else {vErrors.push(err22);}errors++;}}if(data0.instructions !== undefined){let data19 = data0.instructions;if(typeof data19 !== "string"){const err23 = {instancePath:instancePath+"/source/instructions",schemaPath:"#/definitions/IModReference/properties/instructions/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.instructions.type,parentSchema:schema20.properties.instructions,data:data19};if(vErrors === null){vErrors = [err23];}else {vErrors.push(err23);}errors++;}}}else {const err24 = {instancePath:instancePath+"/source",schemaPath:"#/definitions/IModReference/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema20.type,parentSchema:schema20,data:data0};if(vErrors === null){vErrors = [err24];}else {vErrors.push(err24);}errors++;}}if(data.type !== undefined){let data20 = data.type;if(typeof data20 !== "string"){const err25 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/RuleType/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema21.type,parentSchema:schema21,data:data20};if(vErrors === null){vErrors = [err25];}else {vErrors.push(err25);}errors++;}if(!((((((data20 === "before") || (data20 === "after")) || (data20 === "requires")) || (data20 === "conflicts")) || (data20 === "recommends")) || (data20 === "provides"))){const err26 = {instancePath:instancePath+"/type",schemaPath:"#/definitions/RuleType/enum",keyword:"enum",params:{allowedValues: schema21.enum},message:"must be equal to one of the allowed values",schema:schema21.enum,parentSchema:schema21,data:data20};if(vErrors === null){vErrors = [err26];}else {vErrors.push(err26);}errors++;}}if(data.reference !== undefined){let data21 = data.reference;if(data21 && typeof data21 == "object" && !Array.isArray(data21)){if(data21.fileMD5 !== undefined){let data22 = data21.fileMD5;if(typeof data22 !== "string"){const err27 = {instancePath:instancePath+"/reference/fileMD5",schemaPath:"#/definitions/IModReference/properties/fileMD5/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.fileMD5.type,parentSchema:schema20.properties.fileMD5,data:data22};if(vErrors === null){vErrors = [err27];}else {vErrors.push(err27);}errors++;}}if(data21.fileSize !== undefined){let data23 = data21.fileSize;if(!((typeof data23 == "number") && (isFinite(data23)))){const err28 = {instancePath:instancePath+"/reference/fileSize",schemaPath:"#/definitions/IModReference/properties/fileSize/type",keyword:"type",params:{type: "number"},message:"must be number",schema:schema20.properties.fileSize.type,parentSchema:schema20.properties.fileSize,data:data23};if(vErrors === null){vErrors = [err28];}else {vErrors.push(err28);}errors++;}}if(data21.gameId !== undefined){let data24 = data21.gameId;if(typeof data24 !== "string"){const err29 = {instancePath:instancePath+"/reference/gameId",schemaPath:"#/definitions/IModReference/properties/gameId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.gameId.type,parentSchema:schema20.properties.gameId,data:data24};if(vErrors === null){vErrors = [err29];}else {vErrors.push(err29);}errors++;}}if(data21.versionMatch !== undefined){let data25 = data21.versionMatch;if(typeof data25 !== "string"){const err30 = {instancePath:instancePath+"/reference/versionMatch",schemaPath:"#/definitions/IModReference/properties/versionMatch/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.versionMatch.type,parentSchema:schema20.properties.versionMatch,data:data25};if(vErrors === null){vErrors = [err30];}else {vErrors.push(err30);}errors++;}}if(data21.logicalFileName !== undefined){let data26 = data21.logicalFileName;if(typeof data26 !== "string"){const err31 = {instancePath:instancePath+"/reference/logicalFileName",schemaPath:"#/definitions/IModReference/properties/logicalFileName/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.logicalFileName.type,parentSchema:schema20.properties.logicalFileName,data:data26};if(vErrors === null){vErrors = [err31];}else {vErrors.push(err31);}errors++;}}if(data21.fileExpression !== undefined){let data27 = data21.fileExpression;if(typeof data27 !== "string"){const err32 = {instancePath:instancePath+"/reference/fileExpression",schemaPath:"#/definitions/IModReference/properties/fileExpression/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.fileExpression.type,parentSchema:schema20.properties.fileExpression,data:data27};if(vErrors === null){vErrors = [err32];}else {vErrors.push(err32);}errors++;}}if(data21.id !== undefined){let data28 = data21.id;if(typeof data28 !== "string"){const err33 = {instancePath:instancePath+"/reference/id",schemaPath:"#/definitions/IModReference/properties/id/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.id.type,parentSchema:schema20.properties.id,data:data28};if(vErrors === null){vErrors = [err33];}else {vErrors.push(err33);}errors++;}}if(data21.idHint !== undefined){let data29 = data21.idHint;if(typeof data29 !== "string"){const err34 = {instancePath:instancePath+"/reference/idHint",schemaPath:"#/definitions/IModReference/properties/idHint/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.idHint.type,parentSchema:schema20.properties.idHint,data:data29};if(vErrors === null){vErrors = [err34];}else {vErrors.push(err34);}errors++;}}if(data21.md5Hint !== undefined){let data30 = data21.md5Hint;if(typeof data30 !== "string"){const err35 = {instancePath:instancePath+"/reference/md5Hint",schemaPath:"#/definitions/IModReference/properties/md5Hint/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.md5Hint.type,parentSchema:schema20.properties.md5Hint,data:data30};if(vErrors === null){vErrors = [err35];}else {vErrors.push(err35);}errors++;}}if(data21.tag !== undefined){let data31 = data21.tag;if(typeof data31 !== "string"){const err36 = {instancePath:instancePath+"/reference/tag",schemaPath:"#/definitions/IModReference/properties/tag/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.tag.type,parentSchema:schema20.properties.tag,data:data31};if(vErrors === null){vErrors = [err36];}else {vErrors.push(err36);}errors++;}}if(data21.archiveId !== undefined){let data32 = data21.archiveId;if(typeof data32 !== "string"){const err37 = {instancePath:instancePath+"/reference/archiveId",schemaPath:"#/definitions/IModReference/properties/archiveId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.archiveId.type,parentSchema:schema20.properties.archiveId,data:data32};if(vErrors === null){vErrors = [err37];}else {vErrors.push(err37);}errors++;}}if(data21.repo !== undefined){let data33 = data21.repo;if(data33 && typeof data33 == "object" && !Array.isArray(data33)){if(data33.fileId === undefined){const err38 = {instancePath:instancePath+"/reference/repo",schemaPath:"#/definitions/IModReference/properties/repo/required",keyword:"required",params:{missingProperty: "fileId"},message:"must have required property '"+"fileId"+"'",schema:schema20.properties.repo.required,parentSchema:schema20.properties.repo,data:data33};if(vErrors === null){vErrors = [err38];}else {vErrors.push(err38);}errors++;}if(data33.repository === undefined){const err39 = {instancePath:instancePath+"/reference/repo",schemaPath:"#/definitions/IModReference/properties/repo/required",keyword:"required",params:{missingProperty: "repository"},message:"must have required property '"+"repository"+"'",schema:schema20.properties.repo.required,parentSchema:schema20.properties.repo,data:data33};if(vErrors === null){vErrors = [err39];}else {vErrors.push(err39);}errors++;}if(data33.gameId !== undefined){let data34 = data33.gameId;if(typeof data34 !== "string"){const err40 = {instancePath:instancePath+"/reference/repo/gameId",schemaPath:"#/definitions/IModReference/properties/repo/properties/gameId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.gameId.type,parentSchema:schema20.properties.repo.properties.gameId,data:data34};if(vErrors === null){vErrors = [err40];}else {vErrors.push(err40);}errors++;}}if(data33.modId !== undefined){let data35 = data33.modId;if(typeof data35 !== "string"){const err41 = {instancePath:instancePath+"/reference/repo/modId",schemaPath:"#/definitions/IModReference/properties/repo/properties/modId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.modId.type,parentSchema:schema20.properties.repo.properties.modId,data:data35};if(vErrors === null){vErrors = [err41];}else {vErrors.push(err41);}errors++;}}if(data33.fileId !== undefined){let data36 = data33.fileId;if(typeof data36 !== "string"){const err42 = {instancePath:instancePath+"/reference/repo/fileId",schemaPath:"#/definitions/IModReference/properties/repo/properties/fileId/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.fileId.type,parentSchema:schema20.properties.repo.properties.fileId,data:data36};if(vErrors === null){vErrors = [err42];}else {vErrors.push(err42);}errors++;}}if(data33.repository !== undefined){let data37 = data33.repository;if(typeof data37 !== "string"){const err43 = {instancePath:instancePath+"/reference/repo/repository",schemaPath:"#/definitions/IModReference/properties/repo/properties/repository/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.repository.type,parentSchema:schema20.properties.repo.properties.repository,data:data37};if(vErrors === null){vErrors = [err43];}else {vErrors.push(err43);}errors++;}}if(data33.campaign !== undefined){let data38 = data33.campaign;if(typeof data38 !== "string"){const err44 = {instancePath:instancePath+"/reference/repo/campaign",schemaPath:"#/definitions/IModReference/properties/repo/properties/campaign/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.repo.properties.campaign.type,parentSchema:schema20.properties.repo.properties.campaign,data:data38};if(vErrors === null){vErrors = [err44];}else {vErrors.push(err44);}errors++;}}}else {const err45 = {instancePath:instancePath+"/reference/repo",schemaPath:"#/definitions/IModReference/properties/repo/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema20.properties.repo.type,parentSchema:schema20.properties.repo,data:data33};if(vErrors === null){vErrors = [err45];}else {vErrors.push(err45);}errors++;}}if(data21.description !== undefined){let data39 = data21.description;if(typeof data39 !== "string"){const err46 = {instancePath:instancePath+"/reference/description",schemaPath:"#/definitions/IModReference/properties/description/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.description.type,parentSchema:schema20.properties.description,data:data39};if(vErrors === null){vErrors = [err46];}else {vErrors.push(err46);}errors++;}}if(data21.instructions !== undefined){let data40 = data21.instructions;if(typeof data40 !== "string"){const err47 = {instancePath:instancePath+"/reference/instructions",schemaPath:"#/definitions/IModReference/properties/instructions/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema20.properties.instructions.type,parentSchema:schema20.properties.instructions,data:data40};if(vErrors === null){vErrors = [err47];}else {vErrors.push(err47);}errors++;}}}else {const err48 = {instancePath:instancePath+"/reference",schemaPath:"#/definitions/IModReference/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema20.type,parentSchema:schema20,data:data21};if(vErrors === null){vErrors = [err48];}else {vErrors.push(err48);}errors++;}}}else {const err49 = {instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema19.type,parentSchema:schema19,data};if(vErrors === null){vErrors = [err49];}else {vErrors.push(err49);}errors++;}validate16.errors = vErrors;return errors === 0;}function validate11(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(data && typeof data == "object" && !Array.isArray(data)){if(data.info === undefined){const err0 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "info"},message:"must have required property '"+"info"+"'",schema:schema12.required,parentSchema:schema12,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}if(data.mods === undefined){const err1 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "mods"},message:"must have required property '"+"mods"+"'",schema:schema12.required,parentSchema:schema12,data};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}if(data.modRules === undefined){const err2 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "modRules"},message:"must have required property '"+"modRules"+"'",schema:schema12.required,parentSchema:schema12,data};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}if(data.plugins !== undefined){let data0 = data.plugins;if(Array.isArray(data0)){const len0 = data0.length;for(let i0=0; i0<len0; i0++){let data1 = data0[i0];if(data1 && typeof data1 == "object" && !Array.isArray(data1)){if(data1.name === undefined){const err3 = {instancePath:instancePath+"/plugins/" + i0,schemaPath:"#/properties/plugins/items/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema12.properties.plugins.items.required,parentSchema:schema12.properties.plugins.items,data:data1};if(vErrors === null){vErrors = [err3];}else {vErrors.push(err3);}errors++;}if(data1.name !== undefined){let data2 = data1.name;if(typeof data2 !== "string"){const err4 = {instancePath:instancePath+"/plugins/" + i0+"/name",schemaPath:"#/properties/plugins/items/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.plugins.items.properties.name.type,parentSchema:schema12.properties.plugins.items.properties.name,data:data2};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}}if(data1.enabled !== undefined){let data3 = data1.enabled;if(typeof data3 !== "boolean"){const err5 = {instancePath:instancePath+"/plugins/" + i0+"/enabled",schemaPath:"#/properties/plugins/items/properties/enabled/type",keyword:"type",params:{type: "boolean"},message:"must be boolean",schema:schema12.properties.plugins.items.properties.enabled.type,parentSchema:schema12.properties.plugins.items.properties.enabled,data:data3};if(vErrors === null){vErrors = [err5];}else {vErrors.push(err5);}errors++;}}}else {const err6 = {instancePath:instancePath+"/plugins/" + i0,schemaPath:"#/properties/plugins/items/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.properties.plugins.items.type,parentSchema:schema12.properties.plugins.items,data:data1};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}}}else {const err7 = {instancePath:instancePath+"/plugins",schemaPath:"#/properties/plugins/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.plugins.type,parentSchema:schema12.properties.plugins,data:data0};if(vErrors === null){vErrors = [err7];}else {vErrors.push(err7);}errors++;}}if(data.pluginRules !== undefined){let data4 = data.pluginRules;if(data4 && typeof data4 == "object" && !Array.isArray(data4)){if(data4.plugins === undefined){const err8 = {instancePath:instancePath+"/pluginRules",schemaPath:"#/properties/pluginRules/required",keyword:"required",params:{missingProperty: "plugins"},message:"must have required property '"+"plugins"+"'",schema:schema12.properties.pluginRules.required,parentSchema:schema12.properties.pluginRules,data:data4};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}if(data4.plugins !== undefined){let data5 = data4.plugins;if(Array.isArray(data5)){const len1 = data5.length;for(let i1=0; i1<len1; i1++){let data6 = data5[i1];if(data6 && typeof data6 == "object" && !Array.isArray(data6)){if(data6.name === undefined){const err9 = {instancePath:instancePath+"/pluginRules/plugins/" + i1,schemaPath:"#/properties/pluginRules/properties/plugins/items/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema12.properties.pluginRules.properties.plugins.items.required,parentSchema:schema12.properties.pluginRules.properties.plugins.items,data:data6};if(vErrors === null){vErrors = [err9];}else {vErrors.push(err9);}errors++;}if(data6.name !== undefined){let data7 = data6.name;if(typeof data7 !== "string"){const err10 = {instancePath:instancePath+"/pluginRules/plugins/" + i1+"/name",schemaPath:"#/properties/pluginRules/properties/plugins/items/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.plugins.items.properties.name.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items.properties.name,data:data7};if(vErrors === null){vErrors = [err10];}else {vErrors.push(err10);}errors++;}}if(data6.group !== undefined){let data8 = data6.group;if(typeof data8 !== "string"){const err11 = {instancePath:instancePath+"/pluginRules/plugins/" + i1+"/group",schemaPath:"#/properties/pluginRules/properties/plugins/items/properties/group/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.plugins.items.properties.group.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items.properties.group,data:data8};if(vErrors === null){vErrors = [err11];}else {vErrors.push(err11);}errors++;}}if(data6.after !== undefined){let data9 = data6.after;if(Array.isArray(data9)){const len2 = data9.length;for(let i2=0; i2<len2; i2++){let data10 = data9[i2];if(typeof data10 !== "string"){const err12 = {instancePath:instancePath+"/pluginRules/plugins/" + i1+"/after/" + i2,schemaPath:"#/properties/pluginRules/properties/plugins/items/properties/after/items/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.plugins.items.properties.after.items.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items.properties.after.items,data:data10};if(vErrors === null){vErrors = [err12];}else {vErrors.push(err12);}errors++;}}}else {const err13 = {instancePath:instancePath+"/pluginRules/plugins/" + i1+"/after",schemaPath:"#/properties/pluginRules/properties/plugins/items/properties/after/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.pluginRules.properties.plugins.items.properties.after.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items.properties.after,data:data9};if(vErrors === null){vErrors = [err13];}else {vErrors.push(err13);}errors++;}}}else {const err14 = {instancePath:instancePath+"/pluginRules/plugins/" + i1,schemaPath:"#/properties/pluginRules/properties/plugins/items/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.properties.pluginRules.properties.plugins.items.type,parentSchema:schema12.properties.pluginRules.properties.plugins.items,data:data6};if(vErrors === null){vErrors = [err14];}else {vErrors.push(err14);}errors++;}}}else {const err15 = {instancePath:instancePath+"/pluginRules/plugins",schemaPath:"#/properties/pluginRules/properties/plugins/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.pluginRules.properties.plugins.type,parentSchema:schema12.properties.pluginRules.properties.plugins,data:data5};if(vErrors === null){vErrors = [err15];}else {vErrors.push(err15);}errors++;}}if(data4.groups !== undefined){let data11 = data4.groups;if(Array.isArray(data11)){const len3 = data11.length;for(let i3=0; i3<len3; i3++){let data12 = data11[i3];if(data12 && typeof data12 == "object" && !Array.isArray(data12)){if(data12.name === undefined){const err16 = {instancePath:instancePath+"/pluginRules/groups/" + i3,schemaPath:"#/properties/pluginRules/properties/groups/items/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema12.properties.pluginRules.properties.groups.items.required,parentSchema:schema12.properties.pluginRules.properties.groups.items,data:data12};if(vErrors === null){vErrors = [err16];}else {vErrors.push(err16);}errors++;}if(data12.name !== undefined){let data13 = data12.name;if(typeof data13 !== "string"){const err17 = {instancePath:instancePath+"/pluginRules/groups/" + i3+"/name",schemaPath:"#/properties/pluginRules/properties/groups/items/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.groups.items.properties.name.type,parentSchema:schema12.properties.pluginRules.properties.groups.items.properties.name,data:data13};if(vErrors === null){vErrors = [err17];}else {vErrors.push(err17);}errors++;}}if(data12.group !== undefined){let data14 = data12.group;if(typeof data14 !== "string"){const err18 = {instancePath:instancePath+"/pluginRules/groups/" + i3+"/group",schemaPath:"#/properties/pluginRules/properties/groups/items/properties/group/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.groups.items.properties.group.type,parentSchema:schema12.properties.pluginRules.properties.groups.items.properties.group,data:data14};if(vErrors === null){vErrors = [err18];}else {vErrors.push(err18);}errors++;}}if(data12.after !== undefined){let data15 = data12.after;if(Array.isArray(data15)){const len4 = data15.length;for(let i4=0; i4<len4; i4++){let data16 = data15[i4];if(typeof data16 !== "string"){const err19 = {instancePath:instancePath+"/pluginRules/groups/" + i3+"/after/" + i4,schemaPath:"#/properties/pluginRules/properties/groups/items/properties/after/items/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema12.properties.pluginRules.properties.groups.items.properties.after.items.type,parentSchema:schema12.properties.pluginRules.properties.groups.items.properties.after.items,data:data16};if(vErrors === null){vErrors = [err19];}else {vErrors.push(err19);}errors++;}}}else {const err20 = {instancePath:instancePath+"/pluginRules/groups/" + i3+"/after",schemaPath:"#/properties/pluginRules/properties/groups/items/properties/after/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.pluginRules.properties.groups.items.properties.after.type,parentSchema:schema12.properties.pluginRules.properties.groups.items.properties.after,data:data15};if(vErrors === null){vErrors = [err20];}else {vErrors.push(err20);}errors++;}}}else {const err21 = {instancePath:instancePath+"/pluginRules/groups/" + i3,schemaPath:"#/properties/pluginRules/properties/groups/items/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.properties.pluginRules.properties.groups.items.type,parentSchema:schema12.properties.pluginRules.properties.groups.items,data:data12};if(vErrors === null){vErrors = [err21];}else {vErrors.push(err21);}errors++;}}}else {const err22 = {instancePath:instancePath+"/pluginRules/groups",schemaPath:"#/properties/pluginRules/properties/groups/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.pluginRules.properties.groups.type,parentSchema:schema12.properties.pluginRules.properties.groups,data:data11};if(vErrors === null){vErrors = [err22];}else {vErrors.push(err22);}errors++;}}}else {const err23 = {instancePath:instancePath+"/pluginRules",schemaPath:"#/properties/pluginRules/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.properties.pluginRules.type,parentSchema:schema12.properties.pluginRules,data:data4};if(vErrors === null){vErrors = [err23];}else {vErrors.push(err23);}errors++;}}if(data.info !== undefined){let data17 = data.info;if(data17 && typeof data17 == "object" && !Array.isArray(data17)){if(data17.author === undefined){const err24 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "author"},message:"must have required property '"+"author"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err24];}else {vErrors.push(err24);}errors++;}if(data17.authorUrl === undefined){const err25 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "authorUrl"},message:"must have required property '"+"authorUrl"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err25];}else {vErrors.push(err25);}errors++;}if(data17.name === undefined){const err26 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "name"},message:"must have required property '"+"name"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err26];}else {vErrors.push(err26);}errors++;}if(data17.description === undefined){const err27 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "description"},message:"must have required property '"+"description"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err27];}else {vErrors.push(err27);}errors++;}if(data17.domainName === undefined){const err28 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/required",keyword:"required",params:{missingProperty: "domainName"},message:"must have required property '"+"domainName"+"'",schema:schema13.required,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err28];}else {vErrors.push(err28);}errors++;}if(data17.author !== undefined){let data18 = data17.author;if(typeof data18 !== "string"){const err29 = {instancePath:instancePath+"/info/author",schemaPath:"#/definitions/ICollectionInfo/properties/author/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.author.type,parentSchema:schema13.properties.author,data:data18};if(vErrors === null){vErrors = [err29];}else {vErrors.push(err29);}errors++;}}if(data17.authorUrl !== undefined){let data19 = data17.authorUrl;if(typeof data19 !== "string"){const err30 = {instancePath:instancePath+"/info/authorUrl",schemaPath:"#/definitions/ICollectionInfo/properties/authorUrl/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.authorUrl.type,parentSchema:schema13.properties.authorUrl,data:data19};if(vErrors === null){vErrors = [err30];}else {vErrors.push(err30);}errors++;}}if(data17.name !== undefined){let data20 = data17.name;if(typeof data20 !== "string"){const err31 = {instancePath:instancePath+"/info/name",schemaPath:"#/definitions/ICollectionInfo/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.name.type,parentSchema:schema13.properties.name,data:data20};if(vErrors === null){vErrors = [err31];}else {vErrors.push(err31);}errors++;}}if(data17.description !== undefined){let data21 = data17.description;if(typeof data21 !== "string"){const err32 = {instancePath:instancePath+"/info/description",schemaPath:"#/definitions/ICollectionInfo/properties/description/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.description.type,parentSchema:schema13.properties.description,data:data21};if(vErrors === null){vErrors = [err32];}else {vErrors.push(err32);}errors++;}}if(data17.domainName !== undefined){let data22 = data17.domainName;if(typeof data22 !== "string"){const err33 = {instancePath:instancePath+"/info/domainName",schemaPath:"#/definitions/ICollectionInfo/properties/domainName/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.domainName.type,parentSchema:schema13.properties.domainName,data:data22};if(vErrors === null){vErrors = [err33];}else {vErrors.push(err33);}errors++;}}if(data17.gameVersions !== undefined){let data23 = data17.gameVersions;if(Array.isArray(data23)){const len5 = data23.length;for(let i5=0; i5<len5; i5++){let data24 = data23[i5];if(typeof data24 !== "string"){const err34 = {instancePath:instancePath+"/info/gameVersions/" + i5,schemaPath:"#/definitions/ICollectionInfo/properties/gameVersions/items/type",keyword:"type",params:{type: "string"},message:"must be string",schema:schema13.properties.gameVersions.items.type,parentSchema:schema13.properties.gameVersions.items,data:data24};if(vErrors === null){vErrors = [err34];}else {vErrors.push(err34);}errors++;}}}else {const err35 = {instancePath:instancePath+"/info/gameVersions",schemaPath:"#/definitions/ICollectionInfo/properties/gameVersions/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema13.properties.gameVersions.type,parentSchema:schema13.properties.gameVersions,data:data23};if(vErrors === null){vErrors = [err35];}else {vErrors.push(err35);}errors++;}}}else {const err36 = {instancePath:instancePath+"/info",schemaPath:"#/definitions/ICollectionInfo/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema13.type,parentSchema:schema13,data:data17};if(vErrors === null){vErrors = [err36];}else {vErrors.push(err36);}errors++;}}if(data.mods !== undefined){let data25 = data.mods;if(Array.isArray(data25)){const len6 = data25.length;for(let i6=0; i6<len6; i6++){if(!(validate12(data25[i6], {instancePath:instancePath+"/mods/" + i6,parentData:data25,parentDataProperty:i6,rootData}))){vErrors = vErrors === null ? validate12.errors : vErrors.concat(validate12.errors);errors = vErrors.length;}}}else {const err37 = {instancePath:instancePath+"/mods",schemaPath:"#/properties/mods/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.mods.type,parentSchema:schema12.properties.mods,data:data25};if(vErrors === null){vErrors = [err37];}else {vErrors.push(err37);}errors++;}}if(data.modRules !== undefined){let data27 = data.modRules;if(Array.isArray(data27)){const len7 = data27.length;for(let i7=0; i7<len7; i7++){if(!(validate16(data27[i7], {instancePath:instancePath+"/modRules/" + i7,parentData:data27,parentDataProperty:i7,rootData}))){vErrors = vErrors === null ? validate16.errors : vErrors.concat(validate16.errors);errors = vErrors.length;}}}else {const err38 = {instancePath:instancePath+"/modRules",schemaPath:"#/properties/modRules/type",keyword:"type",params:{type: "array"},message:"must be array",schema:schema12.properties.modRules.type,parentSchema:schema12.properties.modRules,data:data27};if(vErrors === null){vErrors = [err38];}else {vErrors.push(err38);}errors++;}}}else {const err39 = {instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object",schema:schema12.type,parentSchema:schema12,data};if(vErrors === null){vErrors = [err39];}else {vErrors.push(err39);}errors++;}validate11.errors = vErrors;return errors === 0;}function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;const _errs0 = errors;let valid0 = false;const _errs1 = errors;if(!(validate11(data, {instancePath,parentData,parentDataProperty,rootData}))){vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);errors = vErrors.length;}var _valid0 = _errs1 === errors;valid0 = valid0 || _valid0;if(!valid0){const err0 = {instancePath,schemaPath:"#/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf",schema:schema11.anyOf,parentSchema:schema11,data};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}else {errors = _errs0;if(vErrors !== null){if(_errs0){vErrors.length = _errs0;}else {vErrors = null;}}}validate10.errors = vErrors;return errors === 0;}


/***/ }),

/***/ "./src/validationCode/dummy.js":
/*!*************************************!*\
  !*** ./src/validationCode/dummy.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

function dummyFunc() {
    console.error('Standalone validation code relies on AJV module; validation may fail');
    return;
}
exports["default"] = dummyFunc;

/***/ }),

/***/ "./src/validationCode/validation.ts":
/*!******************************************!*\
  !*** ./src/validationCode/validation.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateICollection = void 0;
const ICollection_validate_1 = __webpack_require__(/*! ./ICollection.validate */ "./src/validationCode/ICollection.validate.js");
function validateICollection(data) {
    var res = (0, ICollection_validate_1.default)(data);
    return (res === false) ? ICollection_validate_1.default.prototype.constructor.errors : [];
}
exports.validateICollection = validateICollection;


/***/ }),

/***/ "./src/views/AddModsDialog.tsx":
/*!*************************************!*\
  !*** ./src/views/AddModsDialog.tsx ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const react_1 = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const session_1 = __webpack_require__(/*! ../actions/session */ "./src/actions/session.ts");
const collectionCreate_1 = __webpack_require__(/*! ../collectionCreate */ "./src/collectionCreate.ts");
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
function makeColumns(onSelect) {
    let collator;
    return [
        {
            id: 'name',
            name: 'Mod Name',
            description: 'Mod Name',
            calc: (mod) => vortex_api_1.util.renderModName(mod.mod),
            placement: 'table',
            edit: {},
            isDefaultSort: true,
            isSortable: true,
            filter: new vortex_api_1.TableTextFilter(true),
            sortFunc: (lhs, rhs, locale) => {
                if (collator === undefined) {
                    collator = new Intl.Collator(locale, { sensitivity: 'base' });
                }
                return collator.compare(lhs, rhs);
            },
        }, {
            id: 'variant',
            name: 'Variant',
            description: 'The variant',
            calc: (mod) => { var _a, _b; return (_b = (_a = mod.mod.attributes) === null || _a === void 0 ? void 0 : _a.variant) !== null && _b !== void 0 ? _b : ''; },
            placement: 'table',
            edit: {},
        }, {
            id: 'version',
            name: 'Version',
            description: 'The version',
            calc: (mod) => { var _a, _b; return (_b = (_a = mod.mod.attributes) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : ''; },
            placement: 'table',
            edit: {},
        },
    ];
}
function AddModsDialog(props) {
    var _a;
    const { onAddSelection } = props;
    const { t } = (0, react_i18next_1.useTranslation)(constants_1.NAMESPACE);
    const store = (0, react_redux_1.useStore)();
    const dispatch = (0, react_redux_1.useDispatch)();
    const hide = React.useCallback(() => {
        dispatch((0, session_1.startAddModsToCollection)(undefined));
    }, []);
    const [selection, setSelection] = (0, react_1.useState)(new Set());
    const state = store.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const collectionId = (0, react_redux_1.useSelector)(stateSel => stateSel.session.collections.addModsId);
    const collection = collectionId !== undefined
        ? (_a = state.persistent.mods[gameId]) === null || _a === void 0 ? void 0 : _a[collectionId]
        : undefined;
    const mods = state.persistent.mods[gameId];
    const modsWithState = React.useMemo(() => Object.keys(mods !== null && mods !== void 0 ? mods : {})
        .reduce((prev, modId) => {
        if (!(0, collectionCreate_1.alreadyIncluded)(collection === null || collection === void 0 ? void 0 : collection.rules, modId)
            && (mods[modId].type !== constants_1.MOD_TYPE)) {
            prev[modId] = {
                selected: selection.has(modId),
                mod: mods[modId],
            };
        }
        return prev;
    }, {}), [selection, collectionId]);
    const changeSelection = React.useCallback((modIds, selected) => {
        if (selected) {
            setSelection(new Set([].concat(Array.from(selection), modIds)));
        }
        else {
            setSelection(new Set(Array.from(selection).filter(modId => !modIds.includes(modId))));
        }
    }, [selection, setSelection, collectionId]);
    const columns = React.useMemo(() => makeColumns(changeSelection), [selection, setSelection, collectionId]);
    const addSelection = React.useCallback(() => {
        onAddSelection(collectionId, Array.from(selection));
        hide();
    }, [onAddSelection, hide, selection, collectionId]);
    const updateSelection = React.useCallback((modIds) => {
        setSelection(new Set(modIds));
    }, [setSelection]);
    const TableX = vortex_api_1.Table;
    return (React.createElement(vortex_api_1.Modal, { id: 'add-mods-to-collection-dialog', className: 'collection-add-mods-dialog', show: collection !== undefined, onHide: hide },
        React.createElement(vortex_api_1.Modal.Header, null,
            React.createElement(vortex_api_1.Modal.Title, null, vortex_api_1.util.renderModName(collection))),
        React.createElement(vortex_api_1.Modal.Body, null, (Object.keys(modsWithState).length > 0)
            ? (React.createElement(React.Fragment, null,
                t('Select (click, shift-click, ...) installed mods you want to add to your collection below:'),
                React.createElement(TableX, { tableId: 'collection-add-mods', data: modsWithState, staticElements: columns, actions: [], showDetails: false, hasActions: false, onChangeSelection: updateSelection }))) : (React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'folder-download', fill: true, text: t('You don\'t have any installed mods') }))),
        React.createElement(vortex_api_1.Usage, { persistent: true, infoId: 'add-mods-from-mods-page' },
            React.createElement("p", null, t('You can also add mods to a collection from the mods screen: '
                + 'Right-click > Add to Collection')),
            React.createElement("p", null, t('Mods need to be in an installed state in order to add them to a collection. '
                + 'If the mod you want to add is not in this list, make sure it\'s installed.'))),
        React.createElement(vortex_api_1.Modal.Footer, null,
            React.createElement(react_bootstrap_1.Button, { onClick: hide }, t('Close')),
            React.createElement(react_bootstrap_1.Button, { onClick: addSelection }, t('Add Selection')))));
}
exports["default"] = React.memo(AddModsDialog);


/***/ }),

/***/ "./src/views/CollectionList/StartPage.tsx":
/*!************************************************!*\
  !*** ./src/views/CollectionList/StartPage.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const settings_1 = __webpack_require__(/*! ../../actions/settings */ "./src/actions/settings.ts");
const collectionCreate_1 = __webpack_require__(/*! ../../collectionCreate */ "./src/collectionCreate.ts");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const transformCollection_1 = __webpack_require__(/*! ../../util/transformCollection */ "./src/util/transformCollection.ts");
const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
const RemoteTile_1 = __webpack_require__(/*! ../CollectionTile/RemoteTile */ "./src/views/CollectionTile/RemoteTile.tsx");
const _ = __webpack_require__(/*! lodash */ "lodash");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const react_select_1 = __webpack_require__(/*! react-select */ "react-select");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const FEEDBACK_URL = 'https://docs.google.com/forms/d/e/1FAIpQLSc3csy4ycVBECvHQDgri37Gqq1gOuTQ7LcpiIaOkGHpDsW4kA/viewform?usp=sf_link';
const BUG_REPORT_URL = 'https://docs.google.com/forms/d/e/1FAIpQLSdmDBdGjTQVRa7wRouN4yP6zMvqsxTT86R-DwmQXZq7SWGCSg/viewform?usp=sf_link';
function dateCompare(lhs, rhs) {
    return (new Date(lhs !== null && lhs !== void 0 ? lhs : 0)).getTime() - (new Date(rhs !== null && rhs !== void 0 ? rhs : 0)).getTime();
}
const nop = () => null;
const validRE = /^[\p{L}\p{N} -]*$/u;
function validateCollectionName(t, input) {
    if ((input.length < constants_1.MIN_COLLECTION_NAME_LENGTH) || (input.length > constants_1.MAX_COLLECTION_NAME_LENGTH)) {
        return t('The name bust be between {{min}}-{{max}} characters long', {
            replace: {
                min: constants_1.MIN_COLLECTION_NAME_LENGTH,
                max: constants_1.MAX_COLLECTION_NAME_LENGTH,
            },
        });
    }
    if (input.match(validRE) === null) {
        return t('Invalid characters, only letters, numbers, space and - are allowed.');
    }
    return undefined;
}
function AddCard(props) {
    const { t, onClick } = props;
    const classes = ['collection-add-btn'];
    return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' '), bsStyle: 'default', onClick: onClick },
        React.createElement(react_bootstrap_1.Panel.Body, { className: 'collection-thumbnail-body' },
            React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'folder-add', text: t('Discover more collections') }))));
}
function CreateCard(props) {
    const { t, onTrackClick } = props;
    const classes = ['collection-add-btn'];
    const actions = React.useRef([]);
    React.useEffect(() => {
        actions.current = [
            {
                title: 'From Profile',
                icon: 'profile',
                action: () => {
                    onTrackClick('Collections', 'From profile');
                    props.onCreateFromProfile();
                },
            }, {
                title: 'Empty',
                icon: 'show',
                action: () => {
                    onTrackClick('Collections', 'Empty');
                    props.onCreateEmpty();
                },
            }, {
                title: 'Quick Collection',
                icon: 'highlight-lab',
                action: () => {
                    onTrackClick('Collections', 'Quick Collection');
                    props.onCreateQuickCollection();
                },
            },
        ];
    }, [props.onCreateFromProfile, props.onCreateEmpty, props.onCreateQuickCollection]);
    return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' '), bsStyle: 'default' },
        React.createElement(react_bootstrap_1.Panel.Body, { className: 'collection-thumbnail-body' },
            React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'add', text: t('Create a collection'), fill: true }),
            React.createElement("div", { className: 'hover-menu' },
                React.createElement("div", { key: 'primary-buttons', className: 'hover-content' },
                    React.createElement(vortex_api_1.IconBar, { className: 'buttons', group: 'collection-actions', staticElements: actions.current, collapse: false, buttonType: 'text', orientation: 'vertical', clickAnywhere: true, t: t }))))));
}
class StartPage extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.setSortAdded = (value) => {
            if (!!value) {
                this.props.onSetSortAdded(value.value);
            }
        };
        this.setSortWorkshop = (value) => {
            if (!!value) {
                this.props.onSetSortWorkshop(value.value);
            }
        };
        this.setActiveTab = (tabId) => {
            this.props.onSetActiveTab(tabId);
            this.context.api.events.emit('analytics-track-navigation', `collections/${tabId}`);
        };
        this.openCollections = () => {
            const { game } = this.props;
            this.context.api.events.emit('analytics-track-click-event', 'Collections', 'Discover more');
            vortex_api_1.util.opn(`${constants_1.NEXUS_BASE_GAMES_URL}/${vortex_api_1.util.nexusGameId(game)}/collections`).catch(() => null);
        };
        this.openMyCollectionsPage = () => {
            this.context.api.events.emit('analytics-track-click-event', 'Collections', 'Open My Collections');
            vortex_api_1.util.opn(`${constants_1.NEXUS_BASE_URL}/my-collections`).catch(() => null);
        };
        this.trackEvent = (namespace, eventName) => {
            this.context.api.events.emit('analytics-track-click-event', namespace, eventName);
        };
        this.openFeedback = () => {
            vortex_api_1.util.opn(FEEDBACK_URL).catch(() => null);
        };
        this.openBugReport = () => {
            vortex_api_1.util.opn(BUG_REPORT_URL).catch(() => null);
        };
        this.quickCollection = async () => {
            try {
                await (0, collectionCreate_1.initFromProfile)(this.context.api);
                this.refreshImages();
            }
            catch (err) {
                if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                    this.context.api.showErrorNotification('Failed to create quick collection', err);
                }
            }
        };
        this.fromProfile = async () => {
            const { profile } = this.props;
            try {
                await (0, collectionCreate_1.initFromProfile)(this.context.api, profile.id);
                this.refreshImages();
            }
            catch (err) {
                if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                    this.context.api.showErrorNotification('Failed to init collection', err);
                }
            }
        };
        this.fromEmpty = async () => {
            const { t, onCreateCollection } = this.props;
            try {
                const result = await this.context.api.showDialog('question', 'New empty Collection', {
                    text: 'Create an empty collection which you can manually add mods to.',
                    input: [{ id: 'name', label: 'Collection Name', type: 'text' }],
                    condition: content => (0, transformCollection_1.validateName)(t, content),
                }, [
                    { label: 'Cancel' },
                    { label: 'Create', default: true },
                ]);
                if (result.action === 'Create') {
                    await onCreateCollection(result.input['name']);
                    this.refreshImages();
                }
            }
            catch (err) {
                this.context.api.showErrorNotification('Failed to init collection', err);
            }
        };
        this.initState({
            createOpen: false,
            imageTime: Date.now(),
            mousePosition: { x: 0, y: 0 },
            collectionsEx: { added: [], workshop: [] },
        });
    }
    componentDidMount() {
        const collectionsNow = Object.values(this.props.mods).filter(mod => mod.type === constants_1.MOD_TYPE);
        this.updateSorted(collectionsNow, this.props.sortAdded, this.props.sortWorkshop, false)
            .then(() => this.updateSorted(collectionsNow, this.props.sortAdded, this.props.sortWorkshop, false))
            .catch(err => {
            (0, vortex_api_1.log)('error', 'failed to update list of collections', {
                error: err.message,
            });
        });
    }
    componentDidUpdate(prevProps, prevState) {
        const collectionsPrev = Object.values(prevProps.mods).filter(mod => mod.type === constants_1.MOD_TYPE);
        const collectionsNow = Object.values(this.props.mods).filter(mod => mod.type === constants_1.MOD_TYPE);
        if (!_.isEqual(collectionsPrev, collectionsNow)
            || (prevProps.sortAdded !== this.props.sortAdded)
            || (prevProps.sortWorkshop !== this.props.sortWorkshop)
            || (prevProps.localState.ownCollections !== this.props.localState.ownCollections)) {
            this.updateSorted(collectionsNow, this.props.sortAdded, this.props.sortWorkshop, true);
        }
    }
    render() {
        const { t, activeTab, installing, profile, matchedReferences, mods, onClone, onEdit, onPause, onInstallCollection, onRemove, onResume, onUpdate, onUpload, onView, sortAdded, sortWorkshop } = this.props;
        const { imageTime, collectionsEx } = this.state;
        const { added, workshop } = collectionsEx;
        return (React.createElement(react_bootstrap_1.Tabs, { id: 'collection-start-page', activeKey: activeTab, onSelect: this.setActiveTab },
            React.createElement(react_bootstrap_1.Tab, { tabClassName: 'collection-tab', eventKey: 'active-collections', title: React.createElement(React.Fragment, null,
                    React.createElement(vortex_api_1.Icon, { name: 'add' }),
                    t('Added Collections')) },
                React.createElement(react_bootstrap_1.Panel, null,
                    React.createElement(react_bootstrap_1.Panel.Heading, null,
                        React.createElement(react_bootstrap_1.Panel.Title, null, t('View and manage collections created by other users.')),
                        React.createElement("div", { className: 'flex-fill' }),
                        React.createElement("div", { className: 'collection-sort-container' },
                            t('Sort by:'),
                            React.createElement(react_select_1.default, { className: 'select-compact', options: [
                                    { value: 'alphabetical', label: t('Name A-Z') },
                                    { value: 'datedownloaded', label: t('Date downloaded') },
                                    { value: 'recentlyupdated', label: t('Recently updated') },
                                ], value: sortAdded, onChange: this.setSortAdded, clearable: false, autosize: false, searchable: false }))),
                    React.createElement(react_bootstrap_1.Panel.Body, null,
                        React.createElement("div", { className: 'collection-list' },
                            React.createElement(AddCard, { t: t, onClick: this.openCollections }),
                            added.map(mod => {
                                var _a, _b;
                                return React.createElement(CollectionTile_1.default, { key: mod.mod.id, t: t, gameId: profile.gameId, imageTime: imageTime, installing: installing, mods: mods, incomplete: (_b = (_a = matchedReferences[mod.mod.id]) === null || _a === void 0 ? void 0 : _a.includes) === null || _b === void 0 ? void 0 : _b.call(_a, null), collection: mod.mod, infoCache: this.props.infoCache, onView: onView, onRemove: onRemove, onResume: onResume, onPause: onPause, onUpdate: onUpdate, details: true });
                            }))))),
            React.createElement(react_bootstrap_1.Tab, { tabClassName: 'collection-tab', eventKey: 'collection-workshop', title: React.createElement(React.Fragment, null,
                    React.createElement(vortex_api_1.Icon, { name: 'highlight-tool' }),
                    t('Workshop')) },
                React.createElement(react_bootstrap_1.Panel, null,
                    React.createElement(react_bootstrap_1.Panel.Heading, null,
                        React.createElement(react_bootstrap_1.Panel.Title, null,
                            React.createElement(react_i18next_1.Trans, { ns: constants_1.NAMESPACE, i18nKey: 'collection-own-page' },
                                "Build your own collections and share them with the Nexus Mods community. You can view all your uploaded collections\u00A0",
                                React.createElement("a", { onClick: this.openMyCollectionsPage, className: 'my-collections-page-link', title: t('Open My Collections Page') }, "here."))),
                        React.createElement("div", { className: 'flex-fill' }),
                        React.createElement("div", { className: 'collection-sort-container' },
                            t('Sort by:'),
                            React.createElement(react_select_1.default, { className: 'select-compact', options: [
                                    { value: 'alphabetical', label: t('Name A-Z') },
                                    { value: 'datecreated', label: t('Date created') },
                                    { value: 'recentlyupdated', label: t('Recently updated') },
                                ], value: sortWorkshop, onChange: this.setSortWorkshop, clearable: false, autosize: false, searchable: false }))),
                    React.createElement(react_bootstrap_1.Panel.Body, null,
                        React.createElement("div", { className: 'collection-list' },
                            React.createElement(CreateCard, { t: t, onCreateFromProfile: this.fromProfile, onCreateQuickCollection: this.quickCollection, onCreateEmpty: this.fromEmpty, onTrackClick: this.trackEvent }),
                            workshop.map(mod => {
                                var _a, _b, _c, _d;
                                return (mod.mod !== undefined)
                                    ? (React.createElement(CollectionTile_1.default, { t: t, key: mod.mod.id, gameId: profile.gameId, collection: mod.mod, infoCache: this.props.infoCache, imageTime: imageTime, mods: mods, incomplete: (mod.mod === undefined)
                                            || ((_b = (_a = matchedReferences[mod.mod.id]) === null || _a === void 0 ? void 0 : _a.includes) === null || _b === void 0 ? void 0 : _b.call(_a, null)), onEdit: onEdit, onRemove: onRemove, onUpload: onUpload, details: true })) : (React.createElement(RemoteTile_1.default, { t: t, key: mod.revision.id, revision: mod.revision, added: mod.added, incomplete: (mod.added === undefined)
                                        || ((_d = (_c = matchedReferences[mod.added.id]) === null || _c === void 0 ? void 0 : _c.includes) === null || _d === void 0 ? void 0 : _d.call(_c, null)), onInstallCollection: onInstallCollection, onCloneCollection: onClone, onResumeCollection: onResume }));
                            })))))));
    }
    name(input) {
        var _a, _b, _c;
        return (input.mod !== undefined)
            ? vortex_api_1.util.renderModName(input.mod)
            : ((_c = (_b = (_a = input.revision) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : '');
    }
    sorter(sorting) {
        var _a;
        const alphabetical = (lhs, rhs) => this.name(lhs).localeCompare(this.name(rhs));
        return (_a = {
            alphabetical,
            datedownloaded: (lhs, rhs) => { var _a, _b, _c, _d; return dateCompare((_b = (_a = rhs.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.installTime, (_d = (_c = lhs.mod) === null || _c === void 0 ? void 0 : _c.attributes) === null || _d === void 0 ? void 0 : _d.installTime); },
            datecreated: (lhs, rhs) => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                return dateCompare((_c = (_b = (_a = rhs.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.installTime) !== null && _c !== void 0 ? _c : (_d = rhs.revision) === null || _d === void 0 ? void 0 : _d.createdAt, (_g = (_f = (_e = lhs.mod) === null || _e === void 0 ? void 0 : _e.attributes) === null || _f === void 0 ? void 0 : _f.installTime) !== null && _g !== void 0 ? _g : (_h = lhs.revision) === null || _h === void 0 ? void 0 : _h.createdAt);
            },
            recentlyupdated: (lhs, rhs) => {
                var _a, _b, _c, _d, _e, _f;
                return dateCompare((_b = (_a = rhs.revision) === null || _a === void 0 ? void 0 : _a.updatedAt) !== null && _b !== void 0 ? _b : (_c = rhs.mod.attributes) === null || _c === void 0 ? void 0 : _c.installTime, (_e = (_d = lhs.revision) === null || _d === void 0 ? void 0 : _d.updatedAt) !== null && _e !== void 0 ? _e : (_f = lhs.mod.attributes) === null || _f === void 0 ? void 0 : _f.installTime);
            },
        }[sorting]) !== null && _a !== void 0 ? _a : alphabetical;
    }
    updateSorted(collections, sortAdded, sortWorkshop, allowMetaUpdate) {
        return Promise.all(collections.map(async (mod) => {
            var _a;
            const { revisionId, collectionSlug, revisionNumber } = (_a = mod.attributes) !== null && _a !== void 0 ? _a : {};
            const revision = revisionNumber !== undefined
                ? await this.props.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber, allowMetaUpdate ? 'allow' : 'avoid')
                : undefined;
            return { mod, revision };
        }))
            .then((result) => {
            let { foreign, own } = result.reduce((prev, mod) => {
                if (vortex_api_1.util.getSafe(mod.mod.attributes, ['editable'], false)) {
                    prev.own.push(mod);
                }
                else {
                    prev.foreign.push(mod);
                }
                return prev;
            }, { foreign: [], own: [] });
            const installed = new Set(own.map(res => { var _a; return (_a = res.mod.attributes) === null || _a === void 0 ? void 0 : _a['collectionSlug']; }));
            own.push(...this.props.localState.ownCollections
                .filter(coll => { var _a; return !installed.has((_a = coll.collection) === null || _a === void 0 ? void 0 : _a.slug); })
                .map(coll => {
                var _a;
                return ({
                    mod: undefined,
                    added: (_a = foreign.find(iter => { var _a, _b, _c; return ((_b = (_a = iter.revision) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.slug) === ((_c = coll.collection) === null || _c === void 0 ? void 0 : _c.slug); })) === null || _a === void 0 ? void 0 : _a.mod,
                    revision: coll,
                });
            }));
            foreign = foreign.sort(this.sorter(sortAdded));
            own = own.sort(this.sorter(sortWorkshop));
            this.nextState.collectionsEx = { added: foreign, workshop: own };
        });
    }
    refreshImages() {
        this.nextState.imageTime = Date.now();
    }
}
function mapStateToProps(state) {
    var _a, _b, _c;
    return {
        userInfo: (_a = state.persistent['nexus']) === null || _a === void 0 ? void 0 : _a.userInfo,
        sortAdded: (_b = state.settings.collections.sortAdded) !== null && _b !== void 0 ? _b : 'datedownloaded',
        sortWorkshop: (_c = state.settings.collections.sortWorkshop) !== null && _c !== void 0 ? _c : 'recentlyupdated',
    };
}
function mapDispatchToProps(dispatch) {
    return {
        onSetSortAdded: (sorting) => dispatch((0, settings_1.setSortAdded)(sorting)),
        onSetSortWorkshop: (sorting) => dispatch((0, settings_1.setSortWorkshop)(sorting)),
    };
}
exports["default"] = (0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(StartPage);


/***/ }),

/***/ "./src/views/CollectionList/index.tsx":
/*!********************************************!*\
  !*** ./src/views/CollectionList/index.tsx ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const persistent_1 = __webpack_require__(/*! ../../actions/persistent */ "./src/actions/persistent.ts");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const extension_1 = __webpack_require__(/*! ../../util/extension */ "./src/util/extension.ts");
const CollectionPageEdit_1 = __webpack_require__(/*! ../CollectionPageEdit */ "./src/views/CollectionPageEdit/index.tsx");
const CollectionPageView_1 = __webpack_require__(/*! ../CollectionPageView */ "./src/views/CollectionPageView/index.tsx");
const StartPage_1 = __webpack_require__(/*! ./StartPage */ "./src/views/CollectionList/StartPage.tsx");
const React = __webpack_require__(/*! react */ "react");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
const emptyObj = {};
const emptyArr = [];
class CollectionsMainPage extends vortex_api_1.ComponentEx {
    constructor(props) {
        var _a;
        super(props);
        this.onUpdateMeta = () => {
            this.props.onUpdateMeta();
            this.context.api.events.emit('analytics-track-click-event', 'Collections', 'Refresh');
        };
        this.setActiveTab = (tabId) => {
            this.nextState.activeTab = tabId;
        };
        this.createCollection = (name) => {
            const { profile, onCreateCollection } = this.props;
            onCreateCollection(profile, name);
        };
        this.deselectCollection = () => {
            this.nextState.selectedCollection = undefined;
        };
        this.resetMainPage = () => {
            this.deselectCollection();
        };
        this.view = (modId) => {
            this.showPage('view', modId);
        };
        this.edit = async (modId) => {
            var _a, _b;
            const { mods, userInfo } = this.props;
            const { api } = this.context;
            if (mods[modId] === undefined) {
                return;
            }
            const author = (_a = mods[modId].attributes) === null || _a === void 0 ? void 0 : _a['uploaderId'];
            if ((author !== undefined) && (author !== (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId))) {
                const result = await api.showDialog('question', 'Edit Collection', {
                    text: 'This collection has been uploaded with a different account ({{uploadAuthor}}) '
                        + 'than you\'re using now ({{currentUser}}). '
                        + 'If you edit and upload this collection now it will be uploaded as a new '
                        + 'collection by your current user.',
                    parameters: {
                        uploadAuthor: mods[modId].attributes['uploader'],
                        currentUser: (_b = userInfo === null || userInfo === void 0 ? void 0 : userInfo.name) !== null && _b !== void 0 ? _b : '<Logged out>',
                    },
                }, [
                    { label: 'Cancel' },
                    { label: 'Continue' },
                ]);
                if (result.action === 'Cancel') {
                    return;
                }
            }
            this.showPage('edit', modId);
        };
        this.pause = async (modId, silent) => {
            var _a;
            const { downloads, mods } = this.props;
            const collection = mods[modId];
            if (collection === undefined) {
                return;
            }
            ((_a = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _a !== void 0 ? _a : []).forEach(rule => {
                const dlId = vortex_api_1.util.findDownloadByRef(rule.reference, downloads);
                if (dlId !== undefined) {
                    this.context.api.events.emit('pause-download', dlId);
                }
            });
            const { api } = this.context;
            await api.emitAndAwait('cancel-dependency-install', modId);
            this.props.driver.cancel();
            api.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + modId);
            if (silent !== true) {
                api.sendNotification({
                    id: 'collection-pausing',
                    type: 'success',
                    title: 'Collection pausing',
                    message: 'Already queued mod installations will still finish',
                });
            }
        };
        this.clone = async (collectionId) => {
            const id = await this.props.onCloneCollection(collectionId);
            if (id !== undefined) {
                this.showPage('edit', id);
            }
        };
        this.cancel = async (modId, cancel) => {
            const { profile } = this.props;
            return this.props.onRemoveCollection(profile.gameId, modId, cancel !== null && cancel !== void 0 ? cancel : true);
        };
        this.voteSuccess = async (modId, success) => {
            const { mods } = this.props;
            const { api } = this.context;
            const collection = mods[modId];
            if (collection === undefined) {
                return;
            }
            const { revisionId } = collection.attributes;
            if (revisionId === undefined) {
                return;
            }
            const vote = success ? 'positive' : 'negative';
            const voted = (await api.emitAndAwait('rate-nexus-collection-revision', parseInt(revisionId, 10), vote))[0];
            if (voted.success) {
                api.store.dispatch((0, persistent_1.updateSuccessRate)(revisionId, vote, voted.averageRating.average, voted.averageRating.total));
            }
        };
        this.remove = (modId) => {
            var _a, _b;
            const { mods } = this.props;
            const { api } = this.context;
            if (mods[modId] === undefined) {
                return;
            }
            try {
                if ((_b = (_a = mods[modId]) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.editable) {
                    api.events.emit('analytics-track-click-event', 'Collections', 'Remove Workshop Collection');
                    return this.removeWorkshop(modId)
                        .catch(err => {
                        const allowReport = !['EPERM'].includes(err.code)
                            && !(err instanceof vortex_api_1.util.ProcessCanceled)
                            && !(err instanceof vortex_api_1.util.UserCanceled);
                        api.showErrorNotification('Failed to remove collection', err, { allowReport });
                    });
                }
                else {
                    api.events.emit('analytics-track-click-event', 'Collections', 'Remove Added Collection');
                    return this.cancel(modId, false)
                        .catch(err => {
                        api.showErrorNotification('Failed to remove collection', err, {
                            allowReport: !['EPERM'].includes(err.code),
                        });
                    });
                }
            }
            catch (err) {
                if (err instanceof vortex_api_1.util.UserCanceled) {
                    (0, vortex_api_1.log)('info', 'collection removal canceled by user');
                }
                else if (err instanceof vortex_api_1.util.ProcessCanceled) {
                    api.sendNotification({
                        type: 'warning',
                        title: 'Removal failed',
                        message: err.message,
                    });
                }
                else {
                    api.showErrorNotification('Failed to remove collection', err);
                }
            }
        };
        this.update = async (collectionId) => {
            const { mods } = this.props;
            const { api } = this.context;
            const state = api.getState();
            const gameMode = vortex_api_1.selectors.activeGameId(state);
            const mod = mods[collectionId];
            if (mod === undefined) {
                return;
            }
            const downloadGame = vortex_api_1.util.getSafe(mod.attributes, ['downloadGame'], gameMode);
            const newestFileId = vortex_api_1.util.getSafe(mod.attributes, ['newestVersion'], undefined);
            await vortex_api_1.util.toPromise(cb => {
                var _a, _b;
                return this.context.api.events.emit('collection-update', downloadGame, (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.collectionSlug, newestFileId, (_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.source, collectionId, cb);
            });
        };
        this.upload = async (collectionId) => {
            var _a;
            (0, util_1.uploadCollection)(this.context.api, (_a = this.props.profile) === null || _a === void 0 ? void 0 : _a.id, collectionId);
        };
        this.installManually = (collectionId, rules) => {
            const { api } = this.context;
            const ruleGroups = rules.reduce((prev, rule) => {
                if (prev[rule.type] !== undefined) {
                    prev[rule.type].push(rule);
                }
                else {
                    (0, vortex_api_1.log)('error', 'unexpected rule encountered', { collectionId, ruleType: rule.type });
                }
                return prev;
            }, { requires: [], recommends: [] });
            const eaa = (ruleList, recommended) => {
                if (ruleList.length === 0) {
                    return Promise.resolve();
                }
                else {
                    return api.emitAndAwait('install-from-dependencies', collectionId, ruleList, recommended);
                }
            };
            eaa(ruleGroups.requires, false)
                .then(() => eaa(ruleGroups.recommends, true))
                .catch(err => {
                if (err instanceof vortex_api_1.util.UserCanceled) {
                    return;
                }
                api.showErrorNotification('Failed to install dependencies', err, {
                    allowReport: !(err instanceof vortex_api_1.util.ProcessCanceled),
                });
            });
        };
        this.resume = async (modId) => {
            const { driver, mods, profile, userInfo } = this.props;
            if (mods[modId] === undefined) {
                return;
            }
            if ((userInfo === null) || (userInfo === undefined)) {
                const { api } = this.context;
                api.showDialog('info', 'Not logged in', {
                    text: 'You have to be logged in with Nexus Mods to install collections.',
                }, [{ label: 'Continue' }]);
            }
            else if (mods[modId] !== undefined) {
                driver.start(profile, mods[modId]);
            }
        };
        this.initState({
            selectedCollection: undefined,
            matchedReferences: this.updateMatchedReferences(this.props),
            viewMode: 'view',
            activeTab: 'active-collections',
        });
        if (props.onAddCallback !== undefined) {
            props.onAddCallback('viewCollection', (collectionId) => {
                this.showPage('view', collectionId);
            });
            props.onAddCallback('editCollection', () => (collectionId) => {
                this.showPage('edit', collectionId);
            });
        }
        (_a = props.resetCB) === null || _a === void 0 ? void 0 : _a.call(props, this.resetMainPage);
        this.mMatchRefDebouncer = new vortex_api_1.util.Debouncer(() => {
            this.nextState.matchedReferences = this.updateMatchedReferences(this.props);
            return Promise.resolve();
        }, 2000);
    }
    UNSAFE_componentWillReceiveProps(newProps) {
        if (this.props.mods !== newProps.mods) {
            this.mMatchRefDebouncer.schedule();
        }
    }
    componentWillUnmount() {
        this.mMatchRefDebouncer.clear();
    }
    render() {
        const { t, downloads, driver, game, localState, mods, notifications, profile, pathTool } = this.props;
        const { activeTab, matchedReferences, selectedCollection, viewMode } = this.state;
        if (profile === undefined) {
            return null;
        }
        const collection = (selectedCollection !== undefined)
            ? mods[selectedCollection]
            : undefined;
        let content = null;
        if (collection === undefined) {
            content = (React.createElement(React.Fragment, null,
                React.createElement(vortex_api_1.tooltip.IconButton, { className: 'collections-refresh-meta', icon: 'refresh', tooltip: t('Download the latest meta information about your installed and owned collections. '
                        + 'This will reset local changes to names of collections in your workshop.'), onClick: this.onUpdateMeta }, t('Refresh')),
                React.createElement(StartPage_1.default, { t: t, game: game, localState: localState, installing: driver.installDone ? undefined : driver.collection, infoCache: driver.infoCache, profile: profile, mods: mods, matchedReferences: matchedReferences !== null && matchedReferences !== void 0 ? matchedReferences : emptyObj, activeTab: activeTab, onView: this.view, onEdit: this.edit, onRemove: this.remove, onUpdate: this.update, onUpload: this.upload, onClone: this.clone, onCreateCollection: this.createCollection, onResume: this.resume, onPause: this.pause, onSetActiveTab: this.setActiveTab, onInstallCollection: this.props.onInstallCollection })));
        }
        else {
            content = (React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                    React.createElement(vortex_api_1.tooltip.IconButton, { className: 'collection-back-btn', tooltip: 'Return to overview', icon: 'nav-back', onClick: this.deselectCollection }, t('View All Collections'))),
                React.createElement(vortex_api_1.FlexLayout.Flex, null, (viewMode === 'view') ? (React.createElement(CollectionPageView_1.default, { t: t, className: 'collection-details', driver: this.props.driver, profile: profile, collection: collection, mods: mods, downloads: downloads, notifications: notifications, onAddCallback: this.props.onAddCallback, onView: this.view, onPause: this.pause, onCancel: this.cancel, onClone: this.clone, onResume: this.resume, onInstallManually: this.installManually, onVoteSuccess: this.voteSuccess }))
                    : (React.createElement(CollectionPageEdit_1.default, { profile: profile, collection: collection, mods: mods, driver: this.props.driver, onRemove: this.remove, onUpload: this.upload, exts: this.props.exts, pathTool: pathTool })))));
        }
        return (React.createElement(vortex_api_1.MainPage, { id: 'collection-page' },
            React.createElement(vortex_api_1.MainPage.Body, null, content)));
    }
    showPage(page, modId) {
        this.nextState.selectedCollection = modId;
        this.nextState.viewMode = page;
    }
    async removeWorkshop(modId) {
        const { mods, profile } = this.props;
        const { api } = this.context;
        const result = await api.showDialog('question', 'Remove Collection (Workshop)', {
            text: 'Deleting a collection will not remove the mods that have been added to it.\n\n'
                + 'Any changes made to this collection since the last upload to Nexus Mods will '
                + 'be lost.\n\n'
                + 'Are you sure you want to remove "{{collectionName}}" from your Workshop?',
            parameters: {
                collectionName: vortex_api_1.util.renderModName(mods[modId]),
            },
        }, [
            { label: 'Cancel' },
            { label: 'Remove' },
        ]);
        if (result.action === 'Remove') {
            await vortex_api_1.util.toPromise(cb => api.events.emit('remove-mod', profile.gameId, modId, cb, {
                incomplete: true,
            }));
        }
    }
    updateMatchedReferences(props) {
        const { mods, profile } = props;
        const collections = Object.values(mods).filter(mod => mod.type === constants_1.MOD_TYPE);
        return collections.reduce((prev, collection) => {
            prev[collection.id] =
                (collection.rules || [])
                    .filter(rule => (rule.type === 'requires') && !rule['ignored'])
                    .map(rule => {
                    var _a, _b;
                    const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
                    if ((mod !== undefined) && !((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[mod.id]) === null || _b === void 0 ? void 0 : _b.enabled)) {
                        return null;
                    }
                    return mod !== null && mod !== void 0 ? mod : null;
                });
            return prev;
        }, {});
    }
}
function mapStateToProps(state) {
    var _a, _b;
    const profile = vortex_api_1.selectors.activeProfile(state);
    const game = profile !== undefined ? vortex_api_1.selectors.gameById(state, profile.gameId) : undefined;
    return {
        game,
        profile,
        mods: profile !== undefined ? ((_a = state.persistent.mods[profile.gameId]) !== null && _a !== void 0 ? _a : emptyObj) : emptyObj,
        notifications: state.session.notifications.notifications,
        downloads: state.persistent.downloads.files,
        userInfo: (_b = state.persistent['nexus']) === null || _b === void 0 ? void 0 : _b.userInfo,
        exts: profile !== undefined ? (0, extension_1.findExtensions)(state, profile.gameId) : emptyArr,
    };
}
function mapDispatchToProps(dispatch) {
    return {
        removeMod: (gameId, modId) => dispatch(vortex_api_1.actions.removeMod(gameId, modId)),
    };
}
exports["default"] = (0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)((0, react_i18next_1.withTranslation)([constants_1.NAMESPACE, 'common'])(CollectionsMainPage));


/***/ }),

/***/ "./src/views/CollectionModsPageAttributeRenderer.tsx":
/*!***********************************************************!*\
  !*** ./src/views/CollectionModsPageAttributeRenderer.tsx ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function TooltipItem(props) {
    const { name } = props;
    return (React.createElement("li", null, name));
}
function Tooltip(props) {
    const { collectionNames } = props;
    return (React.createElement("ul", { className: 'collection-mods-page-attrib-tooltip' }, collectionNames.map((name, idx) => React.createElement(TooltipItem, { key: `${name}${idx}`, name: name }))));
}
function nop() {
}
function CollectionCount(props) {
    const { collectionNames, modId } = props;
    const filtered = collectionNames.slice(1);
    const tip = React.createElement(Tooltip, { collectionNames: filtered });
    return (React.createElement(vortex_api_1.tooltip.Button, { id: `${modId}-collection-count`, className: 'collection-mods-page-attr-addendum', tooltip: tip, onClick: nop }, `+${filtered.length}`));
}
function CollectionModsPageAttributeRenderer(props) {
    const { collections, detailCell, modId } = props;
    const collectionNames = collections.map(collection => vortex_api_1.util.renderModName(collection));
    const count = collectionNames.length;
    return (count > 0)
        ? (React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-mods-page-attribute-renderer' },
            React.createElement(vortex_api_1.FlexLayout.Fixed, null, detailCell ? (React.createElement("ul", null, collectionNames.map(name => (React.createElement("li", { key: name }, name))))) : (React.createElement("div", null, collectionNames[0]))),
            ((count > 1) && !detailCell) ? (React.createElement(CollectionCount, { collectionNames: collectionNames, modId: modId })) : null)) : null;
}
exports["default"] = CollectionModsPageAttributeRenderer;


/***/ }),

/***/ "./src/views/CollectionPageEdit/FileOverrides.tsx":
/*!********************************************************!*\
  !*** ./src/views/CollectionPageEdit/FileOverrides.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function FileOverrides(props) {
    var _a;
    const { t, collection, mods, onSetCollectionAttribute, pathTool } = props;
    const { discovery } = (0, react_redux_1.useSelector)(mapStateToProps);
    const [showOverlay, setShowOverlay] = React.useState(undefined);
    const target = React.useRef();
    const container = React.useRef();
    const modsWithOverrides = React.useMemo(() => {
        var _a;
        return ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type))
            .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
            .filter(mod => { var _a; return ((_a = mod === null || mod === void 0 ? void 0 : mod.fileOverrides) !== null && _a !== void 0 ? _a : []).length > 0; });
    }, [collection, mods]);
    const toggleOverride = React.useCallback((value, dataId) => {
        onSetCollectionAttribute(['fileOverrides', dataId], value);
    }, []);
    const togglePopover = React.useCallback((evt) => {
        const modId = evt.currentTarget.getAttribute('data-modid');
        if (showOverlay === modId) {
            setShowOverlay(undefined);
        }
        else {
            target.current = evt.currentTarget;
            setShowOverlay(modId);
        }
    }, [setShowOverlay, showOverlay]);
    const hide = React.useCallback((evt) => {
        evt.preventDefault();
        setShowOverlay(undefined);
    }, []);
    const getBounds = React.useCallback(() => {
        return container.current !== undefined ? container.current.getBoundingClientRect() : {
            left: 0,
            top: 0,
            width: window.innerWidth,
            height: window.innerHeight,
            right: window.innerWidth,
            bottom: window.innerHeight,
        };
    }, [container.current]);
    const mod = mods[showOverlay];
    const toRelPath = (filePath) => pathTool.relative(discovery.path, filePath);
    const popover = showOverlay === undefined ? React.createElement(react_bootstrap_1.Popover, null) : (React.createElement(react_bootstrap_1.Popover, { id: 'file-overrides-popover' },
        React.createElement(react_bootstrap_1.ListGroup, null, ((_a = mod.fileOverrides) !== null && _a !== void 0 ? _a : []).map(override => (React.createElement("div", { key: override }, toRelPath(override)))))));
    const isEnabled = (id) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.fileOverrides) === null || _c === void 0 ? void 0 : _c[id]) !== null && _d !== void 0 ? _d : false; };
    return (React.createElement("div", { ref: container, id: 'collection-file-overrides', className: 'collection-file-overrides' },
        React.createElement(react_bootstrap_1.ControlLabel, null,
            React.createElement("p", null, t('File overrides can be considered as a type of ignore list. This page will allow you to export file overrides that '
                + 'are defined for your selected mod list. As of Vortex 1.10.x, the file overrides are generated automatically based on '
                + 'mod rules you export as part of your collection.')),
            React.createElement("p", null, t('Please note that these pre-generated file overrides are toggled off by default as Vortex will '
                + 'generate them on the users machine as part of the collection installation automatically. Therefore there\'s no '
                + 'explicit need to export these overrides unless you have manually set certain overrides which are not generated by the mod dependency system.')),
            React.createElement("p", null, t('Any mods enabled below will NOT be deployed on the user\'s machine. '
                + 'Please use this feature sparingly as most users are not aware that Vortex offers this functionality and may '
                + 'encounter trouble when trying to tweak/remove them.'))),
        React.createElement(react_bootstrap_1.Table, null,
            React.createElement("tbody", null, modsWithOverrides.map(mod => {
                var _a;
                return (React.createElement("tr", { key: mod.id },
                    React.createElement("td", null,
                        React.createElement(vortex_api_1.Toggle, { checked: isEnabled(mod.id), dataId: mod.id, onToggle: toggleOverride },
                            vortex_api_1.util.renderModName(mod),
                            "\u00A0",
                            React.createElement(vortex_api_1.Overlay, { rootClose: true, show: showOverlay !== undefined, onHide: hide, orientation: 'horizontal', getBounds: getBounds, target: target.current }, popover))),
                    React.createElement("td", null,
                        React.createElement("a", { "data-modid": mod.id, onClick: togglePopover }, t('contains {{count}} file override', {
                            count: ((_a = mod.fileOverrides) !== null && _a !== void 0 ? _a : []).length,
                        })))));
            })))));
}
function mapStateToProps(state) {
    const gameId = vortex_api_1.selectors.activeGameId(state);
    return {
        gameId,
        discovery: vortex_api_1.selectors.discoveryByGame(state, gameId),
    };
}
exports["default"] = FileOverrides;


/***/ }),

/***/ "./src/views/CollectionPageEdit/InstallModeRenderer.tsx":
/*!**************************************************************!*\
  !*** ./src/views/CollectionPageEdit/InstallModeRenderer.tsx ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
class InstallModeRenderer extends vortex_api_1.ComponentEx {
    constructor() {
        super(...arguments);
        this.renderIconTooltip = () => {
            const { t, hasInstallerOptions } = this.props;
            return hasInstallerOptions ? (React.createElement(vortex_api_1.FlexLayout.Fixed, { style: { marginLeft: '5px', marginTop: '3px' } },
                React.createElement(vortex_api_1.tooltip.Icon, { name: 'options', tooltip: t('This mod has installer options') }))) : null;
        };
        this.renderOption = (option) => {
            const { t, options, modId } = this.props;
            const text = t(options[option]);
            return React.createElement("option", { key: option, value: option, "data-id": modId }, text);
        };
        this.selectInstallMode = (evt) => {
            var _a;
            const { onSetInstallMode } = this.props;
            const modId = (_a = evt.target.selectedOptions[0]) === null || _a === void 0 ? void 0 : _a.getAttribute('data-id');
            const newVal = evt.target.value;
            onSetInstallMode(modId, newVal);
        };
    }
    render() {
        const { options, currentInstallMode } = this.props;
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
            React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                React.createElement(react_bootstrap_1.FormControl, { componentClass: 'select', onChange: this.selectInstallMode, value: currentInstallMode }, Object.keys(options).map(this.renderOption))),
            this.renderIconTooltip()));
    }
}
function mapStateToProps(state) {
    const activeGameId = vortex_api_1.selectors.activeGameId(state);
    return {
        mods: vortex_api_1.util.getSafe(state, ['persistent', 'mods', activeGameId], {}),
    };
}
exports["default"] = (0, react_i18next_1.withTranslation)([constants_1.NAMESPACE, 'common'])((0, react_redux_1.connect)(mapStateToProps)(InstallModeRenderer));


/***/ }),

/***/ "./src/views/CollectionPageEdit/Instructions.tsx":
/*!*******************************************************!*\
  !*** ./src/views/CollectionPageEdit/Instructions.tsx ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
function CollectionGeneralInfo(props) {
    return (React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
        instructions(props),
        settings(props)));
}
const settings = (props) => {
    var _a, _b, _c;
    const [t] = (0, react_i18next_1.useTranslation)([constants_1.NAMESPACE, 'common']);
    const { onSetCollectionAttribute, collection } = props;
    const [recommendNewProfile, setRecommendNewProfile] = React.useState((_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.collectionConfig) === null || _c === void 0 ? void 0 : _c.recommendNewProfile);
    const toggleRecommendNewProfile = React.useCallback(() => {
        const newValue = !recommendNewProfile;
        setRecommendNewProfile(newValue);
        onSetCollectionAttribute(['collectionConfig', 'recommendNewProfile'], newValue);
    }, [onSetCollectionAttribute, recommendNewProfile, setRecommendNewProfile]);
    return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', id: 'collection-settings-edit', className: 'collection-settings-edit' },
        React.createElement("h4", null, t('Options')),
        React.createElement("p", null, t('The below settings can optionally be changed to customize this collection')),
        React.createElement(vortex_api_1.Toggle, { id: 'settings-recommend-new-profile', onToggle: toggleRecommendNewProfile, checked: recommendNewProfile },
            t('Recommend new profile'),
            React.createElement(vortex_api_1.More, { id: 'collection-settings-recommendnewprofile', name: t('Recommend new profile') }, t('If enabled, Vortex will recommend creating a new profile when installing this collection. If disabled, the collection will be installed into the currently active profile.')))));
};
const instructions = (props) => {
    var _a, _b;
    const [t] = (0, react_i18next_1.useTranslation)([constants_1.NAMESPACE, 'common']);
    const { collection, onSetCollectionAttribute } = props;
    const [input, setInput] = React.useState((_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a['collection']) === null || _b === void 0 ? void 0 : _b['installInstructions']);
    const [placeholder, setPlaceholder] = React.useState(t(constants_1.INSTRUCTIONS_PLACEHOLDER));
    const [hasChanged, setHasChanged] = React.useState(false);
    React.useEffect(() => {
        var _a, _b;
        setInput((_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a['collection']) === null || _b === void 0 ? void 0 : _b['installInstructions']);
    }, [collection]);
    const assignInstructions = React.useCallback((evt) => {
        setInput(evt.currentTarget.value);
        setHasChanged(true);
    }, [setInput]);
    const saveInstructions = React.useCallback(() => {
        onSetCollectionAttribute(['installInstructions'], input);
        setHasChanged(false);
    }, [input]);
    return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', id: 'collection-instructions-edit', className: 'collection-instructions-edit' },
        React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-instructions-container' },
            React.createElement("h4", null, t('Instructions')),
            React.createElement("p", null, t('Instructions will be shown to the user before installation starts and can be reviewed in the Instructions tab. You can also add individual mod instructions in the Mods tab.')),
            React.createElement(react_bootstrap_1.FormControl, { id: 'collection-instructions-area', componentClass: 'textarea', value: input, onChange: assignInstructions, placeholder: placeholder, onFocus: (e) => setPlaceholder(''), onBlur: (e) => setPlaceholder(t(constants_1.INSTRUCTIONS_PLACEHOLDER)), rows: 8 })),
        React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-instructions-buttons' },
            React.createElement(vortex_api_1.tooltip.Button, { disabled: !hasChanged, tooltip: t('Save Instructions'), onClick: saveInstructions }, t('Save')))));
};
exports["default"] = CollectionGeneralInfo;


/***/ }),

/***/ "./src/views/CollectionPageEdit/ModRules.tsx":
/*!***************************************************!*\
  !*** ./src/views/CollectionPageEdit/ModRules.tsx ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
class ModRulesPage extends vortex_api_1.ComponentEx {
    constructor() {
        super(...arguments);
        this.mAugmentedRules = (0, memoize_one_1.default)((rules) => rules.map(rule => this.augmentRule(rule)));
        this.mFilteredRules = (0, memoize_one_1.default)((collection, rules) => rules.filter(rule => !vortex_api_1.util.testModReference(collection, rule.source)));
        this.enableAllRules = () => {
            this.setRulesEnabled(true);
        };
        this.disableAllRules = () => {
            this.setRulesEnabled(false);
        };
        this.ruleSort = (lhs, rhs) => {
            return lhs.sourceName.localeCompare(rhs.sourceName);
        };
        this.toggleRule = (newValue, dataId) => {
            const { onSetCollectionAttribute } = this.props;
            onSetCollectionAttribute(['rule', dataId], newValue);
        };
    }
    shouldComponentUpdate(nextProps) {
        return (this.props.t !== nextProps.t)
            || (this.props.collection !== nextProps.collection)
            || (this.props.mods !== nextProps.mods)
            || (this.props.rules !== nextProps.rules)
            || (this.props.onSetCollectionAttribute !== nextProps.onSetCollectionAttribute);
    }
    render() {
        const { t, collection } = this.props;
        const rules = this.mAugmentedRules(this.props.rules);
        const filtered = this.mFilteredRules(collection, rules);
        let lastSourceName;
        return (React.createElement("div", { id: 'collection-mod-rules', className: 'collection-rules-edit' },
            React.createElement(react_bootstrap_1.ControlLabel, null,
                React.createElement("p", null,
                    t('By default the collection will replicate all your custom rules that dictate '
                        + 'the deployment order of mods.'),
                    "\u00A0",
                    t('If you disable rules here your collection may produce unresolved file conflicts '
                        + 'that the user has to resolve.'))),
            React.createElement("div", null,
                React.createElement("a", { onClick: this.enableAllRules }, t('Enable all')),
                React.createElement("span", { className: 'link-action-seperator' }, "\u00A0 | \u00A0"),
                React.createElement("a", { onClick: this.disableAllRules }, t('Disable all'))),
            React.createElement(react_bootstrap_1.ListGroup, null, filtered
                .sort(this.ruleSort)
                .map((rule, idx) => {
                const separator = rule.sourceName !== lastSourceName;
                lastSourceName = rule.sourceName;
                return this.renderRule(rule, idx, separator);
            }))));
    }
    augmentRule(rule) {
        return {
            ...rule,
            sourceName: (0, util_1.renderReference)(rule.source, this.props.mods),
            referenceName: (0, util_1.renderReference)(rule.reference, this.props.mods),
        };
    }
    setRulesEnabled(enable) {
        const { collection, onSetCollectionAttribute } = this.props;
        const rules = this.mAugmentedRules(this.props.rules);
        const filtered = this.mFilteredRules(collection, rules);
        filtered.forEach(rule => {
            onSetCollectionAttribute(['rule', (0, util_1.ruleId)(rule)], enable);
        });
    }
    renderRule(rule, idx, separator) {
        var _a, _b, _c, _d;
        const { collection } = this.props;
        const id = (0, util_1.ruleId)(rule);
        const checked = (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.rule) === null || _c === void 0 ? void 0 : _c[id]) !== null && _d !== void 0 ? _d : true;
        return (React.createElement(react_bootstrap_1.ListGroupItem, { className: separator ? 'collection-rule-separator' : undefined, key: idx.toString() },
            React.createElement(vortex_api_1.Toggle, { checked: checked, dataId: id, onToggle: this.toggleRule },
                React.createElement("div", { className: 'rule-name' }, rule.sourceName),
                React.createElement("div", { className: 'rule-type' }, rule.type),
                React.createElement("div", { className: 'rule-name' }, rule.referenceName))));
    }
}
exports["default"] = ModRulesPage;


/***/ }),

/***/ "./src/views/CollectionPageEdit/ModsEditPage.tsx":
/*!*******************************************************!*\
  !*** ./src/views/CollectionPageEdit/ModsEditPage.tsx ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const _ = __webpack_require__(/*! lodash */ "lodash");
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const InstallModeRenderer_1 = __webpack_require__(/*! ./InstallModeRenderer */ "./src/views/CollectionPageEdit/InstallModeRenderer.tsx");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
;
const SOURCES = {
    nexus: 'Nexus Mods',
    direct: 'Direct download',
    browse: 'Browse a website',
    bundle: 'Bundle with collection',
};
const INSTALL_MODES = {
    fresh: 'Fresh Install',
    choices: 'Same Installer Options',
    clone: 'Replicate',
};
const getCollator = (() => {
    let lang;
    let collator;
    return (locale) => {
        if ((collator === undefined) || (locale !== lang)) {
            lang = locale;
            collator = new Intl.Collator(locale, { sensitivity: 'base' });
        }
        return collator;
    };
})();
function undefSort(lhs, rhs) {
    return (lhs !== undefined)
        ? 1 : (rhs !== undefined)
        ? -1 : 0;
}
function modNameSort(lhs, rhs, collator, sortDir) {
    const lhsName = vortex_api_1.util.renderModName(lhs);
    const rhsName = vortex_api_1.util.renderModName(rhs);
    return ((lhsName === undefined) || (rhsName === undefined))
        ? undefSort(lhsName, rhsName)
        : collator.compare(lhsName, rhsName) * (sortDir !== 'desc' ? 1 : -1);
}
function sortCategories(lhs, rhs, collator, state, sortDir) {
    var _a, _b;
    const lhsCat = vortex_api_1.util.resolveCategoryName((_a = lhs === null || lhs === void 0 ? void 0 : lhs.attributes) === null || _a === void 0 ? void 0 : _a.category, state);
    const rhsCat = vortex_api_1.util.resolveCategoryName((_b = rhs === null || rhs === void 0 ? void 0 : rhs.attributes) === null || _b === void 0 ? void 0 : _b.category, state);
    return (lhsCat === rhsCat)
        ? modNameSort(lhs, rhs, collator, sortDir)
        : collator.compare(lhsCat, rhsCat);
}
const coerceableRE = /^v?[0-9.]+$/;
function safeCoerce(input) {
    var _a;
    return coerceableRE.test(input)
        ? (_a = vortex_api_1.util.coerceToSemver(input)) !== null && _a !== void 0 ? _a : input
        : input;
}
class ModsEditPage extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.mActions = [
            {
                title: 'Requires',
                icon: 'requires',
                singleRowAction: false,
                multiRowAction: true,
                condition: (instanceIds) => instanceIds.find(id => { var _a, _b; return ((_b = (_a = this.state.entries[id]) === null || _a === void 0 ? void 0 : _a.rule) === null || _b === void 0 ? void 0 : _b.type) === 'recommends'; }) !== undefined,
                action: (instanceIds) => {
                    const { onAddRule, onRemoveRule } = this.props;
                    const { entries } = this.state;
                    instanceIds.forEach(id => {
                        var _a, _b;
                        if (((_b = (_a = entries[id]) === null || _a === void 0 ? void 0 : _a.rule) === null || _b === void 0 ? void 0 : _b.type) === 'recommends') {
                            const newRule = _.cloneDeep(entries[id].rule);
                            onRemoveRule(entries[id].rule);
                            newRule.type = 'requires';
                            onAddRule(newRule);
                        }
                    });
                },
            },
            {
                title: 'Recommends',
                icon: 'recommends',
                singleRowAction: false,
                multiRowAction: true,
                condition: (instanceIds) => instanceIds.find(id => { var _a, _b; return ((_b = (_a = this.state.entries[id]) === null || _a === void 0 ? void 0 : _a.rule) === null || _b === void 0 ? void 0 : _b.type) === 'requires'; }) !== undefined,
                action: (instanceIds) => {
                    const { onAddRule, onRemoveRule } = this.props;
                    const { entries } = this.state;
                    instanceIds.forEach(id => {
                        var _a;
                        if (((_a = entries[id].rule) === null || _a === void 0 ? void 0 : _a.type) === 'requires') {
                            const newRule = _.cloneDeep(entries[id].rule);
                            onRemoveRule(entries[id].rule);
                            newRule.type = 'recommends';
                            onAddRule(newRule);
                        }
                    });
                },
            },
            {
                title: 'Set Install Type',
                icon: 'edit',
                singleRowAction: false,
                multiRowAction: true,
                action: (instanceIds) => {
                    var _a, _b, _c, _d;
                    const { onSetCollectionAttribute, collection } = this.props;
                    const refMode = (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.installMode) === null || _c === void 0 ? void 0 : _c[instanceIds[0]]) !== null && _d !== void 0 ? _d : 'fresh';
                    this.context.api.showDialog('question', 'Install Type', {
                        text: 'Please select the install mode to apply to all selected mods',
                        choices: [
                            { id: 'fresh', text: 'Fresh Install', value: refMode === 'fresh' },
                            { id: 'choices', text: 'Same Installer Options', value: refMode === 'choices' },
                            { id: 'clone', text: 'Replicate', value: refMode === 'clone' },
                        ],
                    }, [
                        { label: 'Cancel' },
                        { label: 'Apply' },
                    ]).then(result => {
                        if (result.action === 'Apply') {
                            const selected = Object.keys(result.input).find(iter => result.input[iter]);
                            instanceIds.forEach(modId => {
                                onSetCollectionAttribute(['installMode', modId], selected);
                            });
                        }
                    });
                },
            },
            {
                title: 'Set Version',
                icon: 'auto-update',
                singleRowAction: false,
                multiRowAction: true,
                action: (instanceIds) => {
                    this.context.api.showDialog('question', 'Version Match', {
                        text: 'Please choose how Vortex should choose the version of the mod to be installed. '
                            + '"Exact" means that the user should install the same version as you have '
                            + 'installed right now. "Latest" means it should get the newest version at '
                            + 'the time of installation.',
                        choices: [
                            { id: 'prefer', text: 'Prefer exact', value: true },
                            { id: 'latest', text: 'Latest', value: false },
                            { id: 'exact', text: 'Exact only', value: false },
                        ],
                    }, [
                        { label: 'Cancel' },
                        { label: 'Apply' },
                    ]).then(result => {
                        if (result.action === 'Apply') {
                            const { onAddRule, onRemoveRule } = this.props;
                            const { entries } = this.state;
                            const selected = Object.keys(result.input).find(iter => result.input[iter]);
                            instanceIds.forEach(modId => {
                                const entry = entries[modId];
                                if (entry.mod !== undefined) {
                                    const newRule = _.cloneDeep(entry.rule);
                                    newRule.reference.versionMatch = (selected === 'exact')
                                        ? entry.mod.attributes['version']
                                        : (selected === 'prefer')
                                            ? '>=' + entry.mod.attributes['version'] + '+prefer'
                                            : '*';
                                    onRemoveRule(entry.rule);
                                    onAddRule(newRule);
                                }
                            });
                        }
                    });
                },
            },
            {
                title: 'Remove',
                icon: 'delete',
                singleRowAction: true,
                multiRowAction: true,
                action: (instanceIds) => {
                    const { entries } = this.state;
                    const filteredIds = instanceIds.filter(id => entries[id] !== undefined);
                    this.context.api.showDialog('question', 'Confirm removal', {
                        text: 'Are you sure you want to remove these mods from this collection? Removing the mods from the collection will not remove them from Vortex.',
                        message: filteredIds.map(id => entries[id].mod !== undefined
                            ? vortex_api_1.util.renderModName(entries[id].mod)
                            : vortex_api_1.util.renderModReference(entries[id].rule.reference)).join('\n'),
                    }, [
                        { label: 'Cancel' },
                        { label: 'Remove', action: () => {
                                filteredIds.forEach(id => {
                                    if (entries[id] !== undefined) {
                                        this.props.onRemoveRule(entries[id].rule);
                                        delete this.nextState.entries[id];
                                    }
                                });
                            } },
                    ]);
                },
            },
            {
                icon: 'sort-none',
                title: 'Assign order',
                subMenus: (instanceIds) => {
                    const { t } = this.props;
                    const ids = Array.isArray(instanceIds)
                        ? instanceIds
                        : [instanceIds];
                    const maxPhase = Object.values(this.state.entries).reduce((prev, entry) => { var _a, _b; return Math.max(prev, (_b = (_a = entry.rule.extra) === null || _a === void 0 ? void 0 : _a['phase']) !== null && _b !== void 0 ? _b : 0); }, 0);
                    return (new Array(maxPhase + 1)).fill(0).map((ignore, idx) => {
                        const item = {
                            title: t('Phase {{num}}', { replace: { num: idx } }),
                            action: () => {
                                ids.forEach(id => { this.setPhase(this.state.entries[id], idx); });
                            },
                        };
                        return item;
                    })
                        .concat({
                        title: t('Create & Add to Phase {{num}}', { replace: { num: maxPhase + 1 } }),
                        action: () => {
                            ids.forEach(id => { this.setPhase(this.state.entries[id], maxPhase + 1); });
                        },
                    });
                },
                singleRowAction: true,
            },
        ];
        this.addMods = () => {
            const { collection, onAddModsDialog } = this.props;
            onAddModsDialog(collection.id);
        };
        this.setPhase = (mod, phase) => {
            const { onAddRule, onDismissPhaseUsage, onShowPhaseColumn, showPhaseUsage } = this.props;
            const impl = async () => {
                const newRule = _.cloneDeep(mod.rule);
                vortex_api_1.util.setdefault(newRule, 'extra', {})['phase'] = phase;
                onAddRule(newRule);
                if (phase !== 0) {
                    onShowPhaseColumn();
                }
                if (showPhaseUsage) {
                    const result = await this.context.api.showDialog('info', 'Installation Phase', {
                        text: 'When installing your collection Vortex will process installation phases '
                            + 'one by one and ensure all mods from a given phase are both '
                            + 'installed and deployed before continuing to the next phase. '
                            + 'That way, mods that require other mods being present can be set to '
                            + 'install after their requirements by being put in different phases.\n'
                            + 'Please note that Vortex will need to deploy after each phase which will '
                            + 'slow down the installation process. '
                            + 'It is advised to only utilise this feature when necessary.',
                        checkboxes: [
                            { id: 'dismiss', text: 'Don\'t show this in the future', value: false },
                        ],
                    }, [
                        { label: 'Understood' },
                    ]);
                    if (result.input['dismiss']) {
                        onDismissPhaseUsage();
                    }
                }
            };
            impl();
        };
        this.showProblems = (evt) => {
            const { t, mods } = this.props;
            const modId = evt.currentTarget.getAttribute('data-modid');
            const mod = mods[modId];
            const problems = this.state.problems[modId];
            const { api } = this.context;
            const solutions = new Map([
                ['invalid-ids', () => this.fixInvalidIds(api, mod)],
                ['no-version-set', () => this.fixMissingVersion(api, mod)],
                ['replicate-fuzzy-version', () => this.setCurrentVersion(this.state.entries[modId])],
                ['choices-fuzzy-version', () => this.setPreferVersion(this.state.entries[modId])],
            ]);
            const modName = vortex_api_1.util.renderModName(mod);
            api.showDialog('info', modName, {
                bbcode: '[list]' + problems.map((prob, idx) => {
                    if (solutions.has(prob.type)) {
                        return `[*]${prob.message} [url="cb://selectproblem/${idx}"]${t('Fix it')}[/url][/*]`;
                    }
                    else {
                        return `[*]${prob.message}[/*]`;
                    }
                }).join('') + '[/list]',
                options: {
                    translated: true,
                    bbcodeContext: {
                        callbacks: {
                            selectproblem: (idx) => {
                                solutions.get(problems[idx].type)();
                                api.closeDialog('collection-problem');
                            },
                        },
                    },
                },
            }, [
                { label: 'Close' },
            ], 'collection-problem');
        };
        this.changeInstallMode = (id, value) => {
            this.props.onSetCollectionAttribute(['installMode', id], value);
        };
        this.changeInstructions = (evt) => {
            var _a, _b, _c, _d;
            const { collection, onSetCollectionAttribute } = this.props;
            const modId = evt.currentTarget.getAttribute('data-modid');
            const value = (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.instructions) === null || _c === void 0 ? void 0 : _c[modId]) !== null && _d !== void 0 ? _d : '';
            this.context.api.showDialog('info', 'Instructions', {
                md: 'Instructions added to **required mods** will display alongside the mod as it installs.  \n'
                    + 'Instructions added to **optional mods** will display before the mod installs, the user '
                    + 'will be given the option to either install or skip the mod.  \n'
                    + 'All added instructions will be available in the "Instructions" tab on the Collections page.',
                input: [{ label: 'Instructions', id: 'instructions', type: 'multiline', value, placeholder: constants_1.INSTRUCTIONS_PLACEHOLDER }],
            }, [
                { label: 'Cancel' },
                { label: 'Save' },
            ], 'collection-set-instructions')
                .then(result => {
                if (result.action === 'Save') {
                    onSetCollectionAttribute(['instructions', modId], result.input['instructions']);
                }
            });
        };
        this.onQuerySource = (evt) => {
            var _a, _b, _c, _d, _e;
            const { collection } = this.props;
            const modId = evt.currentTarget.getAttribute('data-modid');
            const type = (_e = (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.source) === null || _c === void 0 ? void 0 : _c[modId]) === null || _d === void 0 ? void 0 : _d.type) !== null && _e !== void 0 ? _e : 'nexus';
            return this.querySource(modId, type);
        };
        const entries = this.generateEntries(props);
        this.initState({
            entries,
            problems: this.checkProblems(props, entries),
        });
        this.mColumns = [
            {
                id: 'name',
                name: 'Mod Name',
                description: 'Mod Name',
                calc: (entry) => (entry.mod !== undefined)
                    ? vortex_api_1.util.renderModName(entry.mod)
                    : vortex_api_1.util.renderModReference(entry.rule.reference),
                placement: 'table',
                edit: {},
                isDefaultSort: true,
                isSortable: true,
                filter: new vortex_api_1.TableTextFilter(true),
                sortFunc: (lhs, rhs, locale) => {
                    if ((this.mCollator === undefined) || (locale !== this.mLang)) {
                        this.mLang = locale;
                        this.mCollator = new Intl.Collator(locale, { sensitivity: 'base' });
                    }
                    return this.mCollator.compare(lhs, rhs);
                },
            }, {
                id: 'tags',
                name: 'Tag',
                description: 'Mod Highlights',
                customRenderer: (entry) => {
                    if (entry.mod === undefined) {
                        return (React.createElement(vortex_api_1.tooltip.Icon, { name: 'feedback-error', tooltip: this.props.t('This mod isn\'t installed.') }));
                    }
                    const color = vortex_api_1.util.getSafe(entry.mod.attributes, ['color'], '');
                    const icon = vortex_api_1.util.getSafe(entry.mod.attributes, ['icon'], '');
                    const hasProblem = (this.state.problems[entry.mod.id] !== undefined)
                        && (this.state.problems[entry.mod.id].length > 0);
                    const hasHighlight = color || icon;
                    if (!color && !icon && !hasProblem) {
                        return null;
                    }
                    return (React.createElement(React.Fragment, null,
                        hasHighlight ? (React.createElement(vortex_api_1.Icon, { className: 'highlight-base ' + (color !== '' ? color : 'highlight-default'), name: icon !== '' ? icon : 'highlight' })) : null,
                        hasProblem ? (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'incompatible', className: 'btn-embed', tooltip: this.state.problems[entry.mod.id]
                                .map(problem => problem.summary).join('\n'), "data-modid": entry.mod.id, onClick: this.showProblems })) : null));
                },
                calc: (entry) => {
                    var _a, _b, _c, _d;
                    if (entry.mod === undefined) {
                        return ['not-installed', 'has-problems'];
                    }
                    const color = (_b = (_a = entry.mod.attributes) === null || _a === void 0 ? void 0 : _a.color) !== null && _b !== void 0 ? _b : '';
                    const icon = (_d = (_c = entry.mod.attributes) === null || _c === void 0 ? void 0 : _c.icon) !== null && _d !== void 0 ? _d : '';
                    const problems = this.state.problems[entry.mod.id] || [];
                    return [color, icon, problems.length > 0 ? 'has-problems' : 'no-problems'];
                },
                placement: 'table',
                edit: {},
                filter: new vortex_api_1.OptionsFilter([{ value: 'has-problems', label: 'Has Problems' }], false, false),
            }, {
                id: 'category',
                name: 'Category',
                description: 'Mod Category',
                icon: 'sitemap',
                placement: 'table',
                calc: (mod) => {
                    var _a, _b;
                    return vortex_api_1.util.resolveCategoryName((_b = (_a = mod.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.category, this.context.api.store.getState());
                },
                isToggleable: true,
                edit: {},
                isSortable: true,
                isGroupable: (mod, t) => {
                    var _a, _b;
                    return vortex_api_1.util.resolveCategoryName((_b = (_a = mod.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.category, this.context.api.store.getState()) || t('<No category>');
                },
                filter: new vortex_api_1.OptionsFilter(() => {
                    const state = this.context.api.getState();
                    return Array.from(new Set(Object.values(this.state.entries)
                        .map(entry => { var _a, _b; return (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.category; })
                        .filter(entry => !!entry)
                        .map(entry => vortex_api_1.util.resolveCategoryName(entry, state))
                        .sort()))
                        .map(name => {
                        return { value: name, label: name };
                    });
                }, false, false),
                sortFuncRaw: (lhs, rhs, locale) => sortCategories(lhs.mod, rhs.mod, getCollator(locale), this.context.api.store.getState(), this.categorySort()),
            }, {
                id: 'required',
                name: 'Required',
                description: 'Whether the entire collection will fail if this mod is missing',
                calc: (mod) => {
                    return mod.rule.type === 'requires'
                        ? true
                        : false;
                },
                placement: 'table',
                edit: {
                    inline: true,
                    actions: false,
                    choices: () => [
                        { key: 'required', bool: true },
                        { key: 'optional', bool: false },
                    ],
                    onChangeValue: (source, value) => {
                        this.props.onRemoveRule(source.rule);
                        const newRule = _.cloneDeep(source.rule);
                        newRule.type = value ? 'requires' : 'recommends';
                        this.props.onAddRule(newRule);
                    },
                },
            }, {
                id: 'source',
                name: 'Source',
                description: 'How the user acquires the mod',
                calc: (entry) => {
                    var _a, _b, _c, _d;
                    const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                    const { collection } = this.props;
                    const type = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'source', id, 'type'], 'nexus');
                    return SOURCES[type];
                },
                placement: 'table',
                edit: {
                    inline: true,
                    actions: false,
                    choices: () => Object.keys(SOURCES).map(key => ({ key, text: SOURCES[key] })),
                    onChangeValue: (entry, value) => {
                        var _a, _b, _c, _d;
                        const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                        if (id !== undefined) {
                            this.querySource(id, value);
                        }
                    },
                },
            }, {
                id: 'edit-source',
                placement: 'table',
                edit: {},
                calc: (entry) => {
                    var _a, _b, _c, _d;
                    const { collection } = this.props;
                    const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                    const type = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'source', id, 'type'], 'nexus');
                    return SOURCES[type];
                },
                customRenderer: (entry) => {
                    var _a, _b, _c, _d;
                    const { t, collection } = this.props;
                    const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                    const type = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'source', id, 'type'], 'nexus');
                    return (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'edit', disabled: (entry.mod === undefined) || ['nexus', 'bundle'].includes(type), tooltip: t('Edit Source'), "data-modid": id, onClick: this.onQuerySource }));
                },
            }, {
                id: 'version-match',
                name: 'Version',
                description: 'The version to install',
                calc: (entry) => {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
                    const { collection } = this.props;
                    const { t } = this.props;
                    const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                    const version = (_g = (_f = (_e = entry.mod) === null || _e === void 0 ? void 0 : _e.attributes) === null || _f === void 0 ? void 0 : _f['version']) !== null && _g !== void 0 ? _g : t('N/A');
                    if (((_l = (_k = (_j = (_h = collection.attributes) === null || _h === void 0 ? void 0 : _h.collection) === null || _j === void 0 ? void 0 : _j.source) === null || _k === void 0 ? void 0 : _k[id]) === null || _l === void 0 ? void 0 : _l.type) === 'bundle') {
                        return t('Exact only ({{version}})', { replace: { version } });
                    }
                    if (entry.rule.reference.versionMatch === '*') {
                        return t('Latest');
                    }
                    else if ((entry.rule.reference.versionMatch === undefined)
                        || (entry.rule.reference.versionMatch || '').endsWith('+prefer')) {
                        return t('Prefer exact ({{version}})', { replace: { version } });
                    }
                    else {
                        return t('Exact only ({{version}})', { replace: { version } });
                    }
                },
                placement: 'table',
                edit: {
                    inline: true,
                    actions: false,
                    choices: (entry) => {
                        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
                        const { t, collection } = this.props;
                        const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                        const version = (_g = (_f = (_e = entry.mod) === null || _e === void 0 ? void 0 : _e.attributes) === null || _f === void 0 ? void 0 : _f['version']) !== null && _g !== void 0 ? _g : t('N/A');
                        if (((_l = (_k = (_j = (_h = collection.attributes) === null || _h === void 0 ? void 0 : _h.collection) === null || _j === void 0 ? void 0 : _j.source) === null || _k === void 0 ? void 0 : _k[id]) === null || _l === void 0 ? void 0 : _l.type) === 'bundle') {
                            return [
                                { key: 'exact', text: t('Exact only ({{version}})', { replace: { version } }) },
                            ];
                        }
                        return [
                            { key: 'exact', text: t('Exact only ({{version}})', { replace: { version } }) },
                            { key: 'prefer', text: t('Prefer exact ({{version}})', { replace: { version } }) },
                            { key: 'newest', text: t('Latest') },
                        ];
                    },
                    onChangeValue: (entry, value) => {
                        if (entry.mod === undefined) {
                            return;
                        }
                        const newRule = _.cloneDeep(entry.rule);
                        this.props.onRemoveRule(entry.rule);
                        newRule.reference.versionMatch = (value === 'exact')
                            ? entry.mod.attributes['version']
                            : (value === 'prefer')
                                ? '>=' + entry.mod.attributes['version'] + '+prefer'
                                : '*';
                        this.props.onAddRule(newRule);
                    },
                },
            }, {
                id: 'install-type',
                name: 'Install',
                description: 'How the mod should be installed on the user system',
                filter: new vortex_api_1.OptionsFilter([
                    { value: 'has-install-options', label: 'Has Installation Options' }
                ], false, false),
                calc: (entry) => {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                    const { collection } = this.props;
                    const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                    if (((_h = (_g = (_f = (_e = collection.attributes) === null || _e === void 0 ? void 0 : _e.collection) === null || _f === void 0 ? void 0 : _f.source) === null || _g === void 0 ? void 0 : _g[id]) === null || _h === void 0 ? void 0 : _h.type) === 'bundle') {
                        return INSTALL_MODES['clone'];
                    }
                    const hasInstallerOptions = ((_m = (_l = (_k = (_j = entry.mod) === null || _j === void 0 ? void 0 : _j.attributes) === null || _k === void 0 ? void 0 : _k.installerChoices) === null || _l === void 0 ? void 0 : _l.options) !== null && _m !== void 0 ? _m : []).length > 0;
                    const installMode = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'installMode', id], 'fresh');
                    return [INSTALL_MODES[installMode], hasInstallerOptions ? 'has-install-options' : 'no-options'];
                },
                placement: 'table',
                help: 'If set to "Fresh Install" the mod will simply be installed fresh on the users system, '
                    + 'installer (if applicable) and everything.\n'
                    + 'If set to "Replicate" Vortex will try to replicate your exact setup for this mod. '
                    + 'This does not bundle the mod itself but the list of files to install and patches if '
                    + 'necessary. This may increase the size of the collection and the time it takes to '
                    + 'export it considerably.',
                edit: {},
                customRenderer: (entry) => {
                    var _a, _b, _c, _d, _e, _f, _g, _h;
                    const { t, collection } = this.props;
                    const id = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_d = (_c = entry.rule) === null || _c === void 0 ? void 0 : _c.reference) === null || _d === void 0 ? void 0 : _d.id;
                    const hasInstallerOptions = ((_h = (_g = (_f = (_e = entry.mod) === null || _e === void 0 ? void 0 : _e.attributes) === null || _f === void 0 ? void 0 : _f.installerChoices) === null || _g === void 0 ? void 0 : _g.options) !== null && _h !== void 0 ? _h : []).length > 0;
                    const installMode = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'installMode', id], 'fresh');
                    return (React.createElement(InstallModeRenderer_1.default, { hasInstallerOptions: hasInstallerOptions, currentInstallMode: installMode, modId: id, onSetInstallMode: this.changeInstallMode, options: INSTALL_MODES }));
                },
            }, {
                id: 'instructions',
                name: 'Instructions',
                icon: 'edit',
                calc: (entry) => {
                    var _a, _b, _c;
                    const { collection } = this.props;
                    if (entry.mod === undefined) {
                        return null;
                    }
                    return (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.instructions) === null || _c === void 0 ? void 0 : _c[entry.mod.id];
                },
                customRenderer: (entry, detailCell, t) => {
                    var _a, _b, _c;
                    const { collection } = this.props;
                    if (entry.mod === undefined) {
                        return null;
                    }
                    const instructions = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.instructions) === null || _c === void 0 ? void 0 : _c[entry.mod.id];
                    return (!!instructions) ? (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'edit', tooltip: t('Edit Instructions'), "data-modid": entry.mod.id, onClick: this.changeInstructions }, t('Edit'))) : (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'add', tooltip: t('Add Instructions'), "data-modid": entry.mod.id, onClick: this.changeInstructions }, t('Add')));
                },
                placement: 'table',
                edit: {},
            }, {
                id: 'local_edits',
                name: 'Binary patching',
                icon: 'edit',
                help: 'With this option enabled, any changes you did to the files in this mods will '
                    + 'also be included in the Collection.',
                placement: 'table',
                calc: (entry) => {
                    var _a, _b, _c, _d;
                    const { collection } = this.props;
                    if (entry.mod === undefined) {
                        return false;
                    }
                    return (_d = (_c = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.saveEdits) === null || _c === void 0 ? void 0 : _c[entry.mod.id]) !== null && _d !== void 0 ? _d : false;
                },
                edit: {
                    choices: () => [
                        { key: 'ignore', bool: false },
                        { key: 'save', bool: true },
                    ],
                    inline: true,
                    actions: false,
                    onChangeValue: (source, value) => {
                        (async () => {
                            if (source.mod === undefined) {
                                return;
                            }
                            if (value && this.props.showBinpatchWarning) {
                                const result = await this.context.api.showDialog('question', 'Save Local Edits', {
                                    bbcode: 'With this option enabled, when you upload the Collection Vortex will '
                                        + 'compare your files on disk against the archive provided by the mod author '
                                        + 'and include patches so that any modifications get replicated when a user '
                                        + 'installs your collection.\n'
                                        + 'This allows for more customization but there are considerable drawbacks:\n'
                                        + '[list]'
                                        + '[*]Uploading the collection will take longer - a lot if it\'s a big mod\n'
                                        + '[*]these patches apply only to the exact same version&variant of the mod, '
                                        + 'if the user updates the mod the patch will be undone.'
                                        + '[/list]\n'
                                        + 'Therefore please only use this option if you absolutely have to.',
                                    checkboxes: [
                                        { id: 'dont_show_again', value: false, text: 'Don\'t show again' },
                                    ],
                                }, [
                                    { label: 'Cancel' },
                                    { label: 'Enable' },
                                ]);
                                if (result.action === 'Enable') {
                                    const state = this.context.api.getState();
                                    if (result.input['dont_show_again']) {
                                        this.props.onDismissBinpatchWarning();
                                    }
                                    const gameMode = vortex_api_1.selectors.activeGameId(state);
                                    const archive = state.persistent.downloads.files[source.mod.archiveId];
                                    const dlPath = vortex_api_1.selectors.downloadPathForGame(state, gameMode);
                                    if (archive !== undefined) {
                                        try {
                                            await vortex_api_1.fs.statAsync(path.join(dlPath, archive.localPath));
                                            this.props.onSetCollectionAttribute(['saveEdits', source.mod.id], value);
                                        }
                                        catch (err) {
                                            if (err.code === 'ENOENT') {
                                                this.context.api.showErrorNotification('Failed to enable "Local Edits"', 'To enable this feature, the corresponding archive has to exist to '
                                                    + 'compare against.', { allowReport: false });
                                            }
                                            else {
                                                this.context.api.showErrorNotification('Failed to enable "Local Edits"', err);
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                this.props.onSetCollectionAttribute(['saveEdits', source.mod.id], value);
                            }
                        })();
                    },
                },
            }, {
                id: 'phase',
                name: 'Phase',
                placement: 'table',
                isToggleable: true,
                isSortable: true,
                isDefaultVisible: false,
                groupName: (phase) => this.props.t('Phase {{phase}}', {
                    replace: { phase: (phase || 0).toString() },
                }),
                isGroupable: true,
                calc: mod => { var _a, _b; return (_b = (_a = mod.rule.extra) === null || _a === void 0 ? void 0 : _a['phase']) !== null && _b !== void 0 ? _b : 0; },
                edit: {},
            },
        ];
    }
    UNSAFE_componentWillMount() {
        const entries = this.generateEntries(this.props);
        this.nextState.entries = entries;
        this.nextState.problems = this.checkProblems(this.props, entries);
    }
    UNSAFE_componentWillReceiveProps(newProps) {
        if ((newProps.mods !== this.props.mods)
            || (newProps.collection !== this.props.collection)) {
            const entries = this.generateEntries(newProps);
            this.nextState.entries = entries;
            this.nextState.problems = this.checkProblems(newProps, entries);
        }
    }
    render() {
        const { t } = this.props;
        const { entries } = this.state;
        const addModsButton = () => {
            return (React.createElement(react_bootstrap_1.Button, { id: 'btn-more-mods', className: 'collection-add-mods-btn', onClick: this.addMods },
                React.createElement(vortex_api_1.Icon, { name: 'add' }),
                t('Add more mods')));
        };
        if (Object.keys(entries).length === 0) {
            return (React.createElement(vortex_api_1.EmptyPlaceholder, { icon: 'layout-list', text: t('There are no mods in this collection'), subtext: addModsButton(), fill: true }));
        }
        return (React.createElement("div", { className: 'collection-mods-container' },
            React.createElement(vortex_api_1.Table, { tableId: 'collection-mods', data: entries, staticElements: this.mColumns, actions: this.mActions, showDetails: false },
                React.createElement("div", { id: 'collection-add-mods-container' }, addModsButton())),
            React.createElement(vortex_api_1.Usage, { infoId: 'collection-mods' },
                React.createElement("p", null, t('Here you can configure which mods to install and how.')),
                React.createElement("p", null, t('Version: Choose whether the collection will install exactly the version you '
                    + 'have yourself or whatever is current on Nexus Mods.')),
                React.createElement("p", null, t('Required: Select whether the user has to install the mod or whether it\'s an optional recommendation, recommended mods are presented last and the user is given the choice to install them or not.')),
                React.createElement("p", null, t('Install: "Fresh Install" will install the mod as Vortex would usually do, '
                    + 'installer dialog and everything. "Replicate" will extract only the files you have '
                    + 'extracted yourself, in exactly the same location. This basically ensures the user '
                    + 'gets the same options as you without having to pick them but it only works when you '
                    + 'have selected "Exact version" in the Version column. It will also considerably '
                    + 'increase the time it takes to build the pack.')),
                React.createElement("p", null, t('Source: Decides how the user downloads the mod. "Nexus Mods" is easiest, use the '
                    + 'other options when the mod in only hosted on a different source. '
                    + 'The options also include "pack" which bundles the mod directly into the collection. '
                    + 'Do this only for stuff created during setup (e.g. generated LODs, '
                    + 'customized configuration files and such). '
                    + 'You must not include any material you don\'t hold the copyright to. '
                    + 'Also: Do not provide direct download links unless you have express permission to '
                    + 'do so.')))));
    }
    categorySort() {
        var _a, _b, _c;
        const state = this.context.api.getState();
        return (_c = (_b = (_a = state.settings.tables.mods.attributes) === null || _a === void 0 ? void 0 : _a['category']) === null || _b === void 0 ? void 0 : _b.sortDirection) !== null && _c !== void 0 ? _c : 'none';
    }
    generateEntries(props) {
        const { collection, mods } = props;
        if ((collection === undefined) || (collection.rules === undefined)) {
            return {};
        }
        return Object.values(collection.rules)
            .filter(rule => ['requires', 'recommends'].indexOf(rule.type) !== -1)
            .reduce((prev, rule) => {
            var _a, _b;
            const mod = vortex_api_1.util.findModByRef(_.omit(rule.reference, ['versionMatch']), mods);
            const id = (_b = (_a = mod === null || mod === void 0 ? void 0 : mod.id) !== null && _a !== void 0 ? _a : rule.reference.id) !== null && _b !== void 0 ? _b : rule.reference.idHint;
            if (id !== undefined) {
                prev[id] = { rule, mod };
            }
            return prev;
        }, {});
    }
    checkProblems(props, entries) {
        return Object.values(entries).reduce((prev, entry) => {
            var _a, _b, _c;
            const id = (_c = (_b = (_a = entry.mod) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : entry.rule.reference.id) !== null && _c !== void 0 ? _c : entry.rule.reference.idHint;
            if (id !== undefined) {
                prev[id] = this.updateProblems(props, entry);
            }
            return prev;
        }, {});
    }
    updateProblems(props, entry) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        const { t, collection } = props;
        if (entry.mod === undefined) {
            return;
        }
        const res = [];
        const attributes = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.collection;
        const source = (_b = attributes === null || attributes === void 0 ? void 0 : attributes.source) === null || _b === void 0 ? void 0 : _b[entry.mod.id];
        const sourceType = (_c = source === null || source === void 0 ? void 0 : source.type) !== null && _c !== void 0 ? _c : 'nexus';
        const installMode = (_e = (_d = attributes === null || attributes === void 0 ? void 0 : attributes.installMode) === null || _d === void 0 ? void 0 : _d[entry.mod.id]) !== null && _e !== void 0 ? _e : 'fresh';
        const saveEdits = (_g = (_f = attributes === null || attributes === void 0 ? void 0 : attributes.saveEdits) === null || _f === void 0 ? void 0 : _f[entry.mod.id]) !== null && _g !== void 0 ? _g : false;
        const { versionMatch } = entry.rule.reference;
        if ((sourceType === 'nexus')
            && (isNaN(parseInt((_h = entry.mod.attributes) === null || _h === void 0 ? void 0 : _h.modId, 10))
                || isNaN(parseInt((_j = entry.mod.attributes) === null || _j === void 0 ? void 0 : _j.fileId, 10)))) {
            res.push({
                type: 'invalid-ids',
                summary: t('Missing file identifiers'),
                message: t('When using "Nexus Mods" as a source, both the mod id and file id have to be '
                    + 'known. If you didn\'t download the mod through Vortex they may not be set. '
                    + 'To solve this you have to change the source of the mod to "Nexus Mods" '
                    + 'and use the options below "Nexus Mods IDs" to fill in the '
                    + 'missing data (the automated options should be quite reliable).'),
            });
        }
        if (((versionMatch === '*') || ((_k = versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch.endsWith) === null || _k === void 0 ? void 0 : _k.call(versionMatch, '+prefer')))
            && (installMode === 'clone')) {
            res.push({
                type: 'replicate-fuzzy-version',
                summary: t('"Replicate" requires "Exact only" as the version'),
                message: t('"Replicate" install can only be used when installing '
                    + 'a specific version of a mod. This will definitively break '
                    + 'as soon as the mod gets updated.'),
            });
        }
        if ((versionMatch === '*') && (installMode === 'choices')) {
            res.push({
                type: 'choices-fuzzy-version',
                summary: t('"Same Installer Options" should not be used with "Latest" version'),
                message: t('Installing with "Same choices options" may break if the mod gets updated, '
                    + 'you may want to switch to "Prefer exact" to be safe.'),
            });
        }
        if ((sourceType === 'bundle')
            && ((versionMatch === '*') || ((_l = versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch.endsWith) === null || _l === void 0 ? void 0 : _l.call(versionMatch, '+prefer')))) {
            res.push({
                type: 'bundled-fuzzy-version',
                summary: t('Version choice has no effect on "Bundled" mod'),
                message: t('If you bundle a mod the user gets exactly the version of the mod you '
                    + 'have, the Version selection is pointless in this case.'),
            });
        }
        else if (['browse', 'direct'].includes(sourceType)) {
            if ((_m = versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch.endsWith) === null || _m === void 0 ? void 0 : _m.call(versionMatch, '+prefer')) {
                res.push({
                    type: 'web-fuzzy-version',
                    summary: t('Version choice has no effect on mods using generic download.'),
                    message: t('The option to "prefer exact version" only works with sources that '
                        + 'support mod updates (Nexus Mods). For other sources your options '
                        + 'are to use the exact same version you have locally or to accept whatever '
                        + 'version the user downloads.'),
                });
            }
            if (!source.url) {
                res.push({
                    type: 'web-url-missing',
                    summary: t('No URL set'),
                    message: t('The sources "Browse a website" and "Direct download" require that '
                        + 'you provide a URL to download from.'),
                });
            }
        }
        if (saveEdits) {
            if ((versionMatch === '*') || ((_o = versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch.endsWith) === null || _o === void 0 ? void 0 : _o.call(versionMatch, '+prefer'))) {
                res.push({
                    type: 'local-edits-fuzzy-version',
                    summary: t('Version choice incompatible with saving local edits.'),
                    message: t('Local edits can only be applied if the user gets the exact same files '
                        + 'as you have installed locally, meaning they have to use the exact '
                        + 'same version of the mod.'),
                });
            }
            if (sourceType === 'bundle') {
                res.push({
                    type: 'local-edits-bundle',
                    summary: t('Combining the option to save edits and bundling makes no sense.'),
                    message: t('The option to "bundle" already bundles the edited files, storing '
                        + 'the edits separately would not be useful as they can\'t and '
                        + 'don\'t have to be applied.'),
                });
            }
            if (installMode === 'clone') {
                res.push({
                    type: 'replicate-vs-binpatch',
                    summary: t('"Replicate" installation can\'t be combined with "Binary patching"'),
                    message: t('"Replicate" depends on files being unchanged '
                        + 'from the originals in the archive. If you modified mod files '
                        + '(as Binary Patching implies), "Replicate" will fail.'),
                });
            }
        }
        if (sourceType === 'bundle') {
            res.push({
                type: 'bundle-copyright',
                summary: t('Only bundle mods you have the right to do so'),
                message: t('Mods are copyright protected, only pack mods if you are sure you '
                    + 'have the right to do so, e.g. if it\'s dynamically generated content '
                    + 'or if it\'s your own mod.'),
            });
        }
        else if (sourceType === 'direct') {
            res.push({
                type: 'direct-download',
                summary: t('Please verify you are allowed to do direct download on this site'),
                message: t('Most websites don\'t allow direct downloads, Plese make sure you are '
                    + 'allowed to use direct links to the specified page.'),
            });
        }
        if ((installMode === 'choices')
            && (((_r = (_q = (_p = entry.mod.attributes) === null || _p === void 0 ? void 0 : _p.installerChoices) === null || _q === void 0 ? void 0 : _q.options) !== null && _r !== void 0 ? _r : []).length === 0)) {
            res.push({
                type: 'installer-choices-not-saved',
                summary: t('No Installer Options saved for this mod'),
                message: t('The installer choices for this mod haven\'t been saved. '
                    + 'This currently only works with xml-based fomods installed with '
                    + 'Vortex 1.5.0 or later. '
                    + 'You may have to reinstall the mod for this to work.'),
            });
        }
        if (versionMatch === '') {
            res.push({
                type: 'no-version-set',
                summary: t('No version set for this mod'),
                message: t('The mod has no version number set. This isn\'t strictly necessary, we use the '
                    + 'file id to identify the exact version but for the purpose of informing the '
                    + 'user it would be nicer if a version was specified. '
                    + '(Please don\'t forget to update the collection)'),
            });
        }
        return res;
    }
    async fixInvalidIds(api, mod) {
        const modName = vortex_api_1.util.renderModName(mod);
        const result = await api.showDialog('question', modName, {
            text: 'You have to either fix the IDs for this mod or change how the collection '
                + 'acquires this mod.',
        }, [
            { label: 'Change Source' },
            { label: 'Fix IDs' },
        ]);
        if (result.action === 'Fix IDs') {
            api.events.emit('show-main-page', 'Mods');
            setTimeout(() => {
                api.events.emit('mods-select-item', mod.id, true);
                api.highlightControl(`.table-detail-modSource`, 4000);
                api.highlightControl(`.table-detail-nexusModId`, 4000);
            }, 200);
        }
        else {
            api.highlightControl(`#${vortex_api_1.util.sanitizeCSSId(mod.id)} > .cell-source`, 4000, undefined, true);
            api.highlightControl(`#${vortex_api_1.util.sanitizeCSSId(mod.id)} > .cell-edit-source`, 4000, undefined, true);
        }
    }
    async fixMissingVersion(api, mod) {
        api.events.emit('show-main-page', 'Mods');
        setTimeout(() => {
            api.events.emit('mods-select-item', mod.id, true);
            api.highlightControl(`.table-detail-versionDetail`, 4000);
        }, 200);
    }
    setCurrentVersion(entry) {
        this.props.onRemoveRule(entry.rule);
        const newRule = _.cloneDeep(entry.rule);
        newRule.reference.versionMatch = entry.mod.attributes['version'];
        this.props.onAddRule(newRule);
    }
    setPreferVersion(entry) {
        this.props.onRemoveRule(entry.rule);
        const newRule = _.cloneDeep(entry.rule);
        newRule.reference.versionMatch = '>=' + safeCoerce(entry.mod.attributes['version']) + '+prefer';
        this.props.onAddRule(newRule);
    }
    querySource(modId, type) {
        var _a;
        const { collection } = this.props;
        const src = vortex_api_1.util.getSafe(collection, ['attributes', 'collection', 'source', modId], { type });
        const input = [];
        let text;
        if (type === 'bundle') {
            text = 'These files will be bundled with the collection. '
                + 'This means they will be distributed alongside the collection and '
                + 'released into the public domain.\n\n'
                + 'Bundled content should not be used to distribute mods or mod files. '
                + 'It is intended to allow curators to include configuration files or '
                + 'outputs from automated tools for the convenience of users. '
                + 'Any content that would qualify as a "mod" should be uploaded to a '
                + 'Nexus Mods mod page and included in the collection, rather than being bundled.\n\n'
                + 'You should only include content that you have permission to share freely. '
                + 'Failure to respect the permissions/license of mod authors may result in '
                + 'moderation against your account.';
        }
        else if (['direct', 'browse', 'manual'].includes(type)) {
            text = 'Please provide information the user needs to find the mod';
        }
        if (['direct', 'browse'].includes(type)) {
            input.push({ id: 'url', type: 'url', label: 'URL', value: src.url });
        }
        if (['browse', 'manual'].includes(type)) {
            input.push({
                id: 'instructions', type: 'text', label: 'Instructions',
                value: src.instructions,
            });
        }
        if ((input.length > 0) || (text !== undefined)) {
            this.context.api.showDialog('question', 'Provide mod metadata', {
                text,
                input,
                checkboxes: [
                    {
                        id: 'adult',
                        bbcode: 'Mod contains adult content. '
                            + `([url=${constants_1.ADULT_CONTENT_URL}]Adult Content Guidelines[/url])`,
                        value: (_a = src.adultContent) !== null && _a !== void 0 ? _a : false,
                    },
                ],
            }, [
                { label: 'Save' },
            ]).then((result => {
                this.props.onSetCollectionAttribute(['source', modId], {
                    type,
                    url: result.input.url,
                    instructions: result.input.instructions,
                    adultContent: result.input.adult === true,
                });
            }));
        }
        else {
            this.props.onSetCollectionAttribute(['source', modId], { type });
        }
    }
}
exports["default"] = ModsEditPage;


/***/ }),

/***/ "./src/views/CollectionPageEdit/index.tsx":
/*!************************************************!*\
  !*** ./src/views/CollectionPageEdit/index.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const gameSupport_1 = __webpack_require__(/*! ../../util/gameSupport */ "./src/util/gameSupport/index.ts");
const transformCollection_1 = __webpack_require__(/*! ../../util/transformCollection */ "./src/util/transformCollection.ts");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const session_1 = __webpack_require__(/*! ../../actions/session */ "./src/actions/session.ts");
const FileOverrides_1 = __webpack_require__(/*! ./FileOverrides */ "./src/views/CollectionPageEdit/FileOverrides.tsx");
const Instructions_1 = __webpack_require__(/*! ./Instructions */ "./src/views/CollectionPageEdit/Instructions.tsx");
const ModRules_1 = __webpack_require__(/*! ./ModRules */ "./src/views/CollectionPageEdit/ModRules.tsx");
const ModsEditPage_1 = __webpack_require__(/*! ./ModsEditPage */ "./src/views/CollectionPageEdit/ModsEditPage.tsx");
const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const INIT_PAGE = 'mods';
const emptyCollectionInfo = {
    domainName: '',
    author: '',
    authorUrl: '',
    name: '',
    description: '',
    installInstructions: '',
    gameVersions: [],
};
const emptyList = [];
class CollectionEdit extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.collectionRules = (0, memoize_one_1.default)((rules, mods) => {
            const includedMods = rules
                .filter(rule => ['requires', 'recommends'].includes(rule.type))
                .reduce((prev, rule) => {
                const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
                if (mod !== undefined) {
                    prev[mod.id] = mod;
                }
                return prev;
            }, {});
            return Object.values(includedMods)
                .reduce((prev, mod) => {
                const source = vortex_api_1.util.makeModReference(mod);
                prev = [].concat(prev, (mod.rules || [])
                    .filter(rule => {
                    var _a;
                    return !['requires', 'recommends'].includes(rule.type)
                        && (((_a = rule.extra) === null || _a === void 0 ? void 0 : _a['automatic']) !== true);
                })
                    .map(rule => (0, transformCollection_1.makeBiDirRule)(source, rule)));
                return prev;
            }, []);
        });
        this.trackTabChange = (page) => {
            const game = vortex_api_1.util.getGame(this.props.profile.gameId);
            const pageTracking = page === 'gamespecific' ? game.name : page;
            this.context.api.events.emit('analytics-track-navigation', `collections/workshop/collection/${pageTracking}`);
        };
        this.setCurrentPage = (page) => {
            this.trackTabChange(page);
            this.nextState.page = page;
        };
        this.remove = () => {
            const { collection, onRemove } = this.props;
            onRemove(collection.id);
        };
        this.upload = () => {
            const { collection, onUpload } = this.props;
            onUpload(collection.id);
        };
        this.openUrl = () => {
            var _a, _b, _c, _d;
            const collectionSlug = (_c = (_b = (_a = this.state.revision) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.slug) !== null && _c !== void 0 ? _c : (_d = this.props.collection.attributes) === null || _d === void 0 ? void 0 : _d.collectionSlug;
            if (collectionSlug === undefined) {
                return;
            }
            const { revision } = this.state;
            const { collection } = revision;
            if (((collection === null || collection === void 0 ? void 0 : collection.game) !== undefined) && ((revision === null || revision === void 0 ? void 0 : revision.revisionNumber) !== undefined)) {
                this.context.api.events.emit('analytics-track-click-event', 'Collections', 'View on site Workshop Collection');
                vortex_api_1.util.opn(vortex_api_1.util.nexusModsURL([collection.game.domainName,
                    'collections', collection.slug,
                    'revisions', revision.revisionNumber.toString()], {
                    campaign: vortex_api_1.util.Campaign.ViewCollectionAsCurator,
                    section: vortex_api_1.util.Section.Collections
                }));
            }
        };
        this.addRule = (rule) => {
            const { profile, collection } = this.props;
            this.props.onAddRule(profile.gameId, collection.id, rule);
        };
        this.removeRule = (rule) => {
            const { profile, collection } = this.props;
            this.props.onRemoveRule(profile.gameId, collection.id, rule);
        };
        this.setCollectionAttribute = (attrPath, value) => {
            const { profile, collection } = this.props;
            if (this.mAttributes === undefined) {
                this.mAttributes = collection.attributes;
            }
            const attr = vortex_api_1.util.getSafe(this.mAttributes, ['collection'], {});
            const updated = vortex_api_1.util.setSafe(attr, attrPath, value);
            this.mAttributes = vortex_api_1.util.setSafe(this.mAttributes, ['collection'], updated);
            this.props.onSetModAttribute(profile.gameId, collection.id, 'collection', updated);
        };
        this.addModsDialog = (collectionId) => {
            this.props.onAddModsDialog(collectionId);
        };
        this.showPhaseColumn = () => {
            if (this.props.phaseColumnVisible === undefined) {
                this.props.onShowPhaseColumn();
            }
        };
        this.initState({
            page: INIT_PAGE,
            collectionInfo: emptyCollectionInfo,
            revision: undefined,
        });
    }
    componentDidMount() {
        this.updateState(this.props);
    }
    UNSAFE_componentWillReceiveProps(newProps) {
        var _a;
        this.mAttributes = (_a = newProps.collection) === null || _a === void 0 ? void 0 : _a.attributes;
        if (vortex_api_1.util.getSafe(newProps.collection, ['id'], undefined)
            !== vortex_api_1.util.getSafe(this.props.collection, ['id'], undefined)) {
            this.updateState(newProps);
        }
    }
    render() {
        var _a, _b;
        const { t, mods, collection, showBinpatchWarning, exts, onDismissBinpatchWarning, onDismissPhaseUsage, profile, showPhaseUsage, pathTool } = this.props;
        const { page, revision } = this.state;
        if (profile === undefined) {
            return null;
        }
        const game = vortex_api_1.util.getGame(profile.gameId);
        const extInterfaces = exts.filter(ext => ext.editComponent !== undefined);
        const uploadDisabled = this.testUploadPossible();
        const Interface = (0, gameSupport_1.getInterface)(profile.gameId);
        const nextRev = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.revisionNumber;
        const requiredModRules = this.collectionRules((_b = collection.rules) !== null && _b !== void 0 ? _b : emptyList, mods);
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-edit-header' },
                React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                    React.createElement("h3", null,
                        t('Edit Collection'),
                        " / ",
                        vortex_api_1.util.renderModName(collection)),
                    React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'delete', tooltip: t('Remove this collection'), onClick: this.remove }, t('Remove')),
                    React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'collection-export', tooltip: uploadDisabled !== null && uploadDisabled !== void 0 ? uploadDisabled : t('Upload to Nexus Mods'), onClick: this.upload, disabled: uploadDisabled !== undefined }, t(nextRev !== undefined ? 'Upload Update' : 'Upload New')),
                    React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'open-ext', tooltip: t('Open site'), onClick: this.openUrl, disabled: (revision === undefined) }, t('View Site'))),
                t('Set up your mod collection\'s rules and site preferences.')),
            React.createElement(vortex_api_1.FlexLayout.Flex, null,
                React.createElement(react_bootstrap_1.Tabs, { id: 'collection-edit-tabs', activeKey: page, onSelect: this.setCurrentPage },
                    React.createElement(react_bootstrap_1.Tab, { key: 'mods', eventKey: 'mods', title: React.createElement("div", null,
                            t('Mods'),
                            React.createElement(react_bootstrap_1.Badge, null, (collection.rules || []).length)) },
                        React.createElement(react_bootstrap_1.Panel, { style: { position: 'relative' } },
                            React.createElement(ModsEditPage_1.default, { mods: mods, collection: collection, t: t, onSetModVersion: null, showPhaseUsage: showPhaseUsage, showBinpatchWarning: showBinpatchWarning, onAddRule: this.addRule, onRemoveRule: this.removeRule, onSetCollectionAttribute: this.setCollectionAttribute, onAddModsDialog: this.addModsDialog, onDismissPhaseUsage: onDismissPhaseUsage, onDismissBinpatchWarning: onDismissBinpatchWarning, onShowPhaseColumn: this.showPhaseColumn }))),
                    React.createElement(react_bootstrap_1.Tab, { key: 'mod-rules', eventKey: 'mod-rules', title: t('Mod Rules') },
                        React.createElement(react_bootstrap_1.Panel, null,
                            React.createElement(ModRules_1.default, { t: t, collection: collection, mods: mods, rules: requiredModRules, onSetCollectionAttribute: this.setCollectionAttribute }))),
                    React.createElement(react_bootstrap_1.Tab, { key: 'file-overrides', eventKey: 'file-overrides', title: t('File Overrides') },
                        React.createElement(react_bootstrap_1.Panel, null,
                            React.createElement(FileOverrides_1.default, { t: t, collection: collection, mods: mods, onSetCollectionAttribute: this.setCollectionAttribute, pathTool: pathTool }))),
                    React.createElement(react_bootstrap_1.Tab, { key: 'collection-instructions', eventKey: 'collection-instructions', title: t('Collection Instructions') },
                        React.createElement(react_bootstrap_1.Panel, null,
                            React.createElement(Instructions_1.default, { collection: collection, onSetCollectionAttribute: this.setCollectionAttribute }))),
                    extInterfaces.map(ext => (React.createElement(react_bootstrap_1.Tab, { key: ext.id, eventKey: ext.id, title: ext.title(t) },
                        React.createElement(react_bootstrap_1.Panel, null,
                            React.createElement(ext.editComponent, { t: t, gameId: profile.gameId, collection: collection, revisionInfo: revision, onSetCollectionAttribute: this.setCollectionAttribute }))))),
                    !!Interface ? (React.createElement(react_bootstrap_1.Tab, { key: 'gamespecific', eventKey: 'gamespecific', title: game.name },
                        React.createElement(react_bootstrap_1.Panel, null,
                            React.createElement(Interface, { t: t, gameId: profile.gameId, collection: collection, revisionInfo: revision, onSetCollectionAttribute: this.setCollectionAttribute })))) : null))));
    }
    testUploadPossible() {
        var _a;
        const { t, collection } = this.props;
        const refMods = ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type));
        if (refMods.length === 0) {
            return (t('Can\'t upload an empty collection'));
        }
        else {
            return undefined;
        }
    }
    async updateState(props) {
        var _a, _b;
        this.nextState.page = INIT_PAGE;
        if (props.collection !== undefined) {
            const { collection } = props;
            const { revisionId, collectionSlug, revisionNumber } = (_a = collection.attributes) !== null && _a !== void 0 ? _a : {};
            if ((revisionId !== undefined) || (collectionSlug !== undefined)) {
                try {
                    this.nextState.revision = (_b = (await this.props.driver.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber))) !== null && _b !== void 0 ? _b : undefined;
                }
                catch (err) {
                    (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                        revisionId, collectionSlug, revisionNumber,
                        error: err.message,
                    });
                }
            }
        }
    }
}
function mapStateToProps(state, ownProps) {
    var _a, _b, _c, _d, _e, _f;
    const { settings } = state;
    return {
        phaseColumnVisible: (_d = (_c = (_b = (_a = settings.tables['collection-mods']) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.phase) === null || _c === void 0 ? void 0 : _c.enabled) !== null && _d !== void 0 ? _d : false,
        showPhaseUsage: (_e = settings.interface.usage['collection-phase']) !== null && _e !== void 0 ? _e : true,
        showBinpatchWarning: (_f = settings.interface.usage['binpatch-warning']) !== null && _f !== void 0 ? _f : true,
    };
}
function mapDispatchToProps(dispatch) {
    return {
        onSetModAttribute: (gameId, modId, key, value) => dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, key, value)),
        onAddRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.addModRule(gameId, modId, rule)),
        onRemoveRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.removeModRule(gameId, modId, rule)),
        onAddModsDialog: (collectionId) => dispatch((0, session_1.startAddModsToCollection)(collectionId)),
        onDismissPhaseUsage: () => dispatch(vortex_api_1.actions.showUsageInstruction('collection-phase', false)),
        onDismissBinpatchWarning: () => dispatch(vortex_api_1.actions.showUsageInstruction('binpatch-warning', false)),
        onShowPhaseColumn: () => dispatch(vortex_api_1.actions.setAttributeVisible('collection-mods', 'phase', true)),
    };
}
exports["default"] = (0, react_i18next_1.withTranslation)([constants_1.NAMESPACE, 'common'])((0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(CollectionEdit));


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionBanner.tsx":
/*!***********************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionBanner.tsx ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
class CollectionBanner extends vortex_api_1.ComponentEx {
    constructor() {
        super(...arguments);
        this.goGetPremium = () => {
            this.context.api.events.emit('analytics-track-click-event', 'Go Premium', 'Collections Added Collection');
            vortex_api_1.util.opn(vortex_api_1.util.nexusModsURL(constants_1.PREMIUM_PATH, {
                section: vortex_api_1.util.Section.Users,
                campaign: vortex_api_1.util.Campaign.BuyPremium,
                source: vortex_api_1.util.Source.CollectionsAd
            }))
                .catch(err => undefined);
        };
    }
    render() {
        const { t } = this.props;
        const electricBoltIconPath = 'assets/icons/electric-bolt.svg';
        const premiumPictogramPath = 'assets/pictograms/premium-pictogram.svg';
        return (React.createElement("div", { id: 'collection-premium-banner' },
            React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                    React.createElement(vortex_api_1.FlexLayout, { type: 'row', id: 'collection-premium-banner-header' },
                        React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                            React.createElement(vortex_api_1.Image, { className: 'premium-pictogram', srcs: [premiumPictogramPath] })),
                        React.createElement(vortex_api_1.FlexLayout.Flex, null,
                            React.createElement("div", { className: 'collections-premium-banner-title' }, t('Premium'))))),
                React.createElement(vortex_api_1.FlexLayout.Flex, null,
                    React.createElement("div", { className: 'collections-premium-banner-body' }, t('Auto-download collections at max speed'))),
                React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                    React.createElement(react_bootstrap_1.Button, { id: 'get-premium-button', className: 'small', onClick: this.goGetPremium },
                        React.createElement(vortex_api_1.Image, { srcs: [electricBoltIconPath] }),
                        t('Unlock max download speeds'))))));
    }
}
exports["default"] = CollectionBanner;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionInstructions.tsx":
/*!*****************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionInstructions.tsx ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const react_markdown_1 = __webpack_require__(/*! react-markdown */ "./node_modules/react-markdown/index.js");
const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
function Instructions(props) {
    var _a, _b, _c;
    const { t, collection, mods, onToggleInstructions } = props;
    const { required, optional } = React.useMemo(() => {
        var _a;
        return ((_a = collection.rules) !== null && _a !== void 0 ? _a : []).reduce((prev, rule) => {
            var _a, _b;
            if (((0, util_1.isEmpty)((_a = rule.extra) === null || _a === void 0 ? void 0 : _a.instructions))
                || !['requires', 'recommends'].includes(rule.type)) {
                return prev;
            }
            const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
            if (mod !== undefined) {
                const entry = {
                    rule,
                    mod,
                    name: vortex_api_1.util.renderModReference(rule.reference),
                    instructions: (_b = rule.extra) === null || _b === void 0 ? void 0 : _b.instructions
                };
                if (rule.type === 'requires') {
                    prev.required.push(entry);
                }
                else {
                    prev.optional.push(entry);
                }
            }
            return prev;
        }, { required: [], optional: [] });
    }, [mods, collection]);
    const installInstructions = (((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.installInstructions) === undefined ||
        ((_b = collection.attributes) === null || _b === void 0 ? void 0 : _b.installInstructions) === '') &&
        (required.length === 0) &&
        (optional.length === 0) ?
        t(constants_1.DEFAULT_INSTRUCTIONS) :
        (_c = collection.attributes) === null || _c === void 0 ? void 0 : _c.installInstructions;
    return (React.createElement(React.Fragment, null,
        React.createElement(react_markdown_1.default, { className: 'collection-instructions-text', allowedElements: ['p', 'br', 'a', 'em', 'strong'], unwrapDisallowed: true }, installInstructions),
        (required.length > 0) ? (React.createElement(React.Fragment, null,
            React.createElement("h4", null, t('Instructions - Required Mods')),
            React.createElement("div", { className: 'collection-instructions-container' },
                React.createElement("table", null,
                    React.createElement("tbody", null, required.map((iter) => {
                        var _a;
                        return (React.createElement("tr", { key: iter.name },
                            React.createElement("td", { className: 'collection-mod-name' }, iter.name),
                            React.createElement("td", { className: 'collection-mod-instructions' },
                                React.createElement(react_markdown_1.default, { allowedElements: ['p', 'br', 'a', 'em', 'strong'], unwrapDisallowed: true }, iter.instructions)),
                            React.createElement("td", { className: 'collection-mod-actions' },
                                React.createElement(react_bootstrap_1.Button, { "data-modid": (_a = iter.mod) === null || _a === void 0 ? void 0 : _a.id, onClick: onToggleInstructions }, t('Open instructions')))));
                    })))))) : null,
        (optional.length > 0) ? (React.createElement(React.Fragment, null,
            React.createElement("h4", null, t('Instructions - Optional Mods')),
            React.createElement("div", { className: 'collection-instructions-container' },
                React.createElement("table", null,
                    React.createElement("tbody", null, optional.map(iter => {
                        var _a;
                        return (React.createElement("tr", { key: iter.name },
                            React.createElement("td", { className: 'collection-mod-name' }, iter.name),
                            React.createElement("td", { className: 'collection-mod-instructions' },
                                React.createElement(react_markdown_1.default, { allowedElements: ['p', 'br', 'a', 'em', 'strong'], unwrapDisallowed: true }, iter.instructions)),
                            React.createElement("td", { className: 'collection-mod-actions' },
                                React.createElement(react_bootstrap_1.Button, { "data-modid": (_a = iter.mod) === null || _a === void 0 ? void 0 : _a.id, onClick: onToggleInstructions }, t('Open instructions')))));
                    })))))) : null));
}
exports["default"] = Instructions;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionItemStatus.tsx":
/*!***************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionItemStatus.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const RadialProgressT = vortex_api_1.RadialProgress;
class CollectionItemStatus extends React.Component {
    render() {
        var _a, _b;
        const { t, download, mod } = this.props;
        if (mod.collectionRule['ignored'] === true) {
            return (React.createElement("div", { className: 'collection-status-ignored' },
                React.createElement(vortex_api_1.Icon, { name: 'toggle-disabled' }),
                t('Ignored')));
        }
        if (mod.state === 'installed') {
            if (mod.enabled) {
                return (React.createElement("div", { className: 'collection-status-enabled' },
                    React.createElement(vortex_api_1.Icon, { name: 'toggle-enabled' }),
                    t('Enabled')));
            }
            else {
                return (React.createElement("div", { className: 'collection-status-disabled' },
                    React.createElement(vortex_api_1.Icon, { name: 'toggle-disabled' }),
                    t('Disabled')));
            }
        }
        else if (mod.state === 'installing') {
            const progressBarData = {
                min: 0,
                max: 100,
                value: ((_a = mod.progress) !== null && _a !== void 0 ? _a : 0) * 100,
                class: 'collection-install-progress',
            };
            return (React.createElement("div", { className: 'collection-status-progress' },
                React.createElement(RadialProgressT, { className: 'collection-progress-radial', data: [progressBarData], totalRadius: 32 }),
                React.createElement("div", { className: 'progress-title' }, t('Installing...'))));
        }
        else if (mod.state === 'downloading') {
            if ((download === null || download === void 0 ? void 0 : download.state) === 'paused') {
                return (React.createElement("div", { className: 'collection-status-paused' },
                    React.createElement(vortex_api_1.Icon, { name: 'pause' }),
                    t('Download paused')));
            }
            else if ((download === null || download === void 0 ? void 0 : download.state) === 'failed') {
                return (React.createElement("div", { className: 'collection-status-failed' },
                    React.createElement(vortex_api_1.Icon, { name: 'warning' }),
                    t('Download failed')));
            }
            const progressBarData = {
                min: 0,
                max: 100,
                value: ((_b = mod.progress) !== null && _b !== void 0 ? _b : 0) * 100,
                class: 'collection-install-progress',
            };
            return (React.createElement("div", { className: 'collection-status-progress' },
                React.createElement(RadialProgressT, { className: 'collection-progress-radial', data: [progressBarData], totalRadius: 32 }),
                React.createElement("div", { className: 'progress-title' }, t('Downloading...'))));
        }
        else {
            if (mod.collectionRule.type === 'recommends') {
                return (React.createElement("div", { className: 'collection-status-notinstalled' },
                    React.createElement(vortex_api_1.Icon, { name: 'install' }),
                    " ",
                    t('Not installed')));
            }
            else {
                if (mod.state === 'downloaded') {
                    return (React.createElement("div", { className: 'collection-status-pending' },
                        React.createElement(vortex_api_1.Icon, { name: 'install' }),
                        t('Install pending')));
                }
                else {
                    return (React.createElement("div", { className: 'collection-status-pending' },
                        React.createElement(vortex_api_1.Icon, { name: 'download' }),
                        t('Download pending')));
                }
            }
        }
    }
}
exports["default"] = CollectionItemStatus;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionModDetails.tsx":
/*!***************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionModDetails.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
function CollectionModDetails(props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17;
    const { t, gameId, local, remote } = props;
    const uploaderName = (_e = (_b = (_a = local === null || local === void 0 ? void 0 : local.attributes) === null || _a === void 0 ? void 0 : _a.uploader) !== null && _b !== void 0 ? _b : (_d = (_c = remote === null || remote === void 0 ? void 0 : remote.file) === null || _c === void 0 ? void 0 : _c.owner) === null || _d === void 0 ? void 0 : _d.name) !== null && _e !== void 0 ? _e : constants_1.AUTHOR_UNKNOWN;
    const uploaderId = (_g = (_f = local === null || local === void 0 ? void 0 : local.attributes) === null || _f === void 0 ? void 0 : _f.uploaderId) !== null && _g !== void 0 ? _g : (_j = (_h = remote === null || remote === void 0 ? void 0 : remote.file) === null || _h === void 0 ? void 0 : _h.owner) === null || _j === void 0 ? void 0 : _j.memberId;
    const uploaderAvatar = (_m = (_l = (_k = remote === null || remote === void 0 ? void 0 : remote.file) === null || _k === void 0 ? void 0 : _k.owner) === null || _l === void 0 ? void 0 : _l.avatar) !== null && _m !== void 0 ? _m : 'assets/images/noavatar.png';
    const authorName = (_s = (_p = (_o = local === null || local === void 0 ? void 0 : local.attributes) === null || _o === void 0 ? void 0 : _o.author) !== null && _p !== void 0 ? _p : (_r = (_q = remote === null || remote === void 0 ? void 0 : remote.file) === null || _q === void 0 ? void 0 : _q.mod) === null || _r === void 0 ? void 0 : _r.author) !== null && _s !== void 0 ? _s : constants_1.AUTHOR_UNKNOWN;
    const modTitle = (_w = (_t = vortex_api_1.util.renderModName(local)) !== null && _t !== void 0 ? _t : (_v = (_u = remote === null || remote === void 0 ? void 0 : remote.file) === null || _u === void 0 ? void 0 : _u.mod) === null || _v === void 0 ? void 0 : _v.name) !== null && _w !== void 0 ? _w : '';
    const version = (_0 = (_y = (_x = local === null || local === void 0 ? void 0 : local.attributes) === null || _x === void 0 ? void 0 : _x.version) !== null && _y !== void 0 ? _y : (_z = remote === null || remote === void 0 ? void 0 : remote.file) === null || _z === void 0 ? void 0 : _z.version) !== null && _0 !== void 0 ? _0 : '???';
    const description = (_5 = (_2 = (_1 = local === null || local === void 0 ? void 0 : local.attributes) === null || _1 === void 0 ? void 0 : _1.shortDescription) !== null && _2 !== void 0 ? _2 : (_4 = (_3 = remote === null || remote === void 0 ? void 0 : remote.file) === null || _3 === void 0 ? void 0 : _3.mod) === null || _4 === void 0 ? void 0 : _4.summary) !== null && _5 !== void 0 ? _5 : '';
    const image = (_7 = (_6 = local === null || local === void 0 ? void 0 : local.attributes) === null || _6 === void 0 ? void 0 : _6.pictureUrl) !== null && _7 !== void 0 ? _7 : (_9 = (_8 = remote === null || remote === void 0 ? void 0 : remote.file) === null || _8 === void 0 ? void 0 : _8.mod) === null || _9 === void 0 ? void 0 : _9.pictureUrl;
    const domainName = (_12 = (_11 = (_10 = remote === null || remote === void 0 ? void 0 : remote.file) === null || _10 === void 0 ? void 0 : _10.game) === null || _11 === void 0 ? void 0 : _11.domainName) !== null && _12 !== void 0 ? _12 : vortex_api_1.util.nexusGameId(vortex_api_1.util.getGame((_14 = (_13 = local === null || local === void 0 ? void 0 : local.attributes) === null || _13 === void 0 ? void 0 : _13.gameId) !== null && _14 !== void 0 ? _14 : gameId));
    const modId = (_16 = (_15 = local === null || local === void 0 ? void 0 : local.attributes) === null || _15 === void 0 ? void 0 : _15.modId) !== null && _16 !== void 0 ? _16 : (_17 = remote === null || remote === void 0 ? void 0 : remote.file) === null || _17 === void 0 ? void 0 : _17.modId;
    const visitUploader = React.useCallback(() => {
        vortex_api_1.util.opn(`${constants_1.NEXUS_BASE_URL}/users/${uploaderId}`);
    }, [uploaderId]);
    const visitPage = React.useCallback(() => {
        vortex_api_1.util.opn(`${constants_1.NEXUS_BASE_URL}/${domainName}/mods/${modId}`);
    }, [uploaderId]);
    return (React.createElement("div", { className: 'installing-mod-overview' },
        React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-mod-detail-imagecontainer' }, (image)
                ? React.createElement(vortex_api_1.ZoomableImage, { className: 'installing-mod-image', url: image })
                : null),
            React.createElement(vortex_api_1.FlexLayout.Flex, { fill: true },
                React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                    React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                        React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                            React.createElement("div", { className: 'installing-mod-title' }, modTitle),
                            (modId !== undefined) ? (React.createElement(vortex_api_1.tooltip.IconButton, { className: 'collection-open-mod-in-browser', icon: 'open-in-browser', tooltip: t('Open Mod in Webbrowser'), onClick: visitPage })) : null)),
                    React.createElement(vortex_api_1.FlexLayout.Flex, null,
                        React.createElement("div", { className: 'collection-description' }, vortex_api_1.util.bbcodeToReact(description))),
                    React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                        React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell' },
                                React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                    React.createElement(vortex_api_1.Image, { srcs: [uploaderAvatar], circle: true }),
                                    React.createElement("div", null,
                                        React.createElement("div", { className: 'title' }, t('Uploaded by')),
                                        React.createElement("div", null, (uploaderName !== constants_1.AUTHOR_UNKNOWN)
                                            ? React.createElement("a", { onClick: visitUploader }, uploaderName)
                                            : uploaderName)))),
                            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell' },
                                React.createElement("div", { className: 'title' }, t('Created by')),
                                React.createElement("div", null, authorName)),
                            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell' },
                                React.createElement("div", { className: 'title' }, t('Version')),
                                React.createElement("div", null, version)))))))));
}
exports["default"] = CollectionModDetails;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionOverview.tsx":
/*!*************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionOverview.tsx ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const CollectionReleaseStatus_1 = __webpack_require__(/*! ../CollectionReleaseStatus */ "./src/views/CollectionReleaseStatus.tsx");
const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
const HealthIndicator_1 = __webpack_require__(/*! ./HealthIndicator */ "./src/views/CollectionPageView/HealthIndicator.tsx");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const persistent_1 = __webpack_require__(/*! ../../actions/persistent */ "./src/actions/persistent.ts");
const session_1 = __webpack_require__(/*! ../../actions/session */ "./src/actions/session.ts");
const ENDORSE_DELAY_MS = 43200000;
function EndorseButton(props) {
    var _a, _b, _c, _d;
    const { t, collection, gameId, mod, voteAllowed } = props;
    const context = React.useContext(vortex_api_1.MainContext);
    const endorse = React.useCallback(async () => {
        var _a, _b;
        const endorsedStatus = (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.endorsed) !== null && _b !== void 0 ? _b : 'Undecided';
        context.api.events.emit('endorse-mod', gameId, mod.id, endorsedStatus);
        context.api.events.emit('analytics-track-click-event', 'Collections', endorsedStatus);
        setTimeout(async () => {
            refreshCollection(context.api, collection);
        }, 500);
    }, [mod, collection]);
    const endorsedStatus = (_b = (_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.endorsed) !== null && _b !== void 0 ? _b : 'Undecided';
    const endorsed = (((_c = mod.attributes) === null || _c === void 0 ? void 0 : _c.endorsed) === 'Endorsed');
    const classes = `collection-ghost-button ${endorsed ? 'endorse-yes' : 'endorse-maybe'}`;
    const { icon, toolTip } = {
        undecided: { icon: 'endorse-maybe', toolTip: t('Undecided') },
        abstained: { icon: 'endorse-maybe', toolTip: t('Abstained') },
        endorsed: { icon: 'endorse-yes', toolTip: t('Endorsed') },
        disabled: { icon: 'endorse-disabled', toolTip: t('Endorsement disabled by author') },
        pending: { icon: 'spinner_new', toolTip: t('Pending') }
    }[endorsedStatus.toLowerCase()] || { icon: 'like-maybe', toolTip: t('Undecided') };
    return (React.createElement(vortex_api_1.tooltip.IconButton, { icon: icon, tooltip: toolTip, className: classes, onClick: endorse, disabled: !voteAllowed || ((collection === null || collection === void 0 ? void 0 : collection.endorsements) === undefined), spin: endorsedStatus.toLowerCase() === 'pending' }, (_d = collection === null || collection === void 0 ? void 0 : collection.endorsements) !== null && _d !== void 0 ? _d : '?'));
}
function CommentButton(props) {
    var _a, _b;
    const { t, collection } = props;
    const context = React.useContext(vortex_api_1.MainContext);
    const click = React.useCallback(() => {
        if ((collection === null || collection === void 0 ? void 0 : collection['commentLink']) !== undefined) {
            context.api.events.emit('analytics-track-click-event', 'Collections', 'Comments');
            vortex_api_1.util.opn(collection['commentLink']);
        }
    }, [collection]);
    return (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'comments', className: 'collection-ghost-button', tooltip: t('Comments'), onClick: click, disabled: (collection === null || collection === void 0 ? void 0 : collection['commentLink']) === undefined }, (_b = (_a = collection === null || collection === void 0 ? void 0 : collection.forumTopic) === null || _a === void 0 ? void 0 : _a.postsCount) !== null && _b !== void 0 ? _b : 0));
}
async function refreshCollection(api, collection) {
    if (!(collection === null || collection === void 0 ? void 0 : collection.slug)) {
        return;
    }
    (0, vortex_api_1.log)('info', `refreshCollection ${collection.slug}`);
    const result = (await api.emitAndAwait('get-nexus-collection', collection.slug))[0];
    api.store.dispatch((0, persistent_1.updateCollectionInfo)(collection.id.toString(), result, Date.now()));
}
class CollectionOverview extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.enable = () => {
            this.props.onSetEnabled(true);
        };
        this.disable = () => {
            this.props.onSetEnabled(false);
        };
        this.openUrl = () => {
            const { revision } = this.props;
            const { collection } = revision;
            if (collection !== undefined && (revision === null || revision === void 0 ? void 0 : revision.revisionNumber) !== undefined) {
                this.context.api.events.emit('analytics-track-click-event', 'Collections', 'View on site Added Collection');
                vortex_api_1.util.opn(vortex_api_1.util.nexusModsURL([
                    collection.game.domainName,
                    'collections',
                    collection.slug,
                    'revisions',
                    revision.revisionNumber.toString(),
                ], {
                    campaign: vortex_api_1.util.Campaign.ViewCollection,
                    section: vortex_api_1.util.Section.Collections,
                }));
            }
        };
        this.cloneCollection = () => {
            const { onClone, collection } = this.props;
            if (onClone !== undefined && collection !== undefined) {
                onClone(collection.id);
                this.context.api.events.emit('analytics-track-click-event', 'Collections', 'Clone');
            }
        };
        this.remove = () => {
            const { onRemove, collection } = this.props;
            if (onRemove !== undefined && collection !== undefined) {
                onRemove(collection.id);
            }
        };
        this.voteSuccess = (success) => {
            var _a, _b;
            const { collection, profile, revision, showDownvoteResponse, showUpvoteResponse, onSuppressVoteResponse, onVoteSuccess, } = this.props;
            if (revision.collection === undefined) {
                (0, vortex_api_1.log)('error', 'failed to show vote response dialog, missing collection info');
                return;
            }
            const bugLink = `https://next.nexusmods.com/${revision.collection.game.domainName}/collections/${revision.collection.slug}?tab=Bugs`;
            const endorsedStatus = (_b = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.endorsed) !== null && _b !== void 0 ? _b : 'Undecided';
            if (success && showUpvoteResponse) {
                onVoteSuccess === null || onVoteSuccess === void 0 ? void 0 : onVoteSuccess(collection.id, success);
                if (endorsedStatus === 'Endorsed')
                    return;
                this.context.api.showDialog('question', 'Collection was successful', {
                    text: 'Congratulations! Please consider endorsing this collection if you are enjoying it. ' +
                        'Endorsing helps others discover this collection and lets the curator know you enjoyed it.',
                    checkboxes: [
                        { id: 'dont_show_again', value: false, text: "Don't show again" },
                    ],
                }, [
                    { label: 'Close' },
                    {
                        label: 'Endorse',
                        action: () => {
                            this.context.api.events.emit('endorse-mod', profile.gameId, collection.id, endorsedStatus);
                            this.context.api.events.emit('analytics-track-click-event', 'Collections', endorsedStatus);
                        },
                    },
                ])
                    .then((result) => {
                    if (result.input['dont_show_again']) {
                        onSuppressVoteResponse('upvote');
                    }
                });
            }
            else if (!success && showDownvoteResponse) {
                this.context.api.store.dispatch((0, session_1.healthDownvoteDialog)(collection.id));
            }
        };
        this.initState({ selIdx: 0 });
        this.mWorkshopActions = [
            {
                title: 'Enable',
                action: this.enable,
                condition: () => {
                    var _a, _b;
                    const { collection, incomplete, profile } = this.props;
                    return (!incomplete && ((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[collection.id]) === null || _b === void 0 ? void 0 : _b.enabled) !== true);
                },
                icon: 'toggle-enabled',
            },
            {
                title: 'View on Nexus Mods',
                action: this.openUrl,
                condition: () => {
                    var _a;
                    return ((_a = this.props.collection.attributes) === null || _a === void 0 ? void 0 : _a.collectionSlug) !== undefined &&
                        this.props.revision !== undefined;
                },
                icon: 'open-in-browser',
            },
            {
                title: 'Disable',
                action: this.disable,
                condition: () => {
                    var _a, _b;
                    const { collection, incomplete, profile } = this.props;
                    return (!incomplete && ((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[collection.id]) === null || _b === void 0 ? void 0 : _b.enabled) === true);
                },
                icon: 'toggle-disabled',
            },
            {
                title: 'Show in Mods',
                action: this.props.onShowMods,
                icon: 'inspect',
            },
            {
                title: 'Edit (Workshop)',
                action: this.cloneCollection,
                condition: () => this.props.onClone !== undefined,
                icon: 'clone',
            },
            {
                title: 'Remove',
                action: this.remove,
                condition: () => this.props.onRemove !== undefined,
                icon: 'remove',
            },
        ];
    }
    componentDidMount() {
        const { revision } = this.props;
        refreshCollection(this.context.api, revision.collection);
    }
    render() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
        const { t, collection, incomplete, profile, revision, votedSuccess } = this.props;
        const classes = ['collection-overview'];
        const timeSinceInstall = Date.now() - new Date(((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.installCompleted) ? (_b = collection.attributes) === null || _b === void 0 ? void 0 : _b.installCompleted : (_d = (_c = collection.attributes) === null || _c === void 0 ? void 0 : _c.installTime) !== null && _d !== void 0 ? _d : 0).getTime();
        const voteAllowed = timeSinceInstall >= ENDORSE_DELAY_MS;
        const rating = {
            average: parseFloat((_f = (_e = revision.collection) === null || _e === void 0 ? void 0 : _e.overallRating) !== null && _f !== void 0 ? _f : '100'),
            total: (_h = (_g = revision.collection) === null || _g === void 0 ? void 0 : _g.overallRatingCount) !== null && _h !== void 0 ? _h : 0,
        };
        return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' ') },
            React.createElement(react_bootstrap_1.Media, null,
                React.createElement(react_bootstrap_1.Media.Left, null,
                    React.createElement(CollectionTile_1.default, { t: t, imageTime: Date.now(), collection: collection, gameId: profile.gameId, details: false })),
                React.createElement(react_bootstrap_1.Media.Body, null,
                    React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                        React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                            React.createElement("div", { className: 'collection-overview-title' },
                                React.createElement("div", { className: 'collection-title' }, vortex_api_1.util.renderModName(collection)),
                                React.createElement(CollectionReleaseStatus_1.default, { t: t, active: true, enabled: (_l = (_k = (_j = profile.modState) === null || _j === void 0 ? void 0 : _j[collection.id]) === null || _k === void 0 ? void 0 : _k.enabled) !== null && _l !== void 0 ? _l : false, collection: collection, incomplete: incomplete }),
                                React.createElement("div", { className: 'flex-filler' }))),
                        React.createElement(vortex_api_1.FlexLayout.Flex, { className: 'collection-description-container' },
                            React.createElement("div", { className: 'collection-description' }, (_o = (_m = collection.attributes) === null || _m === void 0 ? void 0 : _m.shortDescription) !== null && _o !== void 0 ? _o : t('No description'))),
                        React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-page-detail-bar' },
                            React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell ' },
                                    React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                                        React.createElement(vortex_api_1.Image, { srcs: [
                                                (_q = (_p = collection.attributes) === null || _p === void 0 ? void 0 : _p.uploaderAvatar) !== null && _q !== void 0 ? _q : 'assets/images/noavatar.png',
                                            ], circle: true }),
                                        React.createElement("div", null,
                                            React.createElement("div", { className: 'title' }, t('Curated by')),
                                            React.createElement("div", null, (_r = collection.attributes) === null || _r === void 0 ? void 0 : _r.uploader)))),
                                React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell hideable' },
                                    React.createElement("div", { className: 'title' }, t('Revision')),
                                    React.createElement("div", null, (_s = collection.attributes) === null || _s === void 0 ? void 0 : _s.revisionNumber)),
                                React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell' },
                                    React.createElement("div", { className: 'title' }, t('Last updated')),
                                    React.createElement("div", null, this.renderTime((_t = collection.attributes) === null || _t === void 0 ? void 0 : _t.updatedTimestamp))),
                                React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-detail-cell hideable' },
                                    React.createElement("div", { className: 'title' }, t('Uploaded')),
                                    React.createElement("div", null, this.renderTime((_u = collection.attributes) === null || _u === void 0 ? void 0 : _u.uploadedTimestamp))),
                                React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                    React.createElement(EndorseButton, { t: t, collection: revision.collection, mod: collection, gameId: profile.gameId, voteAllowed: voteAllowed })),
                                React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                    React.createElement(CommentButton, { t: t, collection: revision.collection })),
                                React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                    React.createElement("div", null)))))),
                React.createElement(react_bootstrap_1.Media.Right, null,
                    React.createElement("div", { className: 'collection-health-container' },
                        React.createElement(vortex_api_1.FlexLayout, { type: 'column' },
                            React.createElement(vortex_api_1.FlexLayout.Fixed, null, (revision === null || revision === void 0 ? void 0 : revision.revisionStatus) !== 'is_private' ? (React.createElement(HealthIndicator_1.default, { t: t, revisionNumber: (_v = revision === null || revision === void 0 ? void 0 : revision.revisionNumber) !== null && _v !== void 0 ? _v : 0, value: rating, onVoteSuccess: this.voteSuccess, ownSuccess: votedSuccess, voteAllowed: voteAllowed, gameVersion: (_y = (_x = (_w = this.context.api.getState().persistent) === null || _w === void 0 ? void 0 : _w.gameMode) === null || _x === void 0 ? void 0 : _x.versions[profile.gameId]) !== null && _y !== void 0 ? _y : '?', collectionGameVersion: (_1 = (_0 = (_z = revision === null || revision === void 0 ? void 0 : revision.gameVersions) === null || _z === void 0 ? void 0 : _z[0]) === null || _0 === void 0 ? void 0 : _0.reference) !== null && _1 !== void 0 ? _1 : '?' })) : null),
                            React.createElement(vortex_api_1.FlexLayout.Flex, null,
                                React.createElement("div", { className: 'collection-workshop-actions' },
                                    React.createElement(vortex_api_1.ActionDropdown, { t: t, id: 'collection-workshop-actions', staticElements: this.mWorkshopActions })))))))));
    }
    renderTime(timestamp) {
        const { t, language } = this.props;
        if (timestamp === undefined) {
            return t('Never');
        }
        return new Date(timestamp).toLocaleDateString(language);
    }
}
exports["default"] = CollectionOverview;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionOverviewSelection.tsx":
/*!**********************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionOverviewSelection.tsx ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const CollectionModDetails_1 = __webpack_require__(/*! ./CollectionModDetails */ "./src/views/CollectionPageView/CollectionModDetails.tsx");
const CollectionReleaseStatus_1 = __webpack_require__(/*! ../CollectionReleaseStatus */ "./src/views/CollectionReleaseStatus.tsx");
const SlideshowControls_1 = __webpack_require__(/*! ./SlideshowControls */ "./src/views/CollectionPageView/SlideshowControls.tsx");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
class CollectionOverview extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.setSelection = (idx) => {
            this.nextState.selIdx = (this.props.modSelection.length === 0)
                ? 0
                : idx % this.props.modSelection.length;
        };
        this.initState({ selIdx: 0 });
    }
    render() {
        var _a, _b, _c, _d, _e;
        const { t, collection, incomplete, modSelection, profile } = this.props;
        let { selIdx } = this.state;
        if (selIdx >= modSelection.length) {
            selIdx = 0;
        }
        const modDetails = modSelection.length > 0;
        const classes = ['collection-overview'];
        if (modDetails) {
            classes.push('collection-mod-selection');
        }
        return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' ') },
            React.createElement("div", { className: 'collection-overview-title' },
                React.createElement("div", { className: 'collection-title' }, vortex_api_1.util.renderModName(collection)),
                React.createElement(CollectionReleaseStatus_1.default, { t: t, active: true, enabled: (_c = (_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[collection.id]) === null || _b === void 0 ? void 0 : _b.enabled) !== null && _c !== void 0 ? _c : false, collection: collection, incomplete: incomplete }),
                modSelection.length > 1 ? (React.createElement(React.Fragment, null,
                    React.createElement(SlideshowControls_1.default, { t: t, numItems: modSelection.length, onChangeItem: this.setSelection, autoProgressTimeMS: 5000 }),
                    React.createElement("div", { className: 'flex-filler' }),
                    React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed', tooltip: t('Deselects mods'), icon: 'close', onClick: this.props.onDeselectMods }))) : null),
            React.createElement(CollectionModDetails_1.default, { t: t, local: (_d = modSelection[selIdx]) === null || _d === void 0 ? void 0 : _d.local, remote: (_e = modSelection[selIdx]) === null || _e === void 0 ? void 0 : _e.remote, gameId: profile.gameId })));
    }
}
exports["default"] = CollectionOverview;


/***/ }),

/***/ "./src/views/CollectionPageView/CollectionProgress.tsx":
/*!*************************************************************!*\
  !*** ./src/views/CollectionPageView/CollectionProgress.tsx ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const CollectionBanner_1 = __webpack_require__(/*! ./CollectionBanner */ "./src/views/CollectionPageView/CollectionBanner.tsx");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
class CollectionProgress extends vortex_api_1.ComponentEx {
    static getDerivedStateFromProps(props, state) {
        return {
            totalSize: (0, util_1.calculateCollectionSize)(props.mods),
        };
    }
    constructor(props) {
        super(props);
        this.initState({
            totalSize: 0,
        });
    }
    render() {
        var _a;
        const { t, activity, downloads, isPremium, mods, profile, totalSize, onCancel, onPause, onResume } = this.props;
        const group = (mod, download) => {
            var _a, _b, _c;
            if ((mod.state === 'downloading') && ((download === null || download === void 0 ? void 0 : download.state) === 'paused')) {
                return 'pending';
            }
            if ((mod.state === 'installed') && !((_b = (_a = profile.modState) === null || _a === void 0 ? void 0 : _a[mod.id]) === null || _b === void 0 ? void 0 : _b.enabled)) {
                return 'disabled';
            }
            return (_c = {
                null: 'pending',
                installed: 'done',
                downloaded: 'pending',
                installing: 'installing',
                downloading: 'downloading',
            }[mod.state]) !== null && _c !== void 0 ? _c : 'pending';
        };
        const { pending, downloading, installing, disabled, done } = Object.values(mods).reduce((prev, mod) => {
            if ((mod.collectionRule.type === 'requires') && !mod.collectionRule['ignored']) {
                prev[group(mod, downloads[mod.archiveId])].push(mod);
            }
            return prev;
        }, { pending: [], downloading: [], installing: [], disabled: [], done: [] });
        if ((downloading.length === 0)
            && (installing.length === 0)
            && (pending.length === 0)
            && (disabled.length === 0)) {
            return null;
        }
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
            React.createElement(vortex_api_1.FlexLayout.Flex, null,
                React.createElement(react_bootstrap_1.Panel, null,
                    React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-progress-flex' },
                        (((_a = activity['dependencies']) !== null && _a !== void 0 ? _a : []).length > 0)
                            ? this.renderActivity(t('Checking Dependencies'))
                            : this.renderBars(installing, done),
                        React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                            React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-pause-cancel-flex' },
                                (onResume !== undefined) ? (React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed btn-pause-resume', onClick: onResume, disabled: onResume === null, tooltip: t('Resume'), icon: 'resume' })) : null,
                                (onPause !== undefined) ? (React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed btn-pause-resume', onClick: onPause, tooltip: t('Pause'), icon: 'pause' })) : null,
                                React.createElement(vortex_api_1.tooltip.IconButton, { className: 'btn-embed btn-cancel', onClick: onCancel, icon: 'stop', tooltip: t('Cancel') }, t('Cancel'))))))),
            isPremium ? null : (React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-banner-container' },
                React.createElement(CollectionBanner_1.default, { t: t, totalSize: totalSize })))));
    }
    renderActivity(message) {
        return (React.createElement(vortex_api_1.FlexLayout.Flex, null,
            React.createElement(vortex_api_1.Spinner, null),
            ' ',
            message));
    }
    renderBars(installing, done) {
        const { t, downloads, mods } = this.props;
        const { totalSize } = this.state;
        const curInstall = (installing.length > 0)
            ? installing.find(iter => iter.state === 'installing')
            : undefined;
        const downloadProgress = Object.values(mods).reduce((prev, mod) => {
            var _a;
            let size = 0;
            if ((mod.state === 'downloading') || (mod.state === null)) {
                const download = downloads[mod.archiveId];
                size += (download === null || download === void 0 ? void 0 : download.received) || 0;
            }
            else {
                size += ((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.fileSize) || 0;
            }
            return prev + size;
        }, 0);
        const relevant = Object.values(mods).filter(util_1.isRelevant);
        return (React.createElement(React.Fragment, null,
            React.createElement(vortex_api_1.ProgressBar, { now: downloadProgress, max: totalSize, showPercentage: true, labelLeft: t('Downloading'), labelRight: `${vortex_api_1.util.bytesToString(downloadProgress)} / ${vortex_api_1.util.bytesToString(totalSize)}` }),
            React.createElement(vortex_api_1.ProgressBar, { now: done.length, max: relevant.length, showPercentage: true, labelLeft: installing.length > 0 ? t('Installing') : t('Waiting to install'), labelRight: curInstall !== undefined ? vortex_api_1.util.renderModName(curInstall) : undefined })));
    }
}
exports["default"] = CollectionProgress;


/***/ }),

/***/ "./src/views/CollectionPageView/HealthDownvoteDialog.tsx":
/*!***************************************************************!*\
  !*** ./src/views/CollectionPageView/HealthDownvoteDialog.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const session_1 = __webpack_require__(/*! ../../actions/session */ "./src/actions/session.ts");
const persistent_1 = __webpack_require__(/*! ../../actions/persistent */ "./src/actions/persistent.ts");
function HealthDownvoteDialog(props) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const [optionValue, setOptionValue] = React.useState(undefined);
    const [confirmationCheck, setConfirmationCheck] = React.useState(false);
    const context = React.useContext(vortex_api_1.MainContext);
    const { t } = (0, react_i18next_1.useTranslation)(constants_1.NAMESPACE);
    const dispatch = (0, react_redux_1.useDispatch)();
    const state = context.api.store.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const collectionId = (0, react_redux_1.useSelector)((state) => { var _a; return (_a = state.session.collections.healthDownvoteDialog) !== null && _a !== void 0 ? _a : undefined; });
    const collection = (collectionId !== undefined)
        ? (_a = state.persistent.mods[gameId]) === null || _a === void 0 ? void 0 : _a[collectionId]
        : undefined;
    let revisionInfo;
    let collectionInfo;
    let commentLink = '#';
    let bugLink = '#';
    if (((_b = collection === null || collection === void 0 ? void 0 : collection.attributes) === null || _b === void 0 ? void 0 : _b.revisionId) !== undefined) {
        revisionInfo = (_d = (_c = state.persistent.collections.revisions) === null || _c === void 0 ? void 0 : _c[collection.attributes.revisionId]) === null || _d === void 0 ? void 0 : _d.info;
        if ((revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.collection) !== undefined) {
            collectionInfo = (_f = (_e = state.persistent.collections.collections) === null || _e === void 0 ? void 0 : _e[revisionInfo.collection.id]) === null || _f === void 0 ? void 0 : _f.info;
            commentLink = (_g = collectionInfo === null || collectionInfo === void 0 ? void 0 : collectionInfo['commentLink']) !== null && _g !== void 0 ? _g : '#';
            bugLink = (_h = `https://next.nexusmods.com/${collectionInfo.game.domainName}/collections/${collectionInfo.slug}?tab=Bugs`) !== null && _h !== void 0 ? _h : '#';
        }
    }
    const hide = React.useCallback(() => {
        dispatch((0, session_1.healthDownvoteDialog)(undefined));
    }, []);
    const downvote = () => {
        sendRating(false);
        hide();
    };
    const onChecked = (evt) => {
        setConfirmationCheck(evt.currentTarget.checked);
    };
    const sendRating = async (success) => {
        var _a, _b;
        const revisionId = (_b = (_a = collection === null || collection === void 0 ? void 0 : collection.attributes) === null || _a === void 0 ? void 0 : _a.revisionId) !== null && _b !== void 0 ? _b : undefined;
        const vote = success ? 'positive' : 'negative';
        const voted = (await context.api.emitAndAwait('rate-nexus-collection-revision', parseInt(revisionId, 10), vote))[0];
        if (voted.success) {
            dispatch((0, persistent_1.updateSuccessRate)(revisionId, vote, voted.averageRating.average, voted.averageRating.total));
        }
    };
    return (React.createElement(vortex_api_1.Modal, { id: 'collection-health-downvote-dialog', className: 'collection-health-downvote-dialog', show: collection !== undefined, onHide: hide },
        React.createElement(vortex_api_1.Modal.Header, null,
            React.createElement(vortex_api_1.Modal.Title, null, t('Downvote Success Rating'))),
        React.createElement(vortex_api_1.Modal.Body, null,
            React.createElement("p", null, t(`Sorry to hear that the collection \"${vortex_api_1.util.renderModName(collection)}\" isn't working for you. Here are some steps that could help:`)),
            React.createElement("ol", null,
                React.createElement("li", null, "Make sure your game version matches the game version the collection was created for."),
                React.createElement("li", null, "Read the collection instructions and check if you've missed any steps."),
                React.createElement("li", null,
                    React.createElement("a", { href: commentLink }, "Check comments on Nexus Mods"),
                    " for advice and to reach out to the collection curator."),
                React.createElement("li", null,
                    React.createElement("a", { href: bugLink }, "View bug reports on Nexus Mods"),
                    " or report a new bug to help the curator fix the issue.")),
            React.createElement("h5", null, t(`Success ratings help others know if a collection installs and runs correctly. They are not a vote on whether you liked the collection or not.`)),
            React.createElement(react_bootstrap_1.FormGroup, null,
                React.createElement(react_bootstrap_1.Checkbox, { onChange: onChecked }, t('I have tried the above steps and confirm this collection does not work.')))),
        React.createElement(vortex_api_1.Modal.Footer, null,
            React.createElement(react_bootstrap_1.Button, { onClick: hide }, t('Cancel')),
            React.createElement(react_bootstrap_1.Button, { onClick: downvote, disabled: !confirmationCheck }, t('Submit')))));
}
exports["default"] = HealthDownvoteDialog;


/***/ }),

/***/ "./src/views/CollectionPageView/HealthIndicator.tsx":
/*!**********************************************************!*\
  !*** ./src/views/CollectionPageView/HealthIndicator.tsx ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function HealthIndicator(props) {
    const context = React.useContext(vortex_api_1.MainContext);
    const { t, onVoteSuccess, ownSuccess, revisionNumber, value, voteAllowed, gameVersion, collectionGameVersion } = props;
    const voteSuccess = React.useCallback((evt) => {
        const { success } = evt.currentTarget.dataset;
        const isUpvote = success === 'true';
        if (ownSuccess) {
            if (ownSuccess === 'positive' && isUpvote) {
                return;
            }
            if (ownSuccess === 'negative' && !isUpvote) {
                return;
            }
        }
        onVoteSuccess(isUpvote);
        context.api.events.emit('analytics-track-click-event', 'Collections', isUpvote ? 'Upvote Collection' : 'Downvote Collection');
    }, [ownSuccess]);
    if (value === undefined) {
        return null;
    }
    const RadialProgressT = vortex_api_1.RadialProgress;
    const rating = value.average;
    let cssClass = 'success-rating-good';
    if (rating === undefined) {
        cssClass = 'success-rating-insufficient';
    }
    else if (rating < 50) {
        cssClass = 'success-rating-bad';
    }
    else if (rating < 75) {
        cssClass = 'success-rating-dubious';
    }
    const versionMismatch = gameVersion !== collectionGameVersion;
    const gameVersionClassName = versionMismatch ? 'dialog-danger-text' : '';
    return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', className: 'collection-health-indicator' },
        React.createElement("div", { className: 'collection-health-header' },
            React.createElement("div", { className: 'collection-health-header-title' },
                React.createElement(vortex_api_1.Icon, { name: 'revision' }),
                t('Revision {{number}}', { replace: { number: revisionNumber } })),
            React.createElement("div", { className: 'collection-health-header-gameversion' },
                t('Game Version: '),
                React.createElement("span", { className: gameVersionClassName }, collectionGameVersion),
                (versionMismatch) ? (React.createElement(vortex_api_1.More, { id: 'collection-health-version-mismatch', name: t('Version Mismatch') }, t('This collection was created using a different version of the game than you have and is the most common reason why a collection doesn\'t work correctly.\n\n'
                    + 'Your version: {{gameVersion}}\n\n'
                    + 'Collection version: {{collectionGameVersion}}', { replace: { collectionGameVersion: collectionGameVersion, gameVersion: gameVersion } }))) : null)),
        React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-health-body' },
            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-revition-rating-parent' },
                React.createElement("div", { className: 'collection-revision-rating-container' },
                    React.createElement(RadialProgressT, { data: [
                            { class: cssClass, min: 0, max: 100, value: value.average },
                        ], totalRadius: 32, innerGap: 10, restOverlap: false }),
                    React.createElement("div", { className: 'centered-overlay' },
                        value.average,
                        "%")),
                React.createElement("div", { className: 'collection-revision-rating-numvotes' }, t('{{numVotes}} votes', { replace: { numVotes: value.total } }))),
            React.createElement(vortex_api_1.FlexLayout.Flex, null,
                React.createElement(vortex_api_1.FlexLayout, { type: 'column' }, (!voteAllowed) ? (React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-health-rating-text' }, t('Collection Success Rating'))) : (React.createElement(React.Fragment, null,
                    React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-health-rating-text' }, t('Did this collection work successfully?')),
                    React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                        React.createElement(vortex_api_1.FlexLayout, { type: 'row', className: 'collection-voting-pill' },
                            React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                React.createElement(vortex_api_1.tooltip.Button, { className: 'collection-ghost-button ' +
                                        (ownSuccess === 'positive' ? 'voted' : ''), tooltip: voteAllowed
                                        ? t('Collection worked (mostly)')
                                        : t('You must wait for 12 hours between downloading a collection revision and rating it'), "data-success": true, onClick: voteSuccess, disabled: !voteAllowed }, t('Yes'))),
                            React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                                React.createElement(vortex_api_1.tooltip.Button, { className: 'collection-ghost-button ' +
                                        (ownSuccess === 'negative' ? 'voted' : ''), tooltip: voteAllowed
                                        ? t("Collection didn't work (in a significant way)")
                                        : t('You must wait for 12 hours between downloading a collection revision and rating it'), "data-success": false, onClick: voteSuccess, disabled: !voteAllowed }, t('No'))))))))))));
}
exports["default"] = HealthIndicator;


/***/ }),

/***/ "./src/views/CollectionPageView/SlideshowControls.tsx":
/*!************************************************************!*\
  !*** ./src/views/CollectionPageView/SlideshowControls.tsx ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const Timer_1 = __webpack_require__(/*! ./Timer */ "./src/views/CollectionPageView/Timer.tsx");
function SlideshowControls(props) {
    const { t, autoProgressTimeMS, numItems, onChangeItem } = props;
    const [paused, setPaused] = React.useState(false);
    const [idx, setIdx] = React.useState(0);
    const [lastChange, setLastChange] = React.useState(0);
    const isMounted = React.useRef(false);
    React.useEffect(() => {
        isMounted.current = true;
        return () => { isMounted.current = false; };
    }, []);
    const next = React.useCallback(() => {
        if (!isMounted.current) {
            return;
        }
        let value;
        setIdx(oldValue => {
            value = (oldValue + 1) % numItems;
            return value;
        });
        setLastChange(Date.now());
        onChangeItem(value);
    }, [numItems, onChangeItem, setIdx, setLastChange]);
    const prev = React.useCallback(() => {
        let value;
        setIdx(oldValue => {
            value = oldValue > 0 ? (oldValue - 1) : (numItems - 1);
            return value;
        });
        setLastChange(Date.now());
        onChangeItem(value);
    }, [numItems, onChangeItem, setIdx, setLastChange]);
    const togglePause = React.useCallback(() => {
        setPaused(old => !old);
    }, [setPaused]);
    return (React.createElement("div", { className: 'slideshow-controls' },
        React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'collection-previous', tooltip: t('Show previous mod'), disabled: idx === 0, onClick: prev }),
        t('{{pos}} of {{count}}', { replace: { pos: idx + 1, count: numItems } }),
        React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'collection-next', tooltip: t('Show next mod'), disabled: idx === numItems - 1, onClick: next }),
        (autoProgressTimeMS !== undefined) ? (React.createElement(vortex_api_1.tooltip.IconButton, { className: 'button-with-timer', icon: paused ? 'resume' : 'pause', tooltip: t('Start/Pause automatic advancement'), onClick: togglePause },
            React.createElement(Timer_1.default, { className: 'slideshow-timer', started: lastChange, paused: paused, duration: autoProgressTimeMS, onTrigger: next }))) : null));
}
exports["default"] = SlideshowControls;


/***/ }),

/***/ "./src/views/CollectionPageView/Timer.tsx":
/*!************************************************!*\
  !*** ./src/views/CollectionPageView/Timer.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const circumference = 100;
const radius = circumference / (2 * Math.PI);
const stroke = Math.ceil(radius / 6);
const width = radius * 2 + stroke;
const center = width / 2;
function Timer(props) {
    const { className, duration, onTrigger, paused, started } = props;
    const [timer, setTimer] = React.useState(null);
    const [active, setActive] = React.useState(true);
    const [elapsed, setElapsed] = React.useState(null);
    React.useEffect(() => {
        return () => {
            if (timer !== null) {
                clearTimeout(timer);
            }
        };
    }, []);
    React.useEffect(() => {
        setActive(false);
        setElapsed(null);
        setTimeout(() => {
            setActive(true);
        }, 10);
    }, [setActive, setElapsed, started]);
    React.useEffect(() => {
        if (timer !== null) {
            clearTimeout(timer);
        }
        if (paused) {
            setElapsed(Date.now() - started);
        }
        else {
            let remaining = duration;
            if (elapsed !== null) {
                remaining = duration - elapsed;
                setElapsed(null);
            }
            else {
                remaining = (started + duration) - Date.now();
            }
            if (remaining < 0) {
                remaining = duration;
            }
            setTimer(setTimeout(() => {
                onTrigger();
            }, remaining));
        }
    }, [setTimer, setElapsed, paused, started]);
    return (React.createElement("svg", { className: className, viewBox: `0 0 ${width} ${width}`, style: { strokeWidth: stroke } },
        React.createElement("circle", { className: 'timer-background', fill: 'none', cx: center, cy: center, r: radius }),
        React.createElement("circle", { className: 'timer-circle', style: {
                animationDuration: duration.toString() + 'ms',
                animationDirection: 'reverse',
                animationIterationCount: 'infinite',
                animationTimingFunction: 'linear',
                animationPlayState: paused ? 'paused' : 'running',
                transform: 'rotate(-90deg)',
                transformOrigin: 'center',
                display: active ? undefined : 'none',
            }, strokeDasharray: `${circumference},${circumference}`, strokeLinecap: 'round', fill: 'none', cx: center, cy: center, r: radius })));
}
exports["default"] = Timer;


/***/ }),

/***/ "./src/views/CollectionPageView/index.tsx":
/*!************************************************!*\
  !*** ./src/views/CollectionPageView/index.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const findModByRef_1 = __webpack_require__(/*! ../../util/findModByRef */ "./src/util/findModByRef.ts");
const util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");
const CollectionInstructions_1 = __webpack_require__(/*! ./CollectionInstructions */ "./src/views/CollectionPageView/CollectionInstructions.tsx");
const CollectionItemStatus_1 = __webpack_require__(/*! ./CollectionItemStatus */ "./src/views/CollectionPageView/CollectionItemStatus.tsx");
const CollectionOverview_1 = __webpack_require__(/*! ./CollectionOverview */ "./src/views/CollectionPageView/CollectionOverview.tsx");
const CollectionOverviewSelection_1 = __webpack_require__(/*! ./CollectionOverviewSelection */ "./src/views/CollectionPageView/CollectionOverviewSelection.tsx");
const CollectionProgress_1 = __webpack_require__(/*! ./CollectionProgress */ "./src/views/CollectionPageView/CollectionProgress.tsx");
const Promise = __webpack_require__(/*! bluebird */ "bluebird");
const _ = __webpack_require__(/*! lodash */ "lodash");
const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const ReactDOM = __webpack_require__(/*! react-dom */ "react-dom");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const semver = __webpack_require__(/*! semver */ "semver");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const getCollator = (() => {
    let collator;
    let language;
    return (locale) => {
        if ((collator === undefined) || (locale !== language)) {
            language = locale;
            collator = new Intl.Collator(locale, { sensitivity: 'base' });
        }
        return collator;
    };
})();
const STATUS_ORDER = ['Installing', 'Downloading',
    'Install Pending', 'Download Pending',
    'Enabled', 'Disabled', 'Recommended', 'Ignored'];
function arr(input) {
    return Array.isArray(input) ? input : [input];
}
function matchRepo(mod, ref) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (ref === null) {
        return false;
    }
    const modId = ((_a = mod.attributes) === null || _a === void 0 ? void 0 : _a.modId) || ((_d = (_c = (_b = mod.collectionRule) === null || _b === void 0 ? void 0 : _b.reference) === null || _c === void 0 ? void 0 : _c.repo) === null || _d === void 0 ? void 0 : _d.modId);
    const fileId = ((_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.fileId) || ((_h = (_g = (_f = mod.collectionRule) === null || _f === void 0 ? void 0 : _f.reference) === null || _g === void 0 ? void 0 : _g.repo) === null || _h === void 0 ? void 0 : _h.fileId);
    if ((modId === undefined) || (fileId === undefined)
        || (ref.modId === undefined) || (ref.fileId === undefined)) {
        return false;
    }
    return modId.toString() === ref.modId.toString()
        && fileId.toString() === ref.fileId.toString();
}
class CollectionPage extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.mInstalling = false;
        this.revisionMerged = (0, memoize_one_1.default)((collection, revision) => ({
            ...revision,
            collection,
        }));
        this.selectTab = (tab) => {
            this.context.api.events.emit('analytics-track-navigation', `collections/view/collection/${tab}`);
            this.nextState.currentTab = tab;
        };
        this.extractAndRemoveComparators = (versionString) => {
            const comparatorPattern = /[\~\^><=]+/;
            const match = versionString.match(comparatorPattern);
            const comparator = match ? match[0] : null;
            const cleanedVersion = versionString.replace(comparatorPattern, '').trim();
            return { version: cleanedVersion, comparator: comparator };
        };
        this.pause = () => {
            this.props.onPause(this.props.collection.id);
        };
        this.cancel = () => {
            this.props.onCancel(this.props.collection.id);
        };
        this.resume = () => {
            this.props.onResume(this.props.collection.id);
        };
        this.setEnabled = (enable) => {
            const { collection, profile } = this.props;
            vortex_api_1.actions.setModsEnabled(this.context.api, profile.id, [collection.id], enable);
        };
        this.showMods = () => {
            const { collection } = this.props;
            const { api } = this.context;
            const batch = [];
            batch.push(vortex_api_1.actions.setAttributeFilter('mods', undefined, undefined));
            batch.push(vortex_api_1.actions.setAttributeFilter('mods', 'dependencies', ['depends', collection.id, vortex_api_1.util.renderModName(collection)]));
            batch.push(vortex_api_1.actions.setAttributeSort('mods', 'dependencies', 'asc'));
            vortex_api_1.util.batchDispatch(api.store, batch);
            api.events.emit('show-main-page', 'Mods');
        };
        this.close = () => {
            this.props.onView(undefined);
        };
        this.unselectMods = () => {
            this.nextState.modSelection = [];
        };
        this.clone = (collectionId) => {
            const { modsEx } = this.state;
            const incomplete = Object.values(modsEx)
                .filter(mod => (mod.state !== 'installed'));
            if (incomplete.length > 0) {
                return this.context.api.showDialog('info', 'Cloning incomplete', {
                    text: 'The collection you\'re trying to clone is incomplete. Vortex can '
                        + 'not include a mod in a collection that isn\'t installed so if you continue, '
                        + 'the clone will not include these missing mods..',
                    message: incomplete.map(mod => vortex_api_1.util.renderModName(mod)).join('\n'),
                }, [
                    { label: 'Cancel' },
                    { label: 'Clone anyway', action: () => { this.props.onClone(collectionId); } },
                ]);
            }
            else {
                this.props.onClone(collectionId);
            }
        };
        this.remove = (collectionId) => {
            this.props.onCancel(collectionId);
        };
        this.changeModSelection = (modIds) => {
            const { revisionInfo } = this.props;
            const { modsEx } = this.state;
            this.nextState.modSelection = modIds.map(modId => {
                var _a, _b;
                const mod = modsEx[modId];
                return {
                    local: mod,
                    remote: (_b = (_a = revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.modFiles) === null || _a === void 0 ? void 0 : _a.find) === null || _b === void 0 ? void 0 : _b.call(_a, file => matchRepo(mod, file.file)),
                };
            });
        };
        this.setTableContainerRef = (ref) => {
            this.mTableContainerRef = (ref !== null)
                ? ReactDOM.findDOMNode(ref)
                : null;
        };
        this.toggleInstructions = (evt) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const modId = evt.currentTarget.getAttribute('data-modid');
            const { mods, onShowError, overlays } = this.props;
            const instructions = this.getModInstructions(modId);
            if (instructions === undefined) {
                const err = new vortex_api_1.util.ProcessCanceled('No instructions found', modId);
                err['attachLogOnReport'] = true;
                err['Collection'] = (_b = (_a = this.props.collection) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.collectionSlug;
                err['Revision'] = (_d = (_c = this.props.collection) === null || _c === void 0 ? void 0 : _c.attributes) === null || _d === void 0 ? void 0 : _d.revisionNumber;
                onShowError('Failed to display instructions', err, true);
                return;
            }
            const mod = mods[modId];
            const modName = vortex_api_1.util.renderModName(mod);
            if (((_e = overlays[modId]) === null || _e === void 0 ? void 0 : _e.content) !== undefined) {
                (_g = (_f = this.context.api.ext).dismissOverlay) === null || _g === void 0 ? void 0 : _g.call(_f, modId);
            }
            else {
                (_j = (_h = this.context.api.ext).showOverlay) === null || _j === void 0 ? void 0 : _j.call(_h, modId, modName, instructions, {
                    x: evt.pageX, y: evt.pageY
                });
            }
        };
        this.getModInstructions = (modId) => {
            var _a, _b;
            const { collection, mods } = this.props;
            const mod = mods[modId];
            const modRule = (_a = collection.rules) === null || _a === void 0 ? void 0 : _a.find(rule => vortex_api_1.util.testModReference(mod, rule.reference));
            return (_b = modRule === null || modRule === void 0 ? void 0 : modRule['extra']) === null || _b === void 0 ? void 0 : _b['instructions'];
        };
        this.modAtLeastDownloaded = (instanceIds) => {
            const instanceId = Array.isArray(instanceIds) ? instanceIds[0] : instanceIds;
            const mod = this.state.modsEx[instanceId];
            return mod.state !== null;
        };
        this.ignoreSelected = (modIds) => {
            const { collection, profile } = this.props;
            const { modsEx } = this.state;
            vortex_api_1.util.batchDispatch(this.context.api.store, modIds.reduce((prev, modId) => {
                prev.push(vortex_api_1.actions.addModRule(profile.gameId, collection.id, {
                    ...modsEx[modId].collectionRule,
                    ignored: true,
                }));
                return prev;
            }, []));
        };
        this.unignoreSelected = (modIds) => {
            const { collection, profile } = this.props;
            const { modsEx } = this.state;
            vortex_api_1.util.batchDispatch(this.context.api.store, modIds.reduce((prev, modId) => {
                prev.push(vortex_api_1.actions.addModRule(profile.gameId, collection.id, {
                    ...modsEx[modId].collectionRule,
                    ignored: false,
                }));
                return prev;
            }, []));
        };
        this.installManually = (modIds) => {
            const { collection } = this.props;
            const { modsEx } = this.state;
            const rules = modIds.map(modId => modsEx[modId].collectionRule);
            this.props.onInstallManually(collection.id, rules);
        };
        this.removeSelected = (modIds) => {
            var _a;
            const { t, collection, profile, onRemoveRule } = this.props;
            const { modsEx } = this.state;
            const filteredIds = modIds
                .filter(modId => modsEx[modId] !== undefined)
                .filter(modId => ['downloaded', 'installed', null].indexOf(modsEx[modId].state) !== -1);
            if (filteredIds.length === 0) {
                return;
            }
            const modNames = filteredIds
                .map(modId => (modsEx[modId].state !== null)
                ? vortex_api_1.util.renderModName(modsEx[modId], { version: true })
                : vortex_api_1.util.renderModReference(modsEx[modId].collectionRule.reference, undefined));
            const checkboxes = [
                { id: 'mod', text: t('Remove Mod'), value: true },
                { id: 'archive', text: t('Delete Archive'), value: false },
            ];
            if (((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.editable) === true) {
                checkboxes.push({ id: 'collection', text: t('Remove from Collection'), value: false });
            }
            this.context.api.showDialog('question', 'Confirm removal', {
                text: t('Do you really want to remove this mod?', {
                    count: filteredIds.length,
                    replace: { count: filteredIds.length },
                }),
                message: modNames.join('\n'),
                checkboxes,
            }, [{ label: 'Cancel' }, { label: 'Remove' }])
                .then((result) => {
                const removeMods = result.action === 'Remove' && result.input.mod;
                const removeArchive = result.action === 'Remove' && result.input.archive;
                const removeRule = result.action === 'Remove' && result.input.collection;
                const wereInstalled = filteredIds
                    .filter(key => (modsEx[key] !== undefined) && (modsEx[key].state === 'installed'))
                    .map(key => modsEx[key].id);
                const archiveIds = filteredIds
                    .filter(key => (modsEx[key] !== undefined)
                    && (['downloaded', 'installed'].includes(modsEx[key].state))
                    && (modsEx[key].archiveId !== undefined))
                    .map(key => modsEx[key].archiveId);
                const rulesToRemove = filteredIds.filter(key => modsEx[key] !== undefined);
                return (removeMods
                    ? vortex_api_1.util.removeMods(this.context.api, profile.gameId, wereInstalled)
                    : Promise.resolve())
                    .then(() => {
                    if (removeArchive) {
                        archiveIds.forEach(archiveId => {
                            this.context.api.events.emit('remove-download', archiveId);
                        });
                    }
                    return Promise.resolve();
                })
                    .then(() => {
                    if (removeRule) {
                        rulesToRemove.forEach(key => {
                            onRemoveRule(profile.gameId, collection.id, modsEx[key].collectionRule);
                        });
                    }
                });
            })
                .catch(vortex_api_1.util.ProcessCanceled, err => {
                this.context.api.sendNotification({
                    id: 'cant-remove-mod',
                    type: 'warning',
                    title: 'Failed to remove mods',
                    message: err.message,
                });
            })
                .catch(vortex_api_1.util.UserCanceled, () => null)
                .catch(err => {
                this.context.api.showErrorNotification('Failed to remove selected mods', err);
            });
        };
        this.showInMods = (modIds) => {
            const { modsEx } = this.state;
            this.showMods();
            const modId = modsEx[modIds[0]].id;
            setTimeout(() => {
                this.context.api.events.emit('mods-scroll-to', modId);
                this.context.api.highlightControl('.' + vortex_api_1.util.sanitizeCSSId(modId), 5000);
            }, 2000);
        };
        this.initState({
            modsEx: {},
            modSelection: [],
            currentTab: 'instructions',
        });
        this.mModActions = [
            {
                icon: 'install',
                title: 'Install',
                action: this.installManually,
                condition: instanceIds => {
                    const instanceId = Array.isArray(instanceIds) ? instanceIds[0] : instanceIds;
                    const mod = this.state.modsEx[instanceId];
                    return [null, 'downloaded'].includes(mod.state);
                },
            },
            {
                icon: 'delete',
                title: 'Remove',
                action: this.removeSelected,
                condition: instanceId => (typeof (instanceId) === 'string')
                    ? (['downloaded', 'installed'].includes(this.state.modsEx[instanceId].state))
                    : true,
                hotKey: { code: 46 },
            },
            {
                icon: 'show',
                title: 'Show in Mods',
                action: this.showInMods,
                condition: instanceId => this.modAtLeastDownloaded(instanceId),
                singleRowAction: true,
                multiRowAction: false,
            },
            {
                icon: 'toggle-disabled',
                title: 'Ignore',
                action: this.ignoreSelected,
                condition: instanceIds => arr(instanceIds).find(id => this.state.modsEx[id].collectionRule['ignored'] !== true) !== undefined,
            },
            {
                icon: 'toggle-enabled',
                title: 'Stop Ignoring',
                action: this.unignoreSelected,
                condition: instanceIds => arr(instanceIds).find(id => this.state.modsEx[id].collectionRule['ignored'] === true) !== undefined,
            },
        ];
        this.mAttributes = [
            {
                id: 'collection_status',
                name: 'Status',
                description: 'Is mod enabled in current profile',
                icon: 'check-o',
                customRenderer: (mod) => {
                    const download = (mod.archiveId !== undefined)
                        ? this.props.downloads[mod.archiveId]
                        : undefined;
                    return (React.createElement(CollectionItemStatus_1.default, { t: this.props.t, mod: mod, download: download, notifications: this.props.notifications, container: this.mTableContainerRef, installing: this.mInstalling }));
                },
                calc: (mod) => {
                    if (mod.collectionRule['ignored']) {
                        return ['Ignored'];
                    }
                    else if (mod.state === 'installing') {
                        return ['Installing', Math.floor(mod.progress * 100.0) / 100.0];
                    }
                    else if (mod.state === 'downloading') {
                        return ['Downloading', Math.floor(mod.progress * 100.0) / 100.0];
                    }
                    else if (mod.state === null) {
                        if (mod.collectionRule.type === 'recommends') {
                            return ['Recommended'];
                        }
                        else {
                            return ['Download Pending', 'Pending'];
                        }
                    }
                    else if (mod.state === 'downloaded') {
                        if (mod.collectionRule.type === 'recommends') {
                            return ['Recommended'];
                        }
                        else {
                            return ['Install Pending', 'Pending'];
                        }
                    }
                    return [mod.enabled === true ? 'Enabled' : 'Disabled'];
                },
                placement: 'table',
                isToggleable: false,
                edit: {},
                isSortable: true,
                sortFunc: (lhs, rhs) => {
                    return STATUS_ORDER.indexOf(lhs[0]) - STATUS_ORDER.indexOf(rhs[0]);
                },
                filter: new vortex_api_1.OptionsFilter([
                    { value: 'Enabled', label: 'Enabled' },
                    { value: 'Disabled', label: 'Disabled' },
                    { value: 'Installing', label: 'Installing' },
                    { value: 'Downloading', label: 'Downloading' },
                    { value: 'Pending', label: 'Pending' },
                    { value: 'Recommended', label: 'Not installed' },
                    { value: 'Ignored', label: 'Ignored' },
                ], true, false),
            },
            {
                id: 'required',
                name: 'Required',
                description: 'Is the mod required for this collection',
                placement: 'table',
                calc: (mod) => mod.collectionRule.type === 'requires',
                edit: {},
                filter: new vortex_api_1.OptionsFilter([
                    { value: false, label: 'Recommended' },
                    { value: true, label: 'Required' },
                ], false, false),
            },
            {
                id: 'name',
                name: 'Name',
                calc: mod => (mod.state !== null)
                    ? vortex_api_1.util.renderModReference(mod.collectionRule.reference, mod, { version: false })
                    : vortex_api_1.util.renderModReference(mod.collectionRule.reference, undefined, { version: false }),
                placement: 'table',
                edit: {},
                isToggleable: false,
                isDefaultSort: true,
                isSortable: true,
                filter: new vortex_api_1.TableTextFilter(true),
                sortFunc: (lhs, rhs, locale) => getCollator(locale).compare(lhs, rhs),
            },
            {
                id: 'version',
                name: 'Version',
                calc: mod => {
                    var _a, _b;
                    const prefer = '+prefer';
                    let verString = (_b = ((mod.state !== null)
                        ? (_a = mod.attributes.version) !== null && _a !== void 0 ? _a : mod.collectionRule.reference.versionMatch
                        : mod.collectionRule.reference.versionMatch)) !== null && _b !== void 0 ? _b : '0.0.0';
                    if (verString.endsWith(prefer)) {
                        let sv;
                        try {
                            sv = semver.minVersion(verString);
                        }
                        catch (e) {
                            const { version, comparator } = this.extractAndRemoveComparators(verString);
                            const coerced = vortex_api_1.util.coerceToSemver(version.slice(0, -(prefer.length)));
                            const range = (comparator !== null && comparator !== void 0 ? comparator : '') + coerced + prefer;
                            try {
                                sv = semver.minVersion(range);
                            }
                            catch (e2) {
                                sv = { version: coerced };
                            }
                        }
                        verString = sv.version;
                    }
                    return verString;
                },
                placement: 'table',
                edit: {},
            },
            {
                id: 'uploader',
                name: 'Uploader',
                customRenderer: (mod) => {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
                    const { t } = this.props;
                    let name;
                    let avatar;
                    if (this.props.revisionInfo !== undefined) {
                        const revMods = ((_a = this.props.revisionInfo) === null || _a === void 0 ? void 0 : _a.modFiles) || [];
                        const revMod = revMods.find(iter => matchRepo(mod, iter.file));
                        name = ((_b = mod.attributes) === null || _b === void 0 ? void 0 : _b.uploader) || ((_d = (_c = revMod === null || revMod === void 0 ? void 0 : revMod.file) === null || _c === void 0 ? void 0 : _c.owner) === null || _d === void 0 ? void 0 : _d.name);
                        avatar = ((_e = mod.attributes) === null || _e === void 0 ? void 0 : _e.uploaderAvatar)
                            || ((_g = (_f = revMod === null || revMod === void 0 ? void 0 : revMod.file) === null || _f === void 0 ? void 0 : _f.owner) === null || _g === void 0 ? void 0 : _g.avatar);
                    }
                    else if (mod.attributes !== undefined) {
                        name = (_h = mod.attributes) === null || _h === void 0 ? void 0 : _h.uploader;
                        avatar = (_j = mod.attributes) === null || _j === void 0 ? void 0 : _j.uploaderAvatar;
                    }
                    return (React.createElement("div", null,
                        React.createElement(react_bootstrap_1.Image, { circle: true, src: avatar || constants_1.AVATAR_FALLBACK }),
                        name || t(constants_1.AUTHOR_UNKNOWN)));
                },
                calc: mod => { var _a; return ((_a = mod === null || mod === void 0 ? void 0 : mod.attributes) === null || _a === void 0 ? void 0 : _a.author) || this.props.t(constants_1.AUTHOR_UNKNOWN); },
                placement: 'table',
                edit: {},
                isToggleable: false,
                isSortable: true,
            },
            {
                id: 'instructions',
                name: 'Instructions',
                customRenderer: (mod) => {
                    const instructions = this.getModInstructions(mod.id);
                    if (instructions === undefined) {
                        return null;
                    }
                    return (React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'details', tooltip: instructions, "data-modid": mod.id, onClick: this.toggleInstructions }));
                },
                calc: mod => {
                    return this.getModInstructions(mod.id);
                },
                placement: 'table',
                edit: {},
            },
        ];
        props.onAddCallback('viewCollectionTab', (tab) => {
            if (['instructions', 'mods'].includes(tab)) {
                this.nextState.currentTab = tab;
            }
        });
    }
    async componentDidMount() {
        const { collection, userInfo } = this.props;
        const { attributes } = collection !== null && collection !== void 0 ? collection : {};
        const { revisionId, collectionSlug, revisionNumber } = attributes !== null && attributes !== void 0 ? attributes : {};
        if (((revisionId !== undefined) || (collectionSlug !== undefined))
            && (userInfo !== undefined)) {
            const { infoCache } = this.props.driver;
            try {
                await infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber);
            }
            catch (err) {
                (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                    revisionId, collectionSlug, revisionNumber,
                    error: err.message,
                });
            }
        }
        const modsEx = this.initModsEx(this.props);
        this.nextState.modsEx = modsEx;
    }
    async UNSAFE_componentWillReceiveProps(newProps) {
        if ((this.props.mods !== newProps.mods)
            || (this.props.profile !== newProps.profile)
            || (this.props.collection !== newProps.collection)
            || (this.props.downloads !== newProps.downloads)
            || this.installingNotificationsChanged(this.props, newProps)) {
            this.nextState.modsEx = this.updateModsEx(this.props, newProps);
            const { collection } = this.props;
            const { attributes } = collection;
            const { revisionId, collectionSlug, revisionNumber } = attributes !== null && attributes !== void 0 ? attributes : {};
            if ((revisionId !== undefined) || (collectionSlug !== undefined)) {
                try {
                    await this.props.driver.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber);
                }
                catch (err) {
                    (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                        revisionId, collectionSlug, revisionNumber,
                        error: err.message,
                    });
                }
            }
        }
    }
    shouldComponentUpdate(newProps, newState) {
        if ((this.props.mods !== newProps.mods)
            || (this.props.profile !== newProps.profile)
            || (this.props.downloads !== newProps.downloads)
            || (this.props.collection !== newProps.collection)
            || this.installingNotificationsChanged(this.props, newProps)
            || (this.props.activity.mods !== newProps.activity.mods)
            || (this.props.revisionInfo !== newProps.revisionInfo)
            || (this.props.showUpvoteResponse !== newProps.showUpvoteResponse)
            || (this.props.showDownvoteResponse !== newProps.showDownvoteResponse)
            || (this.state.currentTab !== newState.currentTab)
            || (this.state.modSelection !== newState.modSelection)
            || (this.state.modsEx !== newState.modsEx)) {
            return true;
        }
        return false;
    }
    render() {
        var _a, _b, _c, _d;
        const { t, activity, className, collection, collectionInfo, driver, downloads, language, mods, onSuppressVoteResponse, onVoteSuccess, profile, revisionInfo, showUpvoteResponse, showDownvoteResponse, userInfo, votedSuccess } = this.props;
        const { currentTab, modSelection, modsEx } = this.state;
        if (collection === undefined) {
            return null;
        }
        const incomplete = Object.values(modsEx)
            .find(mod => (mod.state !== 'installed')
            && !mod.collectionRule['ignored']
            && (mod.collectionRule.type === 'requires')) !== undefined;
        const totalSize = Object.values(modsEx).reduce((prev, mod) => {
            const size = vortex_api_1.util.getSafe(mod, ['attributes', 'fileSize'], 0);
            return prev + size;
        }, 0);
        if (collection !== undefined) {
            this.mInstalling = incomplete
                && !driver.installDone
                && (((_a = driver.collection) === null || _a === void 0 ? void 0 : _a.id) === (collection === null || collection === void 0 ? void 0 : collection.id));
        }
        else {
            this.mInstalling = undefined;
        }
        const selection = (_d = ((this.mInstalling && (driver.collectionInfo !== undefined))
            ? (_c = (_b = revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.modFiles) === null || _b === void 0 ? void 0 : _b.map) === null || _c === void 0 ? void 0 : _c.call(_b, file => ({ local: undefined, remote: file }))
            : modSelection)) !== null && _d !== void 0 ? _d : [];
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', className: className },
            React.createElement(vortex_api_1.FlexLayout.Fixed, { className: 'collection-overview-panel' }, (selection.length > 0)
                ? (React.createElement(CollectionOverviewSelection_1.default, { t: t, profile: profile, collection: collection, onDeselectMods: this.unselectMods, incomplete: incomplete, modSelection: selection }))
                : (React.createElement(CollectionOverview_1.default, { t: t, language: language, profile: profile, collection: collection, totalSize: totalSize, showUpvoteResponse: showUpvoteResponse, showDownvoteResponse: showDownvoteResponse, revision: this.revisionMerged(collectionInfo, revisionInfo), votedSuccess: votedSuccess, onSetEnabled: this.setEnabled, onShowMods: this.showMods, onClose: this.close, onClone: this.clone, onRemove: this.remove, onVoteSuccess: onVoteSuccess, onSuppressVoteResponse: onSuppressVoteResponse, incomplete: incomplete }))),
            React.createElement(vortex_api_1.FlexLayout.Flex, { className: 'collection-mods-panel' },
                React.createElement(react_bootstrap_1.Tabs, { id: 'collection-view-tabs', activeKey: currentTab, onSelect: this.selectTab, unmountOnExit: true, mountOnEnter: true },
                    React.createElement(react_bootstrap_1.Tab, { key: 'instructions', eventKey: 'instructions', title: t('Instructions') },
                        React.createElement(react_bootstrap_1.Panel, null,
                            React.createElement(react_bootstrap_1.Panel.Body, null,
                                React.createElement(CollectionInstructions_1.default, { t: t, collection: collection, mods: mods, onToggleInstructions: this.toggleInstructions })))),
                    React.createElement(react_bootstrap_1.Tab, { key: 'mods', eventKey: 'mods', title: t('Mods') },
                        React.createElement(react_bootstrap_1.Panel, { ref: this.setTableContainerRef },
                            React.createElement(react_bootstrap_1.Panel.Body, null,
                                React.createElement(vortex_api_1.Table, { tableId: 'collection-mods', showDetails: false, data: modsEx, staticElements: this.mAttributes, actions: this.mModActions, onChangeSelection: this.changeModSelection })))))),
            React.createElement(vortex_api_1.FlexLayout.Fixed, null,
                React.createElement(CollectionProgress_1.default, { t: t, isPremium: userInfo === null || userInfo === void 0 ? void 0 : userInfo.isPremium, mods: modsEx, profile: profile, downloads: downloads, totalSize: totalSize, activity: activity, onCancel: this.cancel, onPause: this.mInstalling ? this.pause : undefined, onResume: this.mInstalling
                        ? undefined
                        : (driver.collection !== undefined) && !driver.installDone
                            ? null
                            : this.resume }))));
    }
    progress(props, mod) {
        var _a;
        const { downloads, notifications } = props;
        if (mod.state === 'downloading') {
            const { received, size } = downloads[mod.archiveId];
            if (!!size) {
                return received / size;
            }
        }
        else if (mod.state === 'installing') {
            const notification = notifications.find(noti => noti.id === 'install_' + mod.id);
            if (notification !== undefined) {
                return ((_a = notification.progress) !== null && _a !== void 0 ? _a : 100) / 100;
            }
            else {
                return 1;
            }
        }
        return 0;
    }
    installingNotificationsChanged(oldProps, newProps) {
        if (oldProps.notifications !== newProps.notifications) {
            const oldInstalling = oldProps.notifications
                .filter(noti => noti.id.startsWith(constants_1.INSTALLING_NOTIFICATION_ID));
            const newInstalling = newProps.notifications
                .filter(noti => noti.id.startsWith(constants_1.INSTALLING_NOTIFICATION_ID));
            return !_.isEqual(oldInstalling, newInstalling);
        }
        else {
            return false;
        }
    }
    updateModsEx(oldProps, newProps) {
        var _a, _b;
        const result = { ...this.state.modsEx };
        const modifiedDownloads = vortex_api_1.util.objDiff(oldProps.downloads, newProps.downloads);
        const modifiedMods = vortex_api_1.util.objDiff(oldProps.mods, newProps.mods);
        const modifiedState = vortex_api_1.util.objDiff((_a = oldProps.profile.modState) !== null && _a !== void 0 ? _a : {}, (_b = newProps.profile.modState) !== null && _b !== void 0 ? _b : {});
        const genRuleMap = (rules) => {
            return (rules || []).reduce((prev, rule) => {
                prev[(0, util_1.modRuleId)(rule)] = rule;
                return prev;
            }, {});
        };
        const modifiedRules = vortex_api_1.util.objDiff(genRuleMap(oldProps.collection.rules), genRuleMap(newProps.collection.rules));
        Object.keys(modifiedDownloads)
            .filter(dlId => dlId.startsWith('-'))
            .forEach(dlId => {
            const refId = Object.keys(result).find(iter => { var _a; return ((_a = result[iter]) === null || _a === void 0 ? void 0 : _a.archiveId) === dlId.slice(1); });
            delete result[refId];
        });
        const invalidateMod = modId => {
            const realId = modId.slice(1);
            const refId = Object.keys(result).find(iter => { var _a; return ((_a = result[iter]) === null || _a === void 0 ? void 0 : _a.id) === realId; });
            delete result[refId];
        };
        Object.keys(modifiedMods)
            .filter(modId => modId.startsWith('-'))
            .forEach(invalidateMod);
        Object.keys(modifiedState)
            .filter(modId => {
            var _a;
            return modId.startsWith('-')
                || ((_a = modifiedState[modId]) === null || _a === void 0 ? void 0 : _a['-enabled']) !== undefined;
        })
            .forEach(invalidateMod);
        const { collection } = newProps;
        (collection.rules || [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type))
            .forEach(rule => {
            const id = (0, util_1.modRuleId)(rule);
            if ((result[id] === undefined) || (modifiedRules[id] !== undefined)) {
                result[id] = this.modFromRule(newProps, rule);
            }
        });
        Object.keys(modifiedRules)
            .forEach(ruleId => {
            if (ruleId.startsWith('-')) {
                delete result[ruleId.slice(1)];
            }
            else if (ruleId.startsWith('+')) {
                result[ruleId.slice(1)] = this.modFromRule(newProps, modifiedRules[ruleId]);
            }
        });
        const { profile } = newProps;
        const { modsEx } = this.state;
        const pendingDL = Object.keys(modsEx).filter(modId => { var _a; return ((_a = modsEx[modId]) === null || _a === void 0 ? void 0 : _a.state) === null; });
        const pendingInstall = Object.keys(modsEx)
            .filter(modId => { var _a; return ['downloading', 'downloaded', null].includes((_a = modsEx[modId]) === null || _a === void 0 ? void 0 : _a.state); });
        const pendingFinish = Object.keys(modsEx)
            .filter(modId => { var _a; return ['installing', 'installed'].includes((_a = modsEx[modId]) === null || _a === void 0 ? void 0 : _a.state); });
        Object.keys(modifiedDownloads)
            .filter(dlId => dlId.startsWith('+'))
            .forEach(dlId => {
            const download = newProps.downloads[dlId.slice(1)];
            const match = pendingDL.find(modId => (0, findModByRef_1.testDownloadReference)(download, modsEx[modId].collectionRule.reference));
            if (match !== undefined) {
                result[match] = this.modFromDownload(dlId.slice(1), download, modsEx[match].collectionRule);
            }
        });
        const updateMod = modId => {
            const realId = modId.startsWith('+') ? modId.slice(1) : modId;
            const mod = newProps.mods[realId];
            if (mod === undefined) {
                return;
            }
            if (mod.state === 'installing') {
                const dlId = mod.archiveId;
                const download = newProps.downloads[dlId];
                const match = pendingInstall.find(iter => (0, findModByRef_1.testDownloadReference)(download, modsEx[iter].collectionRule.reference));
                if (match !== undefined) {
                    result[match] = {
                        ...this.modFromDownload(dlId, download, modsEx[match].collectionRule),
                        id: modId.slice(1),
                        state: 'installing',
                    };
                }
            }
            else {
                const match = pendingFinish.find(iter => vortex_api_1.util.testModReference(mod, modsEx[iter].collectionRule.reference));
                if (match !== undefined) {
                    result[match] = {
                        ...mod,
                        ...(profile.modState || {})[mod.id],
                        collectionRule: modsEx[match].collectionRule,
                    };
                }
            }
        };
        Object.keys(modifiedMods)
            .filter(modId => !modId.startsWith('-')
            && (modId.startsWith('+')
                || (modifiedMods[modId]['+state'] !== undefined)
                || (modifiedMods[modId]['attributes'] !== undefined)))
            .forEach(updateMod);
        Object.keys(modifiedState)
            .filter(modId => { var _a; return ((_a = modifiedState[modId]) === null || _a === void 0 ? void 0 : _a['+enabled']) !== undefined; })
            .forEach(updateMod);
        Object.keys(modifiedDownloads)
            .filter(dlId => !dlId.startsWith('-') && !dlId.startsWith('+'))
            .forEach(dlId => {
            var _a, _b, _c;
            let ruleId = Object.keys(result).find(modId => { var _a; return ((_a = result[modId]) === null || _a === void 0 ? void 0 : _a.archiveId) === dlId; });
            if ((ruleId === undefined)
                && (((_b = (_a = newProps.downloads[dlId]) === null || _a === void 0 ? void 0 : _a.modInfo) === null || _b === void 0 ? void 0 : _b.referenceTag) !== undefined)) {
                ruleId = Object.keys(result).find(id => {
                    var _a, _b;
                    return (((_a = result[id]) === null || _a === void 0 ? void 0 : _a.archiveId) === undefined)
                        && (0, findModByRef_1.testDownloadReference)(newProps.downloads[dlId], (_b = result[id]) === null || _b === void 0 ? void 0 : _b.collectionRule.reference);
                });
                if (ruleId !== undefined) {
                    result[ruleId] = {
                        ...result[ruleId],
                        archiveId: dlId,
                        state: 'downloading',
                    };
                }
            }
            if (ruleId !== undefined) {
                result[ruleId] = {
                    ...result[ruleId],
                    progress: this.progress(newProps, result[ruleId]),
                };
                const dl = newProps.downloads[(_c = result[ruleId]) === null || _c === void 0 ? void 0 : _c.archiveId];
                if (['finished', 'failed'].includes(dl.state) && !pendingFinish.includes(ruleId)) {
                    result[ruleId].state = 'downloaded';
                }
            }
        });
        newProps.notifications.forEach(noti => {
            if ((noti.id !== undefined) && (noti.id.startsWith('install_'))) {
                const modId = noti.id.slice(8);
                const ruleId = Object.keys(result).find(iter => { var _a; return ((_a = result[iter]) === null || _a === void 0 ? void 0 : _a.id) === modId; });
                if (ruleId !== undefined) {
                    result[ruleId] = {
                        ...result[ruleId],
                        progress: this.progress(newProps, result[ruleId]),
                    };
                }
            }
        });
        return result;
    }
    modFromDownload(dlId, download, rule) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6;
        const modId = (_d = (_c = (_b = (_a = download.modInfo) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.details) === null || _c === void 0 ? void 0 : _c.modId) !== null && _d !== void 0 ? _d : (_g = (_f = (_e = download.modInfo) === null || _e === void 0 ? void 0 : _e.nexus) === null || _f === void 0 ? void 0 : _f.ids) === null || _g === void 0 ? void 0 : _g.modId;
        return {
            id: dlId,
            type: '',
            installationPath: undefined,
            archiveId: dlId,
            enabledTime: 0,
            state: download.state === 'finished' ? 'downloaded' : 'downloading',
            enabled: false,
            collectionRule: rule,
            attributes: {
                customFileName: (_h = download === null || download === void 0 ? void 0 : download.modInfo) === null || _h === void 0 ? void 0 : _h.name,
                fileName: (_m = (_l = (_k = (_j = download.modInfo) === null || _j === void 0 ? void 0 : _j.nexus) === null || _k === void 0 ? void 0 : _k.fileInfo) === null || _l === void 0 ? void 0 : _l.name) !== null && _m !== void 0 ? _m : vortex_api_1.util.renderModReference(rule.reference),
                fileSize: (_o = download.size) !== null && _o !== void 0 ? _o : rule.reference.fileSize,
                name: dlId,
                version: (_r = (_q = (_p = download.modInfo) === null || _p === void 0 ? void 0 : _p.nexus) === null || _q === void 0 ? void 0 : _q.fileInfo) === null || _r === void 0 ? void 0 : _r.mod_version,
                author: (_u = (_t = (_s = download.modInfo) === null || _s === void 0 ? void 0 : _s.nexus) === null || _t === void 0 ? void 0 : _t.modInfo) === null || _u === void 0 ? void 0 : _u.author,
                uploader: (_y = (_x = (_w = (_v = download.modInfo) === null || _v === void 0 ? void 0 : _v.nexus) === null || _w === void 0 ? void 0 : _w.modInfo) === null || _x === void 0 ? void 0 : _x.user) === null || _y === void 0 ? void 0 : _y.name,
                uploaderId: (_2 = (_1 = (_0 = (_z = download.modInfo) === null || _z === void 0 ? void 0 : _z.nexus) === null || _0 === void 0 ? void 0 : _0.modInfo) === null || _1 === void 0 ? void 0 : _1.user) === null || _2 === void 0 ? void 0 : _2.id,
                category: (_5 = (_4 = (_3 = download.modInfo) === null || _3 === void 0 ? void 0 : _3.nexus) === null || _4 === void 0 ? void 0 : _4.modInfo) === null || _5 === void 0 ? void 0 : _5.category_id,
                source: ((_6 = download.modInfo) === null || _6 === void 0 ? void 0 : _6.nexus) !== undefined ? 'nexus' : undefined,
                modId,
                downloadGame: Array.isArray(download.game) ? download.game[0] : download.game,
            },
        };
    }
    modFromRule(props, rule) {
        var _a, _b;
        const { downloads, mods, profile } = props;
        const mod = vortex_api_1.util.findModByRef(rule.reference, mods);
        if (mod !== undefined) {
            return {
                ...mods[mod.id],
                ...(_a = profile.modState) === null || _a === void 0 ? void 0 : _a[mod.id],
                collectionRule: rule,
            };
        }
        else {
            const dlId = vortex_api_1.util.findDownloadByRef(rule.reference, downloads);
            if (dlId !== undefined) {
                return this.modFromDownload(dlId, downloads[dlId], rule);
            }
            else {
                const name = vortex_api_1.util.renderModReference(rule.reference, undefined);
                return {
                    id: name,
                    state: null,
                    type: '',
                    installationPath: undefined,
                    enabledTime: 0,
                    attributes: {
                        fileSize: rule.reference.fileSize,
                        ...(rule.extra || {}),
                        fileName: (_b = rule.extra) === null || _b === void 0 ? void 0 : _b.name,
                    },
                    enabled: false,
                    collectionRule: rule,
                };
            }
        }
    }
    initModsEx(props) {
        var _a;
        const { collection } = props;
        return ((_a = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type))
            .reduce((prev, rule) => {
            const id = (0, util_1.modRuleId)(rule);
            prev[id] = this.modFromRule(props, rule);
            return prev;
        }, {});
    }
}
function mapStateToProps(state, ownProps) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { nexus } = state.persistent;
    const { collection } = ownProps;
    let votedSuccess;
    let revisionInfo;
    let collectionInfo;
    if (((_a = collection === null || collection === void 0 ? void 0 : collection.attributes) === null || _a === void 0 ? void 0 : _a.revisionId) !== undefined) {
        revisionInfo =
            (_c = (_b = state.persistent.collections.revisions) === null || _b === void 0 ? void 0 : _b[collection.attributes.revisionId]) === null || _c === void 0 ? void 0 : _c.info;
        if ((revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.collection) !== undefined) {
            collectionInfo =
                (_e = (_d = state.persistent.collections.collections) === null || _d === void 0 ? void 0 : _d[revisionInfo.collection.id]) === null || _e === void 0 ? void 0 : _e.info;
        }
        votedSuccess = (_g = (_f = revisionInfo === null || revisionInfo === void 0 ? void 0 : revisionInfo.metadata) === null || _f === void 0 ? void 0 : _f.ratingValue) !== null && _g !== void 0 ? _g : 'abstained';
    }
    return {
        userInfo: nexus.userInfo,
        votedSuccess,
        activity: state.session.base.activity,
        language: state.settings.interface.language,
        overlays: state.session.overlays.overlays,
        collectionInfo,
        revisionInfo,
        showUpvoteResponse: (_h = state.settings.interface.usage['collection-upvote-response-dialog']) !== null && _h !== void 0 ? _h : true,
        showDownvoteResponse: (_j = state.settings.interface.usage['collection-downvote-response-dialog']) !== null && _j !== void 0 ? _j : true,
    };
}
function mapDispatchToProps(dispatch) {
    return {
        onSetModEnabled: (profileId, modId, enable) => dispatch(vortex_api_1.actions.setModEnabled(profileId, modId, enable)),
        onSetAttributeFilter: (tableId, filterId, filterValue) => dispatch(vortex_api_1.actions.setAttributeFilter(tableId, filterId, filterValue)),
        onRemoveRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.removeModRule(gameId, modId, rule)),
        onShowError: (message, details, allowReport) => vortex_api_1.util.showError(dispatch, message, details, { allowReport }),
        onSuppressVoteResponse: (response) => dispatch(vortex_api_1.actions.showUsageInstruction(`collection-${response}-response-dialog`, false)),
    };
}
exports["default"] = (0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(CollectionPage);


/***/ }),

/***/ "./src/views/CollectionReleaseStatus.tsx":
/*!***********************************************!*\
  !*** ./src/views/CollectionReleaseStatus.tsx ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function CollectionReleaseStatus(props) {
    const { t, active, collection, enabled, incomplete } = props;
    if (active) {
        if (incomplete) {
            return React.createElement("div", { className: 'collection-status incomplete' }, t('Incomplete'));
        }
        else if ((vortex_api_1.util.getSafe(collection.attributes, ['collectionId'], undefined) !== undefined)
            && vortex_api_1.util.getSafe(collection.attributes, ['editable'], false)) {
            return React.createElement("div", { className: 'collection-status published' }, t('Published'));
        }
        else if (enabled) {
            return React.createElement("div", { className: 'collection-status enabled' }, t('Enabled'));
        }
        else {
            return React.createElement("div", { className: 'collection-status disabled' }, t('Disabled'));
        }
    }
    else {
        return null;
    }
}
exports["default"] = CollectionReleaseStatus;


/***/ }),

/***/ "./src/views/CollectionTile/NewRevisionMarker.tsx":
/*!********************************************************!*\
  !*** ./src/views/CollectionTile/NewRevisionMarker.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function NewRevisionMarker(props) {
    var _a, _b, _c;
    const { t, collection, updating } = props;
    if ((((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a['newestVersion']) === undefined)
        || (parseInt((_b = collection.attributes) === null || _b === void 0 ? void 0 : _b['newestVersion'], 10)
            <= parseInt((_c = collection.attributes) === null || _c === void 0 ? void 0 : _c['version'], 10))) {
        return null;
    }
    return (React.createElement("div", { className: 'collections-new-revision' },
        React.createElement(vortex_api_1.Icon, { name: updating ? 'spinner_new' : 'details' }),
        t('Update')));
}
exports["default"] = NewRevisionMarker;


/***/ }),

/***/ "./src/views/CollectionTile/RemoteTile.tsx":
/*!*************************************************!*\
  !*** ./src/views/CollectionTile/RemoteTile.tsx ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function HoverMenu(props) {
    const { t, added, incomplete, revision, onCloneCollection, onInstallCollection, onResumeCollection, } = props;
    const installOwnCollection = React.useCallback(() => {
        if (added !== undefined) {
            onResumeCollection(added.id);
        }
        else {
            onInstallCollection(revision);
        }
    }, [added, revision, onInstallCollection, onResumeCollection]);
    const cloneOwnCollection = React.useCallback(() => {
        onCloneCollection(added.id);
    }, [onCloneCollection, added]);
    const staticElements = [];
    if ((added !== undefined) && !incomplete) {
        staticElements.push({
            title: 'Edit (Requires clone)',
            icon: 'edit',
            action: () => cloneOwnCollection(),
        });
    }
    else {
        staticElements.push({
            title: 'Install',
            icon: 'install',
            action: () => installOwnCollection(),
        }, {
            title: 'Edit',
            icon: 'edit',
            condition: (instanceId, data) => t('Your collection must be installed first and then cloned to make edits.'),
            action: () => {
            },
        });
    }
    staticElements.push();
    return (React.createElement("div", { className: 'thumbnail-hover-menu' },
        React.createElement("div", { key: 'primary-buttons', className: 'hover-content' },
            React.createElement(vortex_api_1.IconBar, { t: t, id: `collection-thumbnail-${revision.collection.slug}`, className: 'buttons', group: 'collection-actions', instanceId: revision.collection.slug, staticElements: staticElements, collapse: false, buttonType: 'both', orientation: 'vertical', clickAnywhere: true }))));
}
function RemoteTile(props) {
    var _a;
    const { t, revision, onCloneCollection, onInstallCollection, onResumeCollection } = props;
    const classes = ['collection-thumbnail', 'collection-remote'];
    const images = [];
    if (!!((_a = revision.collection.tileImage) === null || _a === void 0 ? void 0 : _a.url)) {
        images.push(revision.collection.tileImage.url);
    }
    images.push(path.join(__dirname, 'fallback_tile.png'));
    return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' ') },
        React.createElement(react_bootstrap_1.Panel.Body, { className: 'collection-thumbnail-body' },
            React.createElement(vortex_api_1.Image, { className: 'thumbnail-img', srcs: images, circle: false }),
            React.createElement("div", { className: 'bottom' },
                React.createElement("div", { className: 'collection-revision-and-rating' },
                    React.createElement("div", { className: 'revision-number' }, t('Revision {{number}}', {
                        replace: {
                            number: revision.revisionNumber,
                        }
                    })),
                    React.createElement("div", { className: classes.join(' ') },
                        React.createElement(vortex_api_1.Icon, { name: 'health' }),
                        t('{{rating}}%', { replace: { rating: revision.rating.average } }))),
                React.createElement("div", { className: 'name no-hover' }, revision.collection.name),
                React.createElement("div", { className: 'details' },
                    React.createElement("div", { className: 'author' }, t('By {{uploader}}', {
                        replace: {
                            uploader: revision.collection.user.name,
                        },
                    })),
                    React.createElement("div", null,
                        React.createElement(vortex_api_1.Icon, { name: 'mods' }),
                        revision.modFiles.length))),
            React.createElement(HoverMenu, { t: t, revision: revision, added: props.added, incomplete: props.incomplete, onInstallCollection: onInstallCollection, onCloneCollection: onCloneCollection, onResumeCollection: onResumeCollection }))));
}
exports["default"] = RemoteTile;


/***/ }),

/***/ "./src/views/CollectionTile/SuccessRating.tsx":
/*!****************************************************!*\
  !*** ./src/views/CollectionTile/SuccessRating.tsx ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuccessRating = void 0;
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function SuccessRating(props) {
    const { t, collectionSlug, infoCache, revisionNumber, revisionId } = props;
    const [rating, setRating] = React.useState(undefined);
    React.useEffect(() => {
        (async () => {
            var _a, _b;
            try {
                const rev = await infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber);
                if (((_b = (_a = rev === null || rev === void 0 ? void 0 : rev.rating) === null || _a === void 0 ? void 0 : _a.total) !== null && _b !== void 0 ? _b : 0) < 3) {
                    setRating(undefined);
                }
                else {
                    setRating(rev.rating.average);
                }
            }
            catch (err) {
                (0, vortex_api_1.log)('error', 'failed to get remote info for revision', {
                    revisionId, collectionSlug, revisionNumber,
                    error: err.message,
                });
            }
        })();
    }, [revisionId]);
    const classes = [
        'collection-success-indicator',
    ];
    if (rating === undefined) {
        classes.push('success-rating-insufficient');
    }
    else if (rating < 50) {
        classes.push('success-rating-bad');
    }
    else if (rating < 75) {
        classes.push('success-rating-dubious');
    }
    else {
        classes.push('success-rating-good');
    }
    return (React.createElement("div", { className: classes.join(' ') },
        React.createElement(vortex_api_1.Icon, { name: 'health' }),
        (rating === undefined)
            ? t('Awaiting')
            : t('{{rating}}%', { replace: { rating } })));
}
exports.SuccessRating = SuccessRating;


/***/ }),

/***/ "./src/views/CollectionTile/index.tsx":
/*!********************************************!*\
  !*** ./src/views/CollectionTile/index.tsx ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const CollectionReleaseStatus_1 = __webpack_require__(/*! ../CollectionReleaseStatus */ "./src/views/CollectionReleaseStatus.tsx");
const NewRevisionMarker_1 = __webpack_require__(/*! ./NewRevisionMarker */ "./src/views/CollectionTile/NewRevisionMarker.tsx");
const SuccessRating_1 = __webpack_require__(/*! ./SuccessRating */ "./src/views/CollectionTile/SuccessRating.tsx");
function ModNameField(props) {
    const { t, name, onChange } = props;
    const [editing, setEditing] = React.useState(false);
    const [tempName, setTempName] = React.useState(name);
    const changeInput = React.useCallback((evt) => {
        setTempName(evt.currentTarget.value.slice(0, constants_1.MAX_COLLECTION_NAME_LENGTH));
    }, [setTempName]);
    const validationState = React.useCallback(() => {
        if ((tempName.length < constants_1.MIN_COLLECTION_NAME_LENGTH)
            || (tempName.length > constants_1.MAX_COLLECTION_NAME_LENGTH)) {
            return 'error';
        }
        else {
            return 'success';
        }
    }, [tempName]);
    const apply = React.useCallback(() => {
        if (validationState() === 'success') {
            onChange(tempName);
            setEditing(false);
        }
    }, [setEditing, tempName]);
    const keyPress = React.useCallback((evt) => {
        if (evt.key === 'Enter') {
            apply();
        }
    }, [apply]);
    const startEdit = React.useCallback(() => {
        setEditing(true);
    }, [setEditing]);
    return (React.createElement("div", { className: `collection-name ${editing ? 'editing' : 'displaying'}` }, editing ? (React.createElement(React.Fragment, null,
        React.createElement(react_bootstrap_1.FormGroup, { controlId: 'formBasicText', validationState: validationState() },
            React.createElement(react_bootstrap_1.FormControl, { type: 'text', value: tempName, placeholder: t('Collection Name'), onChange: changeInput, autoFocus: true, onKeyPress: keyPress })),
        React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'input-confirm', tooltip: t('Save name'), onClick: apply }))) : (React.createElement(React.Fragment, null,
        React.createElement("div", { className: 'name' }, tempName),
        React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'edit', tooltip: t('Change name'), onClick: startEdit })))));
}
class CollectionThumbnail extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.imageURLs = (0, memoize_one_1.default)((collection) => {
            var _a;
            return [(_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.pictureUrl, path.join(__dirname, 'fallback_tile.png')]
                .filter(iter => iter !== undefined);
        });
        this.changeName = (name) => {
            const { collection, onSetModAttribute, profile } = this.props;
            onSetModAttribute(profile.gameId, collection.id, 'customFileName', name);
        };
        this.initState({
            updating: false
        });
    }
    render() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const { t, collection, details, infoCache, incomplete, mods, onEdit, profile, forceRevisionDisplay } = this.props;
        if (collection === undefined) {
            return null;
        }
        const active = vortex_api_1.util.getSafe(profile, ['modState', collection.id, 'enabled'], false);
        const refMods = ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => ['requires', 'recommends'].includes(rule.type));
        const totalSize = Object.values((_b = collection.rules) !== null && _b !== void 0 ? _b : []).reduce((prev, rule) => {
            var _a, _b, _c;
            if (rule.reference.fileSize !== undefined) {
                return prev + rule.reference.fileSize;
            }
            else if ((rule.reference.id !== undefined) && (mods !== undefined)) {
                return prev + ((_c = (_b = (_a = mods[rule.reference.id]) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.fileSize) !== null && _c !== void 0 ? _c : 0);
            }
            else {
                return prev;
            }
        }, 0);
        const classes = ['collection-thumbnail'];
        const hasMenu = (this.actions.length > 0);
        if (this.props.className !== undefined) {
            classes.push(this.props.className);
        }
        if (hasMenu) {
            classes.push('has-menu');
        }
        const { revisionId, collectionSlug, revisionNumber } = (_c = collection.attributes) !== null && _c !== void 0 ? _c : {};
        const validRemote = (revisionId !== undefined)
            && (collectionSlug !== undefined)
            && (revisionNumber !== undefined);
        return (React.createElement(react_bootstrap_1.Panel, { className: classes.join(' '), bsStyle: active ? 'primary' : 'default' },
            React.createElement(react_bootstrap_1.Panel.Body, { className: 'collection-thumbnail-body' },
                (details === true)
                    ? React.createElement(NewRevisionMarker_1.default, { t: t, collection: collection, updating: this.state.updating })
                    : null,
                React.createElement(vortex_api_1.Image, { className: 'thumbnail-img', srcs: this.imageURLs(collection), circle: false }),
                (details !== false) ? React.createElement("div", { className: 'gradient' }) : null,
                (details !== false) ? (React.createElement("div", { className: `bottom ${onEdit !== undefined ? 'editable' : ''}` },
                    React.createElement(CollectionReleaseStatus_1.default, { t: t, active: active, enabled: (_f = (_e = (_d = profile === null || profile === void 0 ? void 0 : profile.modState) === null || _d === void 0 ? void 0 : _d[collection.id]) === null || _e === void 0 ? void 0 : _e.enabled) !== null && _f !== void 0 ? _f : false, collection: collection, incomplete: incomplete }),
                    React.createElement("div", { className: 'collection-revision-and-rating' },
                        React.createElement("div", { className: 'revision-number' }, t('Revision {{number}}{{forceRevision}}', { replace: {
                                number: (_h = (_g = collection.attributes) === null || _g === void 0 ? void 0 : _g.version) !== null && _h !== void 0 ? _h : '0',
                                forceRevision: forceRevisionDisplay === undefined ? '' : ' ➔ ' + forceRevisionDisplay,
                            } })),
                        (infoCache !== undefined) && validRemote
                            ? React.createElement(SuccessRating_1.SuccessRating, { t: t, infoCache: infoCache, collectionSlug: collectionSlug, revisionNumber: revisionNumber, revisionId: revisionId })
                            : null),
                    React.createElement("div", { className: 'name no-hover' }, vortex_api_1.util.renderModName(collection, { version: false })),
                    onEdit !== undefined ? (React.createElement("div", { className: 'hover' },
                        React.createElement(ModNameField, { t: t, name: vortex_api_1.util.renderModName(collection, { version: false }), onChange: this.changeName }))) : null,
                    React.createElement("div", { className: 'details' },
                        React.createElement("div", { className: 'author' }, t('By {{uploader}}', { replace: {
                                uploader: (_k = (_j = collection.attributes) === null || _j === void 0 ? void 0 : _j.uploader) !== null && _k !== void 0 ? _k : t(constants_1.AUTHOR_UNKNOWN)
                            },
                        })),
                        React.createElement("div", null,
                            React.createElement(vortex_api_1.Icon, { name: 'mods' }),
                            refMods.length)))) : null,
                hasMenu ? (React.createElement("div", { className: 'thumbnail-hover-menu' }, this.renderMenu(refMods, totalSize))) : null)));
    }
    invoke(action, inst) {
        if ((action !== undefined) && (inst !== undefined) && (inst.length > 0)) {
            return action(inst[0]);
        }
    }
    get actions() {
        var _a;
        const { t, collection, incomplete, installing, onEdit, onPause, onUpload, onRemove, onResume, onUpdate, onView } = this.props;
        const result = [];
        if (onUpdate) {
            result.push({
                title: 'Update',
                icon: 'auto-update',
                group: 'optional',
                condition: () => {
                    const { attributes } = this.props.collection;
                    if (this.state.updating) {
                        return t('Already updating');
                    }
                    return ((attributes === null || attributes === void 0 ? void 0 : attributes.newestVersion) !== undefined)
                        && (parseInt(attributes.newestVersion, 10) > parseInt(attributes.version, 10));
                },
                action: (instanceIds) => {
                    const prom = this.invoke(onUpdate, instanceIds);
                    if (prom !== undefined) {
                        this.nextState.updating = true;
                        prom
                            .catch(err => {
                            if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                                this.context.api.showErrorNotification('Failed to update collection', err);
                            }
                        })
                            .finally(() => {
                            this.nextState.updating = false;
                        });
                    }
                },
            });
        }
        if (onView) {
            result.push({
                title: 'View',
                icon: 'show',
                action: (instanceIds) => {
                    this.invoke(onView, instanceIds);
                },
            });
            if (incomplete && (onResume !== undefined)) {
                result.push({
                    title: 'Resume',
                    icon: 'resume',
                    condition: () => {
                        if (installing === undefined) {
                            return true;
                        }
                        return (installing.id === collection.id)
                            ? false
                            : t('Another collection is being installed');
                    },
                    action: (instanceIds) => {
                        if (onResume !== undefined) {
                            this.invoke(onResume, instanceIds);
                        }
                        this.invoke(onView, instanceIds);
                    },
                });
            }
            if (incomplete && (onPause !== undefined)) {
                result.push({
                    title: 'Pause',
                    icon: 'pause',
                    condition: () => (installing === null || installing === void 0 ? void 0 : installing.id) === collection.id,
                    action: (instanceIds) => {
                        this.invoke(onPause, instanceIds);
                        this.invoke(onView, instanceIds);
                    },
                });
            }
        }
        if (onEdit) {
            result.push({
                title: 'Edit',
                icon: 'edit',
                action: (instanceIds) => this.invoke(onEdit, instanceIds),
            });
        }
        if (onRemove) {
            result.push({
                title: 'Remove',
                icon: 'remove',
                action: (instanceIds) => this.invoke(onRemove, instanceIds),
            });
        }
        if (onUpload) {
            const nextRev = (_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.revisionNumber;
            result.push({
                title: t(nextRev !== undefined ? 'Upload Update' : 'Upload New'),
                icon: 'upload',
                action: (instanceIds) => this.invoke(onUpload, instanceIds),
                condition: () => {
                    var _a;
                    const refMods = ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
                        .filter(rule => ['requires', 'recommends'].includes(rule.type));
                    if (refMods.length === 0) {
                        return (this.props.t('Can\'t upload an empty collection'));
                    }
                    else {
                        return true;
                    }
                },
            });
        }
        return result;
    }
    renderMenu(refMods, totalSize) {
        const { t, collection } = this.props;
        return [(React.createElement("div", { key: 'primary-buttons', className: 'hover-content' },
                React.createElement(vortex_api_1.IconBar, { id: `collection-thumbnail-${collection.id}`, className: 'buttons', group: 'collection-actions', instanceId: collection.id, staticElements: this.actions, collapse: false, buttonType: 'both', orientation: 'vertical', clickAnywhere: true, t: t })))];
    }
}
const emptyObj = {};
function mapStateToProps(state, ownProps) {
    return {
        profile: vortex_api_1.selectors.activeProfile(state),
    };
}
function mapDispatchToProps(dispatch) {
    return {
        onSetModAttribute: (gameId, modId, key, value) => dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, key, value)),
    };
}
exports["default"] = (0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(CollectionThumbnail);


/***/ }),

/***/ "./src/views/IniTweaks.tsx":
/*!*********************************!*\
  !*** ./src/views/IniTweaks.tsx ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
class Tweak extends vortex_api_1.PureComponentEx {
    constructor() {
        super(...arguments);
        this.mStatusActions = [
            {
                icon: 'toggle-enabled',
                title: 'Enabled',
                action: () => this.disable(),
                condition: () => this.props.enabled,
            },
            {
                icon: 'toggle-disabled',
                title: 'Disabled',
                action: () => this.enable(),
                condition: () => !this.props.enabled,
            },
            {
                icon: 'delete',
                title: 'Remove',
                action: () => this.remove(),
            },
        ];
        this.edit = () => {
            const { tweaksPath, fileName } = this.props;
            vortex_api_1.util.opn(path.join(tweaksPath, fileName)).catch(() => null);
        };
        this.enable = () => {
            this.toggle(true);
        };
        this.disable = () => {
            this.toggle(false);
        };
        this.remove = () => {
            const { fileName, onRemoveTweak } = this.props;
            onRemoveTweak({ fileName });
        };
        this.toggle = (enabled) => {
            const { fileName, onToggle } = this.props;
            onToggle(fileName, enabled);
        };
    }
    render() {
        const { t, fileName } = this.props;
        const match = fileName.match(/(.*)\[(.*)\]\.ini/);
        if (!match || (match.length < 3)) {
            return null;
        }
        return (React.createElement("tr", null,
            React.createElement("td", { className: 'cell-status' }, this.renderStatusActions()),
            React.createElement("td", { className: 'cell-tweak-name' }, match[1]),
            React.createElement("td", { className: 'cell-filename' }, `${match[2]}.ini`),
            React.createElement("td", { className: 'cell-edit' },
                React.createElement("a", { onClick: this.edit },
                    React.createElement(vortex_api_1.Icon, { name: 'edit' })))));
    }
    renderStatusActions() {
        const { t } = this.props;
        return (React.createElement(vortex_api_1.ActionDropdown, { t: t, buttonType: 'text', staticElements: this.mStatusActions, className: 'collections-ini-tweaks-actions' }));
    }
}
class TweakList extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.addIniTweak = () => {
            const { collection, modsPath, onAddIniTweak, settingsFiles } = this.props;
            if ((collection === null || collection === void 0 ? void 0 : collection.installationPath) && modsPath) {
                const modPath = path.join(modsPath, collection.installationPath);
                onAddIniTweak(modPath, settingsFiles)
                    .then(() => this.refreshTweaks());
            }
        };
        this.refreshTweaks = () => {
            const { collection, modsPath, onRefreshTweaks } = this.props;
            if ((collection === null || collection === void 0 ? void 0 : collection.installationPath) && modsPath) {
                const modPath = path.join(modsPath, collection.installationPath);
                onRefreshTweaks(modPath).then((newTweaks) => this.nextState.tweaks = newTweaks);
            }
        };
        this.renderTweak = (tweak) => {
            const { t, collection, modsPath } = this.props;
            const { fileName } = tweak;
            const isEnabled = vortex_api_1.util.getSafe(collection, ['enabledINITweaks'], []).indexOf(fileName) !== -1;
            return (React.createElement(Tweak, { t: t, key: `tweak-${fileName}`, tweaksPath: path.join(modsPath, collection.installationPath, constants_1.INI_TWEAKS_PATH), fileName: fileName, enabled: isEnabled, onToggle: this.toggle, onRemoveTweak: this.removeTweak }));
        };
        this.removeTweak = (tweak) => {
            const { collection, modsPath, onRemoveIniTweak } = this.props;
            if ((collection === null || collection === void 0 ? void 0 : collection.installationPath) && modsPath) {
                const modPath = path.join(modsPath, collection.installationPath);
                onRemoveIniTweak(modPath, tweak)
                    .then(() => this.refreshTweaks());
            }
        };
        this.toggle = (fileName, enabled) => {
            const { collection, gameId, onSetINITweakEnabled } = this.props;
            onSetINITweakEnabled(gameId, collection.id, fileName, enabled);
        };
        this.initState({
            tweaks: [],
        });
    }
    componentDidMount() {
        this.refreshTweaks();
    }
    render() {
        const { t, collection } = this.props;
        const { tweaks } = this.state;
        if (collection === undefined) {
            return null;
        }
        return (React.createElement(vortex_api_1.FlexLayout, { type: 'column', className: 'ini-tweaks-container' },
            React.createElement(react_bootstrap_1.ControlLabel, null,
                React.createElement("p", null, t('This screen lets you set up tweaks for the game ini file that will be applied '
                    + 'to a user\'s setup when they use your collection.')),
                React.createElement("p", null, t('Users can toggle these ini tweaks individually so you may want to set up '
                    + 'multiple tweaks to give users granular control.'))),
            React.createElement(vortex_api_1.FlexLayout.Flex, null,
                React.createElement("div", { id: 'collection-initweaks-table-panel' },
                    React.createElement(react_bootstrap_1.Table, { id: 'collection-initweaks-table' },
                        React.createElement("thead", null,
                            React.createElement("tr", null,
                                React.createElement("th", { className: 'header-status' }, t('Status')),
                                React.createElement("th", { className: 'header-tweak-name' }, t('Tweak Name')),
                                React.createElement("th", { className: 'header-filename' }, t('Ini File')),
                                React.createElement("th", { className: 'header-edit' },
                                    t('Edit'),
                                    React.createElement(vortex_api_1.More, { id: 'edit-ini-file', name: t('Edit Ini File') }, t('"Edit" allows you to input the ini tweak you want to '
                                        + 'apply to the target ini file. Please provide the section as '
                                        + 'well as your tweak(s). e.g.:\n\n[General]\nsIntroSequence=0'))))),
                        React.createElement("tbody", null, tweaks.map(tweak => this.renderTweak(tweak)))),
                    React.createElement(react_bootstrap_1.Button, { onClick: this.addIniTweak }, t('Add')))),
            React.createElement(vortex_api_1.Usage, { infoId: 'ini-tweaks' },
                React.createElement("p", null, t('To assist in the testing of INI configuration application - any enabled INI modification '
                    + 'on this page will be applied to your own environment in the next deployment event; IF '
                    + 'the collection mod is enabled.')),
                React.createElement("p", null, t('To disable/enable an INI tweak, simply click on the button itself (in the status column). '
                    + 'If needed, INI tweak can be removed by clicking the arrow next to the button and selecting "Remove"')))));
    }
}
function mapStateToProps(state, ownProps) {
    return {
        modsPath: vortex_api_1.selectors.installPath(state),
    };
}
function mapDispatchToProps(dispatch) {
    return {
        onSetINITweakEnabled: (gameId, modId, tweak, enabled) => {
            dispatch(vortex_api_1.actions.setINITweakEnabled(gameId, modId, tweak, enabled));
        },
    };
}
const TweakListConnected = (0, react_i18next_1.withTranslation)([constants_1.NAMESPACE, 'common'])((0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(TweakList));
exports["default"] = TweakListConnected;


/***/ }),

/***/ "./src/views/InstallDialog/InstallChangelogDialog.tsx":
/*!************************************************************!*\
  !*** ./src/views/InstallDialog/InstallChangelogDialog.tsx ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InstallChangelogDialog = void 0;
const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_markdown_1 = __webpack_require__(/*! react-markdown */ "./node_modules/react-markdown/index.js");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
function nop() {
}
function InstallChangelogDialogImpl(props) {
    const { collection, gameId, onCancel, onContinue, revisionInfo } = props;
    const { t } = (0, react_i18next_1.useTranslation)();
    const lang = (0, react_redux_1.useSelector)(state => state.settings.interface.language);
    const context = React.useContext(vortex_api_1.MainContext);
    const openUrl = React.useCallback(() => {
        context.api.events.emit('analytics-track-click-event', 'Collections', 'View on site Updated Collection');
        vortex_api_1.util.opn(vortex_api_1.util.nexusModsURL([revisionInfo.collection.game.domainName, 'collections', revisionInfo.collection.slug], {
            campaign: vortex_api_1.util.Campaign.ViewCollection,
            section: vortex_api_1.util.Section.Collections,
        }));
    }, [collection]);
    if (collection === undefined) {
        return null;
    }
    const changelog = revisionInfo.collectionChangelog;
    const changelogDate = new Date(changelog.createdAt);
    return (React.createElement(react_bootstrap_1.Modal, { id: 'install-changelog-dialog', show: collection !== undefined, onHide: nop },
        React.createElement(react_bootstrap_1.Modal.Header, null,
            React.createElement(react_bootstrap_1.Modal.Title, null, t('{{collectionName}} update', { replace: { collectionName: vortex_api_1.util.renderModName(collection) } }))),
        React.createElement(react_bootstrap_1.Modal.Body, null,
            React.createElement(react_bootstrap_1.Media.Left, null,
                React.createElement(CollectionTile_1.default, { t: t, gameId: gameId, collection: collection, details: 'some', imageTime: 42, forceRevisionDisplay: revisionInfo.revisionNumber })),
            React.createElement(react_bootstrap_1.Media.Right, null,
                React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                    React.createElement("h4", null, t('Revision {{revNum}} Changelog', { replace: { revNum: revisionInfo.revisionNumber } })),
                    React.createElement("div", { className: 'changelog-time' }, changelogDate.toLocaleDateString(lang))),
                React.createElement("div", { className: 'changelog-scroll' },
                    React.createElement(react_markdown_1.default, null, changelog.description))),
            React.createElement(vortex_api_1.tooltip.IconButton, { className: 'collection-open-button', icon: 'open-in-browser', tooltip: t('Open Page'), onClick: openUrl }, t('View Collection'))),
        React.createElement(react_bootstrap_1.Modal.Footer, null,
            React.createElement(react_bootstrap_1.Button, { onClick: onCancel }, t('Later')),
            React.createElement(react_bootstrap_1.Button, { onClick: onContinue }, t('Download Update')))));
}
const localState = vortex_api_1.util.makeReactive({
    job: {
        collection: undefined,
        gameId: undefined,
        onCancel: () => {
        },
        onContinue: () => {
        },
        revisionInfo: undefined,
    },
});
class InstallChangelogDialog extends React.Component {
    componentDidMount() {
        var _a;
        (_a = localState['attach']) === null || _a === void 0 ? void 0 : _a.call(localState, this);
    }
    componentWillUnmount() {
        var _a;
        (_a = localState['detach']) === null || _a === void 0 ? void 0 : _a.call(localState, this);
    }
    render() {
        const { job } = localState;
        return (React.createElement(InstallChangelogDialogImpl, { collection: job === null || job === void 0 ? void 0 : job.collection, gameId: job === null || job === void 0 ? void 0 : job.gameId, revisionInfo: job === null || job === void 0 ? void 0 : job.revisionInfo, onContinue: job === null || job === void 0 ? void 0 : job.onContinue, onCancel: job === null || job === void 0 ? void 0 : job.onCancel }));
    }
}
exports.InstallChangelogDialog = InstallChangelogDialog;
function showChangelog(collection, gameId, revisionInfo) {
    return new Promise((resolve, reject) => {
        localState.job = {
            collection,
            gameId,
            revisionInfo,
            onContinue: () => {
                localState.job = undefined;
                resolve();
            },
            onCancel: () => {
                localState.job = undefined;
                reject(new vortex_api_1.util.UserCanceled());
            },
        };
    });
}
exports["default"] = showChangelog;


/***/ }),

/***/ "./src/views/InstallDialog/InstallFinishedDialog.tsx":
/*!***********************************************************!*\
  !*** ./src/views/InstallDialog/InstallFinishedDialog.tsx ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const YouCuratedThisTag_1 = __webpack_require__(/*! ./YouCuratedThisTag */ "./src/views/InstallDialog/YouCuratedThisTag.tsx");
const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
function nop() {
}
const emptyObject = {};
function InstallFinishedDialog(props) {
    var _a, _b, _c, _d, _e, _f;
    const { api, driver, onClone } = props;
    const { t } = (0, react_i18next_1.useTranslation)(api.NAMESPACE);
    const userInfo = (0, react_redux_1.useSelector)(state => { var _a, _b; return (_b = (_a = state.persistent['nexus']) === null || _a === void 0 ? void 0 : _a.userInfo) !== null && _b !== void 0 ? _b : emptyObject; });
    const forceUpdate = React.useState(0)[1];
    React.useEffect(() => {
        driver.onUpdate(() => {
            if (((driver === null || driver === void 0 ? void 0 : driver.collection) !== undefined) && ((driver === null || driver === void 0 ? void 0 : driver.step) === 'review')) {
                forceUpdate(i => i + 1);
            }
        });
    }, [driver, forceUpdate]);
    const skip = React.useCallback(async () => {
        if (driver.collection !== undefined) {
            await driver.continue();
        }
        forceUpdate(i => i + 1);
    }, [driver]);
    const showOptionals = React.useCallback(async () => {
        if (driver.collection !== undefined) {
            api.events.emit('view-collection', driver.collection.id, 'mods');
            api.store.dispatch(vortex_api_1.actions.setAttributeFilter('collection-mods', undefined, undefined));
            api.store.dispatch(vortex_api_1.actions.setAttributeFilter('collection-mods', 'required', false));
            await driver.continue();
        }
        forceUpdate(i => i + 1);
    }, [driver]);
    const installAllOptionals = React.useCallback(() => {
        if ((driver.step === 'review') && (driver.collection !== undefined)) {
            driver.installRecommended();
        }
        forceUpdate(i => i + 1);
    }, []);
    const clone = React.useCallback(async () => {
        if (driver.collection === undefined) {
            return;
        }
        const id = await onClone(driver.collection.id);
        if (id !== undefined) {
            props.editCollection(id);
            driver.continue();
        }
    }, [driver, onClone]);
    const collection = driver.collection;
    const mods = (0, react_redux_1.useSelector)(state => {
        var _a;
        return (driver.profile !== undefined)
            ? state.persistent.mods[(_a = driver.profile) === null || _a === void 0 ? void 0 : _a.gameId]
            : emptyObject;
    });
    const optionals = React.useMemo(() => {
        var _a;
        return ((_a = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _a !== void 0 ? _a : [])
            .filter(rule => (rule.type === 'recommends')
            && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined));
    }, [collection === null || collection === void 0 ? void 0 : collection.rules, mods]);
    const game = driver.profile !== undefined ? vortex_api_1.util.getGame(driver.profile.gameId) : undefined;
    const ownCollection = ((_b = (_a = driver.collectionInfo) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.memberId) === (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId);
    return (React.createElement(vortex_api_1.Modal, { id: 'install-finished-dialog', show: (driver.collection !== undefined) && (driver.step === 'review'), onHide: nop },
        React.createElement(vortex_api_1.Modal.Header, null,
            React.createElement(vortex_api_1.Modal.Title, null, t('Collection installation complete'))),
        React.createElement(vortex_api_1.Modal.Body, null,
            React.createElement("div", { className: 'collection-finished-body' },
                React.createElement(react_bootstrap_1.Media.Left, null,
                    React.createElement(CollectionTile_1.default, { t: t, gameId: (_c = driver.profile) === null || _c === void 0 ? void 0 : _c.gameId, collection: driver.collection, details: true, imageTime: 42 })),
                React.createElement(react_bootstrap_1.Media.Right, null,
                    React.createElement("h5", null, game === null || game === void 0 ? void 0 : game.name),
                    React.createElement("h3", null, vortex_api_1.util.renderModName(driver.collection)), (_f = (_e = (_d = driver.collection) === null || _d === void 0 ? void 0 : _d.attributes) === null || _e === void 0 ? void 0 : _e.shortDescription) !== null && _f !== void 0 ? _f : t('No description'),
                    ownCollection && (optionals.length > 0) ? (React.createElement("div", null,
                        React.createElement(YouCuratedThisTag_1.default, { t: t }),
                        t('To edit this collection you must install all of the optional mods'))) : null)),
            (optionals.length > 0) ? (React.createElement("div", { className: 'collection-finished-optionals' },
                React.createElement("div", { className: 'collection-finished-optionals-text' }, t('{{numOptionals}} optional mods available', { replace: { numOptionals: optionals.length } })),
                React.createElement("p", null, t('This collection has {{count}} optional mods which are not required to '
                    + 'complete the installation but may provide additional features or options. '
                    + 'You can view these mods before installing as they may change the default '
                    + 'behavior of the collection or have additional requirements.', {
                    count: optionals.length,
                    ns: constants_1.NAMESPACE,
                })),
                React.createElement("div", { className: 'collection-finished-optional-buttons' }))) : ownCollection ? (React.createElement("div", { className: 'collection-can-clone-container' },
                React.createElement(YouCuratedThisTag_1.default, { t: t }),
                t('You now have the whole collection installed, you can start editing '
                    + 'your collection by cloning it.'),
                React.createElement(vortex_api_1.tooltip.IconButton, { icon: 'clone', tooltip: t('Clone the collection to the workshop for editing'), onClick: clone }, t('Edit')))) : null),
        (optionals.length > 0) ? (React.createElement(vortex_api_1.Modal.Footer, null,
            React.createElement(react_bootstrap_1.Button, { onClick: skip }, t('No Thanks')),
            React.createElement(react_bootstrap_1.Button, { onClick: showOptionals }, t('View optional mods')),
            React.createElement(react_bootstrap_1.Button, { onClick: installAllOptionals }, t('Install optional mods')))) : (React.createElement(vortex_api_1.Modal.Footer, null,
            React.createElement(react_bootstrap_1.Button, { onClick: skip }, t('Done'))))));
}
exports["default"] = React.memo(InstallFinishedDialog);


/***/ }),

/***/ "./src/views/InstallDialog/InstallStartDialog.tsx":
/*!********************************************************!*\
  !*** ./src/views/InstallDialog/InstallStartDialog.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
const CollectionTile_1 = __webpack_require__(/*! ../CollectionTile */ "./src/views/CollectionTile/index.tsx");
const YouCuratedThisTag_1 = __webpack_require__(/*! ./YouCuratedThisTag */ "./src/views/InstallDialog/YouCuratedThisTag.tsx");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_i18next_1 = __webpack_require__(/*! react-i18next */ "react-i18next");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const react_select_1 = __webpack_require__(/*! react-select */ "react-select");
const shortid_1 = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
const react_markdown_1 = __webpack_require__(/*! react-markdown */ "./node_modules/react-markdown/index.js");
function nop() {
}
function InstallDialogSelectProfile(props) {
    const { t, allProfiles, onSelectProfile, profile, selectedProfile, recommendedNewProfile } = props;
    const profileOptions = Object.keys(allProfiles)
        .filter(profId => allProfiles[profId].gameId === profile.gameId)
        .map(profId => ({
        value: profId,
        label: profId === profile.id
            ? t('{{name}} (Current)', { replace: { name: profile.name } })
            : allProfiles[profId].name,
    }))
        .concat({
        value: '__new', label: t('Create new profile{{recommended}}', { replace: { recommended: recommendedNewProfile ? t(' (Recommended by curator)') : '' } })
    });
    return (React.createElement(vortex_api_1.FlexLayout, { type: 'row', id: 'collections-profile-select' },
        React.createElement(vortex_api_1.FlexLayout.Fixed, null, t('Install this collection to profile') + ':'),
        React.createElement(vortex_api_1.FlexLayout.Flex, null,
            React.createElement(react_select_1.default, { options: profileOptions, value: selectedProfile !== null && selectedProfile !== void 0 ? selectedProfile : profile.id, onChange: onSelectProfile, clearable: false }))));
}
function InstallDialogConfirmProfile(props) {
    var _a;
    const { t, collectionName, selectedProfile } = props;
    const profileName = (_a = selectedProfile === null || selectedProfile === void 0 ? void 0 : selectedProfile.name) !== null && _a !== void 0 ? _a : collectionName;
    return (React.createElement(React.Fragment, null,
        React.createElement("p", null, t('Currently installing to profile: {{profileName}}', {
            replace: {
                profileName,
            },
        })),
        React.createElement("p", null, t('Do you want to switch to this profile?'))));
}
class InstallDialog extends vortex_api_1.ComponentEx {
    constructor(props) {
        super(props);
        this.changeProfile = (value) => {
            if (!!value) {
                this.nextState.selectedProfile = value.value;
            }
        };
        this.cancel = () => {
            this.props.driver.cancel();
        };
        this.next = () => {
            var _a, _b;
            if (!this.state.confirmProfile
                && (this.state.selectedProfile !== undefined)
                && (this.state.selectedProfile !== ((_b = (_a = this.props.driver) === null || _a === void 0 ? void 0 : _a.profile) === null || _b === void 0 ? void 0 : _b.id))) {
                if (this.state.selectedProfile === '__new') {
                    const { driver, onAddProfile, onSetProfilesVisible } = this.props;
                    const { profile } = driver;
                    const profileId = (0, shortid_1.generate)();
                    const name = vortex_api_1.util.renderModName(driver.collection);
                    const newProfile = {
                        id: profileId,
                        gameId: profile.gameId,
                        name,
                        modState: {},
                        lastActivated: 0,
                    };
                    onAddProfile(newProfile);
                    onSetProfilesVisible();
                    this.nextState.selectedProfile = profileId;
                }
                this.nextState.confirmProfile = true;
            }
            else {
                this.startInstall();
            }
        };
        this.switchProfile = async () => {
            const { selectedProfile } = this.state;
            await this.props.onSwitchProfile(selectedProfile);
            this.props.onSetProfilesVisible();
            this.startInstall();
        };
        this.initState({
            selectedProfile: undefined,
            confirmProfile: false,
            recommendedNewProfile: false,
        });
        if (props.driver !== undefined) {
            this.props.driver.onUpdate(() => this.forceUpdate());
        }
    }
    static getDerivedStateFromProps(props, state) {
        var _a, _b, _c;
        if (!state.selectedProfile && !!((_c = (_b = (_a = props.driver) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.attributes) === null || _c === void 0 ? void 0 : _c.recommendNewProfile)) {
            return {
                recommendedNewProfile: true,
                selectedProfile: '__new',
            };
        }
        return null;
    }
    componentDidUpdate(prevProps) {
        const { driver } = this.props;
        if (driver !== undefined) {
            if (driver !== prevProps.driver) {
                driver.onUpdate(() => this.forceUpdate());
            }
            if (driver.collection !== this.mLastCollection) {
                this.nextState.confirmProfile = false;
                this.nextState.selectedProfile = undefined;
                this.mLastCollection = driver.collection;
            }
        }
    }
    render() {
        var _a, _b, _c, _d;
        const { t, driver, allProfiles, nextProfileId, userInfo } = this.props;
        const { selectedProfile, recommendedNewProfile } = this.state;
        if ((driver === null || driver === void 0 ? void 0 : driver.profile) === undefined) {
            return null;
        }
        const { profile } = driver;
        if (nextProfileId !== profile.id) {
            return null;
        }
        let installInstructions = ((_b = (_a = driver.collection) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.installInstructions) || t(constants_1.DEFAULT_INSTRUCTIONS);
        installInstructions = installInstructions.replace(/\r?\n/g, "  \r\n");
        const game = vortex_api_1.util.getGame(profile.gameId);
        const ownCollection = ((userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId) !== undefined)
            && (((_d = (_c = driver.collectionInfo) === null || _c === void 0 ? void 0 : _c.user) === null || _d === void 0 ? void 0 : _d.memberId) === (userInfo === null || userInfo === void 0 ? void 0 : userInfo.userId));
        const collectionName = vortex_api_1.util.renderModName(driver.collection);
        return (React.createElement(vortex_api_1.Modal, { show: (driver.collection !== undefined) && (driver.step === 'query'), onHide: nop },
            React.createElement(vortex_api_1.Modal.Header, null,
                React.createElement(vortex_api_1.Modal.Title, null, t('{{gameName}} collection added', { replace: { gameName: game.name } }))),
            React.createElement(vortex_api_1.Modal.Body, null,
                React.createElement(react_bootstrap_1.Media, null,
                    React.createElement(react_bootstrap_1.Media.Left, null,
                        React.createElement(CollectionTile_1.default, { t: t, gameId: profile.gameId, collection: driver.collection, details: true, imageTime: 42 })),
                    React.createElement(react_bootstrap_1.Media.Right, { style: { width: '100%', display: 'flex' } },
                        React.createElement(react_bootstrap_1.Media.Body, null,
                            React.createElement(react_bootstrap_1.Media.Heading, null, "Collection instructions"),
                            React.createElement("p", { className: 'collections-instructions-canbereviewed' }, "Instructions can be reviewed during installation."),
                            ownCollection ? React.createElement(YouCuratedThisTag_1.default, { t: t }) : null,
                            React.createElement(react_markdown_1.default, { className: 'textarea-install-collection-instructions', allowedElements: ['p', 'br', 'a', 'em', 'strong'], unwrapDisallowed: true }, installInstructions)))),
                React.createElement(vortex_api_1.FlexLayout, { type: 'row' },
                    React.createElement("p", null,
                        t('Profiles allow you to have multiple mod set-ups for a game at once and quickly switch between them.'),
                        React.createElement(vortex_api_1.More, { id: 'more-profile-instcollection', name: t('Profiles'), wikiId: 'profiles' }, vortex_api_1.util.getText('profile', 'profiles', t)))),
                (this.state.confirmProfile && (selectedProfile !== undefined)) ? (React.createElement(InstallDialogConfirmProfile, { t: t, collectionName: collectionName, selectedProfile: selectedProfile === '__new' ? undefined : allProfiles[selectedProfile] })) : (React.createElement(InstallDialogSelectProfile, { t: t, allProfiles: allProfiles, profile: profile, selectedProfile: selectedProfile, onSelectProfile: this.changeProfile, recommendedNewProfile: recommendedNewProfile })),
                React.createElement(vortex_api_1.Toggle, { checked: this.props.collectionsInstallWhileDownloading, onToggle: this.props.onSetCollectionConcurrency }, t('Install mods during collection downloads'))),
            React.createElement(vortex_api_1.Modal.Footer, null, this.state.confirmProfile ? (React.createElement(React.Fragment, null,
                React.createElement(react_bootstrap_1.Button, { onClick: this.next }, t('No')),
                React.createElement(react_bootstrap_1.Button, { onClick: this.switchProfile }, t('Yes')))) : (React.createElement(React.Fragment, null,
                React.createElement(react_bootstrap_1.Button, { onClick: this.cancel }, t('Later')),
                React.createElement(react_bootstrap_1.Button, { onClick: this.next }, t('Install Now')))))));
    }
    startInstall() {
        const { allProfiles, driver } = this.props;
        const { selectedProfile } = this.state;
        const { profile } = driver;
        if ((selectedProfile !== undefined) && (selectedProfile !== profile.id)) {
            driver.profile = allProfiles[selectedProfile];
        }
        driver.continue();
    }
}
const emptyObject = {};
function mapStateToProps(state, ownProps) {
    var _a, _b, _c;
    const { editCollectionId } = state.session.collections;
    const gameMode = (_b = (_a = ownProps.driver) === null || _a === void 0 ? void 0 : _a.profile) === null || _b === void 0 ? void 0 : _b.gameId;
    const isPremium = vortex_api_1.util.getSafe(state, ['persistent', 'nexus', 'userInfo', 'isPremium'], false);
    const collectionsInstallWhileDownloading = vortex_api_1.util.getSafe(state, ['settings', 'downloads', 'collectionsInstallWhileDownloading'], true);
    const { userInfo } = (_c = state.persistent['nexus']) !== null && _c !== void 0 ? _c : {};
    return {
        allProfiles: state.persistent.profiles,
        mods: editCollectionId !== undefined ? state.persistent.mods[gameMode] : emptyObject,
        isPremium,
        userInfo,
        nextProfileId: state.settings.profiles.nextProfileId,
        collectionsInstallWhileDownloading,
    };
}
function mapDispatchToProps(dispatch) {
    return {
        onSetModAttribute: (gameId, modId, key, value) => dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, key, value)),
        onSetModAttributes: (gameId, modId, attributes) => dispatch(vortex_api_1.actions.setModAttributes(gameId, modId, attributes)),
        onAddRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.addModRule(gameId, modId, rule)),
        onRemoveRule: (gameId, modId, rule) => dispatch(vortex_api_1.actions.removeModRule(gameId, modId, rule)),
        onAddProfile: (profile) => dispatch(vortex_api_1.actions.setProfile(profile)),
        onSetProfilesVisible: () => dispatch(vortex_api_1.actions.setProfilesVisible(true)),
        onSetCollectionConcurrency: (enabled) => dispatch(vortex_api_1.actions.setCollectionConcurrency(enabled)),
    };
}
exports["default"] = (0, react_i18next_1.withTranslation)(['common', constants_1.NAMESPACE])((0, react_redux_1.connect)(mapStateToProps, mapDispatchToProps)(React.memo(InstallDialog)));


/***/ }),

/***/ "./src/views/InstallDialog/YouCuratedThisTag.tsx":
/*!*******************************************************!*\
  !*** ./src/views/InstallDialog/YouCuratedThisTag.tsx ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const React = __webpack_require__(/*! react */ "react");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function Tag(props) {
    const { t } = props;
    return (React.createElement("div", { className: 'collections-you-curated-tag' },
        React.createElement(vortex_api_1.Icon, { name: 'completed' }),
        t('You curated this collection')));
}
exports["default"] = Tag;


/***/ }),

/***/ "./src/views/InstallDialog/index.tsx":
/*!*******************************************!*\
  !*** ./src/views/InstallDialog/index.tsx ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InstallStartDialog = exports.InstallFinishDialog = exports.InstallChangelogDialog = void 0;
const InstallChangelogDialog_1 = __webpack_require__(/*! ./InstallChangelogDialog */ "./src/views/InstallDialog/InstallChangelogDialog.tsx");
Object.defineProperty(exports, "InstallChangelogDialog", ({ enumerable: true, get: function () { return InstallChangelogDialog_1.InstallChangelogDialog; } }));
const InstallFinishedDialog_1 = __webpack_require__(/*! ./InstallFinishedDialog */ "./src/views/InstallDialog/InstallFinishedDialog.tsx");
exports.InstallFinishDialog = InstallFinishedDialog_1.default;
const InstallStartDialog_1 = __webpack_require__(/*! ./InstallStartDialog */ "./src/views/InstallDialog/InstallStartDialog.tsx");
exports.InstallStartDialog = InstallStartDialog_1.default;


/***/ }),

/***/ "./src/views/Tools.tsx":
/*!*****************************!*\
  !*** ./src/views/Tools.tsx ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const react_bootstrap_1 = __webpack_require__(/*! react-bootstrap */ "react-bootstrap");
const react_redux_1 = __webpack_require__(/*! react-redux */ "react-redux");
const url_1 = __webpack_require__(/*! url */ "url");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function ToolIcon(props) {
    const { gameId, imageUrl } = props;
    if (imageUrl !== undefined) {
        const src = (0, url_1.pathToFileURL)(path.join(vortex_api_1.util.getVortexPath('userData'), gameId, 'icons', imageUrl)).href;
        return (React.createElement(react_bootstrap_1.Image, { src: src, className: 'tool-icon valid' }));
    }
    else {
        return (React.createElement(vortex_api_1.Icon, { name: 'executable', className: 'tool-icon valid' }));
    }
}
function ToolItem(props) {
    var _a, _b;
    const { enabled, gameId, onToggle, tool } = props;
    return (React.createElement("tr", null,
        React.createElement("td", null,
            React.createElement(vortex_api_1.Toggle, { dataId: tool.id, checked: enabled, onToggle: onToggle })),
        React.createElement("td", null,
            React.createElement(ToolIcon, { gameId: gameId, imageUrl: tool.logo })),
        React.createElement("td", null, tool.name),
        React.createElement("td", null, tool.path),
        React.createElement("td", null, ((_a = tool.parameters) !== null && _a !== void 0 ? _a : []).join(' ')),
        React.createElement("td", null, Object.keys((_b = tool.environment) !== null && _b !== void 0 ? _b : {})
            .map(key => `${key}=${tool.environment[key]}`).join(', '))));
}
const emptyArray = [];
function Tools(props) {
    const { t, collection, onSetCollectionAttribute } = props;
    const gameMode = (0, react_redux_1.useSelector)(vortex_api_1.selectors.activeGameId);
    const includedTools = (0, react_redux_1.useSelector)(state => {
        var _a, _b, _c;
        return (_c = (_b = (_a = state.persistent.mods[gameMode][collection.id].attributes) === null || _a === void 0 ? void 0 : _a.collection) === null || _b === void 0 ? void 0 : _b.includedTools) !== null && _c !== void 0 ? _c : emptyArray;
    });
    const toggleCB = React.useCallback((newValue, toolId) => {
        onSetCollectionAttribute(['includedTools'], newValue
            ? [].concat(includedTools, [toolId])
            : includedTools.filter(id => id !== toolId));
    }, [includedTools, onSetCollectionAttribute]);
    const tools = (0, react_redux_1.useSelector)((state) => state.settings.gameMode.discovered[gameMode].tools);
    const custom = Object.values(tools !== null && tools !== void 0 ? tools : {})
        .filter(tool => tool.custom && !tool.hidden);
    return (React.createElement("div", { className: 'collection-scrollable' },
        React.createElement(react_bootstrap_1.ControlLabel, null,
            React.createElement("p", null, t('This screen lets you include tools you manually configured to be run from Vortex.')),
            React.createElement("p", null, t('Obviously users will need to have these tools installed. If they aren\'t '
                + 'included in the game and not installed as a mod through this collection, '
                + 'you should include instructions for the user on how to get the tool.'))),
        React.createElement(react_bootstrap_1.Table, { id: 'collection-tools-table' },
            React.createElement("thead", null,
                React.createElement("tr", null,
                    React.createElement("th", { className: 'header-status' }, t('Status')),
                    React.createElement("th", { className: 'header-icon' }, t('Icon')),
                    React.createElement("th", { className: 'header-name' }, t('Name')),
                    React.createElement("th", { className: 'header-path' }, t('Path')),
                    React.createElement("th", { className: 'header-args' }, t('Args')),
                    React.createElement("th", { className: 'header-env' }, t('Environment')))),
            React.createElement("tbody", null, custom.map(item => (React.createElement(ToolItem, { key: item.id, t: t, tool: item, gameId: gameMode, enabled: includedTools.includes(item.id), onToggle: toggleCB })))))));
}
exports["default"] = Tools;


/***/ }),

/***/ "bluebird":
/*!***************************!*\
  !*** external "bluebird" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("bluebird");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("lodash");

/***/ }),

/***/ "node-7z":
/*!**************************!*\
  !*** external "node-7z" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node-7z");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("react");

/***/ }),

/***/ "react-bootstrap":
/*!**********************************!*\
  !*** external "react-bootstrap" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-bootstrap");

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-dom");

/***/ }),

/***/ "react-i18next":
/*!********************************!*\
  !*** external "react-i18next" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-i18next");

/***/ }),

/***/ "react-redux":
/*!******************************!*\
  !*** external "react-redux" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-redux");

/***/ }),

/***/ "react-select":
/*!*******************************!*\
  !*** external "react-select" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-select");

/***/ }),

/***/ "redux-act":
/*!****************************!*\
  !*** external "redux-act" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("redux-act");

/***/ }),

/***/ "semver":
/*!*************************!*\
  !*** external "semver" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("semver");

/***/ }),

/***/ "turbowalk":
/*!****************************!*\
  !*** external "turbowalk" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("turbowalk");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "vortex-api":
/*!*****************************!*\
  !*** external "vortex-api" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("vortex-api");

/***/ }),

/***/ "vortexmt":
/*!***************************!*\
  !*** external "vortexmt" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("vortexmt");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const persistent_1 = __webpack_require__(/*! ./actions/persistent */ "./src/actions/persistent.ts");
const persistent_2 = __webpack_require__(/*! ./reducers/persistent */ "./src/reducers/persistent.ts");
const session_1 = __webpack_require__(/*! ./reducers/session */ "./src/reducers/session.ts");
const settings_1 = __webpack_require__(/*! ./reducers/settings */ "./src/reducers/settings.ts");
const defaults_1 = __webpack_require__(/*! ./util/defaults */ "./src/util/defaults.ts");
const extension_1 = __webpack_require__(/*! ./util/extension */ "./src/util/extension.ts");
const InstallDriver_1 = __webpack_require__(/*! ./util/InstallDriver */ "./src/util/InstallDriver.ts");
const transformCollection_1 = __webpack_require__(/*! ./util/transformCollection */ "./src/util/transformCollection.ts");
const util_1 = __webpack_require__(/*! ./util/util */ "./src/util/util.ts");
const AddModsDialog_1 = __webpack_require__(/*! ./views/AddModsDialog */ "./src/views/AddModsDialog.tsx");
const HealthDownvoteDialog_1 = __webpack_require__(/*! ./views/CollectionPageView/HealthDownvoteDialog */ "./src/views/CollectionPageView/HealthDownvoteDialog.tsx");
const CollectionList_1 = __webpack_require__(/*! ./views/CollectionList */ "./src/views/CollectionList/index.tsx");
const InstallDialog_1 = __webpack_require__(/*! ./views/InstallDialog */ "./src/views/InstallDialog/index.tsx");
const CollectionModsPageAttributeRenderer_1 = __webpack_require__(/*! ./views/CollectionModsPageAttributeRenderer */ "./src/views/CollectionModsPageAttributeRenderer.tsx");
const collectionCreate_1 = __webpack_require__(/*! ./collectionCreate */ "./src/collectionCreate.ts");
const collectionInstall_1 = __webpack_require__(/*! ./collectionInstall */ "./src/collectionInstall.ts");
const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");
const eventHandlers_1 = __webpack_require__(/*! ./eventHandlers */ "./src/eventHandlers.ts");
const initweaks_1 = __webpack_require__(/*! ./initweaks */ "./src/initweaks.ts");
const tools_1 = __webpack_require__(/*! ./tools */ "./src/tools.ts");
const PromiseBB = __webpack_require__(/*! bluebird */ "bluebird");
const _ = __webpack_require__(/*! lodash */ "lodash");
const memoize_one_1 = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
const path = __webpack_require__(/*! path */ "path");
const React = __webpack_require__(/*! react */ "react");
const shortid_1 = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
const url_1 = __webpack_require__(/*! url */ "url");
const vortex_api_1 = __webpack_require__(/*! vortex-api */ "vortex-api");
function isEditableCollection(state, modIds) {
    const gameMode = vortex_api_1.selectors.activeGameId(state);
    const mod = state.persistent.mods[gameMode][modIds[0]];
    if (mod === undefined) {
        return false;
    }
    return vortex_api_1.util.getSafe(mod.attributes, ['editable'], false);
}
function profileCollectionExists(api, profileId) {
    const state = api.store.getState();
    const gameMode = vortex_api_1.selectors.activeGameId(state);
    const mods = state.persistent.mods[gameMode];
    return mods[(0, transformCollection_1.makeCollectionId)(profileId)] !== undefined;
}
function onlyLocalRules(rule) {
    return ['requires', 'recommends'].includes(rule.type)
        && (rule.reference.fileExpression === undefined)
        && (rule.reference.fileMD5 === undefined)
        && (rule.reference.logicalFileName === undefined)
        && (rule.reference.repo === undefined);
}
const modsBeingRemoved = new Set();
function makeModKey(gameId, modId) {
    return `${gameId}_${modId}`;
}
function makeWillRemoveMods() {
    return (gameId, modIds) => {
        modIds.forEach(modId => modsBeingRemoved.add(makeModKey(gameId, modId)));
        return Promise.resolve();
    };
}
function makeDidRemoveMods() {
    return (gameId, modIds) => {
        modIds.forEach(modId => modsBeingRemoved.delete(makeModKey(gameId, modId)));
        return Promise.resolve();
    };
}
function makeOnUnfulfilledRules(api) {
    const reported = new Set();
    return (profileId, modId, rules) => {
        var _a;
        const state = api.store.getState();
        const profile = vortex_api_1.selectors.profileById(state, profileId);
        const gameId = profile.gameId;
        if (modsBeingRemoved.has(makeModKey(gameId, modId))) {
            return PromiseBB.resolve(false);
        }
        const collection = vortex_api_1.util.getSafe(state.persistent.mods, [gameId, modId], undefined);
        if ((collection !== undefined)
            && !reported.has(modId)
            && (state.persistent.mods[gameId][modId].type === constants_1.MOD_TYPE)
            && !((_a = collection.attributes) === null || _a === void 0 ? void 0 : _a.editable)) {
            const collectionProfile = Object.keys(state.persistent.profiles)
                .find(iter => (0, transformCollection_1.makeCollectionId)(iter) === modId);
            const notiActions = [{
                    title: 'Disable',
                    action: dismiss => {
                        dismiss();
                        if (profile !== undefined) {
                            api.store.dispatch(vortex_api_1.actions.setModEnabled(profile.id, modId, false));
                        }
                    },
                }];
            if (collectionProfile !== undefined) {
                notiActions.unshift({
                    title: 'Update',
                    action: dismiss => {
                        (0, collectionCreate_1.initFromProfile)(api, collectionProfile)
                            .then(dismiss)
                            .catch(err => api.showErrorNotification('Failed to update collection', err));
                    },
                });
            }
            else if (profile !== undefined) {
                notiActions.unshift({
                    title: 'Resume',
                    action: dismiss => {
                        driver.start(profile, collection);
                        dismiss();
                    },
                });
            }
            reported.add(modId);
            api.sendNotification({
                id: (0, util_1.getUnfulfilledNotificationId)(collection.id),
                type: 'info',
                title: 'Collection incomplete',
                message: vortex_api_1.util.renderModName(collection),
                actions: notiActions,
            });
            return PromiseBB.resolve(true);
        }
        else {
            return PromiseBB.resolve(false);
        }
    };
}
let driver;
async function cloneInstalledCollection(api, collectionId) {
    const state = api.getState();
    const gameMode = vortex_api_1.selectors.activeGameId(state);
    const mods = state.persistent.mods[gameMode];
    const result = await api.showDialog('question', 'Clone collection "{{collectionName}}"?', {
        text: 'Cloning a collection means you can make edits to the collection in the workshop '
            + 'and share your changes with the community.\n'
            + 'If this collection is your own, your uploads will be revisions of that existing '
            + 'collection, otherwise you will create a new collection associated with your own '
            + 'account.',
        parameters: {
            collectionName: vortex_api_1.util.renderModName(mods[collectionId]),
        },
    }, [
        { label: 'Cancel' },
        { label: 'Clone' },
    ]);
    if (result.action === 'Clone') {
        const id = (0, transformCollection_1.makeCollectionId)((0, shortid_1.generate)());
        return (0, transformCollection_1.cloneCollection)(api, gameMode, id, collectionId);
    }
    else {
        return Promise.resolve(undefined);
    }
}
async function createNewCollection(api, profile, name) {
    const id = (0, transformCollection_1.makeCollectionId)((0, shortid_1.generate)());
    await (0, transformCollection_1.createCollection)(api, profile.gameId, id, name, []);
    api.sendNotification({
        type: 'success',
        id: 'collection-created',
        title: 'Collection created',
        message: name,
        actions: [
            {
                title: 'Edit',
                action: dismiss => {
                    api.events.emit('edit-collection', id);
                    dismiss();
                },
            },
        ],
    });
}
async function installCollection(api, revision) {
    return api.showDialog('question', 'Collection not installed', {
        text: 'You can only edit collections that are fully installed in this '
            + 'setup. Please ensure you install the collection with all '
            + 'optional items, then clone the collection into the Workshop.'
    }, [
        { label: 'Cancel' },
        { label: 'Install' },
    ])
        .then(result => {
        if (result.action === 'Install') {
            const gameId = revision.collection.game.domainName;
            api.events.emit('start-download', [`nxm://${gameId}/collections/${revision.collection.slug}/revisions/${revision.revisionNumber}`], {}, undefined, (err) => {
                if ((err !== null) && !(err instanceof vortex_api_1.util.UserCanceled)) {
                    api.showErrorNotification('Failed to download collection', err);
                }
            }, undefined, { allowInstall: 'force' });
        }
    });
}
async function pauseCollection(api, gameId, modId, silent) {
    var _a;
    const state = api.getState();
    const mods = state.persistent.mods[gameId];
    const downloads = state.persistent.downloads.files;
    const collection = mods[modId];
    if (collection === undefined) {
        return;
    }
    ((_a = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _a !== void 0 ? _a : []).forEach(rule => {
        const dlId = vortex_api_1.util.findDownloadByRef(rule.reference, downloads);
        if (dlId !== undefined) {
            api.events.emit('pause-download', dlId);
        }
    });
    await api.emitAndAwait('cancel-dependency-install', modId);
    driver.cancel();
    api.dismissNotification(constants_1.INSTALLING_NOTIFICATION_ID + modId);
    if (silent !== true) {
        api.sendNotification({
            id: 'collection-pausing',
            type: 'success',
            title: 'Collection pausing',
            message: 'Already queued mod installations will still finish',
        });
    }
}
async function removeCollection(api, gameId, modId, cancel) {
    var _a, _b, _c;
    const state = api.getState();
    const mods = state.persistent.mods[gameId];
    const t = api.translate;
    const collection = mods[modId];
    if (collection === undefined) {
        return;
    }
    const filter = rule => (rule.type === 'requires')
        && (rule['ignored'] !== true)
        && (vortex_api_1.util.findModByRef(rule.reference, mods) === undefined);
    const incomplete = ((_a = collection.rules) !== null && _a !== void 0 ? _a : []).find(filter);
    const message = cancel && incomplete
        ? 'Are you sure you want to cancel the installation?'
        : 'Are you sure you want to remove the collection?';
    const result = await api.showDialog('question', message, {
        text: 'This collection will be removed from Vortex and unlinked from any associated mods. '
            + 'You can also choose to uninstall mods related to this collection and delete the '
            + 'downloaded archives.\n'
            + '\nPlease note, some mods may be required by multiple collections.\n'
            + '\nAre you sure you want to remove "{{collectionName}}" from your collections?',
        parameters: {
            collectionName: vortex_api_1.util.renderModName(collection),
        },
        checkboxes: [
            { id: 'delete_mods', text: t('Remove mods'), value: false },
            { id: 'delete_archives', text: t('Delete mod archives'), value: false },
        ],
    }, [
        { label: 'Cancel' },
        { label: 'Remove Collection' },
    ]);
    if (result.action === 'Cancel') {
        return;
    }
    const deleteArchives = result.input.delete_archives;
    const deleteMods = result.input.delete_mods;
    modsBeingRemoved.add(makeModKey(gameId, modId));
    await pauseCollection(api, gameId, modId, true);
    let progress = 0;
    const notiId = (0, shortid_1.generate)();
    const modName = vortex_api_1.util.renderModName(collection);
    const doProgress = (step, value) => {
        if (value <= progress) {
            return;
        }
        progress = value;
        api.sendNotification({
            id: notiId,
            type: 'activity',
            title: 'Removing {{name}}',
            message: step,
            progress,
            replace: {
                name: modName,
            },
        });
    };
    try {
        doProgress('Removing downloads', 0);
        const downloads = state.persistent.downloads.files;
        let completed = 0;
        await Promise.all(((_b = collection.rules) !== null && _b !== void 0 ? _b : []).map(async (rule) => {
            const dlId = vortex_api_1.util.findDownloadByRef(rule.reference, downloads);
            if (dlId !== undefined) {
                const download = state.persistent.downloads.files[dlId];
                if ((download !== undefined)
                    && (deleteArchives || (download.state !== 'finished'))) {
                    await vortex_api_1.util.toPromise(cb => api.events.emit('remove-download', dlId, cb));
                }
            }
            doProgress('Removing downloads', 50 * ((completed++) / collection.rules.length));
        }));
        doProgress('Removing mods', 50);
        completed = 0;
        if (deleteMods) {
            const removeMods = ((_c = collection.rules) !== null && _c !== void 0 ? _c : [])
                .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
                .filter(mod => mod !== undefined)
                .map(mod => mod.id);
            await vortex_api_1.util.toPromise(cb => api.events.emit('remove-mods', gameId, removeMods, cb, {
                progressCB: (idx, length, name) => {
                    doProgress(name, 50 + (50 * idx) / length);
                },
            }));
        }
        {
            doProgress('Removing collection', 0.99);
            const download = state.persistent.downloads.files[collection.archiveId];
            if (download !== undefined) {
                await vortex_api_1.util.toPromise(cb => api.events.emit('remove-download', collection.archiveId, cb));
            }
            await vortex_api_1.util.toPromise(cb => api.events.emit('remove-mod', gameId, modId, cb, {
                incomplete: true,
            }));
        }
    }
    catch (err) {
        if (!(err instanceof vortex_api_1.util.UserCanceled)) {
            api.showErrorNotification('Failed to remove mods', err, {
                message: modName,
                allowReport: !(err instanceof vortex_api_1.util.ProcessCanceled),
                warning: (err instanceof vortex_api_1.util.ProcessCanceled),
            });
        }
    }
    finally {
        modsBeingRemoved.delete(makeModKey(gameId, modId));
        api.dismissNotification(notiId);
    }
}
function genAttributeExtractor(api) {
    return (modInfo, modPath) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        const collectionId = (_d = (_c = (_b = (_a = modInfo.download) === null || _a === void 0 ? void 0 : _a.modInfo) === null || _b === void 0 ? void 0 : _b.nexus) === null || _c === void 0 ? void 0 : _c.ids) === null || _d === void 0 ? void 0 : _d.collectionId;
        const revisionId = (_h = (_g = (_f = (_e = modInfo.download) === null || _e === void 0 ? void 0 : _e.modInfo) === null || _f === void 0 ? void 0 : _f.nexus) === null || _g === void 0 ? void 0 : _g.ids) === null || _h === void 0 ? void 0 : _h.revisionId;
        const collectionSlug = (_m = (_l = (_k = (_j = modInfo.download) === null || _j === void 0 ? void 0 : _j.modInfo) === null || _k === void 0 ? void 0 : _k.nexus) === null || _l === void 0 ? void 0 : _l.ids) === null || _m === void 0 ? void 0 : _m.collectionSlug;
        const revisionNumber = (_r = (_q = (_p = (_o = modInfo.download) === null || _o === void 0 ? void 0 : _o.modInfo) === null || _p === void 0 ? void 0 : _p.nexus) === null || _q === void 0 ? void 0 : _q.ids) === null || _r === void 0 ? void 0 : _r.revisionNumber;
        const referenceTag = (_t = (_s = modInfo.download) === null || _s === void 0 ? void 0 : _s.modInfo) === null || _t === void 0 ? void 0 : _t.referenceTag;
        const result = {
            collectionId,
            revisionId,
            collectionSlug,
            revisionNumber,
            referenceTag,
        };
        return PromiseBB.resolve(result);
    };
}
function generateCollectionMap(mods) {
    const collections = Object.values(mods).filter(mod => mod.type === constants_1.MOD_TYPE);
    const result = {};
    collections.forEach(coll => {
        var _a;
        return ((_a = coll.rules) !== null && _a !== void 0 ? _a : []).forEach(rule => {
            if (rule.reference.id !== undefined) {
                vortex_api_1.util.setdefault(result, rule.reference.id, []).push(coll);
            }
            else {
                const installed = vortex_api_1.util.findModByRef(rule.reference, mods);
                if (installed !== undefined) {
                    vortex_api_1.util.setdefault(result, installed.id, []).push(coll);
                }
            }
        });
    });
    return result;
}
function collectionListEqual(lArgs, rArgs) {
    const lhs = lArgs[0];
    const rhs = rArgs[0];
    if (lhs === rhs) {
        return true;
    }
    const keys = Object.keys(lhs);
    if (!_.isEqual(keys, Object.keys(rhs))) {
        return false;
    }
    const ruleDiff = keys.find(modId => (lhs[modId].state !== rhs[modId].state) || (lhs[modId].rules !== rhs[modId].rules));
    return ruleDiff === undefined;
}
function generateCollectionOptions(mods) {
    return Object.values(mods)
        .filter(mod => mod.type === constants_1.MOD_TYPE)
        .map(mod => ({ label: vortex_api_1.util.renderModName(mod), value: mod.id }));
}
async function updateMeta(api) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const state = api.getState();
    const gameMode = vortex_api_1.selectors.activeGameId(state);
    const mods = (_a = state.persistent.mods[gameMode]) !== null && _a !== void 0 ? _a : {};
    const collections = Object.keys(mods)
        .filter(modId => mods[modId].type === constants_1.MOD_TYPE);
    const notiId = (0, shortid_1.generate)();
    const progress = (name, idx) => {
        api.sendNotification({
            id: notiId,
            type: 'activity',
            title: 'Updating Collection Information',
            message: name,
            progress: (idx * 100) / collections.length,
        });
    };
    for (let i = 0; i < collections.length; ++i) {
        const modId = collections[i];
        const { revisionId, collectionSlug, revisionNumber } = (_b = mods[modId].attributes) !== null && _b !== void 0 ? _b : {};
        try {
            if ((revisionId !== undefined) || (collectionSlug !== undefined)) {
                progress(vortex_api_1.util.renderModName(mods[modId]), i);
                const info = await driver.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber, 'force');
                if (!!info) {
                    const currentRevision = info.collection.revisions
                        .filter(rev => rev.revisionStatus === 'published')
                        .sort((lhs, rhs) => rhs.revisionNumber - lhs.revisionNumber)[0];
                    api.store.dispatch(vortex_api_1.actions.setModAttributes(gameMode, modId, {
                        collectionSlug: info.collection.slug,
                        revisionNumber: info.revisionNumber,
                        author: (_c = info.collection.user) === null || _c === void 0 ? void 0 : _c.name,
                        uploader: (_d = info.collection.user) === null || _d === void 0 ? void 0 : _d.name,
                        uploaderAvatar: (_e = info.collection.user) === null || _e === void 0 ? void 0 : _e.avatar,
                        uploaderId: (_f = info.collection.user) === null || _f === void 0 ? void 0 : _f.memberId,
                        pictureUrl: (_g = info.collection.tileImage) === null || _g === void 0 ? void 0 : _g.url,
                        description: info.collection.description,
                        shortDescription: info.collection.summary,
                        newestFileId: currentRevision === null || currentRevision === void 0 ? void 0 : currentRevision.revisionNumber,
                        newestVersion: (_j = (_h = currentRevision === null || currentRevision === void 0 ? void 0 : currentRevision.revisionNumber) === null || _h === void 0 ? void 0 : _h.toString) === null || _j === void 0 ? void 0 : _j.call(_h),
                        metadata: info.metadata,
                        rating: info.rating,
                    }));
                }
            }
        }
        catch (err) {
            api.showErrorNotification('Failed to check collection for update', err);
        }
    }
    localState.ownCollections = (await api.emitAndAwait('get-my-collections', gameMode))[0] || [];
    api.dismissNotification(notiId);
}
let collectionChangedCB;
function onAddSelectionImpl(api, collectionId, modIds) {
    const state = api.getState();
    const gameId = vortex_api_1.selectors.activeGameId(state);
    const collection = state.persistent.mods[gameId][collectionId];
    if (collection !== undefined) {
        modIds.forEach(modId => {
            if (!(0, collectionCreate_1.alreadyIncluded)(collection.rules, modId)) {
                api.store.dispatch(vortex_api_1.actions.addModRule(gameId, collectionId, {
                    type: 'requires',
                    reference: {
                        id: modId,
                    },
                }));
            }
        });
    }
    else {
        (0, vortex_api_1.log)('warn', 'failed to add mods to collection, collection no longer found', { gameId, collectionId, modIds });
    }
}
const localState = vortex_api_1.util.makeReactive({
    ownCollections: [],
});
function register(context, collectionsCB) {
    context.registerReducer(['session', 'collections'], session_1.default);
    context.registerReducer(['settings', 'collections'], settings_1.default);
    context.registerReducer(['persistent', 'collections'], persistent_2.default);
    const onSwitchProfile = (profileId) => {
        return new Promise((resolve, reject) => {
            context.api.events.once('profile-did-change', (newProfileId) => {
                if (newProfileId === profileId) {
                    resolve();
                }
                else {
                    (0, vortex_api_1.log)('warn', `Failed to switch to profile ${profileId}; got ${newProfileId}`);
                    const profile = vortex_api_1.selectors.profileById(context.api.getState(), profileId);
                    if (profile === undefined) {
                        reject(new Error(`Failed to switch to profile ${profileId}; got ${newProfileId}`));
                    }
                    context.api.store.dispatch(vortex_api_1.actions.setNextProfile(profileId));
                    resolve();
                }
            });
            context.api.store.dispatch(vortex_api_1.actions.setNextProfile(profileId));
        });
    };
    context.registerDialog('collection-install', InstallDialog_1.InstallStartDialog, () => ({
        driver,
        onSwitchProfile,
    }));
    const onClone = (collectionId) => cloneInstalledCollection(context.api, collectionId);
    const onCreateCollection = (profile, name) => createNewCollection(context.api, profile, name);
    const onRemoveCollection = (gameId, modId, cancel) => removeCollection(context.api, gameId, modId, cancel);
    const onUpdateMeta = () => updateMeta(context.api);
    const editCollection = (id) => collectionsCB.editCollection(id);
    const onInstallCollection = (revision) => installCollection(context.api, revision);
    context.registerDialog('collection-finish', InstallDialog_1.InstallFinishDialog, () => ({
        api: context.api,
        driver,
        onClone,
        editCollection,
    }));
    context.registerDialog('collection-changelog', InstallDialog_1.InstallChangelogDialog, () => ({}));
    const onAddSelection = (collectionId, modIds) => onAddSelectionImpl(context.api, collectionId, modIds);
    context.registerDialog('add-mod-to-collection', AddModsDialog_1.default, () => ({
        onAddSelection,
    }));
    context.registerDialog('collection-health-downvote', HealthDownvoteDialog_1.default, () => ({}));
    let resetPageCB;
    const resetCB = (cb) => resetPageCB = cb;
    const onAddCallback = (cbName, cb) => {
        collectionsCB[cbName] = cb;
    };
    context.registerMainPage('collection', 'Collections', CollectionList_1.default, {
        hotkey: 'C',
        group: 'per-game',
        visible: () => vortex_api_1.selectors.activeGameId(context.api.store.getState()) !== undefined,
        props: () => ({
            driver,
            localState,
            onInstallCollection,
            onAddCallback,
            onRemoveCollection,
            onCloneCollection: onClone,
            onCreateCollection,
            onUpdateMeta,
            resetCB,
            pathTool,
        }),
        onReset: () => resetPageCB === null || resetPageCB === void 0 ? void 0 : resetPageCB(),
        priority: 90,
    });
    context.registerModType(constants_1.MOD_TYPE, 200, () => true, () => undefined, () => PromiseBB.resolve(false), {
        name: 'Collection',
        customDependencyManagement: true,
        noConflicts: true,
    });
    const stateFunc = () => context.api.store.getState();
    const emptyArray = [];
    const emptyObj = {};
    const collectionsMapFunc = (0, memoize_one_1.default)(generateCollectionMap, collectionListEqual);
    const collectionsMap = () => {
        var _a;
        return collectionsMapFunc((_a = stateFunc().persistent.mods[vortex_api_1.selectors.activeGameId(stateFunc())]) !== null && _a !== void 0 ? _a : emptyObj);
    };
    const collectionOptions = (0, memoize_one_1.default)(generateCollectionOptions);
    const collectionChanged = new vortex_api_1.util.Debouncer(() => {
        collectionChangedCB === null || collectionChangedCB === void 0 ? void 0 : collectionChangedCB();
        return null;
    }, 500);
    const collectionAttribute = {
        id: 'collection',
        name: 'Collection',
        description: 'Collection(s) this mod was installed from (if any)',
        icon: 'collection',
        placement: 'both',
        customRenderer: (mod, detailCell) => {
            const collections = collectionsMap()[mod.id] || emptyArray;
            return React.createElement(CollectionModsPageAttributeRenderer_1.default, { modId: mod.id, collections, detailCell }, []);
        },
        calc: (mod) => {
            const collections = collectionsMap()[mod.id];
            return (collections === undefined)
                ? '' : collections.map(iter => iter.id);
        },
        externalData: (onChanged) => {
            collectionChangedCB = onChanged;
        },
        isToggleable: true,
        edit: {},
        filter: new vortex_api_1.OptionsFilter((() => {
            var _a;
            const mods = (_a = stateFunc().persistent.mods[vortex_api_1.selectors.activeGameId(stateFunc())]) !== null && _a !== void 0 ? _a : {};
            return [
                { label: `<${context.api.translate('None')}>`, value: vortex_api_1.OptionsFilter.EMPTY },
                ...collectionOptions(mods),
            ];
        }), false, false),
        isGroupable: true,
        groupName: (modId) => { var _a; return vortex_api_1.util.renderModName((_a = stateFunc().persistent.mods[vortex_api_1.selectors.activeGameId(stateFunc())]) === null || _a === void 0 ? void 0 : _a[modId]); },
        isDefaultVisible: false,
    };
    context.registerTableAttribute('mods', collectionAttribute);
    context.registerAction('mods-action-icons', 25, 'collection-edit', {}, 'Edit Collection', (modIds) => {
        context.api.events.emit('show-main-page', 'Collections');
        setTimeout(() => {
            if ((collectionsCB !== undefined) && (collectionsCB.editCollection !== undefined)) {
                collectionsCB.editCollection(modIds[0]);
            }
        }, 100);
    }, (modIds) => isEditableCollection(context.api.getState(), modIds));
    context.registerAction('mods-action-icons', 50, 'conflict', {}, 'Apply Collection Rules', (modIds) => {
        const state = context.api.getState();
        const gameId = vortex_api_1.selectors.activeGameId(state);
        context.api.events.emit('did-install-dependencies', gameId, modIds[0], false);
    }, (modIds) => {
        const state = context.api.getState();
        const gameId = vortex_api_1.selectors.activeGameId(state);
        const mod = state.persistent.mods[gameId][modIds[0]];
        if (mod === undefined) {
            return false;
        }
        return (mod.type === constants_1.MOD_TYPE);
    });
    context.registerAction('profile-actions', 150, 'highlight-lab', {}, 'Init Collection', (profileIds) => {
        (0, collectionCreate_1.initFromProfile)(context.api, profileIds[0])
            .catch(err => context.api.showErrorNotification('Failed to init collection', err));
    }, (profileIds) => !profileCollectionExists(context.api, profileIds[0]));
    context.registerAction('profile-actions', 150, 'highlight-lab', {}, 'Update Collection', (profileIds) => {
        (0, collectionCreate_1.initFromProfile)(context.api, profileIds[0])
            .catch(err => context.api.showErrorNotification('Failed to update collection', err));
    }, (profileIds) => profileCollectionExists(context.api, profileIds[0]));
    context.registerAction('mods-action-icons', 300, 'collection', {}, 'Add to Collection...', (instanceIds) => (0, collectionCreate_1.addCollectionAction)(context.api, instanceIds)
        .then(() => collectionChanged.schedule())
        .catch(err => context.api.showErrorNotification('failed to add mod to collection', err)), (instanceIds) => (0, collectionCreate_1.addCollectionCondition)(context.api, instanceIds));
    context.registerAction('mods-multirow-actions', 300, 'collection', {}, 'Add to Collection...', (instanceIds) => (0, collectionCreate_1.addCollectionAction)(context.api, instanceIds)
        .then(() => collectionChanged.schedule())
        .catch(err => context.api.showErrorNotification('failed to add mod to collection', err)), (instanceIds) => (0, collectionCreate_1.addCollectionCondition)(context.api, instanceIds));
    context.registerAction('mods-action-icons', 300, 'collection', {}, 'Remove from Collection...', (instanceIds) => (0, collectionCreate_1.removeCollectionAction)(context.api, instanceIds)
        .then(() => collectionChanged.schedule())
        .catch(err => context.api.showErrorNotification('failed to remove mod from collection', err)), (instanceIds) => (0, collectionCreate_1.removeCollectionCondition)(context.api, instanceIds));
    context.registerAction('mods-multirow-actions', 300, 'collection', {}, 'Remove from Collection...', (instanceIds) => (0, collectionCreate_1.removeCollectionAction)(context.api, instanceIds)
        .then(() => collectionChanged.schedule())
        .catch(err => context.api.showErrorNotification('failed to remove mod from collection', err)), (instanceIds) => (0, collectionCreate_1.removeCollectionCondition)(context.api, instanceIds));
    context.registerAttributeExtractor(100, genAttributeExtractor(context.api));
    context.registerInstaller('collection', 5, (0, util_1.bbProm)(collectionInstall_1.testSupported), (0, util_1.bbProm)((0, collectionInstall_1.makeInstall)(context.api)));
    context['registerCollectionFeature'] =
        (id, generate, parse, clone, title, condition, editComponent) => {
            (0, extension_1.addExtension)({ id, generate, parse, clone, condition, title, editComponent });
        };
    context.registerActionCheck('ADD_NOTIFICATION', (state, action) => {
        var _a, _b, _c;
        const notification = action['payload'];
        const ruleMatches = rule => { var _a; return rule.reference.tag === ((_a = notification.replace) === null || _a === void 0 ? void 0 : _a.tag); };
        let collection;
        if (((driver === null || driver === void 0 ? void 0 : driver.collection) !== undefined) && notification.id.startsWith('multiple-plugins-')) {
            if (driver.profile !== undefined) {
                collection = (_b = (_a = state.persistent.mods[driver.profile.gameId]) === null || _a === void 0 ? void 0 : _a[driver.collection.id]) !== null && _b !== void 0 ? _b : driver.collection;
            }
            else {
                collection = driver.collection;
            }
        }
        if (((_c = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _c !== void 0 ? _c : []).find(ruleMatches) !== undefined) {
            return false;
        }
        return undefined;
    });
}
async function triggerVoteNotification(api, revisionId, collectionSlug, revisionNumber) {
    if ((collectionSlug === undefined) || (revisionNumber === undefined)) {
        return Promise.resolve();
    }
    const revInfo = await driver.infoCache.getRevisionInfo(revisionId, collectionSlug, revisionNumber);
    if (!revInfo) {
        return Promise.resolve();
    }
    const sendRating = async (success) => {
        const vote = success ? 'positive' : 'negative';
        const voted = (await api.emitAndAwait('rate-nexus-collection-revision', parseInt(revisionId, 10), vote))[0];
        if (voted.success) {
            api.store.dispatch((0, persistent_1.updateSuccessRate)(revisionId, vote, voted.averageRating.average, voted.averageRating.total));
        }
    };
    return new Promise((resolve, reject) => {
        api.sendNotification({
            type: 'info',
            message: revInfo.collection.name,
            title: 'Did the Collection work for you?',
            noDismiss: true,
            actions: [
                {
                    title: 'Yes',
                    action: dismiss => {
                        api.events.emit('analytics-track-click-event', 'Notifications', 'Success rating - Yes');
                        sendRating(true);
                        resolve();
                        dismiss();
                    },
                },
                {
                    title: 'No',
                    action: dismiss => {
                        api.events.emit('analytics-track-click-event', 'Notifications', 'Success rating - No');
                        sendRating(false);
                        resolve();
                        dismiss();
                    },
                },
                {
                    icon: 'close',
                    action: dismiss => {
                        api.events.emit('analytics-track-click-event', 'Notifications', 'Success rating - Dismiss');
                        resolve();
                        dismiss();
                    },
                },
            ],
        });
    });
}
async function checkVoteRequest(api) {
    var _a;
    let elapsed = 0;
    const state = api.getState();
    const pendingVotes = (_a = state.persistent['collections'].pendingVotes) !== null && _a !== void 0 ? _a : {};
    const now = Date.now();
    for (const revisionId of Object.keys(pendingVotes)) {
        const pendingInfo = pendingVotes[revisionId];
        if (now - pendingInfo.time >= constants_1.TIME_BEFORE_VOTE) {
            await triggerVoteNotification(api, revisionId, pendingInfo.collectionSlug, pendingInfo.revisionNumber);
            api.store.dispatch((0, persistent_1.clearPendingVote)(revisionId));
        }
        else {
            elapsed = Math.max(elapsed, now - pendingInfo.time);
        }
    }
    return constants_1.TIME_BEFORE_VOTE - elapsed;
}
function once(api, collectionsCB) {
    const { store } = api;
    const applyCollectionModDefaults = new vortex_api_1.util.Debouncer(() => {
        const gameMode = vortex_api_1.selectors.activeGameId(state());
        const mods = vortex_api_1.util.getSafe(state(), ['persistent', 'mods', gameMode], {});
        const collectionIds = Object.keys(mods).filter(id => { var _a; return (((_a = mods[id]) === null || _a === void 0 ? void 0 : _a.type) === constants_1.MOD_TYPE); });
        const redActions = collectionIds.reduce((accum, id) => {
            var _a;
            const collection = mods[id];
            if ((collection === undefined) || (collection.attributes['editable'] !== true)) {
                return accum;
            }
            const collMods = ((_a = collection.rules) !== null && _a !== void 0 ? _a : [])
                .map(rule => vortex_api_1.util.findModByRef(rule.reference, mods))
                .filter(rule => rule !== undefined);
            const action = (0, defaults_1.genDefaultsAction)(api, id, collMods, gameMode);
            if (action !== undefined) {
                accum.push(action);
            }
            return accum;
        }, []);
        if (redActions.length > 0) {
            vortex_api_1.util.batchDispatch(api.store, redActions);
        }
        return null;
    }, 1000);
    driver = new InstallDriver_1.default(api);
    driver.onUpdate(() => {
        if (driver.step === 'start') {
            driver.continue();
        }
        if (driver.step === 'review') {
            if (driver.collection === undefined)
                return;
            const gameId = driver.profile.gameId;
            const modId = driver.collection.id;
            api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modId, 'installCompleted', Date.now()));
        }
    });
    const doCheckVoteRequest = () => {
        checkVoteRequest(api)
            .then((nextCheck) => {
            setTimeout(doCheckVoteRequest, nextCheck);
        });
    };
    setTimeout(doCheckVoteRequest, constants_1.DELAY_FIRST_VOTE_REQUEST);
    api.setStylesheet('collections', path.join(__dirname, 'style.scss'));
    const state = () => store.getState();
    api.onStateChange(['persistent', 'mods'], (prev, cur) => {
        var _a, _b;
        const gameMode = vortex_api_1.selectors.activeGameId(api.getState());
        const prevG = (_a = prev[gameMode]) !== null && _a !== void 0 ? _a : {};
        const curG = (_b = cur[gameMode]) !== null && _b !== void 0 ? _b : {};
        const allIds = Array.from(new Set([].concat(Object.keys(prevG), Object.keys(curG))));
        const collections = allIds.filter(id => { var _a, _b; return (((_a = prevG[id]) === null || _a === void 0 ? void 0 : _a.type) === constants_1.MOD_TYPE) || (((_b = curG[id]) === null || _b === void 0 ? void 0 : _b.type) === constants_1.MOD_TYPE); });
        const changed = collections.find(modId => { var _a, _b, _c, _d; return (((_b = (_a = prevG[modId]) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.customFileName) !== ((_d = (_c = curG[modId]) === null || _c === void 0 ? void 0 : _c.attributes) === null || _d === void 0 ? void 0 : _d.customFileName)); });
        if (changed !== undefined) {
            collectionChangedCB === null || collectionChangedCB === void 0 ? void 0 : collectionChangedCB();
        }
        const foundRuleChanges = collections.find((id) => {
            var _a, _b, _c, _d, _e, _f;
            if (((_a = prevG[id]) === null || _a === void 0 ? void 0 : _a.rules) === ((_b = curG[id]) === null || _b === void 0 ? void 0 : _b.rules)) {
                return false;
            }
            const added = _.difference((_c = curG[id]) === null || _c === void 0 ? void 0 : _c.rules, (_d = prevG[id]) === null || _d === void 0 ? void 0 : _d.rules);
            const removed = _.difference((_e = prevG[id]) === null || _e === void 0 ? void 0 : _e.rules, (_f = curG[id]) === null || _f === void 0 ? void 0 : _f.rules);
            return (removed.length > 0) || (added.find(rule => ['requires', 'recommends'].includes(rule.type)) !== undefined);
        }) !== undefined;
        if (foundRuleChanges) {
            applyCollectionModDefaults.schedule();
            if (changed === undefined) {
                collectionChangedCB === null || collectionChangedCB === void 0 ? void 0 : collectionChangedCB();
            }
        }
    });
    api.events.on('did-dismiss-overlay', (overlayId, itemId) => {
        var _a, _b, _c;
        const OVERLAY_ID = 'collection-instructions-overlay';
        const state = api.getState();
        const { gameId } = (_a = driver.profile) !== null && _a !== void 0 ? _a : {};
        const mods = (_b = state.persistent.mods[gameId]) !== null && _b !== void 0 ? _b : {};
        if ((driver.lastCollection !== undefined)
            && (mods[driver.lastCollection.id] !== undefined)
            && (itemId !== undefined)
            && (state.settings.notifications.suppress[OVERLAY_ID] !== true)) {
            const collections = mods[driver.lastCollection.id];
            const match = ((_c = collections.rules) !== null && _c !== void 0 ? _c : [])
                .find(rule => (rule.type === 'requires') && (rule.reference.tag === itemId));
            if (match !== undefined) {
                api.showDialog('info', 'Mod instructions', {
                    text: 'You can refer back to closed mod instructions at any time in the Instructions tab on '
                        + 'the Collections page.',
                    checkboxes: [
                        { id: 'dont_show_again', value: false, text: 'Don\'t show again' },
                    ],
                }, [
                    { label: 'Take me to instructions' },
                    { label: 'Close' },
                ], OVERLAY_ID)
                    .then((result) => {
                    if (result.input['dont_show_again']) {
                        api.store.dispatch(vortex_api_1.actions.suppressNotification(OVERLAY_ID, true));
                    }
                    if (result.action === 'Take me to instructions') {
                        api.events.emit('show-main-page', 'Collections');
                        setTimeout(() => {
                            var _a, _b;
                            (_b = (_a = collectionsCB()).viewCollection) === null || _b === void 0 ? void 0 : _b.call(_a, driver.lastCollection.id);
                        }, 100);
                    }
                })
                    .catch(err => {
                    (0, vortex_api_1.log)('warn', 'failed to show mod instructions suppress dialog', { error: err.message });
                });
            }
        }
    });
    api.events.on('did-install-mod', async (gameId, archiveId, modId) => {
        var _a, _b, _c;
        const profileId = vortex_api_1.selectors.lastActiveProfileForGame(state(), gameId);
        const profile = vortex_api_1.selectors.profileById(state(), profileId);
        if (profile === undefined) {
            return;
        }
        const mod = vortex_api_1.util.getSafe(state().persistent.mods, [gameId, modId], undefined);
        if (mod === undefined) {
            return;
        }
        if (mod.type === constants_1.MOD_TYPE) {
            if (driver.collection === undefined) {
                const awaitProfileSwitch = (_b = (_a = api.ext) === null || _a === void 0 ? void 0 : _a.awaitProfileSwitch) !== null && _b !== void 0 ? _b : (() => Promise.resolve());
                await awaitProfileSwitch();
                driver.query(profile, mod);
            }
            else {
                api.sendNotification({
                    type: 'info',
                    message: 'Collection can\'t be installed as another one is being installed already',
                });
            }
        }
        else if (driver.collection !== undefined) {
            const { collection, revisionId } = driver;
            const isDependency = ((_c = collection === null || collection === void 0 ? void 0 : collection.rules) !== null && _c !== void 0 ? _c : []).find(rule => {
                const validType = ['requires', 'recommends'].includes(rule.type);
                if (!validType) {
                    return false;
                }
                const matchedRule = vortex_api_1.util.testModReference(mod, rule.reference);
                return matchedRule;
            }) !== undefined;
            if (isDependency) {
                const modRules = await driver.infoCache.getCollectionModRules(revisionId, collection, gameId);
                vortex_api_1.util.batchDispatch(api.store, (modRules !== null && modRules !== void 0 ? modRules : []).reduce((prev, rule) => {
                    if (vortex_api_1.util.testModReference(mod, rule.source)) {
                        prev.push(vortex_api_1.actions.addModRule(gameId, modId, {
                            type: rule.type,
                            reference: rule.reference,
                            extra: {
                                fromCollection: collection.id,
                            },
                        }));
                    }
                    return prev;
                }, []));
            }
        }
    });
    api.onAsync('will-remove-mods', makeWillRemoveMods());
    api.onAsync('did-remove-mods', makeDidRemoveMods());
    api.onAsync('unfulfilled-rules', makeOnUnfulfilledRules(api));
    api.events.on('collection-update', (0, eventHandlers_1.onCollectionUpdate)(api, driver));
    api.events.on('did-finish-download', (dlId, outcome) => {
        if (outcome === 'finished') {
            const download = state().persistent.downloads.files[dlId];
            if (download === undefined) {
                return;
            }
        }
    });
    api.events.on('did-download-collection', async (dlId) => {
        var _a, _b, _c;
        try {
            const dlInfo = vortex_api_1.util.getSafe(state().persistent.downloads.files, [dlId], undefined);
            const profile = vortex_api_1.selectors.activeProfile(state());
            if ((profile === undefined) || (dlInfo === undefined)) {
                return;
            }
            if (!dlInfo.game.includes(profile.gameId)) {
                (0, vortex_api_1.log)('info', 'Collection downloaded for a different game than is being managed', { gameMode: profile.gameId, game: dlInfo.game });
                const expectedGame = vortex_api_1.util.getGame(dlInfo.game[0]);
                const actualGame = vortex_api_1.util.getGame(profile.gameId);
                api.sendNotification({
                    message: '"{{collectionName}}" - This collection is intended for {{expectedGame}} '
                        + 'and cannot be installed to {{actualGame}}',
                    type: 'info',
                    replace: {
                        collectionName: (_b = (_a = dlInfo.modInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : dlInfo.localPath,
                        expectedGame: (_c = expectedGame === null || expectedGame === void 0 ? void 0 : expectedGame.name) !== null && _c !== void 0 ? _c : api.translate('an unsupported game'),
                        actualGame: actualGame.name,
                    },
                });
                return;
            }
            else {
                await vortex_api_1.util.toPromise(cb => api.events.emit('start-install-download', dlId, {
                    allowAutoEnable: false,
                }, cb));
            }
        }
        catch (err) {
            if (!(err instanceof vortex_api_1.util.UserCanceled)) {
                api.showErrorNotification('Failed to add collection', err, {
                    allowReport: !(err instanceof vortex_api_1.util.ProcessCanceled),
                });
            }
        }
    });
    api.events.on('view-collection', (modId, tabId) => {
        api.events.emit('show-main-page', 'Collections');
        setTimeout(() => {
            var _a, _b, _c, _d;
            (_b = (_a = collectionsCB()).viewCollection) === null || _b === void 0 ? void 0 : _b.call(_a, modId);
            (_d = (_c = collectionsCB()).viewCollectionTab) === null || _d === void 0 ? void 0 : _d.call(_c, tabId);
        }, 100);
    });
    api.events.on('edit-collection', (modId) => {
        api.events.emit('show-main-page', 'Collections');
        setTimeout(() => {
            var _a, _b;
            (_b = (_a = collectionsCB()).editCollection) === null || _b === void 0 ? void 0 : _b.call(_a, modId);
        }, 100);
    });
    api.events.on('resume-collection', (gameId, modId) => {
        var _a;
        const state = api.getState();
        const profileId = vortex_api_1.selectors.lastActiveProfileForGame(state, gameId);
        const profile = state.persistent.profiles[profileId];
        const mod = (_a = state.persistent.mods[gameId]) === null || _a === void 0 ? void 0 : _a[modId];
        (0, vortex_api_1.log)('info', 'resume collection', { gameId, modId, archiveId: mod === null || mod === void 0 ? void 0 : mod.archiveId });
        driver.start(profile, mod);
    });
    api.onStateChange(['persistent', 'collections', 'collections'], (prev, cur) => {
        const state = api.getState();
        const changedIds = Object.keys(cur).filter(id => { var _a; return cur[id].info !== ((_a = prev[id]) === null || _a === void 0 ? void 0 : _a.info); });
        const knownGames = vortex_api_1.selectors.knownGames(state);
        const { mods } = state.persistent;
        changedIds.forEach(collId => {
            const coll = cur[collId].info;
            const gameId = vortex_api_1.util.convertGameIdReverse(knownGames, coll.game.domainName);
            const collModId = Object.keys(mods[gameId])
                .find(modId => mods[gameId][modId].attributes['collectionId'] === coll.id);
            if ((collModId !== undefined) && !mods[gameId][collModId].attributes.editable) {
                const newestVersion = coll.revisions
                    .filter(rev => rev.revisionStatus === 'published')
                    .sort((lhs, rhs) => rhs.revisionNumber - lhs.revisionNumber);
                if (newestVersion.length > 0) {
                    api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, collModId, 'newestVersion', newestVersion[0].revisionNumber.toString()));
                }
            }
        });
    });
    vortex_api_1.util.installIconSet('collections', path.join(__dirname, 'icons.svg'))
        .catch(err => api.showErrorNotification('failed to install icon set', err));
    const iconPath = path.join(__dirname, 'collectionicon.svg');
    document.getElementById('content').style
        .setProperty('--collection-icon', `url(${(0, url_1.pathToFileURL)(iconPath).href})`);
    const updateOwnCollectionsCB = (gameId) => api.emitAndAwait('get-my-collections', gameId)
        .then(result => {
        var _a;
        localState.ownCollections = (_a = result[0]) !== null && _a !== void 0 ? _a : [];
    });
    api.events.on('gamemode-activated', updateOwnCollectionsCB);
    api.onStateChange(['persistent', 'nexus', 'userInfo'], (prev, cur) => {
        const gameMode = vortex_api_1.selectors.activeGameId(api.getState());
        updateOwnCollectionsCB(gameMode);
    });
    driver.infoCache.clearCache();
}
const pathTool = {
    relative: path.relative,
};
function init(context) {
    const collectionsCB = {};
    register(context, collectionsCB);
    (0, initweaks_1.default)(context);
    (0, tools_1.default)(context);
    context.once(() => {
        once(context.api, () => collectionsCB);
    });
    return true;
}
exports["default"] = init;

})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=bundledPlugins/collections/modpacks.js.map